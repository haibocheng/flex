<?xml version="1.0"?>
<apiPackage id="__Global__"><apiName>__Global__</apiName><apiDetail/><apiClassifier id="globalClassifier:VerifyError"><apiName>VerifyError</apiName><shortdesc>
 Die VerifyError-Klasse repräsentiert einen Fehler, der auftritt, wenn eine SWF-Datei angetroffen wird, die ungültig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Ein VerifyError-Fehler wird ausgelöst, wenn eine ungültige oder beschädigte SWF-Datei angetroffen wird.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die VerifyError-Klasse repräsentiert einen Fehler, der auftritt, wenn eine SWF-Datei angetroffen wird, die ungültig ist. 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>Loader-Klasse</linktext></link></related-links><apiConstructor id="VerifyError:VerifyError"><apiName>VerifyError</apiName><shortdesc>
	 Erstellt ein neues VerifyError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Enthält die mit dem VerifyError-Objekt verknüpfte Meldung.      
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues VerifyError-Objekt.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
 Die ArgumentError-Klasse repräsentiert einen Fehler, der auftritt, wenn die in einer Funktion angegebenen Argumente nicht den für diese Funktion definierten Argumenten entsprechen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Ein ArgumentError-Fehler wird ausgelöst, wenn die bei einem Funktionsaufruf bereitgestellten Parameterwerte nicht den Parametern entsprechen, die für diese Funktion definiert wurden.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die ArgumentError-Klasse repräsentiert einen Fehler, der auftritt, wenn die in einer Funktion angegebenen Argumente nicht den für diese Funktion definierten Argumenten entsprechen. Dieser Fehler tritt beispielsweise auf, wenn eine Funktion mit der falschen Anzahl an Argumenten, einem Argument mit falschem Datentyp oder ein unzulässiges Argument aufgerufen wird.
 
 </apiDesc><example conref="examples\ArgumentErrorExample.as"> Dieses Beispiel veranschaulicht, wie ein <codeph>RangeError</codeph>-Fehler erzeugt und in einer<codeph>try..catch</codeph>-Anweisung verarbeitet wird. Die Funktion <codeph>println()</codeph> nimmt als Argument einen String entgegen; da aber zwei Strings bereitgestellt werden, wird der Fehler ausgelöst. In der Regel würde der Compiler einen solchen Fehler erfassen, aufgrund der <codeph>this[]</codeph>-Syntax in der <codeph>try</codeph>-Anweisung wird jedoch die Compilersyntax, mit der auf diese Funktion geprüft wird, umgangen.
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentErrorExample extends Sprite {
        public function ArgumentErrorExample() {
                println("Hello World");
                
                try {
                    this["println"]("Hello", "World");
                }
                catch(e:ArgumentError) {
                    trace(e);
                }
        }
        
        public function println(str:String):void {
            trace(str);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="ArgumentError:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
	 Erstellt ein neues ArgumentError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Ein String, der mit dem Fehler verknüpft ist.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues ArgumentError-Objekt.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:QName"><apiName>QName</apiName><shortdesc>

QName-Objekte repräsentieren qualifizierte Namen von XML-Elementen und -Attributen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>QName
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

QName-Objekte repräsentieren qualifizierte Namen von XML-Elementen und -Attributen. Jedes QName-Objekt besitzt einen lokalen Namen und einen Namespace-URI (Uniform Resource Identifier, einheitlichen Ressourcenbezeichner). Ist der Wert des Namespace-URI <codeph>null</codeph>, entspricht das QName-Objekt einem beliebigen Namespace. Verwenden Sie den QName-Konstruktor, um ein neues QName-Objekt zu erstellen, bei dem es sich entweder um eine Kopie eines anderen QName-Objekts handelt oder um ein neues QName-Objekt mit dem <codeph>uri</codeph> eines Namespace-Objekts und dem <codeph>localName</codeph> eines QName-Objekts. 
 

<p>E4X-spezifische Methoden können QName-Objekte anstelle von Strings verwenden. E4X-Methoden sind in den Klassen QName, Namespace, XML und XMLList zu finden. Diese E4X-Methoden, die einen String akzeptieren, können stattdessen auch ein QName-Objekt annehmen. Durch diese Austauschbarkeit ist es möglich, dass die Namespace-Unterstützung beispielsweise mit der Methode <codeph>XML.child()</codeph> funktioniert. </p>

<p>Die QName-Klasse implementiert (zusammen mit den Klassen XML, XMLList und Namespace) leistungsstarke Standards zur XML-Verarbeitung, die in der Spezifikation ECMA-357, Edition 2: „ECMAScript for XML (E4X)“ definiert sind.</p>

<p>Wenn ein qualifizierter Bezeichner ausgewertet wird, ergibt sich ein QName-Objekt. Wird das QName-Objekt eines XML-Elements angegeben ohne einen Namespace zu identifizieren, wird die <codeph>uri</codeph>-Eigenschaft des verknüpften QName-Objekts auf den globalen Standardnamespace gesetzt. Wird das QName-Objekt eines XML-Attributs angegeben ohne einen Namespace zu identifizieren, wird die <codeph>uri</codeph>-Eigenschaft auf einen leeren String gesetzt.</p>

</apiDesc><example conref="examples\QNameExample.as"> Im folgenden Beispiel sehen Sie, wie eine QName-Instanz erstellt und damit XML-Elemente ausgewählt werden. Es werden zwei Möglichkeiten zum Erstellen einer QName-Instanz gezeigt:
 <ol>
    <li>Erstellen Sie eine Namespace-Instanz, und übergeben Sie sie dann an den QName-Konstruktor. Dieser Ansatz ist zu empfehlen, wenn Sie die <codeph>Namespace.prefix</codeph>-Eigenschaft später für andere Zwecke verwenden möchten.</li>
  <li>Erstellen Sie eine QName-Instanz und verwenden Sie einen einfachen Stringwert für den <codeph>uri</codeph>-Parameter im QName-Konstruktor.</li>
 </ol>
 <p>
 Dieser Code bewirkt Folgendes:
 </p>
 <ol>
  <li>Definiert eine XML-Variable namens <codeph>rssXML</codeph>.</li>
    <li>Erstellt ein neues Namespace-Objekt mit dem Präfix <codeph>dc</codeph>.</li>
  <li>Erstellt ein neues QName-Objekt mithilfe des Namespace-Objekts und dem lokalen Namen <codeph>creator</codeph>.</li>
  <li>Ruft die <codeph>showDescendants()</codeph>-Methode auf, die mithilfe der <codeph>XML.descendants()</codeph>-Methode eine XMLList-Instanz abruft. Diese Instanz enthält alle untergeordneten Elemente, deren qualifizierte Namen mit der gegebenen QName-Instanz übereinstimmen.</li>
    <li>Zeigt den qualifizierten Namen und den Textwert jedes aufgelisteten Elements mithilfe einer <codeph>for each</codeph>-Schleife an.</li>
  <li>Erstellt ein weiteres QName-Objekt und verwendet einen Stringwert für den Parameter <codeph>uri</codeph> sowie den lokalen Namen <codeph>date</codeph>.</li>
  <li>Ruft die <codeph>showDescendants()</codeph>-Methode erneut auf, um den Namen und den Textwert der untergeordneten Elemente anzuzeigen.</li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    
    public class QNameExample extends Sprite
    {
        public function QNameExample()
        {
            var rssXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/">
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            var dcNamespace:Namespace = new Namespace("dc", "http://purl.org/dc/elements/1.1/");
            var creatorQName:QName = new QName(dcNamespace, "creator");
            trace(creatorQName.uri); // http://purl.org/dc/elements/1.1/
            trace(creatorQName.localName); // creator
            
            showDescendants(rssXML, creatorQName);
            
            var dateQName:QName = new QName("http://purl.org/dc/elements/1.1/", "date");
            trace(dateQName.uri); // http://purl.org/dc/elements/1.1/
            trace(dateQName.localName); // date
            
            showDescendants(rssXML, dateQName);
        }
        
        public function showDescendants(xmlData:XML, qualifiedName:QName):void
        {
            var decendantList:XMLList = xmlData.descendants(qualifiedName);
            
            for each (var element:XML in decendantList)
            {
                trace(element.name()); // the fully qualified name, 
                                       // like "http://purl.org/dc/elements/1.1/::creator"
                trace(element); // the simple text value of each element, like "Adobe"
            }                
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Spezifikation ECMA-357, Edition 2: „ECMAScript for XML (E4X)“</linktext></link></related-links><apiConstructor id="QName:QName_0"><apiName>QName</apiName><shortdesc> 
    Erstellt ein QName-Objekt mit einem URI-Objekt aus einem Namespace-Objekt und localName aus einem QName-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName
    </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Ein Namespace-Objekt, aus dem der <codeph>uri</codeph>-Wert zu kopieren ist. Parameter aller anderen Typen werden in einen String konvertiert.
    </apiDesc></apiParam><apiParam><apiItemName>localName</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>Ein QName-Objekt, aus dem der <codeph>localName</codeph>-Wert zu kopieren ist. Parameter aller anderen Typen werden in einen String konvertiert.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    Erstellt ein QName-Objekt mit einem URI-Objekt aus einem Namespace-Objekt und <codeph>localName</codeph> aus einem QName-Objekt. Hat einer der Parameter nicht den erwarteten Datentyp, wird er in einen String konvertiert und der entsprechenden Eigenschaft des neuen QName-Objekts zugewiesen. Handelt es sich beispielsweise bei beiden Parametern um Strings, wird ein neues QName-Objekt zurückgegeben, dessen <codeph>uri</codeph>-Eigenschaft auf den ersten Parameter gesetzt ist und dessen <codeph>localName</codeph>-Eigenschaft auf den zweiten Parameter gesetzt ist. Anders ausgedrückt: Die folgenden Permutationen sind, neben vielen anderen, zulässige Formen des Konstruktors:
<pre>
QName (uri:Namespace, localName:String);
QName (uri:String, localName: QName);
QName (uri:String, localName: String);
</pre>
    <p>Wenn Sie den Wert <codeph>null</codeph> an den <codeph>uri</codeph>-Parameter übergeben, wird die <codeph>uri</codeph>-Eigenschaft des neuen QName-Objekts auf <codeph>null</codeph> gesetzt.
    </p>
    <p><b>Hinweis:</b> Diese Klasse zeigt zwei Konstruktoreinträge, da jede Form andere Parameter akzeptiert. Der Konstruktor verhält sich unterschiedlich, je nach Typ und Anzahl der übergebenen Parameter, wie sie in den einzelnen Einträgen beschrieben sind. Überladene Methoden oder Konstruktoren werden von ActionSript 3.0 nicht unterstützt.</p>
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="QName:QName_1"><apiName>QName</apiName><shortdesc> 
    Erstellt ein QName-Objekt, das eine Kopie eines anderen QName-Objekts ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>(pdehaan) i changed first param from "name" to "uri" as the previous naming was very confusing
    </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>qname</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>Das zu kopierende QName-Objekt. Objekte eines anderen Typs werden in einen String konvertiert, der dann der <codeph>localName</codeph>-Eigenschaft des neuen QName-Objekts zugewiesen wird.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    Erstellt ein QName-Objekt, das eine Kopie eines anderen QName-Objekts ist. Wenn der an den Konstruktor übergebene Parameter ein QName-Objekt ist, wird eine Kopie des QName-Objekts erstellt. Handelt es sich bei dem Parameter aber nicht um ein QName-Objekt, wird der Parameter in einen String konvertiert und der <codeph>localName</codeph>-Eigenschaft der neuen QName-Instanz zugewiesen. Ist der Parameter <codeph>undefined</codeph> oder wurde er gar nicht angegeben, wird ein neues QName-Objekt erstellt, wobei die <codeph>localName</codeph>-Eigenschaft auf einen leeren String gesetzt ist.
    <p><b>Hinweis:</b> Diese Klasse zeigt zwei Konstruktoreinträge, da jede Form andere Parameter akzeptiert. Der Konstruktor verhält sich unterschiedlich, je nach Typ und Anzahl der übergebenen Parameter, wie sie in den einzelnen Einträgen beschrieben sind. Überladene Methoden oder Konstruktoren werden von ActionSript 3.0 nicht unterstützt.</p>
    
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="QName:AS3:toString"><apiName>toString</apiName><shortdesc>
	Gibt einen String zurück, der sich aus dem URI und dem lokalen Namen für das QName-Objekt zusammensetzt, wobei die beiden durch „::“ voneinander getrennt sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der qualifizierte Name als String.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt einen String zurück, der sich aus dem URI und dem lokalen Namen für das QName-Objekt zusammensetzt, wobei die beiden durch „::“ voneinander getrennt sind.
	
	<p>Das Format hängt von der <codeph>uri</codeph>-Eigenschaft des QName-Objekts ab:</p>
	<pre>If <codeph>uri</codeph> == "" 
		<codeph>toString</codeph> returns <codeph>localName</codeph>
	else if <codeph>uri</codeph> == null
		<codeph>toString</codeph> returns ~~::<codeph>localName</codeph> 
	else
		<codeph>toString</codeph> returns <codeph>uri</codeph>::<codeph>localName</codeph></pre>
	
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="QName:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    Gibt das QName-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Grundwert einer QName-Instanz.
    
    </apiDesc><apiOperationClassifier>QName</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Gibt das QName-Objekt zurück.
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="QName:localName:get"><apiName>localName</apiName><shortdesc>
	Der lokale Name des QName-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.localName, localName
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Der lokale Name des QName-Objekts.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="QName:uri:get"><apiName>uri</apiName><shortdesc>
	Der URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner) des QName-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Der URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner) des QName-Objekts.
 	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:EvalError"><apiName>EvalError</apiName><shortdesc>
 Die EvalError-Klasse repräsentiert einen Fehler, der auftritt, wenn der Benutzercode die Funktion eval() aufruft oder versucht, den new-Operator mit dem Function-Objekt aufzurufen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Ein EvalError-Fehler wird ausgelöst, wenn der Code versucht, die Methode eval() aufzurufen oder „new“ mit dem Function-Objekt zu verwenden.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die EvalError-Klasse repräsentiert einen Fehler, der auftritt, wenn der Benutzercode die Funktion <codeph>eval()</codeph> aufruft oder versucht, den Operator <codeph>new</codeph> mit dem Function-Objekt aufzurufen. Es wird nicht unterstützt, <codeph>eval()</codeph> und <codeph>new</codeph> mit dem Function-Objekt aufzurufen.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="EvalError:EvalError"><apiName>EvalError</apiName><shortdesc>
	 Erstellt ein neues EvalError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Ein String, der mit dem Fehler verknüpft ist.     
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues EvalError-Objekt.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Math"><apiName>Math</apiName><shortdesc>
 Die Math-Klasse umfasst Methoden und Konstanten, die allgemeine mathematische Funktionen und Werte repräsentieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math, math object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Bei der Math-Klasse handelt es sich um eine Klasse der obersten Ebene; sie besteht aus statischen Eigenschaften und Methoden, die allgemeine mathematische Konstanten und Funktionen definieren.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Math-Klasse umfasst Methoden und Konstanten, die allgemeine mathematische Funktionen und Werte repräsentieren. 
 <p>Verwenden Sie die Methoden und Eigenschaften dieser Klasse, um auf mathematische Konstanten und Funktionen zuzugreifen und diese zu bearbeiten. Alle Eigenschaften und Methoden der Math-Klasse sind statisch und müssen mit der Syntax <codeph>Math.method(</codeph><codeph><i>parameter</i></codeph><codeph>)</codeph> oder <codeph>Math.constant</codeph> aufgerufen werden. In ActionScript sind Konstanten mit der maximalen Genauigkeit doppelt genauer Gleitkommazahlen nach IEEE-754 definiert.</p>
 <p>Verschiedene Methoden der Math-Klasse verwenden als Parameter den Bogenmaßwert eines Winkels. Sie können die unten stehende Gleichung zur Berechnung von Bogenmaßwerten verwenden und den berechneten Wert als Parameter bereitstellen, oder Sie können die gesamte rechte Seite der Gleichung (bei der der Winkel in Bogenmaß anstelle von <codeph>degrees</codeph> angegeben ist) als Parameter für das Bogenmaß bereitstellen.</p>
 <p>Bogenmaßwerte lassen sich wie folgt berechnen:</p>
 <pre>
 radians = degrees ~~ Math.PI/180
 </pre>
 <p>Um aus einem Bogenmaßwert die Gradzahl zu berechnen, verwenden Sie die folgende Formel:</p>
 <pre>
 degrees = radians ~~ 180/Math.PI
 </pre>
 <p>Im folgenden Beispiel wird die Gleichung als Parameter zum Berechnen des Sinus eines 45-Grad-Winkels übergeben:</p>
 <p><codeph>Math.sin(45 ~~ Math.PI/180)</codeph> ist identisch mit <codeph>Math.sin(.7854)</codeph></p>
 <p><b>Hinweis:</b> Die Math-Funktionen acos, asin, atan, atan2, cos, exp, log, pow, sin und sqrt können je nach Algorithmus, den die CPU oder das Betriebssystem verwendet, zu leicht abweichenden Ergebnissen führen. Flash Player nutzt die CPU (oder das Betriebssystem, falls die CPU keine Gleitkommaberechnungen unterstützt), wenn Berechnungen für die aufgezählten Funktionen durchzuführen sind, und die Ergebnisse haben je nach verwendeter CPU bzw. verwendetem Betriebssystem leichte Abweichungen aufgezeigt.
 </p>
 
 
 </apiDesc></apiClassifierDetail><apiOperation id="Math:abs"><apiName>abs</apiName><shortdesc>
  Berechnet einen absoluten Wert für die im Parameter „val“ angegebene Zahl und gibt diesen zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.abs, abs, absolute
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der absolute Wert des angegebenen Parameters.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Zahl, deren absoluter Wert zurückgegeben wird.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den absolute Wert der angegebenen Zahl zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet einen absoluten Wert für die im Parameter <codeph>val</codeph> angegebene Zahl und gibt diesen zurück.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:acos"><apiName>acos</apiName><shortdesc>
  Berechnet den Arkuskosinus für die im Parameter „val“ angegebene Zahl und gibt diesen in Bogenmaß zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.acos, acos, arc cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der Arkuskosinus des Parameters <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl zwischen -1,0 und 1,0.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Arkuskosinus der angegebenen Zahl in Bogenmaß zurück. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet den Arkuskosinus für die im Parameter <codeph>val</codeph> angegebene Zahl und gibt diesen in Bogenmaß zurück.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:asin"><apiName>asin</apiName><shortdesc>
  Berechnet den Arkussinus für die im Parameter „val“ angegebene Zahl und gibt diesen in Bogenmaß zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.asin, asin, arc sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Zahl zwischen negativ Pi dividiert durch 2 und positiv Pi dividiert durch 2.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl zwischen -1,0 und 1,0.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Wert des Arkussinus des angegebenen Number-Parameters in Bogenmaß zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet den Arkussinus für die im Parameter <codeph>val</codeph> angegebene Zahl und gibt diesen in Bogenmaß zurück.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan"><apiName>atan</apiName><shortdesc>
  Berechnet in Bogenmaß den Wert des Winkels, dessen Tangens durch den Parameter „val“ festgelegt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan, atan, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Zahl zwischen negativ Pi dividiert durch 2 und positiv Pi dividiert durch 2.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die den Tangens eines Winkels angibt.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Winkel, dessen Tangens durch den Parameter „val“ angegeben ist, in Bogenmaß zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet den Wert des Winkels, dessen Tangens durch den Parameter <codeph>val</codeph> festgelegt ist, in Bogenmaß. Der Rückgabewert liegt zwischen negativ Pi dividiert durch 2 und positiv Pi dividiert durch 2.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan2"><apiName>atan2</apiName><shortdesc>
  Berechnet den Winkel des Punktes „y/x“ in Bogenmaß, gegen den Uhrzeigersinn von der x-Achse eines Kreises aus gemessen (mit 0,0 als Mittelpunkt des Kreises).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan2, atan2, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Zahl.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>y</i>-Koordinate des Punkts.
  </apiDesc></apiParam><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>x</i>-Koordinate des Punkts.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Winkel des Punktes „y/x“ in Bogenmaß zurück, von der x-Achse eines Kreises aus gegen den Uhrzeigersinn gemessen.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet den Winkel des Punktes <codeph>y</codeph>/<codeph>x</codeph> in Bogenmaß, von der <i>x</i>-Achse eines Kreises aus gegen den Uhrzeigersinn gemessen (mit 0,0 als Mittelpunkt des Kreises). Der Rückgabewert liegt zwischen positiv Pi und negativ Pi. Der erste Parameter von atan2 ist immer die <i>y</i>-Koordinate.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:ceil"><apiName>ceil</apiName><shortdesc>
  Gibt die Obergrenze der angegebenen Zahl bzw. des angegebenen Ausdrucks zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ceil, ceil, ceiling
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Die Ganzzahl, die dem Parameter <codeph>val</codeph> am Nächsten liegt und gleichzeitig größer oder gleich diesem Parameter ist.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Obergrenze der angegebenen Zahl bzw. des angegebenen Ausdrucks zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Gibt die Obergrenze der angegebenen Zahl bzw. des angegebenen Ausdrucks zurück. Die Obergrenze einer Zahl ist die nächstliegende Ganzzahl, die größer oder gleich der Zahl ist.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/floor()"><linktext>Math.floor()</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="Math:cos"><apiName>cos</apiName><shortdesc>
  Berechnet den Kosinus des angegebenen Winkels und gibt den Wert in Bogenmaß zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.cos, cos, cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Zahl zwischen -1,0 und 1,0.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die einen Winkel in Bogenmaß angibt. 
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Kosinus des angegebenen Winkels zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet den Kosinus des angegebenen Winkels und gibt den Wert in Bogenmaß zurück. Informationen zum Berechnen eines Bogenmaßes finden Sie in der Einführung zur Math-Klasse.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:exp"><apiName>exp</apiName><shortdesc>
  Gibt den Wert der Basis des natürlichen Logarithmus (e) potenziert mit dem im Parameter „x“ angegebenen Exponenten zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.exp, exp, exponent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc><i>e</i> hoch <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Exponent. Eine Zahl oder ein Ausdruck.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Wert der Basis des natürlichen Logarithmus (e) potenziert mit dem im Parameter „val“ angegebenen Exponenten zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Gibt den Wert der Basis des natürlichen Logarithmus (<i>e</i>) potenziert mit dem im Parameter <codeph>x</codeph> angegebenen Exponenten zurück. Die Konstante <codeph>Math.E</codeph> kann den Wert von <i>e</i> liefern.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/E"><linktext>Math.E</linktext></link></related-links></apiOperation><apiOperation id="Math:floor"><apiName>floor</apiName><shortdesc>
  Gibt die Untergrenze der Zahl oder des Ausdrucks zurück, die bzw. der im Parameter „val“ angegeben ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.floor, floor
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Die Ganzzahl, die dem Parameter <codeph>val</codeph> am Nächsten liegt und gleichzeitig kleiner oder gleich diesem Parameter ist.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Untergrenze der Zahl oder des Ausdrucks zurück, die bzw. der im Parameter „val“ angegeben ist.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Gibt die Untergrenze der Zahl oder des Ausdrucks zurück, die bzw. der im Parameter <codeph>val</codeph> angegeben ist. Die Untergrenze einer Zahl ist die nächstliegende Ganzzahl, die kleiner oder gleich der angegebenen Zahl bzw. dem angegebenen Ausdruck ist.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:log"><apiName>log</apiName><shortdesc>
  Gibt den natürlichen Logarithmus des Parameters „val“ zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log, log, logarithm
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der natürliche Logarithmus des Parameters <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck mit einem Wert größer als 0.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Logarithmus des Parameters „val“ zurück. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Gibt den natürlichen Logarithmus des Parameters <codeph>val</codeph> zurück.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:max"><apiName>max</apiName><shortdesc>
  Wertet „val1“ und „val2“ (oder auch weitere Werte) aus und gibt den größten Wert zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.max, max, maximum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der größte Wert der Parameter <codeph>val1</codeph> und <codeph>val2</codeph> (und gegebenenfalls weiterere Werte).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck.
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck.
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Eine Zahl oder ein Ausdruck. <codeph>Math.max()</codeph> kann mehrere Argumente akzeptieren.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Wertet die Parameter „val1“ und „val2“ aus und gibt den größeren Wert zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Wertet <codeph>val1</codeph> und <codeph>val2</codeph> (oder auch weitere Werte) aus und gibt den größten Wert zurück.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/min()"><linktext>Math.min()</linktext></link></related-links></apiOperation><apiOperation id="Math:min"><apiName>min</apiName><shortdesc>
  Wertet „val1“ und „val2“ (oder auch weitere Werte) aus und gibt den kleinsten Wert zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.min, min, minimum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der kleinste Wert der Parameter <codeph>val1</codeph> und <codeph>val2</codeph> (und gegebenenfalls weiterere Werte).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck.
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck.
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Eine Zahl oder ein Ausdruck. <codeph>Math.min()</codeph> kann mehrere Argumente akzeptieren.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Wertet die Parameter „val1“ und „val2“ aus und gibt den kleineren Wert zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Wertet <codeph>val1</codeph> und <codeph>val2</codeph> (oder auch weitere Werte) aus und gibt den kleinsten Wert zurück.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/max()"><linktext>Math.max()</linktext></link></related-links></apiOperation><apiOperation id="Math:pow"><apiName>pow</apiName><shortdesc>
  Berechnet und gibt „base“ hoch „pow“ zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pow, pow, power
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der Wert von <codeph>base </codeph> erhöht auf die Potenz von <codeph>pow</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>base</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die mit dem Parameter <codeph>pow</codeph> potenziert werden soll.
  </apiDesc></apiParam><apiParam><apiItemName>pow</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die angibt, mit welchem Exponenten der Parameter <codeph>base</codeph> potenziert wird.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Wert von „val1“ hoch „val2“ zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet und gibt den Wert <codeph>base</codeph> hoch <codeph>pow</codeph> zurück.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:random"><apiName>random</apiName><shortdesc>
  Gibt eine Pseudozufallszahl n zurück, wobei 0 &amp;lt;= n &amp;lt; 1.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.random, random
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Pseudozufallszahl.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt eine Pseudozufallszahl n zurück, wobei 0 &lt;= n &lt; 1.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Gibt eine Pseudozufallszahl n zurück, wobei 0 &lt;= n &lt; 1. Wie die zurückgegebene Zahl berechnet wird, wird nicht bekannt gegeben. Man spricht von einer „Pseudo“-Zufallszahl, da es unvermeidlich ist, dass die Berechnung einige nicht-zufällige Elemente enthält.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:round"><apiName>round</apiName><shortdesc>
  Rundet den Wert des Parameters „val“ auf die nächstliegende Ganzzahl auf oder ab und gibt diese zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.round, round
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der auf die nächste Ganzzahl gerundete Parameter <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Zahl, die gerundet werden soll.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Wert des auf die nächste Ganzzahl auf- bzw. abgerundeten Parameters „val“ zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Rundet den Wert des Parameters <codeph>val</codeph> auf die nächstliegende Ganzzahl auf oder ab und gibt diese zurück. Hat <codeph>val</codeph> den gleichen Abstand von den beiden nächstliegenden Ganzzahlen (z. B. Zahlen die mit .5 enden), wird der Wert auf die nächsthöhere Ganzzahl aufgerundet.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/ceil()"><linktext>Math.ceil()</linktext></link><link href="#Math/floor()"><linktext>Math.floor()</linktext></link></related-links></apiOperation><apiOperation id="Math:sin"><apiName>sin</apiName><shortdesc>
  Berechnet den Sinus des angegebenen Winkels und gibt den Wert in Bogenmaß zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sin, sin, sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Ein Zahl, der Sinus des angegebenen Winkels (zwischen -1,0 und 1,0).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die einen Winkel in Bogenmaß angibt.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Sinus des angegebenen Winkels zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet den Sinus des angegebenen Winkels und gibt den Wert in Bogenmaß zurück. Informationen zum Berechnen eines Bogenmaßes finden Sie in der Einführung zur Math-Klasse.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:sqrt"><apiName>sqrt</apiName><shortdesc>
  Berechnet die Quadratwurzel der angegebenen Zahl und gibt diese zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt, sqrt, square root 
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Zahl, wenn der Parameter <codeph>val</codeph> größer oder gleich Null ist; andernfalls <codeph>NaN</codeph> (Not a Number &amp;#2013; keine Zahl).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl oder ein Ausdruck größer oder gleich 0. 
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Quadratwurzel der angegebenen Zahl zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet die Quadratwurzel der angegebenen Zahl und gibt diese zurück.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:tan"><apiName>tan</apiName><shortdesc>
  Berechnet den Tangens des angegebenen Winkels und gibt diesen zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.tan, tan, tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der Tangens des Parameters <codeph>angleRadians</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die einen Winkel in Bogenmaß angibt.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den Tangens des angegebenen Winkels zurück.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Berechnet den Tangens des angegebenen Winkels und gibt diesen zurück. Informationen zum Berechnen eines Bogenmaßes finden Sie in der Einführung zur Math-Klasse.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link></related-links></apiOperation><apiValue id="Math:E"><apiName>E</apiName><shortdesc>
  Eine mathematische Konstante für die Basis des natürlichen Logarithmus, ausgedrückt als „e“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.e, e
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.71828182845905</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für die Basis des natürlichen Logarithmus, ausgedrückt als „e“.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Eine mathematische Konstante für die Basis des natürlichen Logarithmus, ausgedrückt als <i>e</i>. Der ungefähre Wert von <i>e</i><codeph> </codeph>ist 2,71828182845905.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN10"><apiName>LN10</apiName><shortdesc>
  Eine mathematische Konstante für den natürlichen Logarithmus von 10, der als „loge10“ ausgedrückt wird und den Näherungswert 2,302585092994046 aufweist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln10, ln10, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.302585092994046</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für den natürlichen Logarithmus von 10, der als „loge10“ ausgedrückt wird und den Näherungswert 2,302585092994046 aufweist.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Eine mathematische Konstante für den natürlichen Logarithmus von 10, der als log<sub>e</sub>10 ausgedrückt wird und den Näherungswert 2,302585092994046 aufweist.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN2"><apiName>LN2</apiName><shortdesc>
  Eine mathematische Konstante für den natürlichen Logarithmus von 2, der als „loge2“ ausgedrückt wird und den Näherungswert 0,6931471805599453 aufweist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln2, ln2, natural logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.6931471805599453</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für den natürlichen Logarithmus von 2, der als „loge2“ ausgedrückt wird und den Näherungswert 0,6931471805599453 aufweist.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Eine mathematische Konstante für den natürlichen Logarithmus von 2, der als log<sub>e</sub>2 ausgedrückt wird und den Näherungswert 0,6931471805599453 aufweist.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG10E"><apiName>LOG10E</apiName><shortdesc>
  Eine mathematische Konstante für den Logarithmus zur Basis 10 der Konstante e (Math.E), der als „log10e“ ausgedrückt wird und den Näherungswert 0,4342944819032518 aufweist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log10e, log10e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.4342944819032518</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für den Zehnerlogarithmus der Konstante e, der als „log10e“ ausgedrückt wird und den Näherungswert 0,4342944819032518 aufweist.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Eine mathematische Konstante für den Zehnerlogarithmus der Konstante <i>e</i> (<codeph>Math.E</codeph>), der als log<sub>10</sub>e ausgedrückt wird und den Näherungswert 0,4342944819032518 aufweist. 
  <p>Die <codeph>Math.log()</codeph>-Methode berechnet den natürlichen Logarithmus einer Zahl. Den Zehnerlogarithmus erhalten Sie, indem Sie das Ergebnis von <codeph>Math.log()</codeph> mit <codeph>Math.LOG10E</codeph> multiplizieren.</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG2E"><apiName>LOG2E</apiName><shortdesc>
  Eine mathematische Konstante für den Zweierlogarithmus der Konstante e, der als „log2e“ ausgedrückt wird und den Näherungswert 1,442695040888963387 aufweist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log2e, log2e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.442695040888963387</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für den Zweierlogarithmus der Konstante e, der als „log2e“ ausgedrückt wird und den Näherungswert 1,442695040888963387 aufweist.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Eine mathematische Konstante für den Zweierlogarithmus der Konstante <i>e</i>, der als „log2e“ ausgedrückt wird und den Näherungswert 1,442695040888963387 aufweist.
  
  <p>Die <codeph>Math.log</codeph>-Methode berechnet den natürlichen Logarithmus einer Zahl. Den Zweierlogarithmus erhalten Sie, indem Sie das Ergebnis von <codeph>Math.log()</codeph> mit <codeph>Math.LOG2E</codeph> multiplizieren.</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:PI"><apiName>PI</apiName><shortdesc>
  Eine mathematische Konstante für das Verhältnis des Umfangs eines Kreises zu seinem Durchmesser, der als Pi mit dem Wert 3,141592653589793 ausgedrückt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pi, pi
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3.141592653589793</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für das Verhältnis des Umfangs eines Kreises zu seinem Durchmesser, der als Pi mit dem Wert 3,141592653589793 ausgedrückt wird.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Eine mathematische Konstante für das Verhältnis des Umfangs eines Kreises zu seinem Durchmesser, der als Pi mit dem Wert 3,141592653589793 ausgedrückt wird.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT1_2"><apiName>SQRT1_2</apiName><shortdesc> 
  Eine mathematische Konstante für die Quadratwurzel von 1/2 mit dem Näherungswert 0,7071067811865476.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt1_2, sqrt1_2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.7071067811865476</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für die Quadratwurzel von 1/2 mit dem Näherungswert 0,7071067811865476.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
  Eine mathematische Konstante für die Quadratwurzel von 1/2 mit dem Näherungswert 0,7071067811865476.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT2"><apiName>SQRT2</apiName><shortdesc>
  Eine mathematische Konstante für die Quadratwurzel von 2 mit dem Näherungswert 1,4142135623730951.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt2, sqrt2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.4142135623730951</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine mathematische Konstante für die Quadratwurzel von 2 mit dem Näherungswert 1,4142135623730951.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Eine mathematische Konstante für die Quadratwurzel von 2 mit dem Näherungswert 1,4142135623730951.
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Array"><apiName>Array</apiName><shortdesc>
 Die Array-Klasse ermöglicht den Zugriff und die Bearbeitung von Arrays.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Array, Array object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Die Array-Klasse ermöglicht den Zugriff und die Bearbeitung von indizierten Arrays.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Array-Klasse ermöglicht den Zugriff und die Bearbeitung von Arrays. Alle Arrays haben die Basis null, d. h., das erste Element im Array ist <codeph>[0]</codeph>, das zweite Element <codeph>[1]</codeph> usw. Verwenden Sie zum Erstellen eines Array-Objekts den Konstruktor <codeph>new Array()</codeph>. <codeph>Array()</codeph> kann auch als Funktion aufgerufen werden. Zudem können Sie den Array-Zugriffsoperator (<codeph>[]</codeph>) verwenden, um ein Array zu initialisieren oder auf die Elemente eines Arrays zuzugreifen. 
 <p>Sie können viele unterschiedliche Datentypen in einem Arrayelement speichern, z. B. Zahlen, Strings, Objekte und auch andere Arrays. Außerdem haben Sie die Möglichkeit, ein <i>mehrdimensionales</i> Array zu erstellen, indem Sie ein indiziertes Array anlegen und jedem seiner Elemente ein weiteres indiziertes Array zuweisen. Diese Arrays werden als mehrdimensional bezeichnet, da sie zur Darstellung von Daten in einer Tabelle verwendet werden können.</p>
 <p> Arrays sind <i>karge Arrays</i>, d. h., sie weisen unter Umständen ein Element auf Indexposition 0 und ein weiteres auf Position 5 auf, dazwischen jedoch keine Elemente. In diesem Fall sind die Elemente in Position 1 bis 4 nicht definiert, wodurch das Fehlen eines Elements angezeigt wird, nicht unbedingt das Vorhandensein eines Elements mit dem Wert <codeph>undefined</codeph>.</p>
 
 <p>Die Zuweisung von Arrays erfolgt nicht mithilfe von Werten, sondern über Verweise. Wenn Sie eine Array-Variable einer anderen zuweisen, verweisen beide Variablen auf das gleiche Array:</p>
 <codeblock>
 var oneArray:Array = new Array("a", "b", "c");
 var twoArray:Array = oneArray; // Both array variables refer to the same array.
 twoArray[0] = "z";             
 trace(oneArray);               // Output: z,b,c.
 </codeblock>
 <p>Allerdings sollten Sie mithilfe der Array-Klasse keine <i>assoziativen Arrays</i> (auch als <i>hashes</i> bezeichnet) erstellen, bei denen es sich um Datenstrukturen mit bezeichneten statt numerierten Elementen handelt. Um assoziative Arrays zu erstellen, verwenden Sie die Object-Klasse. ActionScript ermöglicht zwar auch das Erstellen assoziativer Arrays mithilfe der Array-Klasse, Sie können dann jedoch keine der Methoden oder Eigenschaften der Array-Klasse verwenden. </p>
 <p>Sie können die Array-Klasse erweitern und Methoden überschreiben oder hinzufügen. Allerdings müssen Sie die Unterklasse als <codeph>dynamic</codeph> angeben, da Sie sonst die Fähigkeit, Daten in einem Array zu speichern, verlieren.</p>
 
 </apiDesc><example conref="examples\ArrayExample.as"> Im folgenden Beispiel wird ein neues <codeph>myArr</codeph>-Objekt mit der Ausgangslänge 0 erstellt:
<codeblock>
package {
    import flash.display.Sprite;

    public class ArrayExample extends Sprite {
        public function ArrayExample() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[] (Array-Zugriff)</linktext></link><link href="#Object"><linktext>Object-Klasse</linktext></link></related-links><apiConstructor id="Array:Array_0"><apiName>Array</apiName><shortdesc>
	 Ermöglicht das Erstellen eines Arrays mit der angegebenen Anzahl an Elementen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Das Argument ist eine Zahl, die keine Ganzzahl größer oder gleich 0 ist.	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>numElements</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl, die die Anzahl von Elementen im Array angibt.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Ermöglicht das Erstellen eines Arrays mit der angegebenen Anzahl an Elementen. Wenn Sie keine Parameter angeben, wird ein Array erstellt, der 0 Elemente enthält. Wenn Sie eine bestimmte Anzahl an Elementen angeben, wird ein Array mit <codeph>numElements</codeph> Elementen erstellt. 
     <p><b>Hinweis:</b> Diese Klasse zeigt zwei Konstruktormethodeneinträge, da der Konstruktor Argumente verschiedenen Typs akzeptiert. Der Konstruktor verhält sich unterschiedlich, je nach Typ und Anzahl der übergebenen Argumente, wie sie in den einzelnen Einträgen beschrieben sind. Überladene Methoden oder Konstruktoren werden von ActionSript 3.0 nicht unterstützt.</p>
     
	 
	 </apiDesc><example conref="examples\Array_Array.as"> Im folgenden Beispiel wird das Array-Objekt <codeph>myArr</codeph> mit der Ausgangslänge 0 erstellt:
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array extends Sprite {

        public function Array_Array() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example><example conref="examples\Array_Array_2.as"> Im folgenden Beispiel wird ein Array-Objekt mit 5 Ausgangselementen und der Länge 5 erstellt, das erste Element wird mit dem String <codeph>"one"</codeph> gefüllt und fügt das Stringelement <codeph>"six"</codeph> am Ende des Arrays mithilfe der <codeph>push()</codeph>-Methode hinzu:
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_2 extends Sprite {

        public function Array_Array_2() {
            var myArr:Array = new Array(5);
            trace(myArr.length); // 5
            myArr[0] = "one";
            myArr.push("six");
            trace(myArr);         // one,,,,,six
            trace(myArr.length); // 6
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[] Array-Zugriff</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiConstructor id="Array:Array_1"><apiName>Array</apiName><shortdesc>
	 Ermöglicht das Erstellen eines Arrays mit der angegebenen Anzahl an Elementen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Das Argument ist eine Zahl, die keine Ganzzahl größer oder gleich 0 ist.	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Eine Liste mit mindestens zwei beliebigen Werten. 
	 <p><b>Hinweis: </b>Wenn an den Array-Konstruktor nur ein einziger numerischer Parameter übergeben wird, wird davon ausgegangen, dass er die <codeph>length</codeph>-Eigenschaft des Arrays beschreibt.</p>
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Ermöglicht das Erstellen eines Arrays mit der angegebenen Anzahl an Elementen. Sie können Werte beliebigen Typs angeben. Das erste Element in einem Array hat immer die Indexposition 0.
     <p><b>Hinweis:</b> Diese Klasse zeigt zwei Konstruktoreinträge, da der Konstruktor Argumente verschiedenen Typs akzeptiert. Der Konstruktor verhält sich unterschiedlich, je nach Typ und Anzahl der übergebenen Argumente, wie sie in den einzelnen Einträgen beschrieben sind. Überladene Methoden oder Konstruktoren werden von ActionSript 3.0 nicht unterstützt.</p>
	 </apiDesc><example conref="examples\Array_Array_3.as"> Im folgenden Beispiel wird ein neues Array-Objekt mit der Ausgangslänge 3 erstellt, das Array wird mit den String-Elementen <codeph>one</codeph>, <codeph>two</codeph> und <codeph>three</codeph> gefüllt und anschließend werden die Elemente in einen String umgewandelt.
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_3 extends Sprite {

        public function Array_Array_3() {
            var myArr:Array = new Array("one", "two", "three");
            trace(myArr.length); // 3
            trace(myArr);          // one,two,three
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[] Array-Zugriff</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiOperation id="Array:AS3:concat"><apiName>concat</apiName><shortdesc>
	 Verkettet die in den Parametern angegebenen Elemente mit den Elementen in einem Array und erstellt ein neues Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Array mit den Elementen dieses Arrays und den Elementen aus den Parametern.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Ein Wert beliebigen Datentyps (wie etwa Zahlen, Elemente oder Strings) der in einem neuen Array verkettet werden soll. Wenn Sie keine Werte übergeben, wird das neue Array als Duplikat des ursprünglichen Arrays erstellt.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Verkettet die in den Parametern angegebenen Elemente.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Verkettet die in den Parametern angegebenen Elemente mit den Elementen in einem Array und erstellt ein neues Array. Wenn die Parameter ein Array angeben, werden die Elemente dieses Arrays verkettet. 
 	 
 	 </apiDesc><example conref="examples\Array.concat.1.as"> Mit dem folgenden Code werden vier Array-Objekte erstellt:
 <ul>
   <li>Das <codeph>numbers</codeph>-Array, das die Zahlen <codeph>1</codeph>, <codeph>2</codeph> und <codeph>3</codeph> enthält. </li>
   <li>Das <codeph>letters</codeph>-Array, das die Buchstaben <codeph>a</codeph>, <codeph>b</codeph> und <codeph>c</codeph> enthält. </li>
   <li>Das <codeph>numbersAndLetters</codeph>-Array, das die <codeph>concat()</codeph>-Methode aufruft, um das Array <codeph>[1,2,3,a,b,c]</codeph> zu erstellen. </li>
   <li>Das <codeph>lettersAndNumbers</codeph>-Array, das die <codeph>concat()</codeph>-Methode aufruft, um das Array <codeph>[a,b,c,1,2,3]</codeph> zu erstellen. </li>
 </ul>
<codeblock>

var numbers:Array = new Array(1, 2, 3);
var letters:Array = new Array("a", "b", "c");
var numbersAndLetters:Array = numbers.concat(letters);
var lettersAndNumbers:Array = letters.concat(numbers);

trace(numbers);       // 1,2,3
trace(letters);       // a,b,c
trace(numbersAndLetters); // 1,2,3,a,b,c
trace(lettersAndNumbers); // a,b,c,1,2,3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:every"><apiName>every</apiName><shortdesc>
	 Führt für jedes Element im Array eine Testfunktion aus, bis ein Element erreicht wird, das für die angegebene Funktion „false“ zurückgibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der boolesche Wert <codeph>true</codeph>, wenn alle Elemente im Array für die Funktion <codeph>true</codeph> zurückgeben; andernfalls <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element im Array ausgeführt werden soll. Diese Funktion kann einen einfachen Vergleich enthalten (z. B. <codeph>item &lt; 20</codeph>) oder eine komplexere Operation und wird mit drei Argumenten aufgerufen, nämlich dem Wert eines Elements, der Indexposition eines Elements und einem Array-Objekt:
     <pre>function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Ein Objekt, das als <codeph>this</codeph>-Wert für die Funktion verwendet wird.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Führt für jedes Element im Array eine Testfunktion aus, bis ein Element erreicht wird, das für die angegebene Funktion <codeph>false</codeph> zurückgibt. Sie verwenden diese Methode, um zu ermitteln, ob alle Elemente in einem Array ein Kriterium erfüllen, z. B. dass die Werte unter einer bestimmten Zahl liegen.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Angenommen, Sie erstellen eine Funktion in einem Movieclip mit dem Namen <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Nehmen Sie weiter an, Sie wenden dann die <codeph>every()</codeph>-Methode auf ein Array mit dem Namen <codeph>myArray</codeph> an:</p>
     <pre product="flash">
     myArray.every(myFunction, me);
     </pre>
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Timeline-Klasse ist, die von <codeph>me</codeph> nicht überschrieben werden kann, wird Flash Player eine Ausnahme auslösen. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
     };
     myArray.every(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array_every.as"> Im folgenden Beispiel soll mit einer Prüfung von zwei Arrays festgestellt werden, ob es sich bei jedem Element in jedem Array um eine Zahl handelt. Außerdem werden die Ergebnisse der Tests ausgegeben: <codeph>isNumeric</codeph> ist <codeph>true</codeph> für das erste Array und <codeph>false</codeph> für das zweite:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_every extends Sprite {
        public function Array_every() {
            var arr1:Array = new Array(1, 2, 4);
            var res1:Boolean = arr1.every(isNumeric);
            trace("isNumeric:", res1); // true
 
            var arr2:Array = new Array(1, 2, "ham");
            var res2:Boolean = arr2.every(isNumeric);
            trace("isNumeric:", res2); // false
        }
        private function isNumeric(element:*, index:int, arr:Array):Boolean {
            return (element is Number);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/some()"><linktext>Array.some()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:filter"><apiName>filter</apiName><shortdesc>
	 Führt für jedes Element im Array eine Testfunktion aus und erstellt ein neues Array für alle Elemente, die für die angegebene Funktion „true“ zurückgeben.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein neues Array, das alle Elemente des ursprünglichen Arrays enthält, die den Wert <codeph>true</codeph> zurückgegeben haben.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element im Array ausgeführt werden soll. Diese Funktion kann einen einfachen Vergleich enthalten (z. B. <codeph>item &lt; 20</codeph>) oder eine komplexere Operation und wird mit drei Argumenten aufgerufen, nämlich dem Wert eines Elements, der Indexposition eines Elements und einem Array-Objekt:
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Ein Objekt, das als <codeph>this</codeph>-Wert für die Funktion verwendet wird.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Führt für jedes Element im Array eine Testfunktion aus und erstellt ein neues Array für alle Elemente, die für die angegebene Funktion <codeph>true</codeph> zurückgeben. Gibt ein Element <codeph>false</codeph> zurück, wird es nicht in den neuen Array aufgenommen.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Angenommen, Sie erstellen eine Funktion in einem Movieclip mit dem Namen <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Nehmen Sie weiter an, Sie wenden dann die <codeph>filter()</codeph>-Methode auf ein Array mit dem Namen <codeph>myArray</codeph> an:</p>
     <pre product="flash"> 
     myArray.filter(myFunction, me);
     </pre>
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Timeline-Klasse ist, die von <codeph>me</codeph> nicht überschrieben werden kann, wird Flash Player eine Ausnahme auslösen. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.filter(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array.filter.as"> Im folgenden Beispiel wird ein Array aus allen Angestellten erstellt, die dem Management angehören:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_filter extends Sprite {
        public function Array_filter() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace("Employees:");
            employees.forEach(traceEmployee);
            
            var managers:Array = employees.filter(isManager);
            trace("Managers:");
            managers.forEach(traceEmployee);
        }
        private function isManager(element:*, index:int, arr:Array):Boolean {
            return (element.manager == true);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace("\t" + element.name + ((element.manager) ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/map()"><linktext>Array.map()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:forEach"><apiName>forEach</apiName><shortdesc>
	 Führt für jedes Element im Array eine Funktion aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element im Array ausgeführt werden soll. Diese Funktion kann einen einfachen Befehl enthalten (z. B. <codeph>trace()</codeph>) oder eine komplexere Operation und wird mit drei Argumenten aufgerufen, nämlich dem Wert eines Elements, der Indexposition eines Elements und einem Array-Objekt:
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Ein Objekt, das als <codeph>this</codeph>-Wert für die Funktion verwendet wird.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Führt für jedes Element im Array eine Funktion aus.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Angenommen, Sie erstellen eine Funktion in einem Movieclip mit dem Namen <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Nehmen Sie weiter an, Sie wenden dann die <codeph>forEach()</codeph>-Methode auf ein Array mit dem Namen <codeph>myArray</codeph> an:</p>
     <pre product="flash">
     myArray.forEach(myFunction, me);
     </pre>
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Timeline-Klasse ist, die von <codeph>me</codeph> nicht überschrieben werden kann, wird Flash Player eine Ausnahme auslösen. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.forEach(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_forEach.as"> Im folgenden Beispiel wird die <codeph>trace()</codeph>-Anweisung in der <codeph>traceEmployee()</codeph>-Funktion für jedes Element im Array ausgeführt:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach extends Sprite {
        public function Array_forEach() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace(employees);
            employees.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace(element.name + " (" + element.manager + ")");
        }
    }
}
</codeblock></example><example conref="examples\Array_forEach_2.as"> Im folgenden Beispiel wird die <codeph>trace()</codeph>-Anweisung in einer leicht abgewandelten <codeph>traceEmployee()</codeph>-Funktion für jedes Element im Array ausgeführt:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach_2 extends Sprite {
        public function Array_forEach_2() {
            var employeeXML:XML = &lt;employees>
                    &lt;employee name="Steven" manager="false" />
                    &lt;employee name="Bruce" manager="true" />
                    &lt;employee name="Rob" manager="false" />
                &lt;/employees>;
            var employeesList:XMLList = employeeXML.employee;
            var employeesArray:Array = new Array();
            for each (var tempXML:XML in employeesList) {
                employeesArray.push(tempXML);
            }
            employeesArray.sortOn("@name");
            employeesArray.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:Number, arr:Array):void {
            trace(element.@name + ((element.@manager == "true") ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 Sucht nach einem Element in einem Array unter Verwendung strikter Gleichheit (===), und gibt die Indexposition des Elements zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine auf Null basierende Indexposition des Elements im Array. Wird das Argument <codeph>searchElement</codeph> nicht gefunden, lautet der Rückgabewert -1.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>Das Element, das im Array gesucht werden soll.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Position im Array, ab der die Suche nach dem Element gestartet werden soll.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sucht nach einem Element in einem Array unter Verwendung strikter Gleichheit (<codeph>===</codeph>), und gibt die Indexposition des Elements zurück.
	 </apiDesc><example conref="examples\Array_indexOf.as"> Im folgenden Beispiel wird die Position des angegebenen Arrays angezeigt:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_indexOf extends Sprite {
        public function Array_indexOf() {
            var arr:Array = new Array(123,45,6789);
            arr.push("123-45-6789");
            arr.push("987-65-4321");
            
            var index:int = arr.indexOf("123");
            trace(index); // -1
            
            var index2:int = arr.indexOf(123);
            trace(index2); // 0
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/lastIndexOf()"><linktext>Array.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strikte Gleichheit)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:join"><apiName>join</apiName><shortdesc>
	 Wandelt die Elemente in einem Array in Strings um, fügt zwischen ihnen das angegebene Trennzeichen ein, verkettet die Elemente und gibt den resultierenden String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.join, join
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein String, der aus den Elementen eines Arrays besteht, die in Strings umgewandelt und durch den angegebenen Parameter getrennt werden sollen.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Ein Zeichen oder String, mit dem die Arrayelemente im zurückgegebenen String voneinander getrennt werden. Wenn Sie diesen Parameter weglassen, wird als Standardtrennzeichen das Komma verwendet. 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Konvertiert die Elemente in einem Array in Strings.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Wandelt die Elemente in einem Array in Strings um, fügt zwischen ihnen das angegebene Trennzeichen ein, verkettet die Elemente und gibt den resultierenden String zurück. Ein verschachteltes Array wird immer durch ein Komma getrennt und nicht durch das Trennzeichen, das an die <codeph>join()</codeph>-Methode übergeben wurde.
	 
	 </apiDesc><example conref="examples\Array.join.1.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>myArr</codeph> mit den Elementen <codeph>one</codeph>, <codeph>two</codeph> und <codeph>three</codeph> erstellt. Anschließend wird ein String, der <codeph>one and two and three</codeph> enthält, mithilfe der <codeph>join()</codeph>-Methode erstellt.
<codeblock>

var myArr:Array = new Array("one", "two", "three");
var myStr:String = myArr.join(" and ");
trace(myArr); // one,two,three
trace(myStr); // one and two and three
</codeblock></example><example conref="examples\Array.join.2.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>specialChars</codeph> mit den Elementen <codeph>(</codeph>, <codeph>)</codeph>, <codeph>-</codeph> und einer Leerstelle erstellt. Anschließend wird ein String erstellt, der <codeph>(888) 867-5309</codeph> enthält. Dann werden mithilfe einer <codeph>for</codeph>-Schleife alle in <codeph>specialChars</codeph> aufgelisteten Sonderzeichentypen entfernt, um einen String (<codeph>myStr</codeph>) zu erstellen, der nur die Zahlen der verbleibenden Telefonnummer enthält: <codeph>888675309</codeph>. Beachten Sie, dass möglicherweise andere Zeichen, wie etwa <codeph>+</codeph>, zu <codeph>specialChars</codeph> hinzugefügt wurden. Diese Routine würde dann mit internationalen Telefonnummerformaten funktionieren.
<codeblock>

var phoneString:String = "(888) 867-5309";

var specialChars:Array = new Array("(", ")", "-", " ");
var myStr:String = phoneString;

var ln:uint = specialChars.length;
for(var i:uint; i &lt; ln; i++) {
    myStr = myStr.split(specialChars[i]).join("");
}

var phoneNumber:Number = new Number(myStr);

trace(phoneString); // (888) 867-5309
trace(phoneNumber); // 8888675309
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 Sucht rückwärts, vom letzten Element aus, nach einem Element in einem Array und gibt die Indexposition des Elements zurück, das unter Verwendung des strikten Gleichheitsoperators (===) übereinstimmt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine auf Null basierende Indexposition des Elements im Array. Wird das Argument <codeph>searchElement</codeph> nicht gefunden, lautet der Rückgabewert -1.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>Das Element, das im Array gesucht werden soll.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Die Position im Array, ab der die Suche nach dem Element gestartet werden soll. Standard ist der maximale für eine Indexposition erlaubte Wert. Wenn Sie <codeph>fromIndex</codeph> nicht angeben, beginnt die Suche bei dem letzten Element im Array.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sucht rückwärts, vom letzten Element aus, nach einem Element in einem Array und gibt die Indexposition des Elements zurück, das unter Verwendung des strikten Gleichheitsoperators (<codeph>===</codeph>) übereinstimmt.
	 </apiDesc><example conref="examples\Array_lastIndexOf.as"> Im folgenden Beispiel wird die Position des angegebenen Arrays angezeigt:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_lastIndexOf extends Sprite {
        public function Array_lastIndexOf() {
            var arr:Array = new Array(123,45,6789,123,984,323,123,32);
            
            var index:int = arr.indexOf(123);
            trace(index); // 0
            
            var index2:int = arr.lastIndexOf(123);
            trace(index2); // 6
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/indexOf()"><linktext>Array.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strikte Gleichheit)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:map"><apiName>map</apiName><shortdesc>
     Führt für jedes Element in einem Array eine Funktion aus, und erstellt ein neues Array mit Elementen, die den Ergebnissen der Funktion entsprechen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein neues Array, das die Ergebnisse der Funktion enthält, die für jedes Element im ursprünglichen Array ausgeführt wurde.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element im Array ausgeführt werden soll. Diese Funktion kann einen einfachen Befehl enthalten (z. B. die Groß-/Kleinschreibung in einem Array an Strings umschalten) oder eine komplexere Operation und wird mit drei Argumenten aufgerufen, nämlich dem Wert eines Elements, der Indexposition eines Elements und einem Array-Objekt:
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Ein Objekt, das als <codeph>this</codeph>-Wert für die Funktion verwendet wird.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt für jedes Element in einem Array eine Funktion aus, und erstellt ein neues Array mit Elementen, die den Ergebnissen der Funktion entsprechen.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Angenommen, Sie erstellen eine Funktion in einem Movieclip mit dem Namen <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Nehmen Sie weiter an, Sie wenden dann die <codeph>map()</codeph>-Methode auf ein Array mit dem Namen <codeph>myArray</codeph> an:</p>
     <pre product="flash">
     myArray.map(myFunction, me);
     </pre>
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Timeline-Klasse ist, die von <codeph>me</codeph> nicht überschrieben werden kann, wird Flash Player eine Ausnahme auslösen. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.map(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_map.as"> Im folgenden Beispiel werden alle Elemente im Array zur Verwendung von Großbuchstaben veranlasst:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_map extends Sprite {
        public function Array_map() {
            var arr:Array = new Array("one", "two", "Three");
            trace(arr); // one,two,Three

            var upperArr:Array = arr.map(toUpper);
            trace(upperArr); // ONE,TWO,THREE
        }
        private function toUpper(element:*, index:int, arr:Array):String {
            return String(element).toUpperCase();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/filter()"><linktext>Array.filter()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:pop"><apiName>pop</apiName><shortdesc>
	  Entfernt das letzte Element aus einem Array und gibt den Wert dieses Elements zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.pop, pop
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Wert des letzten Elements (beliebigen Typs) im angegebenen Array.
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	  Entfernt das letzte Element aus einem Array und gibt den Wert dieses Elements zurück.
	 
	 </apiDesc><example conref="examples\Array.pop.1.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>letters</codeph> mit den Elementen <codeph>a</codeph>, <codeph>b</codeph> und <codeph>c</codeph> erstellt. Der letzte Element (<codeph>c</codeph>) wird dann mithilfe der <codeph>pop()</codeph>-Methode aus dem Array entfernt und dem String-Objekt <codeph>letter</codeph> zugewiesen.
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
var letter:String = letters.pop();
trace(letters); // a,b
trace(letter);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:push"><apiName>push</apiName><shortdesc>
	 Fügt am Ende eines Arrays ein oder mehrere Elemente hinzu und gibt die neue Länge des Arrays zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.push, push
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Ganzzahl, die die Länge des neuen Arrays angibt.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Ein oder mehrere Werte, die an das Array angehängt werden.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Fügt am Ende eines Arrays ein oder mehrere Elemente hinzu und gibt die neue Länge des Arrays zurück.
	 
	 </apiDesc><example conref="examples\Array.push.1.as"> Mit dem folgenden Code wird ein leeres Array-Objekt <codeph>letters</codeph> erstellt und mit den Elementen <codeph>a</codeph>, <codeph>b</codeph> und <codeph>c</codeph> mithilfe der <codeph>push()</codeph>-Methode gefüllt.
<codeblock>

var letters:Array = new Array();

letters.push("a");
letters.push("b");
letters.push("c");

trace(letters.toString()); // a,b,c
</codeblock></example><example conref="examples\Array.push.2.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>letters</codeph> erstellt, das zunächst mit dem Element <codeph>a</codeph> gefüllt wird. Dann werden durch einmaliges Anwenden der <codeph>push()</codeph>-Methode die Elemente <codeph>b</codeph> und <codeph>c</codeph> am Ende des Arrays hinzugefügt, d. h. drei Elemente nach dem „push“.
<codeblock>

var letters:Array = new Array("a");
var count:uint = letters.push("b", "c");

trace(letters); // a,b,c
trace(count);   // 3
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:reverse"><apiName>reverse</apiName><shortdesc>
	  Kehrt die Reihenfolge der Arrayelemente im Array um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.reverse, reverse
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das neue Array.
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Kehrt die Reihenfolge der Arrayelemente im Array um.
	 
	 </apiDesc><example conref="examples\Array.reverse.1.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>letters</codeph> mit den Elementen <codeph>a</codeph>, <codeph>b</codeph> und <codeph>c</codeph> erstellt. Anschließend wird die Reihenfolge der Arrayelemente mithilfe der <codeph>reverse()</codeph>-Methode umgekehrt, um das Array <codeph>[c,b,a]</codeph> zu erstellen.
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
letters.reverse();
trace(letters); // c,b,a
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:shift"><apiName>shift</apiName><shortdesc>
	 Entfernt das erste Element aus einem Array und gibt dieses Element zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.shift, shift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das erste Element (beliebigen Datentyps) in einem Array.
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 Entfernt das erste Element aus einem Array und gibt dieses Element zurück. Die verbleibenden Arrayelemente werden von ihrer ursprünglichen Position, i, nach i-1 verschoben.
	 
	 </apiDesc><example conref="examples\Array.shift.1.as"> Mit dem folgenden Code wird das Array-Objekt <codeph>letters</codeph> mit den Elementen <codeph>a</codeph>, <codeph>b</codeph> und <codeph>c</codeph> erstellt. Dann wird mithilfe der <codeph>shift()</codeph>-Methode das erste Elemente (<codeph>a</codeph>) aus <codeph>letters</codeph> entfernt und dem String <codeph>firstLetter</codeph> zugewiesen.
<codeblock>

var letters:Array = new Array("a", "b", "c");
var firstLetter:String = letters.shift();
trace(letters);     // b,c
trace(firstLetter); // a
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:slice"><apiName>slice</apiName><shortdesc>
	 Gibt ein neues Array zurück, das aus mehreren Elementen des ursprünglichen Arrays besteht, ohne das ursprüngliche Array dabei zu ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Array, das aus mehreren Elementen des ursprünglichen Arrays besteht.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Zahl, die die Indexposition des Segmentanfangs angibt. Wenn <codeph>startIndex</codeph> eine negative Zahl ist, liegt der Ausgangspunkt am Ende des Arrays, wobei -1 das letzte Element ist.	
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>Eine Zahl, die die Indexposition des Segmentendes angibt. Wenn Sie diesen Parameter weglassen, umfasst das Segment alle Elemente vom Anfang bis zum Ende des Arrays. Wenn <codeph>endIndex</codeph> eine negative Zahl ist, wird der Endpunkt vom Ende des Arrays aus berechnet, wobei -1 das letzte Element ist.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt ein Array zurück, das aus mehreren Elementen des ursprünglichen Arrays besteht.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt ein neues Array zurück, das aus mehreren Elementen des ursprünglichen Arrays besteht, ohne das ursprüngliche Array dabei zu ändern. Das zurückgegebene Array umfasst das Element <codeph>startIndex</codeph> und alle Elemente bis (ausschließlich) zum Element <codeph>endIndex</codeph>. 
	 <p>Wenn Sie keine Parameter übergeben, wird eine Kopie des ursprünglichen Arrays erstellt.</p>
	 
	 </apiDesc><example conref="examples\Array.slice.1.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>letters</codeph> mit den Elementen <codeph>[a,b,c,d,e,f]</codeph> erstellt. Anschließend wird das Array <codeph>someLetters</codeph> erstellt, und zwar durch den Aufruf der Methode <codeph>slice()</codeph> für die Elemente 1 (<codeph>b</codeph>) bis 3 (<codeph>d</codeph>). Dadurch entsteht ein Array mit den Elementen <codeph>b</codeph> und <codeph>c</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(1,3);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // b,c
</codeblock></example><example conref="examples\Array.slice.2.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>letters</codeph> mit den Elementen <codeph>[a,b,c,d,e,f]</codeph> erstellt. Anschließend wird das Array <codeph>someLetters</codeph> erstellt, und zwar durch den Aufruf der Methode <codeph>slice()</codeph> für das Elemente 2 (<codeph>c</codeph>). Dadurch entsteht ein Array mit den Elementen <codeph>[c,d,e,f]</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // c,d,e,f
</codeblock></example><example conref="examples\Array.slice.3.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>letters</codeph> mit den Elementen <codeph>[a,b,c,d,e,f]</codeph> erstellt. Anschließend wird das Array <codeph>someLetters</codeph> erstellt, und zwar durch den Aufruf der Methode <codeph>slice()</codeph> für das vorletzte Element (<codeph>e</codeph>). Dadurch entsteht ein Array mit den Elementen <codeph>e</codeph> und <codeph>f</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(-2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // e,f
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:some"><apiName>some</apiName><shortdesc>
     Führt für jedes Element im Array eine Testfunktion aus, bis ein Element erreicht wird, das „true“ zurückgibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der boolesche Wert <codeph>true</codeph>, wenn ein Element im Array für die angegebene Funktion <codeph>true</codeph> zurückgibt; andernfalls <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element im Array ausgeführt werden soll. Diese Funktion kann einen einfachen Vergleich enthalten (z. B. <codeph>item &lt; 20</codeph>) oder eine komplexere Operation und wird mit drei Argumenten aufgerufen, nämlich dem Wert eines Elements, der Indexposition eines Elements und einem Array-Objekt:
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Ein Objekt, das als <codeph>this</codeph>-Wert für die Funktion verwendet wird.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt für jedes Element im Array eine Testfunktion aus, bis ein Element erreicht wird, das <codeph>true</codeph> zurückgibt. Verwenden Sie diese Methode, um festzustellen, ob alle Elemente in einem Array ein Kriterium erfüllen, z. B. dass die Werte unter einer bestimmten Zahl liegen.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Angenommen, Sie erstellen eine Funktion in einem Movieclip mit dem Namen <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Nehmen Sie weiter an, Sie wenden dann die <codeph>some()</codeph>-Methode auf ein Array mit dem Namen <codeph>myArray</codeph> an:</p>
     <pre product="flash">
     myArray.some(myFunction, me);
     </pre>
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Timeline-Klasse ist, die von <codeph>me</codeph> nicht überschrieben werden kann, wird Flash Player eine Ausnahme auslösen. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.some(myFunction, me);
     </pre>   
	 </apiDesc><example conref="examples\Array_some.as"> Im folgenden Beispiel wird angezeigt, welche Werte nicht definiert sind:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_some extends Sprite {
        public function Array_some() {
            var arr:Array = new Array();
            arr[0] = "one";
            arr[1] = "two";
            arr[3] = "four";
            var isUndef:Boolean = arr.some(isUndefined);
            if (isUndef) {
                trace("array contains undefined values: " + arr);
            } else {
                trace("array contains no undefined values.");
            }
        }
        private function isUndefined(element:*, index:int, arr:Array):Boolean {
            return (element == undefined);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sort"><apiName>sort</apiName><shortdesc>
	 Sortiert die Elemente in einem Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sort, sort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Rückgabewert hängt, wie in der folgenden Liste beschrieben, davon ab, ob Sie Argumente übergeben:
	 <ul>
	   <li>Wenn Sie den Wert 4 oder <codeph>Array.UNIQUESORT</codeph> für das Argument <codeph>sortOptions</codeph> des Parameters <codeph>...args</codeph> angeben und mindestens zwei zu sortierende Elemente identische Sortierfelder aufweisen, gibt Flash den Wert 0 zurück, ändert das Array jedoch nicht. </li>
  	   <li>Wenn Sie den Wert 8 oder <codeph>Array.RETURNINDEXEDARRAY</codeph> für das Argument <codeph>sortOptions</codeph> des Parameters <codeph>...args</codeph> angeben, gibt Flash ein sortiertes numerisches Array der Indexpositionen zurück, das die Ergebnisse der Sortierung wiedergibt, ändert das Array jedoch nicht. </li>
	   <li>Andernfalls gibt Flash keinen Wert zurück und ändert das Array entsprechend der Sortierreihenfolge.</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Die Argumente, die eine Vergleichsfunktion angeben, sowie mindestens ein Wert, der das Verhalten der Sortierung bestimmt.
	 <p>Diese Methode verwendet die Syntax und Argumentreihenfolge <codeph>Array.sort(compareFunction, sortOptions)</codeph>, wobei die Argument wie folgt definiert sind:</p>
     <ul><li><codeph>compareFunction</codeph> – Eine Vergleichsfunktion, mit der die Sortierreihenfolge der Elemente im Array festgelegt wird. Dieses Argument ist optional. Eine Vergleichsfunktion sollte zwei zu vergleichende Argumente akzeptieren. Bei gegebenen Elementen A und B kann das Ergebnis von <codeph>compareFunction</codeph> einen negativen oder einen positiven oder den Wert 0 haben:
	 <ul>
	   <li>Ein negativer Rückgabewert legt fest, dass A in der sortierten Reihenfolge vor B erscheint.</li>
	   <li>Der Rückgabewert 0 legt fest, dass A und B die gleiche Sortierreihenfolge haben.</li>
	   <li>Ein positiver Rückgabewert legt fest, dass A in der sortierten Reihenfolge nach B erscheint.</li>
	 </ul>
	 </li>
	 <li><codeph>sortOptions</codeph> – Eine oder mehrere durch den bitweisen OR-Operator <codeph>|</codeph> voneinander getrennte Zahlen oder definierte Konstanten, die das Verhalten der Sortierung gegenüber dem Standardverhalten ändern. Dieses Argument ist optional. Folgende Werte sind für <codeph>sortOptions</codeph> zulässig: 
	  <ul>
	   <li>1 oder <codeph>Array.CASEINSENSITIVE</codeph></li>
	   <li>2 oder <codeph>Array.DESCENDING</codeph></li>
	   <li>4 oder <codeph>Array.UNIQUESORT</codeph></li>
	   <li>8 oder <codeph>Array.RETURNINDEXEDARRAY</codeph> </li>
	   <li>16 oder <codeph>Array.NUMERIC</codeph></li>
	 </ul>
	 Weitere Informationen hierzu finden Sie im Abschnitt zur Methode <codeph>Array.sortOn()</codeph>.</li>
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sortiert die Elemente in einem Array. Diese Methode sortiert nach Unicode-Werten. (ASCII ist eine Untergruppe von Unicode.)
	 <p>In der Standardeinstellung funktioniert <codeph>Array</codeph> .<codeph>sort()</codeph> wie folgt:</p>
	 <ul>
	   <li>Bei der Sortierung wird Groß-/Kleinschreibung beachtet (<i>Z</i> kommt vor <i>a</i>).</li>
	   <li>Die Sortierung erfolgt aufsteigend (<i>a</i> kommt vor <i>b</i>). </li>
	   <li>Das Array wird entsprechend der Sortierreihenfolge geändert. Elemente mit identischen Sortierfeldern werden im sortierten Array ohne bestimmte Reihenfolge nacheinander platziert.</li>
	   <li>Alle Elemente werden, unabhängig von ihrem Datentyp, so sortiert, als seien sie Strings. 100 kommt demnach vor 99, da „1“ ein kleinerer Stringwert ist als „9“.</li>
	 </ul>
	 <p>
	 Um ein Array in einer von den Standardeinstellungen abweichenden Reihenfolge zu sortieren, können Sie entweder eine der im Abschnitt <codeph>sortOptions</codeph> des <codeph>...args</codeph>-Parameters beschriebenen Sortierreihenfolgen verwenden oder eine eigene benutzerdefinierte Funktion für die Sortierung erstellen. Wenn Sie eine benutzerdefinierte Funktion erstellen möchten, rufen Sie die <codeph>sort()</codeph>-Methode auf und verwenden den Namen der benutzerdefinierten Funktion als erstes Argument (<codeph>compareFunction</codeph>). 
	 </p>
	 
	 </apiDesc><example conref="examples\Array.sort.1.as"> Im folgenden Beispiel wird das Array-Objekt <codeph>vegetables</codeph> mit den Elementen <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph> erstellt. Anschließend wird das Array mithilfe der <codeph>sort()</codeph>-Methode, die ohne Parameter aufgerufen wird, sortiert. Das Ergebnis ist <codeph>vegetables</codeph> sortiert in alphabetischer Reihenfolge (<codeph>[avocado, cilantro, green pepper, onion, spinach]</codeph>).
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

trace(vegetables); // spinach,green pepper,cilantro,onion,avocado
vegetables.sort();
trace(vegetables); // avocado,cilantro,green pepper,onion,spinach
</codeblock></example><example conref="examples\Array.sort.2.as"> Im folgenden Beispiel wird das Array-Objekt <codeph>vegetables</codeph> mit den Elementen <codeph>[spinach, green pepper, Cilantro, Onion, and Avocado]</codeph> erstellt. Anschließend wird das Array mithilfe der <codeph>sort()</codeph>-Methode, die beim ersten Mal ohne Parameter aufgerufen wird, sortiert. Das Ergenis ist <codeph>[Avocado,Cilantro,Onion,green pepper,spinach]</codeph>. Anschließend wird <codeph>sort()</codeph> erneut für <codeph>vegetables</codeph> aufgerufen, wobei die Konstante <codeph>CASEINSENSITIVE</codeph> als ein Parameter verwendet wird. Das Ergebnis ist <codeph>vegetables</codeph> sortiert in alphabetischer Reihenfolge (<codeph>[Avocado, Cilantro, green pepper, Onion, spinach]</codeph>).
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "Cilantro",
                 "Onion",
                 "Avocado");

vegetables.sort();
trace(vegetables); // Avocado,Cilantro,Onion,green pepper,spinach
vegetables.sort(Array.CASEINSENSITIVE);
trace(vegetables); // Avocado,Cilantro,green pepper,Onion,spinach
</codeblock></example><example conref="examples\Array.sort.3.as"> Im folgenden Beispiel wird das leere Array-Objekt <codeph>vegetables</codeph> erstellt, das dann durch fünf Aufrufe von <codeph>push()</codeph> gefüllt wird. Mit jedem Aufrufen von <codeph>push()</codeph> wird ein neues <codeph>Vegetable</codeph>-Objekt durch einen Aufruf des <codeph>Vegetable()</codeph>-Konstruktors erstellt, der ein String- (<codeph>name</codeph>) und ein Number- (<codeph>price</codeph>)-Objekt akzeptiert. Durch das fünfmalige Aufrufen von <codeph>push()</codeph> mit den gezeigten Werten ergibt sich das folgende Array: <codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>. Dann wird das Array mithilfe der <codeph>sort()</codeph>-Methode sortiert, und es ergibt das Array <codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>.
<codeblock>
var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort();

trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

//The following code defines the Vegetable class
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.4.as"> Das folgende Beispiel unterscheidet sich vom vorherigen nur dadurch, dass die <codeph>sort()</codeph>-Methode zusammen mit einer benutzerdefinierten Sortierfunktion (<codeph>sortOnPrice</codeph>) ausgeführt wird, d. h. das Array wird nicht in alphabetischer Reihenfolge sondern anhand des Preises sortiert. Beachten Sie, dass die neue Funktion <codeph>getPrice()</codeph> den Preis extrahiert.
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort(sortOnPrice);

trace(vegetables);
// celery:1.29, squash:1.44, lettuce:1.49, spinach:1.89, asparagus:3.99

function sortOnPrice(a:Vegetable, b:Vegetable):Number {
    var aPrice:Number = a.getPrice();
    var bPrice:Number = b.getPrice();

    if(aPrice > bPrice) {
        return 1;
    } else if(aPrice &lt; bPrice) {
        return -1;
    } else  {
        //aPrice == bPrice
        return 0;
    }
}

// The following code defines the Vegetable class and should be in a separate package.
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function getPrice():Number {
        return price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.5.as"> Mit dem folgenden Code wird das Array-Objekt <codeph>numbers</codeph> mit den Elementen <codeph>[3,5,100,34,10]</codeph> erstellt. Durch das Aufrufen von <codeph>sort()</codeph> ohne Parameter wird das Array in alphabetischer Reihenfolge sortiert; es ergibt das unerwünschte Ergebnis <codeph>[10,100,3,34,5]</codeph>. Um numerische Werte richtig zu sortieren, müssen Sie die <codeph>NUMERIC</codeph>-Konstante an die <codeph>sort()</codeph>-Methode übergeben, mit der <codeph>numbers</codeph> wie folgt sortiert wird: <codeph>[3,5,10,34,100]</codeph>.
 <p><b>Hinweis:</b> Das Standardverhalten der Funktion <codeph>sort()</codeph> besteht darin, jede Einheit als String zu behandeln. Mit dem Argument <codeph>Array.NUMERIC</codeph> werden andere Datentypen nicht in den Datentyp Number umgewandelt; es gestattet dem Sortieralgorithmus lediglich Zahlen zu erkennen.</p>
<codeblock>

var numbers:Array = new Array(3,5,100,34,10);

trace(numbers); // 3,5,100,34,10
numbers.sort();
trace(numbers); // 10,100,3,34,5
numbers.sort(Array.NUMERIC);
trace(numbers); // 3,5,10,34,100
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (bitweiser OR-Operator)</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sortOn"><apiName>sortOn</apiName><shortdesc>
	 Sortiert die Elemente in einem Array nach mindestens einem Feld im Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sortOn, sortOn
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Rückgabewert hängt davon ab, ob Sie Parameter übergeben:
	 <ul>
	   <li>Wenn Sie den Wert 4 oder <codeph>Array.UNIQUESORT</codeph> für den Parameter <codeph>options</codeph> angeben und mindestens zwei zu sortierende Elemente identische Sortierfelder aufweisen, wird der Wert 0 zurückgegeben, und das Array wird nicht geändert. </li>
  	   <li>Wenn Sie den Wert 8 oder <codeph>Array.RETURNINDEXEDARRAY</codeph> für den Parameter <codeph>options</codeph> angeben, wird ein Array zurückgegeben, das die Ergebnisse der Sortierung wiedergibt, und das Array wird nicht geändert.</li>
  	   <li>Andernfalls wird nichts zurückgegeben, und das Array wird entsprechend der Sortierreihenfolge geändert.</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>fieldName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein String, der ein Feld mit einem Sortierwert definiert bzw. ein Array, in dem das erste Element das primäre Sortierfeld, das zweite Element das sekundäre Sortierfeld darstellt usw.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>options</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Durch den Operator <codeph>bitwise OR (|)</codeph> voneinander getrennte Zahlen oder Namen definierter Konstanten, die das Verhalten der Sortierung ändern. Folgende Werte sind für den <codeph>options</codeph>-Parameter zulässig:
	 <ul>
	   <li><codeph>Array.CASEINSENSITIVE</codeph> oder 1</li>
	   <li><codeph>Array.DESCENDING</codeph> oder 2</li>
	   <li><codeph>Array.UNIQUESORT</codeph> oder 4</li>
	   <li><codeph>Array.RETURNINDEXEDARRAY</codeph> oder 8</li>
	   <li><codeph>Array.NUMERIC</codeph> oder 16</li>
	 </ul>
     <p product="flash">Codehinweise sind aktiviert, wenn Sie die Stringform des Parameters (z. B. <codeph>DESCENDING</codeph>) anstelle der numerischen Form (2) verwenden.</p>
   	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sortiert die Elemente in einem Array nach mindestens einem Feld im Array. Das Array muss folgende Merkmale aufweisen:
	 <ul>
	   <li>Es handelt sich um ein indiziertes und kein assoziatives Array.</li>
 	   <li>Jedes Element des Arrays enthält ein Objekt mit mindestens einer Eigenschaft.</li>
	   <li>Sämtliche Objekte haben mindestens eine Eigenschaft gemeinsam, anhand deren Werte die Objekte im Array sortiert werden können. Eine solche Eigenschaft wird als <i>field</i> bezeichnet.</li>
	 </ul>
	 <p>Wenn Sie mehrere <codeph>fieldName</codeph>-Parameter übergeben, stellt das erste Feld das primäre Sortierfeld dar, das zweite Feld das nächste Sortierfeld usw. Flash sortiert nach Unicode-Werten. (ASCII ist eine Untergruppe von Unicode.) Wenn eines der zu vergleichenden Elemente das im <codeph>fieldName</codeph>-Parameter angegebene Feld nicht enthält, wird davon ausgegangen, dass das Feld auf <codeph>undefined</codeph> gesetzt wurde, und die Elemente werden im sortierten Array ohne bestimmte Reihenfolge nacheinander platziert.</p>
 	 <p>In der Standardeinstellung funktioniert <codeph>Array</codeph> .<codeph>sortOn()</codeph> wie folgt:</p>
	 <ul>
	   <li>Bei der Sortierung wird Groß-/Kleinschreibung beachtet (<i>Z</i> kommt vor <i>a</i>).</li>
	   <li>Die Sortierung erfolgt aufsteigend (<i>a</i> kommt vor <i>b</i>). </li>
	   <li>Das Array wird entsprechend der Sortierreihenfolge geändert. Elemente mit identischen Sortierfeldern werden im sortierten Array ohne bestimmte Reihenfolge nacheinander platziert.</li>
	   <li>Numerische Felder werden so sortiert, als seien sie Strings. 100 kommt demnach vor 99, da „1“ ein kleinerer Stringwert ist als „9“.</li>
	 </ul>
	 <p>Flash Player 7 umfasst den <codeph>options</codeph>-Parameter, mit dem Sie das Standardverhalten der Sortierung außer Kraft setzen können. Wenn Sie ein einfaches Array (z. B. ein Array mit nur einem Feld) sortieren oder eine nicht vom <codeph>options</codeph>-Parameter unterstützte Sortierreihenfolge festlegen möchten, verwenden Sie <codeph>Array.sort()</codeph>.</p>
 	 <p>Wenn Sie mehrere Flags übergeben möchten, trennen Sie diese mithilfe des bitweisen OR-Operators (<codeph>|</codeph>):</p>
	 <codeblock>
	 my_array.sortOn(someFieldName, Array.DESCENDING | Array.NUMERIC);
	 </codeblock>
	 <p>In Flash Player 8 haben Sie die Möglichkeit, bei einer Sortierung nach mehreren Feldern für jedes Feld eine andere Sortieroption anzugeben. In Flash Player 8 kann für den <codeph>options</codeph>-Parameter ein Array mit Sortieroptionen angegeben werden, bei dem jede Sortieroption einem Sortierfeld im <codeph>fieldName</codeph>-Parameter entspricht. Im folgenden Beispiel wird nach dem primären Sortierfeld <codeph>a</codeph> in absteigender Reihenfolge, dann nach dem sekundären Sortierfeld <codeph>b</codeph> anhand einer numerischen Sortierung und schließlich nach dem Sortierfeld <codeph>c</codeph> mit einer Sortierung ohne Beachtung der Groß-/Kleinschreibung sortiert.</p>
	 <codeblock>
	 Array.sortOn (["a", "b", "c"], [Array.DESCENDING, Array.NUMERIC, Array.CASEINSENSITIVE]);
	 </codeblock>
	 <p><b>Hinweis: </b> Die Arrays <codeph>fieldName</codeph> und <codeph>options</codeph> müssen die gleiche Anzahl von Elementen aufweisen. Andernfalls wird das Array <codeph>options</codeph> ignoriert. Außerdem können die Optionen <codeph>Array.UNIQUESORT</codeph> und <codeph>Array.RETURNINDEXEDARRAY</codeph> nur als erstes Element im Array verwendet werden, da sie ansonsten ignoriert werden.</p>
	 
	 </apiDesc><example conref="examples\Array.sortOn.1.as"> Im folgenden Beispiel wird das leere Array-Objekt <codeph>vegetables</codeph> erstellt, das dann durch fünf Aufrufe von <codeph>push()</codeph> gefüllt wird. Mit jedem Aufrufen von <codeph>push()</codeph> wird ein neues <codeph>Vegetable</codeph>-Objekt durch einen Aufruf des <codeph>Vegetable()</codeph>-Konstruktors erstellt, der ein String- (<codeph>name</codeph>) und ein Number- (<codeph>price</codeph>)-Objekt akzeptiert. Durch das fünfmalige Aufrufen von <codeph>push()</codeph> mit den gezeigten Werten ergibt sich das folgende Array: <codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>. Anschließend wird die <codeph>sortOn()</codeph>-Methode zusammen mit dem <codeph>name</codeph>-Parameter angewendet, um das folgende Array zu erstellen: <codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>. Daraufhin wird die <codeph>sortOn()</codeph>-Methode erneut zusammen mit dem price-Parameter und den Konstanten NUMERIC und DESCENDING aufgerufen, um ein nach Zahlen in absteigender Reihenfolge sortiertes Array zu erstellen: <codeph>[asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29]</codeph>.
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sortOn("name");
trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

vegetables.sortOn("price", Array.NUMERIC | Array.DESCENDING);
trace(vegetables);
// asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29

class Vegetable {
    public var name:String;
    public var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sortOn.2.as"> Im folgenden Beispiel wird das leere Array-Objekt <codeph>records</codeph> erstellt, das dann durch drei Aufrufe von <codeph>push()</codeph> gefüllt wird. Mit jedem Aufrufen von <codeph>push()</codeph> werden die Strings <codeph>name</codeph> und <codeph>city</codeph> sowie eine <codeph>zip</codeph>-Zahl zu <codeph>records</codeph> hinzugefügt. Die Arrayelemente werden mit drei <codeph>for</codeph>-Schleifen gedruckt. Mit der ersten <codeph>for</codeph>-Schleife werden die Elemente in der Reihenfolge gedruckt, in der sie hinzugefügt wurden. Die zweite <codeph>for</codeph>-Schleife wird ausgeführt, nachdem <codeph>records</codeph> zuerst anhand des Namens und dann der Stadt mithilfe der <codeph>sortOn()</codeph>-Methode sortiert wurde. Mit der dritten <codeph>for</codeph>-Schleife wird <codeph>records</codeph> zuerst anhand der Stadt und dann anhand des Namens sortiert.
<codeblock>


var records:Array = new Array();
records.push({name:"john", city:"omaha", zip:68144});
records.push({name:"john", city:"kansas city", zip:72345});
records.push({name:"bob", city:"omaha", zip:94010});

for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, omaha
// john, kansas city
// bob, omaha

trace("records.sortOn('name', 'city');");
records.sortOn(["name", "city"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// bob, omaha
// john, kansas city
// john, omaha

trace("records.sortOn('city', 'name');");
records.sortOn(["city", "name"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, kansas city
// bob, omaha
// john, omaha
</codeblock></example><example conref="examples\Array.sortOn.3.as"> Im folgenden Beispiel wird das leere Array-Objekt <codeph>users</codeph> erstellt, das dann durch vier Aufrufe von <codeph>push()</codeph> gefüllt wird. Mit jedem Aufrufen von <codeph>push()</codeph> wird ein User-Objekt mit dem <codeph>User()</codeph>-Konstruktor erstellt und den Benutzern wird ein <codeph>name</codeph>-String sowie eine <codeph>age</codeph>-uint hinzugefügt. Das sich daraus ergebende Array ist <codeph>[Bob:3,barb:35,abcd:3,catchy:4]</codeph>.
 <p>Anschließend wird das Array folgendermaßen sortiert:
 <ol>
   <li>Anhand des Namens ergibt sich <codeph>[Bob:3,abcd:3,barb:35,catchy:4]</codeph>.</li>
   <li>Anhand des Namens zusammen mit der Konstante <codeph>CASEINSENSITIVE</codeph> ergibt sich <codeph>[abcd:3,barb:35,Bob:3,catchy:4]</codeph>.</li>
   <li>Anhand des Namens zusammen mit den Konstanten <codeph>CASEINSENSITIVE</codeph> und <codeph>DESCENDING</codeph> ergibt sich <codeph>[catchy:4,Bob:3,barb:35,abcd:3]</codeph>.</li>
   <li>Anhand des Alters ergibt sich <codeph>[abcd:3,Bob:3,barb:35,catchy:4]</codeph>.</li>
   <li>Anhand des Alters zusammen mit der Konstante <codeph>NUMERIC</codeph> ergibt sich <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph>.</li>
   <li>Anhand des Alters zusammen mit den Konstanten <codeph>DESCENDING</codeph> und <codeph>NUMERIC</codeph> ergibt sich <codeph>[barb:35,catchy:4,Bob:3,abcd:3]</codeph>.</li>
 </ol>
 </p>
 <p>Anschließend wird ein Array mit dem Namen <codeph>indices</codeph> erstellt, dem die Ergebnisse einer Sortierung anhand des Alters zusammen mit den Konstanten <codeph>NUMERIC</codeph> und <codeph>RETURNINDEXEDARRAY</codeph> zugewiesen werden. Daraus ergibt sich das Array <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph>, das mithilfe einer <codeph>for</codeph>-Schleife gedruckt wird.</p>
<codeblock>

class User {
    public var name:String;
    public var age:Number;
    public function User(name:String, age:uint) {
        this.name = name;
        this.age = age;
    }

    public function toString():String {
        return this.name + ":" + this.age;
    }
}

var users:Array = new Array();
users.push(new User("Bob", 3));
users.push(new User("barb", 35));
users.push(new User("abcd", 3));
users.push(new User("catchy", 4));

trace(users); // Bob:3,barb:35,abcd:3,catchy:4

users.sortOn("name");
trace(users); // Bob:3,abcd:3,barb:35,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE);
trace(users); // abcd:3,barb:35,Bob:3,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE | Array.DESCENDING);
trace(users); // catchy:4,Bob:3,barb:35,abcd:3

users.sortOn("age");
trace(users); // abcd:3,Bob:3,barb:35,catchy:4

users.sortOn("age", Array.NUMERIC);
trace(users); // Bob:3,abcd:3,catchy:4,barb:35

users.sortOn("age", Array.DESCENDING | Array.NUMERIC);
trace(users); // barb:35,catchy:4,Bob:3,abcd:3

var indices:Array = users.sortOn("age", Array.NUMERIC | Array.RETURNINDEXEDARRAY);
var index:uint;
for(var i:uint = 0; i &lt; indices.length; i++) {
    index = indices[i];
    trace(users[index].name, ": " + users[index].age);
}

// Results:
// Bob : 3
// abcd : 3
// catchy : 4
// barb : 35
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (bitweiser OR-Operator)</linktext></link><link href="#Array/sort()"><linktext>Array.sort()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:splice"><apiName>splice</apiName><shortdesc>
	 Fügt einem Array Elemente hinzu bzw. entfernt diese.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.splice, splice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Array, das die aus dem ursprünglichen Array entfernten Elemente enthält.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die Indexposition des Arrayelements angibt, an der der Einfüge- oder Löschvorgang beginnt. Sie können hier negative Ganzzahlen verwenden, um eine Position am Ende des Arrays anzugeben (so ist -1 das letzte Element des Arrays).
	 </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die Anzahl der zu löschenden Elemente angibt. Diese Zahl schließt das im <codeph>startIndex</codeph>-Parameter angegebene Element ein. Wenn kein Wert für <codeph>deleteCount</codeph> angegeben ist, löscht die Methode alle Werte von <codeph>startIndex</codeph> bis zum letzten Arrayelement. Wenn der Wert 0 lautet, werden keine Elemente gelöscht. 	 
	 </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Eine optionale Liste mit mindestens zwei durch Kommas getrennten Werten, die an der durch den Parameter <codeph>startIndex</codeph> angegebenen Position in das Array einzufügen sind. Wenn ein eingefügter Wert den Typ „Array“ aufweist, wird das Array intakt gehalten und als einzelnes Element eingefügt. Wenn Sie zum Beispiel ein vorhandenes Array mit der Länge 3 mit einem anderen Array mit der Länge 3 verbinden, hat das resultierende Array nur vier Elemente. Eines dieser Elemente ist ein Array mit der Länge 3.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Fügt einem Array Elemente hinzu bzw. entfernt diese. Bei dieser Methode werden Änderungen am Array vorgenommen, ohne eine Kopie zu erstellen.
	 <p><b>Hinweis:</b> Um diese Methode in einer Unterklasse von Array zu überschreiben, verwenden Sie, wie im folgenden Beispiel gezeigt, <codeph>...args</codeph> für die Parameter:</p>
	 <pre>
	 public override function splice(...args) {
	   // your statements here
	 }
	 </pre>
	 </apiDesc><example conref="examples\Array.splice.1.as"> Im folgenden Beispiel wird das Array-Objekt <codeph>vegetables</codeph> mit den Elementen <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph> erstellt. Anschließend wird die <codeph>splice()</codeph>-Methode mit den Parametern 2 und 2 aufgerufen. Dadurch werden <codeph>cilantro</codeph> und <codeph>onion</codeph> dem <codeph>spliced</codeph>-Array hinzugefügt. Das <codeph>vegetables</codeph>-Array enthält daraufhin <codeph>[spinach,green pepper,avocado]</codeph>. Die <codeph>splice()</codeph>-Methode wird ein zweites Mal mit den Parametern 1 und 0 sowie dem <codeph>spliced</codeph>-Array aufgerufen, um <codeph>[cilantro,onion]</codeph> als zweites Element von <codeph>vegetables</codeph> zuzuweisen.
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

var spliced:Array = vegetables.splice(2, 2);
trace(vegetables); // spinach,green pepper,avocado
trace(spliced);    // cilantro,onion

vegetables.splice(1, 0, spliced);
trace(vegetables); // spinach,cilantro,onion,green pepper,avocado

</codeblock></example><example conref="examples\Array.splice.2.as"> Beachten Sie, dass <codeph>cilantro</codeph> und <codeph>onion</codeph> wiedergegeben werden, als ob <codeph>vegetables</codeph> 5 Elemente enthielte, obwohl es nur vier sind (wobei es sich beim zweiten Element um ein anderes Array mit zwei Elementen handelt). Sie können <codeph>cilantro</codeph> und <codeph>onion</codeph> einzeln hinzufügen, und zwar mithilfe von:
<codeblock>
 
var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");
 
 var spliced:Array = vegetables.splice(2, 2);
 trace(vegetables); // spinach,green pepper,avocado
 trace(spliced);    // cilantro,onion
 
 vegetables.splice(1, 0, "cilantro", "onion");
 trace(vegetables); // spinach,cilantro,onion,green pepper,avocado
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     Gibt einen String zurück, der die Elemente im angegebenen Array repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String mit Arrayelementen.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Gibt einen String zurück, der die Elemente im angegebenen Array repräsentiert. Alle Arrayelemente von Indexposition 0 bis zur höchsten Indexposition werden in einen verketteten, durch Kommas getrennten String umgewandelt. In der ActionScript 3.0-Implementierung gibt diese Methode denselben Wert wie die <codeph>Array.toString()</codeph>-Methode zurück.
   	 
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/toString()"><linktext>Array.toString()</linktext></link></related-links></apiOperation><apiOperation id="Array:toString"><apiName>toString</apiName><shortdesc>
	 Gibt einen String zurück, der die Elemente im angegebenen Array repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String mit Arrayelementen.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt einen String zurück, der die Elemente im angegebenen Array repräsentiert. Alle Arrayelemente von Indexposition 0 bis zur höchsten Indexposition werden in einen verketteten, durch Kommas getrennten String umgewandelt. Verwenden Sie die <codeph>Array.join()</codeph>-Methode, um ein benutzerdefiniertes Trennzeichen anzugeben.
   	 
	 
	 </apiDesc><example conref="examples\Array.toString.1.as"> MIt dem folgenden Beispiel wird ein Array erstellt, die Werte werden in Strings umgewandelt und in der <codeph>vegnums</codeph>-Variable vom Datentyp String gespeichert.

<codeblock>

var vegetables:Array = new Array();
vegetables.push(1);
vegetables.push(2);
vegetables.push(3);
vegetables.push(4);
vegetables.push(5);
var vegnums:String = vegetables.toString();
trace(vegnums+",6");
// 1,2,3,4,5,6
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Array/join()"><linktext>Array.join()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     Fügt am Anfang eines Arrays ein oder mehrere Elemente hinzu und gibt die neue Länge des Arrays zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.unshift, unshift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Ganzzahl, die die neue Länge des Arrays repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Eine oder mehrere Zahlen, Elemente oder Variablen, die am Anfang des Arrays eingefügt werden sollen.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt am Anfang eines Arrays ein oder mehrere Elemente hinzu und gibt die neue Länge des Arrays zurück. Die anderen Elemente im Array werden von ihrer ursprünglichen Position, i, nach i+1 verschoben.
	 
	 </apiDesc><example conref="examples\Array.unshift.1.as"> Im folgenden Beispiel wird das leere Array-Objekt <codeph>names</codeph> erstellt. Die Strings <codeph>Bill</codeph> und <codeph>Jeff</codeph> werden mithilfe der <codeph>push()</codeph>-Methode hinzugefügt. Anschließend werden die Strings <codeph>Alfred</codeph> und <codeph>Kyle</codeph> am Anfang von <codeph>names</codeph> durch zwei Aufrufe der <codeph>unshift()</codeph>-Methode eingefügt.
<codeblock>

var names:Array = new Array();
names.push("Bill");
names.push("Jeff");

trace(names); // Bill,Jeff

names.unshift("Alfred");
names.unshift("Kyle");

trace(names); // Kyle,Alfred,Bill,Jeff
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link></related-links></apiOperation><apiValue id="Array:CASEINSENSITIVE"><apiName>CASEINSENSITIVE</apiName><shortdesc>
     Legt als Sortiermethode für die Array-Klasse eine Sortierung ohne Beachtung der Groß- und Kleinschreibung fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F6
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Legt als Sortiermethode für die Array-Klasse eine Sortierung ohne Beachtung der Groß- und Kleinschreibung fest. Sie können diese Konstante als Wert für den <codeph>options</codeph>-Parameter in der Methode <codeph>sort()</codeph> oder <codeph>sortOn()</codeph> verwenden. 
	 <p>Diese Konstante hat den Wert 1.</p>
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:DESCENDING"><apiName>DESCENDING</apiName><shortdesc>
     Legt als Sortiermethode für die Array-Klasse eine absteigende Sortierreihenfolge fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F7
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Legt als Sortiermethode für die Array-Klasse eine absteigende Sortierreihenfolge fest. Sie können diese Konstante als Wert für den <codeph>options</codeph>-Parameter in der Methode <codeph>sort()</codeph> oder <codeph>sortOn()</codeph> verwenden. 
 	 <p>Diese Konstante hat den Wert 2.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:NUMERIC"><apiName>NUMERIC</apiName><shortdesc>
     Legt als Sortiermethode für die Array-Klasse eine numerische (statt einer stringbasierten) Sortierreihenfolge fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F8
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>16</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Legt als Sortiermethode für die Array-Klasse eine numerische (statt einer stringbasierten) Sortierreihenfolge fest. Wenn Sie diese Konstante dem <codeph>options</codeph>-Parameter hinzufügen, sortieren die <codeph>sort()</codeph>- und <codeph>sortOn()</codeph>-Methoden Zahlen als numerische Werte und nicht als Strings numerischer Zeichen. Ohne die Konstante <codeph>NUMERIC</codeph> werden bei der Sortierung alle Arrayelemente wie Strings behandelt, und die Ergebnisse werden in der Unicode-Reihenfolge dargestellt. 
 	 
     <p>Wenn beispielsweise bei einem Array der Werte <codeph>[2005, 7, 35]</codeph> die Konstante <codeph>NUMERIC</codeph> <b>not</b> dem <codeph>options</codeph>-Parameter hinzugefügt ist, lautet das sortierte Array <codeph>[2005, 35, 7]</codeph>. Wurde die Konstante <codeph>NUMERIC</codeph> jedoch <b>is</b>, lautet das sortierte Array <codeph>[7, 35, 2005]</codeph>. </p>
 	 
 	 <p>Diese Konstante gilt nur für Zahlen im Array. Sie gilt jedoch nicht für Strings mit numerischen Daten wie <codeph>["23", "5"]</codeph>.</p>
 	 
 	 <p>Diese Konstante hat den Wert 16.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:RETURNINDEXEDARRAY"><apiName>RETURNINDEXEDARRAY</apiName><shortdesc>
	 Legt fest, dass eine Sortierung ein Array zurückgibt, der aus Arrayindizes besteht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F9
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Legt fest, dass eine Sortierung ein Array zurückgibt, der aus Arrayindizes besteht. Diese Konstante können Sie für den Parameter <codeph>options</codeph> in den Methoden <codeph>sort()</codeph> oder <codeph>sortOn()</codeph> verwenden, sodass Sie Zugriff auf mehrere Ansichten zu Arrayelementen haben, während das Originalarray unverändert bleibt. 
 	 <p>Diese Konstante hat den Wert 8.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:UNIQUESORT"><apiName>UNIQUESORT</apiName><shortdesc>
     Legt als Sortiermethode für die Array-Klasse eine eindeutige Sortierreihenfolge fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217FA
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Legt als Sortiermethode für die Array-Klasse eine eindeutige Sortierreihenfolge fest. Sie können diese Konstante als Wert für den <codeph>options</codeph>-Parameter in der Methode <codeph>sort()</codeph> oder <codeph>sortOn()</codeph> verwenden. Bei der eindeutigen Sortierung wird der Vorgang beendet, sobald zwei beliebige zu sortierende Elemente bzw. Felder den gleichen Wert enthalten. 
	 <p>Diese Konstante hat den Wert 4.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:length:get"><apiName>length</apiName><shortdesc>
	 Eine nicht negative Ganzzahl, die die Anzahl von Elementen im Array angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Eine nicht negative Ganzzahl, die die Anzahl von Elementen im Array angibt. Diese Eigenschaft wird automatisch aktualisiert, wenn dem Array neue Elemente hinzugefügt werden. Sobald Sie einem Arrayelement einen Wert zuweisen (z. B. <codeph>my_array[index] = value</codeph>) und wenn <codeph>index</codeph> eine Zahl und <codeph>index+1</codeph> größer als die <codeph>length</codeph>-Eigenschaft ist, wird die <codeph>length</codeph>-Eigenschaft auf <codeph>index+1</codeph> aktualisiert.
   	 <p><b>Hinweis: </b>Wenn Sie der <codeph>length</codeph>-Eigenschaft einen Wert zuweisen, der kleiner ist als die tatsächliche Länge des Arrays, wird das Array abgeschnitten.</p>
   	 
	 </apiDesc><example conref="examples\Array.length.1.as"> Mit dem folgenden Code wird ein Array-Objekt <codeph>names</codeph> mit dem Element <codeph>Bill</codeph> erstellt. Anschließend wird mithilfe der <codeph>push()</codeph>-Methode das String-Element <codeph>Kyle</codeph> hinzugefügt. Die Länge des Arrays, die durch die <codeph>length</codeph>-Eigenschaft bestimmt wird, betrug ein Element bevor f <codeph>push()</codeph> angewendet wurde; nach dem Aufrufen von <codeph>push()</codeph> beträgt sie zwei Elemente. Ein weiterer String, <codeph>Jeff</codeph>, wird hinzugefügt, damit <codeph>names</codeph> eine Länge von drei Elementen hat. Anschließend wird die <codeph>shift()</codeph>-Methode zweimal aufgerufen, um <codeph>Bill</codeph> und <codeph>Kyle</codeph> zu entfernen. Abschließend hat <codeph>length</codeph> eine Länge von eins.
<codeblock>

var names:Array = new Array("Bill");
names.push("Kyle");
trace(names.length); // 2

names.push("Jeff");
trace(names.length); // 3

names.shift();
names.shift();
trace(names.length); // 1
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:RegExp"><apiName>RegExp</apiName><shortdesc>
     
     Die RegExp-Klasse ermöglicht Ihnen den Einsatz regulärer Ausdrücke. Reguläre Ausdrücke sind Muster, die Sie in Such- und Ersetzungsvorgängen in Strings verwenden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp
     </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     
     Die RegExp-Klasse ermöglicht Ihnen den Einsatz regulärer Ausdrücke. Reguläre Ausdrücke sind Muster, die Sie in Such- und Ersetzungsvorgängen in Strings verwenden können.
     
     <p>Ein neues RegExp-Objekt erstellen Sie mithilfe des Konstruktors <codeph>new RegExp()</codeph> oder per Zuweisung eines RegExp-Literals zu einer Variable:</p>
     
     <codeblock> var pattern1:RegExp = new RegExp("test-\\d", "i");
     var pattern2:RegExp = /test-\d/i;
     </codeblock>
     
     <p>Weitere Informationen finden Sie im Kapitel „Reguläre Ausdrücke“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
     
     </apiDesc><example conref="examples\RegExpExample.as"> Aus diesem Beispiel geht hervor, wie Sie mithilfe von regulären Ausdrücken Strings parsen und einen neuen String oder einen booleschen Wert, der auf dem übergebenen String basiert, zurückgeben. Die <codeph>informalizeGreeting()</codeph>-Methode ersetzt einfach das Wort<codeph>Hello</codeph> durch <codeph>Hi</codeph>, wobei die Groß- oder Kleinschreibung keine Rolle spielt. Außerdem wird der Nachname aus dem Namen im String entfernt (vorausgesetzt, dass der Name dem angegebenen Muster entspricht). In den <codeph>validateEmail()</codeph>- und <codeph>validatePhoneNumber()</codeph>-Methoden wird der übergebene String wird überprüft, um zu sehen, ob sein Muster einer gültigen E-Mail-Adresse oder einem bestimmten Telefonnummernmuster entspricht. Auf der Grundlage der Ergebnisse geben die Methoden boolesche Werte zurück. 
<codeblock>
package {
    import flash.display.Sprite;

    public class RegExpExample extends Sprite {        
        public function RegExpExample() {            
            var formalGreeting:String = "Hello, John Smith.";
            trace(informalizeGreeting(formalGreeting));    // Hi, John.

            var validEmail:String = "name@domain.com";
            trace(validateEmail(validEmail));        // true
            
            var invalidEmail:String = "foo";
            trace(validateEmail(invalidEmail));  // false
            
            var validPhoneNumber:String = "415-555-1212";
            trace(validatePhoneNumber(validPhoneNumber));    // true
            
            var invalidPhoneNumber:String = "312-867-530999";
            trace(validatePhoneNumber(invalidPhoneNumber));  // false
        }
        private function informalizeGreeting(str:String):String {
            var pattern:RegExp = new RegExp("hello, (\\w+) \\w+", "i");
            return str.replace(pattern, "Hi, $1");
        }
        private function validateEmail(str:String):Boolean {
            var pattern:RegExp = /(\w|[_.\-])+@((\w|-)+\.)+\w{2,4}+/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
        private function validatePhoneNumber(str:String):Boolean {
            var pattern:RegExp = /^\d{3}-\d{3}-\d{4}$/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/replace()"><linktext>String.replace()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links><apiConstructor id="RegExp:RegExp"><apiName>RegExp</apiName><shortdesc>
        Dient zur Erstellung eines regulären Ausdrucks aus zwei Strings.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.attribute, attribute
        </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>re</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Das Muster des regulären Ausdrucks (wird auch <i>Konstruktorstring</i> genannt). Dies ist der Hauptteil des regulären Ausdrucks (der Teil, der innerhalb der Schrägstriche („/“) vorkommt). 
        
        <p><b>Hinweise:</b> </p>
        
        <ul>
        
        <li>Die einleitenden und abschließenden Schrägstriche („/“) dürfen Sie nicht einbinden. Sie werden nur eingesetzt, wenn Sie ein reguläres Ausdrucksliteral definieren, ohne den Konstruktor zu verwenden. Die beiden folgenden regulären Ausdrücke sind beispielsweise gleichwertig:
        
        <codeblock> var re1:RegExp = new RegExp("bob", "i"); 
        var re2:RegExp = /bob/i;</codeblock>
        
        </li>
        
        <li>Um in einem regulären Ausdruck, der mit der Konstruktormethode <codeph>RegExp()</codeph> definiert wird, eine Metasequenz zu verwenden, die mit dem rückwärtigen Schrägstrich (\) beginnt, z. B. <codeph>\d</codeph> (was einer beliebigen Ziffer entspricht), geben Sie den rückwärtigen Schrägstrich zweimal ein. Die beiden folgenden regulären Ausdrücke sind beispielsweise gleichwertig:
        
        <codeblock> var re1:RegExp = new RegExp("\\d+", ""); 
        var re2:RegExp = /\d/;</codeblock>
        
        <p>Im ersten Ausdruck müssen Sie in diesem Fall den rückwärtigen Schrägstrich zweimal eingeben, da der erste Parameter der Konstruktormethode <codeph>RegExp()</codeph> ein String ist und in einem Stringliteral ein rückwärtiger Schrägstrich zweimal eingegeben werden muss, damit er als einfacher rückwärtiger Schrägstrich erkannt wird.</p>
        
        </li>
        
        </ul>
        
        </apiDesc></apiParam><apiParam><apiItemName>flags</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Modifizierer des regulären Ausdrucks. Dazu zählen die folgenden Zeichen:
        
        <ul>
        
           <li> <codeph>g</codeph> – Wenn Sie die <codeph>replace()</codeph>-Methode der String-Klasse verwenden, geben Sie diesen Modifizierer an, um alle Übereinstimmungen zu ersetzen und nicht nur die erste. Dieser Modifizierer entspricht der Eigenschaft <codeph>global</codeph> der RegExp-Instanz.</li>
           <li> <codeph>i</codeph> – Der reguläre Ausdruck wird <i>ohne</i> Berücksichtigung der Groß-/Kleinschreibung ausgewertet. Dieser Modifizierer entspricht der Eigenschaft <codeph>ignoreCase</codeph> der RegExp-Instanz.</li>
           <li> <codeph>s</codeph> – Der Punkt (<codeph>.</codeph>) sucht nach Zeilenumbruchzeichen. Hinweis: Dieser Modifizierer entspricht der Eigenschaft <codeph>dotall</codeph> der RegExp-Instanz.</li>
           <li> <codeph>m</codeph> – Das Caretzeichen (<codeph>^</codeph>) und das Dollarzeichen (<codeph>$</codeph>) stimmen vor <i>und</i> nach einem Zeilenumbruch überein. Dieser Modifizierer entspricht der Eigenschaft <codeph>multiline</codeph> der RegExp-Instanz.</li>
           <li> <codeph>x</codeph> – Leerraumzeichen im <codeph>re</codeph>-String werden ignoriert, sodass Sie besser lesbare Konstruktoren schreiben können. Dieser Modifizierer entspricht der Eigenschaft <codeph>extended</codeph> der RegExp-Instanz.</li>
        
        </ul>
        
        <p>Alle anderen Zeichen im <codeph>flags</codeph>-String werden ignoriert. </p>
        
        </apiDesc></apiParam></apiConstructorDef><apiDesc>
        Dient zur Erstellung eines regulären Ausdrucks aus zwei Strings. Ein String definiert das Muster des regulären Ausdrucks, und der zweite definiert die im regulären Ausdruck verwendeten Flags. 
        
        </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="RegExp:AS3:exec"><apiName>exec</apiName><shortdesc>
         Führt in dem gegebenen String „str“ eine Suche nach dem regulären Ausdruck durch.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.exec, exec
         </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>null</codeph>, wenn keine Übereinstimmung gefunden wird; andernfalls ein Objekt mit einer der folgenden Eigenschaften: 
         
         <ul>
         
          <li>Ein Array, in dem Element 0 den vollständigen, übereinstimmenden Teilstring enthält, und dessen andere Elemente (1 bis <i>n</i>) Teilstrings enthalten, die in Klammern eingeschlossenen Gruppen im regulären Ausdruck entsprechen </li>
         
          <li><codeph>index</codeph> – Die Zeichenposition des übereinstimmenden Teilstrings innerhalb des Strings</li>
         
          <li><codeph>input</codeph> – Der String (<codeph>str</codeph>)</li>
         
         </ul>
         
         
         </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, der durchsucht werden soll.  
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Führt in dem gegebenen String <codeph>str</codeph> eine Suche nach dem regulären Ausdruck durch. 
         
         <p>Ist das <codeph>g</codeph>-Flag (<codeph>global</codeph>) für den regulären Ausdruck <i>not</i> gesetzt, so beginnt die Suche am Anfang des Strings (bei Indexposition 0); die Suche ignoriert die <codeph>lastIndex</codeph>-Eigenschaft des regulären Ausdrucks.</p>
         
         <p>Ist das <codeph>g</codeph>-Flag (<codeph>global</codeph>) für den regulären Ausdruck <i>gesetzt</i>, so beginnt die Suche bei der Indexposition, die durch die <codeph>lastIndex</codeph>-Eigenschaft des regulären Ausdrucks angegeben wird. Wird nach einem Teilstring gesucht, ändert sich die <codeph>lastIndex</codeph>-Eigenschaft so, dass sie der Position des Endes der Übereinstimmung entspricht. </p>
         
         </apiDesc><example>Wenn das <codeph>g</codeph>-Flag (<codeph>global</codeph>) im regulären Ausdruck <i>nicht</i> gesetzt ist, können Sie mit <codeph>exec()</codeph> nach der ersten Übereinstimmung im String suchen: 
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;   
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         trace(result);
         </codeblock>
         
         <p> Das <codeph>result</codeph>-Objekt wird auf folgende Werte gesetzt:</p>
         
         <ul>
         
          <li> <codeph>result[0]</codeph> wird auf <codeph>"She"</codeph> gesetzt (die vollständige Übereinstimmung). </li>
         
          <li> <codeph>result[1]</codeph> wird auf einen leeren String gesetzt (die erste übereinstimmende in Klammern eingeschlossene Gruppe). </li>
         
          <li> <codeph>result[2]</codeph> wird auf <codeph>"e"</codeph> gesetzt (die zweite übereinstimmende in Klammern eingeschlossene Gruppe). </li>
         
          <li> <codeph>result.index</codeph> wird auf 0 gesetzt.</li>
         
          <li> <codeph>result.input</codeph> wird auf den Eingabestring gesetzt: <codeph>"She sells seashells by the seashore"</codeph>.</li>
         
         </ul> 
         
         
         
         <p> Im folgenden Beispiel wird das <codeph>g</codeph>-Flag (<codeph>global</codeph>) im regulären Ausdruck <i>gesetzt</i>, sodass Sie <codeph>exec()</codeph> wiederholt verwenden können, um mehrere Übereinstimmungen zu finden:</p>
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;  
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         
         while (result != null) {
             trace ( result.index, "\t", result);
             result = myPattern.exec(str);
         }
         </codeblock>
         
         <p> Der Code ergibt die folgende Ausgabe.</p>
         
         <pre><codeph>
            0      She,,e
            10     seashells,sea,ells
            27     seashore,sea,ore
         </codeph></pre>
         
         </example></apiOperationDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links></apiOperation><apiOperation id="RegExp:AS3:test"><apiName>test</apiName><shortdesc>
         Testet in dem gegebenen String „str“ auf Übereinstimmung mit dem regulären Ausdruck.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.test, test
          
          </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>true</codeph>, wenn es eine Übereinstimmung gibt; andernfalls <codeph>false</codeph>.
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der zu testende String.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Prüft den gegebenen String <codeph>str</codeph> auf eine Übereinstimmung mit dem regulären Ausdruck. 
         
         <p>Ist das <codeph>g</codeph>-Flag (<codeph>global</codeph>) für den regulären Ausdruck <i>not</i> gesetzt, so beginnt die Suche am Anfang des Strings (bei Indexposition 0); die Suche ignoriert die <codeph>lastIndex</codeph>-Eigenschaft des regulären Ausdrucks.</p>
         
         <p>Ist das <codeph>g</codeph>-Flag (<codeph>global</codeph>) für den regulären Ausdruck <i>gesetzt</i>, so beginnt die Suche bei der Indexposition, die durch die <codeph>lastIndex</codeph>-Eigenschaft des regulären Ausdrucks angegeben wird. Wird nach einem Teilstring gesucht, ändert sich die <codeph>lastIndex</codeph>-Eigenschaft so, dass sie der Position des Endes der Übereinstimmung entspricht. </p>
         
         </apiDesc><example conref="examples\RegExp.test.1.as"> Das folgende Beispiel veranschaulicht die Verwendung der <codeph>test()</codeph>-Methode bei einem regulären Ausdruck, in dem das <codeph>g</codeph>-Flag (<codeph>global</codeph>) wie folgt gesetzt ist: 
<codeblock>
var re1:RegExp = /\w/g;
var str:String = "a b c";
trace (re1.lastIndex); // 0
trace (re1.test(str)); // true
trace (re1.lastIndex); // 1
trace (re1.test(str)); // true
trace (re1.lastIndex); // 3
trace (re1.test(str)); // true
trace (re1.lastIndex); // 5
trace (re1.test(str)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="RegExp:dotall:get"><apiName>dotall</apiName><shortdesc>
         Gibt an, ob ein Punkt (.) in einem regulären Ausdruck nach Zeilenumbrüchen sucht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.dotall, dotall
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Gibt an, ob ein Punkt (.) in einem regulären Ausdruck nach Zeilenumbrüchen sucht. Verwenden Sie das <codeph>s</codeph>-Flag, um einen regulären Ausdruck zu erstellen, der <codeph>dotall = true</codeph> setzt.
         
         </apiDesc><example conref="examples\RegExp.dotall.1.as"> Aus dem folgenden Beispiel geht die Wirkung des <codeph>s</codeph>-Flags (<codeph>dotall</codeph>) bei einem regulären Ausdruck hervor: 
<codeblock>
var str:String = "&lt;p>Hello\n"
        + "again&lt;/p>"
        + "&lt;p>Hello&lt;/p>";

var pattern:RegExp = /&lt;p>.*?&lt;\/p>/;
trace(pattern.dotall) // false
trace(pattern.exec(str)); // &lt;p>Hello&lt;/p>

pattern = /&lt;p>.*?&lt;\/p>/s;
trace(pattern.dotall) // true
trace(pattern.exec(str)); 
   </codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:extended:get"><apiName>extended</apiName><shortdesc>
         Gibt an, ob für den regulären Ausdruck der erweiterte Modus verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.extended, extended
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Gibt an, ob für den regulären Ausdruck der erweiterte Modus verwendet werden soll. Befindet sich ein RegExp-Objekt im erweiterten Modus, werden Leerraumzeichen im Konstruktorstring ignoriert. Dadurch können die Konstruktoren lesbarer gestaltet werden.
         
         <p>Verwenden Sie das <codeph>x</codeph>-Flag, um einen regulären Ausdruck zu erstellen, der <codeph>extended = true</codeph> setzt. </p>
         
         </apiDesc><example conref="examples\RegExp.extended.1.as"> Im folgenden Beispiel werden verschiedene Möglichkeiten gezeigt, um den gleichen regulären Ausdruck zu erstellen. In allen Fällen soll mit dem regulären Ausdruck nach dem Telefonnummernmuster xxx-xxx-xxxx oder (xxx) xxx-xxxx oder (xxx)xxx-xxxx gesucht werden. Im zweiten regulären Ausdruck wird das <codeph>x</codeph>-Flag verwendet, wodurch die Leerräume im String ignoriert werden. 
<codeblock>
var rePhonePattern1:RegExp = /\d{3}-\d{3}-\d{4}|\(\d{3}\)\s?\d{3}-\d{4}/; 
var str:String = "The phone number is (415)555-1212.";

trace(rePhonePattern1.extended) // false
trace(rePhonePattern1.exec(str)); // (415)555-1212

var rePhonePattern2:RegExp = / \d{3}-\d{3}-\d{4}  |   \( \d{3} \) \ ? \d{3}-\d{4}  /x; 
trace(rePhonePattern2.extended) // true
trace(rePhonePattern2.exec(str)); // (415)555-1212
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:global:get"><apiName>global</apiName><shortdesc>
         Gibt an, ob für den regulären Ausdruck eine globale Suche verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.global, global
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Gibt an, ob für den regulären Ausdruck eine globale Suche verwendet werden soll. Wenn <codeph>global == true</codeph>, wird die <codeph>lastIndex</codeph>-Eigenschaft gesetzt, nachdem eine Übereinstimmung gefunden wurde. Wenn das nächste Mal eine Suche ausgelöste wird, beginnt die Engine für reguläre Ausdrücke ab der Position <codeph>lastIndex</codeph> in dem String. Verwenden Sie das <codeph>g</codeph>-Flag, um einen regulären Ausdruck zu erstellen, der <codeph>global</codeph> auf <codeph>true</codeph> setzt. 
         
         </apiDesc><example conref="examples\RegExp.global.1.as"> Aus dem folgenden Beispiel geht die Wirkung des <codeph>g</codeph>-Flags (<codeph>global</codeph>) auf die <codeph>exec()</codeph>-Methode hervor:
<codeblock>
var pattern:RegExp = /foo\d/; 
var str:String = "foo1 foo2";
trace(pattern.global); // false
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 0
trace(pattern.exec(str)); // foo1

pattern = /foo\d/g;
trace(pattern.global); // true
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 4
trace(pattern.exec(str)); // foo2
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:ignoreCase:get"><apiName>ignoreCase</apiName><shortdesc>
         Gibt an, ob der reguläre Ausdruck die Groß-/Kleinschreibung ignoriert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.ignoreCase, ignoreCase
         </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Gibt an, ob der reguläre Ausdruck die Groß-/Kleinschreibung ignoriert. Verwenden Sie das <codeph>i</codeph>-Flag, um einen regulären Ausdruck zu erstellen, der <codeph>ignoreCase = true</codeph> setzt. 
         
         </apiDesc><example conref="examples\RegExp.ignoreCase.1.as"> Aus dem folgenden Beispiel geht hervor, welche Wirkung das Setzen des <codeph>i</codeph>-Flags (<codeph>ignoreCase</codeph>) hat:
<codeblock>
var pattern:RegExp = /bob/; 
var str:String = "Bob bob";
trace(pattern.ignoreCase); // false
trace(pattern.exec(str)); // bob

pattern = /bob/i;
trace(pattern.ignoreCase); // true
trace(pattern.exec(str)); // Bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:lastIndex:get"><apiName>lastIndex</apiName><shortdesc>
         Gibt die Indexposition im String an, ab der die nächste Suche beginnen soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.lastIndex, lastIndex
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
         Gibt die Indexposition im String an, ab der die nächste Suche beginnen soll. Diese Eigenschaft wirkt sich auf die <codeph>exec()</codeph>- und <codeph>test()</codeph>-Methode der RegExp-Klasse aus. Allerdings ignorieren die <codeph>match()</codeph>-, <codeph>replace()</codeph>- und <codeph>search()</codeph>-Methoden der String-Klasse die <codeph>lastIndex</codeph>-Eigenschaft und beginnen die Suche immer ab dem Anfang eines Strings.
         
         <p>Wenn die <codeph>exec()</codeph>- oder <codeph>test()</codeph>-Methode eine Übereinstimmung findet, und das <codeph>g</codeph>-Flag (<codeph>global</codeph>) für diesen regulären Ausdruck auf <codeph>true</codeph> gesetzt ist, setzt die Methode automatisch die <codeph>lastIndex</codeph>-Eigenschaft auf die Indexposition des Zeichens <i>nach</i> dem letzten Zeichen im gefundenen passenden Teilstring der letzten Suche. Ist das <codeph>g</codeph>-Flag (<codeph>global</codeph>) auf <codeph>false</codeph> gesetzt, wird die <codeph>lastIndex</codeph>-Eigenschaft von der Methode nicht gesetzt.</p>
         
         <p>Sie können die <codeph>lastIndex</codeph>-Eigenschaft setzen, um die Anfangsposition in dem String zu setzen, in dem nach einem regulären Ausdruck gesucht werden soll. </p>
         
         </apiDesc><example conref="examples\RegExp.lastIndex.1.as"> Aus dem folgenden Beispiel geht hervor, welche Wirkung das Setzen der <codeph>lastIndex</codeph>-Eigenschaft hat. Außerdem wird gezeigt, wie sie nach einem Aufruf der <codeph>exec()</codeph>-Methode bei einem regulären Ausdruck aktualisiert wird, in dem das <codeph>g</codeph>-Flag (<codeph>global</codeph>) gesetzt wurde:
<codeblock>
var pattern:RegExp = /\w\d/g; 
var str:String = "a1 b2 c3 d4";
pattern.lastIndex = 2; 
trace(pattern.exec(str)); // b2
trace(pattern.lastIndex); // 5
trace(pattern.exec(str)); // c3
trace(pattern.lastIndex); // 8
trace(pattern.exec(str)); // d4
trace(pattern.lastIndex); // 11
trace(pattern.exec(str)); // null
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:multiline:get"><apiName>multiline</apiName><shortdesc>
         Gibt an, ob das m-Flag (multiline) gesetzt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.multiline, multiline
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Gibt an, ob das <codeph>m</codeph>-Flag (<codeph>multiline</codeph>) gesetzt wurde. Ist das Flag gesetzt, wird mit dem Caret- (<codeph>^</codeph>) und dem Dollarzeichen (<codeph>$</codeph>) in einem regulären Ausdruck nach Übereinstimmungen vor und nach einem Zeilenumbruch gesucht. Verwenden Sie das <codeph>m</codeph>-Flag, um einen regulären Ausdruck zu erstellen, der <codeph>multiline = true</codeph> setzt.
         
         </apiDesc><example conref="examples\RegExp.multiline.1.as"> Aus dem folgenden Beispiel geht hervor, welche Wirkung das Setzen des <codeph>m</codeph>-Flags (<codeph>multiline</codeph>) hat:
<codeblock>
var pattern:RegExp = /^bob/; 
var str:String = "foo\n"
                + "bob";
trace(pattern.multiline); // false
trace(pattern.exec(str)); // null

pattern = /^bob/m;
trace(pattern.multiline); // true
trace(pattern.exec(str)); // bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:source:get"><apiName>source</apiName><shortdesc>
         Gibt das Muster des regulären Ausdrucks an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.source, source
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Gibt das Muster des regulären Ausdrucks an.
         
         </apiDesc><example conref="examples\RegExp.source.1.as"> Der folgende Code gibt den <codeph>source</codeph>-Parameter für zwei reguläre Ausdrücke aus:
<codeblock>
var re1:RegExp = /aabb/gi;
trace (re1.source); // aabb

var re2:RegExp = new RegExp("x+y*", "i");
trace(re2.source); // x+y*
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Date"><apiName>Date</apiName><shortdesc>
 Die Date-Klasse repräsentiert Informationen zu Datum und Uhrzeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Date object, built-in class, date 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Date-Klasse repräsentiert Informationen zu Datum und Uhrzeit. Eine Instanz der Date-Klasse repräsentiert einen bestimmten Zeitpunkt, für den Eigenschaften wie month, day, hours und seconds abgefragt oder geändert werden können. Mit der Date-Klasse können Sie Werte abrufen für Datum und Uhrzeit relativ zur Weltzeit (GMT, heute als Koordinierte Weltzeit, UTC bezeichnet) oder relativ zur Ortszeit, die von der Einstellung für die aktuelle Zeitzone des Betriebssystems bestimmt wird, auf dem Flash Player ausgeführt wird. Die Methoden der Date-Klasse sind nicht statisch, sondern gelten nur für das jeweilige Date-Objekt, das beim Aufruf der Methode angegeben wird. Die Methoden <codeph>Date.UTC()</codeph> und <codeph>Date.parse()</codeph> sind Ausnahmen; es handelt sich um statische Methoden.
 <p product="flash">Wie die Sommerzeit von der Date-Klasse behandelt wird, hängt vom Betriebssystem und der Flash Player-Version ab. Flash Player behandelt ab Version 6 die Sommerzeit auf den folgenden Betriebssystemen auf folgende Art:</p>
 <ul product="flash">
 <li>Windows: Das Date-Objekt passt seine Ausgabe automatisch an die Sommerzeit an. Das Date-Objekt ermittelt, ob für das aktuelle Gebietsschema Sommerzeit Gültigkeit hat, und wenn ja, wann die Umstellung auf Sommer- bzw. Winterzeit erfolgt. Die derzeit verwendeten Umstellungstermine werden jedoch auch auf Datumswerte in der Vergangenheit und Zukunft angewendet, sodass bei in der Vergangenheit liegenden Datumswerten, zu denen für das Gebietsschema andere Umstellungstermine galten, der Sommerzeitausgleich u. U. falsch berechnet wird.</li>
 <li>Mac OS X: Das Date-Objekt passt seine Ausgabe automatisch an die Sommerzeit an. Anhand der Zeitzonendatenbank in Mac OSX wird ermittelt, ob für in der Gegenwart oder Vergangenheit liegende Datums- oder Uhrzeitwerte ein Sommerzeitausgleich erfolgen soll.</li>
 <li>Mac OS 9: Das Betriebssystem stellt nur Informationen bereit, anhand derer ermittelt werden kann, ob auf das aktuelle Datum und die aktuelle Uhrzeit ein Sommerzeitausgleich angewendet werden soll. Demzufolge geht das Date-Objekt davon aus, dass der aktuelle Sommerzeitausgleich für alle vergangenen und künftigen Datums- und Uhrzeitwerte gilt.</li>
 </ul>
 <p product="flash">Flash Player 5 behandelt die Sommerzeit auf den verschiedenen Betriebssystemen wie folgt:</p>
 <ul product="flash">
 <li>Windows: Die US-Sommerzeitregeln finden immer Anwendung, was u. U. zu falschen Umstellungsterminen in Europa und anderen Regionen mit Sommerzeit führt. Ob im aktuellen Gebietsschema Sommerzeit verwendet wird, wird von Flash korrekt erkannt.</li>
 </ul>
 <p>Um die Date-Klasse zu verwenden, erstellen Sie mithilfe des Operators <codeph>new</codeph> eine Date-Instanz.</p>
 <p>ActionScript 3.0 stellt mehrere neue accessor-Eigenschaften bereit, die anstelle der vielen Methoden der Date-Klasse verwendet werden können, die auf Date-Instanzen zugreifen oder sie verändern. ActionScript 3.0 umfasst auch folgende neue Variationen der Methode <codeph>toString()</codeph>, die zur Norm ECMA-262, 3rd Edition, gehören: <codeph>Date.toLocaleString()</codeph>, <codeph>Date.toTimeString()</codeph>, <codeph>Date.toLocaleTimeString()</codeph>, <codeph>Date.toDateString()</codeph> und <codeph>Date.toLocaleDateString()</codeph>.</p>
 <p>Wie Sie die relative oder verstrichene Zeit berechnen, erfahren Sie im Abschnitt über die Methode <codeph>getTimer()</codeph> im flash.utils-Paket.</p>
 
 </apiDesc><example conref="examples\DateExample.as"> Das folgende Beispiel veranschaulicht verschiedene Möglichkeiten, wie Sie mit dem <codeph>Date()</codeph>-Konstruktor die folgenden Variablen zuweisen können:
 <ul>
   <li><codeph>myDate1</codeph> ruft <codeph>Date()</codeph> ohne Parameter auf, wodurch <codeph>myDate1</codeph> auf das aktuelle Datum und die aktuelle Uhrzeit gesetzt wird (gemäß der aktuellen Datums- und Uhrzeiteinstellung des System). </li>
   <li><codeph>myDate2</codeph> ruft <codeph>Date()</codeph> auf, wobei die Parameter <codeph>year</codeph> (<codeph>2000</codeph>), month (<codeph>0</codeph> = Januar) und <codeph>day</codeph> (<codeph>1</codeph>) übergeben werden.</li>
   <li><codeph>myDate3</codeph> ruft <codeph>Date()</codeph> mit <codeph>year</codeph> (<codeph>65</codeph> = 1965), <codeph>month</codeph> (<codeph>2</codeph> = März) auf, wobei <codeph>day</codeph> (<codeph>6</codeph>), <codeph>hour</codeph> (<codeph>9</codeph>), <codeph>minute</codeph> (<codeph>30</codeph>), <codeph>second</codeph> (<codeph>15</codeph>) und <codeph>millisecond</codeph>-+ (<codeph>0</codeph>) als Parameter übergeben werden.</li>
   <li><codeph>myDate4</codeph> ruft <codeph>Date()</codeph> auf, wobei der Zeitwert die Anzahl der Millisekunden <b>vor</b> (da dieser Wert negativ ist) dem 1. Januar 1970, 0.00 Uhr GMT angibt.</li>
 </ul>
<codeblock>

package {
    import flash.display.Sprite;
    
    public class DateExample extends Sprite{
        public function DateExample() {
            var myDate1:Date = new Date();
            trace(myDate1); // [NOW]

            var myDate2:Date = new Date(2000, 0, 1);
            trace(myDate2); // Sat Jan 1 00:00:00 GMT-0800 2000

            var myDate3:Date = new Date(65, 2, 6, 9, 30, 15, 0);
            trace(myDate3); // Sat Mar 6 09:30:15 GMT-0800 1965

            var myDate4:Date = new Date(-14159025000);
            trace(myDate4); // Sun Jul 20 19:56:15 GMT-0700 1969
        }        
    }    
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#/getTimer()"><linktext>flash.utils.getTimer()</linktext></link></related-links><apiConstructor id="Date:Date"><apiName>Date</apiName><shortdesc>
	 Erstellt ein neues Date-Objekt mit dem angegebenen Datum und der angegebenen Uhrzeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new Date, constructor, date
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>yearOrTimevalue</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Wenn andere Parameter angegeben werden, stellt diese Zahl das Jahr (z. B. 1965), andernfalls einen Zeitwert dar. Wenn es sich um eine Jahresangabe handelt, steht ein Wert von 0 bis 99 für eine Jahreszahl zwischen 1900 und 1999, andernfalls müssen alle vier Ziffern der Jahreszahl angegeben werden. Stellt diese Zahl dagegen einen Zeitwert dar (ohne die Angabe anderer Parameter), so ist die Anzahl der Millisekunden vor bzw. nach dem 1. Januar 1970, 0.00 Uhr GMT gemeint. Ein negativer Wert bezieht sich auf die Zeit <i>vor</i> dem 1. Januar 1970, 0.00 Uhr GMT, ein positiver Wert auf eine Zeit danach.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Januar) bis 11 (Dezember).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Eine Ganzzahl von 1 bis 31. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 (Mitternacht) bis 23 (23.00 Uhr).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 bis 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 bis 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 bis 999 Millisekunden. 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues Date-Objekt mit dem angegebenen Datum und der angegebenen Uhrzeit.  
	 
	 <p>Dem <codeph>Date()</codeph>-Konstruktor können bis zu sieben Parameter (year, month, ..., millisecond) übergeben werden, um ein Datum und die Uhrzeit bis hin zu den Millisekunden anzugeben. Das Datum, das das neu erstellte Date-Objekt enthält, hängt von der übergebenen Zahl, dem Datentyp und den Argumenten ab. </p>
	 <ul>
	   <li>Wenn Sie keine Argumente übergeben, werden dem Date-Objekt das aktuelle Datum und die aktuelle Uhrzeit zugewiesen.</li>
	   <li>Wenn Sie ein Argument des Datentyps Number übergeben, wird dem Date-Objekt ein Zeitwert zugewiesen, der der Anzahl an Millisekunden entspricht, die seit dem 1. Januar 1970 0:00:000 GMT verstrichen sind, wie es im lone-Argument angegeben ist.</li>
	   <li>Wenn Sie ein Argument des Datentyps String übergeben, enthält der String ein gültiges Datum und das Date-Objekt enthält einen auf diesem Datum basierenden Zeitwert.</li>
	   <li>Wenn Sie zwei oder mehrere Argumente übergeben, wird dem Date-Objekt ein Zeitwert zugewiesen, der auf den übergebenen Argumentwerten basiert, die das Jahr, den Monat, den Tag, die Stunde, die Minute, die Sekunde und die Millisekunde des Datums repräsentieren.</li>
	 </ul>
	 <p>Wenn Sie an den Date-Klassenkonstruktor einen String übergeben, kann das Datum eine Vielzahl von Formaten annehmen, muss aber mindestens, den Monat, den Tag und das Jahr enthalten. So wäre <codeph>Feb 1 2005</codeph> beispielsweise ein zulässiger Datumswert, <codeph>Feb 2005</codeph> aber nicht. Die folgende Liste zeigt einige zulässige Formate auf:</p>
	 <ul>
	   <li>Wochentag Monat Tag Stunde:Minute:Sekunde GMT Jahr (z. B. „Tue Feb 1 00:00:00 GMT-0800 2005“, was dem <codeph>toString()</codeph>-Format entspricht)</li>
	   <li>Wochentag Monat Tag Jahr Stunde:Minute:Sekunde AM/PM (z. B. „Tue Feb 1 2005 12:00:00 AM“, was dem <codeph>toLocaleString()</codeph>-Format entspricht)</li>
	   <li>Wochentag Monat Tag Jahr (z. B. „Tue Feb 1 2005“, was dem <codeph>toDateString()</codeph>-Format entspricht)</li>
	   <li>Monat/Tag/Jahr (z. B. „02/01/2005“)</li>
	   <li>Monat/Jahr (z. B. „02/2005“)</li>
	 </ul>
	 </apiDesc></apiConstructorDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiConstructor><apiOperation id="Date:UTC"><apiName>UTC</apiName><shortdesc>
	 Gibt die Anzahl von Millisekunden zurück, die zwischen dem 1. Januar 1970, 0.00 Uhr Weltzeit, und der in den Parametern angegebenen Zeit vergangen sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.utc, utc, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Die Anzahl von Millisekunden seit dem 1. Januar 1970 und dem angegebenen Datum und der Uhrzeit.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine vierstellige Ganzzahl, die das Jahr darstellt (z. B. 2000).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Januar) bis 11 (Dezember).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Eine Ganzzahl von 1 bis 31. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 (Mitternacht) bis 23 (23.00 Uhr).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 bis 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 bis 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl von 0 bis 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt die Anzahl von Millisekunden zurück, die zwischen dem 1. Januar 1970, 0.00 Uhr Weltzeit, und der in den Parametern angegebenen Zeit vergangen sind. Diese Methode verwendet Weltzeit, während der Konstruktor <codeph>Date</codeph> Ortszeit verwendet.
	 <p>Diese Methode ist nützlich, wenn Sie ein UTC-Datum an den Date-Klassenkonstruktor übergeben. Da der Date-Klassenkonstruktor den Zeitabstand in Millisekunden als Argument akzeptiert, können Sie mithilfe der Methode Date.UTC() Ihr UTC-Datum in den entsprechenden Zeitabstand in Millisekunden konvertieren und diesen Zeitabstand dann als Argument an den Date-Klassenkonstruktor senden.</p>
	 
	 </apiDesc><example conref="examples\Date.UTC.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) in Ortszeit erstellt. Durch das Aufrufen von <codeph>UTC()</codeph> innerhalb einer <codeph>setTime()</codeph>-Methode werden die gleichen Parameter auf Weltzeit gesetzt.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);
trace(someBirthday.toString());

someBirthday.setTime(Date.UTC(1974, 10, 30, 15, 20));
trace(someBirthday.toString());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getDate"><apiName>getDate</apiName><shortdesc>
	 Gibt den von einem Date-Objekt gemäß der Ortszeit angegebenen Tag des Monats (eine Ganzzahl von 1 bis 31) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getdate, getdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Tag des Monats (1 - 31), den ein <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den von einem <codeph>Date</codeph>-Objekt gemäß der Ortszeit angegebenen Tag des Monats (eine Ganzzahl von 1 bis 31) zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
 	 </apiDesc><example conref="examples\Date.getDate.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getDate()</codeph>-Methode aufgerufen, die den Tag des Monats abruft.
<codeblock>
package {
    import flash.display.Sprite;

    public class DateExample extends Sprite {

        public function DateExample() {
            var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
            trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
            trace(someBirthday.getDate()); // 30
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getDay"><apiName>getDay</apiName><shortdesc>
	 Gibt den von dem Date-Objekt gemäß der Ortszeit angegebenen Wochentag zurück (0 für Sonntag, 1 für Montag usw.).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getday, getday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine numerische Version des Tags der Woche (0 - 6), die ein <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den von dem <codeph>Date</codeph>-Objekt gemäß der Ortszeit angegebenen Wochentag zurück (0 für Sonntag, 1 für Montag usw.). Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
 	 </apiDesc><example conref="examples\Date.getDay.1.as"> Bei folgendem Beispiel wird ein neues Array-Objekt <codeph>weekDayLabels</codeph> mit den Elementen <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph> und ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getDay()</codeph>-Methode zweimal aufgerufen. Daraufhin wird zuerst der Tag des Monats als 6 angezeigt und dann wird der Tag der Woche mithilfe von <codeph>weekDayLabels</codeph> angezeigt.
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                       // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDay());            // 6
trace(weekDayLabels[someBirthday.getDay()]); // Saturday
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getFullYear"><apiName>getFullYear</apiName><shortdesc>
	 Gibt die vollständige Jahreszahl (eine vierstellige Zahl, z. B. 2000) eines Date-Objekts gemäß der Ortszeit zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getfullyear, getfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die vollständige Jahreszahl, die ein <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt die vollständige Jahreszahl (eine vierstellige Zahl, z. B. 2000) eines <codeph>Date</codeph>-Objekts gemäß der Ortszeit zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.getFullYear.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getFullYear()</codeph>-Methode aufgerufen, die die vierstellige Jahreszahl abruft.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getHours"><apiName>getHours</apiName><shortdesc>
	 Gibt die Stunde (eine Ganzzahl von 0 bis 23) des day-Teils eines Date-Objekts gemäß der Ortszeit zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gethours, gethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stunde des Tags (0 - 23), die ein <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt die Stunde (eine Ganzzahl von 0 bis 23) des day-Teils eines <codeph>Date</codeph>-Objekts gemäß der Ortszeit zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird. 
	 
	 </apiDesc><example conref="examples\Date.getHours.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend werden die <codeph>getHours()</codeph>- und <codeph>getMinutes()</codeph>-Methoden aufgerufen, die die Stunden und Minuten im 24-Stunden-Format abrufen. Abschließend wird ein String (<codeph>localTime</codeph>) erstellt und dem Ergebnis zugeordnet, das sich aus dem Aufruf der <codeph>getUSClockTime()</codeph>-Funktion ergibt. Daraufhin werden erneut <codeph>getHours()</codeph> und <codeph>getMinutes()</codeph> aufgerufen und schließlich wird die Uhrzeit ausgegeben: <codeph>03:05 PM</codeph>.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMilliseconds"><apiName>getMilliseconds</apiName><shortdesc>
	 Gibt den milliseconds-Teil (eine Ganzzahl von 0 bis 999) des Date-Objekts gemäß der Ortszeit zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmilliseconds, getmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der milliseconds-Teil eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den milliseconds-Teil (eine Ganzzahl von 0 bis 999) des <codeph>Date</codeph>-Objekts gemäß der Ortszeit zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.getMilliseconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getMilliseconds()</codeph>-Methode aufgerufen, die die Millisekunden des Date-Objekts <codeph>now</codeph> zum Zeitpunkt seiner Erstellung abruft.
<codeblock>

var now:Date = new Date();
trace(now.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMinutes"><apiName>getMinutes</apiName><shortdesc>
	 Gibt den minutes-Teil (eine Ganzzahl von 0 bis 59) des Date-Objekts gemäß der Ortszeit zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getminutes, getminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der minutes-Teil eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den minutes-Teil (eine Ganzzahl von 0 bis 59) des <codeph>Date</codeph>-Objekts gemäß der Ortszeit zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.getMinutes.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getMinutes()</codeph>-Methode aufgerufen, die die Minuten des Date-Objekts <codeph>now</codeph> zum Zeitpunkt seiner Erstellung abruft.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMonth"><apiName>getMonth</apiName><shortdesc>
	 Gibt den Monat (0 für Januar, 1 für Februar usw.) dieses Date-Objekts gemäß der Ortszeit zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmonth, getmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der month-Teil (0 – 11) eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den Monat (0 für Januar, 1 für Februar usw.) dieses <codeph> Date</codeph>-Objekts gemäß der Ortszeit zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.getMonth.1.as"> Im folgenden Beispiel wird ein neues Array-Objekt <codeph>monthLabels</codeph>, und zwar mit den Elementen <codeph>January</codeph> bis <codeph>December</codeph> und einem neuen Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getMonth()</codeph>-Methode zweimal aufgerufen. Dadurch wird zuerst die Zahl des Monats und dann der Name des Monats, in dem das Date-Objekt <codeph>now</codeph> erstellt wurde, zurückgegeben.
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getSeconds"><apiName>getSeconds</apiName><shortdesc>
	 Gibt den seconds-Teil (eine Ganzzahl von 0 bis 59) des Date-Objekts gemäß der Ortszeit zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getseconds, getseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der seconds-Teil (0 – 59) eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den seconds-Teil (eine Ganzzahl von 0 bis 59) des <codeph>Date</codeph>-Objekts gemäß der Ortszeit zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.getSeconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getSeconds()</codeph>-Methode aufgerufen, die die Sekunden des Date-Objekts <codeph>now</codeph> zum Zeitpunkt seiner Erstellung abruft.
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTime"><apiName>getTime</apiName><shortdesc>
	 Gibt für ein Date-Objekt die Anzahl der Millisekunden zurück, die seit dem 1. Januar 1970, 0.00 Uhr, Weltzeit, vergangen sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettime, gettime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Anzahl an Millisekunden, die zwischen dem 1. Januar 1970 und dem Datum, den das <codeph>Date</codeph>-Objekt repräsentiert, vergangen sind.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt für ein <codeph>Date</codeph>-Objekt die Anzahl der Millisekunden zurück, die seit dem 1. Januar 1970, 0.00 Uhr, Weltzeit, vergangen sind. Mit dieser Methode können Sie beim Vergleich von mindestens zwei &lt;<codeph>Date</codeph>-Objekten einen bestimmten Zeitpunkt angeben.
	 
	 </apiDesc><example conref="examples\Date.getTime.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>mlk</codeph> mit den folgenden Parametern erstellt: <codeph>year</codeph> (<codeph>1929</codeph>), <codeph>month</codeph> (<codeph>0</codeph> = January) und <codeph>day</codeph> (<codeph>15</codeph>). Anschließend wird die <codeph>getTime()</codeph>-Methode aufgerufen, die die Millisekunden seit dem 1. Januar 1970, 0.00 Uhr, abruft. Hierbei handelt es sich um einen negativen Wert, da als Jahr 1929 festgelegt wurde.
<codeblock>

var mlk:Date = new Date(1929, 0, 15);
trace(mlk);           // Tue Jan 15 00:00:00 GMT-0800 1929
trace(mlk.getTime()); // -1292601600000
</codeblock></example><example conref="examples\Date.getTime.2.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt und anschließend wird dem ursprünglichen Date-Objekt <codeph>now</codeph> mithilfe der folgenden DateMath-Klassenmethode (siehe unten) die Zeit seit seiner Erstellung hinzugefügt:
 <ul>
   <li><codeph>addSeconds()</codeph>: fügt 30 Sekunden zu <codeph>now</codeph> hinzu.</li>
   <li><codeph>addMinutes()</codeph>: fügt 30 Minuten zu <codeph>now</codeph> hinzu.</li>
   <li><codeph>addHours()</codeph>: fügt 6 Stunden zum Date-Objekt <codeph>now</codeph> hinzu.</li>
   <li><codeph>addDays()</codeph> : fügt 30 Tage zum Date-Objekt <codeph>now</codeph> hinzu.</li>
   <li><codeph>addWeeks()</codeph> : fügt 4 Wochen zu <codeph>now</codeph> hinzu.</li>
 </ul>

<codeblock>

var now:Date = new Date();
trace(now);
trace(DateMath.addSeconds(now, 30));
trace(DateMath.addMinutes(now, 30));
trace(DateMath.addHours(now, 6));
trace(DateMath.addDays(now, 30));
trace(DateMath.addWeeks(now, 4));

class DateMath {
    public static function addWeeks(date:Date, weeks:Number):Date {
        return addDays(date, weeks*7);
    }

    public static function addDays(date:Date, days:Number):Date {
        return addHours(date, days*24);
    }

    public static function addHours(date:Date, hrs:Number):Date {
        return addMinutes(date, hrs*60);
    }

    public static function addMinutes(date:Date, mins:Number):Date {
        return addSeconds(date, mins*60);
    }

    public static function addSeconds(date:Date, secs:Number):Date {
        var mSecs:Number = secs * 1000;
        var sum:Number = mSecs + date.getTime();
        return new Date(sum);
    }
}
</codeblock> <b>Hinweis</b>: Die Verwendung von getTime bei der Ausführung der Datumsarithmetik ist wichtig, da getTime auch in Schaltjahren verwendet werden kann und keine komplizierte if-Logik wie der folgende Pseudocode erfordert:
 <pre>
 function addMonths(num:Number):void {
     currentMonth = currentMonth + num;
     if(currentMonth > 12) {
         currentYear++;
         currentMonth = currentMonth - 12;
     }
 }
 </pre>
</example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTimezoneOffset"><apiName>getTimezoneOffset</apiName><shortdesc>
     Gibt die Differenz zwischen der Weltzeit (UTC) und der Ortszeit des Computers in Minuten zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettimezoneoffset, gettimezoneoffset, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Anzahl Minuten, die Sie zur Ortszeit des Computers hinzufügen müssen, damit sie gleich der Weltzeit ist. Ist die Ortszeit des Computers später als die Weltzeit, wird ein negativer Wert zurückgegeben.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Gibt die Differenz zwischen der Weltzeit (UTC) und der Ortszeit des Computers in Minuten zurück. 
	 
	 </apiDesc><example conref="examples\Date.getTimezoneOffset.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getTimezoneOffset()</codeph>-Methode aufgerufen, die die Differenz zwischen dem Zeitpunkt der Erstellung von <codeph>now</codeph> und der Weltzeit in Minuten abruft. Anschließend wird die Zeitzonenabweichung in Stunden umgewandelt, indem das Ergebnis durch 60 geteilt wird.
<codeblock>

var date:Date = new Date();
trace(date.getTimezoneOffset() / 60);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCDate"><apiName>getUTCDate</apiName><shortdesc>
	 Gibt den Tag des Monats (eine Ganzzahl von 1 bis 31) eines Date-Objekts gemäß der Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcdate, getutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Tag des Monats (1 - 31) gemäß Weltzeit (UTC), den ein <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den Tag des Monats (eine Ganzzahl von 1 bis 31) eines <codeph>Date</codeph>-Objekts gemäß der Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCDate.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getUTCDate()</codeph>-Methode aufgerufen, die den Tag des Monats gemäß der Weltzeit abruft.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);             // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCDay"><apiName>getUTCDay</apiName><shortdesc>
	 Gibt den Wochentag (0 für Sonntag, 1 für Montag usw.) dieses Date-Objekts gemäß Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcday, getutcday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Tag der Woche (0 - 6) gemäß Weltzeit (UTC), den ein <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den Wochentag (0 für Sonntag, 1 für Montag usw.) dieses <codeph>Date </codeph>-Objekts gemäß Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCDay.1.as"> Bei folgendem Beispiel wird ein neues Array-Objekt <codeph>weekDayLabels</codeph> mit den Elementen <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph> und ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getUTCDay()</codeph>-Methode zweimal aufgerufen. Daraufhin wird zuerst der Tag des Monats als 6 angezeigt und dann wird der Tag der Woche gemäß Weltzeit mithilfe von <codeph>weekDayLabels</codeph> angezeigt.
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDay()); // 6
trace(weekDayLabels[someBirthday.getUTCDay()]); // Saturday
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCFullYear"><apiName>getUTCFullYear</apiName><shortdesc>
	 Gibt die vierstellige Jahreszahl des Date-Objekts gemäß Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcfullyear, getutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die vierstellige Jahreszahl gemäß Weltzeit (UTC), die das <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt die vierstellige Jahreszahl des <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCFullYear.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getUTCFullYear()</codeph>-Methode aufgerufen, die die vierstellige Jahreszahl gemäß Weltzeit abruft.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                 // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCHours"><apiName>getUTCHours</apiName><shortdesc>
	 Gibt die Stunde (eine Ganzzahl von 0 bis 23) des Date-Objekts gemäß der Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutchours, getutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stunde (0 - 23) gemäß Weltzeit (UTC), die ein <codeph>Date</codeph>-Objekt repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt die Stunde (eine Ganzzahl von 0 bis 23) des <codeph>Date</codeph>-Objekts gemäß der Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCHours.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend werden die <codeph>getHours()</codeph>- und <codeph>getMinutes()</codeph>-Methoden aufgerufen, die die Stunden und Minuten im 24-Stunden-Format abrufen. Abschließend wird ein String (<codeph>localTime</codeph>) erstellt und dem Ergebnis zugeordnet, das sich aus dem Aufruf der <codeph>getUSClockTime()</codeph>-Funktion ergibt. Daraufhin werden erneut <codeph>getHours()</codeph> und <codeph>getMinutes()</codeph> aufgerufen und schließlich wird die Uhrzeit ausgegeben: <codeph>03:05 PM</codeph>. Abschließend wird eine String-Variable (<codeph>utcTime</codeph>) auf die gleiche Weise wie <codeph>localTime</codeph> erstellt, und in diesem Fall ist das Ergebnis identisch.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

var utcTime:String = getUSClockTime(someBirthday.getUTCHours(), someBirthday.getUTCMinutes());
trace(utcTime);      // 11:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCMilliseconds"><apiName>getUTCMilliseconds</apiName><shortdesc>
	  Gibt den milliseconds-Teil (eine Ganzzahl von 0 bis 999) eines Date-Objekts gemäß Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmilliseconds, getutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der milliseconds-Teil gemäß Weltzeit (UTC) eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Gibt den milliseconds-Teil (eine Ganzzahl von 0 bis 999) eines <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCMilliseconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCMilliseconds()</codeph>-Methode aufgerufen, die die Millisekunden des Date-Objekts <codeph>now</codeph> zum Zeitpunkt seiner Erstellung gemäß Weltzeit abruft.
<codeblock>

var now:Date = new Date();
trace(now.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMinutes"><apiName>getUTCMinutes</apiName><shortdesc>
	 Gibt den minutes-Teil (eine Ganzzahl von 0 bis 59) eines Date-Objekts gemäß Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcminutes, getutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der minutes-Teil gemäß Weltzeit (UTC) eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den minutes-Teil (eine Ganzzahl von 0 bis 59) eines <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCMinutes.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCMinutes()</codeph>-Methode aufgerufen, die die Minuten des Date-Objekts <codeph>now</codeph> zum Zeitpunkt seiner Erstellung gemäß Weltzeit abruft.
<codeblock>

var now:Date = new Date();
trace(now.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMonth"><apiName>getUTCMonth</apiName><shortdesc>
	 Gibt den month-Teil (von 0 für Januar bis 11 für Dezember) eines Date-Objekts gemäß der Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmonth, getutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der month-Teil gemäß Weltzeit (UTC) eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den month-Teil (von 0 für Januar bis 11 für Dezember) eines <codeph>Date</codeph>-Objekts gemäß der Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCMonth.1.as"> Im folgenden Beispiel wird ein neues Array-Objekt <codeph>monthLabels</codeph>, und zwar mit den Elementen <codeph>January</codeph> bis <codeph>December</codeph> und einem neuen Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCMonth()</codeph>-Methode zweimal aufgerufen. Dadurch wird zuerst die Zahl des Monats und dann der Name des Monats, in dem das Date-Objekt <codeph>now</codeph> erstellt wurde, gemäß Weltzeit zurückgegeben.
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(now.getUTCMonth());
trace(monthLabels[now.getUTCMonth()]);
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCSeconds"><apiName>getUTCSeconds</apiName><shortdesc>
	 Gibt den seconds-Teil (eine Ganzzahl von 0 bis 59) eines Date-Objekts gemäß Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcseconds, getutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der seconds-Teil gemäß Weltzeit (UTC) eines <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den seconds-Teil (eine Ganzzahl von 0 bis 59) eines <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC) zurück.
	 
	 </apiDesc><example conref="examples\Date.getUTCSeconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCSeconds()</codeph>-Methode aufgerufen, die die Sekunden des Date-Objekts <codeph>now</codeph> zum Zeitpunkt seiner Erstellung gemäß Weltzeit abruft.
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:parse"><apiName>parse</apiName><shortdesc>
	 Konvertiert einen String, der ein Datum repräsentiert, in eine Zahl, die der Anzahl der seit dem 1. Januar 1970 vergangenen Millisekunden gemäß Weltzeit (UTC) entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Zahl, die der Anzahl der seit dem 1. Januar 1970 vergangenen Millisekunden gemäß Weltzeit (UTC) entspricht.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Stringdarstellung eine Datums, das dem Format für die Ausgabe von <codeph>Date.toString()</codeph> entspricht. Die Ausgabe von <codeph>Date.toString()</codeph> hat das folgende Format: 
     <pre>
     Day Mon DD HH:MM:SS TZD YYYY
     </pre>
     <p>Beispiel: </p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
     <p>Die Zeitzonenzuweisung (TZD, Time Zone Designation) hat immer das Format <codeph>GMT-HHMM</codeph> oder <codeph>UTC-HHMM</codeph>, wobei die Abweichung von der Weltzeit (GMT, heute als Koordinierte Weltzeit, UTC bezeichnet) in Stunden und Minuten angegeben wird. Jahr, Monat und Tag können auch durch einen Schrägstrich (<codeph>/</codeph>)getrennt sein oder durch Leerzeichen, aber niemals durch einen Bindestrich (<codeph>-</codeph>). Es werden zudem die folgenden Formate unterstützt (Sie können jeweils auch Teilrepräsentationen dieser Formate verwenden, also nur Monat, Tag und Jahr):</p>
     <pre>
     MM/DD/YYYY HH:MM:SS TZD
     HH:MM:SS TZD Day Mon/DD/YYYY 
     Mon DD YYYY HH:MM:SS TZD
     Day Mon DD HH:MM:SS TZD YYYY
     Day DD Mon HH:MM:SS TZD YYYY
     Mon/DD/YYYY HH:MM:SS TZD
     YYYY/MM/DD HH:MM:SS TZD
     </pre>
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Konvertiert einen String, der ein Datum repräsentiert, in eine Zahl, die der Anzahl der seit dem 1. Januar 1970 vergangenen Millisekunden gemäß Weltzeit (UTC) entspricht.
	 
     </apiDesc><example conref="examples\Date.parse.1.as"> Im folgenden Beispiel wird <codeph>dateParsed</codeph> ein Datumsstring für den 30. November 1974 zugewiesen. Anschließend wird die <codeph>Date.parse()</codeph>-Methode aufgerufen, die das Datum in die Anzahl Millisekunden seit dem 1. Januar 1970 umwandelt.
<codeblock>
var dateParsed:String = "Sat Nov 30 1974";

var milliseconds:Number = Date.parse(dateParsed);
trace(milliseconds); // 155030400000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>Date.toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setDate"><apiName>setDate</apiName><shortdesc>
	 Stellt den Tag des Monats gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setdate, setdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 1 bis 31.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt den Tag des Monats gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.setDate.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getDate()</codeph>-Methode aufgerufen, die den Tag des Monats abruft. Dann wird <codeph>setDate()</codeph> aufgerufen, wobei der <codeph>day</codeph>-Parameter auf den Wert <codeph>20</codeph> gesetzt ist; daraufhin wird erneut<codeph>getDate()</codeph> aufgerufen, um den neu eingestellten Tag des Monats abzurufen.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDate()); // 30

someBirthday.setDate(20);
trace(someBirthday.getDate()); // 20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setFullYear"><apiName>setFullYear</apiName><shortdesc>
	 Stellt das Jahr gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setfullyear, setfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine vierstellige Zahl zur Angabe eines Jahres. Zweistellige Zahlen sind nicht für vierstellige Jahresangaben vorgesehen. So steht 99 z. B. nicht für das Jahr 1999, sondern für das Jahr 99.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Januar) bis 11 (Dezember). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl zwischen 1 und 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt das Jahr gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Die Angabe der Parameter <codeph>month</codeph> und <codeph>day</codeph> setzt diese auf Ortszeit. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 <p>
	 Bei Aufruf dieser Methode werden die anderen Felder des <codeph>Date</codeph>-Objekts nicht geändert. Die Methoden <codeph>Date.getUTCDay()</codeph> und <codeph>Date.getDay()</codeph> können jedoch einen neuen Wert zurückgeben, wenn sich der Wochentag aufgrund des Aufrufs dieser Methode ändert.
	 </p>
	 
	 </apiDesc><example conref="examples\Date.setFullYear.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getFullYear()</codeph>-Methode aufgerufen, die die vierstellige Jahreszahl abruft. Dann wird <codeph>setFullYear()</codeph> aufgerufen, wobei der <codeph>year</codeph>-Parameter auf den Wert <codeph>2000</codeph> gesetzt ist; daraufhin wird erneut<codeph>getFullYear()</codeph> aufgerufen, um das neu eingestellte Jahr abzurufen.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974

someBirthday.setFullYear(2000);
trace(someBirthday.getFullYear()); // 2000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setHours"><apiName>setHours</apiName><shortdesc>
	 Stellt die Stunde gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.sethours, sethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Mitternacht) bis 23 (23.00 Uhr).
     </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59. 
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59. 
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Stunde gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.setHours.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend werden die <codeph>getHours()</codeph>- und <codeph>getMinutes()</codeph>-Methoden aufgerufen, die die Stunden und Minuten abrufen. Dann wird <codeph>setHours()</codeph> aufgerufen, wobei der <codeph>hour</codeph>-Parameter auf den Wert <codeph>12</codeph> gesetzt ist; daraufhin wird erneut<codeph>getHours()</codeph> und <codeph>getMinutes()</codeph> aufgerufen, um die neu eingestellten Stunden und Minuten abzurufen.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:20

someBirthday.setHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMilliseconds"><apiName>setMilliseconds</apiName><shortdesc>
	 Stellt die Millisekunde gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmilliseconds, setmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Millisekunde gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.setMilliseconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getMilliseconds()</codeph>-Methode aufgerufen, die die Anzahl von Millisekunden zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird ein weiteres neues Date-Objekt (<codeph>before</codeph>) mit einem zusätzlichen Aufruf von<codeph>setMilliseconds()</codeph> erstellt, wobei der <codeph>millisecond</codeph>-Parameter auf den Wert <codeph>4</codeph> gesetzt ist. Dann wird <codeph>getMilliseconds()</codeph> erneut aufgerufen. Hierdurch werden die neu eingestellten Millisekunden abgerufen.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMilliseconds());

var before:Date = new Date(now.setMilliseconds(4));
trace(before);
trace(before.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMinutes"><apiName>setMinutes</apiName><shortdesc>
	 Stellt die Minute gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setminutes, setminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59.
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59.
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Minute gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.setMinutes.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getMinutes()</codeph>-Methode aufgerufen, die die Anzahl von Minuten zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird ein weiteres neues Date-Objekt (<codeph>before</codeph>) mit einem zusätzlichen Aufruf von <codeph>setMinutes()</codeph> erstellt, wobei der <codeph>minute</codeph>-Parameter auf den Wert <codeph>0</codeph> gesetzt ist. <codeph>getMinutes()</codeph> wird erneut aufgerufen. Hierdurch werden die neu eingestellten Minuten abgerufen.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());

var before:Date = new Date(now.setMinutes(0));
trace(before);
trace(before.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMonth"><apiName>setMonth</apiName><shortdesc>
	 Stellt den Monat und optional den Tag des Monats gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmonth, setmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Januar) bis 11 (Dezember).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 1 bis 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt den Monat und optional den Tag des Monats gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.setMonth.1.as"> Im folgenden Beispiel wird ein neues Array-Objekt <codeph>monthLabels</codeph>, und zwar mit den Elementen <codeph>January</codeph> bis <codeph>December</codeph> und einem neuen month-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getMonth()</codeph>-Methode aufgerufen, die den Monat zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird <codeph>setMonth()</codeph> aufgerufen, wobei der <codeph>month</codeph>-Parameter auf den Wert <codeph>0</codeph> gesetzt ist; daraufhin wird erneut <codeph>getMonth()</codeph> aufgerufen, um den neu eingestellten Monat abzurufen..
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);

now.setMonth(0);
trace(now.getMonth());             // 0
trace(monthLabels[now.getMonth()]); // January
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setSeconds"><apiName>setSeconds</apiName><shortdesc>
	 Stellt die Sekunde gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setseconds, setseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59.
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Sekunde gemäß Ortszeit ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc><example conref="examples\Date.setSeconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getseconds()</codeph>-Methode aufgerufen, die die Anzahl von Minuten zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird <codeph>setSeconds()</codeph> aufgerufen, wobei der <codeph>second</codeph>-Parameter auf den Wert <codeph>0</codeph> gesetzt ist; daraufhin wird erneut<codeph>getSeconds()</codeph> aufgerufen, um die neu eingestellten Sekunden abzurufen.
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());

now.setSeconds(0);
trace(now.getSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setTime"><apiName>setTime</apiName><shortdesc>
	 Legt das Datum in Millisekunden seit dem 1. Januar 1970, 0.00 Uhr fest und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.settime, settime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, bei der 0 dem 1. Januar, 0.00 Uhr Weltzeit (UTC) entspricht.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt das Datum in Millisekunden seit dem 1. Januar 1970, 0.00 Uhr fest und gibt den neuen Zeitpunkt in Millisekunden zurück. 
	 
	 </apiDesc><example conref="examples\Date.setTime.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>setTime()</codeph>-Methode aufgerufen, wobei der <codeph>millisecond</codeph>-Parameter auf den Wert <codeph>-1292601600000</codeph> gesetzt ist; dadurch wird die Zeit wie folgt eingestellt: <codeph>Tue Jan 15 00:00:00 GMT-0800 1929</codeph>.
<codeblock>

var now:Date = new Date();
trace(now);

now.setTime(-1292601600000);
trace(now); // Tue Jan 15 00:00:00 GMT-0800 1929
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCDate"><apiName>setUTCDate</apiName><shortdesc>
	 Stellt den Tag des Monats gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcdate, setutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 1 bis 31.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt den Tag des Monats gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Bei Aufruf dieser Methode werden die anderen Felder des <codeph>Date </codeph>-Objekts nicht geändert. Die Methoden <codeph>Date.getUTCDay()</codeph> und <codeph>Date.getDay()</codeph> können jedoch einen neuen Wert zurückgeben, wenn sich der Wochentag aufgrund des Aufrufs dieser Methode ändert.
	 
	 </apiDesc><example conref="examples\Date.setUTCDate.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getUTCDate()</codeph>-Methode aufgerufen, die den richtigen Tag des Monats zurückgibt. Dann wird <codeph>setUTCDate()</codeph> aufgerufen, wobei der <codeph>day</codeph>-Parameter auf den Wert <codeph>1</codeph> gesetzt ist. Mithilfe einer <codeph>trace()</codeph>-Anweisung wird bestätigt, dass das Datum richtig gesetzt wurde.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30

someBirthday.setUTCDate(1);
trace(someBirthday); // Fri Nov 1 01:20:00 GMT-0800 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCFullYear"><apiName>setUTCFullYear</apiName><shortdesc>
	 Stellt das Jahr gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcfullyear, setutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Ganzzahl.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die das Jahr mit vier Stellen darstellt, z. B. 2007.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Januar) bis 11 (Dezember). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 1 bis 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt das Jahr gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. 
	 <p>
	 Optional können mit dieser Methode auch der Monat und der Tag des Monats eingestellt werden. Bei Aufruf dieser Methode werden die anderen Felder des Objekts nicht geändert. Die Methoden <codeph>Date.getUTCDay()</codeph> und <codeph>Date.getDay()</codeph> können jedoch einen neuen Wert zurückgeben, wenn sich der Wochentag aufgrund des Aufrufs dieser Methode ändert. 
	 </p>
	 
 	 </apiDesc><example conref="examples\Date.setUTCFullYear.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend wird die <codeph>getUTCFullYear()</codeph>-Methode aufgerufen, die korrekt die vierstellige Jahreszahl zurückgibt. Dann wird <codeph>setUTCFullYear()</codeph> aufgerufen, wobei der <codeph>year</codeph>-Parameter auf den Wert <codeph>1975</codeph> gesetzt ist. Mithilfe einer <codeph>trace()</codeph>-Anweisung wird bestätigt, dass das Jahr richtig gesetzt wurde.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974

someBirthday.setUTCFullYear(1975);
trace(someBirthday); // Thu Nov 30 01:20:00 GMT-0800 1975
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCHours"><apiName>setUTCHours</apiName><shortdesc>
	 Stellt die Stunde gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutchours, setutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Mitternacht) bis 23 (23.00 Uhr).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Stunde gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Optional können auch die Minute, Sekunde und Millisekunde angegeben werden.
	 
	 </apiDesc><example conref="examples\Date.setUTCHours.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>someBirthday</codeph> mit den Parametern <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) und <codeph>minute</codeph> (<codeph>20</codeph>) erstellt. Anschließend werden die <codeph>getHours()</codeph>-, <codeph>getMinutes()</codeph>-, <codeph>getUTCHours()</codeph>- und <codeph>getUTCMinutes()</codeph>-Methoden aufgerufen, die die Stunden und Minuten abrufen. Dann wird <codeph>setUTCHours()</codeph> aufgerufen, wobei der <codeph>hour</codeph>-Parameter auf den Wert <codeph>12</codeph> gesetzt ist. Anschließend werden die <codeph>getHours()</codeph>-, <codeph>getMinutes()</codeph>-, <codeph>getUTCHours()</codeph>- und <codeph>getUTCMinutes()</codeph>-Methoden erneut aufgerufen und die aktualisierte Stunde wird korrekt angezeigt.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 15:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 23:20

someBirthday.setUTCHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 4:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMilliseconds"><apiName>setUTCMilliseconds</apiName><shortdesc>
	 Stellt die Millisekunde gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmilliseconds, setutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Millisekunde gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.
	 
	 </apiDesc><example conref="examples\Date.setUTCMilliseconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCMilliseconds()</codeph>-Methode aufgerufen, die die Anzahl von Millisekunden gemäß Weltzeit zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird ein weiteres neues Date-Objekt (<codeph>before</codeph>) mit einem zusätzlichen Aufruf von<codeph>setUTCMilliseconds()</codeph> erstellt, wobei der <codeph>millisecond</codeph>-Parameter auf den Wert <codeph>4</codeph> gesetzt ist. <codeph>getUTCMilliseconds()</codeph> wird erneut aufgerufen. Hierdurch werden die neu eingestellten Millisekunden abgerufen.
<codeblock>


var now:Date = new Date();
trace(now);
trace(now.getUTCMilliseconds());

var before:Date = new Date(now.setUTCMilliseconds(4));
trace(before);
trace(before.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMinutes"><apiName>setUTCMinutes</apiName><shortdesc>
	 Stellt die Minute gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcminutes, setutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Minute gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Optional können Sie auch die Sekunde und Millisekunde angeben.
	 
	 </apiDesc><example conref="examples\Date.setUTCMinutes.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCMinutes()</codeph>-Methode aufgerufen, die die Anzahl von Minuten gemäß Weltzeit zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird ein weiteres neues Date-Objekt (<codeph>before</codeph>) mit einem zusätzlichen Aufruf von <codeph>setUTCMinutes()</codeph> erstellt, wobei der <codeph>minute</codeph>-Parameter auf den Wert <codeph>0</codeph> gesetzt ist. <codeph>getUTCMinutes()</codeph> wird erneut aufgerufen. Hierdurch werden die neu eingestellten Minuten abgerufen.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getUTCMinutes());

var before:Date = new Date(now.setUTCMinutes(0));
trace(before);
trace(before.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMonth"><apiName>setUTCMonth</apiName><shortdesc>
	 Stellt den Monat, und optional auch den Tag des Monats, gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmonth, setutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 (Januar) bis 11 (Dezember).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 1 bis 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt den Monat, und optional auch den Tag des Monats, gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück. Bei Aufruf dieser Methode werden die anderen Felder des Objekts nicht geändert. Die Methoden <codeph>Date.getUTCDay()</codeph> und <codeph>Date.getDay()</codeph> können jedoch einen neuen Wert zurückgeben, wenn sich der Wochentag aufgrund des Aufrufs dieser Methode ändert.
	 
	 </apiDesc><example conref="examples\Date.setUTCMonth.1.as"> Im folgenden Beispiel wird ein neues Array-Objekt <codeph>UTCMonthLabels</codeph>, und zwar mit den Elementen <codeph>January</codeph> bis <codeph>December</codeph> und einem neuen UTCMonth-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCMonth()</codeph>-Methode aufgerufen, die den Monat gemäß Weltzeit zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird <codeph>setUTCMonth()</codeph> aufgerufen, wobei der <codeph>month</codeph>-Parameter auf den Wert <codeph>0</codeph> gesetzt ist; daraufhin wird erneut <codeph>getUTCMonth()</codeph> aufgerufen, um den neu eingestellten Monat abzurufen..
<codeblock>

var UTCMonthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getUTCMonth());
trace(UTCMonthLabels[now.getUTCMonth()]);

now.setUTCUTCMonth(0);
trace(now.getUTCMonth());              // 0
trace(UTCMonthLabels[now.getUTCMonth()]); // January
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCSeconds"><apiName>setUTCSeconds</apiName><shortdesc>
	 Stellt die Sekunde, und optional auch die Millisekunde, gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcseconds, setutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die neue Zeit in Millisekunden.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 59.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl von 0 bis 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt die Sekunde, und optional auch die Millisekunde, gemäß Weltzeit (UTC) ein, und gibt den neuen Zeitpunkt in Millisekunden zurück.
	 
	 </apiDesc><example conref="examples\Date.setUTCSeconds.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getUTCSeconds()</codeph>-Methode aufgerufen, die die Anzahl von Minuten zum Zeitpunkt der Erstellung von <codeph>now</codeph> zurückgibt. Dann wird <codeph>setUTCSeconds()</codeph> aufgerufen, wobei der <codeph>second</codeph>-Parameter auf den Wert <codeph>0</codeph> gesetzt ist; daraufhin wird erneut<codeph>getUTCSeconds()</codeph> aufgerufen, um die neu eingestellten Sekunden abzurufen.
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());

now.setUTCSeconds(0);
trace(now.getUTCSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toDateString"><apiName>toDateString</apiName><shortdesc>
	 Gibt eine Stringdarstellung nur des Wochentags und des Tags des Monats zurück ohne Angabe zu Uhrzeit und Zeitzone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung nur des Wochentags und des Tags des Monats.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Stringdarstellung nur des Wochentags und des Tags des Monats zurück ohne Angabe zu Uhrzeit und Zeitzone. Vergleichen Sie dies mit den folgenden Methoden:
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph>, die nur die Zeit und die Zeitzone zurückgibt.</li>
	   <li><codeph>Date.toString()</codeph>, die nicht nur den Wochentag und den Tag des Monats zurückgibt, sondern auch die Uhrzeit und die Zeitzone.</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\Date.toDateString.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt und anschließend werden die folgenden Methoden innerhalb einer <codeph>trace()</codeph>-Anweisung aufgerufen
 <ul>
   <li><codeph>toString</codeph>: zeigt alle Parameter für <codeph>now</codeph> zum Zeitpunkt der Erstellung von <codeph>now</codeph> an.</li>
   <li><codeph>toDateString()</codeph>: zeigt die Parameter <codeph>day</codeph>, <codeph>month</codeph> und <codeph>year</codeph> zum Zeitpunkt der Erstellung von <codeph>now</codeph> an.</li>
 </ul>
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.toDateString());
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleDateString"><apiName>toLocaleDateString</apiName><shortdesc>
	 Gibt eine Stringdarstellung nur des Wochentags und des Tags des Monats zurück ohne Angabe zu Uhrzeit und Zeitzone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die <codeph>String</codeph>-Darstellung nur des Wochentags und des Tags des Monats.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Stringdarstellung nur des Wochentags und des Tags des Monats zurück ohne Angabe zu Uhrzeit und Zeitzone. Diese Methode gibt denselben Wert zurück wie <codeph>Date.toDateString</codeph>. Vergleichen Sie dies mit den folgenden Methoden:
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph>, die nur die Zeit und die Zeitzone zurückgibt.</li>
	   <li><codeph>Date.toString()</codeph>, die nicht nur den Wochentag und den Tag des Monats zurückgibt, sondern auch die Uhrzeit und die Zeitzone.</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 Gibt eine Stringdarstellung des Wochentags, des Tags des Monats, der Uhrzeit gemäß der Ortszeit zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Stringdarstellung eines <codeph>Date</codeph>-Objekts in der lokalen Zeitzone.
	 
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Stringdarstellung des Wochentags, des Tags des Monats, der Uhrzeit gemäß der Ortszeit zurück. Vergleichen Sie dies mit der Methode <codeph>Date.toString()</codeph>, die dieselben Informationen (plus die Zeitzone) zurückgibt, wobei am Ende des Strings zudem das Jahr erscheint.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toLocaleTimeString"><apiName>toLocaleTimeString</apiName><shortdesc>
	 Gibt eine Stringdarstellung nur der Uhrzeit zurück ohne Angabe zu Wochentag, Tag des Monats, Jahr oder Zeitzone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung nur der Uhrzeit und der Zeitzone.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Stringdarstellung nur der Uhrzeit zurück ohne Angabe zu Wochentag, Tag des Monats, Jahr oder Zeitzone. Vergleichen Sie dies mit der Methode <codeph>Date.toTimeString()</codeph>, die nur die Uhrzeit und die Zeitzone zurückgibt.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Gibt eine Stringdarstellung des Wochentags, des Tags des Monats, der Uhrzeit und der Zeitzone zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.tostring, tostring, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung des <codeph>Date</codeph>-Objekts.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Stringdarstellung des Wochentags, des Tags des Monats, der Uhrzeit und der Zeitzone zurück. Das Datum für die Ausgabe hat das folgende Format: 
     <pre>
     Day Mon Date HH:MM:SS TZD YYYY
     </pre>
     <p>Beispiel:</p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
	 
	 </apiDesc><example conref="examples\Date.toString.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parametera erstellt. Anschließend wird <codeph>toString</codeph> innerhalb einer <codeph>trace()</codeph> Anweisung aufgerufen, wodurch alle Parameter für <codeph>now</codeph> zum Zeitpunkt der Erstellung von <codeph>now</codeph> angezeigt werden.
<codeblock>


var now:Date = new Date();
trace(now);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toTimeString"><apiName>toTimeString</apiName><shortdesc>
	 Gibt eine Stringdarstellung nur der Uhrzeit und der Zeitzone zurück ohne Angabe zu Wochentag und Tag des Monats.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung nur der Uhrzeit und der Zeitzone.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Stringdarstellung nur der Uhrzeit und der Zeitzone zurück ohne Angabe zu Wochentag und Tag des Monats. Vergleichen Sie dies mit der Methode <codeph>Date.toDateString()</codeph>, die nur den Wochentag und den Tag des Monats zurückgibt.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toUTCString"><apiName>toUTCString</apiName><shortdesc>
	 Gibt eine Stringdarstellung des Wochentags, des Tags des Monats und der Uhrzeit gemäß der Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung eines <codeph>Date</codeph>-Objekts in der UTC-Zeitzone.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Stringdarstellung des Wochentags, des Tags des Monats und der Uhrzeit gemäß der Weltzeit (UTC) zurück. Das Datum „1. Februar 2005“ wird beispielsweise als <codeph>Tue Feb 1 00:00:00 2005 UTC</codeph> zurückgegeben.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Gibt für ein Date-Objekt die Anzahl der Millisekunden zurück, die seit dem 1. Januar 1970, 0.00 Uhr, Weltzeit, vergangen sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.valueof, valueof, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Anzahl an Millisekunden, die zwischen dem 1. Januar 1970 und dem Datum, den das <codeph>Date</codeph>-Objekt repräsentiert, vergangen sind.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt für ein <codeph>Date</codeph>-Objekt die Anzahl der Millisekunden zurück, die seit dem 1. Januar 1970, 0.00 Uhr, Weltzeit, vergangen sind.
	 
	 </apiDesc><example conref="examples\Date.valueOf.1.as"> Im folgenden Beispiel wird ein neues Date-Objekt <codeph>now</codeph> ohne Parameter erstellt. Anschließend wird die <codeph>getTime()</codeph>-Methode aufgerufen, die die Anzahl von Millisekunden zwischen dem Zeitpunkt der Erstellung von <codeph>now</codeph> und dem 1. Januar 1970, 0.00 Uhr abruft. Dann wird <codeph>valueOf()</codeph> aufgerufen, womit ebenfalls diese Anzahl von Millisekunden abgerufen wird.
<codeblock>


var now:Date = new Date();
trace(now.getTime());
trace(now.valueOf());
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="Date:AS3:date:get"><apiName>date</apiName><shortdesc>
	 Der von einem Date-Objekt gemäß der Ortszeit angegebenen Tag des Monats (eine Ganzzahl von 1 bis 31).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der von einem <codeph>Date</codeph>-Objekt gemäß der Ortszeit angegebenen Tag des Monats (eine Ganzzahl von 1 bis 31). Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/setDate()"><linktext>setDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dateUTC:get"><apiName>dateUTC</apiName><shortdesc>
	 Gibt den Tag des Monats (eine Ganzzahl von 1 bis 31) eines Date-Objekts gemäß der Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt den Tag des Monats (eine Ganzzahl von 1 bis 31) eines <codeph>Date</codeph>-Objekts gemäß der Weltzeit (UTC) zurück.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDate()"><linktext>getUTCDate()</linktext></link><link href="#Date/setUTCDate()"><linktext>setUTCDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:day:get"><apiName>day</apiName><shortdesc>
	 Der von dem Date-Objekt gemäß der Ortszeit angegebenen Wochentag (0 für Sonntag, 1 für Montag usw.).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der von dem <codeph>Date</codeph>-Objekt gemäß der Ortszeit angegebenen Wochentag (0 für Sonntag, 1 für Montag usw.). Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dayUTC:get"><apiName>dayUTC</apiName><shortdesc>
	 Der Wochentag (0 für Sonntag, 1 für Montag usw.) dieses Date-Objekts gemäß Weltzeit (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der Wochentag (0 für Sonntag, 1 für Montag usw.) dieses <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYear:get"><apiName>fullYear</apiName><shortdesc>
	 Die vollständige Jahreszahl (eine vierstellige Zahl, z. B. 2000) eines Date-Objekts gemäß der Ortszeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die vollständige Jahreszahl (eine vierstellige Zahl, z. B. 2000) eines <codeph>Date</codeph>-Objekts gemäß der Ortszeit. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link><link href="#Date/setFullYear()"><linktext>setFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYearUTC:get"><apiName>fullYearUTC</apiName><shortdesc>
	 Die vierstellige Jahreszahl des Date-Objekts gemäß Weltzeit (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die vierstellige Jahreszahl des <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCFullYear()"><linktext>getUTCFullYear()</linktext></link><link href="#Date/setUTCFullYear()"><linktext>setUTCFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hours:get"><apiName>hours</apiName><shortdesc>
	 Die Stunde (eine Ganzzahl von 0 bis 23) des day-Teils eines Date-Objekts gemäß der Ortszeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Stunde (eine Ganzzahl von 0 bis 23) des day-Teils eines <codeph>Date</codeph>-Objekts gemäß der Ortszeit. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link><link href="#Date/setHours()"><linktext>setHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hoursUTC:get"><apiName>hoursUTC</apiName><shortdesc>
	 Die Stunde (eine Ganzzahl von 0 bis 23) des Date-Objekts gemäß der Weltzeit (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Stunde (eine Ganzzahl von 0 bis 23) des <codeph>Date</codeph>-Objekts gemäß der Weltzeit (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCHours()"><linktext>getUTCHours()</linktext></link><link href="#Date/setUTCHours()"><linktext>setUTCHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:milliseconds:get"><apiName>milliseconds</apiName><shortdesc>
	 Der milliseconds-Teil (eine Ganzzahl von 0 bis 999) des Date-Objekts gemäß der Ortszeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der milliseconds-Teil (eine Ganzzahl von 0 bis 999) des <codeph>Date</codeph>-Objekts gemäß der Ortszeit. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMilliseconds()"><linktext>getMilliseconds()</linktext></link><link href="#Date/setMilliseconds()"><linktext>setMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:millisecondsUTC:get"><apiName>millisecondsUTC</apiName><shortdesc>
	 Der milliseconds-Teil (eine Ganzzahl von 0 bis 999) eines Date-Objekts gemäß Weltzeit (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der milliseconds-Teil (eine Ganzzahl von 0 bis 999) eines <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMilliseconds()"><linktext>getUTCMilliseconds()</linktext></link><link href="#Date/setUTCMilliseconds()"><linktext>setUTCMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutes:get"><apiName>minutes</apiName><shortdesc>
	 Der minutes-Teil (eine Ganzzahl von 0 bis 59) des Date-Objekts gemäß der Ortszeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der minutes-Teil (eine Ganzzahl von 0 bis 59) des <codeph>Date</codeph>-Objekts gemäß der Ortszeit. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMinutes()"><linktext>getMinutes()</linktext></link><link href="#Date/setMinutes()"><linktext>setMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutesUTC:get"><apiName>minutesUTC</apiName><shortdesc>
	 Der minutes-Teil (eine Ganzzahl von 0 bis 59) eines Date-Objekts gemäß Weltzeit (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der minutes-Teil (eine Ganzzahl von 0 bis 59) eines <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMinutes()"><linktext>getUTCMinutes()</linktext></link><link href="#Date/setUTCMinutes()"><linktext>setUTCMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:month:get"><apiName>month</apiName><shortdesc>
	 Der month-Teil (0 für Januar, 1 für Februar usw.) dieses Date-Objekts gemäß der Ortszeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der month-Teil (0 für Januar, 1 für Februar usw.) dieses <codeph> Date</codeph>-Objekts gemäß der Ortszeit. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/setMonth()"><linktext>setMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:monthUTC:get"><apiName>monthUTC</apiName><shortdesc>
	 Der month-Teil (von 0 für Januar bis 11 für Dezember) eines Date-Objekts gemäß der Weltzeit (UTC) zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt den month-Teil (von 0 für Januar bis 11 für Dezember) eines <codeph>Date</codeph>-Objekts gemäß der Weltzeit (UTC) zurück.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMonth()"><linktext>getUTCMonth()</linktext></link><link href="#Date/setUTCMonth()"><linktext>setUTCMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:seconds:get"><apiName>seconds</apiName><shortdesc>
	 Der seconds-Teil (eine Ganzzahl von 0 bis 59) des Date-Objekts gemäß der Ortszeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der seconds-Teil (eine Ganzzahl von 0 bis 59) des <codeph>Date</codeph>-Objekts gemäß der Ortszeit. Die Ortszeit wird durch das Betriebssystem festgelegt, auf dem der Flash Player ausgeführt wird.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getSeconds()"><linktext>getSeconds()</linktext></link><link href="#Date/setSeconds()"><linktext>setSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:secondsUTC:get"><apiName>secondsUTC</apiName><shortdesc>
	 Der seconds-Teil (eine Ganzzahl von 0 bis 59) eines Date-Objekts gemäß Weltzeit (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der seconds-Teil (eine Ganzzahl von 0 bis 59) eines <codeph>Date</codeph>-Objekts gemäß Weltzeit (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCSeconds()"><linktext>getUTCSeconds()</linktext></link><link href="#Date/setUTCSeconds()"><linktext>setUTCSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:time:get"><apiName>time</apiName><shortdesc>
	 Die Anzahl der Millisekunden seit dem 1. Januar 1970, 0.00 Uhr, Weltzeit für ein Date-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl der Millisekunden Gibt seit dem 1. Januar 1970, 0.00 Uhr, Weltzeit (UTC) für ein <codeph>Date</codeph>-Objekt. Mit dieser Methode können Sie beim Vergleich von mindestens zwei <codeph>Date</codeph>-Objekten einen bestimmten Zeitpunkt angeben.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getTime()"><linktext>getTime()</linktext></link><link href="#Date/setTime()"><linktext>setTime()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:timezoneOffset:get"><apiName>timezoneOffset</apiName><shortdesc>
     Gibt die Differenz zwischen der Weltzeit (UTC) und der Ortszeit des Computers in Minuten zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Differenz zwischen der Weltzeit (UTC) und der Ortszeit des Computers in Minuten zurück. Dieser Wert gibt die Anzahl von Minuten an, die Sie zur Ortszeit des Computers hinzufügen müssen, damit sie gleich der Weltzeit ist. Ist die Ortszeit des Computers später als die Weltzeit, wird ein negativer Wert zurückgegeben.
     </apiDesc></apiValueDetail><related-links><link href="#Date/getTimezoneOffset()"><linktext>getTimezoneOffset()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="globalClassifier:URIError"><apiName>URIError</apiName><shortdesc>
 Eine URIError-Ausnahme wird ausgelöst, wenn eine der globalen Funktionen für die URI-Verarbeitung auf eine Weise eingesetzt wird, die mit ihrer Definition nicht kompatibel ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, URIError
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Eine URIError-Ausnahme wird ausgelöst, wenn eine der globalen Funktionen für die URI-Verarbeitung auf eine Weise eingesetzt wird, die mit ihrer Definition nicht kompatibel ist. Diese Ausnahme wird ausgelöste, wenn ein ungültiger URI für eine Funktion angegeben wird, die einen gültigen URI erwartet, wie z. B. die Methode <codeph>Socket.connect()</codeph>.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>flash.net.Socket.connect()</linktext></link></related-links><apiConstructor id="URIError:URIError"><apiName>URIError</apiName><shortdesc>
	 Erstellt ein neues URIError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Enthält die mit dem URIError-Objekt verbundene Meldung.  
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues URIError-Objekt.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Object"><apiName>Object</apiName><shortdesc>
 Die Object-Klasse ist das Stammelement der ActionScript-Klassenhierarchie zur Laufzeit.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/></apiClassifierDef><apiDesc>
 Die Object-Klasse ist das Stammelement der <ph platform="actionscript">ActionScript</ph><ph platform="javascript">-Klassenhierarchie zur Laufzeit</ph>. Objekte werden von Konstruktoren mithilfe der <codeph>new</codeph>-Operatorsyntax erstellt und können Eigenschaften dynamisch zugewiesen bekommen. <ph platform="actionscript">Objekt können auch erstellt werden, indem, wie im folgenden Code, ein Objektliteral zugewiesen wird:</ph>
 
 <codeblock platform="actionscript">var obj:Object = {a:"foo", b:"bar"}</codeblock>
 
 <p platform="actionscript">Alle Klassen, die nicht ausdrücklich eine Basisklasse deklarieren, erweitern die integrierte Object-Klasse.</p>
 
 <p platform="javascript">Alle Laufzeitklassen in Adobe Integrated Runtime erweitern die runtime.Object-Klasse.</p>
 
 <p platform="actionscript">Sie können die Object-Klasse einsetzen, um <i>assoziative Arrays</i> zu erstellen. Im Grunde ist ein assoziatives Array eine Instanz der Object-Klasse, bei der jedes Schlüssel-Werte-Paar durch eine Eigenschaft und deren Wert dargestellt wird. Ein weiterer Grund für die Deklaration eines assoziativen Arrays mit dem Object-Datentyp besteht darin, dass das assoziative Array auf diese Weise mithilfe von Objektliteralen mit Daten gefüllt werden kann (wenn auch nur unmittelbar bei seiner Erstellung). Im folgenden Beispiel wird ein assoziatives Array mit einem Objektliteral erstellt. Der anschließende Zugriff auf dessen Elemente erfolgt sowohl mit dem Punkt (.)- als auch mit dem Array-Zugriffsoperator. Anschließend wird durch Erstellen einer neuen Eigenschaft ein neues Schlüssel-Werte-Paar hinzugefügt:</p>
 
 <codeblock platform="actionscript">
 var myAssocArray:Object = {fname:"John", lname:"Public"};
 trace(myAssocArray.fname);     // John
 trace(myAssocArray["lname"]);  // Public
 myAssocArray.initial = "Q";
 trace(myAssocArray.initial);   // Q</codeblock> 
 
 <p platform="actionscript">ActionScript 3.0 verfügt über zwei Arten der Vererbung: Klassenvererbung und Prototypvererbung:</p>
 <ul platform="actionscript">
 <li>Klassenvererbung ist die primäre Vererbungsart. Sie unterstützt die Vererbung fester Eigenschaften. Eine feste Eigenschaft ist eine Variable oder Methode, die als Teil einer Klassendefinition deklariert worden ist. Jede Klassendefinition wird nun durch ein spezielles Klassenobjekt repräsentiert, das Informationen über die Klasse speichert. </li>
 <li>Die Prototypvererbung war in früheren ActionScript-Versionen die einzige Vererbungsart. In ActionScript 3.0 dient sie als alternative Vererbungsform. Mit jeder Klasse ist ein Prototypobjekt verbunden und die Eigenschaften des Prototypobjekts werden von allen Instanzen der Klasse genutzt. Wenn eine Klasseninstanz erstellt wird, besitzt diese einen Verweis auf das Prototypobjekt ihrer Klasse, der als Verknüpfung zwischen der Instanz und ihrem verbundenen Klassenprototypobjekt dient. Wenn während der Laufzeit für eine Klasseninstanz eine bestimmte Eigenschaft nicht gefunden wird, wird das Delegate-Objekt, das identisch ist mit dem Klassenprototypobjekt, auf die Eigenschaft hin überprüft. Enthält das Prototypobjekt die Eigenschaft auch nicht, wird der Vorgang fortgesetzt, indem das Delegate-Objekt des Prototypobjekts in der nächsthöheren Hierarchieebene sucht, bis die Eigenschaft gefunden wird. </li>
 </ul>
 
 <p platform="actionscript">Klassen- und Prototypvererbung können nebeneinander existieren, wie Sie im folgenden Beispiel sehen können:</p>
 
 <codeblock platform="actionscript">
 class A {
     var x = 1
     prototype.px = 2
 }
 dynamic class B extends A {
     var y = 3
     prototype.py = 4
 }
  
 var b = new B()
 b.x // 1 via class inheritance
 b.px // 2 via prototype inheritance from A.prototype
 b.y // 3
 b.py // 4 via prototype inheritance from B.prototype
  
 B.prototype.px = 5
 b.px // now 5 because B.prototype hides A.prototype
  
 b.px = 6
 b.px // now 6 because b hides B.prototype</codeblock>
 
 <p platform="actionscript">Wenn Sie Funktionen anstelle von Klassen verwenden, können Sie eine eigene Prototypvererbungsstruktur erstellen. Mit Klassen wird die Prototypvererbungsstruktur in der Klassenvererbungsstruktur widergespiegelt. Da Prototypobjekte jedoch dynamisch sind, können Sie prototypgestützte Eigenschaften auch während der Laufzeit hinzufügen oder löschen.</p>
 
 </apiDesc><example conref="examples\ObjectExample.as"> Im folgenden Beispiel wird mithilfe der Klassen <codeph>ObjectExample</codeph> und <codeph>Circle</codeph> der dynamische Charakter der Object-Klasse veranschaulicht. Außerdem wird gezeigt, wie Value-Objekte in Shape-Objekte umgewandelt und zur Bühne an den angegebenen x/y-Koordinaten hinzugefügt werden können.
 
 <p>Im folgenden Beispiel werden die Value-Objekte <codeph>firstInitObj</codeph> und <codeph>secondInitObj</codeph> erstellt. Die benutzerdefinierte Klasse <codeph>Circle</codeph> akzeptiert das Value-Objekt, durchläuft es wiederholt und stellt seine entsprechenden internen Eigenschaften gemäß den im Value-Objekt definierten Werten ein.</p>
<codeblock>
package {
    import flash.display.Sprite;

    public class ObjectExample extends Sprite {
        public function ObjectExample() {
            var firstInitObj:Object = new Object();
            firstInitObj.bgColor = 0xFF0000;
            firstInitObj.radius = 25;
            firstInitObj.xCenter = 25;
            firstInitObj.yCenter = 25;
                        
            var firstCircle:Circle = new Circle(firstInitObj);
            addChild(firstCircle);
            firstCircle.x = 50;
            firstCircle.y = 50;

            var secondInitObj:Object = {bgColor:0xCCCCCC, radius:50, xCenter:50, yCenter:50};

            var secondCircle:Circle = new Circle(secondInitObj);            
            addChild(secondCircle);
            secondCircle.x = 100;
            secondCircle.y = 100;
        }
        
    }
}

import flash.display.Shape;
    
class Circle extends Shape {
    public var bgColor:Number = 0xFFFFFF;
    public var radius:Number = 0;
    public var xCenter:Number = 0;
    public var yCenter:Number = 0;
        
    public function Circle(initObj:Object) {
        for(var i:String in initObj) {
            this[i] = initObj[i];
        }
        draw();
    }
        
    public function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawCircle(xCenter, yCenter, radius);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links><apiConstructor id="Object:Object"><apiName>Object</apiName><shortdesc>
	 Erstellt ein Object-Objekt und speichert eine Referenz auf die Konstruktormethode in der constructor-Eigenschaft des Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Erstellt ein Object-Objekt und speichert eine Referenz auf die Konstruktormethode in der Eigenschaft <codeph>constructor</codeph> des Objekts.
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Object:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	 Gibt an, ob für ein Objekt eine bestimmte Eigenschaft definiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Method
	 </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Wenn die Eigenschaft beim Zielobjekt durch den Parameter <codeph>name</codeph> angegeben wird, lautet dieser Wert <codeph>true</codeph>; andernfalls <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Eigenschaft des Objekts.	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob für ein Objekt eine bestimmte Eigenschaft definiert wurde. Diese Methode gibt <codeph>true</codeph> zurück, wenn das Zielobjekt eine Eigenschaft aufweist, die dem String entspricht, der durch den Parameter <codeph>name</codeph> festgelegt ist; andernfalls gibt sie <codeph>false</codeph> zurück. Bei den folgenden Eigenschaften gibt diese Methode für Objekte den Wert <codeph>true</codeph> zurück, die Instanzen einer Klasse sind (im Gegensatz zu Klassenobjekten):
	 <ul>
	   <li>Feste Instanzeigenschaften: Variablen, Konstanten oder Methoden, die von der Objektklasse definiert und nicht statisch sind;</li>
	   <li>Geerbte feste Instanzeigenschaften: Variablen, Konstanten oder Methoden, die von der Objektklasse geerbt sind;</li>
	   <li>Dynamische Eigenschaften: Eigenschaften, die zu einem Objekt hinzugefügt werden, nachdem es instanziiert ist (also außerhalb seiner Klassendefinition). Damit Sie dynamische Eigenschaften hinzufügen können, muss die Klasse, die das Objekt definiert, mit dem Schlüsselwort <codeph>dynamic</codeph> deklariert worden sein.</li>
	 </ul>
	 <p>Bei den folgenden Eigenschaften gibt diese Methode für solche Objekte den Wert <codeph>false</codeph> zurück, die Instanzen einer Klasse sind:</p>
	 <ul>
	   <li>Statische Eigenschaften: Variablen, Konstanten oder Methoden, die in der Klasse, die das Objekt definiert, oder einer übergeordneten Klasse mit dem Schlüsselwort „static“ definiert worden sind;</li>
	   <li>Prototypeigenschaften: Eigenschaften, die für ein Prototypobjekt definiert wurden, das Teil der Prototypkette des Objekts ist. In ActionScript 3.0 wird die Prototypkette nicht für die Klassenvererbung eingesetzt, existiert aber weiterhin als alternative Vererbungsform. So kann beispielsweise eine Instanz der Array-Klasse auf die Methode <codeph>valueOf()</codeph> zugreifen, weil sie in <codeph>Object.prototype</codeph> existiert, was wiederum Teil der Prototypkette der Array-Klasse ist. Obwohl Sie <codeph>valueOf()</codeph> für eine Array-Instanz verwenden können ist der Wert von <codeph>hasOwnProperty("valueOf")</codeph> für diese Instanz <codeph>false</codeph>.</li>
	 </ul>
	 
	 <p platform="actionscript">ActionScript 3.0 besitzt auch Klassenobjekte, die direkte Repräsentationen von Klassendefinitionen darstellen. Wird die Methode <codeph>hasOwnProperty()</codeph> für Klassenobjekte aufgerufen, gibt sie nur dann den Wert <codeph>true</codeph> zurück, wenn eine Eigenschaft eine statische Eigenschaft ist, die für das betreffende Klassenobjekt definiert worden ist. Wenn Sie beispielsweise eine Unterklasse von Array mit dem Namen „CustomArray“ erstellen und in CustomArray eine statische Eigenschaft mit dem Namen <codeph>foo</codeph> definieren, gibt ein Aufruf von <codeph>CustomArray.hasOwnProperty("foo")</codeph> den Wert <codeph>true</codeph> zurück. Für die statische Eigenschaft <codeph>DESCENDING</codeph> hingegen, die in der Array-Klasse definiert wurde, gibt ein Aufruf von <codeph>CustomArray.hasOwnProperty("DESCENDING")</codeph> den Wert <codeph>false</codeph> zurück.</p>
	 
     <p platform="actionscript"><b>Hinweis:</b> Methoden der Object-Klasse werden für den Prototyp des Objekts dynamisch erstellt. Um diese Methode in eine Unterklasse von Object umzudefinieren, sollten Sie nicht das Schlüsselwort <codeph>override</codeph> verwenden. So implementiert eine Unterklasse von Object beispielsweise <codeph>function hasOwnProperty():Boolean</codeph> anstatt die Basisklasse per „override“ außer Kraft zu setzen.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:isPrototypeOf"><apiName>isPrototypeOf</apiName><shortdesc>
	 Gibt an, ob eine Instanz der Object-Klasse in der Prototypkette des Objekts vorhanden ist, das als Parameter angegeben wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Wenn sich das Objekt in der Prototypkette des Objekts befindet, das vom Parameter <codeph>theClass</codeph> angegeben wird, lautet der Wert <codeph>true</codeph>; andernfalls <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>theClass</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Die Klasse, auf die das angegebene Objekt verweisen kann.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob eine Instanz der Object-Klasse in der Prototypkette des Objekts vorhanden ist, das als Parameter angegeben wurde. Diese Methode gibt <codeph>true</codeph> zurück, wenn sich das Objekt in der Prototypkette des Objekts befindet, das vom Parameter <codeph>theClass</codeph> angegeben wird. Die Methode gibt <codeph>false</codeph> nicht nur dann zurück, wenn das Zielobjekt in der Prototypkette des <codeph>theClass</codeph>-Objekts fehlt, sondern auch dann, wenn der <codeph>theClass</codeph>-Parameter kein Objekt ist.
	 
     <p platform="actionscript"><b>Hinweis:</b> Methoden der Object-Klasse werden für den Prototyp des Objekts dynamisch erstellt. Um diese Methode in eine Unterklasse von Object umzudefinieren, sollten Sie nicht das Schlüsselwort <codeph>override</codeph> verwenden. So implementiert eine Unterklasse von Object beispielsweise <codeph>function isPrototypeOf():Boolean</codeph> anstatt die Basisklasse per „override“ außer Kraft zu setzen.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	 Gibt an, ob die angegebene Eigenschaft vorhanden ist und durchlaufen werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a generic object, adds a property to the object, then checks whether the object is enumerable. By way of contrast, the example also shows that a built-in property, the <code>Array.length</code> property, is not enumerable.
	 <listing>
	 var myObj:Object = new Object();
	 myObj.prop1 = "hello";
	 trace(myObj.propertyIsEnumerable("prop1")); // true
	 
	 var myArray = new Array();
	 trace(myArray.propertyIsEnumerable("length")); // false
	 </listing> 
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Wenn die durch den Parameter <codeph>name</codeph> angegebene Eigenschaft durchlaufen werden kann, lautet dieser Wert<codeph>true</codeph>; andernfalls <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Eigenschaft des Objekts.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob die angegebene Eigenschaft vorhanden ist und durchlaufen werden kann. Wenn <codeph>true</codeph>, ist die Eigenschaft vorhanden und kann in einer <codeph>for..in</codeph>-Schleife durchlaufen werden. Die Eigenschaft muss im Zielobjekt vorhanden sein, da diese Methode nicht die Prototypkette des Zielobjekts prüft.
	 
	 <p>Eigenschaften, die Sie erstellen, können durchlaufen werden, integrierte Eigenschaften können jedoch im Allgemeinen nicht durchlaufen werden.</p>
	 
     <p platform="actionscript"><b>Hinweis:</b> Methoden der Object-Klasse werden für den Prototyp des Objekts dynamisch erstellt. Um diese Methode in eine Unterklasse von Object umzudefinieren, sollten Sie nicht das Schlüsselwort <codeph>override</codeph> verwenden. So implementiert eine Unterklasse von Object beispielsweise <codeph>function propertyIsEnumerable():Boolean</codeph> anstatt die Basisklasse per „override“ außer Kraft zu setzen.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:setPropertyIsEnumerable"><apiName>setPropertyIsEnumerable</apiName><shortdesc>
     Legt die Verfügbarkeit einer dynamischen Eigenschaft für Schleifenoperationen fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Eigenschaft des Objekts.
     </apiDesc></apiParam><apiParam><apiItemName>isEnum</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc> Ist eine dynamische Eigenschaft auf <codeph>false</codeph> gesetzt, kommt sie in <codeph>for..in</codeph>-Schleifen nicht vor, und die Methode <codeph>propertyIsEnumerable()</codeph> gibt <codeph>false</codeph> zurück. 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Legt die Verfügbarkeit einer dynamischen Eigenschaft für Schleifenoperationen fest. Die Eigenschaft muss im Zielobjekt vorhanden sein, da diese Methode nicht die Prototypkette des Zielobjekts prüft.
     </apiDesc></apiOperationDetail><related-links><link href="#Object/propertyIsEnumerable()"><linktext>propertyIsEnumerable()</linktext></link></related-links></apiOperation><apiOperation id="Object:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 Gibt die Stringdarstellung dieses Objekts zurück, formatiert entsprechend den Konventionen des Gebietsschemas.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tolocalestring, tolocalestring
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine Stringdarstellung dieses Objekts, lokalen Konventionen entsprechend formatiert.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt die Stringdarstellung dieses Objekts zurück, formatiert entsprechend den Konventionen des Gebietsschemas.
	 
	 <p>Die Standardimplementierung dieser Methode führt keine gebietsschemaspezifische Formatierung aus und gibt denselben String wie<codeph>toString</codeph> zurück. Unterklassen sollten ggf. ihre eigenen, das Gebietsschema berücksichtigenden Implementierungen bereitstellen.</p>
	 
     <p platform="actionscript"><b>Hinweis:</b> Methoden der Object-Klasse werden für den Prototyp des Objekts dynamisch erstellt. Um diese Methode in eine Unterklasse von Object umzudefinieren, sollten Sie nicht das Schlüsselwort <codeph>override</codeph> verwenden. So implementiert eine Unterklasse von Object beispielsweise <codeph>function toLocaleString():String</codeph>, anstatt die Basisklasse per „override“ außer Kraft zu setzen.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiOperation id="Object:toString"><apiName>toString</apiName><shortdesc>
	 Gibt das angegebene Objekt als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die Stringdarstellung des Objekts.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt das angegebene Objekt als String zurück.
	 
     <p platform="actionscript"><b>Hinweis:</b> Methoden der Object-Klasse werden für den Prototyp des Objekts dynamisch erstellt. Um diese Methode in eine Unterklasse von Object umzudefinieren, sollten Sie nicht das Schlüsselwort <codeph>override</codeph> verwenden. So implementiert eine Unterklasse von Object beispielsweise <codeph>function toString():String</codeph> anstatt die Basisklasse per „override“ außer Kraft zu setzen.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Gibt den Grundwert des angegebenen Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.valueof, valueof
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Grundwert des angegebenen Objekts oder das Objekt selbst.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den Grundwert des angegebenen Objekts zurück. Wenn das Objekt keinen Grundwert aufweist, wird das Objekt selbst zurückgegeben.
	 
     <p platform="actionscript"><b>Hinweis:</b> Methoden der Object-Klasse werden für den Prototyp des Objekts dynamisch erstellt. Um diese Methode in eine Unterklasse von Object umzudefinieren, sollten Sie nicht das Schlüsselwort <codeph>override</codeph> verwenden. So implementiert eine Unterklasse von Object beispielsweise <codeph>function valueOf():Object</codeph> anstatt die Basisklasse per „override“ außer Kraft zu setzen.</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiValue id="Object:constructor"><apiName>constructor</apiName><shortdesc>
	 Ein Verweis auf das Klassenobjekt oder die Konstruktorfunktion für eine angegebene Objektinstanz.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Object, Object.constructor, constructor
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Verweis auf das Klassenobjekt oder die Konstruktorfunktion für eine angegebene Objektinstanz. Ist ein Objekt eine Instanz einer Klasse, enthält die <codeph>constructor</codeph>-Eigenschaft einen Verweis auf das Klassenobjekt. Wird ein Objekt mit einer Konstruktorfunktion erstellt, enthält die <codeph>constructor</codeph>-Eigenschaft einen Verweis auf die Konstruktorfunktion. Verwechseln Sie eine Konstruktorfunktion jedoch nicht mit den Konstruktormethoden einer Klasse. Eine Konstruktorfunktion ist ein Function-Objekt, das zum Erstellen von Objekten verwendet wird, und stellt eine Alternative dar zum Verwenden des Schlüsselworts <codeph>class</codeph> für das Definieren einer Klasse.
	 
	 <p platform="actionscript">Wenn Sie eine Klasse mithilfe des Schlüsselworts <codeph>class</codeph> definieren, wird das Prototypobjekt der Klasse einer Eigenschaft mit dem Namen <codeph>constructor</codeph> zugewiesen, die einen Verweis auf das Klassenobjekt enthält. Eine Instanz der Klasse erbt diese Eigenschaft von dem Prototypobjekt. Der folgende Code erstellt beispielsweise eine neue Klasse, <codeph>A</codeph>, sowie eine Klasseninstanz mit dem Namen <codeph>myA</codeph>:</p>
	 <codeblock platform="actionscript" rev="3.0">
	 dynamic class A {}
	 trace(A.prototype.constructor);      // [class A]
	 trace(A.prototype.constructor == A); // true
	 var myA:A = new A();
	 trace(myA.constructor == A);         // true</codeblock>
	 
	 <p platform="actionscript">Fortgeschrittene Benutzer verwenden vielleicht anstelle des Schlüsselworts <codeph>function</codeph> lieber das Schlüsselwort <codeph>class</codeph>, um ein Function-Objekt zu definieren, das als Vorlage für die Erstellung von Objekten eingesetzt werden kann. Eine solche Funktion nennt man eine Konstruktorfunktion, da sie zusammen mit dem Operator <codeph>new</codeph> verwendet werden kann, um Objekte zu erstellen. Wenn Sie eine Konstruktorfunktion mithilfe des Schlüsselworts <codeph>function</codeph> definieren, wird das Prototypobjekt der Klasse einer Eigenschaft mit dem Namen <codeph>constructor</codeph> zugewiesen, die einen Verweis auf die Konstruktorfunktion enthält. Wenn Sie die Konstruktorfunktion verwenden, um ein Objekt zu erstellen, erbt das Objekt die <codeph>constructor</codeph>-Eigenschaft vom Prototypobjekt der Konstruktorfunktion. Der folgende Code erstellt beispielsweise eine neue Konstruktorfunktion, <codeph>f</codeph>, sowie ein Objekt mit dem Namen <codeph>myF</codeph>:</p>
	 <codeblock platform="actionscript" rev="3.0">
	 function f() {}
	 trace(f.prototype.constructor);      // function Function() {}
	 trace(f.prototype.constructor == f); // true
	 var myF = new f();
	 trace(myF.constructor == f);         // true</codeblock>
	 
	 <p><b>Hinweis</b>: Die <codeph>constructor</codeph>-Eigenschaft ist änderbar, d. h., der Benutzercode kann ihren Wert durch eine Zuweisungsanweisung ändern. Es wird nicht empfohlen, den Wert der <codeph>constructor</codeph>-Eigenschaft zu ändern, doch wenn Sie Code schreiben, der von dem Wert der <codeph>constructor</codeph>-Eigenschaft abhängig ist, sollten Sie sicherstellen, dass der Wert nicht zurückgesetzt wird. Der Wert kann nur geändert werden, wenn über das Prototypobjekt auf die Eigenschaft zugegriffen wird (z. B. <codeph>className.prototype.constructor</codeph>).</p>
     <p>Wenn Sie auf die <codeph>constructor</codeph>-Eigenschaft zugreifen und sie im Strict-Modus kompilieren, erhalten Sie einen Fehler beim Kompilieren, da die Konstruktoreigenschaft vom Prototypobjekt abhängt, das eine Laufzeiteinheit ist. Wenn Sie den Standardmodus verwenden oder wenn die Klassenbeschreibung „dynamic“ festlegt, wird der Code ausgeführt, ohne einen Fehler zu generieren.</p>     
	 </apiDesc></apiValueDetail><related-links><link href="#Class"><linktext>Klasse</linktext></link><link href="#Function"><linktext>Funktion</linktext></link><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links></apiValue><apiValue id="Object:prototype"><apiName>prototype</apiName><shortdesc>
	 Ein Verweis auf das Prototypobjekt einer Klasse oder eines Funktionsobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a class named Shape and a subclass of Shape named Circle.
	 <listing version="2.0">
	 // Shape class defined in external file named Shape.as
	 class Shape {
	 	function Shape() {}
	 }
	 
	 // Circle class defined in external file named Circle.as
	 class Circle extends Shape{
	 	function Circle() {}
	 }
	 </listing>
	 The Circle class can be used to create two instances of Circle:
	 <listing version="2.0">
	 var oneCircle:Circle = new Circle();
	 var twoCircle:Circle = new Circle();
	 </listing>
	 The following trace statement shows that the <code>prototype</code> property of the Circle class points to its superclass Shape. The identifier <code>Shape</code> refers to the constructor function of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.constructor == Shape); // true
	 </listing>
	 The following trace statement shows how you can use the <code>prototype</code> property and the <code>__proto__</code> property together to move two levels up the inheritance hierarchy (or prototype chain). The <code>Circle.prototype.__proto__</code> property contains a reference to the superclass of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.__proto__ == Shape.prototype); // true
	 </listing>
	 
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Verweis auf das Prototypobjekt einer Klasse oder eines Funktionsobjekts. Die <codeph>prototype</codeph>-Eigenschaft wird automatisch erstellt und an die erstellten Klassen oder Funktionsobjekte angehängt. Diese Eigenschaft ist insofern statisch, als sie spezifisch für die Klasse oder Funktion gilt, die Sie erstellen. Wenn Sie beispielsweise eine benutzerdefinierte Klasse erstellen, wird der Wert der Eigenschaft <codeph>prototype</codeph> von allen Instanzen der Klasse verwendet und ist nur als Klasseneigenschaft zugänglich. Instanzen Ihrer Klasse können die <codeph>prototype</codeph>-Eigenschaft nicht direkt erreichen. 
	 
     <p>Das Prototypobjekt einer Klasse ist eine spezielle Instanz dieser Klasse, die eine Funktionalität bereitstellt, durch die ein Status von allen Instanzen einer Klasse genutzt werden kann. Wenn während der Laufzeit für eine Klasseninstanz eine bestimmte Eigenschaft nicht gefunden wird, wird das Delegate-Objekt, das identisch ist mit dem Klassenprototypobjekt, auf die Eigenschaft hin überprüft. Enthält das Prototypobjekt die Eigenschaft auch nicht, wird der Vorgang fortgesetzt, indem das Delegate-Objekt des Prototypobjekts in der nächsthöheren Hierarchieebene sucht, bis die Eigenschaft von <ph platform="actionscript">Flash Player oder</ph> Adobe Integrated Runtime gefunden wird. </p>
	 
     <p platform="actionscript"><i>Hinweis:</i> In ActionScript 3.0 ist die Prototypvererbung nicht die primäre Vererbungsart. Vielmehr ist die Klassenvererbung, die die Vererbung fester Klassen in Klassendefinitionen unterbringt, die primäre Vererbungsart in ActionScript 3.0.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:SecurityError"><apiName>SecurityError</apiName><shortdesc>
 Die SecurityError-Klasse wird ausgelöst, wenn irgendeine Art von Sicherheitsverletzung eintritt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SecurityError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Ausnahme <codeph>SecurityError</codeph> wird ausgelöst, wenn irgendeine Art von Sicherheitsverletzung eintritt.
 <p>
 Beispiele für Sicherheitsfehler:</p>
 <ul>
   <li>Es findet ein nicht autorisierter Zugriff auf eine Eigenschaft oder ein nicht autorisierter Aufruf einer Methode statt, über die Grenzen einer Sicherheits-Sandbox hinweg.</li>
   <li>Es wurde versucht, auf eine URL-Adresse zuzugreifen die von der Sicherheits-Sandbox nicht zugelassen ist.</li>
   <li>Es wurde versucht, eine Socketverbindung zu einer nicht autorisierten Portnummer herzustellen, z. B. zu einem Port mit einer höheren Nummer als 65535.</li>
   <li>Es wurde versucht, auf die Kamera oder das Mikrofon eines Benutzers zuzugreifen, und die Zugriffsanforderung wurde vom Benutzer abgelehnt.</li>
 </ul>
 
 </apiDesc><example conref="examples\SecurityErrorExample.as"> Dieses Beispiel veranschaulicht, wie <codeph>SecurityError</codeph>-Fehler erzeugt und in einer <codeph>try...catch</codeph>-Anweisung verarbeitet werden kann, indem versucht wird, eine Verbindung zu einem Port mit einer höheren Nummer als der maximal zulässigen herzustellen.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.Socket;

    public class SecurityErrorExample extends Sprite {

        public function SecurityErrorExample() {
            try {
                var host:String = "www.[yourDomain].com";
                var socket:Socket = new Socket();
                socket.connect(host, 65536);
            }
            catch(e:SecurityError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="SecurityError:SecurityError"><apiName>SecurityError</apiName><shortdesc>
	 Erstellt ein neues SecurityError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues SecurityError-Objekt.
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
 Beim Versuch, auf ein versiegeltes (nicht dynamisches) Objekt zu verweisen, wird eine ReferenceError-Ausnahme ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, ReferenceError
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Beim Versuch, auf ein versiegeltes (nicht dynamisches) Objekt zu verweisen, wird eine ReferenceError-Ausnahme ausgelöst. Verweise auf nicht definierte Variablen resultieren in ReferenceError-Ausnahmen, die Sie über mögliche Fehler informieren und bei der Fehlersuche im Anwendungscode unterstützen sollen.
 <p>Allerdings ist es möglich, auf nicht definierte Eigenschaften einer dynamischen Klasse zu verweisen ohne eine ReferenceError-Ausnahme zu verursachen. Weitere Informationen hierzu finden Sie in der Beschreibung des Schlüsselworts <codeph>dynamic</codeph>.</p>
 
 </apiDesc><example conref="examples\ReferenceErrorExample.as"> Dieses Beispiel veranschaulicht, wie eine <codeph>ReferenceError</codeph>-Ausnahme erzeugt und in einer<codeph>try..catch</codeph>-Anweisung verarbeitet wird. 
<codeblock>
package {
    import flash.display.Sprite;

    public class ReferenceErrorExample extends Sprite {

        public function ReferenceErrorExample() {
            try {
                this["someMember"] = true;
            }
            catch(e:ReferenceError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#dynamic"><linktext>dynamic-Schlüsselwort</linktext></link></related-links><apiConstructor id="ReferenceError:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
	 Erstellt ein neues ReferenceError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Enthält die mit dem ReferenceError-Objekt verbundene Meldung.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues ReferenceError-Objekt.
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:RangeError"><apiName>RangeError</apiName><shortdesc>
 Es wird eine RangeError-Ausnahme ausgelöst, wenn ein numerischer Wert außerhalb des akzeptierbaren Bereichs liegt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, RangeError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Es wird eine RangeError-Ausnahme ausgelöst, wenn ein numerischer Wert außerhalb des akzeptierbaren Bereichs liegt. Wenn Sie mit Arrays arbeiten und auf die Indexposition eines Arrays verweisen, die gar nicht existiert, wird eine RangeError-Ausnahme ausgelöst. Bei Verwendung der Methoden <codeph>Number.toExponential()</codeph>, <codeph>Number.toPrecision()</codeph> und <codeph>Number.toFixed()</codeph> wird eine RangeError-Ausnahme ausgelöst, wenn sich die Argumente außerhalb des akzeptierbaren Zahlenbereichs befinden. Sie können <codeph>Number.toExponential()</codeph>, <codeph>Number.toPrecision()</codeph> und <codeph>Number.toFixed()</codeph> erweitern, um einen solchen RangeError-Fehler zu vermeiden.
 <p product="flash">Auch die folgenden Situationen können diese Ausnahme verursachen:
 <ul>
   <li>Jede Flash Player-API, die eine Zahl für die Tiefe erwartet, wird mit einer unzulässigen Tiefennummer aufgerufen.</li>
   <li>Jede Flash Player-API, die eine Zahl für die Bildposition erwartet, wird mit einer unzulässigen Bildnummer aufgerufen.</li>
   <li>Jede Flash Player-API, die eine Zahl für die Ebenennummer erwartet, wird mit einer unzulässigen Ebenennummer aufgerufen.</li>
 </ul>
 </p>
 </apiDesc><example conref="examples\RangeErrorExample.as"> Dieses Beispiel veranschaulicht, wie eine <codeph>RangeError</codeph>-Ausnahme erzeugt und in einer<codeph>try..catch</codeph>-Anweisung verarbeitet wird. 
<codeblock>
package {
    import flash.display.Sprite;

    public class RangeErrorExample extends Sprite {

        public function RangeErrorExample() {
            var child:Sprite = new Sprite();
            try {
                addChildAt(child, 1);
            }
            catch(e:RangeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Number/toExponential()"><linktext>Number.toExponential()</linktext></link><link href="#Number/toPrecision()"><linktext>Number.toPrecision()</linktext></link><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links><apiConstructor id="RangeError:RangeError"><apiName>RangeError</apiName><shortdesc>
	 Erstellt ein neues RangeError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Enthält die mit dem RangeError-Objekt verbundene Meldung.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues RangeError-Objekt.
	 </apiDesc></apiConstructorDetail><related-links><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:int"><apiName>int</apiName><shortdesc>
 Die int-Klasse ermöglicht Ihnen die Arbeit mit einem Datentyp, der eine 32-Bit-Ganzzahl mit Vorzeichen repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int object, int, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die int-Klasse ermöglicht Ihnen die Arbeit mit einem Datentyp, der eine 32-Bit-Ganzzahl mit Vorzeichen repräsentiert. Der von der int-Klasse repräsentierte Wertebereich liegt zwischen -2.147.483.648 (-2^31) und 2.147.483.647 (2^31-1).
 <p>Die konstanten Eigenschaften der int-Klasse, <codeph>MAX_VALUE</codeph> <codeph>MIN_VALUE</codeph>, sind statisch, d. h., Sie können sie verwenden, ohne dass ein Objekt nötig ist. Somit ist kein Konstruktor erforderlich. Die Methoden sind allerdings nicht statisch, d. h., Sie benötigen ein Objekt, um sie zu verwenden. Sie können ein int-Objekt erstellen, indem Sie den int-Klassenkonstruktor verwenden oder eine Variable vom Typ int deklarieren und der Variable einen Literalwert zuweisen.</p>
 <p>Der int-Datentyp ist nützlich für Schleifenzähler und andere Situationen, in denen keine Gleitkommazahl benötigt wird, und ähnelt dem int-Datentyp in Java und C++. Der Standardwert einer Variable vom Typ int lautet <codeph>0</codeph></p>
 <p>Wenn Sie mit Zahlen arbeiten, die den Wert <codeph>int.MAX_VALUE</codeph> überschreiten, sollten Sie es in Betracht ziehen, den Datentyp Number zu verwenden.  </p>
 <p>Im folgenden Beispiel wird die Methode <codeph>toString()</codeph> der int-Klasse aufgerufen, die den String <codeph>1234</codeph> zurückgibt: </p>
 <codeblock rev="3.0">
 var myint:int = 1234;
 myint.toString();
 </codeblock>
 <p>Im folgenden Beispiel wird der Wert der Eigenschaft <codeph>MIN_VALUE</codeph> einer Variablen zugewiesen, die ohne den Konstruktor deklariert wurde:</p>
 <pre>
 var smallest:int = int.MIN_VALUE;
 </pre> 
 
 </apiDesc><example conref="examples\IntExample.as"> Im folgenden Beispiel wird mithilfe der <codeph>IntExample</codeph>-Klasse veranschaulicht, wie Sie mit int-Datentypen arbeiten und ihre Gültigkeit prüfen:
 <ol>
     <li>Im Konstruktor werden zwei int-Variablen <codeph>a</codeph> und <codeph>b</codeph> deklariert.</li>
     <li>Diese beiden int-Variablen werden mithilfe der Methode <codeph>addIntegers()</codeph> hinzugefügt.</li>
     <li>Einer dritten int-Variablen <codeph>c</codeph> wird das Ergebnis von <codeph>parseInteger()</codeph> zugewiesen. Sie überprüft die Gültigkeit des ihr übergebenen Strings, um sicherzustellen, dass es sich um eine Ganzzahl im für int-Datentypen akzeptierbaren Zahlenbereich handelt. Ist dies der Fall, wird ein „int“ gleich der Ganzzahl des Strings zurückgegeben.</li>
     <li>Die int-Variablen <codeph>a</codeph> und <codeph>c</codeph> werden mihilfe von <codeph>addIntegers()</codeph> hinzugefügt.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class IntExample extends Sprite {    
        public function IntExample() {
            var a:int = 512;
            var b:int = -128;
            
            trace(addIntegers(a, b)); // 384

            var c:int = parseInteger("32");
            
            trace(addIntegers(a, c)); // 544
        }
            
        public function addIntegers(a:int, b:int):int {
            return a + b;
        }
        
        public function parseInteger(str:String):int {
            var num:Number = parseInt(str);
            if(!isNaN(num) &amp;&amp; num &lt;= int.MAX_VALUE &amp;&amp; num >= int.MIN_VALUE) {
                return int(num);
            }
            
            return 0;
        }
        
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="uint.html"><linktext>uint</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="int:int"><apiName>int</apiName><shortdesc>
	 Konstruktor; erstellt ein neues int-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Der numerische Wert des zu erstellenden int-Objekts oder ein Wert, der in eine Zahl umgewandelt werden soll. Wenn <codeph>value</codeph> nicht angegeben wird, gilt der Standardwert 0.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Konstruktor; erstellt ein neues int-Objekt. Wenn Sie mit <codeph>int.toString()</codeph> und <codeph>int.valueOf()</codeph> arbeiten, müssen Sie den int-Konstruktor verwenden. Wenn Sie mit den Eigenschaften eines int-Objekts arbeiten, verwenden Sie keinen Konstruktor. Der <codeph>new int</codeph>-Konstruktor dient hauptsächlich als Platzhalter. Ein int-Objekt entspricht nicht der Funktion <codeph>int()</codeph>, die einen Parameter in einen Grundwert umwandelt.
	 
 	 </apiDesc><example>Der folgende Code erstellt neue int-Objekte:
	 <pre>
	 var n1:int = new int(3.4);
	 var n2:int = new int(-10);
	 </pre>
	 
	 
	 </example></apiConstructorDetail><related-links><link href="#int/toString()"><linktext>int.toString()</linktext></link><link href="#int/valueOf()"><linktext>int.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="int:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      Gibt eine Zahl in Exponentialschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>fractionDigits</codeph> nicht zwischen 0 und 20 liegt.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 0 und 20 (einschließlich), die die gewünschte Anzahl an Dezimalstellen repräsentiert.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Gibt eine Zahl in Exponentialschreibweise als String zurück. Der String enthält eine Ziffer vor der Dezimalstelle und bis zu 20 Nachkommastellen, gemäß der Angabe im Parameter <codeph>fractionDigits</codeph>.
      </apiDesc><example conref="examples\Number.toExponential.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings in Exponentialschreibweise durch <codeph>toFixed(2)</codeph>.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     Gibt eine Zahl in Festkommaschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>fractionDigits</codeph> nicht zwischen 0 und 20 liegt.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 0 und 20 (einschließlich), die die gewünschte Anzahl an Dezimalstellen repräsentiert.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt eine Zahl in Festkommaschreibweise als String zurück. Festkommaschreibweise bedeutet, dass der String eine bestimmte Anzahl an Nachkommastellen enthält, und zwar gemäß der Angabe im Parameter <codeph>fractionDigits</codeph>. Die zulässigen Werte für den Parameter <codeph>fractionDigits</codeph> liegen zwischen 0 und 20. Wird ein Wert außerhalb dieses Bereichs angegeben, wird eine Ausnahme ausgelöst.
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings durch <codeph>toFixed(3)</codeph>, mit dem auf drei Dezimalstellen aufgerundet wird.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings durch <codeph>toFixed(2)</codeph>, mit dem nachgestellte Nullen hinzugefügt werden.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      Gibt eine Zahl in Exponential- oder Festkommaschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>precision</codeph> nicht zwischen 1 und 21 liegt.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 1 und 21 (einschließlich), die die gewünschte Anzahl an Nachkommastellen für die Darstellung des Strings repräsentiert.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Gibt eine Zahl in Exponential- oder Festkommaschreibweise als String zurück. Der String enthält die im Parameter <codeph>precision</codeph> angegebene Anzahl an Ziffern.
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings mit nur drei Stellen durch <codeph>toFixed(3)</codeph>. Der String wird in Festkommaschreibweise zurückgegeben, da Exponentialschreibweise nicht erforderlich ist.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings mit nur drei Stellen durch <codeph>toFixed(3)</codeph>. Der String wird in Exponentialschreibweise zurückgegeben, da die Anzahl an Stellen der sich ergebenden Zahl nicht ausreichen für die Festkommaschreibweise.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Gibt das angegebene int-Objekt als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein String.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Gibt die numerische Basis (von 2 bis 36) an, die bei der Umwandlung von Zahlen in Strings verwendet werden soll. Wenn Sie den Parameter <codeph>radix</codeph> nicht angeben, wird als Standardwert 10 verwendet.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt das angegebene <codeph>int</codeph>-Objekt als String zurück.
	 
	 </apiDesc><example>Im folgenden Beispiel wird 2 und 8 für den <codeph>radix</codeph>-Parameter verwendet und eine Zeichenfolge ausgegeben, in der die entsprechende Angabe der Zahl 9 enthalten ist.
	 <pre>
	 var myint:int = new int(9);
	 trace(myint.toString(2)); // 1001
	 trace(myint.toString(8)); // 11
	 </pre>
	 <p>Das folgende Beispiel ergibt einen Hexadezimalwert.</p>
	 <pre>
	 var r:int = new int(250);
	 var g:int = new int(128);
	 var b:int = new int(114);
	 var rgb:String = "0x"+ r.toString(16)+g.toString(16)+b.toString(16);
	 trace(rgb); // 0xfa8072
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Gibt den Grundwert des angegebenen int-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein int-Wert.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den Grundwert des angegebenen int-Objekts zurück.
	 
 	 </apiDesc><example>Das folgende Beispiel ergibt den Grundwert des <codeph>numSocks</codeph>-Objekts.
	 <pre>
	 var numSocks:int = new int(2);
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="int:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	Die größte darstellbare vorzeichenbehaftete 32-Bit-Ganzzahl, nämlich 2.147.483.647.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2147483647</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
	Die größte darstellbare vorzeichenbehaftete 32-Bit-Ganzzahl, nämlich 2.147.483.647.
	
    </apiDesc><example>Der·folgende·ActionScript-Code·<ph outputclass="flashonly">zeigt</ph> <ph outputclass="flexonly">schreibt </ph>das größte und kleinste darstellbare „int“-Objekt <ph outputclass="flashonly">￼im·Bedienfeld·„Ausgabe“ an</ph><ph outputclass="flexonly">in die Protokolldatei</ph>:
	<pre>
	trace("int.MIN_VALUE = "+int.MIN_VALUE);
	trace("int.MAX_VALUE = "+int.MAX_VALUE);
	</pre>
	<p>Mit diesem Code werden die folgenden Werte <ph outputclass="flexonly">protokolliert</ph><ph outputclass="flashonly">angezeigt</ph>: </p>
	<pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
	</pre>
	
	
	</example></apiValueDetail></apiValue><apiValue id="int:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 Die kleinste darstellbare vorzeichenbehaftete 32-Bit-Ganzzahl, nämlich -2.147.483.648.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>-2147483648</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die kleinste darstellbare vorzeichenbehaftete 32-Bit-Ganzzahl, nämlich -2.147.483.648.
	 
 	 </apiDesc><example>Der·folgende·ActionScript-Code·<ph outputclass="flashonly">zeigt </ph> <ph outputclass="flexonly">schreibt </ph>das größte und kleinste darstellbare „int“-Objekt <ph outputclass="flashonly">￼im·Bedienfeld·„Ausgabe“ an</ph><ph outputclass="flexonly">in die Protokolldatei</ph>:
     <pre>
     trace("int.MIN_VALUE = "+int.MIN_VALUE);
     trace("int.MAX_VALUE = "+int.MAX_VALUE);
     </pre>
     <p>Mit diesem Code werden die folgenden Werte <ph outputclass="flexonly">protokolliert</ph><ph outputclass="flashonly">angezeigt</ph>: </p>
     <pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
     </pre>
     
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Number"><apiName>Number</apiName><shortdesc>
 Ein Datentyp, der eine Gleitkommazahl nach IEEE -754 mit doppelter Genauigkeit repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number object, number, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Bei der Number-Klasse handelt es sich um ein einfaches Wrapper-Objekt für den <codeph>Number</codeph>-Datentyp.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Ein Datentyp, der eine Gleitkommazahl nach IEEE -754 mit doppelter Genauigkeit repräsentiert. Sie können Grundwerte manipulieren, indem Sie die der Number-Klasse zugeordneten Methoden und Eigenschaften verwenden. Diese Klasse ist mit der Number-Klasse in JavaScript identisch.
 <p>Die Eigenschaften der Number-Klasse sind statisch, d. h., Sie können sie verwenden, ohne dass ein Objekt nötig ist. Somit ist kein Konstruktor erforderlich.</p>
 <p>Der Datentyp Number hält sich an den IEEE-754-Standard (doppelt genau). </p>
 <p>Der Datentyp Number ist nützlich, wenn Sie Gleitkommawerte verwenden müssen. Flash Player behandelt die Datentypen int und uint effektiver als Number, doch ist Number praktisch in Situationen, in denen der erforderliche Wertebereich den Wertebereich der Datentypen int und uint überschreitet. Die Number-Klasse kann zur Darstellung von Ganzzahlwerten verwendet werden, die weit über den gültigen Bereich der Datentypen int und uint hinausgehen. Der Datentyp Number kann bis zu 53 Bits verwenden, um ganzzahlige Werte darzustellen, im Gegensatz zu 32 Bits bei int und uint. Der Standardwert einer als Number eingegebenen Variable ist <codeph>NaN</codeph> (Not a Number, keine Zahl).</p>
 
 </apiDesc><example conref="examples\NumberExample.as"> Das folgende Beispiel veranschaulicht, wie eine Zahl mit sechs Nachkommastellen durch Abrunden auf eine Zahl mit zwei Nachkommastellen verkürzt wird.
<codeblock>

package {
    import flash.display.Sprite;

    public class NumberExample extends Sprite {
        public function NumberExample() {
            var num:Number = new Number(10.456345);
            var str:String = num.toFixed(2);
            trace(num); // 10.456345
            trace(str); // 10.46
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="uint.html"><linktext>uint</linktext></link></related-links><apiConstructor id="Number:Number"><apiName>Number</apiName><shortdesc>
  Erstellt ein Number-Objekt mit dem angegebenen Wert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Der numerische Wert der zu erstellenden Number-Instanz oder ein Wert, der in eine Zahl umgewandelt werden soll. Der Standardwert ist 0, wenn <codeph>num</codeph> nicht angegeben wird. Den Konstruktor ohne <codeph>num</codeph>-Parameter zu verwenden ist nicht dasselbe wie die Deklaration einer Variable vom Typ Number, ohne ihr einen Wert zuzuweisen (z. B. <codeph>var myNumber:Number</codeph>), wobei der Standardwert <codeph>NaN</codeph> ist. Eine Zahl ohne zugewiesenen Wert ist nicht definiert und ist ein Äquivalent zu <codeph>new Number(undefined)</codeph>.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt ein Number-Objekt mit dem angegebenen Wert.
  
  </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
  Erstellt ein Number-Objekt mit dem angegebenen Wert. Dieser Konstruktor hat denselben Effekt wie die native public-Funktion <codeph>Number()</codeph>, mit der ein Objekt eines anderen Typs in einen numerischen Grundwert umgewandelt wird.
  
  </apiDesc></apiConstructorDetail><related-links><link href="#Number/toString()"><linktext>Number.toString()</linktext></link><link href="#Number/valueOf()"><linktext>Number.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="Number:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
	  Gibt eine Zahl in Exponentialschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>fractionDigits</codeph> nicht zwischen 0 und 20 liegt.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 0 und 20 (einschließlich), die die gewünschte Anzahl an Dezimalstellen repräsentiert.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Gibt eine Zahl in Exponentialschreibweise als String zurück. Der String enthält eine Ziffer vor der Dezimalstelle und bis zu 20 Nachkommastellen, gemäß der Angabe im Parameter <codeph>fractionDigits</codeph>.
	  </apiDesc><example conref="examples\Number.toExponential.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings in Exponentialschreibweise durch <codeph>toFixed(2)</codeph>.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
	 Gibt eine Zahl in Festkommaschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>fractionDigits</codeph> nicht zwischen 0 und 20 liegt.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 0 und 20 (einschließlich), die die gewünschte Anzahl an Dezimalstellen repräsentiert.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt eine Zahl in Festkommaschreibweise als String zurück. Festkommaschreibweise bedeutet, dass der String eine bestimmte Anzahl an Nachkommastellen enthält, und zwar gemäß der Angabe im Parameter <codeph>fractionDigits</codeph>. Die zulässigen Werte für den Parameter <codeph>fractionDigits</codeph> liegen zwischen 0 und 20. Wird ein Wert außerhalb dieses Bereichs angegeben, wird eine Ausnahme ausgelöst.
	 
	 </apiDesc><example conref="examples\Number.toFixed.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings durch <codeph>toFixed(3)</codeph>, mit dem auf drei Dezimalstellen aufgerundet wird.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings durch <codeph>toFixed(2)</codeph>, mit dem nachgestellte Nullen hinzugefügt werden.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
	  Gibt eine Zahl in Exponential- oder Festkommaschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>precision</codeph> nicht zwischen 1 und 21 liegt.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 1 und 21 (einschließlich), die die gewünschte Anzahl an Nachkommastellen für die Darstellung des Strings repräsentiert.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Gibt eine Zahl in Exponential- oder Festkommaschreibweise als String zurück. Der String enthält die im Parameter <codeph>precision</codeph> angegebene Anzahl an Ziffern.
	  </apiDesc><example conref="examples\Number.toPrecision.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings mit nur drei Stellen durch <codeph>toFixed(3)</codeph>. Der String wird in Festkommaschreibweise zurückgegeben, da Exponentialschreibweise nicht erforderlich ist.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings mit nur drei Stellen durch <codeph>toFixed(3)</codeph>. Der String wird in Exponentialschreibweise zurückgegeben, da die Anzahl an Stellen der sich ergebenden Zahl nicht ausreichen für die Festkommaschreibweise.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toString"><apiName>toString</apiName><shortdesc>
 Gibt das angegebene Number-Objekt (myNumber) als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die numerische Repräsentation des Number-Objekts als String.
 
 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>10</apiData><apiDesc>Gibt die numerische Basis (von 2 bis 36) an, die bei der Umwandlung von Zahlen in Strings verwendet werden soll. Wenn Sie den Parameter <codeph>radix</codeph> nicht angeben, wird als Standardwert 10 verwendet.
 
 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Zahl als String zurück, wobei der angegebene radix-Parameter als numerische Basis verwendet wird.
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 Gibt das angegebene Number-Objekt (<codeph><i>myNumber</i></codeph>) als Zeichenfolge zurück. Ist der Wert des Number-Objekts eine Dezimalzahl ohne führende Null (z. B. <codeph>.4</codeph>), fügt <codeph>Number.toString()</codeph> die führende Null hinzu (<codeph>0.4</codeph>).
 
 
 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
 Gibt den Grundwerttyp des angegebenen Number-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Grundwert dieses Number-Objekts.
 
 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt den Grundwerttyp des angegebenen Number-Objekts zurück.
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 Gibt den Grundwerttyp des angegebenen Number-Objekts zurück.
 
 </apiDesc></apiOperationDetail></apiOperation><apiValue id="Number:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc>
  Die größte darstellbare Zahl (IEEE-754, doppelt genau).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.max_value, max_value, max value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die größte darstellbare Zahl (IEEE-754, doppelt genau).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Die größte darstellbare Zahl (IEEE-754, doppelt genau). Diese Zahl lautet ungefähr 1.79E+308.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
  Die kleinste darstellbare Zahl (IEEE-754, doppelt genau).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.min_value, min_value, min value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die kleinste darstellbare Zahl (doppeltgenau nach IEEE-754).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Die kleinste darstellbare Zahl (IEEE-754, doppelt genau). Diese Zahl beträgt ungefähr 5E-324. Die kleinste darstellbare Zahl insgesamt ist <codeph>-Number.MAX_VALUE</codeph>.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NEGATIVE_INFINITY"><apiName>NEGATIVE_INFINITY</apiName><shortdesc>
  Gibt den IEEE-754-Wert an, der für negative Unendlichkeit steht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.negative_infinity, negative_infinity, negative infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Gibt den IEEE-754-Wert an, der für negative Unendlichkeit steht.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Gibt den IEEE-754-Wert an, der für negative Unendlichkeit steht. Der Wert dieser Eigenschaft ist identisch mit dem der Konstanten <codeph>-Infinity</codeph>.
  <p>
  Negative Unendlichkeit ist ein spezieller numerischer Wert, der zurückgegeben wird, wenn eine mathematische Operation oder Funktion einen negativen Wert zurückgibt, der außerhalb des darstellbaren Bereichs liegt.
  </p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NaN"><apiName>NaN</apiName><shortdesc>
  Der Wert für NaN (Not A Number, keine Zahl) nach IEEE-754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.nan, nan, not a number
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Der Wert für NaN (Not A Number, keine Zahl) nach IEEE-754.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Der Wert für <codeph>NaN</codeph> (Not A Number, keine Zahl) nach IEEE-754.
  
  </apiDesc></apiValueDetail><related-links><link href="package.html#isNaN()"><linktext>isNaN()</linktext></link></related-links></apiValue><apiValue id="Number:POSITIVE_INFINITY"><apiName>POSITIVE_INFINITY</apiName><shortdesc>
  Gibt den IEEE-754-Wert an, der für positive Unendlichkeit steht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.positive_infinity, positive_infinity, positive infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Gibt den IEEE-754-Wert an, der für positive Unendlichkeit steht.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Gibt den IEEE-754-Wert an, der für positive Unendlichkeit steht. Der Wert dieser Eigenschaft ist identisch mit dem der Konstanten <codeph>Infinity</codeph>.
  <p>
  Positive Unendlichkeit ist ein spezieller numerischer Wert, der zurückgegeben wird, wenn eine mathematische Operation oder Funktion einen positiven Wert zurückgibt, der außerhalb des darstellbaren Bereichs liegt.
  </p>
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
 Die DefinitionError-Klasse repräsentiert einen Fehler, der auftritt, wenn der Benutzercode versucht, einen Bezeichner zu definieren, der bereits definiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Ein DefinitionError-Fehler wird ausgelöst, wenn der Code versucht eine Klasse, Schnittstelle oder Funktion neu zu definieren.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die DefinitionError-Klasse repräsentiert einen Fehler, der auftritt, wenn der Benutzercode versucht, einen Bezeichner zu definieren, der bereits definiert wurde. Dieser Fehler tritt häufig beim neu Definieren von Klassen, Schnittstellen und Funktionen auf.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="DefinitionError:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
	 Erstellt ein neues DefinitionError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues DefinitionError-Objekt.
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Function"><apiName>Function</apiName><shortdesc>
 Eine Funktion ist die grundlegende Codeeinheit, die in ActionScript aufgerufen werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Die Function-Klasse wird für integrierte Funktionen verwendet.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Eine Funktion ist die grundlegende Codeeinheit, die in ActionScript aufgerufen werden kann. Sowohl benutzerdefinierte als auch integrierte Funktionen in ActionScript werden durch Function-Objekte repräsentiert, die Instanzen der Function-Klasse sind.
 <p>Die Methoden einer Klasse unterscheiden sich etwas von Function-Objekten. Im Gegensatz zu einem gewöhnlichen Function-Objekt ist eine Methode eng an das zugehörige Klassenobjekt gebunden. Daher besitzt eine Methode oder Eigenschaft eine Definition, die von allen Instanzen derselben Klasse genutzt wird. Methoden können aus einer Instanz extrahiert werden, und werden als „gebundene“ Methoden bezeichnet (da sie die Verknüpfung zur Originalinstanz beibehalten). Bei einer gebundenen Methode zeigt das Schlüsselwort <codeph>this</codeph> auf das Objekt, das ursprünglich die Methode implementiert hat. Bei einer Funktion zeigt <codeph>this</codeph> auf das Objekt, das zum Zeitpunkt des Funktionsaufruf verknüpft war.</p>
 
 
 </apiDesc><example conref="examples\FunctionExample.as"> Im folgenden Beispiel werden mithilfe der Klassen <codeph>FunctionExample</codeph>, <codeph>SimpleCollection</codeph>, <codeph>EventBroadcaster</codeph> und <codeph>EventListener</codeph> verschiedene Verwendungsweisen von Funktionen in ActionScript veranschaulicht. Dies wird in den folgenden Schritten erreicht:
 <ol>
    <li>Mit dem Konstruktor für <codeph>FunctionExample</codeph> wird eine lokale Variable mit dem Namen <codeph>simpleColl</codeph> erstellt. Sie wird mit einem Array aus Ganzzahlen gefüllt, die zwischen den Werten <codeph>1</codeph> und <codeph>8</codeph> liegen. </li>
    <li>Das <codeph>simpleColl</codeph>-Objekt wird mithilfe von <codeph>trace()</codeph> gedruckt.</li>
  <li>Ein EventListener-Objekt, <codeph>listener</codeph>, wird zu <codeph>simpleColl</codeph> hinzugefügt.</li>
  <li>Beim Aufrufen der Funktionen <codeph>insert()</codeph> und <codeph>remove()</codeph> reagiert der Listener auf ihre Ereignisse.</li>
    <li>Es wird ein zweites SimpleCollection-Objekt mit dem Namen <codeph>greaterThanFourColl</codeph> erstellt.</li>
    <li>Dem <codeph>greaterThanFourColl</codeph>-Objekt wird das Ergebnis von <codeph>simpleColl.select()</codeph> zusammen mit dem Argument <codeph>4</codeph> und einer anonymen Funktion zugewiesen. Bei der Auswahlmethode des SimpleCollection-Objekts handelt es sich um einen internen Iterator, der den anonymen Funktionsparameter als Block verwendet.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class FunctionExample extends Sprite {
        public function FunctionExample() {
            var simpleColl:SimpleCollection;
            simpleColl = new SimpleCollection(0, 1, 2, 3, 4, 5, 6, 7, 8);
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 8

            var listener:EventListener = new EventListener();
            simpleColl.addListener(listener);
            simpleColl.insert(9);        // itemInsertedHandler: 9
            simpleColl.remove(8);        // itemRemovedHandler: 8
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 9

            var greaterThanFourColl:SimpleCollection;
            greaterThanFourColl = simpleColl.select(4, function(item:int, value:int){ return item > value });
            trace(greaterThanFourColl);    // 5, 6, 7, 9
        }
    }
}
    
import flash.display.Sprite;
    
class EventBroadcaster {
    private var listeners:Array;

    public function EventBroadcaster() {
        listeners = new Array();
    }
        
    public function addListener(obj:Object):void {
        removeListener(obj);
        listeners.push(obj);
    }
        
    public function removeListener(obj:Object):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            if(listeners[i] == obj) {
                listeners.splice(i, 1);
            }
        }
    }
    
    public function broadcastEvent(evnt:String, ...args):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            listeners[i][evnt].apply(listeners[i], args);
        }
    }    
}
    
class SimpleCollection extends EventBroadcaster {
    private var arr:Array;
        public function SimpleCollection(... args) {
        arr = (args.length == 1 &amp;&amp; !isNaN(args[0])) ? new Array(args[0]) : args;
    }
        
    public function insert(obj:Object):void {
        remove(obj);
        arr.push(obj);
        broadcastEvent("itemInsertedHandler", obj);
    }
        
    public function remove(obj:Object):void {
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(arr[i] == obj) {
                var obj:Object = arr.splice(i, 1)[0];
                broadcastEvent("itemRemovedHandler", obj);
            }
        }
    }

    public function select(val:int, fn:Function):SimpleCollection {
        var col:SimpleCollection = new SimpleCollection();
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(fn.call(this, arr[i], val)) {
                col.insert(arr[i]);
            }
        }
        return col;
    }
        
    public function toString():String {
        var str:String = new String();
        for(var i:uint = 0; i &lt; arr.length - 1; i++) {
            str += arr[i] + ", ";
        }
        str += arr[arr.length - 1];
        return str;
    }
}

class EventListener {
    public function EventListener() {
    }
    
    public function itemInsertedHandler(obj:Object):void {
        trace("itemInsertedHandler: " + obj);
    }
    
    public function itemRemovedHandler(obj:Object):void {
        trace("itemRemovedHandler: " + obj);        
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="Function:AS3:apply"><apiName>apply</apiName><shortdesc>
  Gibt den Wert von thisObject an, der in sämtlichen von ActionScript aufgerufenen Funktionen verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.apply, apply
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Alle Werte, die durch die aufgerufene Funktion angegeben werden.
  
  
  </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Das Objekt, auf das die Funktion angewendet wird.
  
  </apiDesc></apiParam><apiParam><apiItemName>argArray</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Ein Array, dessen Elemente als Parameter an die Funktion übergeben werden.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Objektinstanz an, für die die Funktion aufgerufen wird.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Gibt den Wert von <codeph>thisObject</codeph> an, der in sämtlichen von ActionScript aufgerufenen Funktionen verwendet werden soll. Diese Methode gibt außerdem die Parameter an, die an eine aufgerufene Funktion übergeben werden. Da es sich bei <codeph>apply()</codeph> um eine Methode der Function-Klasse handelt, ist sie gleichzeitig auch eine Methode aller Function-Objekte in ActionScript. 
  <p>Die Parameter werden im Gegensatz zu <codeph>Function.call()</codeph>, das Parameter als eine durch Komma getrennte Liste definiert, als Array-Objekte angegeben. Dies ist besonders dann nützlich, wenn die Anzahl der zu übergebenden Parameter erst bei der eigentlichen Skriptausführung bekannt wird.</p>
  <p>Gibt den Wert zurück, der von der aufgerufenen Funktion als Rückgabewert angegeben wurde.</p>

  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/call()"><linktext>Function.call()</linktext></link></related-links></apiOperation><apiOperation id="Function:AS3:call"><apiName>call</apiName><shortdesc>
  Ruft die durch ein Function-Objekt dargestellte Funktion auf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.call, call
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Ein Objekt, das den Wert von <codeph>thisObject</codeph> innerhalb des Hauptteils der Funktion angibt.
  
  </apiDesc></apiParam><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Der/die Parameter, der/die an die Funktion übergeben wird/werden. Sie können keinen oder beliebig viele Parameter angeben.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Ruft diese Funktion auf. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Ruft die durch ein Function-Objekt dargestellte Funktion auf. Da jede Funktion in ActionScript durch ein Function-Objekt dargestellt wird, unterstützen alle Funktionen diese Methode. 
  <p>In den meisten Fällen kann der Funktionsaufrufoperator (<codeph>()</codeph>) anstelle dieser Methode verwendet werden. Der Funktionsaufrufoperator erzeugt kompakten und leicht lesbaren Code. Diese Methode bietet sich besonders dann an, wenn der <codeph>thisObject</codeph>-Parameter im Funktionsaufruf explizit gesteuert werden muss. Wenn eine Funktion als Methode eines Objekts aufgerufen wird, wird, wie im folgenden Beispiel, im Hauptteil der Funktion <codeph>thisObject</codeph> normalerweise auf <codeph>myObject</codeph> gesetzt:</p>
  <codeblock>
  myObject.myMethod(1, 2, 3);
  </codeblock>
  <p>In bestimmten Fällen sollten Sie mit <codeph>thisObject</codeph> auf ein anderes Objekt Bezug nehmen, z. B. wenn eine Funktion als Methode eines Objekts aufgerufen werden muss, aber nicht als Methode dieses Objekts gespeichert ist:</p>
  <codeblock>
  myObject.myMethod.call(myOtherObject, 1, 2, 3); 
  </codeblock>
  <p>Sie können für den Parameter <codeph>null</codeph> den Wert <codeph>thisObject</codeph> übergeben, um eine Funktion als normale Funktion und nicht als Methode eines Objekts aufzurufen. Die folgenden Funktionsaufrufe sind beispielsweise gleichwertig:</p>
  <codeblock>
  Math.sin(Math.PI / 4)
  Math.sin.call(null, Math.PI / 4)
  </codeblock>
  
  <p>Gibt den Wert zurück, der von der aufgerufenen Funktion als Rückgabewert angegeben wurde.</p>
  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/apply()"><linktext>Function.apply()</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="globalClassifier:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
 Eine SyntaxError-Ausnahme wird ausgegeben, wenn ein Parsingfehler aus einem der folgenden Gründe auftritt:</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SyntaxError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Eine SyntaxError-Ausnahme wird ausgegeben, wenn ein Parsingfehler aus einem der folgenden Gründe auftritt: 
 <ul>
   <li>Ein ungültiger regulärer Ausdruck wird von der RegExp-Klasse analysiert.</li>
   <li>Ungültiger XML-Inhalt wird von der XML-Klasse analysiert.</li>
 </ul>
 
 </apiDesc></apiClassifierDetail><related-links><link href="#RegExp"><linktext>RegExp-Klasse</linktext></link><link href="#XML"><linktext>XML-Klasse</linktext></link></related-links><apiConstructor id="SyntaxError:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
	 Erstellt ein neues SyntaxError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Enthält die mit dem SyntaxError-Objekt verbundene Meldung. 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues SyntaxError-Objekt.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Boolean"><apiName>Boolean</apiName><shortdesc>
Ein Boolean-Objekt ist ein Datentyp, der einen der zwei für logische Operationen verwendeten Werte annehmen kann, entweder „true“ oder „false“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>Objects/Core/Boolean/
 
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Ein Boolean-Objekt ist ein Datentyp, der einen der zwei für logische Operationen verwendeten Werte annehmen kann, entweder <codeph>true</codeph> oder <codeph>false</codeph>. Mit der Boolean-Klasse können Sie den Grunddatentyp oder die Stringdarstellung eines Boolean-Objekts abrufen. 

<p>Um ein Boolean-Objekt zu erstellen, können Sie den Konstruktor der globalen Funktion verwenden oder einen Literalwert zuweisen. Es spielt keine Rolle, welches Verfahren Sie verwenden; in ActionScript 3.0 sind alle drei Verfahren gleichwertig. (In JavaScript wird dies unterschiedlich gehandhabt, denn dort unterscheidet sich ein Boolean-Objekt vom Grunddatentyp Boolean.)</p>

  <p>Die folgenden Codezeilen sind äquivalent:</p>
<codeblock rev="3.0">
var flag:Boolean = true;
var flag:Boolean = new Boolean(true);
var flag:Boolean = Boolean(true);
</codeblock>

 </apiDesc><example conref="examples\BooleanExample.as"> Im folgenden Beispiel wird zwischen den entsprechenden Werten des Boolean-Objekts umgeschaltet und die Werte werden angezeigt:
<codeblock>
 package {
    import flash.display.Sprite;

    public class BooleanExample extends Sprite {
        private var flag:Boolean;

        public function BooleanExample() {
            trace(flag);    // false
            toggle();
            trace(flag);    // true
            toggle();
            trace(flag);    // false
        }
        
        private function toggle():void{
            flag = !flag;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Boolean:Boolean"><apiName>Boolean</apiName><shortdesc>
 Erstellt ein Boolean-Objekt mit dem angegebenen Wert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new boolean, constructor
  
  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein beliebiger Ausdruck. 
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Erstellt ein Boolean-Objekt mit dem angegebenen Wert. Wenn Sie den Parameter <codeph>expression</codeph> weglassen, wird das Boolean-Objekt mit dem Wert <codeph>false</codeph> initialisiert. Geben Sie dagegen einen Wert für den Parameter <codeph>expression</codeph> an, wertet die Methode diesen aus und gibt das Ergebnis als booleschen Wert entsprechend der Regeln der allgemeinen <codeph>Boolean()</codeph>-Funktion zurück.
 
 </apiDesc><example>Der folgende Code erstellt ein neues Boolean-Objekt, das mit dem Wert <codeph>false</codeph> initialisiert wird, und den Namen <codeph>myBoolean</codeph> trägt:
 <codeblock rev="3.0">
 var myBoolean:Boolean = new Boolean();
 </codeblock>
 
 </example></apiConstructorDetail><related-links><link href="package.html#Boolean()"><linktext>Boolescher Ausdruck()</linktext></link></related-links></apiConstructor><apiOperation id="Boolean:AS3:toString"><apiName>toString</apiName><shortdesc>
	  Gibt die Stringdarstellung („true“ bzw. „false“) des Boolean-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der String <codeph>"true"</codeph> oder <codeph>"false"</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Gibt die Stringdarstellung (<codeph>"true"</codeph> oder <codeph>"false"</codeph>) des Boolean-Objekts zurück. Die Ausgabe wird nicht lokalisiert und ist <codeph>"true"</codeph> oder <codeph>"false"</codeph>, und zwar unabhängig von der Systemsprache.
	 
 	 </apiDesc><example>In diesem Beispiel wird eine Variable vom Typ Boolean erstellt, und anschließend wird deren Wert für die Verwendung in einem Stringarray mithilfe von <codeph>toString()</codeph> in einen String umgewandelt:
	 <codeblock rev="3.0">
	 var myStringArray:Array = new Array("yes", "could be");
	 var myBool:Boolean = 0;
	 myBool.toString();
	 myStringArray.push(myBool);
	 trace(myStringArray); // yes,could be,false
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="Boolean:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Gibt „true“ zurück, wenn der Wert des angegebenen Boolean-Objekts wahr ist; andernfalls „false“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.valueOf, valueOf
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein boolescher Wert.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt <codeph>true</codeph> zurück, wenn der Wert des angegebenen Boolean-Objekts wahr ist; andernfalls <codeph>false</codeph>.  
	 
	 </apiDesc><example>Aus dem folgenden Beispiel geht die Funktionsweise dieser Methode hervor. Es zeigt außerdem, dass der Wert eines neuen Boolean-Objekts <codeph>false</codeph> lautet:
	 <codeblock rev="3.0">
	 var myBool:Boolean = new Boolean();
	 trace(myBool.valueOf());   // false
	 myBool = (6==3+3);
	 trace(myBool.valueOf());   // true  
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:XMLList"><apiName>XMLList</apiName><shortdesc>
 Die XMLList-Klasse enthält Methoden zur Arbeit mit einem oder mehreren XML-Elementen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XMLList
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die XMLList-Klasse enthält Methoden zur Arbeit mit einem oder mehreren XML-Elementen. Ein XMLList-Objekt kann eines oder mehrere XML-Objekte oder -Elemente (einschließlich mehrere Knoten und Attribute) repräsentieren. Dadurch haben Sie die Möglichkeit, Methoden für die Elemente als Gruppe oder für einzelne Elemente in der Sammlung aufzurufen.
 <p>Wenn ein XMLList-Objekt nur ein XML-Element aufweist, können Sie die Methoden der XML-Klasse direkt auf das XMLList-Objekt anwenden. Im folgenden Beispiel ist <codeph>example.two</codeph> ein XMLList-Objekt mit einer Länge von 1, sodass Sie eine XML-Methode darauf anwenden können.</p>
 <codeblock>
 var example2 = &lt;example>&lt;two>2&lt;/two>&lt;/example>;</codeblock>
 <p>Wenn Sie versuchen, Methoden der XML-Klasse auf ein XMLList-Objekt anzuwenden, dass mehrere XML-Objekte enthält, wird eine Ausnahme ausgelöst. Durchlaufen Sie stattdessen die XMLList-Sammlung (beispielsweise mit einer <codeph>for each..in</codeph>-Anweisung), und wenden Sie Methoden auf jedes einzelne XML-Objekt in der Sammlung an.</p>
 
 </apiDesc><example conref="examples\XMLListExample.as"> Im folgenden Beispiel wird eine XML-Eigenschaft namens <codeph>books</codeph> erstellt, und mehrere Elemente werden mit<codeph>book publisher</codeph> und <codeph>name</codeph>-Tags zum Knoten <codeph>books</codeph> hinzugefügt. Anschließend wird die <codeph>showBooksByPublisher()</codeph>-Methode aufgerufen und auf die XMLList-Sammlung angewendet; jedes Element, das dem Herausgeber „Addison-Wesley“ entspricht, wird zurückgegeben.
<codeblock>
package {
    import flash.display.Sprite;

    public class XMLListExample extends Sprite {
        private var books:XML;

        public function XMLListExample() {
            books =    &lt;books>
                        &lt;book publisher="Addison-Wesley" name="Design Patterns" />
                        &lt;book publisher="Addison-Wesley" name="The Pragmatic Programmer" />
                        &lt;book publisher="Addison-Wesley" name="Test Driven Development" />
                        &lt;book publisher="Addison-Wesley" name="Refactoring to Patterns" />
                        &lt;book publisher="O'Reilly Media" name="The Cathedral &amp; the Bazaar" />
                        &lt;book publisher="O'Reilly Media" name="Unit Test Frameworks" />
                    &lt;/books>;

            showBooksByPublisher("Addison-Wesley");
        }

        private function showBooksByPublisher(name:String):void {
            var results:XMLList = books.book.(@publisher == name);
            showList(results);
        }

        private function showList(list:XMLList):void {
            var item:XML;
            for each(item in list) {
                trace("item: " + item.toXMLString());
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="statements.html#for_each..in"><linktext>for each..in</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#QName"><linktext>QName</linktext></link></related-links><apiConstructor id="XMLList:XMLList"><apiName>XMLList</apiName><shortdesc>
	Erstellt ein neues XMLList-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList 
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Jedes Objekt, das mithilfe von <codeph>XMLList()</codeph>, einer Funktion oberster Ebene, in ein XMLList-Objekt konvertieren werden kann.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Erstellt ein neues XMLList-Objekt.
	
	</apiDesc></apiConstructorDetail><related-links><link href="#global/XMLList()"><linktext>XMLList()-Funktion auf oberster Ebene</linktext></link></related-links></apiConstructor><apiOperation id="XMLList:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	Ruft die attribute()-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt mit den Ergebnissen zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit übereinstimmenden XML-Objekten oder ein leeres XMLList-Objekt.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>Der Name des Attributs, dass Sie in ein XMLList-Objekt einbinden wollen.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ruft die <codeph>attribute()</codeph>-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt mit den Ergebnissen zurück. Die Ergebnisse entsprechen dem angegebenen <codeph>attributeName</codeph>-Parameter. Wenn es keine Übereinstimmung gibt, gibt die <codeph>attribute()</codeph>-Methode ein leeres XMLList-Objekt zurück.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	Ruft die attributes()-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt mit Attributen für jedes XML-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit Attributen für jedes XML-Objekt.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Ruft die <codeph>attributes()</codeph>-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt mit Attributen für jedes XML-Objekt zurück. 
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:child"><apiName>child</apiName><shortdesc>
	Ruft die child()-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt zurück, das die Ergebnisse in der richtigen Reihenfolge enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit untergeordneten Knoten, die dem input-Parameter entsprechen.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Der Elementname oder die Ganzzahl des untergeordneten XML-Elements.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ruft die <codeph>child()</codeph>-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt zurück, das die Ergebnisse in der richtigen Reihenfolge enthält.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:children"><apiName>children</apiName><shortdesc>
	Ruft die children()-Methode für jedes XML-Objekt zurück und gibt ein XMLList-Objekt mit den Ergebnissen zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit den Knoten, die dem XML-Objekt untergeordnet sind.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Ruft die <codeph>children()</codeph>-Methode für jedes XML-Objekt zurück und gibt ein XMLList-Objekt mit den Ergebnissen zurück.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/children()"><linktext>XML.children()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:comments"><apiName>comments</apiName><shortdesc>
	Ruft die comments()-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt mit Kommentaren zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit den Kommentaren im XML-Objekt.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Ruft die <codeph>comments()</codeph>-Methode für jedes XML-Objekt auf und gibt ein XMLList-Objekt mit Kommentaren zurück.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/comments()"><linktext>XML.comments()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:contains"><apiName>contains</apiName><shortdesc>
	Prüft, ob das XMLList-Objekt ein XML-Objekt enthält, das dem angegebenen value-Parameter entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>value</codeph>, wenn das XMLList-Objekt das im Parameter <codeph>true</codeph> deklarierte XML-Objekt enthält; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Ein XML-Objekt, das mit dem aktuellen XMLList-Objekt verglichen werden soll. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Prüft, ob das XMLList-Objekt ein XML-Objekt enthält, das dem angegebenen <codeph>value</codeph>-Parameter entspricht.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:copy"><apiName>copy</apiName><shortdesc>
	Gibt eine Kopie des gegebenen XMLList-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Kopie des XMLList-Objekts.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie des gegebenen XMLList-Objekts zurück. Die Kopie ist ein Duplikat der gesamten Knotenbaumstruktur. Das kopierte XML-Objekt hat kein übergeordnetes Objekt und gibt den Wert <codeph>null</codeph> zurück, wenn Sie versuchen, die <codeph>parent()</codeph>-Methode aufzurufen.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	Gibt alle untergeordnete Elemente (direkt untergeordnete und über mehrere Zweige hinweg untergeordnete Knoten) des XML-Objekts zurück, die dem gegebenen name-Parameter entsprechen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt der übereinstimmenden untergeordneten Elemente (direkt untergeordnete sowie über mehrere Zweige hinweg untergeordnete Knoten) des XML-Objekts in der ursprünglichen Liste. Wenn es keine untergeordneten Elemente gibt, wird ein leeres XMLList-Objekt zurückgegeben.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Der Name des zu vergleichenden Elements.
	
 	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Gibt alle untergeordneten Elemente (direkt untergeordnete und über mehrere Zweige hinweg untergeordnete Knoten) des XML-Objekts zurück, die dem gegebenen <codeph>name</codeph>-Parameter entsprechen. Der <codeph>name</codeph>-Parameter kann ein QName-Objekt sein, ein Objekt des Datentyps String oder jeglichen sonstigen Datentyps, der sich in einen String konvertieren lässt.
	
	<p>Um alle untergeordneten Elemente zurückzugeben, verwenden Sie den Sternparameter (~~). Wird kein Parameter übergeben, wird der String „~~“ übergeben, sodass alle untergeordneten Elemente des XML-Objekts zurückgegeben werden.</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/descendants()"><linktext>XML.descendants()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:elements"><apiName>elements</apiName><shortdesc>
	Ruft die elements()-Methode jedes XML-Objekts auf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.elements, elements
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit den übereinstimmenden untergeordneten Elementen im XML-Objekt.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Der Name des zu vergleichenden Elements.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ruft die <codeph>elements()</codeph>-Methode jedes XML-Objekts auf. Der Parameter <codeph>name</codeph> wird an die Methode <codeph>descendants()</codeph> übergeben. Wird kein Parameter übergeben, wird der String „~~“ an die Methode <codeph>descendants()</codeph> übergeben.
	
 	</apiDesc></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	Prüft, ob das XMLList-Objekt komplexen Inhalt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>true</codeph>, wenn das XMLList-Objekt einen komplexen Inhalt hat; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Prüft, ob das XMLList-Objekt komplexen Inhalt enthält. Man betrachtet den Inhalt eines XMLList-Objekts als komplex, wenn es nicht leer ist oder eine der folgenden Bedingungen erfüllt ist: 
	
	<ul>
	  <li>Das XMLList-Objekt enthält ein einziges XML-Element mit komplexem Inhalt.</li>
	  <li>Das XMLList-Objekt enthält Elemente.</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	Sucht nach der durch „p“ angegebenen Eigenschaft.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>true</codeph>, wenn der Parameter vorhanden ist; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die zu vergleichende Eigenschaft.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Prüft nach der durch <codeph>p</codeph> angegebenen Eigenschaft. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	Prüft, ob das XMLList-Objekt einfachen Inhalt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>true</codeph>, wenn das XMLList-Objekt einen einfachen Inhalt hat; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Prüft, ob das XMLList-Objekt einfachen Inhalt enthält. Man betrachtet den Inhalt eines XMLList-Objekts als einfach, wenn eine oder mehrere der folgenden Bedingungen erfüllt sind:
	<ul>
	  <li>Das XMLList-Objekt ist leer.</li>
	  <li>Das XMLList-Objekt enthält ein einziges XML-Element mit einfachem Inhalt.</li>
	  <li>Das XMLList-Objekt enthält keine Elemente.</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:length"><apiName>length</apiName><shortdesc>
	Gibt die Anzahl der Eigenschaften im XMLList-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Anzahl der Eigenschaften im XMLList-Objekt. 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt die Anzahl der Eigenschaften im XMLList-Objekt zurück.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	Führt benachbarte Textknoten zusammen und entfernt leere Textknoten für alle Textknoten im XMLList-Objekt, alle XML-Objekte im XMLList-Objekt und die untergeordneten Elemente aller XML-Objekte im XMLList-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das normalisierte XMLList-Objekt.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Führt benachbarte Textknoten zusammen und entfernt leere Textknoten für alle Textknoten im XMLList-Objekt, alle XML-Objekte im XMLList-Objekt und die untergeordneten Elemente aller XML-Objekte im XMLList-Objekt. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:parent"><apiName>parent</apiName><shortdesc>
	Gibt den übergeordneten Knoten des XMLList-Objekts zurück, wenn alle Elemente im XMLList-Objekt denselben übergeordneten Knoten besitzen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Gibt das übergeordnete XML-Objekt zurück.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt den übergeordneten Knoten des XMLList-Objekts zurück, wenn alle Elemente im XMLList-Objekt denselben übergeordneten Knoten besitzen. Hat das XMLList-Objekt keine oder unterschiedliche übergeordnete Knoten, gibt die Methode den Wert <codeph>undefined</codeph> zurück.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	Wird ein name-Parameter bereitgestellt, werden alle untergeordneten Knoten des XMLList-Objekts aufgelistet, die Verarbeitungsanweisungen mit diesem Namen enthalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt, das die Verarbeitungsanweisungen für jedes XML-Objekt enthält.
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>Der Name der gesuchten Verarbeitungsanweisung.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Wird ein <codeph>name</codeph>-Parameter bereitgestellt, werden alle untergeordneten Knoten des XMLList-Objekts aufgelistet, die Verarbeitungsanweisungen mit diesem Namen enthalten. Ohne Parameter listet diese Methode alle untergeordneten Knoten des XMLList-Objekts auf, die irgendwelche Verarbeitungsanweisungen enthalten.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/processingInstructions()"><linktext>XML.processingInstructions()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	Prüft, ob sich die Eigenschaft „p“ in dem Satz an Eigenschaften befindet, die in einer auf das XMLList-Objekt angewendeten „for..in“-Anweisung durchlaufen werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Wenn die Eigenschaft in einer <codeph>for..in</codeph>-Anweisung durchlaufen werden kann, lautet der Wert <codeph>true</codeph>; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Indexposition einer zu überprüfenden Eigenschaft.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Prüft, ob sich die Eigenschaft <codeph>p</codeph> in dem Satz an Eigenschaften befindet, die in einer auf das XMLList-Objekt angewendeten <codeph>for..in</codeph>-Anweisung durchlaufen werden können. Es ergibt sich der <codeph>true</codeph>, wenn <codeph>toNumber(p)</codeph> größer oder gleich 0 und kleiner als die Länge des XMLList-Objekts ist. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:text"><apiName>text</apiName><shortdesc>
	Ruft die text()-Methode für jedes XML-Objekt zurück und gibt ein XMLList-Objekt mit den Ergebnissen zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit allen XML-Eigenschaften des XMLList-Objekts, die XML-Textknoten darstellen.
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Ruft die <codeph>text()</codeph>-Methode für jedes XML-Objekt zurück und gibt ein XMLList-Objekt mit den Ergebnissen zurück.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/text()"><linktext>XML.text()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toString"><apiName>toString</apiName><shortdesc>
	Gibt alle XML-Objekte in einem XMLList-Objekt als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung des XML-Objekts.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt alle XML-Objekte in einem XMLList-Objekt als String zurück. Nach welchen Regeln diese Konvertierung vollzogen wird, ist abhängig davon, ob das XML-Objekt einen einfachen oder komplexen Inhalt hat:
	
	<ul>
		<li>Hat das XML-Objekt einen einfachen Inhalt, gibt <codeph>toString()</codeph> den String-Inhalt des XML-Objekts zurück, wobei das Start-Tag, vorhandene Attribute, Namespace-Deklarationen und das Endtag entfernt werden.</li> 
	</ul>
	
	<ul>
		<li> Hat das XML-Objekt einen komplexen Inhalt, gibt <codeph>toString()</codeph> das gesamte XML-Objekt als XML-kodierten String zurück, einschließlich Start-Tag, Attributen, Namespace-Deklarationen und End-Tag.</li>
	</ul>
	
	<p>Damit jedes Mal das gesamte XML-Objekt zurückgegeben wird, verwenden Sie die Methode <codeph>toXMLString()</codeph>.</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> Im folgende Beispiel wird veranschaulicht, was die <codeph>toString()</codeph>-Methode zurückgibt, wenn das XML-Objekt einen einfachen Inhalt hat:
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> Im folgende Beispiel wird veranschaulicht, was die <codeph>toString()</codeph>-Methode zurückgibt, wenn das XML-Objekt einen komplexen Inhalt hat:
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XMLList/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	Gibt alle XML-Objekte in einem XMLList-Objekt als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung des XML-Objekts.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt alle XML-Objekte in einem XMLList-Objekt als String zurück. Im Gegensatz zur Methode <codeph>toString()</codeph> gibt die Methode <codeph>toXMLString()</codeph> immer das Start-Tag, vorhandene Attribute und das End-Tag des XML-Objekts zurück, unabhängig davon, ob das XML-Objekt einen einfachen oder komplexen Inhalt hat. (Die Methode <codeph>toString()</codeph> entfernt alle diese Elemente für XML-Objekte mit einfachem Inhalt.)
	
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	Gibt das XMLList-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Gibt das aktuelle XMLList-Objekt zurück.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt das XMLList-Objekt zurück. 
	
	</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:Error"><apiName>Error</apiName><shortdesc>
 Die Error-Klasse enthält Informationen zu einem Fehler in Ihrem Skript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Ein Fehler wird ausgelöst, wenn in einem Skript ein Fehler auftritt.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Error-Klasse enthält Informationen zu einem Fehler in Ihrem Skript. Wenn Sie ActionScript 3.0-Anwendungen entwickeln und Ihren kompilierten Programmcode in der Debugger-Version von Flash Player ausführen, werden in einem speziellen Dialogfeld Ausnahmen vom Typ Error angezeigt, oder von einer Unterklasse. Dadurch wird Ihnen die Fehlersuche im Code erleichtert. Ein Error-Objekt wird mit der Konstruktorfunktion <codeph>Error</codeph> erstellt. Gewöhnlich lösen Sie in einem <codeph>try</codeph>-Codeblock ein neues Error-Objekt aus, das mithilfe eines<codeph>catch</codeph>- oder <codeph>finally</codeph>-Codeblocks abgefangen werden kann.
 <p>Sie können auch eine Unterklasse der Error-Klasse erstellen und Instanzen dieser Unterklasse ausgeben.</p>
 
 </apiDesc><example conref="examples\ErrorExample.as"> Im folgenden Beispiel wird mithilfe der <codeph>ErrorExample</codeph>-Klasse gezeigt, wie ein benutzerdefinierter Fehler erzeugt werden kann. Dies wird in den folgenden Schritten erreicht:
 <ol>
     <li>Eine lokale Variable <codeph>nullArray</codeph> vom Typ Array wird zwar deklariert, es muss jedoch beachten werden, dass kein neues Array-Objekt erstellt wird.</li>
     <li>Der Konstruktor versucht mithilfe der <codeph>push()</codeph>-Methode einen Wert in das nicht initialisierte Array zu laden. Diese Methode befindet sich in einem Codesegment zur Fehlerverarbeitung, mit dem ein benutzerdefinierter Fehler mithilfe der <codeph>CustomError</codeph>-Klasse abgefangen und <codeph>Error</codeph> erweitert wird.</li>
     <li>Wenn ein benutzerdefinierter Fehler ausgelöst wird, wird er vom Konstruktor abgefangen. Anschließend gibt er eine Fehlermeldung mithilfe der <codeph>trace()</codeph>-Anweisung aus. </li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    public class ErrorExample extends Sprite 
    {
        private var nullArray:Array;
        public function ErrorExample() 
        {
            try 
            {
                nullArray.push("item");
            }
            catch(e:Error) 
            {
                throw new CustomError("nullArray is null");
            }
        }
    }
}

class CustomError extends Error 
{
    public function CustomError(message:String) 
    {
        super(message);
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Error:Error"><apiName>Error</apiName><shortdesc>
	 Erstellt ein neues Error-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Ein String, der mit dem Error-Objekt verknüpft ist. Dieser Parameter ist optional. 
     </apiDesc></apiParam><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Enthält die Verweisnummer der zugeordneten Fehlermeldung.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt eine neue Error-Instanz mit der angegebenen Fehlermeldung.
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Erstellt ein neues Error-Objekt. Wenn <codeph>message</codeph> angegeben ist, wird dieser Wert der Eigenschaft <codeph>Error.message</codeph> des Objekts zugewiesen.
	 
	 
	 </apiDesc><example conref="examples\Error.1.as"> Im folgenden Beispiel wird ein neues Error-Objekt <codeph>err</codeph> erstellt. Anschließend wird mithilfe des <codeph>Error()</codeph>-Konstruktors der String <codeph>"New Error Message"</codeph> dem Error-Objekt <codeph>err</codeph> zugewiesen.
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message
</codeblock></example></apiConstructorDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiConstructor><apiOperation id="Error:getStackTrace"><apiName>getStackTrace</apiName><shortdesc>
	 Gibt zum Zeitpunkt der Fehlerentstehung den Call-Stack für den Fehler als String zurück (nur bei der Debugger-Version des Flash Players und bei AIR Debug Launcher (ADL)); gibt Null zurück, wenn nicht die Debugger-Version des Flash Players oder ADL verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, call stack
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine Stringdarstellung des Call-Stack. 
	 
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt den Call-Stack für einen Fehler in lesbarer Form zurück.
	 
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt zum Zeitpunkt der Fehlerentstehung den Call-Stack für den Fehler als String zurück (nur bei der Debugger-Version des Flash Players und bei AIR Debug Launcher (ADL)); gibt <codeph>null</codeph> zurück, wenn nicht die Debugger-Version des Flash Players oder ADL verwendet wird. Wie im folgenden Beispiel ersichtlich, ist die erste Zeile des Rückgabewerts die Stringdarstellung des Ausnahmeobjekts, gefolgt von den Stack-Trace-Elementen:
	 
	 <codeblock>
	 TypeError: null cannot be converted to an object
	     at com.xyz.OrderEntry.retrieveData(OrderEntry.as:995)
	     at com.xyz.OrderEntry.init(OrderEntry.as:200)
	     at com.xyz.OrderEntry.$construct(OrderEntry.as:148)
   	 </codeblock>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Error:toString"><apiName>toString</apiName><shortdesc>
	
	Gibt in der Standardeinstellung den String „Error“ oder, sofern definiert, den in der Error.message-Eigenschaft enthaltenen Wert zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.toString, toString
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Die Fehlermeldung.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt entweder die Fehlermeldung zurück oder das Wort „Error“, falls keine Meldung definiert ist.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	
	Gibt in der Standardeinstellung den String <codeph>"Error"</codeph> oder, sofern definiert, den in der <codeph>Error.message</codeph>-Eigenschaft enthaltenen Wert zurück.
	
    </apiDesc><example conref="examples\Error.toString.1.as"> Im folgenden Beispiel wird ein neues Error-Objekt <codeph>err</codeph> erstellt. Anschließend wird mithilfe des <codeph>Error()</codeph>-Konstruktors der String <codeph>"New Error Message"</codeph> dem Error-Objekt <codeph>err</codeph> zugewiesen. Abschließend wird die <codeph>message</codeph>-Eigenschaft auf <codeph>"Another New Error Message"</codeph> gesetzt, womit <codeph>"New Error Message"</codeph> überschrieben wird.
 
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message

err.message = "Another New Error Message";
trace(err.toString());    // Error: Another New Error Message
</codeblock></example></apiOperationDetail><related-links><link href="#Error/message"><linktext>Error.message</linktext></link><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiOperation><apiValue id="Error:message"><apiName>message</apiName><shortdesc>
	 Enthält die mit dem Error-Objekt verbundene Meldung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.message, message
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Enthält die mit der Error-Instanz verbundene Fehlermeldung.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Enthält die mit dem Error-Objekt verbundene Meldung. Der Standardwert dieser Eigenschaft lautet "<codeph>Error</codeph>". Sie können eine <codeph>message</codeph>-Eigenschaft angeben, wenn Sie ein neues Error-Objekt erstellen, indem Sie den Fehlerstring an die <codeph>Error</codeph>-Konstruktorfunktion übergeben.
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiValue><apiValue id="Error:name"><apiName>name</apiName><shortdesc>
	  Enthält den Namen des Error-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Der Name der Error-Instanz.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	  Enthält den Namen des Error-Objekts. Der Standardwert dieser Eigenschaft lautet "<codeph>Error</codeph>".
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiValue><apiValue id="Error:errorID:get"><apiName>errorID</apiName><shortdesc>
     Enthält die Verweisnummer der zugeordneten Fehlermeldung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.errorID, errorID
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Enthält die Fehlernummer.
     
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Enthält die Verweisnummer der zugeordneten Fehlermeldung. Bei einem selbst definierten Error-Objekt entspricht diese Nummer dem Wert des im Konstruktor bereitgestellten <codeph>id</codeph>-Parameters.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:TypeError"><apiName>TypeError</apiName><shortdesc>
 Es wird eine TypeError-Ausnahme ausgelöst, wenn sich der tatsächliche Typ eines Operanden vom erwarteten unterscheidet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, TypeError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Es wird eine TypeError-Ausnahme ausgelöst, wenn sich der tatsächliche Typ eines Operanden vom erwarteten unterscheidet. 
 <p>
 Darüber hinaus wird diese Ausnahme in den folgenden Fällen ausgelöst:
  <ul>
  <li>Der tatsächliche Parameter einer Funktion oder Methode konnte dem formalen Parametertyp nicht aufgezwungen werden.</li>
  <li>Einer Variable wird ein Wert zugewiesen, konnte aber dem Variablentyp nicht aufgezwungen werden.</li>
  <li>Die rechte Seite des <codeph>is</codeph>- oder <codeph>instanceof</codeph>-Operators besitzt einen ungültigen Typ.</li>
  <li>Das Schlüsselwort <codeph>super</codeph> wurde in unzulässiger Weise eingesetzt.</li>
  <li>Das Nachschlagen einer Eigenschaft resultiert in mehreren Bindungen und ist daher mehrdeutig.</li>
  <li>Eine Methode wird für ein inkompatibles Objekt aufgerufen. So wird beispielsweise eine TypeError-Ausnahme ausgelöst, wenn eine RegExp-Klassenmethode einem generischen Objekt „aufgepfropft“ und dann aufgerufen wurde.</li>
 </ul>
 </p>
 
 </apiDesc><example conref="examples\TypeErrorExample.as"> Dieses Beispiel veranschaulicht, wie eine TypeError-Ausnahme erzeugt und in einer <codeph>try..catch</codeph>-Anweisung verarbeitet wird. 
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class TypeErrorExample extends Sprite {
        public function TypeErrorExample() {
            try {
                var child:Object = new Object();
                addChild(DisplayObject(child));
            }
            catch(e:TypeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#is"><linktext>is-Operator</linktext></link><link href="operators.html#instanceof"><linktext>instanceof-Operator</linktext></link><link href="statements.html#super"><linktext>super-Anweisung</linktext></link><link href="#RegExp"><linktext>RegExp-Klasse</linktext></link></related-links><apiConstructor id="TypeError:TypeError"><apiName>TypeError</apiName><shortdesc>
	 Erstellt ein neues TypeError-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Enthält die mit dem TypeError-Objekt verbundene Meldung. 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues TypeError-Objekt.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:arguments"><apiName>arguments</apiName><shortdesc>
 Ein arguments-Objekt dient zum Speichern der Argumente einer Funktion und zum Zugriff auf diese Argumente.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Ein arguments-Objekt dient zum Speichern der Argumente einer Funktion und zum Zugriff auf diese Argumente.
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Ein arguments-Objekt dient zum Speichern der Argumente einer Funktion und zum Zugriff auf diese Argumente. Im Hauptabschnitt einer Funktion können Sie auf ihr arguments-Objekt zugreifen, indem Sie die Variable für lokale Argumente verwenden.
 <p>
 Die Argumente werden als Arrayelemente gespeichert: Das erste ist über <codeph>arguments[0]</codeph> zugänglich, das zweite über <codeph>arguments[1]</codeph> usw. Die <codeph>arguments.length</codeph>-Eigenschaft gibt die Anzahl der an die Funktion übergebenen Argumente an. Die Anzahl der übergebenen Argumente muss jedoch nicht unbedingt mit der in der Funktion deklarierten Anzahl übereinstimmen.
 </p>
 <p>
 Im Gegensatz zu früheren ActionScript-Versionen besitzt ActionScript 3.0 keine <codeph>arguments.caller</codeph>-Eigenschaft. Um auf die Funktion zu verweisen, die die aktuelle aufgerufen hat, müssen Sie einen Verweis auf diese Funktion als Argument übergeben. Ein Beispiel für diese Technik finden Sie im Beispiel für <codeph>arguments.callee</codeph>.
 </p>
 <p>ActionScript 3.0 umfasst ein neues <codeph>...(rest)</codeph>-Schlüsselwort, das anstelle der arguments-Klasse empfohlen wird.</p>
 
 </apiDesc><example conref="examples\ArgumentsExample.as"> Das folgende Beispiel veranschaulicht die Verwendung von verschiedenen <codeph>arguments</codeph>-Eigenschaften, wie etwa <codeph>callee</codeph> und <codeph>length</codeph>.
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        public function ArgumentsExample() {
                println("Hello World");
        }
        
        public function println(str:String):void {
            trace(arguments.callee == this.println); // true
            trace(arguments.length);                 // 1
            trace(arguments[0]);                     // Hello World
            trace(str);                                // Hello World
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#..._(rest)_parameter"><linktext>...(rest)</linktext></link><link href="#Function"><linktext>Funktion</linktext></link></related-links><apiValue id="arguments:callee"><apiName>callee</apiName><shortdesc>
	 Ein Verweis auf die derzeit ausgeführte Funktion.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Function</apiValueClassifier><apiTipTexts><apiTipText>Ein Verweis auf die derzeit ausgeführte Funktion.
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein Verweis auf die derzeit ausgeführte Funktion.
	 
	 </apiDesc><example conref="examples\arguments.callee.1.as"> Im folgenden Code wird veranschaulicht, wie ein Verweis auf die Funktion hergestellt wird, durch die die Funktion <codeph>secondFunction()</codeph> aufgerufen wird. Die <codeph>firstFunction()</codeph>-Funktion enthält das boolesche Argument<codeph>true</codeph>, um zu demonstrieren, dass <codeph>secondFunction()</codeph> erfolgreich <codeph>firstFunction()</codeph> aufruft, und um eine Endlosschleife zu verhindern, in der eine Funktion die andere aufruft.
  
 <p>Da der <codeph>callSecond</codeph>-Parameter <codeph>true</codeph> lautet, ruft <codeph>firstFunction()</codeph> die <codeph>secondFunction()</codeph>-Funktion auf und übergibt als einziges Argument einen Verweis auf sich selbst. Die <codeph>secondFunction()</codeph>-Funktion empfängt dieses Argument und speichert es mithilfe des Parameters <codeph>caller</codeph>, der den Datentyp Function aufweist. Anschließend wird aus der <codeph>secondFunction()</codeph>-Funktion heraus mit dem <codeph>caller</codeph>-Parameter die <codeph>firstFunction</codeph>-Funktion aufgerufen. Dieses Mal ist das Argument <codeph>callSecond</codeph> jedoch auf <codeph>false</codeph> gesetzt.</p>
 <p>Wenn die Ausführung zu <codeph>firstFunction()</codeph> zurückkehrt, wird die <codeph>trace()</codeph>-Anweisung ausgeführt, da <codeph>callSecond</codeph> den Wert <codeph>false</codeph> aufweist.</p>
<codeblock>
  package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        private var count:int = 1;
        
        public function ArgumentsExample() {
            firstFunction(true);
        }

        public function firstFunction(callSecond:Boolean) {
            trace(count + ": firstFunction");
            if(callSecond) {
                secondFunction(arguments.callee);
            }
            else {
                trace("CALLS STOPPED");
            }
        }

        public function secondFunction(caller:Function) {
            trace(count + ": secondFunction\n");
            count++;
            caller(false);
        }        
    }
} 
</codeblock></example></apiValueDetail></apiValue><apiValue id="arguments:length"><apiName>length</apiName><shortdesc>
	 Anzahl der an die Funktion übergebenen Argumente.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Anzahl der an die Funktion übergebenen Parameter.
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Anzahl der an die Funktion übergebenen Argumente. Diese Anzahl kann von der in der Funktion deklarierten Anzahl abweichen.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:String"><apiName>String</apiName><shortdesc>
 Die String-Klasse ist ein Datentyp, der einen String repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die String-Klasse ist ein Datentyp, der einen String repräsentiert. Die String-Klasse stellt Methoden und Eigenschaften bereit, die die Bearbeitung des Grunddatentyps String erlauben. Mit der Funktion <codeph>String()</codeph> können Sie den Wert jedes Objekts in ein Objekt mit dem Datentyp String umwandeln. 
 <p> 
 Alle Methoden der String-Klasse, mit Ausnahme von <codeph>concat()</codeph>, <codeph>fromCharCode()</codeph>, <codeph>slice()</codeph> und <codeph>substr()</codeph>, sind allgemeine Methoden, d. h., die Methoden rufen zunächst <codeph>toString()</codeph> auf, bevor die eigentlichen Operationen durchgeführt werden. Sie können diese Methoden daher auch zusammen mit anderen Objekten verwenden, bei denen es sich nicht um String-Objekte handelt. 
 </p><p>
 Da alle String-Indexpositionen die Basis null haben, ist die Indexposition für das letzte Zeichen eines <codeph>x</codeph>-Strings <codeph>x.length - 1</codeph>.
 </p><p>
 Sie können jede Methode der String-Klasse aufrufen, ob Sie nun die Konstruktormethode <codeph>new String()</codeph> verwenden, um eine neue Stringvariable zu erstellen, oder einfach ein Stringliteral als Wert angeben. Im Gegensatz zu früheren ActionScript-Versionen, macht es keinen Unterschied, ob Sie den Konstruktor verwenden, die globale Funktion oder einfach einen Stringliteralwert zuweisen. Die folgenden Codezeilen sind äquivalent:
 </p>
 <codeblock rev="3.0">
 var str:String = new String("foo");
 var str:String = "foo";
 var str:String = String("foo");</codeblock>
 <p>Wenn Sie eine Stringvariable auf <codeph>undefined</codeph> setzen, erzwingt Adobe<sup>®</sup> Flash<sup>®</sup> Player für <codeph>undefined</codeph> den Wert <codeph>null</codeph>. Somit setzt die Anweisung</p>
 <pre>
 var s:String = undefined;</pre>
 den Wert auf <codeph>null</codeph> statt <codeph>undefined</codeph>. Verwenden Sie die Funktion <codeph>String()</codeph>, wenn Sie <codeph>undefined</codeph> benötigen.
 </apiDesc><example conref="examples\StringExample.as"> Im folgenden Beispiel wird mithilfe der StringExample- und StringHelper-Klassen veranschaulicht, wie verschiedene Methoden der String-Klasse eingesetzt werden. Dies wird in den folgenden Schritten erreicht:
 <ol>
    <li>Der Konstruktor für StringExample deklariert mehrere lokale String-Instanzen, die mit verschiedenen Strings und einem neuen StringHelper-Objekt initialisiert werden.</li>
    <li>Das StringHelper-Klasse weist die folgende Methoden auf:
    <ul>
        <li><codeph>replace()</codeph>: Ruft die <codeph>split()</codeph>- und <codeph>join()</codeph>-Methoden von String auf, um einen Teilstring des Strings zu entfernen, der mit einem neuen übergeben wurde.</li>
        <li><codeph>trim()</codeph>: Ruft sowohl <codeph>trimBack()</codeph> als auch <codeph>trimFront()</codeph> mithilfe der übergebenen Strings auf und gibt den aktualisierten String zurück.</li>
        <li><codeph>trimFront()</codeph>: Entfernt rekursiv alle Zeichen, die mit dem Parameter <codeph>char</codeph> übereinstimmen, und zwar vom Anfang des Strings in Richtung Ende, bis das erste Zeichen im String erreicht ist, das nicht mit <codeph>char</codeph> übereinstimmt, und gibt den aktualisierten String zurück.</li>
        <li><codeph>trimBack()</codeph>: Entfernt rekursiv alle Zeichen, die mit dem Parameter <codeph>char</codeph> übereinstimmen, und zwar vom Ende des Strings in Richtung Anfrang, bis das letzte Zeichen im String erreicht ist, das nicht mit <codeph>char</codeph> übereinstimmt, und gibt den aktualisierten String zurück.</li>
        <li><codeph>stringToCharacter()</codeph>: Gibt das erste Zeichen des übergebenen Strings zurück.</li>
    </ul>
  </li>
    <li>Anschließend werden drei Strings erstellt, und zwar mithilfe der deklarierten Stringvariablen, mit einem Aufruf der <codeph>replace()</codeph>-Methode, um den zweiten String zu erstellen und mit <codeph>trim()</codeph>, um den dritten String zu erstellen.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class StringExample extends Sprite {
        public function StringExample() {
            var companyStr:String = new String("     Company X");
            var productStr:String = "Product Z Basic     ";
            var emptyStr:String = " ";
            var strHelper:StringHelper = new StringHelper();

            var companyProductStr:String = companyStr + emptyStr + productStr;
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Basic     '

            companyProductStr = strHelper.replace(companyProductStr, "Basic", "Professional");
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Professional     '

            companyProductStr = strHelper.trim(companyProductStr, emptyStr);
            trace("'" + companyProductStr + "'");    // 'Company X Product Z Professional'
        }
    }
}

class StringHelper {
    public function StringHelper() {
    }

    public function replace(str:String, oldSubStr:String, newSubStr:String):String {
        return str.split(oldSubStr).join(newSubStr);
    }

    public function trim(str:String, char:String):String {
        return trimBack(trimFront(str, char), char);
    }

    public function trimFront(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(0) == char) {
            str = trimFront(str.substring(1), char);
        }
        return str;
    }

    public function trimBack(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(str.length - 1) == char) {
            str = trimBack(str.substring(0, str.length - 1), char);
        }
        return str;
    }

    public function stringToCharacter(str:String):String {
        if (str.length == 1) {
            return str;
        }
        return str.slice(0, 1);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="package.html#String()"><linktext>String-Funktion</linktext></link></related-links><apiConstructor id="String:String"><apiName>String</apiName><shortdesc>
  Erstellt ein neues String-Objekt, das mit dem angegebenen String initialisiert wird.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, new string, new, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Ausgangswert des neuen String-Objekts.
  
  </apiDesc></apiParam></apiConstructorDef><apiDesc>
  Erstellt ein neues String-Objekt, das mit dem angegebenen String initialisiert wird.
  
  <p>
  <b>Hinweis: </b>Da Stringliterale weniger Aufwand erfordern als String-Objekte und ihre Verwendung im Allgemeinen einfacher ist, sollten Sie anstatt der String-Klasse immer Stringliterale verwenden, es sei denn, Sie haben einen guten Grund für die Verwendung eines String-Objekts.
  </p>
  
  </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="String:AS3:charAt"><apiName>charAt</apiName><shortdesc>
     Gibt das Zeichen zurück, das sich an der durch den Parameter index angegebenen Position befindet.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charat, charat, character at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das Zeichen mit der angegebenen Indexposition. Oder ein leerer String, wenn die angegebene Indexposition außerhalb des Bereichs der Indexpositionen dieses Strings liegt.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl, die die Position eines Zeichens im String angibt. Die Position des ersten Zeichens wird durch <codeph>0</codeph> und die des letzten Zeichens durch <codeph>my_str.length - 1</codeph> angegeben.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt das Zeichen zurück, das sich an der durch den Parameter <codeph>index</codeph> angegebenen Position befindet. Wenn <codeph>index</codeph> keine Zahl zwischen 0 und <codeph>string.length - 1</codeph> ist, wird ein leerer String zurückgegeben.
	 <p>
	 Diese Methode ähnelt <codeph>String.charCodeAt()</codeph>, es wird jedoch ein ganzzahliger 16-Bit-Zeichencode zurückgegeben und kein Zeichen.
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charCodeAt()"><linktext>charCodeAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:charCodeAt"><apiName>charCodeAt</apiName><shortdesc>
	 Gibt den numerischen Unicode-Zeichencode des Zeichens an der angegebenen Indexposition zurück.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charcodeat, charcodeat, character code at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Gibt den numerischen Unicode-Zeichencode des Zeichens an der angegebenen Indexposition zurück. Oder <codeph> NaN</codeph>, wenn die angegebene Indexposition außerhalb des Bereichs der Indexpositionen dieses Strings liegt.
	 <p><xref href="" scope="external"/> </p>		 
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl, die die Position eines Zeichens im String angibt. Die Position des ersten Zeichens wird durch <codeph>0</codeph> und die des letzten Zeichens durch <codeph>my_str.length - 1</codeph> angegeben.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt den numerischen Unicode-Zeichencode des Zeichens an der durch <codeph>index</codeph> festgelegten Stelle zurück. Wenn <codeph>index</codeph> keine Zahl zwischen 0 und <codeph> string.length - 1</codeph> ist, wird <codeph>NaN</codeph> zurückgegeben.
	 <p>
	 Diese Methode ähnelt <codeph>String.charAt()</codeph>, es wird jedoch ein ganzzahliger 16-Bit-Zeichencode zurückgegeben und nicht das eigentliche Zeichen.
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charAt()"><linktext>charAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:concat"><apiName>concat</apiName><shortdesc>
	 Hängt die angegebenen Argumente ans Ende des String-Objekts an, wobei sie notwendigenfalls in Strings konvertiert werden, und gibt den resultierenden String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein neuer String, für den dieser String mit den angegebenen Parametern verkettet wurde.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Null oder mehr zu verkettende Werte.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Hängt die angegebenen Argumente ans Ende des String-Objekts an, wobei sie notwendigenfalls in Strings konvertiert werden, und gibt den resultierenden String zurück. Der ursprüngliche Wert des String-Quellobjekts bleibt unverändert.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:fromCharCode"><apiName>fromCharCode</apiName><shortdesc>
	Gibt einen String mit den Zeichen zurück, die den in den Parametern angegebenen Unicode-Zeichencodes entsprechen.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.fromcharcode, fromcharcode, from character code
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Der Stringwert des angegebenen Unicode-Zeichencodes.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>charCodes</apiItemName><apiType value="restParam"/><apiDesc>Eine Reihe dezimaler Ganzzahlen, die Unicode-Werte repräsentieren.
	<p><xref href="" scope="external"/> </p>	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Gibt einen String mit den Zeichen zurück, die den in den Parametern angegebenen Unicode-Zeichencodes entsprechen.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 Durchsucht den String und gibt die Position des ersten Vorkommens von „val“ nach (einschließlich) „startIndex“ innerhalb des aufrufenden Strings zurück.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.indexof, indexof, index
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Position des ersten Vorkommens des angegebenen Teilstrings oder <codeph>-1</codeph>.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, nach dem gesucht werden soll.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine optionale Ganzzahl, die die Startindexposition der Suche angibt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Durchsucht den String und gibt die Position des ersten Vorkommens von <codeph>val</codeph> nach (einschließlich) <codeph>startIndex</codeph> innerhalb des aufrufenden Strings zurück. Diese Indexposition basiert auf Null, d. h., das erste Zeichen in einem String befindet sich an Indexposition 0 und nicht an Indexposition 1. Wenn <codeph>val</codeph> nicht gefunden wird, gibt die Methode -1 zurück.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/lastIndexOf()"><linktext>lastIndexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 Durchsucht den String von rechts nach links und gibt die Indexposition des letzten Vorkommens von „val“ innerhalb des aufrufenden Strings zurück, das vor der startIndex-Position gefunden wurde.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.lastindexof, lastindexof, last index of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Position des letzten Vorkommens des angegebenen Teilstrings oder -1, wenn er nicht gefunden wird.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, nach dem gesucht werden soll.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7FFFFFFF</apiData><apiDesc>Eine optionale Ganzzahl, die angibt, von welcher Indexposition aus nach <codeph>val</codeph> gesucht werden soll. Standard ist der maximale für eine Indexposition erlaubte Wert. Wird <codeph>startIndex</codeph> nicht angegeben, beginnt die Suche beim letzten Element im String.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Durchsucht den String von rechts nach links und gibt die Indexposition des letzten Vorkommens von <codeph>val</codeph> innerhalb des aufrufenden Strings zurück, das vor der <codeph>startIndex</codeph>-Position gefunden wurde. Die Indexposition basiert auf null, d. h., das erste Zeichen befindet sich auf Indexposition 0 und das letzte auf <codeph>string.length - 1</codeph>. Wenn <codeph>val</codeph> nicht gefunden wird, gibt die Methode <codeph>-1</codeph> zurück.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/indexOf()"><linktext>indexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:localeCompare"><apiName>localeCompare</apiName><shortdesc>
	 Vergleicht die Sortierreihenfolge von zwei oder mehr Strings und gibt das Ergebnis des Vergleichs als Ganzzahl zurück.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Wert 0, wenn die Strings gleich sind. Andernfalls eine negative Ganzzahl, wenn der ursprüngliche String vor dem Stringargument kommt und eine positive Ganzzahl, wenn das Stringargument vor dem ursprünglichen String kommt. In beiden Fällen repräsentieren die absoluten Werte den Unterschied zwischen den beiden Strings.
	  
	  </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der zu vergleichende Stringwert.
     </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Optionaler Satz von weiteren zu vergleichenden Strings.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Vergleicht die Sortierreihenfolge von zwei oder mehr Strings und gibt das Ergebnis des Vergleichs als Ganzzahl zurück. Obwohl diese Methode dafür konzipiert ist, den Vergleich je nach lokaler Einstellung zu vergleichen, erzeugt die ActionScript 3.0-Implementierung keine anderen Ergebnisse als die Operatoren für Gleichheit (<codeph>==</codeph>) oder Ungleichheit (<codeph>!=</codeph>) operators. Sind die Strings äquivalent, lautet der Rückgabewert 0. Kommt der ursprüngliche Stringwert vor dem durch <codeph>other</codeph> angegebenen Stringwert, ist der Rückgabewert eine negative Ganzzahl, deren absoluter Wert die Anzahl von Zeichen repräsentiert, die die beiden Stringwerte voneinander trennt. Kommt der ursprüngliche Stringwert nach <codeph>other</codeph>, ist der Rückgabewert eine positive Ganzzahl, deren absoluter Wert die Anzahl von Zeichen repräsentiert, die die beiden Stringwerte voneinander trennt.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:match"><apiName>match</apiName><shortdesc>
	Vergleicht das angegebene Muster (pattern) mit dem String.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
		 var myPattern:RegExp = /sh./g;  
			// The dot (.) matches any character.
	 var str:String = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: she,sho
	
		 myPattern = /sh./gi;  
			// This time, make it case insensitive (with the i flag).
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: She,she,sho	
	
		 myPattern = RegExp = new RegExp("sh(.)", "gi")  
			// Note the grouping parentheses.
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
		// Output: She,e,she,e,sho,o
		 	// Note that the result array is 
			// [[She,e],[she,e],[sho,o]] 
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Array an Strings, der aus allen Teilstrings in dem String besteht, die mit dem angegebenen Muster (<codeph>pattern</codeph>) übereinstimmen.
	
	<p>Handelt es sich bei <codeph>pattern</codeph> um einen regulären Ausdruck, um ein Array mit mehreren übereinstimmenden Teilsstrings zurückzugeben, muss in dem regulären Ausdruck das <codeph>g</codeph>-Flag (global) gesetzt sein: </p>
	
	<ul>
	
		<li>Ist das <codeph>g</codeph>-Flag (global) <i>nicht</i> gesetzt, enthält der Rückgabe-Array nicht mehr als eine Übereinstimmung und die <codeph>lastIndex</codeph>-Eigenschaft des regulären Ausdrucks bleibt unverändert.</li> 
	
		<li>Ist das <codeph>g</codeph>-Flag (global) <i>gesetzt</i>, beginnt die Methode die Suche am Anfang des Strings (Indexposition 0). Ist ein übereinstimmender Teilstring ein leerer String (was bei einem regulären Ausdruck wie <codeph>/x~~/</codeph> durchaus passieren kann), fügt die Methode diesen leeren String in das Array an Übereinstimmungen ein, und sucht dann an der nächsten Indexposition weiter. Die <codeph>lastIndex</codeph>-Eigenschaft des regulären Ausdrucks wird auf 0 gesetzt, nachdem die Methode abgeschlossen ist. </li>
	
	</ul>
	
	<p>Wenn keine Übereinstimmung gefunden wird, gibt die Methode den Wert <codeph>null</codeph> zurück. Wenn Sie keinen Wert oder einen nicht definierten Wert) als <codeph>pattern</codeph>-Parameter angeben, gibt die Methode den Wert <codeph>null</codeph> zurück.</p>
	
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Das Muster, mit dem die Fundstelle übereinstimmen soll. Dabei kann es sich um einen beliebigen Objekttyp handeln, typischerweise wird aber ein String oder ein regulärer Ausdruck verwendet. Handelt es sich bei <codeph>pattern</codeph> weder um einen regulären Ausdruck noch um einen String, konvertiert die Methode den Wert in einen String, bevor sie ausgeführt wird. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vergleicht das angegebene Muster (<codeph>pattern</codeph>) mit dem String.
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:replace"><apiName>replace</apiName><shortdesc>
	Vergleicht das angegebene Muster mit dem String und gibt einen neuen String zurück, in dem die erste Übereinstimmung mit Muster durch den von „repl“ angegebenen Inhalt ersetzt ist.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Ergebnisstring. Beachten Sie, dass der Quellstring unverändert bleibt.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Das Muster, mit dem die Fundstelle übereinstimmen soll. Dabei kann es sich um einen beliebigen Objekttyp handeln, typischerweise wird aber ein String oder ein regulärer Ausdruck verwendet. Wenn Sie für den Parameter <codeph>pattern</codeph> ein Objekt beliebigen Typs angeben (also weder String noch regulärer Ausdruck), wird die Methode <codeph>toString()</codeph> auf den Parameter angewendet, und anschließend wird die Methode <codeph>replace()</codeph> ausgeführt, wobei der Ergebnisstring als <codeph>pattern</codeph> verwendet wird. 
	
	</apiDesc></apiParam><apiParam><apiItemName>repl</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>In der Regel wird der String anstelle des übereinstimmenden Inhalts eingefügt. Sie können für diesen Parameter jedoch auch eine Funktion angeben. Wenn Sie eine Funktion angeben, wird der von der Funktion zurückgegebene String anstelle des übereinstimmenden Inhalts eingesetzt.
	
	<p>Wenn Sie für den Parameter <codeph>repl</codeph> einen String angeben und für den Parameter <codeph>pattern</codeph> einen regulären Ausdruck, können Sie die folgenden speziellen <i>$-Ersetzungscodes</i> im <codeph>repl</codeph>-String angeben.</p>
	
	<adobetable class="innertable">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<tgroup cols="2"><thead><row><entry NOWRAP="true">$ Code
		</entry><entry>Ersatztext
		</entry></row></thead><tbody><row>
	
		<entry><codeph>$$</codeph>
		</entry>
	
		<entry><codeph>$</codeph>
		</entry>
	
	</row><row>
	
		<entry><codeph>$&amp;</codeph>
		</entry>
	
		<entry>Der übereinstimmende Teilstring.
		</entry>
	
	</row><row>
	
		<entry><codeph>$`</codeph>	
		</entry>
	
		<entry>Der Teil des Strings, der vor dem übereinstimmenden Teilstring kommt. Beachten Sie, dass dieser Code das nach links gerichtete, halbe Anführungszeichen ohne Tropfen (`) verwendet (und nicht das gerade, Anführungszeichen ohne Tropfen (') oder das nach linksgerichtete Anführungszeichen mit Tropfen ().
		</entry>
	
	</row><row>
	
		<entry><codeph>$'</codeph>
		</entry>
	
		<entry>Der Teil des Strings, der nach dem übereinstimmenden Teilstring kommt. Beachten Sie, dass dieser Code halbe Anführungszeichen ohne Tropfen (') verwendet.
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>n</i>
		</entry>
	
		<entry>Die <i>n</i>. erfasste, in Klammern eingeschlossene Gruppe, wobei <i>n</i> für eine Ziffer zwischen 1 und 9 steht und hinter <codeph>$</codeph><i>n</i> kein Dezimalpunkt steht. 
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>nn</i>
		</entry>
	
		<entry>Die <i>nn</i>. erfasste, in Klammern eingeschlossene Gruppe, wobei <i>nn</i> für eine zweistellige Dezimalzahl (01-99) steht. Ist die <i>nn</i>. Erfassung nicht definiert, ist der Ersetzungstext ein leerer String. 
		</entry>
	
	</row></tbody></tgroup></adobetable>
	
	<p>So zeigt das folgende Beispiel die Verwendung der Ersetzungscodes <codeph>$2</codeph> und <codeph>$1</codeph>, die die erste und zweite erfasste, übereinstimmende Gruppe repräsentieren:</p>
	
	<codeblock>var str:String = "flip-flop";
	var pattern:RegExp = /(\w+)-(\w+)/g;
	trace(str.replace(pattern, "$2-$1")); // flop-flip</codeblock>
	
	<p>Wenn Sie für <codeph>repl</codeph> eine Funktion angeben, übergibt die Methode <codeph>replace()</codeph> die folgenden Parameter an die Funktion:
	</p>
	
	<ul>
	
		<li>
		Der übereinstimmende Teil des Strings.
		</li>
	
		<li>
		Jede erfasste Übereinstimmung mit einer in Klammern eingeschlossene Gruppe wird als nächstes Argument bereitgestellt. Die Anzahl der in dieser Weise übergebenen Argumente hängt von der Anzahl der Übereinstimmungen mit einer in Klammern eingeschlossene Gruppe ab. Um die Anzahl der Übereinstimmungen mit einer in Klammern eingeschlossene Gruppe zu bestimmen, verwenden Sie <codeph>arguments.length - 3</codeph> innerhalb des Funktionscodes.
		</li>
	
		<li>
		Die Indexposition im String, an der die Übereinstimmung beginnt.
		</li>
	
		<li>
		Der vollständige String.
		</li>
	
	</ul>
	
	<p>Berücksichtigen Sie beispielsweise Folgendes:</p>
	
	<codeblock>
	var str1:String = "abc12 def34";
	var pattern:RegExp = /([a-z]+)([0-9]+)/;
	var str2:String = str1.replace(pattern, replFN);
	trace (str2);   // 12abc 34def
	
	function replFN():String {
		return arguments[2] + arguments[1];
	}</codeblock>
	
	
	<p>Der Aufruf an die Methode <codeph>replace()</codeph> verwendet eine Funktion als <codeph>repl</codeph>-Parameter. Der reguläre Ausdruck (<codeph>/([a-z]([0-9]/g</codeph>) wird zweimal gefunden. Das erste Mal entspricht das Muster dem Teilstring <codeph>"abc12"</codeph>, und die folgende Liste an Argumenten wird an die Funktion übergeben:
	</p>
	
	<codeblock>
	{"abc12", "abc", "12", 0, "abc12 def34"}</codeblock>
	
	
	<p>Das zweite Mal entspricht das Muster dem Teilstring <codeph>"def23"</codeph>, und die folgende Liste an Argumenten wird an die Funktion übergeben:
	</p>
	
	<codeblock>
	{"def34", "def", "34", 6, "abc123 def34"}</codeblock>
	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vergleicht das angegebene <codeph>pattern</codeph> mit dem String und gibt einen neuen String zurück, in dem die erste Übereinstimmung mit <codeph>pattern</codeph> durch den von <codeph>repl</codeph> angegebenen Inhalt ersetzt ist. Der Parameter <codeph>pattern</codeph> kann ein String oder ein regulärer Ausdruck sein. Der Parameter <codeph>repl</codeph> kann ein String oder eine Funktion sein. Wenn es sich um eine Funktion handelt, wird die Übereinstimmung durch den von der Funktion zurückgegebenen String ersetzt. Der ursprüngliche String wird nicht geändert.
	
	<p>Im folgenden Beispiel wird die erste Instanz von „sh“ ersetzt (wobei Groß-/Kleinschreibung beachtet wird): </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seashore.</codeblock>
	
	<p>Im folgenden Beispiel werden alle Instanzen von „sh“ (bei Beachtung der Groß-/Kleinschreibung) ersetzt, da im regulären Ausdruck das <codeph>g</codeph>-Flag (global) gesetzt ist. </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/g;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seaschore.</codeblock>
	
	<p>Im folgenden Beispiel werden alle Instanzen von „sh“ ersetzt, da im regulären Ausdruck das <codeph>g</codeph>-Flag (global) gesetzt ist, und die Groß-/Kleinschreibung wird <i>nicht</i> beachtet, da das <codeph>i</codeph>-Flag (ignorCase) gesetzt ist:</p>
	
	<codeblock>
	var myPattern:RegExp = /sh/gi;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // sche sells seaschells by the seaschore.</codeblock>
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:search"><apiName>search</apiName><shortdesc>
	Sucht nach dem angegebenen Muster (pattern) und gibt die Indexposition des ersten übereinstimmenden Teilstrings zurück.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
	 var str:String = "She sells seashells by the seashore.";
		 var myPattern:RegExp = /sh/;  
			// This time, make it case insensitive (with the i flag).
	 trace(str.match(myPattern));  
	
		// Output: 13
		// (The substring match starts at character position 13.)
	
		 var myPattern:RegExp = /sh/i;
	 trace(str.match(myPattern));  
	
		// Output: 0
		// (The substring match starts at character position 0 
			//   -- the first character of the source string.)
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Indexposition des ersten übereinstimmenden Teilstrings bzw. <codeph>-1</codeph>, wenn keine Übereinstimmung gefunden wird. Beachten Sie, dass der String nullindiziert ist, d. h., das erste Zeichen des Strings befindet sich auf Indexposition 0 und das letzte auf <codeph>string.length - 1</codeph>. 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Das Muster, mit dem die Fundstelle übereinstimmen soll. Dabei kann es sich um einen beliebigen Objekttyp handeln, typischerweise wird aber ein String oder ein regulärer Ausdruck verwendet. Handelt es sich bei <codeph>pattern</codeph> weder um einen regulären Ausdruck noch um einen String, konvertiert die Methode den Wert in einen String, bevor sie ausgeführt wird. Beachten Sie, dass die Methode bei regulären Ausdrücken das globale Flag („g“) ignoriert, und ebenso die <codeph>lastIndex</codeph>-Eigenschaft des regulären Ausdrucks ignoriert (und ihn unverändert lässt). Wenn Sie einen nicht definierten Wert (oder keinen Wert) übergeben, gibt die Methode den Wert <codeph>-1</codeph> zurück.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Sucht nach dem angegebenen Muster (<codeph>pattern</codeph>) und gibt die Indexposition des ersten übereinstimmenden Teilstrings zurück. Gibt es keinen übereinstimmenden Teilstring, gibt die Methode den Wert <codeph>-1</codeph> zurück.
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:slice"><apiName>slice</apiName><shortdesc>
	 Gibt einen String zurück, der das durch startIndex angegebene Zeichen und alle Zeichen bis zu dem durch endIndex angegebenen Zeichen (aber nicht einschließlich) enthält.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Teilstring, der auf den angegebenen Indexpositionen basiert.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Indexposition mit der Basis Null des Segmentanfangs. Ist <codeph>startIndex</codeph> eine negative Zahl, wird das Segment von rechts nach links erstellt, wobei -1 das letzte Zeichen bezeichnet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Eine Ganzzahl, die 1+ die Indexposition des Segmentendes angibt. Das durch den Parameter <codeph>endIndex</codeph> indizierte Zeichen wird nicht in den extrahierten String aufgenommen. Wenn <codeph>endIndex</codeph> negativ ist, wird der Endpunkt ausgehend vom Ende des Strings ermittelt, wobei -1 das letzte Zeichen des Strings ist. Standard ist der maximale für eine Indexposition erlaubte Wert. Wenn Sie diesen Parameter weglassen, wird <codeph>String.length</codeph> verwendet.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen String zurück, der das durch <codeph>startIndex</codeph> angegebene Zeichen und alle Zeichen bis zu dem durch <codeph>endIndex</codeph> angegebenen Zeichen (jedoch nicht einschließlich) enthält. Das ursprüngliche String-Objekt wird nicht geändert. Wenn der Parameter <codeph>endIndex</codeph> nicht angegeben wird, endet der Teilstring am Ende des Strings. Wenn das durch <codeph>startIndex</codeph> indizierte Zeichen mit dem durch <codeph>endIndex</codeph> indizierten Zeichen übereinstimmt oder rechts von diesem liegt, gibt die Methode einen leeren String zurück.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/substr()"><linktext>substr()</linktext></link><link href="#String/substring()"><linktext>substring()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:split"><apiName>split</apiName><shortdesc>
	 Unterteilt ein String-Objekt in ein Array an Teilstrings, und immer dort, wo der Parameter „delimiter“ vorkommt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.split, split
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Array mit Teilstrings.
	 
	 
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>delimiter</apiItemName><apiType value=""/><apiDesc>Das Muster, das angibt, wo dieser String aufgeteilt werden soll. Dabei kann es sich um einen beliebigen Objekttyp handeln, typischerweise wird aber ein String oder ein regulärer Ausdruck verwendet. Handelt es sich bei <codeph>delimiter</codeph> weder um einen regulären Ausdruck noch um einen String, konvertiert die Methode den Wert in einen String, bevor sie ausgeführt wird. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>limit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Die maximale Anzahl von Elementen, die in das Array platziert werden sollen. Standard ist der zulässige Höchstwert. 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Unterteilt ein String-Objekt in ein Array an Teilstrings, und immer dort, wo der Parameter <codeph>delimiter</codeph> vorkommt. 
	 
	 <p>Handelt es sich beim Parameter <codeph>delimiter</codeph> um einen regulären Ausdruck, wird nur die erste Übereinstimmung an einer bestimmten Position des Strings berücksichtigt, selbst wenn bei einer Rückverfolgung ein nicht leerer Teilstring an dieser Position gefunden werden könnte. Beispiel:</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "ab";
	 var results:Array = str.split(/a~~?/); // results == ["","b"]
	 
	 results = str.split(/a~~/); // results == ["","b"].)</codeblock>
	 
	 
	 <p>Handelt es sich beim Parameter <codeph>delimiter</codeph> um einen regulären Ausdruck mit Klammerausdrücken, so werden die Ergebnisse der Klammerausdrücke (einschließlich etwaiger undefinierter Ergebnisse) jedes Mal dann auf den Ausgabe-Array aufgeteilt, wenn nach <codeph>delimiter</codeph> gesucht wird. Beispiel</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "Thi5 is a tricky-66 example.";
	 var re:RegExp = /(\d+)/;
	 var results:Array = str.split(re);
	     // results == ["Thi","5"," is a tricky-","66"," example."]</codeblock>
	 
	 
	 <p>Wird der Parameter <codeph>limit</codeph> angegeben, wird der zurückgegebene Array nichts anderes als die angegebene Anzahl an Elementen enthalten.</p>
     <p>Wenn <codeph>delimiter</codeph> ein leerer String, ein leerer regulärer Ausdruck oder ein regulärer Ausdruck, der einem leeren String entsprechen kann, ist, wird jedes einzelne Zeichen in dem String als ein Element in das Array eingetragen.</p>
     
     <p>Wenn der Parameter <codeph>delimiter</codeph> nicht definiert ist, wird der gesamte String in das erste Element des zurückgegebenen Arrays gestellt. </p>     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/join()"><linktext>Array.join()</linktext></link><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:substr"><apiName>substr</apiName><shortdesc>
	 Gibt einen Teilstring zurück, der aus den Zeichen besteht, die an dem angegebenen startIndex beginnen und eine durch „len“ festgelegte Länge besitzen.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substr, substr, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Teilstring, der auf den Parametern basiert.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl, die die Indexposition des ersten Zeichens angibt, das zum Erstellen des Teilstrings verwendet werden soll. Wenn <codeph>startIndex</codeph> negativ ist, wird der Anfangsindex ausgehend vom Ende des Strings ermittelt, wobei <codeph>-1</codeph> das letzte Zeichen des Strings ist.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Die Anzahl der in den Teilstring aufzunehmenden Zeichen. Standard ist der zulässige Höchstwert. Wenn <codeph>len</codeph> nicht angegeben wird, enthält der Teilstring alle Zeichen von <codeph>startIndex</codeph> bis zum Ende des Strings.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen Teilstring zurück, der aus den Zeichen besteht, die an dem angegebenen <codeph> startIndex</codeph> beginnen und eine durch <codeph>len</codeph> festgelegte Länge besitzen. Der ursprüngliche String bleibt unverändert.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:substring"><apiName>substring</apiName><shortdesc>
	 Gibt einen String zurück, der aus dem von „startIndex“ angegebenen Zeichen und allen Zeichen bis zu endIndex - 1 besteht.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substring, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Teilstring, der auf den Parametern basiert.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl, die die Indexposition des ersten Zeichens angibt, das zum Erstellen des Teilstrings verwendet wird. Gültige Werte für <codeph>startIndex</codeph> sind <codeph>0</codeph> bis <codeph>String.length</codeph>. Ist <codeph>startIndex</codeph> ein negativer Wert, wird <codeph>0 </codeph> verwendet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Eine Ganzzahl, die 1+ die Indexposition des letzten Zeichens im extrahierten String angibt. Gültige Werte für <codeph>endIndex</codeph> sind <codeph>0</codeph> bis <codeph>String.length</codeph>. Das bei <codeph>endIndex</codeph> angegebene Zeichen ist nicht im Teilstring enthalten. Standard ist der maximale für eine Indexposition erlaubte Wert. Wenn Sie diesen Parameter weglassen, wird <codeph>String.length</codeph> verwendet. Wenn dieser Parameter ein negativer Wert ist, wird <codeph>0</codeph> verwendet.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen String zurück, der aus dem von <codeph>startIndex</codeph> angegebenen Zeichen und allen Zeichen bis zu <codeph>endIndex - 1</codeph> besteht. Wenn <codeph>endIndex</codeph> nicht angegeben ist, wird <codeph>String.length</codeph> verwendet. Wenn die Werte von <codeph>startIndex</codeph> und <codeph>endIndex</codeph> identisch sind, gibt die Methode einen leeren String zurück. Wenn der Wert von <codeph>startIndex</codeph> größer ist als der Wert von <codeph> endIndex</codeph>, werden die Parameter vor Ausführung der Funktion automatisch ausgetauscht. Der ursprüngliche String bleibt unverändert.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:toLocaleLowerCase"><apiName>toLocaleLowerCase</apiName><shortdesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Großbuchstaben in Kleinbuchstaben umgewandelt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Kopie dieses Strings, in der alle Großbuchstaben in Kleinbuchstaben umgewandelt wurden.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Großbuchstaben in Kleinbuchstaben umgewandelt wurden. Der ursprüngliche String bleibt unverändert. Obwohl diese Methode dafür konzipiert ist, die Umwandlung der lokalen Einstellung entsprechend durchzuführen, erzeugt die ActionScript 3.0-Implementierung keine anderen Ergebnisse als die Methode <codeph>toLowerCase()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLocaleUpperCase"><apiName>toLocaleUpperCase</apiName><shortdesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Kleinbuchstaben in Großbuchstaben umgewandelt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Kopie dieses Strings, in der alle Kleinbuchstaben in Großbuchstaben umgewandelt wurden.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Kleinbuchstaben in Großbuchstaben umgewandelt wurden. Der ursprüngliche String bleibt unverändert. Obwohl diese Methode dafür konzipiert ist, die Umwandlung der lokalen Einstellung entsprechend durchzuführen, erzeugt die ActionScript 3.0-Implementierung keine anderen Ergebnisse als die Methode <codeph>toUpperCase()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLowerCase"><apiName>toLowerCase</apiName><shortdesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Großbuchstaben in Kleinbuchstaben umgewandelt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.tolowercase, tolowercase, to lowercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Kopie dieses Strings, in der alle Großbuchstaben in Kleinbuchstaben umgewandelt wurden.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Großbuchstaben in Kleinbuchstaben umgewandelt wurden. Der ursprüngliche String bleibt unverändert.
	 
	 <p>Diese Methode konvertiert alle Zeichen (nicht einfach A–Z), für die es in Unicode Kleinbuchstaben gibt:</p>
	 
	 <codeblock>
	 var str:String = " JOSÉ BARÇA";
	 trace(str.toLowerCase()); // josé barça</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toUpperCase"><apiName>toUpperCase</apiName><shortdesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Kleinbuchstaben in Großbuchstaben umgewandelt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.touppercase, touppercase, to uppercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Kopie dieses Strings, in der alle Kleinbuchstaben in Großbuchstaben umgewandelt wurden.
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt eine Kopie dieses Strings zurück, in der alle Kleinbuchstaben in Großbuchstaben umgewandelt wurden. Der ursprüngliche String bleibt unverändert.
	 
	 <p>Diese Methode konvertiert alle Zeichen (nicht einfach a–z), für die es in Unicode Großbuchstaben gibt:</p>
	 
	 <codeblock>
	 var str:String = "José Barça";
	 trace(str.toUpperCase()); // JOSÉ BARÇA</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Gibt den Grundwert einer String-Instanz zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new instance of the String class
	 and then shows that the <code>valueOf</code> method returns 
	 the <i>primitive</i> value, rather than a reference to the new instance.
	 
	 <listing version="2.0">
	 var str:String = new String("Hello World");
	 var value:String = str.valueOf();
	 trace(str instanceof String); // true
	 trace(value instanceof String); // false
	 trace(str === value); // false</listing>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Wert des Strings.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den Grundwert einer String-Instanz zurück. Diese Methode ist dafür konzipiert ein String-Objekt in einen String-Grundwert umzuwandeln. Da Flash Player, falls notwendig, <codeph>valueOf()</codeph> automatisch aufruft, kommt es selten vor, dass Sie diese Methode explizit aufrufen müssen.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="String:length:get"><apiName>length</apiName><shortdesc>
	 Eine Ganzzahl, die die Anzahl der Zeichen im angegebenen String-Objekt angibt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Eine Ganzzahl, die die Anzahl der Zeichen im angegebenen String-Objekt angibt.
	 <p>
	 Da alle Stringindizes die Basis null haben, ist die Indexposition für das letzte Zeichen eines <codeph>x</codeph>-Strings <codeph>x.length - 1</codeph>.
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Class"><apiName>Class</apiName><shortdesc>
 Ein Class-Objekt wird für jede Klassendefinition in einem Programm erstellt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Ein Class-Objekt wird für jede Klassendefinition in einem Programm erstellt. Jedes Class-Objekt ist eine Instanz der Class-Klasse. Das Class-Objekt enthält die statischen Eigenschaften und Methoden der Klasse. Das Klassenobjekt erstellt Instanzen der Klasse, wenn es mit dem Operator <codeph>new</codeph> erstellt worden ist.
 
 <p>Einige Methoden, wie etwa <codeph>flash.net.getClassByAlias()</codeph> geben ein Objekt vom Class-Typ zurück. Andere Methoden haben einen Parameter vom Class-Typ, z. B. <codeph>flash.net.registerClassAlias()</codeph>. </p>
 <p>Der Name der Klasse ist der Verweis auf das Class-Objekt, wie das folgende Beispiel veranschaulicht:</p>
 <pre> 
 class Foo {
 }
 </pre> 
 <p>Die Anweisung <codeph>class Foo{}</codeph> ist die Klassendefinition, die dass Class-Objekt Foo erstellt. Außerdem wird die Anwendung <codeph>new Foo()</codeph> eine neue Instanz der Foo-Klasse erstellen, und das Ergebnis wird vom Typ Foo sein.</p>
 <p>Verwenden Sie die Anwendung <codeph>class</codeph>, um Ihre Klasse zu deklarieren. Class-Objekte sind nützlich für fortgeschrittene Techniken wie das Zuweisen von Klassen zu einem vorhandenen Instanzobjekt während der Laufzeit (vgl. den Abschnitt „Beispiele“ weiter unten).</p>
 <p>Statische Eigenschaften und Methoden einer Klasse befinden sich im Class-Objekt einer Klasse. „Class“ selbst deklariert <codeph>prototype</codeph>.</p>
 
 <p>Im Allgemeinen müssen Sie Variablen vom Typ Class nicht manuell deklarieren. Im nachfolgenden Code jedoch wird eine Klasse als öffentliche Class-Eigenschaft <codeph>circleClass</codeph> zugewiesen, und Sie können auf diese Class-Eigenschaft als eine Eigenschaft der Hauptklasse Library verweisen.</p>
 <codeblock>
 package {
  import flash.display.Sprite;
  public class Library extends Sprite {
      
      public var circleClass:Class = Circle;
      public function Library() {
      }
  }
 }
  
 import flash.display.Shape;
 class Circle extends Shape {
  public function Circle(color:uint = 0xFFCC00, radius:Number = 10) {
      graphics.beginFill(color);
      graphics.drawCircle(radius, radius, radius);
  }
 }
 </codeblock>
 
 <p>Eine andere SWF-Datei kann die resultierende Datei „Library.swf“ laden und dann Objekte vom Typ Circle instanziieren. Das folgende Beispiel zeigt eine Möglichkeit, auf die Bestände einer untergeordneten SWF-Datei zuzugreifen. (Andere mögliche Verfahren sind die Verwendung von <codeph>flash.utils.getDefnitionByName()</codeph> oder das Importieren von Teildefinitionen aus der untergeordneten SWF-Datei.)</p>
 
 <codeblock>
 package {
  import flash.display.Sprite;
  import flash.display.Shape;
  import flash.display.Loader;
  import flash.net.URLRequest;
  import flash.events.Event;
  public class LibaryLoader extends Sprite {
      public function LibaryLoader() {
          var ldr:Loader = new Loader();
          var urlReq:URLRequest = new URLRequest("Library.swf");
          ldr.load(urlReq);
          ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
      }
      private function loaded(event:Event):void {
          var library:Object = event.target.content;
          var circle:Shape = new library.circleClass();
          addChild(circle);
      }
  }
 }
 </codeblock>
 <p>In ActionScript 3.0 können Sie für externe Bestände (wie Grafiken, Sounds oder Schriften) eingebettete Klassen erstellen, die in SWF-Dateien kompiliert werden. In früheren ActionScript-Versionen haben Sie diese Bestände verknüpft, indem Sie in der Methode <codeph>MovieClip.attachMovie()</codeph> eine Verknüpfungs-ID verwendet haben. In ActionScript 3.0 wird jeder eingebettete Bestand durch eine einmalige eingebettete Bestandklasse repräsentiert. Daher können Sie die mit dem Bestand verbundene Klasse mithilfe des Operators <codeph>new</codeph> instanziieren und für diesen Bestandsartikel Methoden und Eigenschaft aufrufen.</p>
 <p product="flex">Wenn Sie beispielsweise SWF-Dateien mit einem MXML-Compiler erstellen, würden Sie eine eingebettete Klasse folgendermaßen erstellen:</p>
 <codeblock product="flex">
     [Embed(source="bratwurst.jpg")]
     public var imgClass:Class;
 </codeblock>
 <p product="flex">Zum Instanziieren schreiben Sie Folgendes:</p>
 <codeblock product="flex">
     var myImg:Bitmap = new imgClass();
 </codeblock>
 
 </apiDesc><example conref="examples\Class.1.as"> Im folgenden Beispiel wird veranschaulicht, wie Sie mit Class-Objekten die Entscheidung darüber, welche Klasse instanziiert werden soll, bis zur Laufzeit zurückstellen können. Führen Sie dazu die folgenden Schritte aus:
 <ol>
     <li>Deklarieren Sie zwei Klassen: <codeph>ClassA</codeph> und <codeph>ClassB</codeph>. </li>
     <li>Deklarieren Sie eine Variablen vom Typ Class mit dem Namen <codeph>classToConstruct</codeph> und eine vom Typ Boolean <codeph>chooseClassA</codeph>, die in diesem Fall auf <codeph>true</codeph> gesetzt ist. Sie können den Wert dieser Variablen jedoch auch mit einen benutzerdefinierten Test-Ausdruck festlegen. </li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ClassExample extends Sprite {
        public function ClassExample() {
            var classToConstruct:Class;            
            var classInstance:Object;

            classToConstruct = ClassA;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassA]

            classToConstruct = ClassB;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassB]
        }
    }
}

class ClassA {
}
    
class ClassB {
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>Object.prototype</linktext></link><link href="operators.html#new"><linktext>new-Operator</linktext></link></related-links></apiClassifier><apiClassifier id="globalClassifier:Namespace"><apiName>Namespace</apiName><shortdesc>

Die Namespace-Klasse enthält Methoden und Eigenschaften für die Definition und Verwendung von Namespaces (Namensräumen).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Namespace
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Die Namespace-Klasse enthält Methoden und Eigenschaften für die Definition und Verwendung von Namespaces von XML-Objekten.

</apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

Die Namespace-Klasse enthält Methoden und Eigenschaften für die Definition und Verwendung von Namespaces (Namensräumen). Es gibt drei Situationen, in denen Namespaces verwendet werden:

<ul>
<li> <b>Namespaces von XML-Objekten.</b> Namespaces ordnen ein Namespacepräfix einem URI (Uniform Resource Identifier, einheitlicher Ressourcenlokator) zu, der den Namespace identifiziert. Das Präfix ist ein String, der verwendet wird, um innerhalb eines XML-Objekts auf den Namespace zu verweisen. Ist das Präfix nicht definiert, wenn das XML-Objekt in einen String konvertiert wird, wird ein Präfix automatisch erzeugt.
</li>

<li> <b>Namespaces zum Unterscheiden von Methoden.</b> Namespaces können Methoden mit demselben Namen unterscheiden, die aber unterschiedliche Aufgaben wahrnehmen. Besitzen zwei Methoden denselben Namen, aber unterschiedliche Namespaces, so können Sie unterschiedliche Aufgaben durchführen.
</li>

<li> <b>Namespaces für die Zugriffskontrolle.</b> Namespaces können verwendet werden, um auf eine Gruppe von Eigenschaften und Methoden in einer Klasse zuzugreifen. Wenn Sie die Eigenschaften und Methoden in einen „private“-Namespace setzen, sind sie für jeglichen Code, der keine Zugriffsberechtigung zu diesem Namespace hat, unzugänglich. Sie können Zugriff zu dieser Gruppe an Eigenschaften und Methoden gewähren, indem Sie den Namespace auch an andere Klassen, Methoden oder Funktionen übergeben.
</li>
</ul>

<p>Diese Klasse zeigt zwei Formen der Konstruktormethode, da jede Form andere Parameter akzeptiert.</p>

<p>Diese Klasse implementiert (zusammen mit den Klassen XML, XMLList und QName) leistungsstarke Standards zur XML-Verarbeitung, die in der Spezifikation ECMA-357, Edition 2: „ECMAScript for XML (E4X)“ definiert sind.</p>

</apiDesc><example conref="examples\NamespaceExample.as"> Das folgende Beispiel veranschaulicht, wie Sie mit in XML-Objekten definierten Namespaces arbeiten. Dies wird in den folgenden Schritten erreicht:
 <ol>
    <li>In diesem Beispiel werden drei Namespace-Objekte definiert, und zwar jeweils mit einer den Namespace definierenden eindeutigen URI.</li>
    <li>In diesem Beispiel wird eine XML-Variable mit dem Namen <codeph>myXML</codeph> definiert und dem Rückgabewert <codeph>getRSS()</codeph> zugewiesen. Die <codeph>getRSS()</codeph>-Methode definiert ein XML-Objekt, das mehrere Namespaces enthält, und gibt dieses XML-Objekt zurück.</li>
    <li>Eine Array-Variable wird deklariert und bewertet, indem die Methode <codeph>parseRSS()</codeph> aufgerufen und an die<codeph>myXML</codeph> übergeben wird. Der Standard-XML-Namespace wird in <codeph>parseRSS()</codeph> als <codeph>rss</codeph> definiert. Im Beispiel wird durch Zuweisen der Liste der <codeph>item</codeph>-Objekte in <codeph>myXML</codeph> eine XMLList-Variable definiert. Ein Array wird mit verschiedenen Knoten innerhalb von <codeph>myXML.item</codeph> erstellt und gefüllt. Anschließend wird das Array zurückgegeben.</li>
    <li>Der Ausdruck der im Array enthaltenen Elemente erfolgt mithilfe einer <codeph>for</codeph>-Schleife und von drei Aufrufen von <codeph>trace()</codeph>.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class NamespaceExample extends Sprite {
        private var rss:Namespace = new Namespace("http://purl.org/rss/1.0/");
        private var rdf:Namespace = new Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
        private var dc:Namespace  = new Namespace("http://purl.org/dc/elements/1.1/");

        public function NamespaceExample() {
            var myXML:XML = getRSS();
            var rssItems:Array = parseRSS(myXML);
            
            var len:uint = rssItems.length;
            for (var i:uint; i &lt; len; i++) {
                trace(rssItems[i].title);
                trace(rssItems[i].creator);
                trace(rssItems[i].date);
                // Adobe Flash Developer Center
                // Adobe
                // 2005-08-08
                // Flex Developer Center
                // Adobe
                // 2005-10-16                
            }
        }
        
        private function parseRSS(rssXML:XML):Array {
            default xml namespace = rss;

            var items:XMLList = rssXML.item;

            var arr:Array = new Array();            
            var len:uint = items.length();
            for (var i:uint; i &lt; len; i++) {
                arr.push({title:items[i].title, creator:items[i].dc::creator, date:items[i].dc::date});
            }
            
            return arr;
        }

        private function getRSS():XML {
            var myXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/"
            >
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Adobe Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            return myXML;
        }
    }
}
</codeblock></example><example conref="examples\Namespace_2_Example.as"> Das folgende Beispiel veranschaulicht, wie Methoden, die den gleichen Namen haben, aber verschiedene Aufgaben ausführen, mithilfe von Namespaces unterschieden werden können. Im Rahmen dieses Beispiels befinden sich drei Methoden namens <codeph>hello()</codeph> in separaten Namespaces; bei jedem Aufruf wird ein anderer String zurückgegeben.
<codeblock>
package {

    import flash.display.Sprite;

    public class Namespace_2_Example extends Sprite {    
        public function Namespace_2_Example() {
            var vocab:MultilingualVocabulary = new MultilingualVocabulary();

            trace(vocab.hello());    // hello
            
            var languages:Array = vocab.getLanguages();
            
            for (var i:uint; i &lt; languages.length; i++) {
                var ns:Namespace = languages[i];
                if (ns != null) {
                    trace(ns.toString() + ": " + vocab.ns::hello());
                    // hello
                    // MultilingualVocabulary:Hawaiian: aloha
                    // MultilingualVocabulary:French: bon jour
                }
            }
        }
    }    
}

class MultilingualVocabulary {
    public namespace French;
    public namespace Hawaiian;
    private var languages:Array;

    public function MultilingualVocabulary() {
        languages = new Array(Hawaiian, French);
    }
        
    public function hello():String { 
        return "hello";
    }

    Hawaiian function hello():String {
        return "aloha";
    }

    French function hello():String { 
        return "bon jour";
    }
        
    public function getLanguages():Array {
        return languages;
    }
}
</codeblock></example><example conref="examples\Namespace_3_Example.as"> Im folgenden Beispiel wird mithilfe von Namespace-Namen der entsprechende Variablenwert ausgewählt. Es wird veranschaulicht, wie Sie einen Namespace-Wert in einer Variable speichern und mit dieser Variablen auf Objekte in diesem Namespace verweisen.
 <p>In diesem Beispiel werden Namespaces und Farben definiert, die den Mauszuständen für eine rechteckige Schaltfläche entsprechen. Bei jedem Zeichnen der Schaltfläche wird die entsprechende Farbe („out“ (Deaktiviert) ist Rot; „over“ (Darüber) ist Gelb; „down“ (Gedrückt) ist Weiß) angewendet, indem die <codeph>bgcolor</codeph>-Variable auf den entsprechenden Namespace verweist (<codeph>out</codeph>, <codeph>over</codeph>, <codeph>down</codeph>). </p>
<codeblock>
package {
    import flash.display.Sprite;
  
    public class Namespace_3_Example extends Sprite {     
        public function Namespace_3_Example() {
            addChild(new StateButton("Press Me."));
        }
    }
}

import flash.display.Sprite;
import flash.text.TextField;
import flash.events.Event;
import flash.events.MouseEvent;

class StateButton extends Sprite{
    private namespace out;
    private namespace over;
    private namespace down;
    private var label:TextField;
    private var labelTxt:String;
    private var ns:Namespace;
    out var bgColor:Number = 0xFF0000;
    over var bgColor:Number = 0xFFFF00;
    down var bgColor:Number = 0xFFFFFF;
      
    public function StateButton(str:String) {
        buttonMode = true;
        labelTxt = str;
        ns = out;
        draw();
        addLabel();
        addListeners();
    }

    private function addLabel():void {
        label = new TextField();
        label.text = labelTxt;
        label.width = 50;
        label.height = 20;
        label.mouseEnabled = false;
        addChild(label);
    }
      
    private function addListeners():void {
        addEventListener(MouseEvent.MOUSE_UP, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
    }
 
    private function mouseOutHandler(e:Event):void {
        ns = out;
        draw();
    }
 
    private function mouseOverHandler(e:Event):void {
        ns = over;
        draw();
    }
 
    private function mouseDownHandler(e:Event):void {
        ns = down;
        draw();
    }
 
    private function draw():void {
        this.graphics.clear();
        this.graphics.beginFill(ns::bgColor);
        this.graphics.drawRect(0, 0, 60, 20);
    }
} 
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Spezifikation ECMA-357, Edition 2: „ECMAScript for XML (E4X)“</linktext></link></related-links><apiConstructor id="Namespace:Namespace_0"><apiName>Namespace</apiName><shortdesc> 
	Erstellt ein Namespace-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>Der Namespace-URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner).
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt ein Namespace-Objekt bei gegebenem „uriValue“.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	Erstellt ein Namespace-Objekt. Welche Werte den Eigenschaften <codeph>uri</codeph> und <codeph>prefix</codeph> des neuen Namespace-Objekts zugewiesen werden, hängt davon ab, welche Art von Wert an den Parameter <codeph>uriValue</codeph> übergeben wurde:
	<ul>
	  <li>Wurde kein Wert übergeben, werden die Eigenschaften <codeph>prefix</codeph> und <codeph>uri</codeph> auf einen leeren String gesetzt.</li>
	  <li>Ist der Wert ein Namespace-Objekt, wird eine Kopie des Objekts erstellt.</li>
	  <li>Ist der Wert ein QName-Objekt, wird die <codeph>uri</codeph> auf die <codeph>uri</codeph>-Eigenschaft des QName-Objekts gesetzt.</li>
	</ul>
    <p><b>Hinweis:</b> Diese Klasse zeigt zwei Konstruktoreinträge, da jede Form andere Parameter akzeptiert. Der Konstruktor verhält sich unterschiedlich, je nach Typ und Anzahl der übergebenen Parameter, wie sie in den einzelnen Einträgen beschrieben sind. Überladene Methoden oder Konstruktoren werden von ActionSript 3.0 nicht unterstützt.</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="Namespace:Namespace_1"><apiName>Namespace</apiName><shortdesc> 
	Erstellt ein Namespace-Objekt gemäß den Werten der Parameter prefixValue und uriValue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>prefixValue</apiItemName><apiType value=""/><apiDesc>Das für den Namespace zu verwendende Präfix.   
	
	</apiDesc></apiParam><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>Der Namespace-URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner).
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt ein Namespace-Objekt bei gegebenem prefixValue und uriValue.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	Erstellt ein Namespace-Objekt gemäß den Werten der Parameter <codeph>prefixValue</codeph> und <codeph>uriValue</codeph>. Dieser Konstruktor benötigt beide Parameter.
	<p>Der Wert des Parameters <codeph>prefixValue</codeph> wird der <codeph>prefix</codeph>-Eigenschaft wie folgt zugewiesen:</p>
	<ul>
	  <li>Wird <codeph>undefined</codeph> übergeben, wird die <codeph>prefix</codeph>-Eigenschaft auf <codeph>undefined</codeph> gesetzt.</li>
	  <li>Handelt es sich bei dem Wert um einen gemäß der Funktion <codeph>isXMLName()</codeph> gültigen XML-Namen, wird er in einen String konvertiert und der Eigenschaft <codeph>prefix</codeph> zugewiesen.</li>
	  <li>Ist der Wert kein gültiger XML-Name, wird <codeph>prefix</codeph> auf <codeph>undefined</codeph> gesetzt.</li>
	</ul>
	
	<p>Der Wert des Parameters <codeph>uriValue</codeph> wird der Eigenschaft <codeph>uri</codeph> wie folgt zugewiesen:</p>
	<ul>
	  <li>Wird ein QName-Objekt übergeben, wird die Eigenschaft <codeph>uri</codeph> auf den Wert der <codeph>uri</codeph>-Eigenschaft des QName-Objekts gesetzt.</li>
	  <li> Andernfalls wird der Parameter <codeph>uriValue</codeph> in einen String konvertiert und der Eigenschaft <codeph>uri</codeph> zugewiesen.</li>
	</ul>
    <p><b>Hinweis:</b> Diese Klasse zeigt zwei Konstruktormethodeneinträge, da jede Form andere Parameter akzeptiert. Der Konstruktor verhält sich unterschiedlich, je nach Typ und Anzahl der übergebenen Argumente, wie sie in den einzelnen Einträgen beschrieben sind. Überladene Methoden oder Konstruktoren werden von ActionSript 3.0 nicht unterstützt.</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Namespace:AS3:toString"><apiName>toString</apiName><shortdesc>
	Äquivalent zur Eigenschaft Namespace.uri.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Namespace-URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner) als String.
	
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Äquivalent zur Eigenschaft Namespace.uri. 
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Äquivalent zur Eigenschaft <codeph>Namespace.uri</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="Namespace:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    Gibt den URI-Wert des angegebenen Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Namespace-URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner) als String.
    
    
    </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Äquivalent zur Eigenschaft Namespace.uri. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Gibt den URI-Wert des angegebenen Objekts zurück. 
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="Namespace:prefix:get"><apiName>prefix</apiName><shortdesc>
	Das Präfix des Namespaces.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.prefix, prefix
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Das Präfix des Namespaces.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Das Präfix des Namespaces.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="Namespace:uri:get"><apiName>uri</apiName><shortdesc>
	Der Namespace-URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Der Namespace-URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner).
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Der Namespace-URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner).
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:XML"><apiName>XML</apiName><shortdesc>
	Die XML-Klasse enthält Methoden und Eigenschaften für die Arbeit mit XML-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XML
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die XMl-Klasse enthält Methoden und Eigenschaften für die Arbeit mit XML-Objekten. Die XML-Klasse implementiert (zusammen mit den Klassen XMLList, Namespace und QName) leistungsstarke Standards zur XML-Verarbeitung, die in der Spezifikation ECMA-357, Edition 2: „ECMAScript for XML (E4X)“ definiert sind.
	
	<p>Verwenden Sie die Methode <codeph>toXMLString()</codeph>, um das XML-Objekt als String zurückzugeben, und zwar unabhängig davon, ob das XML-Objekt einen einfachen oder komplexen Inhalt besitzt.</p>
	
	<p><b>Hinweis</b>: Die XML-Klasse aus ActionScript 2.0 wurde (ebenso wie andere, verwandte Klassen) in „XMLDocument“ umbenannt und in das Paket flash.xml verlagert. In ActionScript 3.0 ist sie aus Gründen der Rückwärtskompatibilität enthalten.</p> 
	
	
    </apiDesc><example conref="examples\XMLExample.as"> Im folgenden Beispiel wird zunächst eine XML-Variable erstellt, zu der dann Knoten hinzugefügt werden. Anschließend wird mithilfe von XML-Eigenschaften nach XML-Knoten gesucht, die dann gedruckt werden. Beachten Sie, dass das „at“-Symbol (<codeph>@</codeph>) bei mehreren Aufrufen von <codeph>trace()</codeph> verwendet wird, um Informationen anhand des Attributnamens zu finden.
<codeblock>
package {
    import flash.display.Sprite;

    public class XmlExample extends Sprite {        
        public function XmlExample() {
            var employees:XML =
                &lt;employees>
                    &lt;employee ssn="123-123-1234">
                        &lt;name first="John" last="Doe"/>
                        &lt;address>
                            &lt;street>11 Main St.&lt;/street>
                            &lt;city>San Francisco&lt;/city>
                            &lt;state>CA&lt;/state>
                            &lt;zip>98765&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                    &lt;employee ssn="789-789-7890">
                        &lt;name first="Mary" last="Roe"/>
                        &lt;address>
                            &lt;street>99 Broad St.&lt;/street>
                            &lt;city>Newton&lt;/city>
                            &lt;state>MA&lt;/state>
                            &lt;zip>01234&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                &lt;/employees>;

            trace(employees.employee[0].address.zip);   // 98765

            trace(employees.employee[1].@ssn);          // 789-789-7890

            trace(employees.employee.name);             // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees..zip[0]);                   // 98765

            trace(employees..@ssn[1]);                  // 789-789-7890

            trace(employees..name);                     // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees.employee[0].address.*);     // &lt;street>11 Main St.&lt;/street>    
                                                        // &lt;city>San Francisco&lt;/city>
                                                        // &lt;state>CA&lt;/state>
                                                        // &lt;zip>98765&lt;/zip>
            var node:String = "zip";
            trace(employees.employee[0].address[node]); // 98765
            
            var attribute:String = "ssn";
            trace(employees.employee[1].@[attribute]);  // 789-789-7890
            
            for each (var num:XML in employees..@ssn) {
                trace(num);                             // 123-123-1234
            }                                           // 789-789-7890
            
            var ssnToFind:String = "789-789-7890";
            trace(employees.employee.(@ssn == ssnToFind).toXMLString());
                                                        // &lt;employee ssn="789-789-7890">
                                                        // &lt;name first="Mary" last="Roe"/>
                                                        // &lt;address>
                                                        // &lt;street>99 Broad St.&lt;/street>
                                                        // &lt;city>Newton&lt;/city>
                                                        // &lt;state>MA&lt;/state>
                                                        // &lt;zip>01234&lt;/zip>
                                                        // &lt;/address>
                                                        // &lt;/employee>
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Spezifikation ECMA-357, Edition 2: „ECMAScript for XML (E4X)“</linktext></link></related-links><apiConstructor id="XML:XML"><apiName>XML</apiName><shortdesc> 
	Erstellt ein neues XML-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Jedes Objekt, das sich mithilfe von <codeph>XML()</codeph>, einer Funktion oberster Ebene, in ein XMLList-Objekt konvertieren lässt.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc> 
	Erstellt ein neues XML-Objekt. Vor dem Aufruf einer Methode der XML-Klasse muss der Konstruktor zum Erstellen eines XML-Objekts verwendet werden. 
	
	<p>Verwenden Sie die Methode <codeph>toXMLString()</codeph>, um das XML-Objekt als String zurückzugeben, und zwar unabhängig davon, ob das XML-Objekt einen einfachen oder komplexen Inhalt besitzt.</p>
	
	</apiDesc></apiConstructorDetail><related-links><link href="package.html#XML()"><linktext>top-level XML() function</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiConstructor><apiOperation id="XML:AS3:addNamespace"><apiName>addNamespace</apiName><shortdesc>
	Erweitert den Satz an gültigen Namespaces für das XML-Objekt um einen Namespace.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.addNamespace, addNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das neue XML-Objekt mit dem zusätzlichen Namespace.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Der Namespace, der zum XML-Objekt hinzufügt werden soll.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Erweitert den Satz an gültigen Namespaces für das XML-Objekt um einen Namespace. Existiert der Namespace bereits im Namespace-Gültigkeitsbereich für das XML-Objekt (mit dem Präfix aus dem angegebenen Parameter), so wird das Präfix des bereits vorhandenen Namespaces auf <codeph>undefined</codeph> gesetzt. Handelt es sich beim Eingabeparameter um ein Namespace-Objekt, wird es direkt verwendet. Handelt es sich um ein QName-Objekt, wird der URI des Eingabeparameters verwendet, um einen neuen Namespace zu erstellen; andernfalls wird es in einen String konvertiert und der Namespace wird aus diesem String erstellt.
	
	</apiDesc><example conref="examples\XML.addNamespace.1.as"> In diesem Beispiel wird ein Namespace, der in einem XML-Objekt definiert wurde auf ein anderes XML-Objekt angewendet:
<codeblock>
var xml1:XML = &lt;ns:foo xmlns:ns="www.example.com/ns" />;
var nsNamespace:Namespace = xml1.namespace();

var xml2:XML = &lt;bar />;
xml2.addNamespace(nsNamespace);
trace(xml2.toXMLString()); // &lt;bar xmlns:ns="www.example.com/ns"/>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:appendChild"><apiName>appendChild</apiName><shortdesc>
	Hängt das angegebene untergeordnete Objekt ans Ende der Eigenschaften des XML-Objekts an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.appendChild, appendChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das resultierende XML-Objekt.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das anzuhängende XML-Objekt.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
	Hängt das angegebene untergeordnete Objekt ans Ende der Eigenschaften des XML-Objekts an. Die Methode <codeph>appendChild()</codeph> akzeptiert ein XML-Objekt, ein XMLList-Objekt oder einen anderen Datentyp, der dann in einen String konvertiert wird. 
    
    <p>Verwenden Sie den Operator <codeph>delete</codeph>, um den XML-Knoten zu entfernen.</p>
	
	</apiDesc><example conref="examples\XML.appendChild.1.as"> In diesem Beispiel wird am Ende der untergeordneten Liste eines XML-Objekts ein neues Element angehängt:
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.appendChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>hello&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>world&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>delete-(XML)-Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	Gibt den XML-Wert des Attributs zurück, das den mit dem Parameter attributeName übereinstimmenden Namen besitzt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt oder ein leeres XMLList-Objekt. Gibt ein leeres XMLList-Objekt zurück, wenn ein Attributwert nicht definiert worden ist.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>Der Name des Attributs.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Gibt den XML-Wert des Attributs zurück, das den mit dem Parameter <codeph>attributeName</codeph> übereinstimmenden Namen besitzt. Attribute befinden sich innerhalb von XML-Elementen. Im folgenden Beispiel hat das Element ein Attribut mit dem Namen "<codeph>gender</codeph>" und dem Wert "<codeph>boy</codeph>": <codeph>&lt;first gender="boy">John&lt;/first></codeph> .
	
	<p>Der Parameter <codeph>attributeName</codeph> kann einen beliebigen Datentyp besitzen; allerdings ist String der am häufigsten verwendete Datentyp. Wenn Sie ein beliebiges Objekt übergeben, das kein QName-Objekt ist, verwendet der Parameter <codeph>attributeName</codeph> die Methode <codeph>toString()</codeph>, um den Parameter in einen String zu konvertieren. </p>
	
	<p>Wenn Sie eine qualifizierte Namensreferenz benötigen, können Sie ein QName-Objekt übergeben. Ein QName-Objekt definiert einen Namespace und den lokalen Namen, den Sie verwenden können, um den qualifizierten Namen eines Attributs zu definieren. Daher ist es nicht dasselbe, ob Sie <codeph>attribute(qname)</codeph> oder <codeph>attribute(qname.toString())</codeph> aufrufen.</p>
	
	</apiDesc><example conref="examples\XMLAttributeExample1.as"> Im folgenden Beispiel wird ein QName-Objekt in eine <codeph>attribute()</codeph>-Methode übergeben. Die <codeph>localName</codeph>-Eigenschaft hat den Wert <codeph>attr</codeph>, und die <codeph>namespace</codeph>-Eigenschaft hat den Wert <codeph>ns</codeph>.
<codeblock>
 var xml:XML = &lt;ns:node xmlns:ns = "http://uri" ns:attr = '7' />       
 var qn:QName = new QName("http://uri", "attr");
 trace (xml.attribute(qn)); // 7
</codeblock></example><example conref="examples\XMLAttributeExample2.as"> Um ein Attribut mit einem Namen zurückzugeben, der einem in ActionScript reservierten Wort entspricht, verwenden Sie die <codeph>attribute()</codeph>-Methode anstelle des (@)-Operators, der als Attributbezeichner dient (siehe folgendes Beispiel):
<codeblock>
 var xml:XML = &lt;example class="first" />
 trace(xml.attribute("class"));
 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="operators.html#attribute_identifier"><linktext>Attributbezeichner (&amp;#064;) Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	Gibt eine Liste von Attributwerten für ein bestimmtes XML-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Liste der Attributwerte.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Liste von Attributwerten für ein bestimmtes XML-Objekt zurück. Verwenden Sie die Methode <codeph>name()</codeph> mit der Methode <codeph>attributes()</codeph>, um den Namen eines Attributs zurückzugeben. Die Verwendung von <codeph>xml.attributes()</codeph> entspricht <codeph>xml.@*</codeph>.
	
	</apiDesc><example conref="examples\XMLAttributesExample1.as"> Im folgenden Beispiel wird der Name des Attributs zurückgegeben:

<codeblock>
var xml:XML=&lt;example id='123' color='blue'/>
trace(xml.attributes()[1].name()); //color
</codeblock></example><example conref="examples\XMLAttributesExample2.as"> In diesem Beispiel werden die Namen aller Attribute zurückzugeben:
<codeblock>
 
var xml:XML = &lt;example id='123' color='blue'/>
var attNamesList:XMLList = xml.@*;

trace (attNamesList is XMLList); // true
trace (attNamesList.length()); // 2

for (var i:int = 0; i &lt; attNamesList.length(); i++)
{ 
    trace (typeof (attNamesList[i])); // xml
    trace (attNamesList[i].nodeKind()); // attribute
    trace (attNamesList[i].name()); // id and color
} 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/name()"><linktext>XML.name()</linktext></link><link href="operators.html#attribute_identifier"><linktext>&amp;#064; Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:child"><apiName>child</apiName><shortdesc>
	Listet die untergeordneten Knoten eines XML-Objekts auf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit untergeordneten Knoten, die dem input-Parameter entsprechen. 
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Der Elementname oder die Ganzzahl des untergeordneten XML-Elements. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Listet die untergeordneten Knoten eines XML-Objekts auf. Bei einem untergeordneter XML-Knoten kann es sich um ein XML-Element, einen Textknoten, einen Kommentar oder eine Verarbeitungsanweisung handeln. 
	
	<p>Verwenden Sie den Parameter <codeph>propertyName</codeph>, um den Inhalt eines bestimmten untergeordneten XML-Knotens aufzulisten. Um beispielsweise den Inhalt des untergeordneten Knotens mit dem Namen <codeph>&lt;first></codeph> auszugeben, verwenden Sie <codeph>child.name("first")</codeph>. Sie erzeugen dasselbe Ergebnis, wenn Sie die Indexnummer des untergeordneten Knotens verwenden. Die Indexnummer identifiziert die Position des untergeordneten Knotens in der Liste weiterer untergeordneter XML-Knoten. <codeph>name.child(0)</codeph> beispielsweise gibt den ersten untergeordneten Knoten in einer Liste zurück. </p>
	
	<p>Verwenden Sie ein Sternchen (~~), um alle untergeordneten Knoten eines XML-Dokuments auszugeben. Zum Beispiel <codeph>doc.child("~~")</codeph>.</p>  
	
	<p>Verwenden Sie die Methode <codeph>length()</codeph> mit dem Sternparameter (~~) der Methode <codeph>child()</codeph>, um die Gesamtanzahl der untergeordneten Knoten auszugeben. Zum Beispiel <codeph>numChildren = doc.child("~~").length()</codeph>.</p>
	
	</apiDesc><example conref="examples\XML.child.1.as"> Im folgenden Beispiel wird veranschaulicht, wie Sie mithilfe der <codeph>child()</codeph>-Methode untergeordnete Elemente mit einem angegebenen Namen identifizieren:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;bar>text1&lt;/bar>
            &lt;bar>text2&lt;/bar>
        &lt;/foo>;
trace(xml.child("bar").length());  // 2
trace(xml.child("bar")[0].toXMLString()); // &lt;bar>text1&lt;/bar>
trace(xml.child("bar")[1].toXMLString()); // &lt;bar>text2&lt;/bar>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="#XMLList"><linktext>XMLList-Klasse</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:childIndex"><apiName>childIndex</apiName><shortdesc>
	Identifiziert die nullindizierte Position dieses XML-Objekts innerhalb des Kontexts des übergeordneten Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.childindex, childindex
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Position des Objekts. Gibt -1 zurück sowie alle positiven Ganzzahlen.
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Identifiziert die nullindizierte Position dieses XML-Objekts innerhalb des Kontexts des übergeordneten Objekts.
	
	</apiDesc><example conref="examples\XML.childIndex.1.as"> Im folgenden Beispiel wird veranschaulicht, wie Sie die <codeph>childIndex()</codeph>-Methode verwenden:
<codeblock>
var xml:XML = 
            &lt;foo>
                &lt;bar />
                text
                &lt;bob />
            &lt;/foo>;
trace(xml.bar.childIndex()); // 0
trace(xml.bob.childIndex()); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:children"><apiName>children</apiName><shortdesc>
	Listet die untergeordneten Knoten des XML-Objekts auf, und zwar in der Reihenfolge, in der sie erscheinen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit den Knoten, die dem XML-Objekt untergeordnet sind.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Listet die untergeordneten Knoten des XML-Objekts auf, und zwar in der Reihenfolge, in der sie erscheinen. Bei einem untergeordneten XML-Knoten kann es sich um ein XML-Element, einen Textknoten, einen Kommentar oder eine Verarbeitungsanweisung handeln. 
	
	</apiDesc><example conref="examples\XML.children.1.as"> Im folgenden Beispiel wird veranschaulicht, wie Sie die <codeph>children()</codeph>-Methode verwenden:
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var xml:XML = 
        &lt;foo id="22">
            &lt;bar>44&lt;/bar>
            text
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml.children().length()); // 4
trace(xml.children()[0].toXMLString()); // &lt;bar>44&lt;/bar>
trace(xml.children()[1].toXMLString()); // text
trace(xml.children()[2].toXMLString()); // &lt;!-- comment -->
trace(xml.children()[3].toXMLString()); // &lt;?instruction ?>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:comments"><apiName>comments</apiName><shortdesc>
	Listet die Eigenschaften des XML-Objekts auf, die XML-Kommentare enthalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt der Eigenschaften, die Kommentare enthalten.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Listet die Eigenschaften des XML-Objekts auf, die XML-Kommentare enthalten.
	
	</apiDesc><example conref="examples\XML.comments.1.as"> Im folgenden Beispiel wird veranschaulicht, wie Sie die <codeph>comments()</codeph>-Methode verwenden:
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;foo>
            &lt;!-- example -->
            &lt;!-- example2 -->
        &lt;/foo>;
trace(xml.comments().length()); // 2
trace(xml.comments()[1].toXMLString()); // &lt;!-- example2 -->
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:contains"><apiName>contains</apiName><shortdesc>
	Vergleicht das XML-Objekt mit dem angegebenen value-Parameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Wenn das XML-Objekt mit dem Parameter <codeph>value</codeph> übereinstimmt, lautet der Wert <codeph>true</codeph>; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Ein mit dem aktuellen XML-Objekt zu vergleichender Wert.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vergleicht das XML-Objekt mit dem angegebenen <codeph>value</codeph>-Parameter. 
	
	</apiDesc><example conref="examples\XML.contains.1.as"> Im folgenden Beispiel wird veranschaulicht, wie Sie die <codeph>contains()</codeph>-Methode verwenden:
<codeblock>
var xml:XML = 
        &lt;order>
            &lt;item>Rice&lt;/item>
            &lt;item>Kung Pao Shrimp&lt;/item>
        &lt;/order>;
trace(xml.item[0].contains(&lt;item>Rice&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>Kung Pao Shrimp&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>MSG&lt;/item>)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:copy"><apiName>copy</apiName><shortdesc>
	Gibt eine Kopie des gegebenen XML-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Kopie des Objekts.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie des gegebenen XML-Objekts zurück. Die Kopie ist ein Duplikat der gesamten Knotenbaumstruktur. Das kopierte XML-Objekt hat kein übergeordnetes Objekt und gibt den Wert <codeph>null</codeph> zurück, wenn Sie versuchen, die <codeph>parent()</codeph>-Methode aufzurufen.
    
	</apiDesc><example conref="examples\XML.copy.1.as"> Aus dem folgenden Beispiel geht hervor, dass die <codeph>copy()</codeph>-Methode eine neue Instanz eines XML-Objekts erstellt. Das Original bleibt unverändert, wenn Sie die Kopie bearbeiten:
<codeblock>
var xml1:XML = &lt;foo />;
var xml2:XML = xml1.copy();
xml2.appendChild(&lt;bar />);
trace(xml1.bar.length()); // 0
trace(xml2.bar.length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:defaultSettings"><apiName>defaultSettings</apiName><shortdesc>
	Gibt ein Objekt zurück, bei dem die folgenden Eigenschaften auf die Standardwerte gesetzt sind: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent und prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.defaultSettings, defaultSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Ein Objekt, dessen Eigenschaften auf die Standardwerte gesetzt sind.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt ein Objekt zurück, bei dem die folgenden Eigenschaften auf die Standardwerte gesetzt sind: <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> und <codeph>prettyPrinting</codeph>. Die Standardwerte lauten wie folgt:
	
	<ul>
	   <li><codeph>ignoreComments = true</codeph></li>
	   <li><codeph>ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>ignoreWhitespace = true</codeph></li>
	 <li><codeph>prettyIndent = 2</codeph></li>
	   <li><codeph>prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>Hinweis:</b> Sie wenden diese Methode nicht auf eine Instanz der XML-Klasse an, sondern, wie im folgenden Code gezeigt, auf <codeph>XML</codeph>: <codeph>var df:Object = XML.defaultSettings()</codeph> . </p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> Das folgende Beispiel veranschaulicht: wie Sie benutzerdefinierte Einstellungen (um Kommentare und Verarbeitungsanweisungen einzuschließen) anwenden, bevor Sie ein XML-Objekt einrichten; wie Sie dann die Standardeinstellungen wiederherstellen, bevor Sie ein weiteres XML-Objekt einrichten; und wie Sie dann wieder die benutzerdefinierte Einstellungen einrichten (um weitere XML-Objekte einzurichten):
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link><link href="#XML/settings()"><linktext>XML.settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	Gibt alle untergeordneten Elemente (direkt untergeordnete und über mehrere Zweige hinweg untergeordnete Knoten) des XML-Objekts zurück, die dem gegebenen name-Parameter entsprechen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit den übereinstimmenden untergeordneten Elementen. Wenn es keine untergeordneten Elemente gibt, wird ein leeres XMLList-Objekt zurückgegeben.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Der Name des zu vergleichenden Elements.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Gibt alle untergeordneten Elemente (direkt untergeordnete und über mehrere Zweige hinweg untergeordnete Knoten) des XML-Objekts zurück, die dem gegebenen <codeph>name</codeph>-Parameter entsprechen. Der Parameter <codeph>name</codeph> ist optional. Der <codeph>name</codeph>-Parameter kann ein QName-Objekt sein, ein Objekt des Datentyps String oder jeglichen sonstigen Datentyps, der sich in einen String konvertieren lässt.
	
	<p>Um alle untergeordneten Elemente zurückzugeben, verwenden Sie den Sternparameter (~~). Wird kein Parameter übergeben, wird der String "~~" übergeben, sodass alle untergeordneten Elemente des XML-Objekts zurückgegeben werden.</p>
	
	</apiDesc><example conref="examples\XMLDescendantsExample1.as"> Um untergeordneten Elemente mit Namen zurückzugeben, die in ActionScript reservierten Worten entsprechen, verwenden Sie im XML-Code die <codeph>descendants()</codeph>-Methode anstelle des untergeordneten Elements (..). Dies wird in dem folgenden Beispiel veranschaulicht: 
<codeblock>
var xml:XML = 
  &lt;enrollees>
    &lt;student id="239">
        &lt;class name="Algebra" />
        &lt;class name="Spanish 2"/>
    &lt;/student>
    &lt;student id="206">
        &lt;class name="Trigonometry" />
        &lt;class name="Spanish 2" />
    &lt;/student>
  &lt;/enrollees>
trace(xml.descendants("class")); 
</codeblock></example><example conref="examples\XML.descendants.1.as"> Im folgenden Beispiel wird veranschaulicht, dass die <codeph>descendants()</codeph>-Methode ein XMLList-Objekt zurückgibt, das <i>alle</i> untergeordneten Elemente enthält (auch über mehrere Unterordnungsstufen hinweg) usw.:
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;body>
            &lt;!-- comment -->
            text1
            &lt;a>
                &lt;b>text2&lt;/b>
            &lt;/a>
        &lt;/body>;
trace(xml.descendants("*").length()); // 5
trace(xml.descendants("*")[0]); // // &lt;!-- comment -->
trace(xml.descendants("*")[1].toXMLString()); // text1
trace(xml.descendants("a").toXMLString()); // &lt;a>&lt;b>text2&lt;/b>&lt;/a>
trace(xml.descendants("b").toXMLString()); // &lt;b>text2&lt;/b>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#descendant_accessor"><linktext>Accessor für untergeordnete Elemente (..) Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:elements"><apiName>elements</apiName><shortdesc>
	 Listet die Elemente eines XML-Objekts auf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.elements, elements
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XMLList-Objekt mit dem Inhalt des Elements. Der Inhalt des Elements liegt zwischen dem Start- und dem End-Tag. Wenn Sie das Sternchen (~~) verwenden, um alle Elemente aufzurufen, werden sowohl die Tags als auch der Inhalt des Elements zurückgegeben.
	 
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Der Name des Elements. Der Name eines Elements ist in spitze Klammern eingeschlossen. So ist im folgenden Beispiel "<codeph>first</codeph>" der Name (<codeph>name</codeph>): <codeph>&lt;first>&lt;/first></codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Listet die Elemente eines XML-Objekts auf. Ein Element besteht aus einem Start- und End-Tag, z. B. <codeph>&lt;first>&lt;/first></codeph>. Der Parameter <codeph>name</codeph> ist optional. Der <codeph>name</codeph>-Parameter kann ein QName-Objekt sein, ein Objekt des Datentyps String oder jeglichen sonstigen Datentyps, der sich in einen String konvertieren lässt. Verwenden Sie den Parameter <codeph>name</codeph>, um ein bestimmtes Element aufzulisten. Im folgenden Beispiel gibt das Element "<codeph>first</codeph>" beispielsweise "<codeph>John</codeph>" zurück: <codeph>&lt;first>John&lt;/first></codeph>. 
	 
	 <p>Um alle Element zurückzugeben, verwenden Sie das Sternchen (~~) als Parameter. Das Sternchen ist auch der Standardparameter. </p>
	 
	 <p>Verwenden Sie die Methode <codeph>length()</codeph> mit dem Sternparameter (~~), um die Gesamtanzahl der Elemente auszugeben. Beispielsweise <codeph>numElement = addressbook.elements("~~").length()</codeph>.</p>
	 
	 </apiDesc><example conref="examples\XML.elements.1.as"> Im folgenden Beispiel wird veranschaulicht, dass die <codeph>elements()</codeph>-Methode nur eine Liste mit Elementen zurückgibt; sie enthält keinen Kommentare, Texteigenschaften oder Verarbeitungsanweisungen:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
            text
            &lt;a>1&lt;/a>
            &lt;b>2&lt;/b>
        &lt;/foo>;
trace(xml.elements("*").length()); // 2
trace(xml.elements("*")[0].toXMLString()); // &lt;a>1&lt;/a>
trace(xml.elements("b").length()); // 1
trace(xml.elements("b")[0].toXMLString()); // &lt;b>2&lt;/b>
</codeblock></example><example conref="examples\XMLElementsExample1.as"> Um Elemente mit Namen zurückzugeben, die in ActionScript reservierten Worten entsprechen, verwenden Sie im XML-Code die Methode <codeph>elements()</codeph> anstelle des XML-Punkt-Operators (.). Dies wird in dem folgenden Beispiel veranschaulicht:
<codeblock>
var xml:XML =
 &lt;student id="206">
    &lt;class name="Trigonometry" />
    &lt;class name="Spanish 2" />
 &lt;/student>
trace(xml.elements("class")); 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XMLList"><linktext>XMLList-Klasse</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="operators.html#dot_(XML)"><linktext>XML-Punkt (.) Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	Prüft, ob das XML-Objekt komplexen Inhalt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>true</codeph>, wenn das XML-Objekt einen komplexen Inhalt hat; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Prüft, ob das XML-Objekt komplexen Inhalt enthält. Ein XML-Objekt enthält komplexen Inhalt, wenn es untergeordnete Elemente besitzt. XML-Objekte, die Attribute, Kommentare, Verarbeitungsanweisungen oder Textknoten repräsentieren, haben keinen komplexen Inhalt. Doch auch ein Objekt, das diese Knoten <i>enthält</i>, kann komplexen Inhalt haben (nämlich wenn es zudem untergeordnete Elemente besitzt).
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> Im folgenden Beispiel sehen Sie ein XML-Objekt mit einer Eigenschaft namens <codeph>a</codeph> und einfachem Inhalt sowie eine Eigenschaft namens <codeph>a</codeph> und komplexem Inhalt:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	Überprüft, ob die Eigenschaft des Objekts vom Parameter „p“ angegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>true</codeph>, wenn die Eigenschaft vorhanden ist; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die zu vergleichende Eigenschaft.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Überprüft, ob die Eigenschaft des Objekts vom Parameter <codeph>p</codeph> angegeben wird. 
	
	</apiDesc><example conref="examples\XML.hasOwnProperty.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>hasOwnProperty()</codeph>-Methode sichergestellt, dass eine Eigenschaft (<codeph>b</codeph>) vorhanden ist, bevor ein Ausdruck (<codeph>b == "11"</codeph>) der diese Eigenschaft verwendet, bewertet wird:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a />
            &lt;a>
                &lt;b>10&lt;/b>
            &lt;/a>
            &lt;a>
                &lt;b>11&lt;/b>
            &lt;/a>
        &lt;/foo>;
trace(xml.a.(hasOwnProperty("b") &amp;&amp; b == "11")); 
</codeblock> Von Flash Player würde eine Ausnahme ausgelöst werden, wenn die letzte Zeile in diesem Beispiel wie folgt lauten würde, da das erste Element mit dem Namen <codeph>a</codeph> keine Eigenschaft mit dem Namen <codeph>b</codeph> aufweist:
 <p>
 <pre>trace(xml.a.(b == "11"));</pre>
 </p>
</example><example conref="examples\XML.hasOwnProperty.2.as"> Im folgenden Beispiel wird mithilfe der <codeph>hasOwnProperty()</codeph>-Methode sichergestellt, dass eine Eigenschaft (<codeph>item</codeph>) vorhanden ist, bevor ein Ausdruck (<codeph>item.contains("toothbrush")</codeph>) der diese Eigenschaft verwendet, bewertet wird:
<codeblock>
var xml:XML = 
        &lt;orders>
            &lt;order id='1'>
                &lt;item>toothbrush&lt;/item>
                &lt;item>toothpaste&lt;/item>
            &lt;/order>
            &lt;order>
                &lt;returnItem>shoe polish&lt;/returnItem>
            &lt;/order>
        &lt;/orders>;
trace(xml.order.(hasOwnProperty("item") &amp;&amp; item.contains("toothbrush"))); 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	Prüft, ob das XML-Objekt komplexen Inhalt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>true</codeph>, wenn das XML-Objekt einen einfachen Inhalt hat; andernfalls <codeph>false</codeph>.
	
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Prüft, ob das XML-Objekt komplexen Inhalt enthält. Ein XML-Objekt enthält einfachen Inhalt, wenn es einen Textknoten, einen Attributknoten oder ein XML-Element ohne untergeordnete Elemente enthält. XML-Objekte, die Kommentare und Verarbeitungsanweisungen repräsentieren, enthalten <i>keinen</i> einfachen Inhalt.
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> Im folgenden Beispiel sehen Sie ein XML-Objekt mit einer Eigenschaft namens <codeph>a</codeph> und einfachem Inhalt sowie eine Eigenschaft namens <codeph>a</codeph> und komplexem Inhalt:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:inScopeNamespaces"><apiName>inScopeNamespaces</apiName><shortdesc>
	Listet, basierend auf dem übergeordneten Objekt, die Namespaces für das XML-Objekt auf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.inScopeNamespaces, inScopeNamespaces
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Array an Namespace-Objekten. 
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Listet, basierend auf dem übergeordneten Objekt, die Namespaces für das XML-Objekt auf. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:insertChildAfter"><apiName>insertChildAfter</apiName><shortdesc>
	Fügt den gegebenen „child2“-Parameter nach dem „child1“-Parameter in dieses XML-Objekt ein, und gibt das resultierende Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildAfter, insertChildAfter
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das resultierende XML-Objekt oder <codeph>undefined</codeph>.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das Objekt in dem Quellobjekt, das Sie vor <codeph>child2</codeph> einfügen.
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das einzufügende Objekt.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Fügt den gegebenen <codeph>child2</codeph>-Parameter nach dem <codeph>child1</codeph>-Parameter in dieses XML-Objekt ein, und gibt das resultierende Objekt zurück. Hat der Parameter <codeph>child1</codeph> den Wert <codeph>null</codeph>, fügt die Methode den Inhalt des Parameters <codeph>child2</codeph> <i>vor</i> allen untergeordneten Knoten des XML-Objekts ein (oder anders ausgedrückt: nach <i>none</i>). Hat <codeph>child1</codeph> jedoch einen Wert, existiert aber nicht im XML-Objekt, wird das XML-Objekt nicht geändert und es wird <codeph>undefined</codeph> zurückgegeben.
	
	<p>Wenn Sie diese Methode für einen untergeordneten XML-Knoten aufrufen, der kein Element ist (sondern Text, Attribut, Kommentar oder Verarbeitungsanweisung), so wird <codeph>undefined</codeph> zurückgegeben.</p>
    
    <p>Verwenden Sie den Operator <codeph>delete</codeph>, um den XML-Knoten zu entfernen.</p>
	
	</apiDesc><example conref="examples\XML.insertChildAfter.1.as"> In diesem Beispiel wird am Ende der child-Elemente eines XML-Objekts ein Element angehängt:
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildAfter(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> Die <codeph>trace()</codeph>-Ausgabe lautet wie folgt:
 <pre><codeph> &lt;menu>
     &lt;item>burger&lt;/item>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>soda&lt;/item>
 &lt;/menu></codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildBefore()"><linktext>XML.insertChildBefore()</linktext></link><link href="operators.html#delete_(XML)"><linktext>delete-(XML)-Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:insertChildBefore"><apiName>insertChildBefore</apiName><shortdesc>
	Fügt den gegebenen „child2“-Parameter vor dem „child1“-Parameter in dieses XML-Objekt ein und gibt das resultierende Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildBefore, insertChildBefore
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das resultierende XML-Objekt oder <codeph>undefined</codeph>.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das Objekt in dem Quellobjekt, das Sie nach <codeph>child2</codeph> einfügen.
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das einzufügende Objekt.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Fügt den gegebenen <codeph>child2</codeph>-Parameter vor dem <codeph>child1</codeph>-Parameter in dieses XML-Objekt ein und gibt das resultierende Objekt zurück. Hat der Parameter <codeph>child1</codeph> den Wert <codeph>null</codeph>, fügt die Methode den Inhalt des Parameters <codeph>child2</codeph> <i>nach</i> allen untergeordneten Knoten des XML-Objekts ein (oder anders ausgedrückt: vor <i>none</i>). Hat <codeph>child1</codeph> jedoch einen Wert, existiert aber nicht im XML-Objekt, wird das XML-Objekt nicht geändert und es wird <codeph>undefined</codeph> zurückgegeben.
	
	<p>Wenn Sie diese Methode für einen untergeordneten XML-Knoten aufrufen, der kein Element ist (sondern Text, Attribut, Kommentar oder Verarbeitungsanweisung), so wird <codeph>undefined</codeph> zurückgegeben.</p>
    
    <p>Verwenden Sie den Operator <codeph>delete</codeph>, um den XML-Knoten zu entfernen.</p>
	
	</apiDesc><example conref="examples\XML.insertChildBefore.1.as"> In diesem Beispiel wird am Ende der child-Elemente eines XML-Objekts ein Element angehängt:
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildBefore(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> Die <codeph>trace()</codeph>-Ausgabe lautet wie folgt:
 <pre>
 &lt;menu>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>burger&lt;/item>
     &lt;item>soda&lt;/item>
 &lt;/menu></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildAfter()"><linktext>XML.insertChildAfter()</linktext></link><link href="operators.html#delete_(XML)"><linktext>delete-(XML)-Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:length"><apiName>length</apiName><shortdesc>
	Für XML-Objekte gibt diese Methode immer die Ganzzahl 1 zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Gibt für XML-Objekte immer den Wert <codeph>1</codeph> zurück.
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Für XML-Objekte gibt diese Methode immer die Ganzzahl <codeph>1</codeph> zurück. Die <codeph>length()</codeph>-Methode der XMLList-Klasse gibt für ein XMLList-Objekt, das nur einen Wert enthält, den Wert <codeph>1</codeph> zurück.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:localName"><apiName>localName</apiName><shortdesc>
	Gibt den Lokalteil des qualifizierten Namens des XML-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.localName, localName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Lokalteil des Namens ist entweder ein String oder <codeph>null</codeph>.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt den Lokalteil des qualifizierten Namens des XML-Objekts zurück.
	
	</apiDesc><example conref="examples\XML.localName.1.as"> Das folgende Beispiel veranschaulicht, wie Sie die <codeph>localName()</codeph>-Methode verwenden:
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.localName()); // Envelope
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:name"><apiName>name</apiName><shortdesc>
	Gibt den qualifizierten Namen des XML-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.name, name
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der qualifizierte Namen ist entweder ein Qname oder <codeph>null</codeph>.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt den qualifizierten Namen des XML-Objekts zurück. 
	
	</apiDesc><example conref="examples\XML.name.1.as"> Das folgende Beispiel veranschaulicht, wie Sie mit der <codeph>name()</codeph>-Methode den qualifizierten Namen eines XML-Objekts abrufen:
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.name().localName); // Envelope
trace(xml.name().uri); // "http://www.w3.org/2001/12/soap-envelope"
</codeblock></example><example conref="examples\XML.name.2.as"> Das folgende Beispiel veranschaulicht, wie Sie die <codeph>name()</codeph>-Methode für eine XML-Eigenschaft, ein Textelement und ein Attribut aufrufen:
<codeblock>
var xml:XML = 
        &lt;foo x="15" y="22">
            text
        &lt;/foo>;
        
trace(xml.name().localName); // foo
trace(xml.name().uri == ""); // true
trace(xml.children()[0]); // text
trace(xml.children()[0].name()); // null
trace(xml.attributes()[0]); // 15
trace(xml.attributes()[0].name()); // x
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="operators.html#attribute_identifier"><linktext>Attributbezeichner</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:namespace"><apiName>namespace</apiName><shortdesc>
	Wenn kein Parameter angegeben wird, gibt diese Methode den mit dem qualifizierten Namen dieses XML-Objekts verbundenen Namespace zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespace, namespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Gibt <codeph>null</codeph>, <codeph>undefined</codeph> oder einen Namespace zurück.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>prefix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Präfix, das übereinstimmen soll.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Wenn kein Parameter angegeben wird, gibt diese Methode den mit dem qualifizierten Namen dieses XML-Objekts verbundenen Namespace zurück. Wird ein <codeph>prefix</codeph>-Parameter angegeben, gibt die Methode den Namespace zurück, der dem <codeph>prefix</codeph>-Parameter entspricht und sich im Gültigkeitsbereich des XML-Objekts befindet. Gibt es keinen solchen Namespace, gibt die Methode den Wert <codeph>undefined</codeph> zurück.
	
	</apiDesc><example conref="examples\XML.namespace.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>namespace()</codeph>-Methode der Namespace eines XML-Objekts abgerufen und einem Namespace-Objekt namens <codeph>soap</codeph> zugewiesen, mit dem dann eine Eigenschaft des <codeph>xml</codeph>-Objekts identifiziert wird (<codeph>xml.soap::Body[0]</codeph>):
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
var soap:Namespace = xml.namespace();
trace(soap.prefix); // soap
trace(soap.uri); // http://www.w3.org/2001/12/soap-envelope

var body:XML = xml.soap::Body[0];
trace(body.namespace().prefix); // soap
trace(xml.namespace().uri); // http://www.w3.org/2001/12/soap-envelope
trace(body.namespace("wx").uri); // "http://example.com/weather"
</codeblock></example><example conref="examples\XML.namespace.2.as"> Im folgenden Beispiel wird mithilfe der <codeph>namespace()</codeph>-Methode zum einen der Standard-Namespace für einen Knoten abgerufen sowie der Namespace für ein bestimmtes Präfix (<codeph>"dc"</codeph>):
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">
                &lt;!-- ... -->
        &lt;/rdf:RDF>;
                    
trace(xml.namespace()); // http://www.w3.org/1999/02/22-rdf-syntax-ns#
trace(xml.namespace("dc")); // http://purl.org/dc/elements/1.1/
trace(xml.namespace("foo")); // undefined
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:namespaceDeclarations"><apiName>namespaceDeclarations</apiName><shortdesc>
	Listet Namespace-Deklarationen auf, die mit dem XML-Objekt im Kontext des übergeordneten Knotens verbunden wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespaceDeclarations, namespaceDeclarations
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Array an Namespace-Objekten.
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Listet Namespace-Deklarationen auf, die mit dem XML-Objekt im Kontext des übergeordneten Knotens verbunden wurden. 
	
	</apiDesc><example conref="examples\XML.namespaceDeclarations.1.as"> Im folgenden Beispiel werden die Namespace-Deklarationen eines XML-Objekts ausgegeben:
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">

            &lt;!-- ... -->
            
        &lt;/rdf:RDF>;
                    
for (var i:uint = 0; i &lt; xml.namespaceDeclarations().length; i++) {
    var ns:Namespace = xml.namespaceDeclarations()[i]; 
    var prefix:String = ns.prefix;
    if (prefix == "") {
        prefix = "(default)";
    }
    trace(prefix + ":" , ns.uri);
}
</codeblock> Die <codeph>trace()</codeph>-Ausgabe lautet wie folgt:
 <pre><codeph>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
 dc: http://purl.org/dc/elements/1.1/
 (default): http://purl.org/rss/1.0/</codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/namespace()"><linktext>XML.namespace()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:nodeKind"><apiName>nodeKind</apiName><shortdesc>
	Gibt den Typ des Knotens an: Text-, Kommentar-, Verarbeitungsanweisungs-, Attribut- oder Elementknoten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.nodeKind, nodeKind
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der verwendete Knotentyp.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt den Typ des Knotens an: Text-, Kommentar-, Verarbeitungsanweisungs-, Attribut- oder Elementknoten. 
	
	</apiDesc><example conref="examples\XMLNodeKindExample1.as"> Im folgenden Beispiel werden alle 5 Knotentypen verfolgt:
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;

var xml:XML = 
    &lt;example id="10">
        &lt;!-- this is a comment -->
        &lt;?test this is a pi ?>
        and some text
    &lt;/example>;

trace(xml.nodeKind()); // element
trace(xml.children()[0].nodeKind()); // comment
trace(xml.children()[1].nodeKind()); // processing-instruction
trace(xml.children()[2].nodeKind()); // text
trace(xml.@id[0].nodeKind()); // attribute
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#attribute_identifier"><linktext>Attributbezeichner</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	Für das XML-Objekt und alle seine untergeordneten Elemente werden benachbarte Textknoten zusammengeführt und leere Textknoten entfernt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das resultierende normalisierte XML-Objekt.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Für das XML-Objekt und alle seine untergeordneten Elemente werden benachbarte Textknoten zusammengeführt und leere Textknoten entfernt.
	
	</apiDesc><example conref="examples\XML.normalize.1.as"> Im folgenden Beispiel wird veranschaulicht, wie sich das Aufrufen der <codeph>normalize()</codeph>-Methode auswirkt:
<codeblock>
var xml:XML = &lt;body>&lt;/body>;
xml.appendChild("hello");
xml.appendChild(" world");
trace(xml.children().length()); // 2
xml.normalize();
trace(xml.children().length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:parent"><apiName>parent</apiName><shortdesc>
	Gibt den übergeordneten Knoten des XML-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein XML-Verweis auf den übergeordneten Knoten oder <codeph>undefinded</codeph>, wenn das XML-Objekt kein übergeordnetes Objekt hat.
	
	</apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	Gibt den übergeordneten Knoten des XML-Objekts zurück. Besitzt das XML-Objekt keinen übergeordneten Knoten, gibt die Methode den Wert <codeph>undefined</codeph> zurück.
	
	</apiDesc><example conref="examples\XML.parent.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>parent()</codeph>-Methode das übergeordnete Element eines bestimmten Elements in einer XML-Struktur identifiziert:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p id="p1">Hello&lt;/p>
        &lt;p id="p2">Test:
            &lt;ul>
                &lt;li>1&lt;/li>
                &lt;li>2&lt;/li>
            &lt;/ul>
        &lt;/p>
    &lt;/body>;
var node:XML = xml.p.ul.(li.contains("1"))[0]; // == &lt;ul> ... &lt;/ul>
trace(node.parent().@id); // p2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:prependChild"><apiName>prependChild</apiName><shortdesc>
	Fügt eine Kopie des bereitgestellten child-Objekts vor irgendwelchen vorhandenen XML-Eigenschaften für dieses Element in das XML-Element ein.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prependChild, prependChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das resultierende XML-Objekt.
    
    </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das einzufügende Objekt.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Fügt eine Kopie des bereitgestellten <codeph>child</codeph>-Objekts vor irgendwelchen vorhandenen XML-Eigenschaften für dieses Element in das XML-Element ein.
    
    <p>Verwenden Sie den Operator <codeph>delete</codeph>, um den XML-Knoten zu entfernen.</p> 
	
	</apiDesc><example conref="examples\XML.prependChild.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>prependChild()</codeph>-Methode am Anfang der child-Liste eines XML-Objekts ein neues Element hinzugefügt:
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.prependChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>world&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>delete-(XML)-Operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	Wird ein name-Parameter bereitgestellt, werden alle untergeordneten Knoten des XML-Objekts aufgelistet, die Verarbeitungsanweisungen mit diesem Namen enthalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Liste an passenden untergeordneten Objekten.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>Der Name der gesuchten Verarbeitungsanweisung.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Wird ein <codeph>name</codeph>-Parameter bereitgestellt, werden alle untergeordneten Knoten des XML-Objekts aufgelistet, die Verarbeitungsanweisungen mit diesem Namen (<codeph>name</codeph>) enthalten. Ohne Parameter listet diese Methode alle untergeordneten Knoten des XML-Objekts auf, die irgendwelche Verarbeitungsanweisungen enthalten.
	
	</apiDesc><example conref="examples\XML.processingInstructions.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>processingInstructions()</codeph>-Methode ein Array mit Verarbeitungsanweisungen für ein XML-Objekt abgerufen:
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml:XML =
    &lt;body>
            foo
            &lt;?xml-stylesheet href="headlines.css" type="text/css" ?>
            &lt;?instructionX ?>
            
    &lt;/body>;

trace(xml.processingInstructions().length()); // 2
trace(xml.processingInstructions()[0].name()); // xml-stylesheet
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	Prüft, ob sich die Eigenschaft p in dem Satz an Eigenschaften befindet, die in einer auf das XMLList-Objekt angewendeten for..in-Anweisung durchlaufen werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Wenn die Eigenschaft in einer <codeph>for..in</codeph>-Anweisung durchlaufen werden kann, lautet der Wert <codeph>true</codeph>; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Eigenschaft, die überprüft werden soll.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Prüft, ob sich die Eigenschaft <codeph>p</codeph> in dem Satz an Eigenschaften befindet, die in einer auf das XML-Objekt angewendeten <codeph>for..in</codeph>-Anweisung durchlaufen werden können. Gibt nur <codeph>true</codeph> zurück, wenn <codeph>toString(p) == "0"</codeph>. 
	
	</apiDesc><example conref="examples\XML.propertyIsEnumerable.1.as"> Im folgenden Beispiel wird veranschaulicht, dass die <codeph>propertyNameIsEnumerable()</codeph>-Methode für ein XML-Objekt den Wert <codeph>true</codeph> nur für den Wert <codeph>0</codeph> zurückgibt; dagegen lautet bei einem XMLList-Objekt der Rückgabewert <codeph>true</codeph> für jeden gültigen Indexwert des XMLList-Objekts:
<codeblock>
var xml:XML = 
        &lt;body>
             &lt;p>Hello&lt;/p>
               &lt;p>World&lt;/p>
        &lt;/body>;

trace(xml.propertyIsEnumerable(0)); // true
trace(xml.propertyIsEnumerable(1)); // false

for (var propertyName:String in xml) {
    trace(xml[propertyName]);
}

var list:XMLList = xml.p;
trace(list.propertyIsEnumerable(0)); // true
trace(list.propertyIsEnumerable(1)); // true
trace(list.propertyIsEnumerable(2)); // false

for (var propertyName:String in list) { 
    trace(list[propertyName]);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:removeNamespace"><apiName>removeNamespace</apiName><shortdesc>
	Entfernt den gegebenen Namespace für dieses Objekt und alle untergeordneten Elemente.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.removeNamespace, removeNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine Kopie des resultierenden XML-Objekts.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Der zu entfernende Namespace.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Entfernt den gegebenen Namespace für dieses Objekt und alle untergeordneten Elemente. Die <codeph>removeNamespaces()</codeph>-Methode entfernt keinen Namespace, wenn vom qualifizierten Namen des Objekts darauf verwiesen wird oder vom qualifizierten Namen des Objektattributs.
	
	</apiDesc><example conref="examples\XML.removeNamespace.1.as"> Das folgende Beispiel veranschaulicht, wie Sie eine Namespace-Deklaration aus einem XML-Objekt entfernen:
<codeblock>
var xml:XML = 
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
        xmlns:dc="http://purl.org/dc/elements/1.1/" 
        xmlns="http://purl.org/rss/1.0/">
    
        &lt;!-- ... -->
        
    &lt;/rdf:RDF>;

trace(xml.namespaceDeclarations().length); // 3
trace(xml.namespaceDeclarations()[0] is String); // 
var dc:Namespace = xml.namespace("dc");
xml.removeNamespace(dc);
trace(xml.namespaceDeclarations().length); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:replace"><apiName>replace</apiName><shortdesc>
	Ersetzt die im Parameter propertyName angegebenen Eigenschaften durch den gegebenen value-Parameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.replace, replace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das resultierende XML-Objekt, in dem die übereinstimmenden Eigenschaften ersetzt worden sind.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Kann ein numerischer Wert sein, ein nicht qualifizierter Name für ein Set an XML-Elementen, ein qualifizierter Name für ein Set an XML-Elementen oder der Sternchenplatzhalter („*“). Einen nicht qualifizierten Namen verwenden Sie, um XML-Elemente im Standard-Namespace zu identifizieren. 
	
	</apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Der Ersetzungswert. Das kann ein XML-Objekt sein, ein XMLList-Objekt oder jeder beliebige Wert, der mit <codeph>toString()</codeph> umgewandelt werden kann. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ersetzt die im Parameter <codeph>propertyName</codeph> angegebenen Eigenschaften durch den gegebenen <codeph>value</codeph>-Parameter. Werden keine Eigenschaften gefunden, die mit <codeph>propertyName</codeph> übereinstimmen, bleibt das XML-Objekt unverändert.
	
	</apiDesc><example conref="examples\XML.replace.1.as"> Im folgenden Beispiel wird die <codeph>replace()</codeph>-Methode mit einer Ganzzahl als erstem Parameter aufgerufen:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace(1, &lt;p>Bob&lt;/p>);
trace(xml);
</codeblock> Der Code ergibt die folgende <codeph>trace()</codeph>-Ausgabe:
 <pre><codeph>
 &lt;body>
     &lt;p>Hello&lt;/p>
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/body>
 </codeph></pre>
</example><example conref="examples\XML.replace.2.as"> Im folgenden Beispiel wird die <codeph>replace()</codeph>-Methode mit einem String als erstem Parameter aufgerufen:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("p", &lt;p>Hi&lt;/p>); 
trace(xml);
</codeblock> Der Code ergibt die folgende <codeph>trace()</codeph>-Ausgabe:
 
 <pre><codeph>
 &lt;body>
     &lt;p>Hi&lt;/p>
     &lt;hr/>
 &lt;/body>;
 </codeph></pre>
</example><example conref="examples\XML.replace.3.as"> Im folgenden Beispiel wird die <codeph>replace()</codeph>-Methode mit einem „QName“ als erstem Parameter aufgerufen:
<codeblock>
var xml:XML = 
    &lt;ns:body xmlns:ns = "myNS">
        &lt;ns:p>Hello&lt;/ns:p>
        &lt;ns:p>World&lt;/ns:p>
        &lt;hr/>
    &lt;/ns:body>;

var qname:QName = new QName("myNS", "p");
xml.replace(qname, &lt;p>Bob&lt;/p>);
trace(xml);

</codeblock> Der Code ergibt die folgende <codeph>trace()</codeph>-Ausgabe:
 
 <pre><codeph>
 &lt;ns:body xmlns:ns = "myNS">
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/ns:body>
 </codeph></pre>
</example><example conref="examples\XML.replace.4.as"> Im folgenden Beispiel wird die <codeph>replace()</codeph>-Methode zusammen mit dem String <codeph>"*"</codeph> als erstem Parameter aufgerufen:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("*", &lt;img src = "hello.jpg"/>);
trace(xml);
</codeblock> Der Code ergibt die folgende <codeph>trace()</codeph>-Ausgabe:
 
 <pre><codeph>
 &lt;body>
     &lt;img src="hello.jpg"/>
 &lt;/body>
 </codeph></pre>
</example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setChildren"><apiName>setChildren</apiName><shortdesc>
	Ersetzt die untergeordneten Eigenschaften des XML-Objekts durch das angegebene Set an XML-Eigenschaften, das im Parameter value bereitgestellt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setChildren, setChildren
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Das resultierende XML-Objekt. 
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Die zu ersetzenden XML-Eigenschaften. Dabei kann es sich um ein einzelnes XML-Objekt handeln oder um ein XMLList-Objekt. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ersetzt die untergeordneten Eigenschaften des XML-Objekts durch das angegebene Set an XML-Eigenschaften, das im Parameter <codeph>value</codeph> bereitgestellt wird.
	
	</apiDesc><example conref="examples\XML.setChildren.1.as"> Im folgenden Beispiel wird das Aufrufen der <codeph>setChildren()</codeph>-Methode veranschaulicht, und zwar zuerst mit einem XML-Objekt als Parameter und dann mit einem XMLList-Objekt als Parameter:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
    &lt;/body>;

var list:XMLList = xml.p;

xml.setChildren(&lt;p>hello&lt;/p>);
trace(xml);

//    &lt;body>
//        &lt;p>hello&lt;/p>
//    &lt;/body>

xml.setChildren(list);
trace(xml);

//    &lt;body>
//        &lt;p>Hello&lt;/p>
//        &lt;p>World&lt;/p>
//    &lt;/body>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setLocalName"><apiName>setLocalName</apiName><shortdesc>
	Ändert den Lokalteil des XML-Objektnamens in den gegebenen name-Parameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setLocalName, setLocalName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der im Lokalteil zu ersetzende Name.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ändert den Lokalteil des XML-Objektnamens in den gegebenen <codeph>name</codeph>-Parameter. 
	
	</apiDesc><example conref="examples\XML.setLocalName.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>setLocalName()</codeph>-Methode der lokale Name eines XML-Elements geändert:
<codeblock>
var xml:XML = 
    &lt;ns:item xmlns:ns="http://example.com">
        toothbrush
    &lt;/ns:item>;
    
xml.setLocalName("orderItem");
trace(xml.toXMLString()); // &lt;ns:orderItem xmlns:ns="http://example.com">toothbrush&lt;/ns:orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setName"><apiName>setName</apiName><shortdesc>
	Setzt den Namen des XML-Objekts auf den gegebenen qualifizierten Namen oder Attributnamen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setName, setName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der neue Name für das Objekt.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Setzt den Namen des XML-Objekts auf den gegebenen qualifizierten Namen oder Attributnamen. 
	
	</apiDesc><example conref="examples\XML.setName.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>setName()</codeph>-Methode der Name eines XML-Elements geändert:
<codeblock>
var xml:XML = 
    &lt;item>
        toothbrush
    &lt;/item>;
    
xml.setName("orderItem");
trace(xml.toXMLString()); // &lt;orderItem>toothbrush&lt;/orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setNamespace"><apiName>setNamespace</apiName><shortdesc>
	Setzt den mit dem XML-Objekt verbundenen Namespace.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setNamespace, setNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Der neue Namespace.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Setzt den mit dem XML-Objekt verbundenen Namespace.
	
	</apiDesc><example conref="examples\XML.setNamespace.1.as"> Im folgenden Beispiel wird der <codeph>soap</codeph>-Namespace, der in einem XML-Objekt definiert wurde, auf den Namespace eines anderen XML-Objekts angewendet (<codeph>xml2</codeph>):
<codeblock>
var xml1:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">
            &lt;!-- ... -->
        &lt;/soap:Envelope>;
var ns:Namespace = xml1.namespace("soap");

var xml2:XML = 
    &lt;Envelope>
        &lt;Body/>
    &lt;/Envelope>;
    
xml2.setNamespace(ns);

trace(xml2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setSettings"><apiName>setSettings</apiName><shortdesc>
	Setzt die Werte für die folgenden XML-Eigenschaften: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent und prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setSettings, setSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Ein Objekt mit jeder der folgenden Eigenschaften: 
	
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Setzt die Werte für die folgenden XML-Eigenschaften: <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> und <codeph>prettyPrinting</codeph>. Im folgenden sind die Standardeinstellungen aufgelistet, die anwendet werden, wenn kein <codeph>setObj</codeph>-Parameter bereitgestellt wird.
	
	<ul>
	   <li><codeph>XML.ignoreComments = true</codeph></li>
	   <li><codeph>XML.ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>XML.ignoreWhitespace = true</codeph></li>
	   <li><codeph>XML.prettyIndent = 2</codeph></li>
	   <li><codeph>XML.prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>Hinweis</b>: Sie wenden diese Methode nicht auf eine Instanz der XML-Klasse an, sondern auf <codeph>XML</codeph>, wie im folgenden Code gezeigt: <codeph>XML.setSettings()</codeph>.</p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> Das folgende Beispiel veranschaulicht: wie Sie benutzerdefinierte Einstellungen (um Kommentare und Verarbeitungsanweisungen einzuschließen) anwenden, bevor Sie ein XML-Objekt einrichten; wie Sie dann die Standardeinstellungen wiederherstellen, bevor Sie ein weiteres XML-Objekt einrichten; und wie Sie anschließend wieder die benutzerdefinierte Einstellungen einrichten (um weitere XML-Objekte einzurichten):
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>defaultSettings()</linktext></link><link href="#XML/settings()"><linktext>settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:settings"><apiName>settings</apiName><shortdesc>
	Ruft die folgenden Eigenschaften ab: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent und prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.settings, settings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Ein Objekt mit den folgenden XML-Eigenschaften:
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Ruft die folgenden Eigenschaften ab: <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> und <codeph>prettyPrinting</codeph>.
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> Das folgende Beispiel veranschaulicht: wie Sie benutzerdefinierte Einstellungen (um Kommentare und Verarbeitungsanweisungen einzuschließen) anwenden, bevor Sie ein XML-Objekt einrichten; wie Sie dann die Standardeinstellungen wiederherstellen, bevor Sie ein weiteres XML-Objekt einrichten; und wie Sie dann wieder die benutzerdefinierte Einstellungen einrichten (um weitere XML-Objekte einzurichten):
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>XML.defaultSettings()</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:text"><apiName>text</apiName><shortdesc>
	Gibt ein XMLList-Objekt zurück mit allen XML-Eigenschaften des XML-Objekts, die XML-Textknoten darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Liste der Eigenschaften.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt ein XMLList-Objekt zurück mit allen XML-Eigenschaften des XML-Objekts, die XML-Textknoten darstellen.
	
	</apiDesc><example conref="examples\XML.text.1.as"> Das folgende Beispiel veranschaulicht, wie Sie mit der <codeph>text()</codeph>-Methode die Textknoten eines XML-Objekts abgerufen:
<codeblock>
var xml:XML =
        &lt;body>
            text1
            &lt;hr/>
            text2
        &lt;/body>;
trace(xml.text()[0]); // text1
trace(xml.text()[1]); // text2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:toString"><apiName>toString</apiName><shortdesc>
	Gibt das XML-Objekt als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung des XML-Objekts.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt das XML-Objekt als String zurück. Nach welchen Regeln diese Konvertierung vollzogen wird, ist abhängig davon, ob das XML-Objekt einen einfachen oder komplexen Inhalt hat:
	
	<ul>
		<li>Hat das XML-Objekt einen einfachen Inhalt, gibt <codeph>toString()</codeph> den String-Inhalt des XML-Objekts zurück, wobei das Start-Tag, vorhandene Attribute, Namespace-Deklarationen und das Endtag entfernt werden.</li> 
	</ul>
	
	<ul>
		<li> Hat das XML-Objekt einen komplexen Inhalt, gibt <codeph>toString()</codeph> das gesamte XML-Objekt als XML-kodierten String zurück, einschließlich Start-Tag, Attributen, Namespace-Deklarationen und End-Tag.</li>
	</ul>
	
	<p>Damit jedes Mal das gesamte XML-Objekt zurückgegeben wird, verwenden Sie die Methode <codeph>toXMLString()</codeph>.</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> Im folgende Beispiel wird veranschaulicht, was die <codeph>toString()</codeph>-Methode zurückgibt, wenn das XML-Objekt einen einfachen Inhalt hat:
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> Im folgende Beispiel wird veranschaulicht, was die <codeph>toString()</codeph>-Methode zurückgibt, wenn das XML-Objekt einen komplexen Inhalt hat:
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	Gibt das XML-Objekt als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung des XML-Objekts.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt das XML-Objekt als String zurück. Im Gegensatz zur Methode <codeph>toString()</codeph> gibt die Methode <codeph>toXMLString()</codeph> immer das Start-Tag, vorhandene Attribute und das End-Tag des XML-Objekts zurück, unabhängig davon, ob das XML-Objekt einen einfachen oder komplexen Inhalt hat. (Die Methode <codeph>toString()</codeph> entfernt alle diese Elemente für XML-Objekte mit einfachem Inhalt.)
	
	</apiDesc><example conref="examples\XML.toXMLString.1.as"> Im folgenden Beispiel wird die unterschiedliche Wirkung der <codeph>toString()</codeph>-Methode (die standardmäßig auf alle Parameter einer <codeph>trace()</codeph>-Methode angewendet wird) und der <codeph>toXMLString()</codeph>-Methode veranschaulicht:
<codeblock>
var xml:XML =
        &lt;p>hello&lt;/p>;
trace(xml); // hello
trace(xml.toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/toString()"><linktext>XML.toString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	Gibt das XML-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Grundwert einer XML-Instanz.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt das XML-Objekt zurück. 
	
	</apiDesc><example conref="examples\XML.valueOf.1.as"> Im folgenden Beispiel wird veranschaulicht, dass der Rückgabewert der <codeph>valueOf()</codeph>-Methode identisch ist mit dem XML-Quellobjekt:
<codeblock>
var xml:XML = &lt;p>hello&lt;/p>;
trace(xml.valueOf() === xml); // true
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="XML:ignoreComments:get"><apiName>ignoreComments</apiName><shortdesc>
	Legt fest, ob XML-Kommentare ignoriert werden, wenn XML-Objekte die XML-Quelldaten analysieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreComments, ignoreComments
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Legt fest, ob XML-Kommentare ignoriert werden, wenn XML-Objekte die XML-Quelldaten analysieren. Standardmäßig werden Kommentare ignoriert (<codeph>true</codeph>). Um XML-Kommentare einzubeziehen, rufen Sie <codeph>false</codeph> auf. Die <codeph>ignoreComments</codeph>-Eigenschaft wird nur während der XML-Analyse verwendet, nicht etwa beim Aufruf von Methoden, wie <codeph>myXMLObject.child(~~).toXMLString()</codeph>. Enthält das XML-Quelldokument Kommentarknoten, werden sie während der XML-Analyse durch den Parser beibehalten oder verworfen. 
	
	</apiDesc><example conref="examples\XML.ignoreComments.1.as"> Im folgenden Beispiel wird veranschaulicht, welche Wirkung es hat, wenn Sie <codeph>XML.ignoreComments</codeph> auf <codeph>false</codeph> und <codeph>true</codeph> setzen:
<codeblock>
XML.ignoreComments = false;
var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;!-- comment -->&lt;/foo>

XML.ignoreComments = true;
var xml2:XML = 
        &lt;foo>
            &lt;!-- example -->
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreProcessingInstructions:get"><apiName>ignoreProcessingInstructions</apiName><shortdesc>
	Legt fest, ob XML-Verarbeitungsanweisungen ignoriert werden, wenn XML-Objekte die XML-Quelldaten analysieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreProcessingInstructions, ignoreProcessingInstructions
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Legt fest, ob XML-Verarbeitungsanweisungen ignoriert werden, wenn XML-Objekte die XML-Quelldaten analysieren. Standardmäßig werden Verarbeitungsanweisungen ignoriert (<codeph>true</codeph>). Um XML-Verarbeitungsanweisungen einzubeziehen, rufen Sie <codeph>false</codeph> auf. Die <codeph>ignoreProcessingInstructions</codeph>-Eigenschaft wird nur während der XML-Analyse verwendet, nicht etwa beim Aufruf von Methoden wie <codeph>myXMLObject.child(~~).toXMLString()</codeph>. Enthält das XML-Quelldokument Verarbeitungsanweisungen, werden sie während der XML-Analyse durch den Parser beibehalten oder verworfen.
	
	</apiDesc><example conref="examples\XML.ignoreProcessingInstructions.1.as"> Im folgenden Beispiel wird veranschaulicht, welche Wirkung es hat, wenn Sie <codeph>XML.ignoreProcessingInstructions</codeph> auf <codeph>false</codeph> und <codeph>true</codeph> setzen:
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml1:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;?exampleInstruction ?>&lt;/foo>

XML.ignoreProcessingInstructions = true;
var xml2:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreWhitespace:get"><apiName>ignoreWhitespace</apiName><shortdesc>
	Legt fest, ob während der Analyse durch den Parser Leerraumzeichen am Anfang und Ende von Textknoten ignoriert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreWhitespace, ignoreWhitespace
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Legt fest, ob während der Analyse durch den Parser Leerraumzeichen am Anfang und Ende von Textknoten ignoriert werden. Standardmäßig wird Leerraum ignoriert (<codeph>true</codeph>). Besteht ein Textknoten zu 100 % aus Leerraum und die <codeph>ignoreWhitespace</codeph>-Eigenschaft ist auf <codeph>true</codeph> gesetzt, wird der Knoten nicht erstellt. Um Leerraum in einem Textknoten anzuzeigen, setzen Sie die <codeph>ignoreWhitespace</codeph>-Eigenschaft auf <codeph>false</codeph>. 
	
	</apiDesc><example conref="examples\XML.ignoreWhitespace.1.as"> Im folgenden Beispiel wird veranschaulicht, welche Wirkung es hat, wenn Sie <codeph>XML.ignoreWhitespace</codeph> auf <codeph>false</codeph> und <codeph>true</codeph> setzen:
<codeblock>
XML.ignoreWhitespace = false;
var xml1:XML = &lt;foo>    &lt;/foo>;
trace(xml1.children().length()); // 1

XML.ignoreWhitespace = true;
var xml2:XML = &lt;foo>    &lt;/foo>;
trace(xml2.children().length()); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="XML:prettyIndent:get"><apiName>prettyIndent</apiName><shortdesc>
	Legt die Breite der Einrückung fest, die von den Methoden toString() und toXMLString() angewendet wird, wenn die Eigenschaft XML.prettyPrinting auf „true“ gesetzt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyIndent, prettyIndent
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Legt die Breite der Einrückung fest, die von den Methoden <codeph>toString()</codeph> und <codeph>toXMLString()</codeph> angewendet wird, wenn die <codeph>XML.prettyPrinting</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt ist. Die Einrückung wird mit dem Leerzeichen angewendet und nicht etwa mit dem Tabulatorzeichen. Der Standardwert ist <codeph>2</codeph>.
	
	</apiDesc><example conref="examples\XML.prettyIndent.1.as"> Im folgenden Beispiel wird veranschaulicht, welche Wirkung es hat, wenn Sie die statische Eigenschaft <codeph>XML.prettyIndent</codeph> festlegen:
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyIndent = 0;
trace(xml.toXMLString());

XML.prettyIndent = 1;
trace(xml.toXMLString());

XML.prettyIndent = 2;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:prettyPrinting:get"><apiName>prettyPrinting</apiName><shortdesc>
	Legt fest, ob die Methoden toString() und toXMLString() Leerraumzeichen zwischen einigen Tags normalisieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyPrinting, prettyPrinting
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Legt fest, ob die Methoden <codeph>toString()</codeph> und <codeph>toXMLString()</codeph> Leerraumzeichen zwischen einigen Tags normalisieren. Der Standardwert ist <codeph>true</codeph>.
	
	</apiDesc><example conref="examples\XML.prettyPrinting.1.as"> Im folgenden Beispiel wird veranschaulicht, welche Wirkung es hat, wenn Sie die statische Eigenschaft <codeph>XML.prettyPrinting</codeph> festlegen:
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyPrinting = false;
trace(xml.toXMLString());

XML.prettyPrinting = true;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:Array"><apiName>Array</apiName><shortdesc>
	 Erstellt ein neues Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Array mit einer Länge von mindestens 0.
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>An ein leeres Array, an ein einzelnes Argument für ein Array festgelegter Länge oder an eine Reihe durch Kommas getrennte Werte verschiedenen Datentyps für ein Array, das mit diesen Werten ausgefüllt wird, können Sie keine Argumente übergeben.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erstellt ein neues Array. Das Array kann eine Länge von 0 oder mehr haben und anhand einer Liste mit angegebenen Elementen, möglicherweise unterschiedlichen Datentyps, ausgefüllt werden. Anhand der Anzahl und dem Datentyp der Argumente können Sie den Inhalt des zurückgegeben Arrays bestimmen.
	 <ul>
	   <li>Wenn Sie <codeph>Array()</codeph> ohne Argumente aufrufen, wird ein leeres Array zurückgegeben.</li>
	   <li>Wenn Sie <codeph>Array()</codeph> mit einem einzigen, ganzzahligen Argument aufrufen, wird ein Array der angegebenen Länge zurückgegeben, für dessen Elemente aber keine Werte definiert sind.</li>
	   <li>Wenn Sie <codeph>Array()</codeph> mit einer Liste an gegebenen Werten aufrufen, wird ein Array mit Elementen zurückgegeben, das jeden der angegebenen Werte enthält.</li>
	 </ul>
	 Die Verwendung der Funktion <codeph>Array()</codeph> ähnelt dem Erstellen eines Arrays mit dem Array-Klassenkonstruktor.
	 <p>Mithilfe des Operators <codeph>as</codeph> können Sie eine ausdrückliche Datentypumwandlung oder -konvertierung festlegen, wenn das Argument kein Grundwert ist. Weitere Informationen finden Sie unten im Abschnitt „Beispiel“. </p>
	 </apiDesc><example conref="examples\Array.func.4.as"> Das folgende Beispiel veranschaulicht das Verhalten der Funktion <codeph>Array()</codeph>, wenn es sich bei einem Argument nicht um einen Grundwert handelt. Die Umwandlung in ein Array wird häufig verwendet, wenn eine Objektinstanz umgewandelt wird, deren Werte im Array-Format gespeichert werden. Wenn <codeph>Array()</codeph> mit einem Argument vom Typ <codeph>Object</codeph> oder einem anderen Datentyp, bei dem es sich nicht um Grundwerte handelt, aufgerufen wird, wird ein Verweis auf das Objekt in einem Element des neuen Arrays gespeichert. Anders ausgedrückt: Wenn als einziges Argument ein Objekt übergeben wird, wird ein Verweis auf dieses Objekt das erste Element des neuen Arrays.
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = Array( obj );

trace(newArray == obj);    // false
trace(newArray[0] == obj); // true
trace(newArray[0][0])      // a
trace(newArray[0][1])      // b
trace(newArray[0][2])      // c
</codeblock></example><example conref="examples\Array.func.5.as"> Um <codeph>obj</codeph> in ein Array umzuwandeln, verwenden Sie den Operator <codeph>as</codeph>. Es wird ein Array-Verweis zurückgegeben, wenn es sich bei<codeph>obj</codeph> um einen gültigen Array handelt; anderfalls <codeph>null</codeph>:
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = obj as Array;

trace(newArray == obj); // true
trace(newArray[0]);     // a
trace(newArray[1]);     // b
trace(newArray[2]);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array"><linktext>Array-Klasse</linktext></link><link href="operators.html#as"><linktext>as-Operator</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:Boolean"><apiName>Boolean</apiName><shortdesc>
	 Wandelt den Parameter „expression“ in einen booleschen Wert um und gibt diesen Wert zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das Ergebnis der Umwandlung in den Datentyp Boolean.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein in den Datentyp Boolean zu konvertierender Ausdruck oder eine Objekt.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Wandelt den Parameter <codeph>expression</codeph> in einen booleschen Wert um und gibt diesen Wert zurück. 
	 <p>Der Rückgabewert hängt, wie in der folgenden Tabelle beschrieben, vom Datentyp und Wert des Arguments ab:</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Eingabewert</entry><entry>Beispiel</entry><entry>Rückgabewert</entry></row></thead><tbody><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>Boolean(0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Boolean(NaN)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Number (nicht <codeph>0</codeph> oder <codeph>NaN</codeph>)</entry>
	     <entry><codeph>Boolean(4)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Leerer String</entry>
	     <entry><codeph>Boolean("")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Nicht leerer String</entry>
	     <entry><codeph>Boolean("6")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry><codeph>„null“</codeph></entry>
	     <entry><codeph>Boolean(null)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>Boolean(undefined)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Instanz der Object-Klasse</entry>
	     <entry><codeph>Boolean(new Object())</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Kein Argument</entry>
	     <entry><codeph>Boolean()</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 <p>Im Gegensatz zu früheren ActionScript-Versionen gibt die Funktion <codeph>Boolean()</codeph> dasselbe Ergebnis zurück wie der Klassenkonstruktor Boolean.</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Number"><apiName>Number</apiName><shortdesc>
	 Konvertiert einen bestimmten Wert in einen Number-Wert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der konvertierte Number-Wert
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein Wert, der in einen Number-Wert umgewandelt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Konvertiert einen bestimmten Wert in einen Number-Wert. Die folgende Tabelle zeigt das Ergebnis verschiedener Eingabetypen:
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Eingabetyp/-wert</entry><entry>Beispiel</entry><entry>Rückgabewert</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>Number(undefined)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry><codeph>„null“</codeph></entry>
	     <entry><codeph>Number(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>Number(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>Number(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Number(NaN)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry>Leerer String</entry>
	     <entry><codeph>Number("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>String, der in einen Number-Wert konvertiert wird</entry>
	     <entry><codeph>Number("5")</codeph></entry>
	     <entry>Die Zahl (z. B. <codeph>5</codeph>)</entry>
	   </row><row>
	     <entry>String, der nicht in einen Number-Wert konvertiert wird</entry>
	     <entry><codeph>Number("5a")</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Object"><apiName>Object</apiName><shortdesc>
	 Jeder Wert in ActionScript 3.0 ist ein Objekt, d. h., wenn Sie für einen Wert Object() aufrufen, wird dieser Wert zurückgegeben.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der von dem Parameter <codeph>value</codeph> angegebene Wert.
     </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein Objekt oder eine umzuwandelnde Zahl, ein String oder ein boolescher Wert.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Jeder Wert in ActionScript 3.0 ist ein Objekt, d. h., wenn Sie für einen Wert <codeph>Object()</codeph> aufrufen, wird dieser Wert zurückgegeben.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:String"><apiName>String</apiName><shortdesc>
	 Gibt den angegebenen Parameter als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine für den Parameter <codeph>expression</codeph> übergebene Stringdarstellung des Werts.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc> Ein Ausdruck, der in einen String umgewandelt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt den angegebenen Parameter als String zurück.
	 <p>Die folgende Tabelle zeigt das Ergebnis verschiedener Eingabetypen:</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Eingabetyp/-wert</entry><entry>Rückgabewert</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>undefined</codeph></entry>
	   </row><row>
	     <entry><codeph>„null“</codeph></entry>
	     <entry><codeph>"null"</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>"true"</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>"false"</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>"NaN"</codeph></entry>
	   </row><row>
	     <entry>String</entry>
	     <entry>String</entry>
	   </row><row>
	     <entry>Object</entry>
	     <entry>Object.toString()</entry>
	   </row><row>
	     <entry>Number</entry>
	     <entry>Die Stringdarstellung der Zahl</entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Vector"><apiName>Vector</apiName><shortdesc>
	 Erstellt eine neue Vector-Instanz, deren Elemente Instanzen des festgelegten Datentyps sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><commentPrivate>The reason this compiles with the .&lt;T> designation is because
	 a dummy class "T" is declared in the top level Vector.as file. If this file is
	 built without that one, the build will fail.
	 
	 </commentPrivate></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn das <codeph>sourceArray</codeph>-Argument ein Element enthält, das nicht in den festgelegten Datentyp konvertiert werden kann.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Eine mit den Elementen des <codeph>sourceArray</codeph>-Arrays gefüllte Vector-Instanz.
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>sourceArray</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein Array oder eine Vector-Instanz, dessen oder deren Elemente zu Elementen des Ergebnisvektors werden. Wenn das Argument eine Vector-Instanz ist, deren verknüpfter Datentyp gleich dem festgelegten Datentyp ist, wird das Argument als das Funktionsergebnis zurückgegeben.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erstellt eine neue Vector-Instanz, deren Elemente Instanzen des festgelegten Datentyps sind. Wenn diese Funktion aufgerufen wird, legen Sie den Datentyp der Elemente des Ergebnisvektors (der <i>Basistyp</i> des Vectors) mithilfe eines type-Parameters fest. Diese Funktion verwendet die gleiche Syntax, die auch beim Deklarieren einer Vector-Instanz oder beim Aufrufen des <codeph>new Vector.&lt;T>()</codeph>-Konstruktors benutzt wird:
	 
	 <codeblock>var v:Vector.&lt;String> = Vector.&lt;String>(["Hello", "World"]);</codeblock>
	 
	 <p>Der Ergebnisvektor wird mit den Werten in den Elementen des <codeph>sourceArray</codeph>-Arguments gefüllt. Wenn das <codeph>sourceArray</codeph>-Argument bereits eine Vector.&lt;T>-Instanz ist, in der <codeph>T</codeph> dem Basistyp entspricht, gibt die Funktion diesen Vector zurück. Andernfalls wird der Ergebnisvektor mit den Elementen aus dem <codeph>sourceArray</codeph>-Array oder dem Vector gefüllt.</p>
	 
	 <p>In beiden Fällen müssen die Datentypen von allen Elementen des <codeph>sourceArray</codeph>-Arguments mit dem im Funktionsaufruf festgelegten Basistyp <codeph>T</codeph> übereinstimmen.</p>
	 
	 <p>Wenn das <codeph>sourceArray</codeph>-Argument einen <codeph>length</codeph>-Wert von 0 hat, gibt die Funktion einen leeren Vector zurück.</p>
	 
	 <p>Wenn ein Vector als das <codeph>sourceArray</codeph>-Argument übergeben wird und sein Basistyp nicht <codeph>T</codeph> ist, oder wenn ein Array übergeben wird und nicht alle Elemente Instanzen vom Datentyp <codeph>T</codeph> sind, wird ein Versuch unternommen, die Werte in den Basistyp zu konvertieren. Wenn die Werte automatisch konvertiert werden können, enthält der Ergebnisvektor die konvertierten Werte. Wenn keine Konvertierung vorgenommen werden kann, tritt ein Fehler auf.</p>
	 
	 <p>Ist ein Element im <codeph>sourceArray</codeph>-Argument eine Instanz einer Unterklasse des Basistyps <codeph>T</codeph>, dann ist der Aufruf erfolgreich und das Element wird dem Ergebnisvektor hinzugefügt. Dies funktioniert auch, wenn das <codeph>sourceArray</codeph>-Argument ein Vector ist, dessen Basistyp eine Unterklasse von <codeph>T</codeph> ist. Dies stellt die einzige Möglichkeit dar, einen Vector mit dem Basistyp <codeph>T</codeph> in einen Vector mit einem Basistyp, der eine Superklasse von <codeph>T</codeph> ist, zu konvertieren.</p>
	 
	 <p>Der folgende Code führt z. B. zu einem Kompilierungsfehler im Strict-Modus oder einem TypeError zur Laufzeit, da versucht wird, ein Vector.&lt;Sprite> einer Vector.&lt;DisplayObject>-Variablen zuzuweisen (Sprite ist eine Unterklasse von DisplayObject):</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = v1;
	 </codeblock>
	 
	 <p>Die folgende alternative Version des Codes kopiert die Elemente einer Vector.&lt;Sprite>-Instanz erfolgreich in eine Vector.&lt;DisplayObject>-Instanz:</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = Vector.&lt;DisplayObject>(v1);
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Vector"><linktext>Vector-Klasse</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XMLList"><apiName>XMLList</apiName><shortdesc>
     Konvertiert ein Objekt in ein XMLList-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein XML-Objekt, das Werte aus dem konvertierten Objekt enthält.
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Der Wert wird in ein XMLList-Objekt konvertiert.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Konvertiert ein Objekt in ein XMLList-Objekt.
     <p>Die folgende Tabelle beschreibt Rückgabewerte für verschiedene Eingabetypen:</p>
	 <adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>Parametertyp</entry><entry>Rückgabewert</entry></row></thead><tbody><row>
	 		<entry>Boolescher Ausdruck</entry>
	 		<entry>Der Wert wird erst in einen String konvertiert und anschließend in ein XMLList-Objekt.</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>Während der Laufzeit tritt ein Fehler auf (TypeError-Ausnahme).</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>Der Wert wird erst in einen String konvertiert und anschließend in ein XMLList-Objekt.</entry>
	 	</row><row>
	 		<entry>Object</entry>
	 		<entry>Wird nur dann in einen XMLList-Objekt konvertiert, wenn es sich um einen String, eine Zahl oder einen booleschen Wert handelt. Andernfalls tritt während der Laufzeit ein Fehler auf (TypeError-Ausnahme).</entry>
	 	</row><row>
	 		<entry>String</entry>
	 		<entry>Der Wert wird in ein XMLList-Objekt konvertiert.</entry>
	 	</row><row>
	 		<entry>Nicht festgelegt</entry>
	 		<entry>Während der Laufzeit tritt ein Fehler auf (TypeError-Ausnahme).</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>Der Wert wird in ein XMLList-Objekt konvertiert.</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>Der Eingabewert wird unverändert zurückgegeben.</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XML()"><linktext>XML()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XML"><apiName>XML</apiName><shortdesc>
	 Konvertiert ein Objekt in ein XML-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein XML-Objekt, das Werte aus dem konvertierten Objekt enthält.
	 </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein Objekt, das in einen XML-Wert umgewandelt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Konvertiert ein Objekt in ein XML-Objekt. 
	 <p>Die folgende Tabelle beschreibt Rückgabewerte für verschiedene Eingabetypen:</p>
	 	<adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>Parametertyp</entry><entry>Rückgabewert</entry></row></thead><tbody><row>
	 		<entry>Boolescher Ausdruck</entry>
	 		<entry>Der Wert wird erst in einen String konvertiert und anschließend in ein XML-Objekt.</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>Während der Laufzeit tritt ein Fehler auf (TypeError-Ausnahme).</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>Der Wert wird erst in einen String konvertiert und anschließend in ein XML-Objekt.</entry>
	 	</row><row>
	 		<entry>Object</entry>
	 		<entry>Wird nur dann in einen XML-Wert konvertiert, wenn es sich um einen String, eine Zahl oder einen booleschen Wert handelt. Andernfalls tritt während der Laufzeit ein Fehler auf (TypeError-Ausnahme).</entry>
	 	</row><row>
	 		<entry>String</entry>
	 		<entry>Wird in einen XML-Wert umgewandelt.</entry>
	 	</row><row>
	 		<entry>Nicht festgelegt</entry>
	 		<entry>Während der Laufzeit tritt ein Fehler auf (TypeError-Ausnahme).</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>Der Eingabewert wird unverändert zurückgegeben.</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>Gibt nur dann ein XML-Objekt aus, wenn das XMLList-Objekt nur eine Eigenschaft vom Typ XML enthält. Andernfalls tritt während der Laufzeit ein Fehler auf (TypeError-Ausnahme).</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XMLList()"><linktext>XMLList()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURIComponent"><apiName>decodeURIComponent</apiName><shortdesc>
	 Dekodiert eine kodierte URI-Komponente in einen String.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, in dem alle zuvor von der Funktion <codeph>encodeURIComponent</codeph> mit Escape-Sequenzen versehenen Zeichen wieder in die Darstellung ohne Escape-Sequenzen zurückversetzt werden.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein mit der Funktion <codeph>encodeURIComponent</codeph> kodierter String.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Dekodiert eine kodierte URI-Komponente in einen String. Gibt einen String zurück, in dem alle zuvor von der Funktion <codeph>encodeURIComponent</codeph> mit Escape-Sequenzen versehenen Zeichen wieder in ihre unkodierte Darstellung zurück versetzt werden.
	 <p>Diese Funktion unterscheidet sich in so fern von der Funktion <codeph>decodeURI()</codeph> als sie für die Verwendung mit nur einem Teil des URI-Strings, einer sogenannten URI-Komponente, konzipiert ist. Eine URI-Komponente ist ein beliebiger Text, der zwischen speziellen Zeichen, den sogenannten <i>component separators</i>, erscheint <codeph>: ( / ; und ? </codeph>). Gewöhnliche Beispiele für URI-Komponenten sind „http“ oder „www.adobe.com“.</p>
	 <p>Ein weiterer wichtiger Unterschied zwischen dieser Funktion und <codeph>decodeURI()</codeph> ist, dass diese Funktion davon ausgeht, dass sie eine URI-Komponente verarbeitet, und somit die Escape-Sequenzen, die spezielle Trennzeichen repräsentieren (<codeph>; / ? : @ &amp; = + $ , #</codeph>) als regulären Text behandelt, der dekodiert werden soll. </p>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURI"><apiName>decodeURI</apiName><shortdesc>
	 Dekodiert einen kodierten URI in einen String.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, in dem alle zuvor von der Funktion <codeph>encodeURI</codeph> mit Escape-Sequenzen versehenen Zeichen wieder in die Darstellung ohne Escape-Sequenzen zurückversetzt werden.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein mit der Funktion <codeph>encodeURI</codeph> kodierter String.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Dekodiert einen kodierten URI in einen String. Gibt einen String zurück, in dem alle zuvor von der Funktion <codeph>encodeURI</codeph> kodierten Zeichen wieder in ihre unkodierte Darstellung zurückversetzt werden.
	 <p>Die folgende Tabelle zeigt den Satz an Escape-Sequenzen, die <i>nicht</i> von der Funktion <codeph>decodeURI</codeph> in Zeichen dekodiert werden. Um die Escape-Sequenzen in dieser Tabelle zu dekodieren, verwenden Sie <codeph>decodeURIComponent()</codeph>.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Nicht dekodierte Escape-Sequenzen</entry><entry>Zeichenentsprechungen</entry></row></thead><tbody><row>
	     <entry><codeph>%23</codeph></entry>
	     <entry><codeph>#</codeph></entry>
	   </row><row>
	     <entry><codeph>%24</codeph></entry>
	     <entry><codeph>$</codeph></entry>
	   </row><row>
	     <entry><codeph>%26</codeph></entry>
	     <entry><codeph>&amp;</codeph></entry>
	   </row><row>
	     <entry><codeph>%2B</codeph></entry>
	     <entry><codeph>+</codeph></entry>
	   </row><row>
	     <entry><codeph>%2C</codeph></entry>
	     <entry><codeph>,</codeph></entry>
	   </row><row>
	     <entry><codeph>%2F</codeph></entry>
	     <entry><codeph>/</codeph></entry>
	   </row><row>
	     <entry><codeph>%3A</codeph></entry>
	     <entry><codeph>:</codeph></entry>
	   </row><row>
	     <entry><codeph>%3B</codeph></entry>
	     <entry><codeph>;</codeph></entry>
	   </row><row>
	     <entry><codeph>%3D</codeph></entry>
	     <entry><codeph>=</codeph></entry>
	   </row><row>
	     <entry><codeph>%3F</codeph></entry>
	     <entry><codeph>?</codeph></entry>
	   </row><row>
	     <entry><codeph>%40</codeph></entry>
	     <entry><codeph>@</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example conref="examples\DecodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class DecodeURIExample extends Sprite {
        public function DecodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURIComponent"><apiName>encodeURIComponent</apiName><shortdesc>
	 Kodiert einen String in eine gültige URI-Komponente.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 Kodiert einen String in eine gültige URI-Komponente. Konvertiert einen Teilstring eines URI in einen String, in dem alle Zeichen, bis auf eine kleine Gruppe von Standardzeichen, als UTF-8-Escape-Sequenzen kodiert werden.
	 <p>Die Funktion <codeph>encodeURIComponent()</codeph> unterscheidet sich in so fern von der Funktion <codeph>encodeURI()</codeph>, als sie für die Verwendung mit nur einem Teil eines URI-Strings, einer sogenannten URI-Komponente, konzipiert ist. Eine URI-Komponente ist ein beliebiger Text, der zwischen speziellen Zeichen, den sogenannten <i>component separators</i>, erscheint <codeph>: ( / ; und ? </codeph>). Gewöhnliche Beispiele für URI-Komponenten sind „http“ oder „www.adobe.com“.</p>
	 <p>Ein weiterer wichtiger Unterschied zwischen dieser Funktion und <codeph>encodeURI()</codeph> ist, dass diese Funktion davon ausgeht, dass sie eine URI-Komponente verarbeitet, und somit die speziellen Trennzeichen (<codeph>; / ? : @ &amp; = + $ , #</codeph>) als regulären Text behandelt, der kodiert werden soll. </p>
	 <p>Die folgende Tabelle zeigt alle Zeichen, die <i>nicht</i> von der Funktion <codeph>encodeURIComponent</codeph> in UTF-8-Escape-Sequenzen konvertiert werden.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Nicht kodierte Zeichen</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>- _ . ! ~ ~~ ' ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURI"><apiName>encodeURI</apiName><shortdesc>
	 Kodiert einen String in einen gültigen URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, in dem bestimmte Zeichen als UTF-8-Escape-Sequenzen kodiert sind.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String, der einen vollständigen URI repräsentiert.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Kodiert einen String in einen gültigen URI (Uniform Resource Identifier, einheitlicher Ressourcenbezeichner). Konvertiert einen vollständigen URI in einen String, in dem alle Zeichen, bis auf eine kleine Gruppe von Standardzeichen, als UTF-8-Escape-Sequenzen kodiert werden.
	 <p>Die folgende Tabelle zeigt den gesamten Satz an Standardzeichen, die <i>nicht</i> von der Funktion <codeph>encodeURI</codeph> in UTF-8-Escape-Sequenzen konvertiert werden.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Nicht kodierte Zeichen</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>; / ? : @ &amp; = + $ , #</codeph></entry>
	   </row><row>
	     <entry><codeph>- _ . ! ~ ~~ ' ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc><example conref="examples\EncodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class EncodeURIExample extends Sprite {
        public function EncodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:escape"><apiName>escape</apiName><shortdesc>
	 Wandelt den Parameter in einen String um und kodiert ihn in einem URL-Format, bei dem die meisten nicht alphanumerischen Zeichen als %, gefolgt von einer Hexadezimalsequenz, dargestellt werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein als URL kodierter String
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Ausdruck, der in einen String umgewandelt und in das URL-Format kodiert werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Wandelt den Parameter in einen String um und kodiert ihn in ein URL-Format, bei dem die meisten nicht alphanumerischen Zeichen durch ein <codeph>%</codeph>, gefolgt von einer Hexadezimalsequenz, ersetzt werden. Bei URL-kodierten Strings dient das Prozentzeichen (<codeph>%</codeph>) zum Maskieren von Escape-Zeichen und entspricht nicht dem Modulo-Operator (<codeph>%</codeph>).
	 <p>Die folgende Tabelle zeigt alle Zeichen, die <i>nicht</i> von der Funktion <codeph>escape()</codeph> in Escape-Sequenzen konvertiert werden.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Nicht kodierte Zeichen</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>@ - _ . ~~ + /</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/unescape()"><linktext>unescape()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:int"><apiName>int</apiName><shortdesc>
	 Konvertiert einen bestimmten numerischen Wert in eine Ganzzahl.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die konvertierte Ganzzahl.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Wert, der in eine Ganzzahl umgewandelt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Konvertiert einen bestimmten numerischen Wert in eine Ganzzahl. Dezimalwerte werden an der Dezimalstelle abgeschnitten.
	 </apiDesc></apiOperationDetail><related-links><link href="#global/uint()"><linktext>uint()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:isFinite"><apiName>isFinite</apiName><shortdesc>
	 Gibt true zurück, wenn der Wert eine endliche Zahl ist und false, wenn der Wert Infinity oder -Infinity ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0."/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Gibt <codeph>true</codeph> zurück, wenn es sich um eine endliche Zahl handelt, bzw. <codeph>false</codeph>, wenn es sich um positive oder negative Unendlichkeit handelt
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die als endlich oder unendlich ausgewertet wird.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt <codeph>true</codeph> zurück, wenn der Wert eine endliche Zahl ist und <codeph>false</codeph>, wenn der Wert <codeph>Infinity</codeph> oder <codeph>-Infinity</codeph> ist. Das Auftreten von <codeph>Infinity</codeph> oder <codeph>-Infinity</codeph> deutet auf einen mathematischen Fehlerzustand hin, beispielsweise eine Division durch 0.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isNaN"><apiName>isNaN</apiName><shortdesc>
	 Gibt „true“ zurück, wenn der Wert „NaN“ (Not a Number – keine Zahl) lautet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Gibt <codeph>true</codeph> zurück, wenn der Wert <codeph>NaN</codeph> (Not a Number – keine Zahl) lautet; andernfalls <codeph>false</codeph>.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein zu berechnender numerischer oder mathematischer Ausdruck.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt <codeph>true</codeph> zurück, wenn der Wert <codeph>NaN</codeph> (Not a Number – keine Zahl) lautet. Die Funktion <codeph>isNaN()</codeph> dient zur Überprüfung, ob ein mathematischer Ausdruck erfolgreich als Zahl ausgewertet werden kann. Die häufigste Verwendung von <codeph>isNaN()</codeph> ist die Überprüfung des Werts, der von der <codeph>parseInt()</codeph>- und der <codeph>parseFloat()</codeph>-Funktion zurückgegeben wird. Der Wert <codeph>NaN</codeph> ist ein spezielles Mitglied des Datentyps Number, das einen Wert repräsentiert der „not a number“, also keine Zahl, ist. 
	 <p><b>Hinweis</b>: Der Wert <codeph>NaN</codeph> ist kein Mitglied der Datentypen „int“ oder „uint“.</p>
	 <p>Die folgende Tabelle beschreibt den Rückgabewert von <codeph>isNaN()</codeph> bei verschiedenen Eingabetypen und -werten. (Wenn für Compilerwarnungen der Strict-Modus festgelegt ist, führen einige der folgenden Vorgänge zu Compilerwarnungen.)</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Eingabetyp/-wert</entry><entry>Beispiel</entry><entry>Rückgabewert</entry></row></thead><tbody><row>
	     <entry>0 durch 0 dividiert</entry>
	     <entry><codeph>isNaN(0/0)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Eine Zahl ungleich Null durch <codeph>0</codeph> dividiert</entry>
	     <entry><codeph>isNaN(5/0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Quadratwurzel aus einer negativen Zahl</entry>
	     <entry><codeph>isNaN(Math.sqrt(-1))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Arkussinus einer Zahl, die größer als 1 oder kleiner als 0 ist</entry>
	     <entry><codeph>isNaN(Math.asin(2))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>String, der in einen Number-Wert konvertiert werden kann</entry>
	     <entry><codeph>isNaN("5")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>String, der nicht in einen Number-Wert konvertiert werden kann</entry>
	     <entry><codeph>isNaN("5a")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isXMLName"><apiName>isXMLName</apiName><shortdesc>
	 Bestimmt, ob der angegebene String ein gültiger Name für ein XML-Element oder -Attribut ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Gibt <codeph>true</codeph> zurück, wenn das Argument <codeph>str</codeph> ein gültiger XML-Name ist; andernfalls <codeph>false</codeph>.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein auszuwertender String.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bestimmt, ob der angegebene String ein gültiger Name für ein XML-Element oder -Attribut ist.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseFloat"><apiName>parseFloat</apiName><shortdesc>
	 Wandelt einen String in eine Gleitkommazahl um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine Zahl oder <codeph>NaN</codeph> (Not a Number – keine Zahl).
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, der gelesen und in eine Gleitkommazahl umgewandelt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Wandelt einen String in eine Gleitkommazahl um. Die Funktion liest bzw. <i>analysiert</i> die Zahlen im String und gibt diese zurück, bis der Parser auf ein Zeichen trifft, das nicht zur Ausgangszahl gehört. Wenn der String nicht mit einer Zahl beginnt, die analysiert werden kann, gibt <codeph>parseFloat()</codeph> den Wert <codeph>NaN</codeph> zurück. Leerzeichen vor gültigen Ganzzahlen werden ebenso ignoriert wie nachgestellte nicht numerische Zeichen.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseInt"><apiName>parseInt</apiName><shortdesc>
	 Wandelt einen String in eine Ganzzahl um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine Zahl oder <codeph>NaN</codeph> (Not a Number – keine Zahl).
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String, der in eine Ganzzahl umgewandelt werden soll.
	 </apiDesc></apiParam><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Ganzzahl, die die Grundzahl (Basis) der zu analysierenden Zahl darstellt. Zulässige Werte liegen zwischen 2 und 36.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Wandelt einen String in eine Ganzzahl um. Wenn der in den Parametern angegebene String nicht in eine Zahl umgewandelt werden kann, gibt die Funktion <codeph>NaN</codeph> zurück. Strings, die mit 0x beginnen, werden als Hexadezimalzahlen interpretiert. Im Gegensatz zu früheren ActionScript-Versionen werden Ganzzahlen, die mit 0 beginnen, <i>nicht</i> als Oktalzahlen interpretiert. Für Oktalzahlen müssen Sie die Grundzahl 8 angeben. Leerzeichen und Nullwerte vor gültigen Ganzzahlen werden ebenso ignoriert wie nachgestellte nicht numerische Zeichen.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:trace"><apiName>trace</apiName><shortdesc>
	 Zeigt während der Fehlersuche Ausdrücke an oder schreibt sie in Protokolldateien.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Einer oder mehrere (durch Kommas getrennte) auszuwertende Ausdrücke. Bei mehreren Ausdrücken wird in der Ausgabe zwischen die einzelnen Ausdrücke ein Leerzeichen gesetzt.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Zeigt während der Fehlersuche Ausdrücke an oder schreibt sie in Protokolldateien. Eine einzelne trace-Anweisung kann mehrere Argumente unterstützen. Enthält ein Argument in einer trace-Anweisung einen Datentyp, der kein String ist, ruft die trace-Funktion die zu diesem Datentyp gehörige <codeph>toString()</codeph>-Methode auf. Ist das Argument beispielsweise ein boolescher Wert, so ruft die trace-Funktion <codeph>Boolean.toString()</codeph> auf und zeigt den Rückgabewert an. 
	 </apiDesc><example conref="examples\TraceExample.as"> Im folgenden Beispiel wird mithilfe der <codeph>TraceExample</codeph>-Klasse veranschaulicht, wie Sie mit der<codeph>trace()</codeph>-Methode einen einfachen String ausdrucken können. Im Allgemeinen wird die Meldung auf einer „Debug“-Konsole ausgedruckt.
<codeblock>
package {
    import flash.display.Sprite;

    public class TraceExample extends Sprite {

        public function TraceExample() {
            trace("Hello World");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="globalOperation:uint"><apiName>uint</apiName><shortdesc>
	 Konvertiert einen bestimmten numerischen Wert in eine vorzeichenlose Ganzzahl.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die konvertierte Ganzzahl.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Wert, der in eine Ganzzahl umgewandelt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Konvertiert einen bestimmten numerischen Wert in eine vorzeichenlose Ganzzahl. Dezimalwerte werden an der Dezimalstelle abgeschnitten.
	 <p>Die folgende Tabelle beschreibt den Rückgabewert von <codeph>uint()</codeph> bei verschiedenen Eingabetypen und -werten.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Eingabetyp/-wert</entry><entry>Beispiel</entry><entry>Rückgabewert</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>uint(undefined)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>„null“</codeph></entry>
	     <entry><codeph>uint(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>uint(0)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>uint(NaN)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Positive Gleitkommazahl</entry>
	     <entry><codeph>uint(5.31)</codeph></entry>
	     <entry>Abgeschnittene vorzeichenlose Ganzzahl (z. B. <codeph>5</codeph>)</entry>
	   </row><row>
	     <entry>Negative Gleitkommazahl</entry>
	     <entry><codeph>uint(-5.78)</codeph></entry>
	     <entry>Schneidet die Ganzzahl ab, und wendet dann die Regel für negative Ganzzahlen an</entry>
	   </row><row>
	     <entry>Negative Ganzzahl</entry>
	     <entry><codeph>uint(-5)</codeph></entry>
         <entry>Die Summe von <codeph>uint.MAX_VALUE</codeph> und der negativen Ganzzahl (z. B. <codeph>uint.MAX_VALUE + (-5)</codeph>)</entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>uint(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>uint(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Leerer String</entry>
	     <entry><codeph>uint("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>String, der in einen Number-Wert konvertiert wird</entry>
	     <entry><codeph>uint("5")</codeph></entry>
	     <entry>Der number-Wert</entry>
	   </row><row>
	     <entry>String, der nicht in einen Number-Wert konvertiert wird</entry>
	     <entry><codeph>uint("5a")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row></tbody></tgroup></adobetable>

	 </apiDesc></apiOperationDetail><related-links><link href="#global/int()"><linktext>int()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:unescape"><apiName>unescape</apiName><shortdesc>
	 Wertet den Parameter str als String aus, dekodiert den String aus dem URL-Format (indem er alle Hexadezimalsequenzen in ASCII-Zeichen konvertiert) und gibt den String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, der mit einem URL-kodierten Parameter dekodiert wurde.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String mit einer Hexadezimalsequenz, die in eine ASCII-Sequenz umgewandelt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Wertet den Parameter <codeph>str</codeph> als String aus, dekodiert den String aus dem URL-Format (indem er alle Hexadezimalsequenzen in ASCII-Zeichen umwandelt) und gibt den String zurück.
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="globalValue:Infinity"><apiName>Infinity</apiName><shortdesc>
 Ein spezieller Wert, der eine positive Infinity repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Ein spezieller Wert, der eine positive <codeph>Infinity</codeph> repräsentiert. Der Wert dieser Konstante entspricht <codeph>Number.POSITIVE_INFINITY</codeph>.
 </apiDesc><example conref="examples\Constants.Infinity.1.as"> Eine Division durch 0 resultiert nur dann in dem Wert <codeph>Infinity</codeph>, wenn der Divisor ein positive Zahl ist.
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/POSITIVE_INFINITY"><linktext>Number.POSITIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:-Infinity"><apiName>-Infinity</apiName><shortdesc>
 Ein spezieller Wert, der eine negative Infinity repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Ein spezieller Wert, der eine negative <codeph>Infinity</codeph> repräsentiert. Der Wert dieser Konstante entspricht <codeph>Number.NEGATIVE_INFINITY</codeph>.
 </apiDesc><example conref="examples\Constants.NegInfinity.1.as"> Eine Division durch 0 resultiert nur dann in dem Wert <codeph>-Infinity</codeph>, wenn der Divisor ein negative Zahl ist.
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/NEGATIVE_INFINITY"><linktext>Number.NEGATIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:NaN"><apiName>NaN</apiName><shortdesc>
 Ein spezielles Mitglied des Datentyps Number, das einen Wert repräsentiert der „not a number“, also keine Zahl, ist (NaN).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Ein spezielles Mitglied des Datentyps Number, das einen Wert repräsentiert der „not a number“, also „keine Zahl“, ist (<codeph>NaN</codeph>). Wenn ein mathematischer Ausdruck einen Wert ergibt, der nicht als Zahl ausgedrückt werden kann, ist das Ergebnis <codeph>NaN</codeph>. Die folgende Liste beschreibt häufig vorkommende Ausdrücke, die das Ergebnis <codeph>NaN</codeph> liefern.
 <ul>
   <li>Eine Division durch 0 resultiert nur dann in dem Wert <codeph>NaN</codeph>, wenn der Divisor ebenfalls 0 ist. Ist der Divisor größer als 0, resultiert die Division durch 0 in dem Wert <codeph><codeph>Infinity</codeph></codeph>. Ist der Divisor kleiner 0, resultiert die Division durch 0 in dem Wert <codeph><codeph>-Infinity</codeph></codeph>.</li>
   <li>Die Quadratwurzel aus einer negativen Zahl.</li>
   <li>Der Arkussinus einer Zahl, die außerhalb des zulässigen Bereichs von 0 bis 1 liegt.</li>
   <li><codeph>Infinity</codeph> subtrahiert von <codeph>Infinity</codeph>;</li>
   <li><codeph>Infinity</codeph> oder <codeph>-Infinity</codeph> geteilt durch <codeph>Infinity</codeph> oder <codeph>-Infinity</codeph>;</li>
   <li><codeph>Infinity</codeph> oder <codeph>-Infinity</codeph> mit 0 multipliziert;</li>
  </ul>
 <p>Der Wert <codeph>NaN</codeph> ist kein Mitglied der Datentypen int oder uint.</p>
 <p>Der Wert <codeph>NaN</codeph> wird nicht als identisch mit einem anderen Wert betrachtet, einschließlich <codeph>NaN</codeph>, d. h., es ist unmöglich, den Gleichheitsoperator darauf anzuwenden, um festzustellen, ob ein Ausdruck <codeph>NaN</codeph> ist. Um festzustellen, ob eine Zahl die Funktion <codeph>NaN</codeph> ist, verwenden Sie <codeph>isNaN()</codeph>.</p>
 
 </apiDesc></apiValueDetail><related-links><link href="#global/isNaN()"><linktext>isNaN()</linktext></link><link href="#Number/NaN"><linktext>Number.NaN</linktext></link></related-links></apiValue><apiValue id="globalValue:undefined"><apiName>undefined</apiName><shortdesc>
 Ein spezieller Wert, der auf nicht typisierte Variablen angewendet wird, die nicht initialisiert worden sind, oder auf dynamische Objekteigenschaften, die nicht initialisiert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
 Ein spezieller Wert, der auf nicht typisierte Variablen angewendet wird, die nicht initialisiert worden sind, oder auf dynamische Objekteigenschaften, die nicht initialisiert werden. In ActionScript 3.0 können nur nicht typisierte Variablen den Wert <codeph>undefined</codeph> besitzen, was in ActionScript 1.0 und ActionScript 2.0 noch anders war. So sind beispielsweise beide der folgenden Variablen <codeph>undefined</codeph>, da sie nicht typisiert und nicht initialisiert sind:
 <ul>
   <li><codeph>var foo;</codeph></li>
   <li><codeph>var bar:~~;</codeph></li>
 </ul>
 <p>Der Wert <codeph>undefined</codeph> trifft auch auf nicht initialisierte und oder nicht definierte Eigenschaften von dynamischen Objekten zu. Ist ein Objekt beispielsweise eine Instanz der Object-Klasse, ist der Wert jeglicher dynamisch hinzugefügter Eigenschaft <codeph>undefined</codeph>, bis er dieser Eigenschaft zugewiesen wird.
 </p>
 <p>Bei verschiedenen Funktionen ist das Ergebnis bei der Verwendung von <codeph>undefined</codeph> unterschiedlich:</p>
 <ul>
 <li>Der von <codeph>String(undefined)</codeph> zurückgegebene Wert ist <codeph>"undefined"</codeph> (<codeph>undefined</codeph> wird in einen String konvertiert).</li> 
 <li>Der von <codeph>Number(undefined)</codeph> zurückgegebene Wert ist <codeph>NaN</codeph>.</li> 
 <li>Der von <codeph>int(undefined)</codeph> und <codeph>uint(undefined)</codeph> zurückgegebene Wert ist 0.</li>
 <li>Der von <codeph>Object(undefined)</codeph> zurückgegebene Wert ist eine neue Object-Instanz.</li>
 <li>Wird der Wert <codeph>undefined</codeph> einer typisierten Variable zugewiesen, wird er in den Standardwert des betreffenden Datentyps umgewandelt.</li>
 </ul>
 <p>Verwechseln Sie <codeph>undefined</codeph> nicht mit <codeph>null</codeph>. Wenn <codeph>null</codeph> und <codeph>undefined</codeph> anhand des Gleichheitsoperators (<codeph>==</codeph>) verglichen werden, gelten sie als identisch. Wenn <codeph>null</codeph> und <codeph>undefined</codeph> dagegen mit dem Operator für strikte Gleichheit (<codeph>===</codeph>) verglichen werden, sind sie nicht identisch.</p>
 </apiDesc><example conref="examples\Constants.undefined.1.as"> Im folgenden Beispiel wurde eine nicht typisiert Variable (<codeph>myVar</codeph>) deklariert aber nicht initialisiert. Der Wert von <codeph>myVar</codeph> ist <codeph>undefined</codeph>, da es sich um eine nicht typisiert Variable handelt. Dies trifft immer dann zu, wenn die Variable keine Typanmerkung aufweist oder das Asterisk-Symbol (~~) entspricht keiner Typanmerkung verwendet (<codeph>var myVar:~~;</codeph>).
<codeblock>

// trace value of untyped and uninitialized variable
var myVar;
trace(myVar); // undefined
</codeblock></example><example conref="examples\Constants.undefined.2.as"> Die gleiche Regel trifft auch auf nicht initialisierte Eigenschaften von dynamischen Objekten zu. So lautet beispielsweise bei einer Instanz <codeph>obj</codeph> der dynamischen Klasse <codeph>A</codeph> der Wert von <codeph>obj.propName</codeph>, wobei es sich um eine nicht initialisierte Eigenschaft der <codeph>obj</codeph>-Instanz handelt, <codeph>undefined</codeph>.
<codeblock>

dynamic class A {}
var obj:A = new A()

// trace undefined property of obj
trace(obj.propName); // undefined

</codeblock></example></apiValueDetail><related-links><link href="statements.html#null"><linktext>„null“</linktext></link></related-links></apiValue><apiClassifier id="globalClassifier:uint"><apiName>uint</apiName><shortdesc>
 Die uint-Klasse stellt Methoden für die Arbeit mit einem Datentyp bereit, der eine vorzeichenlose 32-Bit-Ganzzahl (engl. „unsigned integer“) repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint object, uint, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die uint-Klasse stellt Methoden für die Arbeit mit einem Datentyp bereit, der eine vorzeichenlose 32-Bit-Ganzzahl (engl. „unsigned integer“) repräsentiert. Da eine vorzeichenlose Ganzzahl nur positiv sein kann, entspricht ihr maximaler Wert dem Doppelten des Werts der int-Klasse.
 <p>Der von der uint-Klasse repräsentierte Wertebereich liegt zwischen 0 und 4.294.967.295 (2^32-1).</p>
 <p>Sie können ein uint-Objekt erstellen, indem Sie eine Variable vom Typ uint erstellen und der Variable einen Literalwert zuweisen. Der Standardwert einer Variable vom Typ „uint“ lautet <codeph>0</codeph>.</p>
 <p>Die uint-Klasse ist insbesondere bei der Verwendung von Pixelfarbwerten (ARGB und RGBA) nützlich sowie in anderen Situationen, bei denen der Datentyp „int“ nicht gut funktioniert. Die Zahl 0xFFFFFFFF beispielsweise, die den Farbwert Weiß mit einem Alphawert von 255 repräsentiert, lässt sich mit dem Datentyp „int“ nicht darstellen, da sie sich außerhalb des für „int“-Werte zulässigen Wertebereichs befindet.</p> 
 
 <p>Mit dem folgenden Beispiel wird ein uint-Objekt erstellt und die Methode <codeph> toString()</codeph> aufgerufen:</p>
 <pre>
 var myuint:uint = 1234;
 trace(myuint.toString()); // 1234
 </pre>
 <p>Im folgenden Beispiel wird der Wert der Eigenschaft <codeph>MIN_VALUE</codeph> einer Variablen zugewiesen ohne den Konstruktor zu verwenden:</p>
 <pre>
 var smallest:uint = uint.MIN_VALUE;
 trace(smallest.toString()); // 0
 </pre> 
 
 </apiDesc><example conref="examples\UintExample.as"> Im folgenden Beispiel wird <codeph>i</codeph> als Wert für ein „uint“ in einer <codeph>for</codeph>-Schleife deklariert, wodurch die Zahlen 0 bis geduckt werden (da der Standardwert von „uint“ 0 lautet).
<codeblock>

package {
    import flash.display.Sprite;

    public class UintExample extends Sprite {
        public function UintExample() {
            for(var i:uint; i &lt; 10; i++) {
                trace(i);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="uint:uint"><apiName>uint</apiName><shortdesc>
	 Erstellt ein neues uint-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Der numerische Wert des zu erstellenden uint-Objekts oder ein Wert, der in eine Zahl umgewandelt werden soll. Wird <codeph>num</codeph> nicht bereitgestellt, lautet der Standardwert <codeph>0</codeph>.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues uint-Objekt. Sie können eine Variable vom Typ uint erstellen und ihr einen Literalwert zuweisen. Der Konstruktor <codeph>new uint()</codeph> wird hauptsächlich als Platzhalter verwendet. Ein uint-Objekt entspricht nicht der Funktion <codeph> uint()</codeph>, die einen Parameter in einen Grundwert umwandelt.
	 
	 </apiDesc><example>Der folgende Code erstellt zwei neue uint-Objekte; das erste, indem ein Literalwert zugewiesen wird und das zweite, indem die Konstruktorfunktion verwendet wird:
	 <pre>
	 var n1:uint = 3;
	 var n2:uint = new uint(10);
	 </pre>
	 
	 </example></apiConstructorDetail></apiConstructor><apiOperation id="uint:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      Gibt eine Zahl in Exponentialschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>fractionDigits</codeph> nicht zwischen 0 und 20 liegt.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 0 und 20 (einschließlich), die die gewünschte Anzahl an Dezimalstellen repräsentiert.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Gibt eine Zahl in Exponentialschreibweise als String zurück. Der String enthält eine Ziffer vor der Dezimalstelle und bis zu 20 Nachkommastellen, gemäß der Angabe im Parameter <codeph>fractionDigits</codeph>.
      </apiDesc><example conref="examples\Number.toExponential.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings in Exponentialschreibweise durch <codeph>toFixed(2)</codeph>.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     Gibt eine Zahl in Festkommaschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>fractionDigits</codeph> nicht zwischen 0 und 20 liegt.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 0 und 20 (einschließlich), die die gewünschte Anzahl an Dezimalstellen repräsentiert.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt eine Zahl in Festkommaschreibweise als String zurück. Festkommaschreibweise bedeutet, dass der String eine bestimmte Anzahl an Nachkommastellen enthält, und zwar gemäß der Angabe im Parameter <codeph>fractionDigits</codeph>. Die zulässigen Werte für den Parameter <codeph>fractionDigits</codeph> liegen zwischen 0 und 20. Wird ein Wert außerhalb dieses Bereichs angegeben, wird eine Ausnahme ausgelöst.
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings durch <codeph>toFixed(3)</codeph>, mit dem auf drei Dezimalstellen aufgerundet wird.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings durch <codeph>toFixed(2)</codeph>, mit dem nachgestellte Nullen hinzugefügt werden.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      Gibt eine Zahl in Exponential- oder Festkommaschreibweise als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Löst eine Ausnahme aus, wenn das Argument <codeph>precision</codeph> nicht zwischen 1 und 21 liegt.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl zwischen 1 und 21 (einschließlich), die die gewünschte Anzahl an Nachkommastellen für die Darstellung des Strings repräsentiert.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Gibt eine Zahl in Exponential- oder Festkommaschreibweise als String zurück. Der String enthält die im Parameter <codeph>precision</codeph> angegebene Anzahl an Ziffern.
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings mit nur drei Stellen durch <codeph>toFixed(3)</codeph>. Der String wird in Festkommaschreibweise zurückgegeben, da Exponentialschreibweise nicht erforderlich ist.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> Das folgende Beispiel zeigt die Rückgabe eines Strings mit nur drei Stellen durch <codeph>toFixed(3)</codeph>. Der String wird in Exponentialschreibweise zurückgegeben, da die Anzahl an Stellen der sich ergebenden Zahl nicht ausreichen für die Festkommaschreibweise.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Gibt den Wert des uint-Objekts als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Die Stringdarstellung des uint-Objekts.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Gibt die numerische Basis (von 2 bis 36) an, die bei der Umwandlung von Zahlen in Strings verwendet werden soll. Wenn Sie den Parameter <codeph>radix</codeph> nicht angeben, wird als Standardwert <codeph>10</codeph> verwendet.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt den Wert des uint-Objekts als String zurück.
	 
     </apiDesc><example>Im folgenden Beispiel werden für die <codeph>radix</codeph>-Parameter die Werte 2 und 8 verwendet, und es wird ein String mit der entsprechenden Repräsentation der Zahl 9 ausgegeben.
	 <pre>
	 var myuint:uint = 9;
	 trace(myuint.toString(2)); // 1001
	 trace(myuint.toString(8)); // 11
	 </pre>
	 Das folgende Beispiel erstellt Hexadezimalwerte:
	 <pre>
	 var r:uint = 250;
	 var g:uint = 128;
	 var b:uint = 114;
	 var rgb:String = "0x" + r.toString(16) + g.toString(16) + b.toString(16);
	 trace(rgb); // 0xfa8072 
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Gibt den uint-Grundwert des angegebenen uint-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der uint-Grundwert dieses uint-Objekts.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt den uint-Grundwert des angegebenen uint-Objekts zurück.
	 
	 </apiDesc><example>Das folgende Beispiel gibt den Grundwert des Objekts <codeph> numSocks</codeph> aus.
	 <pre>
	 var numSocks:uint = 2;
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="uint:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	Die größte darstellbare vorzeichenlose 32-Bit-Ganzzahl, nämlich 4.294.967.295.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4294967295</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
	Die größte darstellbare vorzeichenlose 32-Bit-Ganzzahl, nämlich 4.294.967.295.
	
   	</apiDesc><example>Der folgende ActionScript-Code zeigt die den größten und kleinsten darstellbaren <codeph>uint</codeph>-Wert an:
	<pre>
	trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	</pre>
	<p>Die Werte sind wie folgt:</p>
	<pre>
	uint.MIN_VALUE = 0
	uint.MAX_VALUE = 4294967295
	</pre>
	
	</example></apiValueDetail></apiValue><apiValue id="uint:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 Die kleinste darstellbare vorzeichenlose Ganzzahl, nämlich 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Die kleinste darstellbare vorzeichenlose Ganzzahl, nämlich <codeph>0</codeph>.
	 
	 </apiDesc><example>Der folgende ActionScript-Code zeigt die den größten und kleinsten darstellbaren <codeph>uint</codeph>-Wert an:
	 <pre>
	 trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	 trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	 </pre>
	 <p>Die Werte sind wie folgt:</p>
	 <pre>
	 uint.MIN_VALUE = 0
	 uint.MAX_VALUE = 4294967295
	 </pre>
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Vector"><apiName>Vector</apiName><shortdesc>
 Mithilfe der Vector-Klasse können Sie einen Vector – ein Array, dessen Elemente alle den gleichen Datentyp aufweisen – bearbeiten und darauf zugreifen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector, Vector object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Sie können Vectors definieren (Typ-Arrays).
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mithilfe der Vector-Klasse können Sie einen Vector – ein Array, dessen Elemente alle den gleichen Datentyp aufweisen – bearbeiten und darauf zugreifen. Der Datentyp der Elemente eines Vectors wird als der <i>Basistyp</i> des Vectors bezeichnet. Der Basistyp kann jede Klasse sein, einschließlich integrierter und benutzerdefinierter Klassen. Der Basistyp wird bei der Deklaration einer Vector-Variablen und auch bei der Erstellung einer Instanz durch Aufrufen des Klassenkonstruktors festgelegt.
 
 <p>Wie bei einem Array können Sie den Array-Zugriffsoperator (<codeph>[]</codeph>) verwenden, um den Wert eines Vector-Elements festzulegen oder abzurufen. Außerdem stellen mehrere Vector-Methoden Mechanismen zum Festlegen und Abrufen von Elementwerten bereit. Dazu gehören <codeph>push()</codeph>, <codeph>pop()</codeph>, <codeph>shift()</codeph>, <codeph>unshift()</codeph> und andere. Die Eigenschaften und Methoden eines Vector-Objekts ähneln den Eigenschaften und Methoden eines Arrays, in den meisten Fällen sind sie sogar identisch. In allen Fällen, in denen Sie ein Array verwenden würden, dessen Elemente alle denselben Datentyp aufweisen, ist es empfehlenswert, stattdessen eine Vector-Instanz zu verwenden.</p>
 
 <p>Der Basistyp des Vectors wird mithilfe der Suffix-Syntax des type-Parameters festgelegt. Die Syntax des type-Parameters ist eine Sequenz, die einen Punkt (<codeph>.</codeph>), eine linke spitze Klammer (<codeph>&lt;</codeph>), einen Klassennamen, dann eine rechte spitze Klammer (<codeph>></codeph>) enthält, wie in diesem Beispiel angezeigt:</p>
 
 <codeblock>
 var v:Vector.&lt;String>;
 v = new Vector.&lt;String>();
 </codeblock>
 
 <p>In der ersten Zeile des Beispiels wird die Variable <codeph>v</codeph> als Vector.&lt;String>-Instanz deklariert. Dies bedeutet, dass sie einen Vector (ein Array) darstellt, der nur String-Instanzen enthält und von dem nur String-Instanzen abgerufen werden können. Die zweite Zeile erstellt eine Instanz des gleichen Vector-Typs (ein Vector, dessen Elemente alle String-Objekte sind) und weist ihn <codeph>v</codeph> zu.</p>
 
 <p>Eine Variable, die mit dem Vector.&lt;T>-Datentyp deklariert wurde, kann nur eine Vector-Instanz speichern, die mit dem gleichen Basistyp <codeph>T</codeph> erstellt wurde. Beispiel: Ein durch den Aufruf von <codeph>new Vector.&lt;String>()</codeph> erstellter Vector kann keiner Variablen zugewiesen werden, die mit dem Vector.&lt;int>-Datentyp deklariert wurde. Die Basistypen müssen genau übereinstimmen. Beispiel: Der folgende Code kann nicht kompiliert werden, da der Basistyp des Objekts nicht identisch mit dem deklarierten Basistyp der Variablen ist (obwohl Sprite eine Unterklasse von DisplayObject ist):</p>
 
 <codeblock>
 // This code doesn't compile even though Sprite is a DisplayObject subclass
 var v:Vector.&lt;DisplayObject> = new Vector.&lt;Sprite>();
 </codeblock>
 
 <p>Um einen Vector mit dem Basistyp <codeph>T</codeph> in einen Vector mit einer Superklasse von <codeph>T</codeph> zu konvertieren, verwenden Sie die globale <codeph>Vector()</codeph>-Funktion.</p>
 
 <p>Neben der Datentypbeschränkung unterscheidet sich die Vector-Klasse von der Array-Klasse noch durch weitere Beschränkungen:</p>
 
 <ul>
   <li>Ein Vector ist ein dichtes Array. Im Gegensatz zu einem Array, das Werte in den Indexpositionen 0 und 7 aufweisen kann, auch wenn keine Werte in den Indexpositionen 1 bis 7 vorhanden sind, muss ein Vector einen Wert (oder <codeph>null</codeph>) in jeder Indexposition aufweisen.</li>
   <li>Für einen Vector kann wahlweise eine feste Länge angegeben werden, wobei dies bedeutet, dass die Anzahl der enthaltenen Elemente nicht geändert werden kann.</li>
   <li>Der Zugriff auf die Vector-Elemente ist begrenzt. Es kann kein Wert von einer Indexposition größer als das letzte Element (<codeph>length - 1</codeph>) gelesen werden. Es kann kein Wert festgelegt werden, der eine Indexposition von mehr als eins hinter der aktuellen letzten Indexposition aufweist (anders ausgedrückt, ein Wert kann nur an einer vorhandenen Indexposition oder an der Indexposition <codeph>[length]</codeph> festgelegt werden).</li>
 </ul>
 
 <p>Aufgrund dieser Beschränkungen bietet ein Vektor zwei wichtige Vorteile gegenüber einer Array-Instanz, bei deren Elementen es sich ausschließlich um Instanzen einer Klasse handelt:</p>
 <ul>
   <li>Leistung: Bei einer Vector-Instanz erfolgen der Zugriff auf die Array-Elemente und die Iteration viel schneller als bei einem Array.</li>
   <li>Typsicherheit: Im Strict-Modus kann der Compiler Datentypfehler erkennen, z. B. wenn einem Vector ein Wert mit einem falschen Datentyp zugewiesen wird oder wenn beim Lesen eines Wertes von einem Vector der falsche Datentyp erwartet wird. Beachten Sie jedoch Folgendes: Wenn Sie einem Vector mithilfe der <codeph>push()</codeph>- oder der <codeph>unshift()</codeph>-Methode Werte hinzufügen, werden die Datentypen der Argumente während der Laufzeit und nicht bei der Kompilierung überprüft.</li>
 </ul> 
 
 </apiDesc></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[] Array-Zugriff</linktext></link><link href="#global/Vector()"><linktext>Vector()-Funktion</linktext></link><link href="#Array"><linktext>Array-Klasse</linktext></link></related-links><apiConstructor id="Vector:Vector"><apiName>Vector</apiName><shortdesc>
	 Erstellt einen Vector mit dem festgelegten Basistyp.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Die ursprüngliche Länge (Anzahl der Elemente) des Vectors. Wenn dieser Parameter größer als null ist, wird die festgestellte Anzahl der Vector-Elemente erstellt und mit dem Standardwert gefüllt, der dem Basistyp (<codeph>null</codeph> für Verweistypen) entspricht.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fixed</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob die Länge des Vectors fixiert ist (<codeph>true</codeph>) oder verändert werden kann (<codeph>false</codeph>). Dieser Wert kann auch mithilfe der <codeph>fixed</codeph>-Eigenschaft festgelegt werden.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt einen Vector mit dem festgelegten Basistyp.
	 
	 <p>Beim Aufrufen des <codeph>Vector.&lt;T>()</codeph>-Konstruktors legen Sie den Basistyp mithilfe der Syntax des type-Parameters fest. Die Syntax des type-Parameters ist eine Sequenz, die einen Punkt (<codeph>.</codeph>), eine linke spitze Klammer (<codeph>&lt;</codeph>), einen Klassennamen, dann eine rechte spitze Klammer (<codeph>></codeph>) enthält, wie in diesem Beispiel angezeigt:</p>
	 
	 <pre product="flash">
	 var v:Vector.&lt;String> = new Vector.&lt;String>();
	 </pre>
	 
	 <p>Im Gegensatz zur Array-Klasse können Sie den <codeph>Vector.&lt;T>()</codeph>-Konstruktor nicht verwenden, um eine vorab gefüllte Vector-Instanz zu erstellen. Um eine Vector-Instanz aus einem Array oder einem anderen Vector (z. B. einem Vector mit einem unterschiedlichen Basistypen) zu erstellen, verwenden Sie die globale <codeph>Vector()</codeph>-Funktion.</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="#global/Vector()"><linktext>Vector()-Funktion</linktext></link></related-links></apiConstructor><apiOperation id="Vector:AS3:concat"><apiName>concat</apiName><shortdesc>
     Verkettet die in den Parametern angegebenen Elemente mit den Elementen im Vector und erstellt einen neuen Vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.concat, concat, concatenate
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Wenn ein beliebiges Argument keine Instanz des Basistyps ist und nicht in den Basistyp konvertiert werden kann.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Vector mit dem gleichen Basistyp wie dieser Vector, der die Elemente von diesem Element enthält, gefolgt von Elementen der Parameter.
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Ein oder mehrere Werte des Basistyps dieses in einem neuen Vector zu verkettenden Vectors. Wenn Sie keine Werte übergeben, wird der neue Vector als Duplikat des ursprünglichen Vectors erstellt.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Verkettet die in den Parametern angegebenen Elemente.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Verkettet die in den Parametern angegebenen Elemente mit den Elementen im Vector und erstellt einen neuen Vector. Wenn die Parameter einen Vector festlegen, werden die Elemente dieses Vectors verkettet. 
	 
	 <codeblock>hello world</codeblock>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:every"><apiName>every</apiName><shortdesc>
	Führt für jedes Element im Vector eine Testfunktion aus, bis ein Element erreicht wird, das für die festgelegte Funktion „false“ zurückgibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein boolescher Wert <codeph>true</codeph>, falls die festgelegte Funktion beim Aufruf in allen Elementen <codeph>true</codeph> zurückgibt und andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element des Vectors ausgeführt werden soll. Diese Funktion wird mit drei Argumenten aufgerufen: Das aktuelle Element des Vectors, die Indexposition des Elements und das Vector-Objekt:
	<pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre> 
	
	<p>Die Rückruffunktion sollte einen booleschen Wert zurückgeben.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Objekt, auf das der Bezeichner <codeph>this</codeph> in der Rückruffunktion verweist, wenn die Funktion aufgerufen wird.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Führt für jedes Element im Vector eine Testfunktion aus, bis ein Element erreicht wird, das für die festgelegte Funktion <codeph>false</codeph> zurückgibt. Sie verwenden diese Methode, um zu ermitteln, ob alle Elemente in einem Vector ein Kriterium erfüllen, z. B. dass die Werte unter einer bestimmten Zahl liegen.
	
	<p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Dies ist der gebräuchlichste Weg zur Verwendung dieser Methode.</p>
	
	<p product="flash">Nehmen Sie an, dass Sie mit Flash Professional eine Funktion in einem Bild auf der Hauptzeitleiste erstellen, diese jedoch in einem anderen <codeph>this</codeph>-Kontext aufrufen möchten:</p>
	
	<pre product="flash">
	function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre>
	
	<p product="flash">Nehmen Sie weiter an, dass Sie dann die <codeph>every()</codeph>-Methode bei einem Vector mit dem Namen <codeph>myVector</codeph> verwenden:</p>
	
	<pre product="flash">
	myVector.every(myFunction, someObject);
	</pre>
	
	<p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Hauptklasse der SWF ist, kann sie nicht in einem anderen <codeph>this</codeph>-Kontext ausgeführt werden. Flash Player oder AIR geben eine Ausnahme aus, wenn dieser Code ausgeführt wird. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
	
	<pre product="flash">
	var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	    //your code here
	};
	myVector.every(myFunction, someObject);
	</pre>
	
	</apiDesc></apiOperationDetail><related-links><link href="#Vector/some()"><linktext>Vector.some()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:filter"><apiName>filter</apiName><shortdesc>
     Führt für jedes Element im Vector eine Testfunktion aus und erstellt einen neuen Vector für alle Elemente, die für die angegebene Funktion „true“ zurückgeben.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein neuer Vector, der alle Elemente des ursprünglichen Vectors enthält, für den die <codeph>callback</codeph>-Funktion <codeph>true</codeph> zurückgibt.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element des Vectors ausgeführt werden soll. Diese Funktion wird mit drei Argumenten aufgerufen: Das aktuelle Element des Vectors, die Indexposition des Elements und das Vector-Objekt:
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Objekt, auf das der Bezeichner <codeph>this</codeph> in der Rückruffunktion verweist, wenn die Funktion aufgerufen wird.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt für jedes Element im Vector eine Testfunktion aus und erstellt einen neuen Vector für alle Elemente, die für die festgelegte Funktion <codeph>true</codeph> zurückgeben. Wenn ein Element <codeph>false</codeph> zurückgibt, ist es nicht im Ergebnisvektor enthalten. Der Basistyp des Rückgabevektors stimmt mit dem Basistyp des Vectors überein, bei dem die Methode aufgerufen wurde.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Dies ist der gebräuchlichste Weg zur Verwendung dieser Methode.</p>
	 
	 <p product="flash">Nehmen Sie an, dass Sie mit Flash Professional eine Funktion in einem Bild auf der Hauptzeitleiste erstellen, diese jedoch in einem anderen <codeph>this</codeph>-Kontext aufrufen möchten:</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">Nehmen Sie weiter an, dass Sie dann die <codeph>filter()</codeph>-Methode bei einem Vector mit dem Namen <codeph>myVector</codeph> verwenden:</p>
	 
     <pre product="flash">
     var result:Vector.&lt;T> = myVector.filter(myFunction, someObject);
     </pre>
	 
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Hauptklasse der SWF ist, kann sie nicht in einem anderen <codeph>this</codeph>-Kontext ausgeführt werden. Flash Player gibt eine Ausnahme aus, wenn dieser Code ausgeführt wird. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.filter(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/map()"><linktext>Vector.map()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:forEach"><apiName>forEach</apiName><shortdesc>
     Führt für jedes Element im Vector eine Funktion aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element des Vectors ausgeführt werden soll. Diese Funktion wird mit drei Argumenten aufgerufen: Das aktuelle Element des Vectors, die Indexposition des Elements und das Vector-Objekt:
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):void;</pre>
	 <p>Jeder Rückgabewert von diesem Funktionsaufruf wird verworfen.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Objekt, auf das der Bezeichner <codeph>this</codeph> in der Rückruffunktion verweist, wenn die Funktion aufgerufen wird.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt für jedes Element im Vector eine Funktion aus.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Dies ist der gebräuchlichste Weg zur Verwendung dieser Methode.</p>
	 
	 <p product="flash">Nehmen Sie an, dass Sie mit Flash Professional eine Funktion in einem Bild auf der Hauptzeitleiste erstellen, diese jedoch in einem anderen <codeph>this</codeph>-Kontext aufrufen möchten:</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):void {
        // your code here
     }
     </pre>
	 
     <p product="flash">Nehmen Sie weiter an, dass Sie dann die <codeph>forEach()</codeph>-Methode bei einem Vector mit dem Namen <codeph>myVector</codeph> verwenden:</p>
	 
     <pre product="flash">
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Hauptklasse der SWF ist, kann sie nicht in einem anderen <codeph>this</codeph>-Kontext ausgeführt werden. Flash Player gibt eine Ausnahme aus, wenn dieser Code ausgeführt wird. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
     Sucht nach einem Element im Vector und gibt die Indexposition des Elements zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine auf Null basierende Indexposition des Elements im Vector. Wird das <codeph>searchElement</codeph>-Argument nicht gefunden, lautet der Rückgabewert -1.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>Das Element, das im Vector gesucht werden soll.
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Position im Vector, ab der die Suche nach dem Element gestartet werden soll. Wenn dieser Parameter negativ ist, wird er als <codeph>length + fromIndex</codeph> behandelt. Dies bedeutet, dass der Suchvorgang am Ende der <codeph>-fromIndex</codeph>-Elemente beginnt und von dieser Position vorwärts bis zum Ende des Vectors sucht.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Sucht nach einem Element im Vector und gibt die Indexposition des Elements zurück. Das Element wird mit dem Operator für strikte Gleichheit (<codeph>===</codeph>) verglichen.
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/lastIndexOf()"><linktext>Vector.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strikte Gleichheit)</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:join"><apiName>join</apiName><shortdesc>
     Wandelt die Elemente in einem Vector in Strings um, fügt zwischen ihnen das festgelegte Trennzeichen ein, verkettet die Elemente und gibt den Ergebnisstring zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.join, join
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein String, der aus den Elementen eines Vectors besteht, die in Strings umgewandelt und durch den angegebenen Parameter getrennt werden sollen.
     
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>,</apiData><apiDesc>Ein Zeichen oder String, mit dem die Vector-Elemente im zurückgegebenen String voneinander getrennt werden. Wenn Sie diesen Parameter weglassen, wird als Standardtrennzeichen das Komma verwendet. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Konvertiert die Elemente in einem Vector in Strings.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Wandelt die Elemente in einem Vector in Strings um, fügt zwischen ihnen das festgelegte Trennzeichen ein, verkettet die Elemente und gibt den Ergebnisstring zurück. Ein verschachtelter Vector wird immer durch ein Komma (,) getrennt und nicht durch das Trennzeichen, das an die <codeph>join()</codeph>-Methode übergeben wurde.
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
     Sucht nach einem Element im Vector, wobei von der festgelegten Indexposition nach hinten gesucht wird und gibt dann die Indexposition des übereinstimmenden Elements zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Eine auf Null basierende Indexposition des Elements im Vector. Wird das <codeph>searchElement</codeph>-Argument nicht gefunden, lautet der Rückgabewert -1.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>Das Element, das im Vector gesucht werden soll.
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Die Position im Vector, ab der die Suche nach dem Element gestartet werden soll. Der Standardwert ist der maximal zulässige Indexpositionswert. Dies bedeutet, dass der Suchvorgang beim letzten Element im Vector beginnt.
	 <p>Wenn dieser Parameter negativ ist, wird er als <codeph>length + fromIndex</codeph> behandelt. Dies bedeutet, dass der Suchvorgang am Ende der <codeph>-fromIndex</codeph>-Elemente beginnt und von dieser Position zurück bis zur Indexposition 0 sucht.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Sucht nach einem Element im Vector, wobei von der festgelegten Indexposition nach hinten gesucht wird und gibt dann die Indexposition des übereinstimmenden Elements zurück. Das Element wird mit dem Operator für strikte Gleichheit (<codeph>===</codeph>) verglichen.
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/indexOf()"><linktext>Vector.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strikte Gleichheit)</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:map"><apiName>map</apiName><shortdesc>
     Führt eine Funktion in jedem Element des Vectors aus und gibt einen neuen Vector mit Elementen zurück, die den Ergebnissen des Funktionsaufrufs in jedem Element dieses Vectors entsprechen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein neuer Vector, der die Ergebnisse des Funktionsaufrufs in jedem Element dieses Vectors enthält. Der Ergebnisvektor hat den gleichen Basistyp und <codeph>length</codeph>-Wert wie das Original.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element des Vectors ausgeführt werden soll. Diese Funktion wird mit drei Argumenten aufgerufen: Das aktuelle Element des Vectors, die Indexposition des Elements und das Vector-Objekt:
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):T;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Objekt, auf das der Bezeichner <codeph>this</codeph> in der Rückruffunktion verweist, wenn die Funktion aufgerufen wird.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt eine Funktion in jedem Element des Vectors aus und gibt einen neuen Vector mit Elementen zurück, die den Ergebnissen des Funktionsaufrufs in jedem Element dieses Vectors entsprechen. Der Ergebnisvektor hat den gleichen Basistyp und <codeph>length</codeph>-Wert wie der ursprüngliche Vector. Das Element an der Indexposition <codeph>i</codeph> im Ergebnisvektor ist das Ergebnis des Elementaufrufs an der Indexposition <codeph>i</codeph> im ursprünglichen Vector.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Dies ist der gebräuchlichste Weg zur Verwendung dieser Methode.</p>
	 
	 <p product="flash">Nehmen Sie an, dass Sie mit Flash Professional eine Funktion in einem Bild auf der Hauptzeitleiste erstellen, diese jedoch in einem anderen <codeph>this</codeph>-Kontext aufrufen möchten:</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):T {
        // your code here
     }
     </pre>
	 
     <p product="flash">Nehmen Sie weiter an, dass Sie dann die <codeph>map()</codeph>-Methode bei einem Vector mit dem Namen <codeph>myVector</codeph> verwenden:</p>
	 
     <pre product="flash">
     myVector.map(myFunction, someObject);
     </pre>
	 
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Hauptklasse der SWF-Datei ist, kann sie nicht in einem anderen <codeph>this</codeph>-Kontext ausgeführt werden. Flash Player gibt eine Ausnahme aus, wenn dieser Code ausgeführt wird. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.map(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/filter()"><linktext>Vector.filter()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:pop"><apiName>pop</apiName><shortdesc>
     Entfernt das letzte Element aus einem Vector und gibt dieses Element zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.pop, pop
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Wenn diese Methode aufgerufen wird, während <codeph>fixed</codeph> dem Wert <codeph>true</codeph> entspricht.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der Wert des letzten Elements im festgelegten Vector.
	 
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     Entfernt das letzte Element aus einem Vector und gibt dieses Element zurück. Die <codeph>length</codeph>-Eigenschaft des Vectors verringert sich um eins, wenn diese Funktion aufgerufen wird.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:push"><apiName>push</apiName><shortdesc>
     Fügt am Ende eines Vectors ein oder mehrere Elemente hinzu und gibt die neue Länge des Vectors zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.push, push
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Wenn ein beliebiges Argument keine Instanz des Basistyps <codeph>T</codeph> des Vectors ist.
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn diese Methode aufgerufen wird, während <codeph>fixed</codeph> dem Wert <codeph>true</codeph> entspricht.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die Länge des Vectors, nachdem die neuen Elemente hinzugefügt wurden.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Ein oder mehrere Werte, die an den Vector angehängt werden.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt am Ende eines Vectors ein oder mehrere Elemente hinzu und gibt die neue Länge des Vectors zurück.
	 
	 <p>Da diese Funktion mehrere Argumente akzeptieren kann, wird der Datentyp der Argumente während des Kompilierens auch im Strict-Modus nicht überprüft. Wird jedoch ein Argument übergeben, das keine Instanz des Basistyps ist, tritt zur Laufzeit eine Ausnahme auf.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:reverse"><apiName>reverse</apiName><shortdesc>
     Kehrt die Reihenfolge der Elemente im Vector um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.reverse, reverse
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der Vector mit den Elementen in umgekehrter Reihenfolge.
	 
     </apiDesc><apiType value="Vector$T"/></apiReturn></apiOperationDef><apiDesc>
     Kehrt die Reihenfolge der Elemente im Vector um. Diese Methode ändert den Vector, über den sie aufgerufen wurde.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:shift"><apiName>shift</apiName><shortdesc>
     Entfernt das erste Element aus einem Vector und gibt dieses Element zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.shift, shift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Wenn <codeph>fixed</codeph> dem Wert<codeph>true</codeph> entspricht.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das erste Element im Vector.
     
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     Entfernt das erste Element aus einem Vector und gibt dieses Element zurück. Die verbleibenden Vector-Elemente werden von ihrer ursprünglichen Position i nach i-1 verschoben.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:slice"><apiName>slice</apiName><shortdesc>
     Gibt einen neuen Vector zurück, der aus mehreren Elementen des ursprünglichen Vectors besteht, ohne dabei den ursprünglichen Vector zu ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.slice, slice
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ein Vector, der aus mehreren Elementen des ursprünglichen Vectors besteht.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Zahl, die die Indexposition des Segmentanfangs angibt. Wenn <codeph>startIndex</codeph> eine negative Zahl ist, beginnt der Startpunkt am Ende des Vectors, wobei -1 das letzte Element ist.  
     
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>Eine Zahl, die die Indexposition des Segmentendes angibt. Wenn Sie diesen Parameter weglassen, umfasst das Segment alle Elemente vom Anfang bis zum Ende des Vectors. Wenn <codeph>endIndex</codeph> eine negative Zahl ist, wird der Endpunkt vom Ende des Vectors aus festgelegt, wobei -1 das letzte Element ist.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt einen neuen Vector zurück, der aus mehreren Elementen des ursprünglichen Vectors besteht.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Gibt einen neuen Vector zurück, der aus mehreren Elementen des ursprünglichen Vectors besteht, ohne dabei den ursprünglichen Vector zu ändern. Der zurückgegebene Vector beinhaltet das <codeph>startIndex</codeph>-Element und alle Elemente bis zum <codeph>endIndex</codeph>-Element, schließt dieses jedoch nicht ein.
	 
     <p>Wenn Sie keine Parameter übergeben, wird eine Kopie des ursprünglichen Vectors erstellt.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:some"><apiName>some</apiName><shortdesc>
     Führt für jedes Element im Vector eine Testfunktion aus, bis ein Element erreicht wird, das „true“ zurückgibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Der boolesche Wert <codeph>true</codeph>, wenn ein Element im Vector für die festgelegte Funktion <codeph>true</codeph> zurückgibt; andernfalls <codeph>false</codeph>.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die für jedes Element des Vectors ausgeführt werden soll. Diese Funktion wird mit drei Argumenten aufgerufen: Das aktuelle Element des Vectors, die Indexposition des Elements und das Vector-Objekt:
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean</pre> 
     
     <p>Die Rückruffunktion sollte einen booleschen Wert zurückgeben.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Objekt, auf das der Bezeichner <codeph>this</codeph> in der Rückruffunktion verweist, wenn die Funktion aufgerufen wird.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt für jedes Element im Vector eine Testfunktion aus, bis ein Element erreicht wird, das <codeph>true</codeph> zurückgibt. Verwenden Sie diese Methode, um festzustellen, ob alle Elemente in einem Vector ein Kriterium erfüllen, z. B. dass die Werte unter einer bestimmten Zahl liegen.
     
     <p product="flash">Für diese Methode muss der zweite Parameter (<codeph>thisObject</codeph>) den Wert <codeph>null</codeph> haben, wenn der erste Parameter (<codeph>callback</codeph>) ein Methodenabschluss ist. Dies ist der gebräuchlichste Weg zur Verwendung dieser Methode.</p>
	 
	 <p product="flash">Nehmen Sie an, dass Sie eine Funktion in einem Bild auf der Hauptzeitleiste erstellen, diese jedoch in einem anderen <codeph>this</codeph>-Kontext aufrufen möchten:</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">Nehmen Sie weiter an, dass Sie dann die <codeph>some()</codeph>-Methode bei einem Vector mit dem Namen <codeph>myVector</codeph> verwenden:</p>
	 
     <pre product="flash">
     myVector.some(myFunction, someObject);
     </pre>
	 
     <p product="flash">Da <codeph>myFunction</codeph> ein Mitglied der Hauptklasse der SWF-Datei ist, kann sie nicht in einem anderen <codeph>this</codeph>-Kontext ausgeführt werden. Flash Player gibt eine Ausnahme aus, wenn dieser Code ausgeführt wird. Sie können diesen Laufzeitfehler vermeiden, indem Sie die Funktion wie folgt einer Variable zuweisen:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.some(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:sort"><apiName>sort</apiName><shortdesc>
     Sortiert die Elemente im Vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.sort, sort
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Dieser Vector mit Elementen in der neuen Reihenfolge.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>compareFunction</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Eine Vergleichsmethode, die das Verhalten der Sortierung ermittelt.
	 
     <p>Die festgelegte Methode muss zwei Argumente vom Basistyp (<codeph>T</codeph>) des Vectors aufweisen und eine Zahl zurückgeben:</p>
	 
	 <codeblock>function compare(x:T, y:T):Number {}</codeblock>
	 
	 <p>Die Logik der <codeph>compareFunction</codeph>-Funktion besteht darin, bei zwei gegebenen Elementen <codeph>x</codeph> und <codeph>y</codeph> einen der drei folgenden Werte zurückzugeben:</p>
	 
     <ul>
       <li>Eine negative Zahl, wenn <codeph>x</codeph> vor <codeph>y</codeph> in der sortierten Sequenz eingeblendet werden sollte</li>
       <li>0, wenn <codeph>x</codeph> und <codeph>y</codeph> einander entsprechen</li>
       <li>Eine positive Zahl, wenn <codeph>x</codeph> in der sortierten Sequenz nach <codeph>y</codeph> eingeblendet werden soll</li>
     </ul>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Sortiert die Elemente im Vector. Diese Methode sortiert nach der Funktion, die als <codeph>compareFunction</codeph>-Parameter bereitgestellt wurde.
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:splice"><apiName>splice</apiName><shortdesc>
     Fügt einem Vector Elemente hinzu bzw. entfernt diese.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.splice, splice
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Wenn die <codeph>startIndex</codeph>- und <codeph>deleteCount</codeph>-Argumente eine zu löschende Indexposition festlegen, die sich außerhalb der Grenzen des Vectors befindet.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn diese Methode aufgerufen wird, während <codeph>fixed</codeph> dem Wert <codeph>true</codeph> entsprich, und der <codeph>splice()</codeph>-Vorgang den <codeph>length</codeph>-Wert des Vectors ändert.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Vector, der die aus dem ursprünglichen Vector entfernten Elemente enthält.
     
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die Indexposition des Vector-Elements angibt, an der der Einfüge- oder Löschvorgang beginnt. Sie können hier negative Ganzzahlen verwenden, um eine Position in Bezug auf das Ende des Vectors anzugeben (so ist -1 das letzte Element des Vectors).
	 
     </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die Anzahl der zu löschenden Elemente angibt. Diese Zahl schließt das im <codeph>startIndex</codeph>-Parameter angegebene Element ein. Wenn kein Wert für den <codeph>deleteCount</codeph>-Parameter festgelegt ist, löscht die Methode alle Werte des <codeph>startIndex</codeph>-Elements bis zum letzten Vector-Element. Wenn der Wert 0 lautet, werden keine Elemente gelöscht.
	 
     </apiDesc></apiParam><apiParam><apiItemName>items</apiItemName><apiType value="restParam"/><apiDesc>Eine optionale Liste mit mindestens zwei durch Kommas getrennten Werten, die an der durch den Parameter <codeph>startIndex</codeph> angegebenen Position in den Vektor einzufügen sind.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt einem Vector Elemente hinzu bzw. entfernt diese. Bei dieser Methode werden Änderungen am Vector vorgenommen, ohne eine Kopie zu erstellen.
	 
     <p><b>Hinweis:</b> Um diese Methode in einer Vector-Unterklasse zu überschreiben, verwenden Sie, wie im folgenden Beispiel gezeigt, <codeph>...args</codeph> für die Parameter:</p>
	 
     <pre>
     public override function splice(...args) {
       // your statements here
     }
     </pre>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     Gibt einen String zurück, der die Elemente im angegebenen Vector repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String mit Vector-Elementen.
	 
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Gibt einen String zurück, der die Elemente im angegebenen Vector repräsentiert. Alle Vector-Elemente von der Indexposition 0 bis zur höchsten Indexposition werden in einen verketteten, durch Kommas getrennten String konvertiert. In der ActionScript 3.0-Implementierung gibt diese Methode den gleichen Wert wie die <codeph>Vector.toString()</codeph>-Methode zurück.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/toString()"><linktext>Vector.toString()</linktext></link></related-links></apiOperation><apiOperation id="Vector:toString"><apiName>toString</apiName><shortdesc>
     Gibt einen String zurück, der die Elemente im Vector repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.toString, toString
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String mit Vector-Elementen.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Gibt einen String zurück, der die Elemente im Vector repräsentiert. Alle Vector-Elemente von der Indexposition 0 bis zur höchsten Indexposition werden in einen verketteten, durch Kommas getrennten String konvertiert. Verwenden Sie die <codeph>Vector.join()</codeph>-Methode, um ein benutzerdefiniertes Trennzeichen festzulegen.
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Vector/join()"><linktext>Vector.join()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     Fügt am Beginn eines Vectors ein oder mehrere Elemente hinzu und gibt die neue Länge des Vectors zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.unshift, unshift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Wenn ein beliebiges Argument keine Instanz des Basistyps <codeph>T</codeph> des Vectors ist.
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn diese Methode aufgerufen wird, während <codeph>fixed</codeph> dem Wert <codeph>true</codeph> entspricht.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Eine Ganzzahl, die die neue Länge des Vectors darstellt.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Eine oder mehrere Instanzen des Basistyps des Vectors, die am Anfang des Vectors eingefügt werden sollen.  
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt am Beginn eines Vectors ein oder mehrere Elemente hinzu und gibt die neue Länge des Vectors zurück. Die anderen Elemente in diesem Vector werden von ihrer ursprünglichen Position i nach i + der Anzahl der neuen Elemente verschoben.
     
	 <p>Da diese Funktion mehrere Argumente akzeptieren kann, wird der Datentyp der Argumente während des Kompilierens auch im Strict-Modus nicht überprüft. Wird jedoch ein Argument übergeben, das keine Instanz des Basistyps ist, tritt zur Laufzeit eine Ausnahme auf.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link></related-links></apiOperation><apiValue id="Vector:fixed:get"><apiName>fixed</apiName><shortdesc>
     Zeigt an, ob die length-Eigenschaft des Vectors geändert werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.fixed, fixed
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Zeigt an, ob die <codeph>length</codeph>-Eigenschaft des Vectors geändert werden kann. Wenn der Wert <codeph>false</codeph> ist, kann die <codeph>length</codeph>-Eigenschaft nicht geändert werden. Dies bedeutet, dass die folgenden Vorgänge nicht zulässig sind, wenn <codeph>fixed</codeph> dem Wert <codeph>true</codeph> entspricht:
	 
	 <ul>
	   <li>direktes Festlegen der <codeph>length</codeph>-Eigenschaft</li>
	   <li>Zuweisen eines Wertes zur Indexposition <codeph>length</codeph></li>
	   <li>Aufrufen einer Methode, die die <codeph>length</codeph>-Eigenschaft ändert, einschließlich:
	     <ul>
	       <li><codeph>pop()</codeph></li>
	       <li><codeph>push()</codeph></li>
	       <li><codeph>shift()</codeph></li>
	       <li><codeph>unshift()</codeph></li>
	       <li><codeph>splice()</codeph> (wenn der <codeph>splice()</codeph>-Aufruf den <codeph>length</codeph>-Wert des Vectors ändert).</li>
	     </ul>
	   </li>
	 </ul>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="Vector:length:get"><apiName>length</apiName><shortdesc>
     Der Bereich der gültigen Indexpositionen, die im Vector verfügbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.length, length
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Wenn diese Eigenschaft geändert wird, während <codeph>fixed</codeph> dem Wert <codeph>true</codeph> entspricht.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn diese Eigenschaft auf einen Wert festgelegt ist, der höher als die maximal zulässige Indexposition ist (2<sup>32</sup>).
	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Der Bereich der gültigen Indexpositionen, die im Vector verfügbar sind. Eine Vector-Instanz hat Indexpositionen bis zum <codeph>length</codeph>-Wert, schließen diesen jedoch nicht ein.
	 
	 <p>Jedes Vector-Element hat immer einen Wert, der eine Instanz des Basistyps oder <codeph>null</codeph> ist. Wenn für die <codeph>length</codeph>-Eigenschaft ein Wert festgelegt wird, der größer als der vorhergehende ist, werden zusätzliche Elemente erstellt und mit dem Standardwert gefüllt, der dem Basistyp (<codeph>null</codeph> für Verweistypen) entspricht.</p>
	 
	 <p>Wenn für die <codeph>length</codeph>-Eigenschaft ein Wert festgelegt wird, der kleiner als der vorhergehende ist, werden alle Elemente in den Indexpositionen, die größer oder gleich dem neuen <codeph>length</codeph>-Wert sind, vom Vector entfernt.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>