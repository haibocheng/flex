<?xml version="1.0"?>
<apiPackage id="flash.data"><apiName>flash.data</apiName><apiDetail/><apiClassifier id="flash.data:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
 Die in einer „SQLViewSchema“-Instanz enthaltenen Informationen beschreiben eine bestimmte Ansicht in einer Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLTableSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die in einer „SQLViewSchema“-Instanz enthaltenen Informationen beschreiben eine bestimmte Ansicht in einer Datenbank. Zu den verfügbaren Informationen gehören der Name der Ansicht (die <codeph>name</codeph>-Eigenschaft), die SQL-Anweisung, mit der die Ansicht erstellt wurde (die <codeph>sql</codeph>-Eigenschaft) und Informationen zu den Ansichtsspalten (die <codeph>columns</codeph>-Eigenschaft).
 
 <p>Um die Ansichtsschemainformationen für eine Datenbank zu erhalten, laden Sie die Schemainformationen mithilfe der Methode <codeph>SQLConnection.loadSchema()</codeph>. Achten Sie dabei darauf, dass <codeph>null</codeph> oder <codeph>SQLViewSchema</codeph> als Wert für das Argument <codeph>type</codeph> angegeben ist. Die <codeph>views</codeph>-Eigenschaft der resultierenden „SQLSchemaResult“-Instanz enthält ein Array mit „SQLViewSchema“-Instanzen, die die Ansichten in der Datenbank repräsentieren.</p>
 
 <p>Im Allgemeinen werden „SQLViewSchema“-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLViewSchema:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
     Erstellt eine „SQLViewSchema“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der zugeordneten Datenbank. 
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Ansicht.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die SQL-Anweisung, mit der die Ansicht erstellt wurde.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit „SQLColumnSchema“-Instanzen, die die Ansichtsspalten beschreiben.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLViewSchema“-Instanz. Im Allgemeinen wird der „SQLViewSchema“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Schemainformationen für eine Datenbank erhalten Sie durch einen Aufruf der Methode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.data:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
 Die in der „SQLColumnSchema“-Klasse enthaltenen Informationen beschreiben die Charakteristiken einer spezifischen Spalte in einer Tabelle der Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die in der „SQLColumnSchema“-Klasse enthaltenen Informationen beschreiben die Charakteristiken einer spezifischen Spalte in einer Tabelle der Datenbank.
 
 <p>Um die Spaltenchemainformationen für eine oder mehrere Tabellen einer Datenbank zu erhalten, laden Sie die Schemainformationen mithilfe der Methode <codeph>SQLConnection.loadSchema()</codeph>. Achten Sie dabei darauf, dass <codeph>true</codeph> als Wert für das Argument <codeph>includeColumnSchema</codeph> angegeben ist. In der daraus resultierenden SQLSchemaResult-Instanz enthält jede Tabelle und Ansichtsdefinition eine Eigenschaft <codeph>columns</codeph>, ein Array mit SQLColumnSchema-Instanzen, welche die Spalten in der Tabelle oder Ansicht repräsentieren.</p>
 
 <p>Im Allgemeinen werden SQLColumnSchema-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLColumnSchema:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
     Erstellt eine „SQLColumnSchema“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Spalte.
     
     </apiDesc></apiParam><apiParam><apiItemName>primaryKey</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Gibt an, ob diese Spalte ein Teil des Primärschlüssels für die verknüpfte Tabelle ist.
     
     </apiDesc></apiParam><apiParam><apiItemName>allowNull</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Gibt an, ob diese Spalte <codeph>NULL</codeph>-Werte enthalten kann.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoIncrement</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Gibt an, ob der Wert dieser Spalte automatisch inkrementiert wird.
     
     </apiDesc></apiParam><apiParam><apiItemName>dataType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der deklarierte Spaltentyp.
     
     </apiDesc></apiParam><apiParam><apiItemName>defaultCollationType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die für diese Spalte festgelegte Vergleichsreihenfolge. Dieser Wert entspricht einer der Konstanten in der „SQLCollationType“-Klasse:
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> gibt an, dass die Spalte die Vergleichsreihenfolge <codeph>BINARY</codeph> verwendet.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> gibt an, dass die Spalte die Vergleichsreihenfolge <codeph>NOCASE</codeph> verwendet, d. h. bei Textvergleichen wird zwischen Groß- und Kleinschreibung unterschieden.</li>
     </ul>
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLColumnSchema“-Instanz. Im Allgemeinen wird der „SQLColumnSchema“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Schemainformationen für eine Datenbank erhalten Sie durch einen Aufruf der Methode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLColumnSchema:allowNull:get"><apiName>allowNull</apiName><shortdesc>
     Gibt an, ob in dieser Spalte „NULL“-Werte gestattet sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob in dieser Spalte <codeph>NULL</codeph>-Werte gestattet sind. Eine Spalte mit der Einschränkung <codeph>NOT NULL</codeph> weist den Wert <codeph>false</codeph> für die <codeph>allowNull</codeph>-Eigenschaft auf.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:autoIncrement:get"><apiName>autoIncrement</apiName><shortdesc>
     Gibt an, ob der Wert dieser Spalte automatisch inkrementiert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob der Wert dieser Spalte automatisch inkrementiert wird. Bei einer automatisch inkrementierten Spalte handelt es sich um einen speziellen Typ der Spalte <codeph>PRIMARY KEY</codeph>, deren Wert bei der Einfügung einer neuen Zeile in die Tabelle automatisch als nächster Wert in der Reihe von Ganzzahlen erstellt wird.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:dataType:get"><apiName>dataType</apiName><shortdesc>
     Ruft den Datentyp der Spalte als String auf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ruft den Datentyp der Spalte als String auf. Bei dem Wert handelt es sich um den eigentlichen Datentypnamen, der in der Anweisung <codeph>CREATE TABLE</codeph>, mit der die Tabelle definiert wird, angegeben ist. Wenn kein Datentyp angegeben ist, lautet der Wert <codeph>null</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:defaultCollationType:get"><apiName>defaultCollationType</apiName><shortdesc>
     Gibt die standardmäßige Vergleichsreihenfolge an, die für diese Spalte festgelegt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die standardmäßige Vergleichsreihenfolge an, die für diese Spalte festgelegt wurde. Der Wert dieser Eigenschaft entspricht einer der Konstanten in der „SQLCollationType“-Klasse:
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> gibt an, dass die Spalte die Vergleichsreihenfolge <codeph>BINARY</codeph> verwendet.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> gibt an, dass die Spalte die <codeph>NOCASE</codeph>-Vergleichsreihenfolge verwendet, d. h. bei Textvergleichen wird die Groß- und Kleinschreibung nicht berücksichtigt.</li>
     </ul>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnSchema:name:get"><apiName>name</apiName><shortdesc>
     Ruft den Namen der Spalte ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ruft den Namen der Spalte ab.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:primaryKey:get"><apiName>primaryKey</apiName><shortdesc>
     Gibt an, ob es sich bei dieser Spalte um die Primärschlüssselspalte (oder eine der Primärschlüssselspalten bei einem zusammengesetzten Schlüssel) der zugewiesenen Tabelle handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob es sich bei dieser Spalte um die Primärschlüssselspalte (oder eine der Primärschlüssselspalten bei einem zusammengesetzten Schlüssel) der zugewiesenen Tabelle handelt.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLColumnNameStyle"><apiName>SQLColumnNameStyle</apiName><shortdesc>
 Diese Klasse enthält die Konstanten, die die möglichen Werte der Eigenschaft „SQLConnection.columnNameStyle“ darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Diese Klasse enthält die Konstanten, die die möglichen Werte der Eigenschaft <codeph>SQLConnection.columnNameStyle</codeph> darstellen. Diese Werte geben die verschiedenen Optionen an, mit denen gesteuert wird, wie Spaltennamen (Eigenschaftsnamen) in den als Ergebnis einer SQL <codeph>SELECT</codeph>-Anweisung zurückgegebenen Objekte formatiert werden.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links><apiValue id="flash.data:SQLColumnNameStyle:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
     Gibt an, das die von einer „SELECT“-Anweisung zurückgegebenen Spaltennamen das Standardformat aufweisen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, das die von einer <codeph>SELECT</codeph>-Anweisung zurückgegebenen Spaltennamen das Standardformat aufweisen. Im Standardformat lauten·Spaltennamen <codeph>[tabellenname]_[spaltenname]</codeph>, wenn die Anweisung <codeph>SELECT</codeph> mehrere Tabellen enthält, oder <codeph>[spaltenname]</codeph>, wenn die Anweisung <codeph>SELECT</codeph> eine Tabelle enthält.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:LONG"><apiName>LONG</apiName><shortdesc>
     Gibt an, das die von einer „SELECT“-Anweisung zurückgegebenen Spaltennamen das lange Spaltennamenformat aufweisen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>long</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, das die von einer <codeph>SELECT</codeph>-Anweisung zurückgegebenen Spaltennamen das lange Spaltennamenformat aufweisen. In diesem Format lauten Spaltennamen <codeph>[tabellenname]_[spaltenname]</codeph>, unabhängig davon, wieviele Tabellen die Anweisung <codeph>SELECT</codeph> enthält.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:SHORT"><apiName>SHORT</apiName><shortdesc>
     Gibt an, das die von einer „SELECT“-Anweisung zurückgegebenen Spaltennamen das kurze Spaltennamenformat aufweisen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>short</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, das die von einer <codeph>SELECT</codeph>-Anweisung zurückgegebenen Spaltennamen das kurze Spaltennamenformat aufweisen. In diesem Format lauten Spaltennamen <codeph>[spaltenname]</codeph>, unabhängig davon, wieviele Tabellen die Anweisung <codeph>SELECT</codeph> enthält.
	 
	 <p>Enthält der Ergebnissatz mehrere Spalten mit demselben Namen, so wird dem Ergebnisobjekt nur eine Eigenschaft mit diesem Namen hinzugefügt. Der dieser Eigenschaft zugewiesene Wert stammt aus der letzten Spalte dieses Namens in der Ergebniszeile. Betrachten Sie sich als Beispiel die folgende <codeph>SELECT</codeph>-Anweisung:</p>
	 
	 <pre>
	 SELECT customers.customerId, addresses.customerId
	 FROM customers INNER JOIN addresses
	    ON customers.customerId = addresses.customerId
	 </pre>
	 
	 <p>Bei der Ausführung dieser Anweisung für eine SQLConnection mit kurzen Spaltennamen weist jedes Ergebnisobjekt eine Eigenschaft namens <codeph>customerId</codeph> auf. Diese Eigenschaft weist den Wert aus der in der Tabelle <codeph>addresses</codeph> enthaltenen Spalte <codeph>customerId</codeph> auf.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
 Bei der „SQLSchema“-Klasse handelt es sich um die Basisklasse für Schemainformationen zu Datenbankobjekten, wie etwa Tabellen, Ansichten und Indizes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Bei der „SQLSchema“-Klasse handelt es sich um die Basisklasse für Schemainformationen zu Datenbankobjekten, wie etwa Tabellen, Ansichten und Indizes.
 
 <p>Um Schemainformationen für eine Datenbank erhalten, laden Sie Schemainformationen mithilfe der Methode <codeph>SQLConnection.loadSchema()</codeph>. Die daraus resultierende „SQLSchemaResult“-Instanz enthält Arrays mit Instanzen, die die Objekte in der Datenbank darstellen.</p>
 
 <p>Im Allgemeinen werden „SQLSchema“-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchema:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
     Erstellt eine „SQLSchema“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der zugeordneten Datenbank. 
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des Datenbankobjekts. 
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die SQL, mit der das Datenbankobjekt erstellt wurde.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLSchema“-Instanz. Im Allgemeinen wird der „SQLSchema“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Schemainformationen für eine Datenbank erhalten Sie durch einen Aufruf der Methode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLSchema:database:get"><apiName>database</apiName><shortdesc>
     Der Name der Datenbank, zu der dieses Schemaobjekt gehört.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Der Name der Datenbank, zu der dieses Schemaobjekt gehört. Der Name der Hauptdatenbank, die einer „SQLConnection“-Instanz zugewiesen ist, lautet „main“ (die Datenbankdatei, die durch den Aufruf der Methode <codeph>open()</codeph> oder <codeph>openAsync()</codeph> einer „SQLConnection“-Instanz geöffnet wurde). Bei anderen Datenbanken, die mithilfe der Methode <codeph>SQLConnection.attach()</codeph> mit der Verbindung verknüpft sind, handelt es sich bei dem Wert um den Namen, der im Aufruf der Methode <codeph>attach()</codeph> angegeben wurde.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>flash.data.SQLConnection.attach()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchema:name:get"><apiName>name</apiName><shortdesc>
     Der Name dieses Schemaobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Der Name dieses Schemaobjekts. Jedes Objekt in einer Datenbank trägt einen eindeutigen Namen. Der Name ist in der SQL-Anweisung festgelegt, mit der das Objekt erstellt wird (wie etwa die <codeph>CREATE TABLE</codeph>-Anweisung für eine Tabelle).
	 
	 <p>Wenn beispielsweise ein Datenbankindex mithilfe der folgenden SQL-Anweisung erstellt wird, lautet der Wert der Eigenschaft <codeph>name</codeph> für dieses Indexschema <codeph>"customer_index":</codeph></p>
	 
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLSchema:sql:get"><apiName>sql</apiName><shortdesc>
     Gibt den gesamten Text der SQL-Anweisung zurück, mit der dieses Schemaobjekt erstellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt den gesamten Text der SQL-Anweisung zurück, mit der dieses Schemaobjekt erstellt wurde. Jedes in einer Datenbank enthaltene Objekt wird mithilfe einer SQL-Anweisung erstellt.
	 
	 <p>Wenn beispielsweise ein Datenbankindex mithilfe der folgenden SQL-Anweisung erstellt wird:</p>
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
	 <p>handelt es sich bei der Eigenschaft <codeph>sql</codeph> für das Indexschema um den gesamten Text der Anweisung.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLCollationType"><apiName>SQLCollationType</apiName><shortdesc>
 Diese Klasse enthält sowohl die Konstanten, die die möglichen Werte für den defaultCollationType-Parameter im SQLColumnSchema-Konstruktor darstellen, als auch diejenigen, für die SQLColumnSchema.defaultCollationType-Eigenschaft.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Diese Klasse enthält sowohl die Konstanten, die die möglichen Werte für den <codeph>defaultCollationType</codeph>-Parameter im SQLColumnSchema-Konstruktor darstellen, als auch diejenigen, für die <codeph>SQLColumnSchema.defaultCollationType</codeph>-Eigenschaft.
 
 <p>Diese Werte repräsentieren verschiedene Vergleichsreihenfolgen, die für eine Spalte in einer Datenbanktabelle angegeben werden können. Mithilfe einer <i>Vergleichsreihenfolge</i> können Daten sortiert und verglichen werden, z. B. ob in der Datenbank zwischen Groß- und Kleinschreibung unterschieden wird.</p>
 
 <p>Weitere Informationen zur Definition und Verwendung von Vergleichsreihenfolgen finden Sie im Abschnitt „<xref href="../../localDatabaseSQLSupport.html#collate">COLLATE</xref>“ im Anhang „<xref href="../../localDatabaseSQLSupport.html">SQL-Unterstützung in lokalen Datenbanken</xref>“.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links><apiValue id="flash.data:SQLCollationType:BINARY"><apiName>BINARY</apiName><shortdesc>
     Gibt an, dass die Vergleichsreihenfolge „BINARY“ auf die Spalte angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, dass die Vergleichsreihenfolge <codeph>BINARY</codeph> auf die Spalte angewendet wird. Bei <codeph>SQLCollationType.BINARY</codeph> werden zwei Werte anhand ihres Bytewertes verglichen, die Textkodierung der Zeichen wird nicht berücksichtigt.
	 
	 <p>Wenn ein binärer Vergleich auf Werte der <codeph>TEXT</codeph>-Speicherklasse angewendet wird, wird beim Sortieren und Vergleichen der Spaltenwerte in der Datenbank zwischen Groß- und Kleinschreibung unterschieden.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLCollationType:NO_CASE"><apiName>NO_CASE</apiName><shortdesc>
     Gibt an, dass die Vergleichsreihenfolge „NOCASE“ auf die Spalte angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noCase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, dass die Vergleichsreihenfolge <codeph>NOCASE</codeph> auf die Spalte angewendet wird. Bei <codeph>SQLCollationType.NO_CASE</codeph> wird beim Sortieren und Vergleichen von Werten nicht zwischen Groß- und Kleinschreibung unterschieden.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTransactionLockType"><apiName>SQLTransactionLockType</apiName><shortdesc>
 Diese Klasse enthält die Konstanten, die die möglichen Werte des Parameters „option“ der Methode „SQLConnection.begin()“ darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Diese Klasse enthält die Konstanten, die die möglichen Werte des Parameters <codeph>option</codeph> der Methode <codeph>SQLConnection.begin()</codeph> darstellen.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links><apiValue id="flash.data:SQLTransactionLockType:DEFERRED"><apiName>DEFERRED</apiName><shortdesc>
     Gibt die verzögerte Sperrtransaktionsoption an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>deferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die verzögerte Sperrtransaktionsoption an. Eine verzögerte Sperrtransaktion erwirbt erst beim ersten Zugriff auf die Datenbank eine Sperre. Bei einer verzögerten Transaktion wird eine Sperre erst beim ersten Lese- oder Schreibvorgang erworben.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:EXCLUSIVE"><apiName>EXCLUSIVE</apiName><shortdesc>
     Gibt die exklusive·Sperrtransaktionsoption an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exclusive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die exklusive·Sperrtransaktionsoption an. Eine exklusive·Sperrtransaktion erwirbt sofort eine Sperre an der Datenbank. Andere „SQLStatement“-Objekte, die über eine andere SQLConnection (in derselben oder einer anderen AIR-Anwendung) an derselben Datenbank ausgeführt werden, können weder Daten in der Datenbank lesen noch Daten in die Datenbank schreiben.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:IMMEDIATE"><apiName>IMMEDIATE</apiName><shortdesc>
     Gibt die sofortige Sperrtransaktionsoption an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>immediate</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die sofortige Sperrtransaktionsoption an. Eine sofortige Sperrtransaktion erwirbt sofort eine Sperre an der Datenbank. „SQLStatement“-Objekte, die über eine andere SQLConnection (in derselben oder einer anderen AIR-Anwendung) an derselben Datenbank ausgeführt werden, können Daten in der Datenbank lesen, aber keine Daten in die Datenbank schreiben. Wenn andere Verbindungen Daten in der Datenbank lesen, gilt jedoch, dass der ursprüngliche Status der Daten in der Datenbank identisch ist mit dem Status der Datenbank, bevor durch die Eingangstransaktion der „SQLConnection“-Instanz die Methode <codeph>begin()</codeph> aufgerufen wurde. Alle ungebundenen Datenänderungen, die im Rahmen einer sofortigen Sperrtransaktion vorgenommen wurden, stehen anderen Verbindungen nicht zur Verfügung.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
 Eine „SQLSchemaResult“-Instanz enthält die Informationen, die aus einem Aufrufen der Methode „SQLConnection.loadSchema()“ resultieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Eine „SQLSchemaResult“-Instanz enthält die Informationen, die aus einem Aufrufen der Methode <codeph>SQLConnection.loadSchema()</codeph> resultieren. Sie enthält vier Arrayeigenschaften mit den angeforderten Schemadaten, die auf den Argumentwerten beim Aufrufen von <codeph>SQLConnection.loadSchema()</codeph> basieren.
 
 <p>Um die „SQLSchemaResult“-Instanz für einen Aufruf von <codeph>SQLConnection.loadSchema()</codeph> abzurufen, müssen Sie die Methode <codeph>getSchemaResult()</codeph> der „SQLConnection“-Instanz aufrufen. Im Allgemeinen werden „SQLSchemaResult“-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchemaResult:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
     Erstellt eine „SQLSchemaResult“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>tables</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit „SQLTableSchema“-Instanzen, wie in der Anforderung <codeph>loadSchema()</codeph> angegeben.
     
     </apiDesc></apiParam><apiParam><apiItemName>views</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit „SQLViewSchema“-Instanzen, wie in der Anforderung <codeph>loadSchema()</codeph> angegeben.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit „SQLIndexSchema“-Instanzen, wie in der Anforderung <codeph>loadSchema()</codeph> angegeben.
     
     </apiDesc></apiParam><apiParam><apiItemName>triggers</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit „SQLTriggerSchema“-Instanzen, wie in der Anforderung <codeph>loadSchema()</codeph> angegeben.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLSchemaResult“-Instanz. Im Allgemeinen wird der „SQLSchemaResult“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Schemainformationen für eine Datenbank erhalten Sie durch einen Aufruf der Methode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLSchemaResult:indices:get"><apiName>indices</apiName><shortdesc>
     Ein Array mit „SQLIndexSchema“-Instanzen, die in einem Aufruf von „SQLConnection.loadSchema()“ angefordert wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array mit SQLIndexSchema-Instanzen, die in einem Aufruf von<codeph>SQLConnection.loadSchema()</codeph> angefordert wurden. Wenn die angegebenen Datenbanken keine Indizes enthalten oder wenn der Aufruf von <codeph>loadSchema()</codeph> angibt, dass Indizes aus dem Ergebnis ausgeschlossen werden sollen, handelt es sich bei der Eigenschaft <codeph>indices</codeph> um ein leeres Array (ein Array, dessen Eigenschaft <codeph>length</codeph> den Wert „0“ hat).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:tables:get"><apiName>tables</apiName><shortdesc>
     Ein Array mit „SQLTableSchema“-Instanzen, die in einem Aufruf von „SQLConnection.loadSchema()“ angefordert wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array mit SQLTableSchema-Instanzen, die in einem Aufruf von <codeph>SQLConnection.loadSchema()</codeph> angefordert wurden. Wenn die angegebenen Datenbanken keine Tabellen enthalten oder wenn der Aufruf von <codeph>loadSchema()</codeph> angibt, dass Tabellen aus dem Ergebnis ausgeschlossen werden sollen, handelt es sich bei der Eigenschaft <codeph>tables</codeph> um ein leeres Array (ein Array, dessen Eigenschaft <codeph>length</codeph> den Wert „0“ hat).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:triggers:get"><apiName>triggers</apiName><shortdesc>
     Ein Array mit „SQLTriggerSchema“-Instanzen, die in einem Aufruf von „SQLConnection.loadSchema()“ angefordert wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array mit SQLTriggerSchema-Instanzen, die in einem Aufruf von <codeph>SQLConnection.loadSchema()</codeph> angefordert wurden. Wenn die angegebenen Datenbanken keine Auslöser enthalten oder wenn der Aufruf von <codeph>loadSchema()</codeph> angibt, dass Auslöser aus dem Ergebnis ausgeschlossen werden sollen, handelt es sich bei der Eigenschaft <codeph>triggers</codeph> um ein leeres Array (ein Array, dessen Eigenschaft <codeph>length</codeph> den Wert „0“ hat).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:views:get"><apiName>views</apiName><shortdesc>
     Ein Array mit „SQLViewSchema“-Instanzen, die in einem Aufruf von „SQLConnection.loadSchema()“ angefordert wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array mit SQLViewSchema-Instanzen, die in einem Aufruf von <codeph>SQLConnection.loadSchema()</codeph> angefordert wurden. Wenn die angegebenen Datenbanken keine Ansichten enthalten oder wenn der Aufruf von <codeph>loadSchema()</codeph> angibt, dass Ansichten aus dem Ergebnis ausgeschlossen werden sollen, handelt es sich bei der Eigenschaft <codeph>views</codeph> um ein leeres Array (ein Array, dessen Eigenschaft <codeph>length</codeph> den Wert „0“ hat).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
 Mithilfe einer „SQLConnection“-Instanz wird die Erstellung von und Verbindung mit lokalen SQL-Datenbankdateien (lokale Datenbanken) verwaltet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mithilfe einer „SQLConnection“-Instanz wird die Erstellung von und Verbindung mit lokalen SQL-Datenbankdateien (lokale Datenbanken) verwaltet.
 
 <p>Die Funktionen der SQLConnection-Klasse werden in mehrere Kategorien unterteilt:</p>
 
 <ul>
   <li><p>Eine lokale SQL-Datenbankdatei wird durch Aufrufen der Methode <codeph>open()</codeph> oder <codeph>openAsync()</codeph> erstellt oder geöffnet. Wenn die Datenbankdatei nicht existiert, können sie mithilfe dieser Methoden wahlweise bei der Verbindungsherstellung erstellt werden. Nachdem eine Verbindung zu einer Datenbank hergestellt wurde, kann eine SQL-Anweisung erstellt und an dieser Datenbank ausgeführt werden. Dazu wird eine „SQLStatement“-Instanz erstellt und die „SQLConnection“-Instanz wird der Eigenschaft <codeph>sqlConnection</codeph> des SQLStatements zugewiesen.</p></li>
 
   <li><p>Außerdem bietet die „SQLConnection“-Klasse Anweisungen für SQL-Anweisungen, einschließlich einer Funktionalität zur Ausführung mehrerer Anweisungen in einer Transaktion, mithilfe der Methoden <codeph>begin()</codeph>, <codeph>commit()</codeph> und <codeph>rollback()</codeph>.</p></li>
 
   <li><p>Die SQLConnection-Klasse bietet Zugriff auf Datenbankschemainformationen zu den verbundenen Datenbanken. Im Schema einer Datenbank werden die Definitionen ihrer Tabellen, Spalten, Indizes und Auslöser beschrieben. Weitere Informationen finden Sie im Abschnitt zur <codeph>loadSchema()</codeph>-Methode.</p></li>
 
   <li><p>Mithilfe der SQLConnection-Klasse können Datenbanken unter Verwendung von AES-CCM verschlüsselt werden. Dadurch können Daten sowohl identifiziert als auch geschützt werden. Zum Verschlüsseln einer Datenbank muss bei deren Erstellung ein 16-Byte-Schlüssel festgelegt werden (durch ein ByteArray). Dieser Schlüssel kann später mithilfe der <codeph>SQLConnection.reencrypt()</codeph>-Methode geändert werden. Durch die Verschlüsselung wird die Leistung beim Schreiben in die Datenbank und beim Lesen daraus verringert. Die Verschlüsselung wird auf die auf der Festplatte gespeicherten Daten angewendet, nicht jedoch auf den temporären Datencache im Arbeitsspeicher. Für Datenbanken im Speicher wird die Verschlüsselung <i>nicht</i> unterstützt.</p></li>
 
   <li><p>Mithilfe einer SQLConnection-Instanz können Ereignisbenachrichtigungen auf Datenbankebene empfangen und Konfigurationssteuerungen aller Aspekte einer Datenbank, einschließlich Seitengröße im Cache, Verfahrensstornierung und Optionen zur Anweisungsausführung, vorgenommen werden.</p></li>
 </ul>
 
 <p>Eine <codeph>SQLConnection</codeph>-Instanz wird entweder im asynchronen oder im synchronen Modus ausgeführt. Für eine Ausführung im synchronen Modus verbinden Sie die „SQLConnection“-Instanz mithilfe der Methode <codeph>open()</codeph> mit der Hauptdatenbank. Für eine Ausführung im asynchronen Modus verbinden Sie die „SQLConnection“-Instanz mithilfe der Methode <codeph>openAsync()</codeph> mit der Hauptdatenbank. </p>
 
 <p>Im asynchronen Modus wird mithilfe von Ereignis-Listenern oder einer Responder-Instanz bestimmt, wann ein Vorgang erfolgreich abgeschlossen wird oder fehlschlägt. Die Vorgänge werden im Hintergrund ausgeführt und nicht im Hauptanwendungs-Thread, d. h. die Anwendung wird weiterhin ausgeführt und reagiert auch während der Ausführung der Datenbankvorgänge auf Benutzereingriffe.</p>
 
 <p>Im asynchronen Modus starten Sie einen bestimmten Vorgang durch ein Aufrufen der entsprechenden Methode. Um den Abschluss (oder das Fehlschlagen) des Vorgangs festzustellen, registrieren Sie einen Listener für das entsprechende Ereignis. Zu jedem Vorgang gibt es ein zugeordnetes Ereignis, das beim erfolgreichen Abschluss des Vorgangs ausgelöst wird. Wenn beispielsweise der Aufruf einer <codeph>openAsync()</codeph>-Methode erfolgreich abgeschlossen wird (wenn die Datenbankverbindung hergestellt wird), wird das Ereignis <codeph>open</codeph> ausgelöst. Beim Fehlschlagen eines Vorgangs wird ein <codeph>error</codeph>-Ereignis ausgelöst. Die „SQLError“-Instanz in der Eigenschaft <codeph>error</codeph> des „SQLErrorEvent“-Objekts enthält Informationen über den jeweiligen Fehler, einschließlich des versuchten Vorgangs und dem Grund für das Fehlschlagen.</p>
 
 <p>Im synchronen Modus brauchen Sie keine Ereignis-Listener zu registrieren, um den Abschluss oder das Fehlschlagen eines Vorgangs zu bestimmen. Zur Identifizierung der Fehler schließen Sie die Anweisungen, die Fehler auslösen, in einen <codeph>try..catch</codeph>-Block ein. Da synchrone Vorgänge im Hauptausführungs-Thread ausgeführt werden, werden alle Anwendungsfunktionen (einschließlich Aktualisierung des Bildschirms und Zulassen von Maus- und Tastaturinteraktion) angehalten, während der Datenbankvorgang ausgeführt wird. Bei längerfristigen Vorgängen kann dies eine spürbare Pause der Anwendung verursachen.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link><link href="flash.events.xml#SQLEvent"><linktext>flash.events.SQLEvent</linktext></link><link href="flash.events.xml#SQLErrorEvent"><linktext>flash.events.SQLErrorEvent</linktext></link><link href="flash.errors.xml#SQLError"><linktext>flash.errors.SQLError</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_en"><linktext>Kurzanleitung: Asynchrones Arbeiten mit einer lokalen SQL-Datenbank (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_flash_en"><linktext>Kurzanleitung: Asynchrones Arbeiten mit einer lokalen SQL-Datenbank (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_html_en"><linktext>Kurzanleitung: Asynchrones Arbeiten mit einer lokalen SQL-Datenbank (HTML)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_en"><linktext>Kurzanleitung: Synchrones Arbeiten mit einer lokalen SQL-Datenbank (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_flash_en"><linktext>Kurzanleitung: Synchrones Arbeiten mit einer lokalen SQL-Datenbank (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_html_en"><linktext>Kurzanleitung: Synchrones Arbeiten mit einer lokalen SQL-Datenbank (HTML)</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.UPDATE_update"><apiName>update</apiName><shortdesc>
 Wird ausgelöst, wenn sich in einer der verbundenen Datenbanken in einer Tabelle Daten aufgrund eines SQL „UPDATE“-Befehls ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.UPDATE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn sich in einer der verbundenen Datenbanken in einer Tabelle Daten aufgrund eines SQL <codeph>UPDATE</codeph>-Befehls ändern. Bei dieser Datenänderung kann es sich um ein direktes Ergebnis der Ausführung einer <codeph>UPDATE</codeph>-Anweisung durch eine SQLStatement-Instanz handeln. Es kann sich aber auch um ein indirektes Ergebnis handeln, wenn ein Auslöser auf eine Anweisungsausführung reagiert hat.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.SCHEMA_schema"><apiName>schema</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „loadSchema()“-Methode erfolgreich ausgeführt wurde und die Schemaergebnisse bereit sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.SCHEMA</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>loadSchema()</codeph>-Methode erfolgreich ausgeführt wurde und die Schemaergebnisse bereit sind.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ROLLBACK_rollback"><apiName>rollback</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „rollback()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ROLLBACK</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>rollback()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.REENCRYPT_reencrypt"><apiName>reencrypt</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer reencrypt()-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.REENCRYPT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>reencrypt()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/reencrypt()"><linktext>reencrypt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.OPEN_open"><apiName>open</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „openAsync()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.OPEN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>openAsync()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.INSERT_insert"><apiName>insert</apiName><shortdesc>
 Wird ausgelöst, wenn sich in einer der verbundenen Datenbanken in einer Tabelle Daten aufgrund eines SQL INSERT-Befehls ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.INSERT</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn sich in einer der verbundenen Datenbanken in einer Tabelle Daten aufgrund eines SQL <codeph>INSERT</codeph>-Befehls ändern. Bei dieser Datenänderung kann es sich um ein direktes Ergebnis der Ausführung einer <codeph>INSERT</codeph>-Anweisung durch eine SQLStatement-Instanz handeln, oder ein indirektes Ergebnis, wenn ein Auslöser auf eine Anweisungsausführung reagiert hat.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Wird ausgelöst, wenn ein asynchroner Vorgang des „SQLConnection“-Objekts einen Fehler ergibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein asynchroner Vorgang des „SQLConnection“-Objekts einen Fehler ergibt. Die als Ereignisobjekt ausgelöste „SQLErrorEvent“-Instanz verfügt über eine <codeph>error</codeph>-Eigenschaft und darin sind Informationen zu dem versuchten Vorgang und dem Grund für das Fehlschlagen enthalten.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DETACH_detach"><apiName>detach</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „detach()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DETACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>detach()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.DELETE_delete"><apiName>delete</apiName><shortdesc>
 Wird ausgelöst, wenn sich in einer der verbundenen Datenbanken in einer Tabelle Daten aufgrund eines SQL „DELETE“-Befehls ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.DELETE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn sich in einer der verbundenen Datenbanken in einer Tabelle Daten aufgrund eines SQL <codeph>DELETE</codeph>-Befehls ändern. Bei dieser Datenänderung kann es sich um ein direktes Ergebnis der Ausführung einer <codeph>DELETE</codeph>-Anweisung durch eine SQLStatement-Instanz handeln. Es kann sich aber auch um ein indirektes Ergebnis handeln, wenn ein Auslöser auf eine Anweisungsausführung reagiert hat.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DEANALYZE_deanalyze"><apiName>deanalyze</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „deanalyze()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DEANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>deanalyze()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMMIT_commit"><apiName>commit</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „commit()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMMIT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>commit()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CLOSE_close"><apiName>close</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „close()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>close()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMPACT_compact"><apiName>compact</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „compact()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMPACT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>compact()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/compact()"><linktext>compact()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „cancel()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>cancel()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/cancel()"><linktext>cancel()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.BEGIN_begin"><apiName>begin</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „begin()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.BEGIN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>begin()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ATTACH_attach"><apiName>attach</apiName><shortdesc>
 Wird ausgelöst, wenn der Vorgang einer „attach()“-Methode erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ATTACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vorgang einer <codeph>attach()</codeph>-Methode erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ANALYZE_analyze"><apiName>analyze</apiName><shortdesc>
 Wird ausgelöst, wenn ein „analyze()“-Vorgang erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein <codeph>analyze()</codeph>-Vorgang·erfolgreich ausgeführt wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLConnection:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
     Erstellt eine „SQLConnection“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>wenn der Konstruktor aus einer Sandbox außerhalb der Hauptanwendungs-Sandbox aufgerufen wird. 
      
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Erstellt eine „SQLConnection“-Instanz.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLConnection:addEventListener"><apiName>addEventListener</apiName><shortdesc>
     
	Registriert ein Ereignis-Listener-Objekt bei einem EventDispatcher-Objekt, sodass der Listener über ein Ereignis benachrichtigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Typ des Ereignisses.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Listener-Funktion, die das Ereignis verarbeitet. Diese Funktion muss, wie das nachfolgende Beispiel zeigt, ein Ereignisobjekt als einzigen Parameter akzeptieren und keinen<ph platform="actionscript"> Wert zurückgeben: </ph> <ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Der Name der Funktion ist beliebig.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Dieser Parameter gilt für Anzeigeobjekte in der ActionScript 3.0-Anzeigelistenarchitektur, die von SWF-Material verwendet wird.</ph> <ph platform="actionscript">Legt fest, ob der Listener in der Aufnahmephase oder in der Ziel- und Bubbling-Phase arbeitet. Ist <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt, so verarbeitet der Listener das Ereignis nur während der Aufnahmephase und nicht während der Ziel- oder Bubbling-Phase. Hat <codeph>useCapture</codeph> hingegen den Wert <codeph>false</codeph>, verarbeitet der Listener das Ereignis nur während der Ziel- oder Bubbing-Phase. Um auf das Ereignis in allen drei Phasen zu warten, rufen Sie <codeph>addEventListener()</codeph> zweimal auf; einmal ist <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt, und beim zweiten Mal hat <codeph>useCapture</codeph> den Wert <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Die Prioritätsstufe des Ereignis-Listeners. Die Priorität wird durch eine vorzeichenbehaftete 32-Bit-Ganzzahl zugewiesen. Je höher die Zahl, desto höher die Priorität. Alle Listener mit der Priorität <i>n</i> werden vor Listenern mit der Priorität <i>n</i> -1 verarbeitet. Wenn zwei oder mehr Listener die gleiche Priorität aufweisen, werden sie in der Reihenfolge verarbeitet, in der sie hinzugefügt wurden. Die Standardpriorität ist 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Legt fest, ob der Verweis auf den Listener stark oder schwach ist. Ein starker Verweis (der Standard) verhindert, dass der Listener von einem Garbage Collector entfernt wird. Ein schwacher Verweis hingegen nicht. <p>Funktionen von Mitgliedern auf Klassenebene werden nicht vom Garbagekollektor entfernt. Daher können Sie <codeph>useWeakReference</codeph> für Mitgliedsfunktionen auf Klassenebene auf <codeph>true</codeph> setzen, ohne dass sie vom Garbagekollektor entfernt werden. Wenn Sie <codeph>useWeakReference</codeph> auf <codeph>true</codeph> setzen bei einem Listener, der eine verschachtelte innere Funktion ist, wird die Funktion vom Garbagekollektor entfernt. Indem Sie Verweise auf die innere Funktion erstellen (d. h sie in einer anderen Variable speichern), umgehen Sie die Garbage Collection, sodass die Funktion permanent gespeichert bleibt.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Registriert ein Ereignis-Listener-Objekt bei einem EventDispatcher-Objekt, sodass der Listener über ein Ereignis benachrichtigt wird. <ph platform="actionscript">Sie können Ereignis-Listener bei allen Knoten in der Anzeigeliste für eine bestimmte Art von Ereignis, Phase oder Priorität registrieren.</ph>
	
	<p platform="javascript">JavaScript-Code in der AIR-Laufzeitumgebung verwendet diese Methode, um Ereignis-Listener für Ereignisse, die von den AIR-APIs definiert werden, zu registrieren. Bei anderen JavaScript-Ereignissen (wie z. B. dem <codeph>onload</codeph>-Ereignis des DOM-<codeph>body</codeph>-Objekts) können Sie Standardtechniken für Ereignisprozeduren verwenden, wie bei Inhalten, die im Browser ausgeführt werden.</p>
	
	<p>Nachdem Sie einen Ereignis-Listener erfolgreich registriert haben, können Sie seine Priorität nicht durch weitere Aufrufe von <codeph>addEventListener()</codeph> ändern. Um die Priorität eines Listeners zu ändern, müssen Sie zunächst <codeph>removeListener()</codeph> aufrufen. Anschließend können Sie den Listener mit der neuen Prioritätsstufe erneut aufrufen. </p>
	
	<p>Nach der Registrierung des Listeners haben nachfolgende Aufrufe von <codeph>addEventListener()</codeph> mit einem anderen <codeph>type</codeph>- oder <codeph>useCapture</codeph>-Wert eine separate Listener-Registrierung zur Folge. <ph platform="actionscript">Wenn Sie beispielsweise zuerst einen Listener registrieren, für den <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt ist, wird dieser nur während der Aufnahmephase aktiv sein. Wenn Sie <codeph>addEventListener()</codeph> für dasselbe Listener-Objekt erneut aufrufen, diesmal aber <codeph>useCapture</codeph> auf <codeph>false</codeph> gesetzt ist, werden zwei separate Listener angelegt: einer, der während der Aufnahmephase aktiv ist und ein zweiter, der während der Ziel- und Bubbling-Phase aktiv ist.</ph>
	</p>
	
	<p platform="actionscript">Sie können einen Ereignis-Listener nicht nur für die Ziel- oder Bubbling-Phase registrieren. Die beiden Phasen hängen während der Registrierung immer zusammen, da Bubbling nur für übergeordnete Elemente des Zielknotens gilt.</p>
	
	<p>Wenn Sie einen Ereignis-Listener nicht mehr brauchen, entfernen sie ihn, indem Sie <codeph>removeEventListener()</codeph> aufrufen. Andernfalls könnte es zu Speicherproblemen kommen. Ereignis-Listener werden nicht automatisch aus dem Speicher entfernt, da der Garbage Collector den Listener nicht entfernt, solange das auslösende Objekt vorhanden ist (sofern der <codeph>useWeakReference</codeph>-Parameter auf <codeph>true</codeph> gesetzt ist).</p>
		
	<p>Beim Kopieren einer EventDispatcher-Instanz werden zugewiesene Ereignis-Listener nicht kopiert. (Wenn ein neu angelegter Knoten einen Ereignis-Listener benötigt, müssen Sie den Listener nach dem Erstellen des Knotens zuweisen.) Wenn Sie jedoch eine EventDispatcher-Instanz verschieben, werden zugewiesene Ereignis-Listener ebenfalls verschoben.</p>
	
	
	<p platform="actionscript">Wenn der Ereignis-Listener bei einem Knoten registriert wird, während mit diesem Knoten ein Ereignis durchgeführt wird, so wird der Ereignis-Listener während der aktuellen Phase nicht ausgelöst, kann aber während einer späteren Phase im Ereignisablauf ausgelöst werden, etwa während der Bubbling-Phase.</p>
	
	<p platform="actionscript">Wird ein Ereignis-Listener von einem Knoten entfernt, während mit dem Knoten ein Ereignis durchgeführt wird, so wird er von den aktuellen Aktionen immer noch ausgelöst. Nachdem er entfernt worden ist, wird der Ereignis-Listener nicht wieder aufgerufen (es sei denn er wird für spätere Verarbeitungsvorgänge erneut aufgerufen). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:analyze"><apiName>analyze</apiName><shortdesc>
     Sammelt statistische Daten über Datenbankindizes und speichert sie in der Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn diese Methode aufgerufen wird und die „SQLConnection“-Instanz ist an keine Datenbank angeschlossen (die <codeph>connected</codeph>-Eigenschaft hat den Wert <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>resourceName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Name der Datenbank oder Tabelle, deren Indizes analysiert werden. Wenn es sich bei der angegebenen Ressource um eine Tabelle handelt, deren Name nur einmal in allen verknüpften Datenbanken vorkommt, brauchen Sie nur den Tabellennamen anzugeben. Sie können einen Tabellennamen jedoch auch als <codeph>[datenbankname].[tabellenname]</codeph> angeben, um bei nicht eindeutigen Tabellennamen Missverständnisse zu vermeiden. Weist der Parameter <codeph>resourceName</codeph> den Wert <codeph>null</codeph> (Standard) auf, werden alle Indizes in allen verknüpften Datenbanken analysiert.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>analyze</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Sammelt statistische Daten über Datenbankindizes und speichert sie in der Datenbank. Diese Statistiken können dann vom Abfrageoptimierer verwendet werden (der Teil der Datenbank-Engine, der die effizienteste Ausführungsweise für jede Anweisung bestimmt). Aufgrund dieser Statistiken kann der Abfrageoptimierer eine bessere Entscheidung treffen, welche Indexpositionen bei der Ausführung einer bestimmten Abfrage angewendet werden sollen.
	 
	 <p>Wenn für eine Datenbank Indexpositionen definiert wurden, aber die Methode <codeph>analyze()</codeph> wurde nicht aufgerufen, werden zur Laufzeit Anweisungen mithilfe dieser Indexpositionen ausgeführt. Ohne die zusätzlichen statistischen Daten, die durch die <codeph>analyze()</codeph>-Methode generiert werden, wird zur Laufzeit möglicherweise nicht die effizienteste Indexposition für eine bestimmte Abfrage ausgewählt.</p>
	 
	 <p>Ändern sich die Daten einer Tabelle (aufgrund einer <codeph>INSERT</codeph>-, <codeph>UPDATE</codeph>- oder <codeph>DELETE</codeph>-Anweisung), werden auch die dieser Tabelle zugeordneten Indizes geändert. Die durch die Methode <codeph>analyze()</codeph> erzeugten statistischen Informationen werden dagegen nicht automatisch aktualisiert. Daher ist es im Allgemeinen empfehlenswert, die <codeph>analyze()</codeph>-Methode nach einer größeren Anzahl von Datenänderungen erneut aufzurufen. Welcher Vorteil aus einer erneuten Ausführung von <codeph>analyze()</codeph> gezogen werden kann, hängt jedoch von mehreren Faktoren ab: der Anzahl der für eine Tabelle definierten Indizes, dem Verhältnis zwischen der Anzahl der geänderten Zeilen und der Gesamtzahl von Zeilen in der Tabelle, wie stark die Abweichung in den indizierten Daten der Tabelle ist und wie stark sich die Daten vor und nach der Änderung unterscheiden.</p>
     
     <p>Mit dem <codeph>resourceName</codeph>-Parameter geben Sie an, ob der Vorgang für die Indizes aller verknüpften Datenbanken, einer bestimmten Datenbank oder einer bestimmten Tabelle ausgeführt werden soll.</p>
     
     <p>Durch jeden Aufruf dieser Methode werden die zuvor erstellten statistischen Daten gelöscht und für die im Parameter <codeph>resourceName</codeph> angegebene Datenbank oder Tabelle neu erstellt (oder alle Tabellen in allen verbundenen Datenbanken, wenn <codeph>resourceName</codeph> den Wert <codeph>null</codeph>) aufweist. Diese Methode kann jederzeit aufgerufen werden, während eine Verbindung zur Datenbank besteht. Der <codeph>analyze()</codeph>-Vorgang und die daraus resultierenden statistischen Daten sind nicht in einer Transaktion enthalten. Es empfiehlt sich jedoch nicht, <codeph>analyze()</codeph> aufzurufen, wenn an der Datenbank eine Transaktion ausgeführt wird (die <codeph>inTransaction</codeph>-Eigenschaft den Wert <codeph>true</codeph>aufweist). Daten, ein Tabellenschema oder Indexänderungen, die zwar in der Transaktion ausgeführt aber noch nicht angewendet wurden, werden bei einem Aufruf von <codeph>analyze()</codeph> nicht erfasst, d. h. die aus dem Aufruf von <codeph>analyze()</codeph> resultierenden Daten sind veraltet, sobald die Transaktion angewendet wird.</p>
     
     <p>Sie können die mit der Methode <codeph>analyze()</codeph> erstellten statistischen Daten mit der Methode <codeph>deanalyze()</codeph> entfernen.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:analyze_analyze"><apiName>analyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:analyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:attach"><apiName>attach</apiName><shortdesc>
     Fügt der „SQLConnection“-Instanz unter dem angegenenen Namen eine neue Datenbank hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der <codeph>name</codeph>-Paramenter ein leerer String (<codeph>""</codeph>) oder <codeph>null</codeph> ist.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn es sich bei dem für den Parameter <codeph>reference</codeph> angegebenen Wert nicht um eine flash.filesystem.File-Instanz handelt
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn das <codeph>encryptionKey</codeph>-Argument nicht <codeph>null</codeph> ist und seine <codeph>length</codeph> nicht 16 Byte beträgt
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der <codeph>reference</codeph>-Parameter <codeph>null</codeph> und das <codeph>encryptionKey</codeph>-Argument nicht <codeph>null</codeph> ist.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die SQLConnection-Instanz nicht mit einer Datenbank verbunden ist (die <codeph>connected</codeph>-Eigenschaft hat den Wert <codeph>false</codeph>), oder wenn aktuell eine Transaktion geöffnet ist (die <codeph>inTransaction</codeph>-Eigenschaft hat den Wert <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name, mit dem die neu verbundene Datenbank bezeichnet wird. Mit diesem Namen können Sie in SQL-Anweisungen ausdrücklich darauf hinweisen, dass eine Tabelle zu einer bestimmten Datenbank gehört, wenn Sie den Namen im Format <codeph>[datenbankname].[tabellenname]</codeph> angeben. Die Namen „main“ und „temp“ sind reserviert und sind nicht verfügbar.
     
     </apiDesc></apiParam><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Verweis auf die zu verknüpfende Datenbankdatei (eine „flash.filesystem.File“-Instanz). Wenn auf eine nicht existierende Datei verwiesen wird, wird entweder eine neue Datenbankdatei erstellt oder ein Fehler ausgelöst. Das hängt von dem Wert ab, der für den Parameter <codeph>openMode</codeph> im Aufruf von <codeph>open()</codeph> oder <codeph>openAsync()</codeph> angegeben wurde, mit dem die Verbindung zur Hauptdatenbank hergestellt wurde.
	 
     <p>Weist der Parameter den Wert <codeph>null</codeph> auf, wird eine Datenbank im Speicher erstellt und verknüpft.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>attach</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Schlüssel für die Verschlüsselung der Datenbankdatei. Wenn durch das Aufrufen von <codeph>attach()</codeph> eine Datenbank erstellt wird, wird diese mithilfe des festgelegten Schlüssels verschlüsselt. Wenn durch das Aufrufen eine bestehende verschlüsselte Datenbank verknüpft wird, muss der Wert dem Schlüssel der Datenbank entsprechen; andernfalls tritt ein Fehler auf. Wenn die zu verknüpfende Datenbank nicht verschlüsselt ist oder eine unverschlüsselte Datenbank erstellt werden soll, muss der Wert der Standardwert <codeph>null</codeph> sein.
	 
	 <p>Ein gültiger Verschlüsselungsschlüssel hat eine Länge von 16 Byte. Eine im Speicher abgelegte Datenbank kann nicht verschlüsselt werden. Deshalb muss dieser Parameter <codeph>null</codeph> sein, wenn der <codeph>reference</codeph>-Parameter <codeph>null</codeph> ist.</p>
	 
	 <p>Entspricht beim Verknüpfen einer verschlüsselten Datenbank der Verschlüsselungsschlüssel nicht jenem der Datenbank, so tritt ein Ausnahmefehler auf. Im synchronen Ausführungsmodus wird ein SQLError-Ausnahmefehler ausgegeben. Im asynchronen Ausführungsmodus wird ein SQLErrorEvent ausgelöst, wobei die <codeph>error</codeph>-Eigenschaft des Ereignisobjekts eine SQLError-Instanz enthält. In beiden Fällen ist die <codeph>errorID</codeph>-Eigenschaft des SQLError-Objekts 3138 („File opened is not a database file“).</p>
	 
	 <p>Der <codeph>encryptionKey</codeph>-Parameter ist ab AIR 1.5 verfügbar.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt der „SQLConnection“-Instanz unter dem angegenenen Namen eine neue Datenbank hinzu. Nachdem eine Datenbank verknüpft wurde, können Sie sie in SQL-Anweisungen verwenden, die an dieser „SQLConnection“-Instanz ausgeführt werden.
     
     <p>Wenn bereits eine Datenbank mit dem angegebenen Namen verknüpft wurde, wird durch das Aufrufen von <codeph>attach()</codeph> ein <codeph>error</codeph>-Ereignis ausgelöst. Sie können dieselbe Datenbank jedoch mehrfach mithilfe von eindeutigen Namen verknüpfen. Mit einer „SQLConnection“-Instanz können bis zu zehn Datenbanken verknüpft werden.</p>
     
     <p>Jede SQL-Anweisung kann an einer verknüpften Datenbank ausgeführt werden, und zwar mithilfe von <codeph>attach()</codeph>, das an der Hauptdatenbank ausgeführt werden kann (die Datenbank, die mithilfe von <codeph>open()</codeph> oder <codeph>openAsync()</codeph> verknüpft wurde). Eine SQL-Anweisung kann auf Tabellen in allen Datenbanken zugreifen, die mit der der Anweisung zugeordneten „SQLConnection“-Instanz verknüpft sind, einschließlich dem Zugreifen auf Tabellen in mehreren Datenbanken von einer Anweisung aus. Wenn zur Laufzeit Tabellennamen in einer Anweisung aufgelöst werden, werden die Datenbanken der „SQLConnection“-Instanz in der Reihenfolge ihrer Verknüpfung durchsucht, und zwar beginnend mit der Datenbank, die mithilfe der Methode <codeph>open()</codeph> oder <codeph>openAsync()</codeph> verknüpft wurde. Geben Sie in der Anweisung·den Datenbanknamen an (wie in der Methode <codeph>attach()</codeph> im Parameter <codeph>name</codeph> angegeben), um einen Tabellennamen explizit zu qualifizieren.</p>
     
     <p>Eine mithilfe der Methode <codeph>attach()</codeph> verknüpfte Datenbank können Sie mithilfe der Methode <codeph>detach()</codeph> entfernen. Durch das Schließen der SQLConnection-Instanz (durch Aufrufen der Methode <codeph>close()</codeph>), werden die Verknüpfungen zu allen verknüpften Datenbanken aufgehoben.</p>
     
     <p>Für die verknüpfte Datenbank wird der gleiche Ausführungsmodus (synchron oder asynchron) wie für die Hauptdatenbank verwendet. Ausschlaggebend ist dabei, ob die Hauptdatenbank mithilfe der Methode <codeph>open()</codeph> oder <codeph>openAsync()</codeph> verknüpft wurde.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:attach_attach"><apiName>attach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:attach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:begin"><apiName>begin</apiName><shortdesc>
     Startet eine Transaktion, in der alle SQL-Anweisungen, die für die Datenbanken der Verbindung ausgeführt wurden, zusammengefasst sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn diese Methode aufgerufen wird und die „SQLConnection“-Instanz ist an keine Datenbank angeschlossen (die <codeph>connected</codeph>-Eigenschaft hat den Wert <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn es sich bei der angegebenen Opion um keine der <codeph>SQLTransactionLockType</codeph>-Konstanten handelt.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>option</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Gibt die Sperrstrategie an, die von der Transaktion verwendet wird. Hierbei kann es sich um eine Konstante handeln, die in der „SQLTransactionLockType“-Klasse definiert wurde:
     <ul>
        <li><codeph>SQLTransactionLockType.DEFERRED</codeph> gibt an, dass eine Sperre erst beim ersten Lese- oder Schreibvorgang erworben wird.</li>
        <li><codeph>SQLTransactionLockType.EXCLUSIVE</codeph> gibt an, dass eine Sperre so schnell wie möglich erworben wird, und keine andere „SQLConnection“-Instanz kann in der Datenbank lesen oder darin schreiben.</li>
        <li><codeph>SQLTransactionLockType.IMMEDIATE</codeph> gibt an, dass eine Sperre so schnell wie möglich erworben wird, und andere „SQLConnection“-Instanzen können zwar in der Datenbank lesen, aber nicht darin schreiben.</li>
     </ul>
	 <p>Der Standardwert (<codeph>null</codeph>) entspricht <codeph>SQLTransactionLockType.DEFERRED</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>begin</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Beginnt eine Transaktion, in der alle SQL-Anweisungen, die an den Datenbanken der Verbindung ausgeführt wurden, zusammengefasst sind.
     
     <p>Standardmäßig wird jede SQL-Anweisung in einer separaten Transaktion ausgeführt, und die Transaktion ist beendet, wenn die Ausführung der Anweisung erfolgreich beendet wird oder fehlschlägt. Mithilfe der Methode <codeph>begin()</codeph> wird eine neue, manuelle Transaktion erstellt. Ab diesem Zeitpunkt erfolgt die Ausführung aller SQL-Anweisungen an der „SQLConnection“-Instanz innerhalb der Transaktion, und alle durch die Anweisung vorgenommenen Aktionen und Änderungen können als eine Gruppe übergeben (dauerhaft·gemacht) oder rückgängig gemacht werden.</p>
     
     <p>Verschachtelte Transaktionen sind nicht zulässig (verschachtelte Aufrufe von <codeph>begin()</codeph> werden ignoriert). Beenden Sie eine Transaktion durch Aufrufen der <codeph>commit()</codeph>- oder <codeph>rollback()</codeph>-Methode, abhängig davon, ob die durch die Anweisungen der Transaktion vorgenommenen Änderungen dauerhaft gemacht oder verworfen werden sollen.</p>
	 
	 <p>Wird die Datenbankverbindung geschlossen, während eine Transaktion geöffnet ist, macht AIR die Transaktion automatisch rückgängig. (Hinweis: Bei AIR 1.1 und niedrigeren Versionen werden offene Transaktionen beim Schließen einer Verbindung automatisch festgeschrieben.)</p>
     
     <p>Eine Transaktion ist nicht auf Anweisungsausführungen in einer Datenbank beschränkt; sondern es können auch Anweisungen an verschiedenen verknüpften Datenbanken ausgeführt werden.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link><link href="flash.data.xml#SQLTransactionLockType"><linktext>flash.data.SQLTransactionLockType</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:begin_begin"><apiName>begin</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:begin_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:cancel"><apiName>cancel</apiName><shortdesc>
     Bricht alle SQL-Anweisungen ab, die aktuell an mit der „SQLConnection“-Instanz verbundenen Datenbanken ausgeführt werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn diese Methode aufgerufen wird und die „SQLConnection“-Instanz ist an keine Datenbank angeschlossen (die <codeph>connected</codeph>-Eigenschaft hat den Wert <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>cancel</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Bricht alle SQL-Anweisungen ab, die aktuell an mit der „SQLConnection“-Instanz verbundenen Datenbanken ausgeführt werden. Mithilfe dieser Methode können Sie langfristige oder außer Kontrolle geratene Abfragen stoppen.
     
     <p>Werden beim Aufrufen der <codeph>cancel()</codeph>-Methode gerade Anweisungen ausgeführt, werden diese Vorgänge abgebrochen und alle unvollständigen Aktualisierungen oder Transaktionen werden rückgängig gemacht. Wenn aktuell keine Anweisungen ausgeführt werden, geschieht mit Ausnahme der Rückgängigmachung einer offenen Transaktion nichts.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:cancel_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:cancel_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:close"><apiName>close</apiName><shortdesc>
     Schließt die aktuelle Datenbankverbindung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>close</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schließt die aktuelle Datenbankverbindung. Die Verbindung zu allen verknüpften Datenbanken werden ebenfalls unterbrochen.
     
     <p>Wenn es beim Aufrufen von <codeph>close()</codeph> eine offene Transaktion gibt, wird die Transaktion übergeben. Wenn eine SQLConnection-Instanz durch einen Garbagekollektor entfernt wird, wird zur Laufzeit automatisch <codeph>close()</codeph> aufgerufen, auch wenn eine AIR-Anwendung geschlossen wird, während eine SQLConnection noch mit einer Datenbank verbunden ist.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:close_close"><apiName>close</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:close_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:commit"><apiName>commit</apiName><shortdesc>
     Übergibt eine vorhandene Transaktion, wodurch alle durch die Transaktionsanweisungen ausgeführten Aktionen dauerhaft auf die Datenbank angewendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die Methode aufgerufen wird, während die SQLConnection-Instanz mit keiner Datenbank verbunden ist (die <codeph>connected</codeph>-Eigenschaft weist den Wert <codeph>false</codeph> auf) oder wenn aktuell keine Transaktion offen ist (die <codeph>inTransaction</codeph>-Eigenschaft weist den Wert <codeph>false</codeph> auf).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>commit</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Übergibt eine vorhandene Transaktion, wodurch alle durch die Transaktionsanweisungen ausgeführten Aktionen dauerhaft auf die Datenbank angewendet werden.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:commit_commit"><apiName>commit</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:commit_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang mit einem Fehlschlag abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang mit einem Fehlschlag abgeschlossen wurde.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:compact"><apiName>compact</apiName><shortdesc>
     Gewinnt sämtlichen unbenutzten Platz in der Datenbank zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die Methode aufgerufen wird, während die SQLConnection-Instanz mit keiner Datenbank verbunden ist (die <codeph>connected</codeph>-Eigenschaft weist den Wert <codeph>false</codeph> auf) oder wenn aktuell eine Transaktion ausgeführt wird (die <codeph>inTransaction</codeph>-Eigenschaft weist den Wert <codeph>true</codeph> auf).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>compact</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gewinnt sämtlichen unbenutzten Platz in der Datenbank zurück. Wenn ein Objekt (Tabelle, Indexposition oder Auslöser) aus der Datenbank entfernt wird, bleibt ein leerer Platz zurück. Dadurch wird die Datenbank unnötig größer, aber andererseits können <codeph>INSERT</codeph>-Vorgänge schneller ausgeführt werden. Allmählich wird die Struktur der Datenbankdatei durch <codeph>INSERT</codeph>- und <codeph>DELETE</codeph>-Vorgänge fragmentiert, wodurch der Zugriff auf den Datenbankinhalt verlangsamt wird. Mithilfe dieser Methode wird die Datenbankdatei verdichtet, leere Seiten werden eliminiert, Tabellendaten werden ausgerichtet, sodass sie zusammenhängend sind und die Struktur der Datenbankdatei wird bereinigt.
     
     <p>An einer verknüpften Datenbankdatei kann der Vorgang <codeph>compact()</codeph> nicht ausgeführt werden; er kann nur an der ursprünglichen oder Hauptdatenbankdatei, die mithilfe der „SQLConnection“-Instanz geöffnet wurde, ausgeführt werden. Wenn eine Transaktion aktiv ist, schlägt dieser Vorgang fehl und hat keine Auswirkung auf eine Datenbank im Speicher.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:compact_compact"><apiName>compact</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:compact_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:deanalyze"><apiName>deanalyze</apiName><shortdesc>
     Entfernt alle statistischen Daten, die durch einen Aufruf der Methode „analyze()“ erstellt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn diese Methode aufgerufen wird und die „SQLConnection“-Instanz ist an keine Datenbank angeschlossen, hat die <codeph>connected</codeph>-Eigenschaft den Wert <codeph>false</codeph>.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>deanalyze</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Entfernt alle statistischen Daten, die durch einen Aufruf der Methode <codeph>analyze()</codeph> erstellt wurden.
	 
	 <p>Da die durch die Methode <codeph>analyze()</codeph> erzeugten statistischen Daten in der Datenbank Platz einnehmen, können Sie durch Aufrufen von <codeph>deanalyze()</codeph> Platz zurückgewinnen, der z. B. nach dem Entfernen von Indizes oder Tabellen frei geworden ist.</p>
     
     <p>Dieser Vorgang ist in einer aktiven Transaktion nicht eingeschlossen.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:deanalyze_deanalyze"><apiName>deanalyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:deanalyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:detach"><apiName>detach</apiName><shortdesc>
     Unterbricht die Verknüpfung einer zusätzlichen Datenbank, die zuvor mithilfe der Methode „attach()“ mit der „SQLConnection“-Instanz verknüpft wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn das <codeph>name</codeph>-Argument den Wert <codeph>null</codeph> aufweist oder einen leeren String (<codeph>""</codeph>) enthält.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn diese Methode aufgerufen wird, während die „SQLConnection“-Instanz mit keiner Datenbank verbunden ist (die <codeph>connected</codeph>-Eigenschaft weist den Wert <codeph>false</codeph> auf) oder wenn die „SQLConnection“-Instanz eine offene Transaktion aufweist (die <codeph>inTransaction</codeph>-Eigenschaft weist den Wert <codeph>true</codeph> auf).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Datenbank, deren Verbindung unterbrochen werden soll.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>detach</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Unterbricht die Verknüpfung einer zusätzlichen Datenbank, die zuvor mithilfe der Methode <codeph>attach()</codeph> mit der „SQLConnection“-Instanz verknüpft wurde. Sie können eine Datenbankdatei mehrfach unter verschiedenen Namen verknüpfen. Bei der Trennung der Verbindung zu einer Datei bleiben die anderen Verbindungen intakt. Die Verbindung zu einer Datenbank kann nicht unterbrochen werden, wenn eine offene Transaktion vorliegt (die <codeph>inTransaction</codeph>-Eigenschaft weist den Wert <codeph> true</codeph> auf).
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:detach_detach"><apiName>detach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:detach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:getSchemaResult"><apiName>getSchemaResult</apiName><shortdesc>
     Bietet Zugriff auf das Ergebnis, das sich aus einem Aufruf der Methode „loadSchema()“ ergibt. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.data:SQLSchemaResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Bietet Zugriff auf das Ergebnis, das sich aus einem Aufruf der Methode <codeph>loadSchema()</codeph> ergibt. Mit der Methode <codeph>getSchemaResult()</codeph> werden die ältesten Ergebnisse in der Warteschlange zuerst verarbeitet. Jedes Mal, wenn das Aufrufen der <codeph>loadSchema()</codeph>-Methode abgeschlossen wird (jedes Mal, wenn im asynchronen Ausführungsmodus das <codeph>schema</codeph>-Ereignis ausgelöst wird), wird der Warteschlange ein neues SQLSchemaResult-Objekt hinzugefügt. Bei jedem Aufrufen der Methode <codeph>getSchemaResult()</codeph> wird das älteste Ergebnis (das Ergebnis, das der Warteschlange als erstes hinzugefügt wurde) zurückgegeben und aus der Warteschlange entfernt. Wenn die Warteschlange keine weiteren Objekte mehr enthält, gibt <codeph>getSchemaResult()</codeph> den Wert <codeph>null</codeph> zurück.
     
     <p>Ist die Datenbankverbindung geschlossen, gibt die Methode den Wert <codeph>null</codeph> zurück.</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>schema</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLConnection:loadSchema"><apiName>loadSchema</apiName><shortdesc>
     Lädt Schemainformationen von der verbundenen Datenbank oder einer verknüpften Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn diese Methode aufgerufen wird und die „SQLConnection“-Instanz ist an keine Datenbank angeschlossen ist (die Eigenschaft <codeph>connected</codeph> hat den Wert <codeph>false</codeph>).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der angegebene Wert für das Argument <codeph>type</codeph> keiner der zulässigen Typen ist.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn im synchronen Ausführungsmodus ein ungültiger Wert für die Parameter „name“ oder „database“ angegeben wird.
	 
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiData>null</apiData><apiDesc>Gibt den Typ des zu ladenden Schemas an. Der Wert <codeph>null</codeph> (der Standard) gibt an, dass alle Schemainformationen geladen werden sollen. Durch die Eingabe eines anderes Wertes als <codeph>null</codeph> für diesen Parameter engen Sie den Umfang des resultierenden Schemas ein, potenziell unnötige Informationen werden aus dem Ergebnis entfernt und der Vorgang wird effizienter. Bei dem Wert muss es sich um den Klassennamen einer der folgenden Klassen handeln:
	 <ul>
	     <li>SQLIndexSchema</li>
	     <li>SQLTableSchema</li>
	     <li>SQLTriggerSchema</li>
	     <li>SQLViewSchema</li>
	 </ul>
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Zeigt an, welches Ressourcenschema geladen ist. Wie dieser Wert verwendet wird, hängt vom angegebenen <codeph>type</codeph>-Argument ab. In der Regel handelt es sich dabei um den Namen eines Datenbankobjekts, wie etwa einem Tabellen-, Index- oder Ansichtsnamen. Wenn Sie einen Wert angeben, werden nur Schemainformationen für das Datenbankobjekt mit dem angegebenen Namen in die Ergebnisse aufgenommen.
	 
	 <p>Ist der angegebene Wert ungültig, wird ein <codeph>error</codeph>-Ereignis ausgelöst (im synchronen Ausführungsmodus wird ein Fehler ausgegeben). Der Wert des Parameters <codeph>type</codeph> ist nur gültig, wenn er dem Typ des genannten Objekts entspricht (siehe Beschreibung der Methode).</p>
	 
	 <p>Weist das Argument <codeph>name</codeph> den Wert <codeph>null</codeph> auf, dann werden alle Schemata des angegebenen Typs eingeschlossen. Wenn der angegebene Wert ungültig ist, wird ein <codeph>error</codeph>-Ereignis ausgelöst.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>main</apiData><apiDesc>Der Name der Datenbank, deren Schema geladen wird. Wenn der angegebene Wert ungültig ist, wird ein <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam><apiParam><apiItemName>includeColumnSchema</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Gibt an, ob das Ergebnis Schemainformationen für die Spalten von Tabellen und Ansichten enthält.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>schema</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lädt Schemainformationen von der verbundenen Datenbank oder einer verknüpften Datenbank. Das Schema gibt die Struktur der Tabellen, Spalten, Indizes und Auslöser in der Datenbank an.
	 
     <p>Der Zugriff auf das geladene Schema erfolgt mithhilfe der Methode <codeph>SQLConnection.getSchemaResult()</codeph>.</p>
	 
     <p>Im asynchronen Ausführungsmodus wird bei einem erfolgreichen Abschluss des Vorgangs ein <codeph>schema</codeph>-Ereignis ausgelöst. Schlägt der Vorgang fehl, wird ein <codeph>error</codeph>-Ereignis ausgelöst.</p>
	 
	 <p>Mit der Kombination aus den Werten der Parameter <codeph>type</codeph> und <codeph>name</codeph> bestimmen Sie, welcher Typ von Schemadaten mithilfe der <codeph>loadSchema()</codeph>-Methode erzeugt wird, und folglich bestimmen Sie damit auch die Werte der Eigenschaften der erzeugten SQLSchemaResult-Instanz. Die folgende Tabelle gibt die gültigen Paare aus <codeph>type</codeph> und <codeph>name</codeph> sowie·die damit erzeugten Schemadaten an:</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Argument <codeph>type</codeph></entry><entry>Argument <codeph>name</codeph></entry><entry>Ruft Schemadaten ab für: </entry></row></thead><tbody><row>
	     <entry><codeph>„null“</codeph></entry>
	     <entry><codeph>„null“</codeph></entry>
	     <entry>alle Objekte in der Datenbank (alle Tabellen, Ansichten, Auslöser und Indizes)</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry><codeph>„null“</codeph></entry>
	     <entry>alle Indizes in der Datenbank</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>gültiger Tabellenname</entry>
	     <entry>alle in der angegebenen Tabelle definierten Indizes</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>gültiger Indexname</entry>
	     <entry>der angegebene Index</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry><codeph>„null“</codeph></entry>
	     <entry>alle Tabellen·in der Datenbank</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry>gültiger Tabellenname</entry>
	     <entry>die angegebene Tabelle</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry><codeph>„null“</codeph></entry>
	     <entry>alle Auslöser in der Datenbank</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>gültiger Tabellenname</entry>
	     <entry>alle der angegebenen Tabelle zugeordneten Auslöser</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>gültiger Ansichtsname</entry>
	     <entry>alle der angegebenen Ansicht zugeordneten Auslöser </entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>gültiger Auslösername</entry>
	     <entry>der angegebene Auslöser </entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry><codeph>„null“</codeph></entry>
	     <entry>alle Ansichten in der Datenbank</entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry>gültiger Ansichtsname</entry>
	     <entry>die angegebene Ansicht </entry>
	   </row></tbody></tgroup></adobetable>
	 
	 <p>Entspricht die Kombination aus <codeph>type</codeph>- und <codeph>name</codeph>-Argumenten keiner der angegebenen Kombinationen, wird im asynchronen Ausführungsmodus ein <codeph>error</codeph>-Ereignis bzw. im synchronen Ausführungsmodus eine Ausnahme ausgelöst. Beispiel: Das Argument <codeph>type</codeph> weist den Wert <codeph>SQLViewSchema</codeph> und das Argument <codeph>name</codeph> weist als Wert den Name einer Tabelle (nicht den Namen einer Ansicht) auf. Die daraufhin ausgelöst Fehlermeldung gibt an, dass die Datenbank kein Objekt des angegebenen Typs mit dem angegebenen Namen enthält.</p>
	 
	 <p>Ist die Datenbank leer (enthält keine Tabellen, Ansichten, Auslöser oder Indizes), tritt beim Aufrufen der <codeph>loadSchema()</codeph>-Methode ein Fehler auf.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>getSchemaResult()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>schema</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:loadSchema_schema"><apiName>schema</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:loadSchema_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang mit einem Fehlschlag abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang mit einem Fehlschlag abgeschlossen wurde.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:open"><apiName>open</apiName><shortdesc>
     Öffnet eine synchrone Verbindung zu der Datenbankdatei am angegebenen Speicherort im Dateisystem oder erstellt und öffnet eine neue Datenbankdatei an diesem Speicherort oder öffnet eine Datenbank aus dem Arbeitsspeicher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die „SQLConnection“-Instanz bereits über eine offene Verbindung zu einer Datenbank verfügt (die Eigenschaft <codeph>connected</codeph> weist den Wert <codeph>true</codeph> auf).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang fehlschlägt. Nach einem fehlgeschlagenen Vorgang wird die Verbindung immer geschlossen.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn es sich bei dem für den Parameter <codeph>reference</codeph> angegebenen Wert nicht um eine flash.filesystem.File-Instanz handelt
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn das <codeph>encryptionKey</codeph>-Argument nicht <codeph>null</codeph> ist und seine <codeph>length</codeph> nicht 16 Byte beträgt
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der <codeph>reference</codeph>-Parameter <codeph>null</codeph> und das <codeph>encryptionKey</codeph>-Argument nicht <codeph>null</codeph> ist
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn ein ungültiger <codeph>pageSize</codeph>-Parameter angegeben wurde. Dies gilt auch für das Übergeben einer Seitengröße im Modus <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Speicherort der Datenbankdatei, die geöffnet wird. Bei diesem Wert muss es sich um eine „flash.filesystem.File“-Instanz handeln. Lautet der Wert des Parameters <codeph>null</codeph>, dann wird eine im Speicher abgelegte Datenbank erstellt und geöffnet.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Zeigt an, wie die Datenbank geöffnet wird. Bei dem Wert kann es sich um eine beliebige Konstante aus der „SQLMode“-Klasse handeln. Der Standardwert lautet <codeph>SQLMode.CREATE</codeph>, womit angegeben wird, dass eine Datenbankdatei erstellt wird, sollte am angegebenen Speicherort keine gefunden werden. Wenn <codeph>openMode</codeph> den Wert <codeph>SQLMode.READ</codeph> hat und die angegebene Datei nicht existiert, wird ein Fehlerereignis ausgelöst. Dieser Parameter wird ignoriert, wenn der Parameter <codeph>reference</codeph> den Wert <codeph>null</codeph> aufweist.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob unbenutzter Platz in der Datenbank automatisch zurückgewonnen wird. Dieser Parameter ist nur gültig, wenn eine neue Datenbankdatei erstellt wird oder eine Datenbankdatei, in der keine Tabellen erstellt wurden, geöffnet wird. Der durch entfernte Daten eingenommene Platz verbleibt standardmäßig in der Datenbankdatei und wird bei Bedarf wiederverwendet. Wenn Sie diesen Parameter auf <codeph>true</codeph> setzen, wird die Datenbank veranlasst, automatisch nicht benutzten Platz zurückzugewinnen. Dies kann sich nachteilig auf die Leistung auswirken, da jedes Mal, wenn Daten in die Datenbank geschrieben werden, zusätzliche Verarbeitungszeit erforderlich ist. Außerdem können die Datenbankdaten im Laufe der Zeit fragmentiert werden. Mithilfe der Methode <codeph>compact()</codeph> zwingen Sie die Datenbank, jederzeit nicht benutzten Platz in einer Datenbank zurückzugewinnen und die Datenbankdatei zu defragmentieren.
	 
	 <p>Dieser Parameter wird ignoriert, wenn der Parameter <codeph>openMode</codeph> den Wert <codeph>SQLMode.READ</codeph> aufweist.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Gibt die Seitengröße (in Byte) der Datenbank an. Dieser Parameter ist nur gültig, wenn eine neue Datenbankdatei erstellt wird oder eine Datenbankdatei, in der keine Tabellen erstellt wurden, geöffnet wird. Der Wert muss eine Zweierpotenz größer oder gleich 512 und kleiner oder gleich 32768 sein. Der Standardwert lautet 1024 Byte. Dieser Wert kann nur vor der Erstellung von Tabellen festgelegt werden. Wurden die Tabellen erstellt und wird dann versucht, diesen Wert zu ändern, tritt ein Fehler auf. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Schlüssel für die Verschlüsselung der Datenbankdatei. Wenn durch das Aufrufen von <codeph>open()</codeph> eine Datenbank erstellt wird, wird diese mithilfe des festgelegten Schlüssels verschlüsselt. Wenn durch das Aufrufen eine verschlüsselte Datenbank geöffnet wird, muss der Wert dem Schlüssel der Datenbank entsprechen; andernfalls tritt ein Fehler auf. Wenn die zu öffnende Datenbank nicht verschlüsselt ist oder eine unverschlüsselte Datenbank erstellt werden soll, muss der Wert der Standardwert <codeph>null</codeph> sein; andernfalls tritt ein Fehler auf.
	 
	 <p>Ein gültiger Verschlüsselungsschlüssel hat eine Länge von 16 Byte. Eine im Speicher abgelegte Datenbank kann nicht verschlüsselt werden. Deshalb muss dieser Parameter <codeph>null</codeph> sein, wenn der <codeph>reference</codeph>-Parameter <codeph>null</codeph> ist.</p>
	 
	 <p>Entspricht beim Öffnen einer verschlüsselten Datenbank der Verschlüsselungsschlüssel nicht jenem der Datenbank, so wird ein SQLError-Ausnahmefehler ausgegeben. In diesem Fall ist die <codeph>errorID</codeph>-Eigenschaft des SQLError-Objekts 3138 („File opened is not a database file“).</p>
	 
	 <p>Der <codeph>encryptionKey</codeph>-Parameter ist ab AIR 1.5 verfügbar.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Öffnet eine synchrone Verbindung zu der Datenbankdatei am angegebenen Speicherort im Dateisystem oder erstellt und öffnet eine neue Datenbankdatei an diesem Speicherort oder öffnet eine Datenbank aus dem Arbeitsspeicher. Wenn die Datenbank mithilfe dieser Methode geöffnet wird, werden das Erstellen und Öffnen der Datenbank sowie andere, mithilfe dieser „SQLConnection“-Instanz ausgeführte Vorgänge <i>synchron</i> ausgeführt. Dazu gehören auch die Anweisungsausführung und andere Vorgänge, die durch eine dieser „SQLConnection“-Instanz zugewiesene „SQLStatement“-Instanz ausgeführt werden. Um Vorgänge asynchron auszuführen, müssen Sie die Datenbankverbindung stattdessen mithilfe der Methode <codeph>openAsync()</codeph> öffnen.
	 
	 <p>Nachdem die Verbindung zu einer Datenbank hergestellt wurde, verwenden Sie eine <xref href="SQLStatement.html">SQLStatement</xref>-Instanz, um SQL-Befehle auszuführen. Vorgänge auf Datenbankebene wie das Starten oder Beenden von Transaktionen, das Laden von Schemainformationen und andere Vorgänge werden unter Verwendung der SQLConnection-Instanz ausgeführt.</p>
     
     <p>Eine Datenbank, zu der die Verbindung mithilfe der Methode <codeph>open()</codeph> hergestellt wird, erhält automatisch den Datenbanknamen „main“. Mit diesem Namen können Sie Tabellennamen explizit in SQL-Anweisungen qualifizieren, indem Sie sie im Format <codeph>[datenbankname].[tabellenname]</codeph> angeben. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:open_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:openAsync"><apiName>openAsync</apiName><shortdesc>
     Öffnet eine asynchrone Verbindung zu der Datenbankdatei am angegebenen Speicherort im Dateisystem oder erstellt und öffnet eine neue Datenbankdatei an diesem Speicherort oder öffnet eine Datenbank aus dem Arbeitsspeicher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die „SQLConnection“-Instanz bereits über eine offene Verbindung zu einer Datenbank verfügt (die Eigenschaft <codeph>connected</codeph> weist den Wert <codeph>true</codeph> auf).
     
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn es sich bei dem für den <codeph>reference</codeph>-Parameter angegebenen Wert nicht um eine flash.filesystem.File-Instanz handelt
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn das <codeph>encryptionKey</codeph>-Argument nicht <codeph>null</codeph> ist und seine <codeph>length</codeph> nicht 16 Byte beträgt
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der <codeph>reference</codeph>-Parameter <codeph>null</codeph> und das <codeph>encryptionKey</codeph>-Argument nicht <codeph>null</codeph> ist
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn ein ungültiger <codeph>pageSize</codeph>-Parameter angegeben wurde. Dies gilt auch für das Übergeben einer Seitengröße im Modus <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Speicherort der Datenbankdatei, die geöffnet wird. Bei diesem Wert muss es sich um eine „flash.filesystem.File“-Instanz handeln. Lautet der Wert des Parameters <codeph>null</codeph>, dann wird eine im Speicher abgelegte Datenbank erstellt und geöffnet.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Zeigt an, wie die Datenbank geöffnet wird. Bei dem Wert kann es sich um eine beliebige Konstante aus der „SQLMode“-Klasse handeln. Der Standardwert lautet <codeph>SQLMode.CREATE</codeph>, womit angegeben wird, dass eine Datenbankdatei erstellt wird, sollte am angegebenen Speicherort keine gefunden werden. Wenn <codeph>openMode</codeph> den Wert <codeph>SQLMode.READ</codeph> hat und die angegebene Datei nicht existiert, wird ein Fehlerereignis ausgelöst. Dieser Parameter wird ignoriert, wenn der Parameter <codeph>reference</codeph> den Wert <codeph>null</codeph> aufweist.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn das <codeph>responder</codeph>-Argument den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>open</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob unbenutzter Platz in der Datenbank automatisch zurückgewonnen wird. Dieser Parameter ist nur gültig, wenn eine neue Datenbankdatei erstellt wird oder eine Datenbankdatei, in der keine Tabellen erstellt wurden, geöffnet wird. Der durch entfernte Daten eingenommene Platz verbleibt standardmäßig in der Datenbankdatei und wird bei Bedarf wiederverwendet. Wenn Sie diesen Parameter auf <codeph>true</codeph> setzen, wird die Datenbank veranlasst, automatisch nicht benutzten Platz zurückzugewinnen. Dies kann sich nachteilig auf die Leistung auswirken, da jedes Mal, wenn Daten in die Datenbank geschrieben werden, zusätzliche Verarbeitungszeit erforderlich ist. Außerdem können die Datenbankdaten im Laufe der Zeit fragmentiert werden. Mithilfe der Methode <codeph>compact()</codeph> zwingen Sie die Datenbank, jederzeit nicht benutzten Platz in einer Datenbank zurückzugewinnen und die Datenbankdatei zu defragmentieren.
	 
	 <p>Dieser Parameter wird ignoriert, wenn der Parameter <codeph>openMode</codeph> den Wert <codeph>SQLMode.READ</codeph> aufweist.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Gibt die Seitengröße (in Byte) der Datenbank an. Dieser Parameter ist nur gültig, wenn eine neue Datenbankdatei erstellt wird oder eine Datenbankdatei, in der keine Tabellen erstellt wurden, geöffnet wird. Der Wert muss eine Zweierpotenz größer oder gleich 512 und kleiner oder gleich 32768 sein. Der Standardwert lautet 1024 Byte. Dieser Wert kann nur vor der Erstellung von Tabellen festgelegt werden. Wurden die Tabellen erstellt und wird dann versucht, diesen Wert zu ändern, tritt ein Fehler auf. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Schlüssel für die Verschlüsselung der Datenbankdatei. Wenn durch das Aufrufen von <codeph>openAsync()</codeph> eine Datenbank erstellt wird, wird diese mithilfe des festgelegten Schlüssels verschlüsselt. Wenn durch das Aufrufen eine verschlüsselte Datenbank geöffnet wird, muss der Wert dem Schlüssel der Datenbank entsprechen; andernfalls tritt ein Fehler auf. Wenn die zu öffnende Datenbank nicht verschlüsselt ist, muss der Wert der Standardwert <codeph>null</codeph> sein; andernfalls tritt ein Fehler auf.
	 
	 <p>Ein gültiger Verschlüsselungsschlüssel hat eine Länge von 16 Byte. Eine im Speicher abgelegte Datenbank kann nicht verschlüsselt werden. Deshalb muss dieser Parameter <codeph>null</codeph> sein, wenn der <codeph>reference</codeph>-Parameter <codeph>null</codeph> ist.</p>
	 
	 <p>Entspricht beim Öffnen einer verschlüsselten Datenbank der Verschlüsselungsschlüssel nicht jenem der Datenbank, so wird ein SQLErrorEvent-Ausnahmefehler ausgelöst. Die <codeph>error</codeph>-Eigenschaft des Ereignisobjekts enthält eine SQLError-Instanz. Die <codeph>errorID</codeph>-Eigenschaft des SQLError-Objekts ist 3138 („File opened is not a database file“).</p>
	 
	 <p>Der <codeph>encryptionKey</codeph>-Parameter ist ab AIR 1.5 verfügbar.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Öffnet eine asynchrone Verbindung zu der Datenbankdatei am angegebenen Speicherort im Dateisystem oder erstellt und öffnet eine neue Datenbankdatei an diesem Speicherort oder öffnet eine Datenbank aus dem Arbeitsspeicher. Wenn die Datenbank mithilfe dieser Methode geöffnet wird, werden das Erstellen und Öffnen der Datenbank sowie andere, mithilfe dieser „SQLConnection“-Instanz ausgeführte Vorgänge <i>asynchron</i> ausgeführt. Dazu gehören auch die Anweisungsausführung und andere Vorgänge, die durch eine dieser „SQLConnection“-Instanz zugewiesene „SQLStatement“-Instanz ausgeführt werden. Um Vorgänge synchron auszuführen, müssen Sie die Datenbankverbindung stattdessen mithilfe der Methode <codeph>open()</codeph> öffnen.
     
	 <p>Nachdem die Verbindung zu einer Datenbank hergestellt wurde, verwenden Sie eine <xref href="SQLStatement.html">SQLStatement</xref>-Instanz, um SQL-Befehle auszuführen. Vorgänge auf Datenbankebene wie das Starten oder Beenden von Transaktionen, das Laden von Schemainformationen und andere Vorgänge werden unter Verwendung der SQLConnection-Instanz ausgeführt.</p>
     
     <p>Eine Datenbank, zu der die Verbindung mithilfe der Methode <codeph>openAsync()</codeph> hergestellt wird, erhält automatisch den Datenbanknamen „main“. Mit diesem Namen können Sie Tabellennamen explizit in SQL-Anweisungen qualifizieren, indem Sie sie im Format <codeph>[datenbankname].[tabellenname]</codeph> angeben. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:openAsync_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:openAsync_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Fehlschlagen des Vorgangs ausgelöst. Nach einem fehlgeschlagenen Vorgang wird die Verbindung immer geschlossen.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Fehlschlagen des Vorgangs ausgelöst.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:reencrypt"><apiName>reencrypt</apiName><shortdesc>
	 Ändert den Verschlüsselungsschlüssel einer verschlüsselten Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der <codeph>newEncryptionKey</codeph>-Wert nicht <codeph>null</codeph> ist und seine <codeph>length</codeph> nicht 16 Byte beträgt
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Verbindung nicht geöffnet ist oder eine Transaktion geöffnet ist.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newEncryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Ein ByteArray, das den neuen Verschlüsselungsschlüssel für die Datenbank enthält. Ein gültiger Verschlüsselungsschlüssel hat eine Länge von 16 Byte.
	 
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn das <codeph>responder</codeph>-Argument den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung das Ereignis·<codeph>reencrypt</codeph> oder <codeph>error</codeph> ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ändert den Verschlüsselungsschlüssel einer verschlüsselten Datenbank. Diese Methode wirkt sich nur auf den Verschlüsselungsschlüssel der Hauptdatenbank (jene Datenbank, die mithilfe der <codeph>open()</codeph>- oder <codeph>openAsync()</codeph>-Methode verbunden wurde), aus. <codeph>reencrypt()</codeph> kann nur für Datenbanken aufgerufen werden, die bei der Erstellung verschlüsselt wurden. Wurde eine Datenbank verschlüsselt erstellt, so kann die Verschlüsselung nicht mehr aufgehoben werden. Ebenso kann eine unverschlüsselt erstellte Datenbank später nicht verschlüsselt werden.
	 
	 <p>Der Vorgang der erneuten Verschlüsselung läuft in einer eigenen Transaktion ab. Wenn der Vorgang der erneuten Verschlüsselung unterbrochen wird, macht die Datenbank die Transaktion rückgängig und der Verschlüsselungsschlüssel bleibt unverändert.</p> 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:reencrypt_reencrypt"><apiName>reencrypt</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:reencrypt_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Fehlschlagen des Vorgangs ausgelöst.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Fehlschlagen des Vorgangs ausgelöst.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:removeEventListener"><apiName>removeEventListener</apiName><shortdesc>
     
	Entfernt einen Listener aus dem EventDispatcher-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Typ des Ereignisses.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Das zu entfernende Listener-Objekt.
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Dieser Parameter gilt für Anzeigeobjekte in der ActionScript 3.0-Anzeigelistenarchitektur, die von SWF-Material verwendet wird.</ph> <ph platform="actionscript">Gibt an, ob der Listener für die Aufnahmephase oder die Zielphase und Bubbling-Phase registriert wurde. Wenn der Listener sowohl für die Aufnahme- als auch für die Bubbling-Phase registriert wurde, sind auch zwei Aufrufe von <codeph>removeEventListener()</codeph> erforderlich, um beide zu entfernen: ein Aufruf, bei dem <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt ist, und einer, bei dem <codeph>useCapture</codeph> auf <codeph>false</codeph> gesetzt ist.</ph>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Entfernt einen Listener aus dem EventDispatcher-Objekt. Wenn kein entsprechender Listener mit dem EventDispatcher-Objekt registriert ist, hat ein Aufruf dieser Methode keine Auswirkungen.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:rollback"><apiName>rollback</apiName><shortdesc>
     Macht eine vorhandene Transaktion, die mit der Methode „begin()“ erstellt wurde, rückgängig, d. h. alle in der Transaktion durch SQL-Anweisungen vorgenommen Änderungen werden verworfen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die Methode aufgerufen wird, während die SQLConnection-Instanz mit keiner Datenbank verbunden ist (die Eigenschaft <codeph>connected</codeph> weist den Wert <codeph>false</codeph> auf) oder wenn aktuell keine Transaktion offen ist (die Eigenschaft <codeph>inTransaction</codeph> weist den Wert <codeph>false</codeph> auf).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung ein <codeph>rollback</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Macht eine vorhandene Transaktion, die mit der Methode <codeph>begin()</codeph> erstellt wurde, rückgängig, d. h. alle in der Transaktion durch SQL-Anweisungen vorgenommen Änderungen werden verworfen.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:rollback_rollback"><apiName>rollback</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:rollback_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLConnection:autoCompact:get"><apiName>autoCompact</apiName><shortdesc>
     Gibt an, ob bei der Erstellung der aktuellen Datenbank das automatische Verdichten aktiviert wurde (der Wert, der für den autoCompact-Parameter beim Aufrufen von open() oder openAsync(), durch den die Datenbank erstellt wurde, angegeben wurde).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob bei der Erstellung der aktuellen Datenbank das automatische Verdichten aktiviert wurde (der Wert, der für den <codeph>autoCompact</codeph>-Parameter beim Aufrufen von <codeph>open()</codeph> oder <codeph>openAsync()</codeph>, durch den die Datenbank erstellt wurde, angegeben wurde). Weist diese Eigenschaft den Wert <codeph>true</codeph> auf, wird nach jedem Schreibvorgang automatisch nicht benutzter Platz aus der Datenbankdatei entfernt, um die Größe der Datei zu minimieren. Weist diese Eigenschaft den Wert <codeph>false</codeph>auf, verbleibt der durch entfernte Daten eingenommene Platz in der Datenbankdatei und wird bei Bedarf wiederverwendet. Selbst wenn <codeph>autoCompact</codeph> den Wert <codeph>false</codeph> aufweist, können Sie die Zurückgewinnung von nicht benutztem Platz in der Datenbank erzwingen, indem Sie die Methode <codeph>compact()</codeph> aufrufen.
     
     <p>Wenn die Eigenschaft <codeph>connected</codeph> den Wert <codeph>false</codeph> aufweist, wird diese Eigenschaft auf <codeph>false</codeph> gesetzt.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:cacheSize:get"><apiName>cacheSize</apiName><shortdesc>
     Bietet Zugriff auf die Cachegröße dieser Verbindung, die die Höchstzahl der jeweils auf der Festplatte gespeicherten Datenbankseiten darstellt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Wenn versucht wird, diese Eigenschaft einzustellen, während die „SQLConnection“-Instanz mit keiner Datenbank verbunden ist (die Eigenschaft <codeph>connected</codeph> weist den Wert <codeph>false</codeph> auf) oder wenn es aktuell eine offene Transaktion gibt (die Eigenschaft <codeph>inTransaction</codeph> weist den Wert <codeph>true</codeph> auf).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Bietet Zugriff auf die Cachegröße dieser Verbindung, die die Höchstzahl der jeweils auf der Festplatte gespeicherten Datenbankseiten darstellt. Pro Seite sind etwa 1,5 KB Speicher erforderlich (abhängig vom Wert des Parameters <codeph>pageSize</codeph> im Aufruf der Methode <codeph>open()</codeph> oder <codeph>openAsync()</codeph>, mit der die Datenbank erstellt wurde). Die standardmäßige Cache-Größe ist 2000. Wenn eine Anwendung <codeph>UPDATE</codeph>- oder <codeph>DELETE</codeph>-Vorgänge ausführt, durch·die viele Zeilen der Datenbank geändert werden, können Sie durch eine Erhöhung der Cache-Größe die Geschwindigkeit auf Kosten eines erhöhten Speicherverbrauchs verbessern.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:columnNameStyle:get"><apiName>columnNameStyle</apiName><shortdesc>
     Gibt an, wie Spaltennamen im Ergebnis einer „SELECT“-Anweisung wiedergegeben werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn versucht wird, diese Eigenschaft einzustellen, während die „SQLConnection“-Instanz mit keiner Datenbank verbunden ist (die Eigenschaft <codeph>connected</codeph> hat den Wert <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Gibt an, wie Spaltennamen im Ergebnis einer <codeph>SELECT</codeph>-Anweisung wiedergegeben werden.
     
     <p>Die in der „SQLColumnNameStyle“-Klasse definierten Konstanten repräsentieren die möglichen Werte dieser Eigenschaft:</p>
     
     <ul>
         <li><codeph>SQLColumnNameStyle.LONG</codeph> gibt an, dass Spaltennamen im Format <codeph>[tabellenname]_[spaltenname]</codeph> zurückgegeben werden.</li>
         <li><codeph>SQLColumnNameStyle.SHORT</codeph> gibt an, dass Spaltennamen im Format <codeph>[spaltenname]</codeph> zurückgegeben werden. Gibt es mehrere Spalten mit demselben Namen, wird nur eine Eigenschaft mit diesem Namen zum Ergebnisobjekt hinzugefügt.</li>
         <li>Der Standardwert ist <codeph>SQLColumnNameStyle.DEFAULT</codeph>. Kommt dieser Wert zur Anwendung, werden die Ergebnisspaltennamen gemäß der Anzahl Tabellen in der <codeph>SELECT</codeph>-Anweisung, die ähnliche Spaltennamen aufweisen, formatiert. Wenn die Anweisung <codeph>SELECT</codeph> nur eine Tabelle enthält, wird das kurze Namensformat <codeph>[spaltenname]</codeph> verwendet. Enthält die <codeph>SELECT</codeph>-Anweisung mehrere verbundene Tabellen und weisen zwei Spalten identische Namen auf, wird für diese das lange Namensformat <codeph>[tabellenname]_[spaltenname]</codeph> verwendet.</li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnNameStyle"><linktext>flash.data.SQLColumnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:connected:get"><apiName>connected</apiName><shortdesc>
     Gibt an, ob die „SQLConnection“-Instanz über eine offene Verbindung zu einer Datenbankdatei verfügt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob die „SQLConnection“-Instanz über eine offene Verbindung zu einer Datenbankdatei verfügt.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:inTransaction:get"><apiName>inTransaction</apiName><shortdesc>
	 Gibt an, ob diese Verbindung aktuell an einer Transaktion beteiligt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob diese Verbindung aktuell an einer Transaktion beteiligt ist.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     Der letzte von einer SQL „INSERT“-Anweisung erzeugte Zeilenbezeichner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Der letzte von einer SQL <codeph>INSERT</codeph>-Anweisung erzeugte Zeilenbezeichner. Ein Zeilenbezeichner dient zur eindeutigen Kennzeichnung einer Zeile in einer Tabelle in der Datenbank. Der Wert wird häufig von der Datenbank erzeugt.
	 
     <p>Der Wert lautet „zero“, wenn keine Datenbank verbunden ist oder wenn keine <codeph>INSERT</codeph>-Anweisung ausgeführt wurde.</p>
	 
	 <p>Den·Zeilenbezeichner für die Ausführung einer SQL <codeph>INSERT</codeph>-Anweisung erhalten Sie über die Eigenschaft <codeph>lastInsertRowID</codeph> des „SQLResult“-Objekts, das durch die Methode <codeph>getResult()</codeph> des „SQLStatement“-Objekts zurückgegeben wird (wenn sie aufgerufen wird, nachdem SQLStatement das <codeph>result</codeph>-Ereignis ausgelöst hat).</p>
	 
	 <p>Weitere Informationen zu Primärschlüsseln und generierten Zeilenbezeichnern finden Sie in den Abschnitten „<xref href="../../localDatabaseSQLSupport.html#createTable">CREATE TABLE</xref>“ und „<xref href="../../localDatabaseSQLSupport.html#expressions">Ausdrücke</xref>“ im Anhang „<xref href="../../localDatabaseSQLSupport.html">SQL-Unterstützung in lokalen Datenbanken</xref>“.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/lastInsertRowID"><linktext>flash.data.SQLResult.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:pageSize:get"><apiName>pageSize</apiName><shortdesc>
     Gibt die Datenbankseitengröße (in Byte) an, die bei der Erstellung der aktuellen Datenbank angegeben wurde (der Wert, der für den Parameter „pageSize“ beim Aufrufen von „open()“ oder „openAsync()“, durch den die Datenbank erstellt wurde, angegeben wurde).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Datenbankseitengröße (in Byte) an, die bei der Erstellung der aktuellen Datenbank angegeben wurde (der Wert, der für den Parameter <codeph>pageSize</codeph> beim Aufrufen von <codeph>open()</codeph> oder <codeph>openAsync()</codeph>, durch den die Datenbank erstellt wurde, angegeben wurde).
     
     <p>Wenn die Eigenschaft <codeph>connected</codeph> den Wert <codeph>false</codeph> aufweist, lautet der Wert dieser Eigenschaft 0.</p>
     
	 <p>Sie können die Seitengröße einer Datenbank ändern (mithilfe der Methoden <codeph>open()</codeph> oder <codeph>openAsync()</codeph>), solange noch keine Tabelle in der Datenbank erstellt wurde.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:totalChanges:get"><apiName>totalChanges</apiName><shortdesc>
     Gibt die Gesamtzahl der Datenänderungen an, die vorgenommen wurden, seit die Verbindung zur Datenbank hergestellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Gesamtzahl der Datenänderungen an, die vorgenommen wurden, seit die Verbindung zur Datenbank hergestellt wurde. Zusätzlich zu den Änderungen, die durch <codeph>INSERT</codeph>-, <codeph>DELETE</codeph>- und <codeph>UPDATE</codeph>-Anweisungen vorgenommen wurden, enthält dieser Wert auch die durch Auslöser verursachten Änderungen.
	 
	 <p>Ist die Datenbankverbindung geschlossen, wird der Wert auf „0“ zurückgesetzt. Wenn die „SQLConnection“-Instanz mit keine Datenbank verbunden ist, lautet der Wert „0“.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/rowsAffected"><linktext>flash.data.SQLResult.rowsAffected</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
 Die in einer „SQLTriggerSchema“-Instanz enthaltenen Informationen beschreiben einen bestimmten Auslöser·in einer Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die in einer „SQLTriggerSchema“-Instanz enthaltenen Informationen beschreiben einen bestimmten Auslöser·in einer Datenbank. Zu den verfügbaren Informationen gehören der Name des Auslösers (die Eigenschaft <codeph>name</codeph>), der Name der zugewiesenen Tabelle (die Eigenschaft <codeph>table</codeph>) und die SQL-Anweisung, mit der der Auslöser erstellt wurde (die Eigenschaft <codeph>sql</codeph>).
 
 <p>Um die Auslöserschemainformationen für eine Datenbank zu erhalten, laden Sie die Schemainformationen mithilfe der Methode <codeph>SQLConnection.loadSchema()</codeph>. Achten Sie dabei darauf, dass <codeph>null</codeph> oder <codeph>SQLTriggerSchema</codeph> als Wert für das Argument <codeph>type</codeph> angegeben ist. Die Eigenschaft <codeph>triggers</codeph> der resultierenden „SQLSchemaResult“-Instanz enthält ein Array mit „SQLTriggerSchema“-Instanzen, die die Auslöser in der Datenbank repräsentieren.</p>
 
 <p>Im Allgemeinen werden „SQLTriggerSchema“-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLTriggerSchema:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
     Erstellt eine „SQLTriggerSchema“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der zugeordneten Datenbank. 
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des Auslösers.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die SQL-Anweisung, mit der der Auslöser erstellt wurde.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Tabelle, die dem Auslöser zugeordnet ist.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLTriggerSchema“-Instanz. Im Allgemeinen wird der „SQLTriggerSchema“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Schemainformationen für eine Datenbank erhalten Sie durch einen Aufruf der Methode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLTriggerSchema:table:get"><apiName>table</apiName><shortdesc>
     Der Name der Tabelle, für die der Auslöser definiert wurde, oder der Name der Ansicht, falls der Auslöser für eine Ansicht definiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Der Name der Tabelle, für die der Auslöser definiert wurde, oder der Name der Ansicht, falls der Auslöser für eine Ansicht definiert wurde.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
 Eine SQL-Anweisung wird mithilfe einer „SQLStatement“-Instanz an einer lokalen SQL-Datenbank ausgeführt, die über eine „SQLConnection“-Instanz geöffnet ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Eine SQL-Anweisung wird mithilfe einer „SQLStatement“-Instanz an einer lokalen SQL-Datenbank ausgeführt, die über eine „SQLConnection“-Instanz geöffnet ist.
 
 <p>Eine SQLStatement-Instanz wird mit einem SQLConnection-Objekt verknüpft, indem Sie die SQLConnection-Instanz als Wert der <codeph>sqlConnection</codeph>-Eigenschaft des SQLConnection-Objekts einstellen. Der Eigenschaft <codeph>text</codeph> wird der Text der auszuführenden SQL-Anweisung zugewiesen. Bei Bedarf werden die Parameterwerte der SQL-Anweisung mithilfe der Eigenschaft <codeph>parameters</codeph>angegeben; die Anweisung wird durch Aufrufen der Methode <codeph>execute()</codeph> ausgeführt.</p>
 
 <p>Eine umfassende Beschreibung des von der lokalen SQL-Datenbank unterstützten SQL-Dialekts finden Sie im Anhang <xref href="../../localDatabaseSQLSupport.html">SQL-Unterstützung in lokalen Datenbanken</xref>.</p>
 
 <p>Im asynchronen Ausführungsmodus werden die Methoden <codeph>execute()</codeph> und <codeph>next()</codeph> im Hintergrund ausgeführt, und zur Laufzeit werden beim Abschluss oder Fehlschlagen der Vorgänge Ereignisse an registrierte Ereignis-Listener oder an eine angegebene Responder-Instanz ausgelöst. Im synchronen Modus werden die Methoden auf dem Hauptanwendungs-Thread ausgeführt, was bedeutet, dass erst nach Abschluss der Datenbankvorgänge ein anderer Code ausgeführt werden kann. Außerdem wird im synchronen Modus beim Fehlschlagen der Methoden zur Laufzeit kein Fehlerereignis sondern eine Ausnahme ausgelöst.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection"><linktext>flash.data.SQLConnection</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Wird ausgelöst, wenn während des Vorgangs ein Fehler auftritt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn während des Vorgangs ein Fehler auftritt.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLEvent.RESULT_result"><apiName>result</apiName><shortdesc>
 Wird ausgelöst, wenn die Methode „execute()“ oder „next()“ erfolgreich ausgeführt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.RESULT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn die Methode <codeph>execute()</codeph> oder <codeph>next()</codeph> erfolgreich ausgeführt wurde. Nachdem das Ereignis <codeph>result</codeph> ausgelöst wurde, können Sie die Methode <codeph>getResult()</codeph> aufrufen, um Anweisungsergebnisse abzurufen.
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLStatement:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
     Erstellt eine „SQLStatement“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Konstruktor aus einer Sandbox außerhalb der Hauptanwendungs-Sandbox aufgerufen wird. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Erstellt eine „SQLStatement“-Instanz.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLStatement:cancel"><apiName>cancel</apiName><shortdesc>
     Bricht die Ausführung dieser Anweisung ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Bricht die Ausführung dieser Anweisung ab. Mithilfe dieser Methode können Sie, wie mit der <codeph>SQLConnection.cancel()</codeph>-Methode, eine noch nicht abgeschlossene Abfrage abbrechen. Im Gegensatz zu <codeph>SQLConnection.cancel()</codeph> wird mithilfe dieser Methode jedoch nur eine Anweisung abgebrochen. Wird diese Anweisung gerade nicht ausgeführt, hat das Aufrufen dieser Methode keine Auswirkung.
	 
	 <p>Als direkte Reaktion auf den Abschluss des Vorgangs <codeph>cancel()</codeph> werden keine Ereignisse ausgelöst. Sobald der Vorgang <codeph>cancel()</codeph> abgeschlossen und die Ausführung der Anweisung abgebrochen ist, wird von der „SQLStatement“-Instanz ein <codeph>error</codeph>-Ereignis ausgelöst, mit dem angegeben wird, dass die Ausführung der Anweisung (der Aufruf <codeph>execute()</codeph> oder <codeph>next()</codeph>) nicht abgeschlossen wurde. Wenn für den Parameter <codeph>responder</codeph> des Aufrufs <codeph>execute()</codeph> oder <codeph>next()</codeph> ein Wert angegeben wurde, wird die angegebene Fehlerprozedurmethode aufgerufen. In beiden Fällen weist die an die Listener übergebene SQLError-Instanz eine <codeph>errorID</codeph>-Eigenschaft mit dem Wert „3118“ (Vorgang abgebrochen) auf.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLStatement:clearParameters"><apiName>clearParameters</apiName><shortdesc>
     Löscht alle aktuellen Parametereinstellungen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Löscht alle aktuellen Parametereinstellungen.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/parameters"><linktext>parameters</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:execute"><apiName>execute</apiName><shortdesc>
     Führt die in der Eigenschaft „text“ enthaltene SQL an der Datenbank aus, die mit dem „SQLConnection“-Objekt in der Eigenschaft „sqlConnection“ verbunden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die <codeph>text</codeph>-Eigenschaft den Wert <codeph>null</codeph> hat oder einen leeren String (<codeph>""</codeph>) enthält; wenn die <codeph>sqlConnection</codeph>-Eigenschaft nicht eingestellt ist; wenn die der <codeph>sqlConnection</codeph>-Eigenschaft zugewiesene SQLConnection-Instanz nicht verbunden ist; oder wenn die Anweisung gerade ausgeführt wird.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Wenn es sich bei der Eigenschaft <codeph>text</codeph> der Anweisung um eine <codeph>SELECT</codeph>-Anweisung handelt, gibt dieser Wert an, wieviele Zeilen die zurückgegebene Anweisung enthält. Der Standardwert ist „-1“, was bedeutet, dass alle Ergebniszeilen zurückgegeben werden. Dieser Parameter wird in Verbindung mit der Methode <codeph>next()</codeph> verwendet, um umfangreiche Ergebnissätze in kleinere Datensätze zu unterteilen. Das kann die Beurteilung der Anwendungsleistung durch Benutzer verbessern, da die ersten Ergebnisse schneller geliefert und Ergebnisverarbeitungsvorgänge unterteilt werden.
     
     <p>Wenn es sich bei der SQL-Anweisung um eine <codeph>SELECT</codeph>-Abfrage handelt und ein <codeph>prefetch</codeph>-Argument größer Null angegeben wurde, wird die Anweisung ausgeführt, bis der gesamte Ergebnissatz zurückgegeben ist oder entweder die Methode <codeph>SQLStatement.cancel()</codeph> oder <codeph>SQLConnection.cancel()</codeph> aufgerufen wird. Da die Anzahl der Zeilen in einem Ergebnissatz bei der Ausführung nicht bekannt ist, gilt die Anweisung erst als abgeschlossen, wenn sich der Cursor in der Datenbank jenseits der letzten Zeile im Ergebnissatz befindet. Wenn ein <codeph>prefetch</codeph>-Argument in einem <codeph>execute()</codeph>-Aufruf angegeben ist, muss mindestens eine Zeile mehr als die Gesamtzahl der im Ergebnissatz enthaltenen Zeilen angefordert werden (entweder durch einen <codeph>prefetch</codeph>-Wert, der größer als die Anzahl der im Ergebnissatz enthaltenen Zeilen ist, oder durch weitere Aufrufe der Methode <codeph>next()</codeph>); erst dann weist die Eigenschaft <codeph>complete</codeph> der resultierenden „SQLResult“-Instanz den Wert <codeph>true</codeph> auf.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Falls im asynchronen Ausführungsmodus das Argument <codeph>responder</codeph> gleich <codeph>null</codeph> ist, wird ein <codeph>result</codeph>- oder <codeph>error</codeph>-Ereignis ausgelöst, sobald die Ausführung abgeschlossen ist.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt die in der Eigenschaft <codeph>text</codeph> enthaltene SQL an der Datenbank aus, die mit dem „SQLConnection“-Objekt in der Eigenschaft <codeph>sqlConnection</codeph> verbunden ist.
     
	 <p>Falls im asynchronen Ausführungsmodus das <codeph>responder</codeph>-Argument nicht gleich <codeph>null</codeph> ist, gibt das festgelegte Responder-Objekt die Methoden an, die aufgerufen werden, um die Ergebnisse des Vorgangs zu verarbeiten. Wenn das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> hat, wird bei einem erfolgreichen Abschluss des Vorgangs ein <codeph>result</codeph>-Ereignis ausgelöst. Schlägt der Vorgang fehl, wird ein <codeph>error</codeph>-Ereignis ausgelöst.</p>
	 
	 <p>Um auf die Ergebnisse einer Anweisung zuzugreifen, zum Beispiel auf die Ergebniszeilen einer <codeph>SELECT</codeph>-Anweisung oder auf den von der Datenbank generierten primären Schlüssel einer <codeph>INSERT</codeph>-Anweisung, rufen Sie die <codeph>getResult()</codeph>-Methode auf. Die Ergebnisse sind im synchronen Modus sofort nach der Ausführung der Anweisung verfügbar; im asynchronen Modus nach dem Absetzen des <codeph>result</codeph>-Ereignisses.</p>
     
     <p>Eine Anweisung kann erst ausgeführt werden, nachdem sie vorbereitet (kompiliert) wurde. Beim ersten Aufrufen der Methode <codeph>execute()</codeph> einer „SQLStatement“-Instanz wird die Anweisung zur Laufzeit vorbereitet. Eine einmal vorbereitete Anweisung braucht nur aufgrund einer Änderung der Eigenschaft <codeph>text</codeph> erneut vorbereitet zu werden. Durch die Einstellung von Parameterwerten wird keine erneute Vorbereitung der Anweisung erforderlich.</p>
	 
     </apiDesc><example conref="examples\SQLStatement.execute.1.as"> Im folgenden Beispiel für die Ausführung eines SQLStatements wird demonstriert, wie die erfolgreiche Ausführung oder das Fehlschlagen mithilfe von Ereignis-Listenern bestimmt wird.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example><example conref="examples\SQLStatement.execute.2.as"> Im folgenden Beispiel für die Ausführung eines SQLStatements wird demonstriert, wie mithilfe eines Responder-Objekts angegeben wird, welche Funktionen bei der erfolgreichen Ausführung oder dem Fehlschlagen der Anweisung aufgerufen werden.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;
var employeeResponder:Responder;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    employeeResponder = new Responder(resultHandler, errorHandler);
    dbStatement.execute(-1, employeeResponder);
}

function resultHandler(result:SQLResult):void
{
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(error:SQLError):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:execute_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn die Anweisung erfolgreich ausgeführt wurde oder ein Wert für ein <codeph>prefetch</codeph>-Argumentwert angegeben ist und eine <codeph>SELECT-</codeph>Anweisung eine oder mehrere Datenzeilen zurückgibt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn die Anweisungsausführung erfolgreich abgeschlossen wird, oder wenn ein Wert für ein „prefetch“-Argument angegeben ist und eine „SELECT“-Anweisung eine oder mehrere Datenzeilen zurückgibt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:execute_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLStatement:getResult"><apiName>getResult</apiName><shortdesc>
     Bietet Zugriff auf ein „SQLResult“-Objekt, das die Ergebnisse der Anweisungsausführung enthält, und zwar einschließlich der Ergebniszeilen einer „SELECT“-Anweisung sowie weiterer Informationen über die Anweisungsausführung für alle ausgeführten Anweisungen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein „SQLResult“-Objekt, das das Ergebnis eines Aufrufs der Methode <codeph>execute()</codeph> oder <codeph>next()</codeph> enthält.
     
     </apiDesc><apiOperationClassifier>flash.data:SQLResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Bietet Zugriff auf ein „SQLResult“-Objekt, das die Ergebnisse der Anweisungsausführung enthält, und zwar einschließlich der Ergebniszeilen einer <codeph>SELECT</codeph>-Anweisung sowie weiterer Informationen über die Anweisungsausführung für alle ausgeführten Anweisungen. Im asynchronen Modus stehen die Ergebnisinformationen erst nach Auslösung des <codeph>result</codeph>-Ergebnisses zur Verfügung.
     
     <p>Wenn bei der Ausführung einer <codeph>SELECT</codeph>-Anweisung die Methode <codeph>execute()</codeph> aufgerufen wird, wobei das Standardargument <codeph>prefetch</codeph> den Wert „-1“ hat, enthält das zurückgegebene „SQLResult“-Objekt den vollständigen Ergebnissatz der Abfrage.</p>
     
     <p>Wurde das Argument <codeph>prefetch</codeph> für den Aufruf der Methode <codeph>execute()</codeph> oder <codeph>next()</codeph> angegeben, werden von der·Methode <codeph>getResult()</codeph> die ältesten Ergebnisse in der Warteschlange zuerst verarbeitet. Jedesmal, wenn das Ereignis <codeph>result</codeph> ausgelöst wird, wird der Warteschlange ein neues „SQLResult“-Objekt hinzugefügt. Bei jedem Aufrufen der Methode <codeph>getResult()</codeph> wird das „SQLResult“-Objekt, das sich am längsten in der Warteschlange befindet, zurückgegeben und aus der Warteschlange entfernt. Enthält die Warteschlange keine „SQLResult“-Objekte mehr, gibt <codeph>getResult()</codeph> den Wert <codeph>null</codeph> zurück.</p>
	 
	 <p>Beachten Sie, dass „SQLResult“-Objekte in der Warteschlange verbleiben, bis sie durch einen Aufruf von <codeph>getResult()</codeph> daraus entfernt werden. Beispiel: Wenn die <codeph>execute()</codeph>-Methode mehrfach aufgerufen wird, <codeph>getResult()</codeph> jedoch nicht, verbleiben die mit jedem Aufruf von <codeph>execute()</codeph> verknüpften SQLResult-Objekte in der Warteschlange.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/result"><linktext>result</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:next"><apiName>next</apiName><shortdesc>
     Ruft den nächsten Teil des Ergebnissatzes einer „SELECT“-Anweisung ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die Methode aufgerufen wird, während die Anweisung nicht ausgeführt wird, weist die Eigenschaft <codeph>executing</codeph> den Wert <codeph>false</codeph> auf.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>wenn der Vorgang im synchronen Ausführungsmodus fehlschlägt.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Wenn es sich bei der Eigenschaft <codeph>text</codeph> der Anweisung um eine <codeph>SELECT</codeph>-Anweisung handelt, gibt dieser Wert an, wieviele Zeilen die zurückgegebene Anweisung enthält. Der Standardwert ist „-1“, was bedeutet, dass alle Ergebniszeilen zurückgegeben werden. Das kann die Beurteilung der Anwendungsleistung durch Benutzer verbessern, da die ersten Ergebnisse schneller geliefert und Ergebnisverarbeitungsvorgänge unterteilt werden.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Objekt, das die Methoden angibt, die im Anschluss an einen erfolgreich abgeschlossenen oder fehlgeschlagenen Vorgang aufgerufen werden. Wenn das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> aufweist, wird bei Abschluss der Ausführung das Ereignis·<codeph>result</codeph> oder <codeph>error</codeph> ausgelöst.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ruft den nächsten Teil des Ergebnissatzes einer <codeph>SELECT</codeph>-Anweisung ab. Wenn der Ergebnissatz keine weiteren Zeilen mehr enthält, wird ein <codeph>result</codeph>-Ereignis ausgelöst, aber kein weiteres „SQLResult“-Objekt zur Warteschlange <codeph>getResult()</codeph> hinzugefügt.
     
     <p>Falls im asynchronen Ausführungsmodus das <codeph>responder</codeph>-Argument nicht gleich <codeph>null</codeph> ist, gibt das festgelegte Responder-Objekt die Methoden an, die aufgerufen werden, um die Ergebnisse des Vorgangs zu verarbeiten. Wenn das Argument <codeph>responder</codeph> den Wert <codeph>null</codeph> hat, wird bei einem erfolgreichen Abschluss des Vorgangs ein <codeph>result</codeph>-Ereignis ausgelöst. Schlägt der Vorgang fehl, wird ein <codeph>error</codeph>-Ereignis ausgelöst.</p>
     
     <p>Diese Methode kann nur aufgerufen werden, solange die Anweisung ausgeführt wird. Wenn es sich bei der Anweisung um eine <codeph>SELECT</codeph>-Abfrage handelt und ein <codeph>prefetch</codeph>-Argument größer Null angegeben wurde, wird die Anweisung ausgeführt, bis der gesamte Ergebnissatz zurückgegeben ist oder entweder die Methode <codeph>SQLStatement.cancel()</codeph> oder <codeph>SQLConnection.cancel()</codeph> aufgerufen wird.</p>
     
     </apiDesc><example conref="examples\SQLStatement.next.1.as"> Das folgende Beispiel demonstriert die Ausführung eines SQLStatements, in dem ausdrücklich festgelegt wurde, dass bei der ersten Rückgabe des Ergebnisses nur die ersten zehn Zeilen des Ergebnissatzes enthalten sein sollen. Der Code überprüft die Eigenschaft <codeph>complete</codeph> von SQLResult und ruft die Methode <codeph>next()</codeph> auf, falls nicht alle Zeilen abgerufen wurden.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute(10);
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
        if (!result.complete)
        {
            dbStatement.next(10);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:next_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn die Anweisung erfolgreich ausgeführt wurde oder ein Wert für ein <codeph>prefetch</codeph>-Argument angegeben ist und der Aufruf von <codeph>next()</codeph> eine oder mehrere Datenzeilen zurückgibt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn die Anweisungsausführung erfolgreich abgeschlossen wird, oder wenn ein Wert für ein „prefetch“-Argument angegeben ist und der Aufruf von „next()“ eine oder mehrere Datenzeilen zurückgibt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:next_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Vorgang im asynchronen Ausführungsmodus fehlschlägt.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLStatement:executing:get"><apiName>executing</apiName><shortdesc>
     Gibt an, ob die Anweisung aktuell ausgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob die Anweisung aktuell ausgeführt wird.
     
     <p>Diese Eigenschaft hat den Wert „true“, wenn <codeph>execute()</codeph> aufgerufen wurde und von der Datenbank nicht alle Ergebnisse zurückgegeben wurden.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:itemClass:get"><apiName>itemClass</apiName><shortdesc>
     Gibt eine Klasse (Datentyp) an, die für jede als Ergebnis der Anweisungsausführung zurückgebenene Zeile verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Class</apiValueClassifier></apiValueDef><apiDesc>
     Gibt eine Klasse (Datentyp) an, die für jede als Ergebnis der Anweisungsausführung zurückgebenene Zeile verwendet wird.
     
     <p platform="javascript">Diese Eigenschaft ist nur für die Verwendung in SWF-basierten AIR-Anwendungen vorgesehen. Sie kann nicht in JavaScript verwendet werden. (In ActionScript können Sie benutzerdefinierte Klassen definieren, die Sie mit dieser Eigenschaft verwenden.)</p>
     
     <p platform="actionscript">Standardmäßig wird jede von einer <codeph>SELECT</codeph>-Anweisung zurückgegebene Zeile als „Object“-Instanz erstellt. Dabei treten die Spaltennamen des Ergebnissatzes als Eigenschaftsnamen des Objekts auf und die Werte der Spalten als die Werte der jeweiligen Eigenschaften.</p>
     
     <p platform="actionscript">Durch die Angabe einer Klasse für die Eigenschaft <codeph>itemClass</codeph> wird jede Zeile, die bei der Ausführung dieser „SQLStatement“-Instanz von einer <codeph>SELECT</codeph>-Anweisung zurückgegeben wird, als Instanz der angegebenen·Klasse erstellt. Jeder Eigenschaft der Instanz <codeph>itemClass</codeph> wird der Wert aus der gleichnamigen Spalte zugewiesen.</p>
     
     <p platform="actionscript">Eine dieser Eigenschaft zugewiesene Klasse muss über einen Konstruktor verfügen, der keine Parameter erfordert. Außerdem muss die Klasse je eine Eigenschaft für jede von der Anweisung <codeph>SELECT</codeph> zurückgegebene Spalte aufweisen. Es gilt als Fehler, wenn es für eine Spalte der Liste <codeph>SELECT</codeph> keinen entsprechenden Eigenschaftsnamen in der Klasse <codeph>itemClass</codeph> gibt.</p>
     
     </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> Das folgende Beispiel demonstriert, wie mithilfe der Eigenschaft <codeph>itemClass</codeph> zur Laufzeit Instanzen einer benutzerdefinierten Klasse aus den Ergebnissen einer SQL <codeph>SELECT</codeph>-Anweisung erstellt werden.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/data"><linktext>flash.data.SQLResult.data</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:parameters:get"><apiName>parameters</apiName><shortdesc>
     Dient als assoziatives Array, dem Sie Werte für die in der Eigenschaft „text“ der SQL-Anweisung angegebenen Parameter hinzufügen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Dient als assoziatives Array, dem Sie Werte für die in der Eigenschaft <codeph>text</codeph> der SQL-Anweisung angegebenen Parameter hinzufügen. Bei den Array-Schlüsseln handelt es sich um die Namen der Parameter. Wenn im Anweisungstext ein unbenannter Parameter angegeben wird, handelt es sich bei seinem Schlüssel um den Index des Parameters.
     
     <p>Im Text einer SQL-Anweisung wird ein Parameter mit einem der folgenden Zeichen gekennzeichnet: „?“, „:“ oder „@“.</p>
     
     <p>Mit den Token „:“ und „@“ wird ein benannter Parameter gekennzeichnet; die darauf folgenden Zeichen geben den Namen des Parameters an.</p>
     
     <p>Beispiel: In der folgenden SQL-Anweisung wird ein Parameter namens <codeph>firstName</codeph> mit dem Token·„:“ gekennzeichnet:</p>
     
     <pre>SELECT FROM employees WHERE firstName = :firstName</pre>
     
     <p>Das Token „?“ kennzeichnet einen indizierten (nummerierten) Parameter; gemäß der Reihenfolge der Parameter im Anweisungstext erhält jeder Parameter automatisch eine Indexposition. Die Indexpositionswerte der Parameter basieren auf null. d. h. die Indexposition des ersten Parameters lautet 0.</p>
     
     <p>Parameter dienen zur typisierten Ersetzung von Werten, die bei der Konstruktion der SQL-Anweisung unbekannt sind. Nur mithilfe von Parameter kann die Speicherklasse eines an die Datenbank übergebenen Wertes sichergestellt werden. Ohne Parameter werden alle Werte auf der Basis der Typenaffinität der zugewiesenen Spalte von ihrer Textrepräsentation in eine Speicherklasse konvertiert. Weitere Informationen zu Speicherklassen und Spaltenaffinität finden Sie im Abschnitt „<xref href="../../localDatabaseSQLSupport.html#dataTypes">Datentypunterstützung</xref>“ im Anhang „<xref href="../../localDatabaseSQLSupport.html">SQL-Unterstützung in lokalen Datenbanken</xref>“.</p>
     
     <p>Parameter werden auch als Sicherheitsmaßnahmen zur Verhinderung eines böswilligen Verfahrens, das als SQL-Injektionsangriff bekannt ist, eingesetzt. Bei einem SQL-Injektionsangriff gibt ein Benutzer einen SQL-Code an einer für Benutzer zugänglichen Stelle ein (z. B. ein Dateneingabefeld). Wenn der Anwendungscode eine SQL-Anweisung durch die direkte Verkettung·einer Benutzereingabe mit dem SQL-Text erstellt, wird der vom Benutzer eingegebene SQL-Code an der Datenbank ausgeführt. Das folgende Beispiel zeigt die Verkettung·der Benutzereingabe mit dem SQL-Text. <b>Verwenden Sie dieses Verfahren·nicht</b>:</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement = new air.SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <p>Ein SQL-Injektionsangriff lässt sich verhindern, indem Anweisungsparameter verwendet werden, anstatt durch Benutzer eingegebene Werte mit dem Anweisungstext zu verketten. Die Parameterwerte werden ausdrücklich als ersetzte Werte behandelt und werden nicht Teil des eigentlichen Anweisungstexts. Folgendes ist die empfohlene Alternative zur vorherigen Notierung:</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement = new air.SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <p>Alle Parameterwerte müssen vor der Ausführung der Anweisung eingestellt sein. Im Array <codeph>parameters</codeph> angegebene Parameter werden·gebunden (d. h. mit dem Anweisungstext kombiniert), wenn die Methode <codeph>execute()</codeph> aufgerufen wird. Nachdem <codeph>execute()</codeph> aufgerufen wurde, werden alle späteren Werteänderungen nicht auf die ausführende Anweisung angewendet. Bei einem anschließenden Aufrufen von <codeph>execute()</codeph> werden die geänderten Werte jedoch angewendet. Enthält der Anweisungstext einen Parameter, für den in der <codeph>parameters</codeph>-Eigenschaft kein Wert angegeben ist, wird ein Fehler ausgelöst.</p>
     
     <p>Sie können alle Parameterwerte aus der Eigenschaft <codeph>parameters</codeph> mithilfe der Methode <codeph>clearParameters()</codeph> löschen.</p>
     
	 </apiDesc><example conref="examples\SQLStatement.parameters.1.as"> Das folgende Beispiel demonstriert die Verwendung des benannten Parameters <codeph>:firstName</codeph> in einer SQL-Anweisung.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = :firstName";
employees.parameters[":firstName"] = "Sam";
employees.execute();
</codeblock></example><example conref="examples\SQLStatement.parameters.2.as"> Das folgende Beispiel demonstriert die Verwendung eines unbenannten Parameters in einer SQL-Anweisung.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = ?";
employees.parameters[0] = "Sam";
employees.execute();
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/text"><linktext>text</linktext></link><link href="flash.data.xml#SQLStatement/clearParameters()"><linktext>clearParameters()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:sqlConnection:get"><apiName>sqlConnection</apiName><shortdesc>
     Das SQLConnection-Objekt, das die Verbindung zu den Datenbanken verwaltet, auf denen die Anweisung ausgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.data:SQLConnection</apiValueClassifier><apiException><apiDesc>Wenn versucht wird, den Wert dieser Eigenschaft während der Anweisungsausführung zu ändern.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Das SQLConnection-Objekt, das die Verbindung zu den Datenbanken verwaltet, auf denen die Anweisung ausgeführt wird.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLStatement:text:get"><apiName>text</apiName><shortdesc>
     Der tatsächliche SQL-Text der Anweisung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn versucht wird, die Eigenschaft <codeph>text</codeph> während der Anweisungausführung zu ändern.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Der tatsächliche SQL-Text der Anweisung.
	 
     <p>Beim Text kann es sich um jede unterstützte SQL handeln. Eine umfassende Beschreibung des von der lokalen SQL-Datenbank unterstützten SQL-Dialekts finden Sie im Anhang „<xref href="../../localDatabaseSQLSupport.html">SQL-Unterstützung in lokalen Datenbanken</xref>“.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLMode"><apiName>SQLMode</apiName><shortdesc>
 Diese Klasse enthält die Konstanten, die die möglichen Werte des Parameters „openMode“ der Methoden „SQLConnection.open()“ und „SQLConnection.openAsync()“ darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Diese Klasse enthält die Konstanten, die die möglichen Werte des Parameters <codeph>openMode</codeph> der Methoden <codeph>SQLConnection.open()</codeph> und <codeph>SQLConnection.openAsync()</codeph> darstellen.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links><apiValue id="flash.data:SQLMode:CREATE"><apiName>CREATE</apiName><shortdesc>
	 Gibt an, dass die Verbindung für Aktualisierungen geöffnet wird und dass eine Datenbankdatei erstellt wird, wenn die angegebene Datei nicht existiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>create</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass die Verbindung für Aktualisierungen geöffnet wird und dass eine Datenbankdatei erstellt wird, wenn die angegebene Datei nicht existiert. In diesem Modus ist Lesen und Schreiben in der Datenbank zulässig. Falls die Datenbank nicht existiert, wird sie vor Abschluss des Vorgangs erstellt.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:READ"><apiName>READ</apiName><shortdesc>
	 Gibt an, dass die Verbindung im schreibgeschützten Modus geöffnet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>read</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass die Verbindung im schreibgeschützten Modus geöffnet wird. In diesem Modus ist Schreiben in der Datenbank nicht zulässig. Falls die Datenbank nicht existiert, schlägt der Vorgang fehl.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:UPDATE"><apiName>UPDATE</apiName><shortdesc>
	 Gibt an, dass die Verbindung für Aktualisierungen geöffnet wird und dass eine neue Datenbankdatei erstellt wird, wenn die angegebene Datei nicht existiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>update</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass die Verbindung für Aktualisierungen geöffnet wird und dass eine neue Datenbankdatei erstellt wird, wenn die angegebene Datei nicht existiert. In diesem Modus ist Lesen und Schreiben in der Datenbank zulässig. Falls die Datenbank nicht existiert, schlägt der Vorgang fehl.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:EncryptedLocalStore"><apiName>EncryptedLocalStore</apiName><shortdesc>
	Die „EncryptedLocalStore“-Klasse bietet Methoden, mit denen Objekte im verschlüsselten lokalen Datenspeicher einer AIR-Anwendung festgelegt und daraus abgerufen werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die „EncryptedLocalStore“-Klasse bietet Methoden, mit denen Objekte im verschlüsselten lokalen Datenspeicher einer AIR-Anwendung festgelegt und daraus abgerufen werden können. Für jede auf dem Computer eines Benutzers installierte AIR-Anwendung steht ein permanenter, verschlüsselter und lokaler Speicher zur Verfügung. Dadurch können Daten auf der lokalen Festplatte des Benutzers in einem verschlüsselten Format gespeichert und abgerufen werden, das weder von einer anderen Anwendung noch von einem anderen Benutzer entschlüsselt werden kann. Für jede AIR-Anwendung wird ein separater, verschlüsselter und lokaler Speicher verwendet, und jede AIR-Anwendung verwendet einen separaten, verschlüsselten und lokalen Speicher für jeden Benutzer. 
	
	<p>Es empfiehlt sich, den verschlüsselten lokalen Speicher für Daten zu verwenden, die gesichert werden müssen (z. B. Anmeldeinformationen für Webdienste).</p>
	
	<p>Beim Testen einer Anwendung mit dem AIR Debug Launcher (ADL) wird ein anderer verschlüsselter lokaler Speicher verwendet als von der installierten AIR-Anwendung.</p>
	
	<p>AIR verwendet DPAPI unter Windows<sup>®</sup>, KeyChain unter Mac<sup>®</sup> OS<sup>®</sup> und KeyRing oder KWallet unter Linux<sup>®</sup>, um den lokalen Speicher mit jeder Anwendung und jedem Benutzer zu verbinden. Die Verschlüsselung im lokalen Speicher erfolgt mit AES-CBC 128 Bit-Verschlüsselung.</p>
	
	<p>Die im verschlüsselten lokalen Speicher enthaltenen Informationen stehen nur als AIR-Anwendungsinhalt in der Sicherheitssandbox der Anwendung zur Verfügung. </p>
	
	<p>Die Elemente im verschlüsselten lokalen Speicher werden mit einem String gekennzeichnet. Alle Elemente werden als Byte-Array-Daten gespeichert.</p>
	
	<p>Der verschlüsselte lokale Speicher kann langsamer sein, wenn die gespeicherte Datenmenge 10 MB übersteigt.</p>
	
	<p>Bei der Deinstallation einer AIR-Anwendung werden die Daten im verschlüsselten lokalen Speicher nicht gelöscht.</p>
	
	<p>Daten im verschlüsselten lokalen Speicher werden in einem Unterverzeichnis des Anwendungsdatenverzeichnisses gespeichert; der Unterverzeichnispfad lautet Adobe/AIR/ELS/ gefolgt von der Anwendungs-ID.</p>
	
	</apiDesc><example conref="examples\EncryptedLocalStore.1.as"> Mit dem folgenden Codebeispiel wird ein String im verschlüsselten lokalen Speicher gespeichert, abgerufen und dann gelöscht:
<codeblock>
var str:String = "Bob";
var bytes:ByteArray = new ByteArray();
bytes.writeUTFBytes(str);
EncryptedLocalStore.setItem("firstName", bytes);

var storedValue:ByteArray = EncryptedLocalStore.getItem("firstName");
trace(storedValue.readUTFBytes(storedValue.length)); // "Bob"

EncryptedLocalStore.removeItem("firstName");
</codeblock></example></apiClassifierDetail><apiOperation id="flash.data:EncryptedLocalStore:getItem"><apiName>getItem</apiName><shortdesc>
		Gibt die Daten für das Element mit dem angegebenen Namen im verschlüsselten lokalen Speicher zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Der <codeph>name</codeph>-Wert ist <codeph>null</codeph> oder ein leerer String.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die ByteArray-Daten. Wenn für den angegebenen <codeph>name</codeph> keine Daten vorhanden sind, gibt die Methode <codeph>null</codeph> zurück.
		
		</apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des Elements im verschlüsselten lokalen Speicher.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Gibt die Daten für das Element mit dem angegebenen Namen im verschlüsselten lokalen Speicher zurück. Wenn es kein Element mit dem angegebenen Namen gibt, gibt diese Methode <codeph>null</codeph> zurück.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:removeItem"><apiName>removeItem</apiName><shortdesc>
		Entfernt das Element mit dem angegebenen Namen aus dem verschlüsselten lokalen Speicher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Der <codeph>name</codeph>-Wert ist <codeph>null</codeph> oder ein leerer String.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des Elements im verschlüsselten lokalen Speicher.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Entfernt das Element mit dem angegebenen Namen aus dem verschlüsselten lokalen Speicher.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:reset"><apiName>reset</apiName><shortdesc>
		Löscht alle Daten im verschlüsselten lokalen Speicher. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		Löscht alle Daten im verschlüsselten lokalen Speicher. 
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:setItem"><apiName>setItem</apiName><shortdesc>
		Speichert·das Element mit dem angegebenen Namen unter den angegebenen ByteArray-Daten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Der <codeph>name</codeph>-Wert ist <codeph>null</codeph> oder ein leerer String.
		
		<p>Standardmäßig ist eine AIR-Anwendung nicht in der Lage, den verschlüsselten lokalen Speicher einer anderen Anwendung zu lesen. Die Einstellung <codeph>stronglyBound</codeph> bietet eine zusätzliche Bindung (an die Daten in der Anwendung), mit der verhindert wird, dass eine angreifende Anwendung durch Kopieren der Hersteller-ID der Anwendung den verschlüsselten lokalen Speicher Ihrer Anwendung liest.</p> 
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des Elements im verschlüsselten lokalen Speicher.
		
		</apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Die Daten.
		
		</apiDesc></apiParam><apiParam><apiItemName>stronglyBound</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Bei <codeph>true</codeph> ist das gespeicherte Element eng an die digitale Signatur und Bits der AIR-Anwendung (die Inhalte des Anwendungsordners) gebunden sowie an die Veröffentlicher-ID der Anwendung. Bei einem nachfolgenden Aufruf von <codeph>getItem()</codeph> für dieses Element tritt zur Laufzeit eine Ausnahme auf, wenn die Bits der aufrufenden AIR-Anwendung nicht mit jenen der speichernden Anwendung übereinstimmen. Wenn Sie Ihre Anwendung aktualisieren, kann sie stark gebundene Daten, die früher in den verschlüsselten lokalen Speicher geschrieben wurden, nicht lesen. 
		
		<p>Ist der <codeph>stronglyBound</codeph>-Parameter auf <codeph>false</codeph> gesetzt (Standardwert), muss nur die Hersteller-ID gleich bleiben, damit die Anwendung die Daten lesen kann. Die Bits der Anwendung können sich ändern (und sie müssen vom Hersteller signiert werden). Es müssen aber nicht dieselben Bits sein, wie in der Anwendung, in der die Daten gespeichert wurden.</p>
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Setzt·das Element mit dem angegebenen Namen auf die angegebenen ByteArray-<codeph>data</codeph>.
		
		</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.data:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
 Die in einer „SQLIndexSchema“-Instanz enthaltenen Informationen beschreiben einen bestimmten Index in einer Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die in einer „SQLTableSchema“-Instanz enthaltenen Informationen beschreiben eine bestimmte Tabelle in einer Datenbank. Zu den verfügbaren Informationen gehören der Name der verknüpften Tabelle (die <codeph>table</codeph>-Eigenschaft), die SQL-Anweisung, mit der die Indexposition erstellt wurde (die <codeph>sql</codeph>-Eigenschaft) und der Name derIndexposition (die <codeph>name</codeph>-Eigenschaft).
 
 <p>Um die Indexschemainformationen für eine Datenbank zu erhalten, laden Sie die Schemainformationen mithilfe der Methode <codeph>SQLConnection.loadSchema()</codeph>. Achten Sie dabei darauf, dass <codeph>null</codeph> oder <codeph>SQLIndexSchema</codeph> als Wert für das Argument <codeph>type</codeph> angegeben ist. Die Eigenschaft <codeph>indices</codeph> der resultierenden „SQLSchemaResult“-Instanz enthält ein Array mit „SQLIndexSchema“-Instanzen, die die Indizes in der Datenbank repräsentieren.</p>
 
 <p>Im Allgemeinen werden „SQLIndexSchema“-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLIndexSchema:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
     Erstellt eine „SQLIndexSchema“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der zugeordneten Datenbank.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des Index.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die SQL-Anweisung, mit der dieser Index erstellt wurde.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Tabelle, mit der dieser Index verbunden ist.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLIndexSchema“-Instanz. Im Allgemeinen wird der „SQLIndexSchema“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Schemainformationen für eine Datenbank erhalten Sie durch einen Aufruf der Methode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/indices"><linktext>flash.data.SQLSchemaResult.indices</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLIndexSchema:table:get"><apiName>table</apiName><shortdesc>
     Der Name der Tabelle, mit der dieser Index verbunden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Der Name der Tabelle, mit der dieser Index verbunden ist.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
 Die in einer „SQLTableSchema“-Instanz enthaltenen Informationen beschreiben eine bestimmte Tabelle in einer Datenbank.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die in einer „SQLTableSchema“-Instanz enthaltenen Informationen beschreiben eine bestimmte Tabelle in einer Datenbank. Zu den verfügbaren Informationen gehören der Name der Tabelle (die <codeph>name</codeph>-Eigenschaft), die SQL-Anweisung, mit der die Tabelle erstellt wurde (die <codeph>sql</codeph>-Eigenschaft) und Informationen zu den Tabellenspalten (die <codeph>columns</codeph>-Eigenschaft).
 
 <p>Um die Tabellenschemainformationen für eine Datenbank zu erhalten, laden Sie die Schemainformationen mithilfe der Methode <codeph>SQLConnection.loadSchema()</codeph>. Achten Sie dabei darauf, dass <codeph>null</codeph> oder <codeph>SQLTableSchema</codeph> als Wert für das Argument <codeph>type</codeph> angegeben ist. Die Eigenschaft <codeph>tables</codeph> der resultierenden „SQLSchemaResult“-Instanz enthält ein Array mit „SQLTableSchema“-Instanzen, die die Tabellen·in der Datenbank repräsentieren.</p>
 
 <p>Im Allgemeinen werden „SQLTableSchema“-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLTableSchema:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
     Erstellt eine „SQLTableSchema“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der zugeordneten Datenbank. 
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Tabelle.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die SQL-Anweisung, mit der die Tabelle erstellt wurde.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Array mit „SQLColumnSchema“-Instanzen, die die Tabellenspalten beschreiben.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLTableSchema“-Instanz. Im Allgemeinen wird der „SQLTableSchema“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Schemainformationen für eine Datenbank erhalten Sie durch einen Aufruf der Methode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/tables"><linktext>flash.data.SQLSchemaResult.tables</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLTableSchema:columns:get"><apiName>columns</apiName><shortdesc>
     Ein Array mit „SQLColumnSchema“-Instanzen, die Schemainformationen zu den Tabellenspalten enthalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array mit „SQLColumnSchema“-Instanzen, die Schemainformationen zu den Tabellenspalten enthalten. Wenn der Aufruf von <codeph>SQlConnection.loadSchema()</codeph> angibt, dass Spalteninformationen·aus dem Ergebnis ausgeschlossen werden sollen, handelt es sich bei der <codeph>columns</codeph>-Eigenschaft um ein leeres Array (ein Array, dessen <codeph>length</codeph>-Eigenschaft den Wert „0“ hat).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLResult"><apiName>SQLResult</apiName><shortdesc>
 Die „SQLResult“-Klasse bietet Zugriff auf Daten, die auf die Ausführung einer SQL-Anweisung (eine „SQLStatement“-Instanz) hin zurückgegeben wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die „SQLResult“-Klasse bietet Zugriff auf Daten, die auf die Ausführung einer SQL-Anweisung (eine „SQLStatement“-Instanz) hin zurückgegeben wurden.
 
 <p>Der Zugriff auf die SQLResult-Instanz einer SQL-Anweisung erfolgt durch den Aufruf der <codeph>SQLStatement.getResult()</codeph>-Methode, oder sie wird als Argument an die Ergebnisprozedur einer Responder-Instanz übergeben, die in einem Aufruf von <codeph>SQLStatement.execute()</codeph> oder <codeph>SQLStatement.next()</codeph> angegeben wird. Im Allgemeinen werden „SQLResult“-Instanzen nicht direkt aufgrund von Entwicklercode erstellt.</p>
 
 <p>Mit einem SQLResult-Objekt können Sie: auf die von einer <codeph>SELECT</codeph>-Anweisung zurückgegebenen Datenzeilen zugreifen (mithilfe der <codeph>data</codeph>-Eigenschaft), die Zeilenbezeichnerinformationen einer <codeph>INSERT</codeph>-Anweisung abrufen (mithilfe der <codeph>lastInsertRowID</codeph>-Eigenschaft), die Anzahl der von einer <codeph>INSERT</codeph>-, <codeph>UPDATE</codeph>- oder <codeph>DELETE</codeph>-Anweisung betroffenen Zeilen bestimmen (mithilfe der <codeph>rowsAffected</codeph>-Eigenschaft) oder bestimmen, ob es weitere <codeph>SELECT</codeph>-Ergebniszeilen gibt, die nicht abgerufen wurden (mithilfe der <codeph>complete</codeph>-Eigenschaft).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement/getResult()"><linktext>flash.data.SQLStatement.getResult()</linktext></link><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links><apiConstructor id="flash.data:SQLResult:SQLResult"><apiName>SQLResult</apiName><shortdesc>
     Erstellt eine „SQLResult“-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Zeilen-Array, das nach der Anweisungsausführung zurückgegeben wurde. Wenn die Anweisung keine Zeilen zurückgibt, muss dieser Wert „null“ lauten.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowsAffected</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Gibt an, auf wie viele Zeilen sich die ausgeführte Anweisung ausgewirkt hat.
     
     </apiDesc></apiParam><apiParam><apiItemName>complete</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Gibt an, ob weitere Zeilen aufgerufen werden können oder ob alle Daten zurückgegeben wurden.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowID</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Handelte es sich bei der Anweisung um einen SQL <codeph>INSERT</codeph>-Vorgang, ist dies der neue eindeutige Bezeichner der Zeile.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine „SQLResult“-Instanz. Im Allgemeinen wird der „SQLResult“-Konstruktor nicht direkt durch den Entwicklercode aufgerufen. Um eine SQLResult-Instanz abzurufen, die mit einer bestimmten SQLStatement-Instanz verknüpft ist, müssen Sie die <codeph>getResult()</codeph>-Methode dieser Instanz aufrufen. Außerdem wird eine SQLResult-Instanz als Argument an die Ergebnisprozedurfunktion übergeben, wenn eine Responder-Instanz in einem Aufruf der <codeph>execute()</codeph>- oder <codeph>next()</codeph>-Methode angegeben wird.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLResult:complete:get"><apiName>complete</apiName><shortdesc>
     Gibt an, ob alle aus einer Anweisungsausführung resultierenden Daten zurückgegeben wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob alle aus einer Anweisungsausführung resultierenden Daten zurückgegeben wurden.
     
     <p>Wenn die Anweisung eine oder mehrere Zeilen zurückgibt, gibt diese Eigenschaft an, ob alle Zeilen zurückgegeben wurden. Wird die Methode <codeph>execute()</codeph> eines „SQLStatement“-Objekts mit einem <codeph>prefetch</codeph>-Argumentwert aufgerufen, wird nur die angegebene Anzahl Zeilen der resultierenden Daten in der Eigenschaft <codeph>data</codeph> des „SQLResult“-Objekts zurückgegeben. Durch spätere Aufrufe von <codeph>SQLStatement.next()</codeph> werden weitere Daten zur Verfügung gestellt. Mit dieser Eigenschaft wird die Rückgabe der letzten Ergebnisse bestimmt.</p>
     
     <p>Da die Anzahl der Zeilen bei der Ausführung nicht bekannt ist, gilt die Anweisungsausführung erst als abgeschlossen, wenn sich der Datenbankcursor jenseits der letzten Zeile befindet. Wenn die Methode <codeph>SQLStatement.execute()</codeph> mit einem <codeph>prefetch</codeph>-Argument aufgerufen wird, muss die Abfrage mindestens eine Zeile mehr enthalten als die Gesamtzahl der Zeilen im Ergebnis, damit die Eigenschaft <codeph>complete</codeph> der resultierenden „SQLResult“-Instanz den Wert <codeph>true</codeph> aufweist.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:data:get"><apiName>data</apiName><shortdesc>
     Die als Ergebnis der Anweisungsausführung zurückgegebenen Daten, insbesondere wenn eine SQL „SELECT“-Anweisung ausgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Die als Ergebnis der Anweisungsausführung zurückgegebenen Daten, insbesondere wenn eine SQL <codeph>SELECT</codeph>-Anweisung ausgeführt wird.
     
     <p>Wenn eine Anweisung eine oder mehrere Zeilen zurückgibt, ist diese Eigenschaft ein Array mit Objekten, die die Zeilen der Ergebnisdaten repräsentiert. Jedes Objekt in diesem Array verfügt über Eigenschaftennamen, die den Spaltennamen aus den Ergebnisdaten entsprechen.</p>
	 
	 <p>Angenommen, Sie führen die SQL-<codeph>SELECT</codeph>-Anweisung aus:</p>
	 
	 <codeblock>
	 SELECT lastName, firstName
	 FROM employees
	 </codeblock>
	 
	 <p>Wenn die <codeph>employees</codeph>-Tabelle 10 Zeilen enthält, ist die <codeph>SQLResult.data</codeph>-Eigenschaft ein Array mit 10 Elementen. Jedes Element ist ein Objekt mit zwei Eigenschaften, <codeph>lastName</codeph> und <codeph>firstName</codeph>.</p>
	 
	 <p>Die Situation ist komplexer, wenn Sie eine <codeph>SELECT</codeph>-Anweisung mit einer komplexen Ergebnisspalte, zum Beispiel einer Aggregatfunktion, verwenden. Angenommen, Sie führen die folgende SQL aus:</p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary)
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>In den Ergebnissen dieser Anweisung hat jedes Objekt im <codeph>data</codeph>-Array zwei Eigenschaften, nämlich <codeph>departmentId</codeph> und <codeph>SUM(salary)</codeph>. „SUM(salary)“ ist jedoch kein gültiger Bezeichner. Wenn Sie eine berechnete Spalten verwenden, zum Beispiel ein Aggregat oder eine andere Funktion, geben Sie in Ihrer SQL-Anweisung einen Aliasnamen für die berechnete Spalte an. Der Aliasname wird als Eigenschaftenname in den Ergebnisdatenobjekten verwendet. Betrachten Sie zum Beispiel die folgende Alternative zur vorherigen Anweisung:</p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary) AS salarySubtotal
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>Im <codeph>data</codeph>-Array dieser Anweisung haben die Ergebnisobjekte zwei Eigenschaften mit den Namen <codeph>departmentId</codeph> und <codeph>salarySubtotal</codeph>.</p>
	 
	 <p>Die <codeph>data</codeph>-Eigenschaft ist immer ein Array, unabhängig davon, wie viele Reihen und Spalten im Ergebnissatz enthalten sind. Die folgende <codeph>SELECT</codeph>-Anweisung resultiert in einer Zeile und einer Spalte, was einem einzelnen Wert entspricht:</p>
	 
	 <codeblock>
	 SELECT COUNT(~~) AS numEmployees
	 FROM employees
	 </codeblock>
	 
	 <p>Nach dem Ausführen der Abfrage enthält die <codeph>data</codeph>-Eigenschaft ein Array-Objekt mit einem Element. Dieses Element ist ein Objekt mit einer einzelnen Eigenschaft, <codeph>numEmployees</codeph>.</p>
	 
	 <p>Falls es in den Ergebnisdaten doppelte Spaltennamen gibt, zum Beispiel, wenn die <codeph>SELECT</codeph>-Anweisung zwei verschiedene <codeph>id</codeph>-Spalten aus zwei verschiedenen Tabellen enthält, erhalten die doppelten Namen Eigenschaftennamen entsprechend dem Wert der <codeph>SQLConnection.columnNameStyle</codeph>-Eigenschaft. Standardmäßig werden die Namen der einzelnen Spalten als Eigenschaftennamen verwendet, wenn es jedoch mehrere Spalten mit demselben Namen im Ergebnissatz gibt, wird für die identisch benannten Spalten die lange Namensform <codeph>[table-name]_[column-name]</codeph> verwendet. Dieses Verhalten kann durch das Festlegen der <codeph>SQLConnection.columnNameStyle</codeph>-Eigenschaft geändert werden.</p>
	 
	 <p>Standardmäßig handelt es sich bei den Objekten im <codeph>data</codeph>-Array um Object-Instanzen. Wenn der Wert der <codeph>SQLStatement.itemClass</codeph>-Eigenschaft jedoch auf eine Klasse gesetzt wird, werden die Elemente des <codeph>data</codeph>-Arrays stattdessen als Instanzen dieser Klasse erstellt. Für jede Spalte im Ergebnisdatensatz muss die <codeph>itemClass</codeph>-Klasse eine Eigenschaft aufweisen, deren Name genau dem Spaltennamen entspricht.</p> 
	 
	 <p>Wenn eine Anweisung keine Daten zurückgibt, hat diese Eigenschaft den Wert <codeph>null</codeph>. Dies ist der Fall, wenn die Anweisung keine <codeph>SELECT</codeph>-Anweisung ist oder wenn sie eine <codeph>SELECT</codeph>-Anweisung ist, die 0 Zeilen zurückgibt.</p>
     
	 </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> Das folgende Beispiel demonstriert, wie mithilfe der Eigenschaft <codeph>itemClass</codeph> zur Laufzeit Instanzen einer benutzerdefinierten Klasse aus den Ergebnissen einer SQL <codeph>SELECT</codeph>-Anweisung erstellt werden.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>SQLConnection.columnNameStyle</linktext></link><link href="flash.data.xml#SQLStatement/itemClass"><linktext>SQLStatement.itemClass</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     Der letzte von einer SQL „INSERT“-Anweisung erzeugte Zeilenbezeichner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Der letzte von einer SQL <codeph>INSERT</codeph>-Anweisung erzeugte Zeilenbezeichner.
	 
     <p>Handelt es sich bei der ausgeführten Anweisung nicht um eine <codeph>INSERT</codeph>-Anweisung, lautet der Wert „0“.</p>
	 
	 <p>Ein Zeilenbezeichner dient zur eindeutigen Kennzeichnung einer Zeile in einer Tabelle in der Datenbank. Der Wert wird häufig von der Datenbank generiert.</p>
	 
	 <p>Weitere Informationen zu Primärschlüsseln und generierten Zeilenbezeichnern finden Sie in den Abschnitten „<xref href="../../localDatabaseSQLSupport.html#createTable">CREATE TABLE</xref>“ und „<xref href="../../localDatabaseSQLSupport.html#expressions">Ausdrücke</xref>“ im Anhang „<xref href="../../localDatabaseSQLSupport.html">SQL-Unterstützung in lokalen Datenbanken</xref>“.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/lastInsertRowID"><linktext>flash.data.SQLConnection.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:rowsAffected:get"><apiName>rowsAffected</apiName><shortdesc>
     Gibt an, wieviele Zeilen von dem Vorgang betroffen wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, wieviele Zeilen von dem Vorgang betroffen wurden. Es werden nur Änderungen gezählt, die direkt von einer <codeph>INSERT</codeph>-, <codeph>UPDATE</codeph>- oder <codeph>DELETE</codeph>-Anweisung angegeben werden.
     
     <p>Zusätzliche Änderungen, die von Auslösern verursacht werden, werden nicht gezählt. Mithilfe der Eigenschaft <codeph>SQLConnection.totalChanges</codeph> können Sie die Gesamtzahl aller Änderungen, einschließlich derjenigen, die von Auslösern verursacht wurden, in Erfahrung bringen.</p>
	 
	 <p>Wenn es sich bei der entsprechenden SQL-Methode um eine <codeph>DELETE</codeph>-Anweisung ohne <codeph>WHERE</codeph>-Klausel handelt (d. h. alle in der Tabelle enthaltenen Zeilen werden durch die Anweisung gelöscht), hat die <codeph>rowsAffected</codeph>-Eigenschaft immer den Wert „0“. Dabei ist es gleichgültig, wie viele Zeilen gelöscht wurden. Wenn Sie wissen müssen, wie viele Zeilen gelöscht wurden, können Sie die <codeph>WHERE</codeph>-Klausel <codeph>WHERE 1 = 1</codeph> einschließen. In diesem Fall werden alle Zeilen gelöscht, und die <codeph>rowsAffected</codeph>-Eigenschaft gibt die genaue Anzahl der gelöschten Zeilen wieder. Werden viele Zeilen gelöscht, kann sich dies jedoch nachteilig auf die Leistung der Anweisung auswirken.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/totalChanges"><linktext>flash.data.SQLConnection.totalChanges</linktext></link></related-links></apiValue></apiClassifier></apiPackage>