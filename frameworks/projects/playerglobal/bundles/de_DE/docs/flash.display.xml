<?xml version="1.0"?>
<apiPackage id="flash.display"><apiName>flash.display</apiName><apiDetail/><apiClassifier id="flash.display:FrameLabel"><apiName>FrameLabel</apiName><shortdesc>
	
	Das FrameLabel-Objekt umfasst Eigenschaften, die eine Bildnummer und die entsprechende Bildbezeichnung festlegen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	
	Das FrameLabel-Objekt umfasst Eigenschaften, die eine Bildnummer und die entsprechende Bildbezeichnung festlegen. Die Scene-Klasse umfasst die <codeph>labels</codeph>-Eigenschaft, bei der es sich um ein Array an FrameLabel-Objekten für die Szene handelt. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Scene/labels"><linktext>Scene.labels</linktext></link><link href="flash.display.xml#MovieClip/currentLabel"><linktext>MovieClip.currentLabel</linktext></link><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:FrameLabel:frame:get"><apiName>frame</apiName><shortdesc>
		Die Nummer des Bilds mit dieser Bezeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		Die Nummer des Bilds mit dieser Bezeichnung.
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FrameLabel:name:get"><apiName>name</apiName><shortdesc>
		Die Bildbezeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Die Bildbezeichnung.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
 Die InteractiveObject-Klasse ist die abstrakte Basisklasse für alle Anzeigeobjekte, mit denen Benutzer per Maus und Tastatur interagieren können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die InteractiveObject-Klasse ist die abstrakte Basisklasse für alle Anzeigeobjekte, mit denen Benutzer per Maus und Tastatur interagieren können.
 
 <p>Die InteractiveObject-Klasse lässt sich nicht direkt instanziieren. Beim Aufrufen des Konstruktors <codeph>new InteractiveObject()</codeph> wird eine <codeph>ArgumentError</codeph>-Ausnahme ausgelöst.</p>
 
 <p>Die InteractiveObject-Klasse selbst enthält keine APIs zum Rendern von Inhalten auf dem Bildschirm. Wenn Sie eine benutzerdefinierte Unterklasse der InteractiveObject-Klasse erstellen möchten, sollten Sie daher eine ihrer Unterklassen erweitern, die über APIs zum Rendern von Inhalt auf dem Bildschirm verfügt (wie die Klassen Sprite, SimpleButton, TextField oder MovieClip).</p>
 
 </apiDesc><example conref="examples\InteractiveObjectExample.as"> Im folgenden Beispiel wird mit der Klasse <codeph>InteractiveObjectExample</codeph>, die ihrerseits die Klasse <codeph>ChildSprite</codeph> verwendet, ein Rechteck gezeichnet und dann basierend auf verschiedenen Mausereignissen bearbeitet. Dies wird in den folgenden Schritten erreicht:
 <ol>
    <li>Im Konstruktor <codeph>InteractiveObjectExample</codeph> wird ein neues ChildSprite-Objekt vom Typ „Sprite“ mit dem Namen <codeph>child</codeph> erstellt. Dieses Objekt ruft die ChildSprite-Konstruktormethode auf, um die Form zu zeichnen und für die Form Mausereignisse hinzuzufügen (dies ist in den folgenden Schritten erläutert). Das <codeph>child</codeph>-Objekt wird an der ersten Stelle der Anzeigeliste eingefügt, indem die Koordinaten <i>x = 0, y = 0</i> verwendet werden.  </li>
 
    <li>Deklarieren Sie in der Klasse <codeph>ChildSprite</codeph> die Eigenschaften <codeph>size</codeph> und <codeph>overSize</codeph>, die später in der <codeph>draw()</codeph>-Methode und den MouseEvent-Methoden verwendet werden.</li>
 
     <li>Deklarieren Sie Eigenschaften, die die Hintergrundfarbe auf Orange, die Mouseover-Farbe auf Dunkelgelb und die Mousedown-Farbe auf Hellblau setzen.</li>
 
    <li>Im Konstruktor <codeph>ChildSprite</codeph> zeichnen Sie ein orangefarbenes Quadrat, indem Sie Methoden der Graphics-Klasse und der <codeph>draw()</codeph>-Methode verwenden.</li>
 
    <li>Der Konstruktor fügt vier MouseEvent-Ereignis-Listener-Methoden hinzu:
 
     <ul>
        <li><codeph>mouseOverHandler</codeph>: Zeichnet ein größeres Pixelquadrat mit den Maßen 60 x 60 in Dunkelgelb an den ursprünglichen Koordinaten.</li>
        <li><codeph>mouseOutHandler</codeph>: Setzt das Quadrat wieder auf die ursprüngliche Größe und Farbe zurück.</li>
        <li><codeph>mouseDownHandler</codeph>: Zeichnet ein größeres Pixelquadrat mit den Maßen 60 x 60 in Hellblau an den ursprünglichen Koordinaten.</li>
        <li><codeph>mouseUpHandler</codeph>: Identisch mit <codeph>mouseOverHandler</codeph>.</li>
     </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class InteractiveObjectExample extends Sprite {

        public function InteractiveObjectExample() {
            var child:Sprite = new ChildSprite();
            addChild(child);
        }
    }
}

import flash.display.Sprite;
import flash.events.MouseEvent;

class ChildSprite extends Sprite {
    private var size:uint = 50;
    private var overSize:uint = 60;
    private var backgroundColor:uint = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;

    public function ChildSprite() {
        buttonMode = true;
        draw(size, size, backgroundColor);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
        addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
    }

    private function draw(w:uint, h:uint, bgColor:uint):void {
        graphics.clear();
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }

    public function mouseOverHandler(event:MouseEvent):void {
        trace("mouseOverHandler");
        draw(overSize, overSize, overColor);
    }

    public function mouseOutHandler(event:MouseEvent):void {
        trace("mouseOutHandler");
        draw(size, size, backgroundColor);
    }

    public function mouseDownHandler(event:MouseEvent):void {
        trace("mouseDownHandler");
        draw(overSize, overSize, downColor);
    }

    public function mouseUpHandler(event:MouseEvent):void {
        trace("mouseUpHandler");
        draw(overSize, overSize, overColor);
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.display:InteractiveObject_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 Wird ausgelöst, wenn ein Benutzer ein oder mehrere Textzeichen eingibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Benutzer ein oder mehrere Textzeichen eingibt. Dieses Ereignis kann durch verschiedene Texteingabemethoden ausgelöst werden, z. B. Standardtastaturen, Eingabemethodeneditoren (Input Method Editors, IMEs), Spracherkennungssysteme oder das Einfügen von Text ohne Formatierungs- oder Stilinformationen.
 </apiDesc><example conref="examples\TextField_textInput.as"/></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CONTEXT_MENU_contextMenu"><apiName>contextMenu</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer das Kontextmenü, das mit diesem interaktiven Objekt verknüpft ist, in einer AIR-Anwendung einblendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CONTEXT_MENU</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer das Kontextmenü, das mit diesem interaktiven Objekt verknüpft ist, in einer AIR-Anwendung einblendet.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>contextMenu</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE_nativeDragComplete"><apiName>nativeDragComplete</apiName><shortdesc>
 Wird vom InteractiveObject-Ziehinitiator ausgelöst, wenn der Benutzer die Ziehbewegung beendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird vom InteractiveObject-Ziehinitiator ausgelöst, wenn der Benutzer die Ziehbewegung beendet.
 
 <p>Die dropAction-Eigenschaft des Ereignisses gibt die Aktion an, die vom Zielobjekt des Ziehvorgangs festgelegt ist. Der Wert „none“ (<codeph>DragActions.NONE</codeph>) bedeutet, dass der Ablegevorgang abgebrochen oder nicht akzeptiert wurde.</p>
 
 <p>Die <codeph>nativeDragComplete</codeph>-Ereignisprozedur eignet sich, um den Status des einleitenden Anzeigeobjekts zu aktualisieren, beispielsweise durch Entfernen eines Elements aus einer Liste (für die move-Ziehaktion) oder durch Ändern der visuellen Eigenschaften.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE_nativeDragUpdate"><apiName>nativeDragUpdate</apiName><shortdesc>
 Wird während eines Ziehvorgangs von der InteractiveObject-Instanz ausgelöst, die als Ziehinitiator im DragManager.doDrag()-Aufruf festgelegt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird während eines Ziehvorgangs von der InteractiveObject-Instanz ausgelöst, die als Ziehinitiator im DragManager.doDrag()-Aufruf festgelegt ist.
 
 <p>Unter Linux werden keine <codeph>nativeDragUpdate</codeph>-Ereignisse ausgelöst.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_START_nativeDragStart"><apiName>nativeDragStart</apiName><shortdesc>
 Wird am Anfang eines Ziehvorgangs von der InteractiveObject-Instanz ausgelöst, die als Ziehinitiator im DragManager.doDrag()-Aufruf festgelegt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_START</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird am Anfang eines Ziehvorgangs von der InteractiveObject-Instanz ausgelöst, die als Ziehinitiator im DragManager.doDrag()-Aufruf festgelegt ist.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_EXIT_nativeDragExit"><apiName>nativeDragExit</apiName><shortdesc>
 Wird von einer InteractiveObject-Instanz ausgelöst, wenn eine Ziehbewegung ihre Begrenzungen verlässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_EXIT</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von einer InteractiveObject-Instanz ausgelöst, wenn eine Ziehbewegung ihre Begrenzungen verlässt.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_DROP_nativeDragDrop"><apiName>nativeDragDrop</apiName><shortdesc>
 Wird vom InteractiveObject-Zielobjekt ausgelöst, wenn ein gezogenes Objekt darauf abgelegt wird und das Ablegen mit einem Aufruf von „DragManager.acceptDragDrop()“ akzeptiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_DROP</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird vom InteractiveObject-Zielobjekt ausgelöst, wenn ein gezogenes Objekt darauf abgelegt wird und das Ablegen mit einem Aufruf von „DragManager.acceptDragDrop()“ akzeptiert wurde.
 
 <p>Auf die abgelegten Daten kann mit der <codeph>clipboard</codeph>-Eigenschaft des Ereignisobjekts zugegriffen werden.</p>
 
 <p>Die Prozedur für dieses Ereignis sollte die <codeph>DragManager.dropAction</codeph>-Eigenschaft festlegen, um dem Initiatorobjekt mitzuteilen, welche Ziehaktion ausgeführt wurde. Wenn kein Wert festgelegt wird, wählt DragManager einen Standardwert in der Liste der zulässigen Aktionen aus.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_OVER_nativeDragOver"><apiName>nativeDragOver</apiName><shortdesc>
 Wird von einer InteractiveObject-Instanz kontinuierlich ausgelöst, während eine Ziehbewegung innerhalb ihrer Begrenzungen verbleibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_OVER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von einer InteractiveObject-Instanz kontinuierlich ausgelöst, während eine Ziehbewegung innerhalb ihrer Begrenzungen verbleibt.
 
 <p><codeph>nativeDragOver</codeph>-Ereignisse werden ausgelöst, wann immer die Maus bewegt wird. Unter Windows und Mac werden sie auch bei kurzen Timerintervallen ausgelöst, selbst, wenn sich die Maus nicht bewegt hat.</p>
 
 <p>Entweder das <codeph>nativeDragOver</codeph>-Ereignis oder das <codeph>nativeDragEnter</codeph>-Ereignis sollte so eingestellt werden, dass das Anzeigeobjekt zum Ablageziel werden kann.</p> 
 
 <p>Um zu bestimmen, ob das auslösende Anzeigeobjekt den Ablegevorgang akzeptieren kann, überprüfen Sie die Eignung der Daten in der <codeph>clipboard</codeph>-Eigenschaft des Ereignisobjekts und die zulässigen Ziehaktionen in der <codeph>allowedActions</codeph>-Eigenschaft.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_ENTER_nativeDragEnter"><apiName>nativeDragEnter</apiName><shortdesc>
 Wird von einer InteractiveObject-Instanz ausgelöst, wenn eine Ziehbewegung in ihre Begrenzungen eintritt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_ENTER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von einer InteractiveObject-Instanz ausgelöst, wenn eine Ziehbewegung in ihre Begrenzungen eintritt.
 
 <p>Entweder das <codeph>nativeDragEnter</codeph>-Ereignis oder das <codeph>nativeDragOver</codeph>-Ereignis sollte so eingestellt werden, dass das Anzeigeobjekt zum Ablageziel werden kann.</p>
 
 <p>Um zu bestimmen, ob das auslösende Anzeigeobjekt den Ablegevorgang akzeptieren kann, überprüfen Sie die Eignung der Daten in der <codeph>clipboard</codeph>-Eigenschaft des Ereignisobjekts und die zulässigen Ziehaktionen in der <codeph>allowedActions</codeph>-Eigenschaft.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_INDEX_CHANGE_tabIndexChange"><apiName>tabIndexChange</apiName><shortdesc>
 Wird ausgelöst, wenn sich der Wert der tabIndex-Eigenschaft des Objekts ändert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_INDEX_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn sich der Wert der <codeph>tabIndex</codeph>-Eigenschaft des Objekts ändert. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_ENABLED_CHANGE_tabEnabledChange"><apiName>tabEnabledChange</apiName><shortdesc>
 Wird ausgelöst, wenn sich das tabEnabled-Flag des Objekts ändert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_ENABLED_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn sich das <codeph>tabEnabled</codeph>-Kennzeichen des Objekts ändert. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_CHILDREN_CHANGE_tabChildrenChange"><apiName>tabChildrenChange</apiName><shortdesc>
 Wird ausgelöst, wenn sich der Wert des tabChildren-Flags des Objekts ändert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_CHILDREN_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn sich der Wert des <codeph>tabChildren</codeph>-Kennzeichens des Objekts ändert. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_UP_keyUp"><apiName>keyUp</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer eine Taste loslässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_UP</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer eine Taste loslässt. Zuordnungen zwischen Tasten und spezifischen Zeichen variieren zwischen verschiedenen Geräten und Betriebssystemen. Dieser Ereignistyp wird erzeugt, nachdem eine Zuordnung dieser Art stattgefunden hat, aber vor der Verarbeitung eines IME (Input Method Editor, Eingabemethodeneditor). IMEs werden zur Eingabe von Zeichen verwendet, die auf der Standard-QWERTY-Tastatur nicht belegt sind, wie etwa chinesische Ideogramme. Dieses Ereignis tritt nach einem <codeph>keyDown</codeph>-Ereignis auf und besitzt die folgenden Merkmale:
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_DOWN_keyDown"><apiName>keyDown</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer eine Taste drückt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_DOWN</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer eine Taste drückt. Zuordnungen zwischen Tasten und spezifischen Zeichen variieren zwischen verschiedenen Geräten und Betriebssystemen. Dieser Ereignistyp wird erzeugt, nachdem eine Zuordnung dieser Art stattgefunden hat, aber vor der Verarbeitung eines IME (Input Method Editor, Eingabemethodeneditor). IMEs werden zur Eingabe von Zeichen verwendet, die auf der Standard-QWERTY-Tastatur nicht belegt sind, wie etwa chinesische Ideogramme. Dieses Ereignis tritt vor dem <codeph>keyUp</codeph>-Ereignis ein.
 
 <p>Wenn Sie in AIR dieses Ereignis abbrechen, wird verhindert, dass das Zeichen in ein Textfeld eingegeben wird.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz loslässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz loslässt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz drückt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz drückt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die rechte Taste des Zeigegeräts über derselben InteractiveObject-Instanz drückt und loslässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die rechte Taste des Zeigegeräts über derselben InteractiveObject-Instanz drückt und loslässt. Damit ein <codeph>rightClick</codeph>-Ereignis auftritt, müssen zunächst immer die beiden folgenden Ereignisse in der angegebenen Reihenfolge auftreten: <codeph>rightMouseDown</codeph>, dann <codeph>rightMouseUp</codeph>. Das Zielobjekt muss für beide Ereignisse identisch sein; andernfalls tritt kein <codeph>rightClick</codeph>-Ereignis auf. Zwischen den Ereignissen <codeph>rightMouseDown</codeph> und <codeph>rightMouseUp</codeph> können noch verschiedene andere Mausereignisse auftreten, wobei das <codeph>rightClick</codeph>-Ereignis trotzdem auftritt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_UP_middleMouseUp"><apiName>middleMouseUp</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz loslässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz loslässt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_DOWN_middleMouseDown"><apiName>middleMouseDown</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die mittlere Taste des Zeigegeräts über einer InteractiveObject-Instanz drückt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die mittlere Taste des Zeigegeräts über einer InteractiveObject-Instanz drückt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_CLICK_middleClick"><apiName>middleClick</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die mittlere Taste des Zeigegeräts über derselben InteractiveObject-Instanz drückt und loslässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die mittlere Taste des Zeigegeräts über derselben InteractiveObject-Instanz drückt und loslässt. Damit ein <codeph>middleClick</codeph>-Ereignis auftritt, müssen zunächst immer die beiden folgenden Ereignisse in der angegebenen Reihenfolge auftreten: <codeph>middleMouseDown</codeph>, dann <codeph>middleMouseUp</codeph>. Das Zielobjekt muss für beide Ereignisse identisch sein; andernfalls tritt kein <codeph>middleClick</codeph>-Ereignis auf. Zwischen den Ereignissen <codeph>middleMouseDown</codeph> und <codeph>middleMouseUp</codeph> können noch verschiedene andere Mausereignisse auftreten, wobei das <codeph>middleClick</codeph>-Ereignis trotzdem auftritt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OVER_rollOver"><apiName>rollOver</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät auf eine InteractiveObject-Instanz bewegt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät auf eine InteractiveObject-Instanz bewegt. Das Ereignisziel ist das Objekt unter dem Zeigegerät oder ein Objekt, das diesem übergeordnet ist. <codeph>relatedObject</codeph> ist das Objekt, das sich davor unter dem Zeigegerät befunden hat. Die <codeph>rollOver</codeph>-Ereignisse werden über die übergeordnete Kette des Objekts fortlaufend nach unten hin ausgelöst, beginnend mit dem höchsten übergeordneten Objekt, das weder das Stammobjekt noch ein übergeordnetes Element des <codeph>relatedObject</codeph>-Objekts ist.
 <p>Der Zweck des <codeph>rollOver</codeph>-Ereignisses besteht darin, die Programmierung von Rollout-Verhaltensweisen für Anzeigeobjekt-Container mit untergeordneten Objekten zu vereinfachen. Kommt die Maus aus einem Objekt, das diesem Anzeigeobjekt nicht untergeordnet ist, in den Bereich eines Anzeigeobjekts oder in den Bereich, in dem sich die diesem untergeordneten Objekte befinden, löst das Anzeigeobjekt das <codeph>rollOver</codeph>-Ereignis aus. Dieses Verhalten unterscheidet sich vom <codeph>mouseOver</codeph>-Ereignis, das immer dann ausgelöst wird, wenn die Maus auf den Bereich eines dem Anzeigeobjekt-Container untergeordneten Objekts bewegt wird. Dies ist auch der Fall, wenn sich die Maus bereits über einem anderen dem Anzeigeobjekt-Container untergeordneten Objekt befunden hat. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OUT_rollOut"><apiName>rollOut</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät von einer InteractiveObject-Instanz wegbewegt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät von einer InteractiveObject-Instanz wegbewegt. Das Ereignisziel ist das Objekt, das sich davor unter dem Zeigegerät befunden hat, oder ein Objekt, das diesem übergeordnet ist. <codeph>relatedObject</codeph> ist das Objekt, zu dem sich das Zeigegerät bewegt hat. Die <codeph>rollOut</codeph>-Ereignisse werden über die übergeordnete Kette des Objekts fortlaufend nach oben hin ausgelöst, beginnend mit dem Objekt selbst und endend mit dem höchsten übergeordneten Objekt, das weder das Stammobjekt noch ein übergeordnetes Element des <codeph>relatedObject</codeph>-Objekts ist. 
 <p>Der Zweck des <codeph>rollOut</codeph>-Ereignisses besteht darin, die Programmierung von Rollover-Verhaltensweisen für Anzeigeobjekt-Container mit untergeordneten Objekten zu vereinfachen. Verlässt die Maus den Bereich eines Anzeigeobjekts oder den Bereich, in dem sich die diesem untergeordneten Objekte befinden, um auf ein Objekt zu zeigen, das diesem Objekt nicht untergeordnet ist, löst das Anzeigeobjekt das <codeph>rollOut</codeph>-Ereignis aus. Dieses Verhalten unterscheidet sich von dem des <codeph>mouseOut</codeph>-Ereignisses, das jeweils dann ausgelöst wird, wenn die Maus den Bereich eines dem Anzeigeobjekt-Container untergeordneten Objekts verlässt, selbst wenn die Maus über einem anderen dem Anzeigeobjekt-Container untergeordneten Objekt bleibt.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_WHEEL_mouseWheel"><apiName>mouseWheel</apiName><shortdesc>
 Wird ausgelöst, wenn das Mausrad über einer InteractiveObject-Instanz gedreht wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_WHEEL</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn das Mausrad über einer InteractiveObject-Instanz gedreht wird. Handelt es sich beim Ziel um ein Textfeld, wird als Standardverhalten der Text innerhalb des Textfelds nach oben oder unten verschoben. Nur unter Microsoft Windows verfügbar.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz loslässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz loslässt. Handelt es sich beim Ziel um eine SimpleButton-Instanz, zeigt das Objekt das <codeph>upState</codeph>-Anzeigeobjekt an. Handelt es sich beim Ziel um ein auswählbares Textfeld, wird als Standardverhalten die Textauswahl abgeschlossen.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OVER_mouseOver"><apiName>mouseOver</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät auf eine InteractiveObject-Instanz bewegt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät auf eine InteractiveObject-Instanz bewegt. <codeph>relatedObject</codeph> ist das Objekt, das sich davor unter dem Zeigegerät befunden hat. Handelt es sich beim Ziel um eine SimpleButton-Instanz, zeigt das Objekt als Standardverhalten das <codeph>overState</codeph>- oder das <codeph>upState</codeph>-Anzeigeobjekt an. Dies hängt davon ab, ob die Maustaste gerade gedrückt ist.
 <p>Das Ereignis <codeph>mouseOver</codeph> wird jedes Mal ausgelöst, wenn die Maus in den Bereich eines dem Anzeigeobjekt-Container untergeordneten Objekts bewegt wird, selbst wenn sich die Maus bereits über einem anderen dem Anzeigeobjekt-Container untergeordneten Objekt befindet. Dieses Verhalten unterscheidet sich vom Zweck des <codeph>rollOver</codeph>-Ereignisses, der darin besteht, die Programmierung von Rollout-Verhaltensweisen für Anzeigeobjekt-Container mit untergeordneten Objekten zu vereinfachen. Kommt die Maus aus einem Objekt, das diesem Anzeigeobjekt nicht untergeordnet ist, in den Bereich eines Anzeigeobjekts oder in den Bereich, in dem sich die diesem untergeordneten Objekte befinden, löst das Anzeigeobjekt das <codeph>rollOver</codeph>-Ereignis aus. Die <codeph>rollOver</codeph>-Ereignisse werden über die übergeordnete Kette des Objekts fortlaufend nach unten hin ausgelöst, beginnend mit dem höchsten übergeordneten Objekt, das weder das Stammobjekt noch ein übergeordnetes Element des <codeph>relatedObject</codeph>-Objekts ist.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OUT_mouseOut"><apiName>mouseOut</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät von einer InteractiveObject-Instanz wegbewegt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät von einer InteractiveObject-Instanz wegbewegt. Das Ereignisziel ist das Objekt, das sich davor unter dem Zeigegerät befunden hat. <codeph>relatedObject</codeph> ist das Objekt, zu dem sich das Zeigegerät bewegt hat. Handelt es sich bei dem Ziel um eine SimpleButton-Instanz, zeigt die Schaltfläche als Standardverhalten das <codeph>upState</codeph>-Anzeigeobjekt an.
 <p>Das Ereignis <codeph>mouseOut</codeph> wird jedes Mal ausgelöst, wenn die Maus den Bereich eines dem Anzeigeobjekt-Container untergeordneten Objekts verlässt, selbst sich wenn die Maus weiterhin über einem anderen dem Anzeigeobjekt-Container untergeordneten Objekt befindet. Dieses Verhalten unterscheidet sich vom Zweck des <codeph>rollOut</codeph>-Ereignisses, der darin besteht, die Programmierung von Rollover-Verhaltensweisen für Anzeigeobjekt-Container mit untergeordneten Objekten zu vereinfachen. Verlässt die Maus den Bereich eines Anzeigeobjekts oder den Bereich, in dem sich die diesem untergeordneten Objekte befinden, um auf ein Objekt zu zeigen, das diesem Objekt nicht untergeordnet ist, löst das Anzeigeobjekt das <codeph>rollOut</codeph>-Ereignis aus. Die <codeph>rollOut</codeph>-Ereignisse werden über die übergeordnete Kette des Objekts fortlaufend nach oben hin ausgelöst, beginnend mit dem Objekt selbst und endend mit dem höchsten übergeordneten Objekt, das weder das Stammobjekt noch ein übergeordnetes Element des <codeph>relatedObject</codeph>-Objekts ist.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_MOVE_mouseMove"><apiName>mouseMove</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät bewegt, während es sich auf einer InteractiveObject-Instanz befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_MOVE</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer das Zeigegerät bewegt, während es sich auf einer InteractiveObject-Instanz befindet. Handelt es sich beim Ziel um ein Textfeld, in dem der Benutzer eine Auswahl vornimmt, wird als Standardverhalten die Auswahl aktualisiert.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz drückt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die Taste des Zeigegeräts über einer InteractiveObject-Instanz drückt. Handelt es sich bei dem Ziel um eine SimpleButton-Instanz, zeigt die SimpleButton-Instanz als Standardverhalten das <codeph>downState</codeph>-Anzeigeobjekt an. Handelt es sich beim Ziel um ein auswählbares Textfeld, wird als Standardverhalten die Textauswahl begonnen.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.DOUBLE_CLICK_doubleClick"><apiName>doubleClick</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die Haupttaste des Zeigegeräts zweimal schnell hintereinander über dem gleichen InteractiveObject-Objekt drückt und das doubleClickEnabled-Flag des Objekts „true“ lautet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.DOUBLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die Haupttaste des Zeigegeräts zweimal schnell hintereinander über dem gleichen InteractiveObject-Objekt drückt und das <codeph>doubleClickEnabled</codeph>-Kennzeichen des Objekts <codeph>true</codeph> lautet. Damit ein <codeph>doubleClick</codeph>-Ereignis eintreten kann, muss es unmittelbar an die folgende Reihe von Ereignissen anschließen: <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>, <codeph>click</codeph>, <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>. Alle diese Ereignisse müssen dasselbe Ziel wie das <codeph>doubleClick</codeph>-Ereignis aufweisen. Der zweite Klick, der jeweils durch das zweite <codeph>mouseDown</codeph>- und <codeph>mouseUp</codeph>-Ereignis repräsentiert wird, muss innerhalb einer bestimmten Zeitspanne nach dem <codeph>click</codeph>-Ereignis eintreten. Die zulässige Dauer dieser Zeitspanne variiert für verschiedene Betriebssysteme und kann oft vom Benutzer selbst eingestellt werden. Handelt es sich beim Ziel um ein auswählbares Textfeld, wird als Standardverhalten das Wort an der Zeigerposition ausgewählt. Ist für die Ziel-InteractiveObject-Instanz das <codeph>doubleClickEnabled</codeph>-Kennzeichen nicht auf <codeph>true</codeph> gesetzt, empfängt es einfach zwei <codeph>click</codeph>-Ereignisse.  
 
 <p>Die <codeph>doubleClickEnabled</codeph>-Eigenschaft ist standardmäßig auf <codeph>false</codeph> gesetzt.  </p>
 
 <p>Das Doppelklick-Textauswahlverhalten eines TextField-Objekts steht nicht in Bezug zum <codeph>doubleClick</codeph>-Ereignis. Verwenden Sie <codeph>TextField.doubleClickEnabled</codeph>, um die TextField-Auswahl zu steuern.</p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/doubleClickEnabled"><linktext>doubleClickEnabled</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 Wird ausgelöst, wenn ein Benutzer die Haupttaste des Zeigegeräts über derselben InteractiveObject-Instanz drückt und wieder loslässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Benutzer die Haupttaste des Zeigegeräts über derselben InteractiveObject-Instanz drückt und wieder loslässt. Damit ein Klickereignis eintreten kann, muss es immer an die folgende Reihe von Ereignissen anschließen, und zwar in der angegebenen Reihenfolge: mouseDown-Ereignis, dann mouseUp-Ereignis. Das Zielobjekt muss für beide Ereignisse identisch sein, da das <codeph>click</codeph>-Ereignis sonst nicht eintritt. Zwischen den Ereignissen <codeph>mouseDown</codeph> und <codeph>mouseUp</codeph> kann jederzeit eine beliebige Anzahl von Mausereignissen vorkommen. Das <codeph>click</codeph>-Ereignis tritt dennoch ein. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.MOUSE_FOCUS_CHANGE_mouseFocusChange"><apiName>mouseFocusChange</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer versucht, den Fokus mithilfe eines Zeigegeräts zu ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.MOUSE_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer versucht, den Fokus mithilfe eines Zeigegeräts zu ändern. Das Standardverhalten dieses Ereignisses besteht darin, den Fokus zu ändern und das entsprechende <codeph>focusIn</codeph>- und <codeph>focusOut</codeph>-Ereignis auszulösen. 
 
 <p>Dieses Ereignis wird für das Objekt ausgelöst, das gerade den Eingabefokus hat. Das verwandte Objekt für dieses Ereignis ist die InteractiveObject-Instanz, die den Fokus erhält, wenn Sie das Standardverhalten nicht verhindern. Sie können den Fokuswechsel verhindern, indem Sie in einem Ereignis-Listener, der bei dem Zielobjekt ordentlich registriert ist, <codeph>preventDefault()</codeph> aufrufen. Die <codeph>shiftKey</codeph>-Eigenschaft wird nicht verwendet. Der Fokus wird gewechselt und die Ereignisse <codeph>focusIn</codeph> und <codeph>focusOut</codeph> werden standardmäßig ausgelöst.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.KEY_FOCUS_CHANGE_keyFocusChange"><apiName>keyFocusChange</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer versucht, den Fokus mithilfe der Tastatur zu ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.KEY_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer versucht, den Fokus mithilfe der Tastatur zu ändern. Das Standardverhalten dieses Ereignisses besteht darin, den Fokus zu ändern und das entsprechende <codeph>focusIn</codeph>- und <codeph>focusOut</codeph>-Ereignis auszulösen.
 
 <p>Dieses Ereignis wird für das Objekt ausgelöst, das gerade den Eingabefokus hat. Das verwandte Objekt für dieses Ereignis ist die InteractiveObject-Instanz, die den Fokus erhält, wenn Sie das Standardverhalten nicht verhindern. Sie können den Fokuswechsel verhindern, indem Sie in einem Ereignis-Listener, der bei dem Zielobjekt ordentlich registriert ist, die <codeph>preventDefault()</codeph>-Methode aufrufen. Der Fokus wird gewechselt und die Ereignisse <codeph>focusIn</codeph> und <codeph>focusOut</codeph> werden standardmäßig ausgelöst.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_OUT_focusOut"><apiName>focusOut</apiName><shortdesc>
 Wird ausgelöst, nachdem ein Anzeigeobjekt den Fokus verloren hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_OUT</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, <i>nachdem</i> ein Anzeigeobjekt den Fokus abgegeben hat. Dies passiert, wenn Benutzer ein anderes Objekt mit einem Zeigegerät oder per Tastaturnavigation hervorheben. Das Objekt, das den Fokus verliert, ist das Zielobjekt dieses Ereignisses, während die dazugehörige InteractiveObject-Instanz, die den Fokus erhält, „verwandtes Objekt“ genannt wird. Ein Verweis auf das verwandte Objekt wird in der Eigenschaft <codeph>relatedObject</codeph> des Zielobjekts gespeichert. Die <codeph>shiftKey</codeph>-Eigenschaft wird nicht verwendet. Das Ereignis kommt vor dem Auslösen des <codeph>focusIn</codeph>-Ereignisses durch das verwandte Objekt.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_IN_focusIn"><apiName>focusIn</apiName><shortdesc>
 Wird ausgelöst, nachdem ein Anzeigeobjekt den Fokus erhalten hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_IN</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, <i>nachdem</i> ein Anzeigeobjekt den Fokus erhalten hat. Dies passiert, wenn Benutzer das Objekt mit einem Zeigegerät oder per Tastaturnavigation hervorheben. Der Empfänger des Fokus ist das Zielobjekt dieses Ereignisses, während die dazugehörige InteractiveObject-Instanz, die den Fokus verliert, „verwandtes Objekt“ genannt wird. Ein Verweis auf das verwandte Objekt wird in der Eigenschaft <codeph>relatedObject</codeph> des empfangenden Objekts gespeichert. Die <codeph>shiftKey</codeph>-Eigenschaft wird nicht verwendet. Dieses Ereignis folgt nach dem Auslösen des <codeph>focusOut</codeph>-Ereignisses des vorigen Objekts.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.SELECT_ALL_selectAll"><apiName>selectAll</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Alles-auswählen-Vorgang aktiviert oder aus dem Kontextmenü die Option „Alles auswählen“ wählt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT_ALL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Alles-auswählen-Vorgang aktiviert oder aus dem Kontextmenü die Option „Alles auswählen“ wählt. Dieses Ereignis wird für das Objekt ausgelöst, das gerade den Eingabefokus hat. Ist das Objekt, das derzeit den Fokus hat, ein TextField, wählt dieses Ereignis standardmäßig alle Inhalte des Textfelds aus. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.PASTE_paste"><apiName>paste</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Einfügevorgang aktiviert oder aus dem Kontextmenü die Option „Einfügen“ wählt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.PASTE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Einfügevorgang aktiviert oder aus dem Kontextmenü die Option „Einfügen“ wählt. Dieses Ereignis wird für das Objekt ausgelöst, das gerade den Eingabefokus hat. Ist das Objekt, das derzeit den Fokus hat, ein TextField, fügt dieses Ereignis standardmäßig die Inhalte der Zwischenablage an der aktuellen Einfügemarke im Textfeld ein, wobei aktuell ausgewählter Text ersetzt wird. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CUT_cut"><apiName>cut</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Ausschneidevorgang aktiviert oder aus dem Kontextmenü die Option „Ausschneiden“ wählt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CUT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Ausschneidevorgang aktiviert oder aus dem Kontextmenü die Option „Ausschneiden“ wählt. Dieses Ereignis wird für das Objekt ausgelöst, das gerade den Eingabefokus hat. Ist das Objekt, das derzeit den Fokus hat, ein TextField, schneidet dieses Ereignis standardmäßig aktuell ausgewählten Text aus dem Textfeld aus und platziert ihn in die Zwischenablage. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.COPY_copy"><apiName>copy</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Kopierevorgang aktiviert oder aus dem Kontextmenü die Option „Kopieren“ wählt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COPY</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer die plattformspezifische Zugriffstastenkombination für einen Kopierevorgang aktiviert oder aus dem Kontextmenü die Option „Kopieren“ wählt. Dieses Ereignis wird für das Objekt ausgelöst, das gerade den Eingabefokus hat. Ist das Objekt, das derzeit den Fokus hat, ein TextField, kopiert dieses Ereignis standardmäßig aktuell ausgewählten Text aus dem Textfeld in die Zwischenablage. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CLEAR_clear"><apiName>clear</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer aus dem Kontextmenü die Option „Löschen“ wählt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLEAR</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer aus dem Kontextmenü die Option „Löschen“ wählt. Dieses Ereignis wird für das Objekt ausgelöst, das gerade den Eingabefokus hat. Ist das Objekt, das derzeit den Eingabefokus hat, ein TextField, löscht dieses Ereignis standardmäßig aktuell ausgewählten Text aus dem Textfeld. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:InteractiveObject:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
	Durch das Aufrufen des neuen Konstruktors „InteractiveObject()“ wird eine ArgumentError-Ausnahme ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Durch das Aufrufen des Konstruktors <codeph>new InteractiveObject()</codeph> wird eine <codeph>ArgumentError</codeph>-Ausnahme ausgelöst. Sie können jedoch Konstruktoren für die folgenden Unterklassen von „InteractiveObject“ aufrufen:
	
	<ul>
	
		<li><codeph>new SimpleButton()</codeph></li>
		<li><codeph>new TextField()</codeph></li>
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:InteractiveObject:contextMenu:get"><apiName>contextMenu</apiName><shortdesc> 
	 Gibt das diesem Objekt zugeordnete Kontextmenü an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier><apiTipTexts><apiTipText>Das mit diesem Objekt verknüpfte Kontextmenü.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Gibt das diesem Objekt zugeordnete Kontextmenü an.
	 
	 <p>Für Inhalt, der in Flash Player ausgeführt wird, handelt es sich bei dieser Eigenschaft um ein ContextMenu-Objekt. In der AIR-Laufzeitumgebung erweitert die ContextMenu-Klasse die NativeMenu-Klasse, doch Flash Player unterstützt nur die ContextMenu-Klasse, nicht aber die NativeMenu-Klasse.
	 </p>
	 
	 <p><b>Hinweis:</b> TextField-Objekte enthalten im Kontextmenü immer ein Zwischenablagemenü. Das Zwischenablagemenü enthält die Befehle „Ausschneiden“, „Kopieren“, „Einfügen“, Löschen“ und „Alles auswählen“. Diese Befehle können aus dem Kontextmenü von TextField-Objekten nicht entfernt werden. Bei TextField-Objekten werden beim Auswählen dieser Befehle (oder der entsprechenden Zugriffstastenkombinationen) keine <codeph>clear</codeph>-, <codeph>copy</codeph>-, <codeph>cut</codeph>-, <codeph>paste</codeph>- oder <codeph>selectAll</codeph>-Ereignisse ausgelöst.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:doubleClickEnabled:get"><apiName>doubleClickEnabled</apiName><shortdesc> 
	 Gibt an, ob das Objekt doubleClick-Ereignisse empfängt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Gibt an, ob dieses Objekt Doppelklick-Meldungen empfängt.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Gibt an, ob dieses Objekt <codeph>doubleClick</codeph>-Ereignisse empfängt. Der Standardwert ist <codeph>false</codeph>. Das heißt, dass eine InteractiveObject-Instanz standardmäßig keine <codeph>doubleClick</codeph>-Ereignisse erhält. Ist die <codeph>doubleClickEnabled</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt, empfängt die Instanz <codeph>doubleClick</codeph>-Ereignisse innerhalb ihrer Grenzen. Die <codeph>mouseEnabled</codeph>-Eigenschaft der InteractiveObject-Instanz muss ebenfalls auf <codeph>true</codeph> gesetzt werden, damit das Objekt <codeph>doubleClick</codeph>-Ereignisse empfängt.
	 
	 <p>Durch das Festlegen dieser Eigenschaft wird kein Ereignis ausgelöst. Sie müssen die <codeph>addEventListener()</codeph>-Methode verwenden, um einen Ereignis-Listener für das <codeph>doubleClick</codeph>-Ereignis hinzuzufügen.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InteractiveObject/event:doubleClick"><linktext>doubleClick</linktext></link><link href="flash.display.xml#InteractiveObject/mouseEnabled"><linktext>mouseEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:focusRect:get"><apiName>focusRect</apiName><shortdesc> 
	 Gibt an, ob für dieses Objekt ein Fokusrechteck angezeigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip._focusRect, Button._focusRect, and 
	 _focusRect (global property) topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc> 
	 Gibt an, ob für dieses Objekt ein Fokusrechteck angezeigt wird. Es sind drei Werte möglich: <codeph>true</codeph>, <codeph>false</codeph> oder <codeph>null</codeph>. Die Werte <codeph>true</codeph> und <codeph>false</codeph> geben an, ob ein Fokusrechteck angezeigt wird oder nicht. Der Wert <codeph>null</codeph> gibt an, dass dieses Objekt der <codeph>stageFocusRect</codeph>-Eigenschaft der Bühne unterliegt.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:mouseEnabled:get"><apiName>mouseEnabled</apiName><shortdesc> 
	 Gibt an, ob dieses Objekt Meldungen von der Maus empfängt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 Gibt an, ob dieses Objekt Meldungen von der Maus empfängt. Der Standardwert ist <codeph>true</codeph>, d. h., dass standardmäßig jede InteractiveObject-Instanz, die sich in der Anzeigeliste befindet, Mausereignisse erhält. Ist <codeph>mouseEnabled</codeph> auf <codeph>false</codeph> gesetzt, empfängt die Instanz keine Mausereignisse. Untergeordnete Elemente dieser Instanz in der Anzeigeliste sind nicht betroffen. Wenn Sie das <codeph>mouseEnabled</codeph>-Verhalten für alle Objekte ändern möchten, die einem Objekt in der Anzeigeliste untergeordnet sind, verwenden Sie <codeph>flash.display.DisplayObjectContainer.mouseChildren</codeph>.
	 <p> Durch das Festlegen dieser Eigenschaft wird kein Ereignis ausgelöst. Um interaktive Funktionalität zu erzielen, müssen Sie die <codeph>addEventListener()</codeph>-Methode verwenden.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:tabEnabled:get"><apiName>tabEnabled</apiName><shortdesc> 
	 Gibt an, ob sich dieses Objekt in der Tabulatorreihenfolge befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip.tabEnabled, Button.tabEnabled, and 
	 TextField.tabEnabled topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Gibt an, ob dieses Objekt in der Tabulatorreihenfolge vorliegt.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Gibt an, ob sich dieses Objekt in der Tabulatorreihenfolge befindet. Liegt dieses Objekt in der Tabulatorreihenfolge vor, ist der Wert <codeph>true</codeph>, andernfalls <codeph>false</codeph>. Der Standardwert ist <codeph>false</codeph>, mit folgender Ausnahme:
     <ul><li>Bei einem SimpleButton-Objekt lautet der Wert <codeph>true</codeph>.</li>
     <li>Bei einem TextField-Objekt mit <codeph>type = "input"</codeph> lautet der Wert <codeph>true</codeph>.</li>
     <li>Bei einem Sprite-Objekt oder MovieClip-Objekt mit <codeph>buttonMode = true</codeph> lautet der Wert <codeph>true</codeph>.</li></ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:tabIndex:get"><apiName>tabIndex</apiName><shortdesc> 
   	 Gibt die Tabulatorreihenfolge von Objekten in einer SWF-Datei an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Der Tabulatorindex für dieses Objekt.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
   	 Gibt die Tabulatorreihenfolge von Objekten in einer SWF-Datei an. Die Eigenschaft <codeph>tabIndex</codeph> hat standardmäßig den Wert -1, d. h., für das Objekt ist kein Tabulatorindex gesetzt.
	 
   	 <p>Wenn eines der gegenwärtig in der SWF-Datei angezeigten Objekte die <codeph>tabIndex</codeph>-Eigenschaft aufweist, wird die automatische Tabulatorreihenfolge deaktiviert und die Tabulatorreihenfolge anhand der <codeph>tabIndex</codeph>-Eigenschaften der Objekte in der SWF-Datei ermittelt. Bei der benutzerdefinierten Tabulatorreihenfolge werden nur Objekte berücksichtigt, die über die <codeph>tabIndex</codeph>-Eigenschaft verfügen.</p>
	 
   	 <p>Die <codeph>tabIndex</codeph>-Eigenschaft kann eine positive Ganzzahl sein. Die Objekte werden entsprechend den <codeph>tabIndex</codeph>-Eigenschaften in aufsteigender Reihenfolge angeordnet. Dabei liegt ein Objekt mit einem <codeph>tabIndex</codeph>-Wert von 1 in der Reihenfolge vor einem Objekt mit einem <codeph>tabIndex</codeph>-Wert von 2. Derselbe <codeph>tabIndex</codeph>-Wert darf nicht für mehrere Objekte verwendet werden.</p>
	 
	 <p>Die durch die <codeph>tabIndex</codeph>-Eigenschaft festgelegte benutzerdefinierte Tabulatorreihenfolge ist <i>flat</i>. Das heißt, die hierarchischen Beziehungen zwischen Objekten in der SWF-Datei bleiben unberücksichtigt. Alle Objekte in der SWF-Datei, die die <codeph>tabIndex</codeph>-Eigenschaften aufweisen, werden in die Tabulatorreihenfolge eingeordnet, die wiederum durch die Reihenfolge der <codeph>tabIndex</codeph>-Werte bestimmt wird. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
 Definiert einen angeordneten Satz an Dreiecken, die entweder mithilfe von Füllkoordinaten (u, v) oder normaler Füllung dargestellt werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Definiert einen angeordneten Satz an Dreiecken, die entweder mithilfe von Füllkoordinaten (u, v) oder normaler Füllung dargestellt werden können. Jedes Dreieck im Pfad wird durch drei Koordinatensätze (x, y) dargestellt, die jeweils einen Punkt des Dreiecks bilden.
 
 <p>
 Die Scheitelpunkte der Dreiecke enthalten keine z-Koordinate und stellen nicht notwendigerweise eine 3D-Fläche dar. Der Pfad eines Dreiecks kann jedoch verwendet werden, um die 3D-Darstellung in einem 2D-Raum zu unterstützen.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsTrianglePath:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
     Erstellt ein neues GraphicsTrianglePath-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Ein Zahlenvektor, bei dem jedes Zahlenpaar als Punkt behandelt wird (ein Paar bestehend aus x und y). Erforderlich.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Ein Ganzzahl- oder Indexvektor, bei dem jeweils drei Indexwerte ein Dreieck definieren. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Ein Vektor normalisierter Koordinaten, der für die Anwendung von Texturmapping verwendet wird.
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Legt fest, ob Dreiecke, die in eine bestimmte Richtung zeigen, dargestellt werden sollen. Wird für die Darstellung von Dreiecken verwendet, die in der aktuellen Ansicht nicht sichtbar sind. Kann auf einen beliebigen in der TriangleCulling-Klasse festgelegten Wert gesetzt werden.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues GraphicsTrianglePath-Objekt.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsTrianglePath/culling"><linktext>Culling</linktext></link><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsTrianglePath:indices"><apiName>indices</apiName><shortdesc>
     Ein Ganzzahl- oder Indexvektor, bei dem jeweils drei Indexwerte ein Dreieck definieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     Ein Ganzzahl- oder Indexvektor, bei dem jeweils drei Indexwerte ein Dreieck definieren. Ist der indexes-Parameter null, so definieren jeweils drei Scheitelpunkte (sechs Paare bestehend aus x und y im vertices-Vektor) ein Dreieck. Andernfalls bezieht sich jede Indexpositon auf einen Scheitelpunkt, ein Zahlenpaar im vertices-Vektor. Beispiel: <codeph>indexes[1]</codeph> verweist auf (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>). 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:uvtData"><apiName>uvtData</apiName><shortdesc>
     Ein Vektor normalisierter Koordinaten, der für die Anwendung von Texturmapping verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Ein Vektor normalisierter Koordinaten, der für die Anwendung von Texturmapping verwendet wird. Jede Koordinate verweist auf einen Punkt in der Bitmap, die für die Füllung verwendet wird. Für jeden Scheitelpunkt muss es eine UV- oder UVT-Koordinate geben.
     
     <p>
     Die UV-Koordinaten (0,0) entsprechen dem linken oberen Bereich der Bitmap, während (1,1) dem rechten unteren Bereich entspricht. 
     </p>
                    
     <p>
     Entspricht die Länge dieses Vektors der doppelten Länge des <codeph>vertices</codeph>-Vektors, so werden die normalisierten Koordinaten ohne Perspektivenkorrektur verwendet.
     </p>
     
     <p>
     Entspricht die Länge dieses Vektors der dreifachen Länge des <codeph>vertices</codeph>-Vektors, so wird die dritte Koordinate als „t“ interpretiert, als Entfernung zwischen Auge und Textur im Sichtraum. Dies ermöglicht der Wiedergabe-Engine die korrekte Anwendung von Perspektiven beim Texturmapping im 3D-Raum.
     </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:vertices"><apiName>vertices</apiName><shortdesc>
     Ein Zahlenvektor, bei dem jedes Zahlenpaar als Punkt behandelt wird (ein Paar bestehend aus x und y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Ein Zahlenvektor, bei dem jedes Zahlenpaar als Punkt behandelt wird (ein Paar bestehend aus x und y).
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:culling:get"><apiName>culling</apiName><shortdesc>
     Legt fest, ob Dreiecke, die in eine bestimmte Richtung zeigen, dargestellt werden sollen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Legt fest, ob Dreiecke, die in eine bestimmte Richtung zeigen, dargestellt werden sollen. Wird für die Darstellung von Dreiecken verwendet, die in der aktuellen Ansicht nicht sichtbar sind. 
     <p>
     Kann auf einen beliebigen in der TriangleCulling-Klasse festgelegten Wert gesetzt werden.
     </p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObject"><apiName>DisplayObject</apiName><shortdesc>
 Die DisplayObject-Klasse ist die Basisklasse für alle Objekte, die in die Anzeigeliste eingefügt werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die DisplayObject-Klasse ist die Basisklasse für alle Objekte, die in die Anzeigeliste eingefügt werden können. Die Anzeigeliste verwaltet alle Objekte, die in Flash Player oder in Adobe AIR angezeigt werden. Um die Anzeigeobjekte innerhalb der Anzeigeliste anzuordnen, verwenden Sie die DisplayObjectContainer-Klasse. DisplayObjectContainer-Objekte können untergeordnete Anzeigeobjekte besitzen, während andere Anzeigeobjekte, wie die Objekte „Shape“ oder „TextField“, Endknoten sind, die nur übergeordnete und Parallelobjekte besitzen, aber keine untergeordneten Objekte. 
 
 <p>Die DisplayObject-Klasse unterstützt grundlegende Funktionalitäten wie die <i>x</i>- und <i>y</i>-Position eines Objekts sowie Objekteigenschaften für fortgeschrittene Anwender, z. B. die Transformationsmatrix. 
 </p>
 
 <p>DisplayObject ist eine abstrakte Basisklasse. Daher können Sie DisplayObject nicht direkt aufrufen. Durch das Aufrufen von <codeph>new DisplayObject()</codeph> wird eine <codeph>ArgumentError</codeph>-Ausnahme ausgelöst. </p>
 
 <p>Alle Anzeigeobjekte erben die Eigenschaften und Methoden der DisplayObject-Klasse.</p>
 
 <p>Die DisplayObject-Klasse selbst enthält keine APIs zum Rendern von Inhalten auf dem Bildschirm. Wenn Sie eine benutzerdefinierte Unterklasse der DisplayObject-Klasse erstellen möchten, sollten Sie daher eine ihrer Unterklassen erweitern, die über APIs zum Rendern von Inhalt auf dem Bildschirm verfügt (wie die Klassen Shape, Sprite, Bitmap, SimpleButton, TextField oder MovieClip).</p>
 
 <p>Die DisplayObject-Klasse enthält mehrere broadcast-Ereignisse. Normalerweise ist das Ziel eines bestimmten Ereignisses eine bestimmte DisplayObject-Instanz. So ist z. B. das Ziel eines <codeph>added</codeph>-Ereignisses die bestimmte DisplayObjectInstanz, die der Anzeigeliste hinzugefügt wurde. Bei einem einzigen Ziel ist die Platzierung des Ereignis-Listeners auf dieses Ziel beschränkt, in manchen Fällen auf die übergeordneten Elemente des Ziels in der Anzeigeliste. Bei broadcast-Ereignissen ist das Ziel jedoch keine bestimmte DisplayObject-Instanz, sondern alle DisplayObject-Instanzen, einschließlich jener, die nicht in der Anzeigeliste erscheinen. Das bedeutet, dass Sie jeder DisplayObject-Instanz einen Listener hinzufügen können, der auf broadcast-Ereignisse wartet. Zusätzlich zu den in der Ereignistabelle der DisplayObject-Klasse aufgelisteten broadcast-Ereignissen erbt die DisplayObject-Klasse zwei broadcast-Erignisse von der EventDispatcher-Klasse: <codeph>activate</codeph> und <codeph>deactivate</codeph>.</p>
 
 <p>Einige der in den ActionScript 1.0- und 2.0-Klassen MovieClip, TextField und Button verwendeten Eigenschaften (wie <codeph>_alpha</codeph>, <codeph>_height</codeph>, <codeph>_name</codeph>, <codeph>_width</codeph>, <codeph>_x</codeph>, <codeph>_y</codeph> und andere) verfügen über Entsprechungen in der ActionScript 3.0-Klasse DisplayObject, wurden aber so umbenannt, dass der neue Name nicht mehr mit einem Unterstrich (_) beginnt.</p>
 
 <p>Weitere Informationen finden Sie im Kapitel „Programmierung von Anzeigeobjekten“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
 
 </apiDesc><example conref="examples\DisplayObjectExample.as"> Im folgenden Beispiel wird die Klasse <codeph>DisplayObjectExample</codeph> verwendet, um in einer Ecke der Bühne ein orangefarbenes Quadrat zu zeichnen und dann auf Ereignisse zu reagieren, indem für die einzelnen Ereignisse Textinformationen angezeigt werden. Dies wird in den folgenden Schritten erreicht:
 <ol>
    <li>Für die Farbe und Größe des Quadrats werden Klasseneigenschaften deklariert.</li>
     <li>Der Konstruktor ruft die <codeph>draw()</codeph>-Methode auf, die auf der Bühne an der Standardposition mit den Koordinaten <i>x = 0, y = 0</i> ein orangefarbenes Quadrat zeichnet.</li>
    <li>Dem Quadrat sind die folgenden Ereignis-Listener-Methoden zugeordnet:
     <ul>
        <li><codeph>addedHandler()</codeph>: Listener für <codeph>added</codeph>-Ereignisse, die ausgelöst werden, wenn das Quadrat der Anzeigeliste hinzugefügt wird.</li>
        <li><codeph>enterFrameHandler()</codeph>: Listener für <codeph>enterFrame</codeph>-Ereignisse, die in diesem Beispiel keine besondere Bedeutung haben.</li>
        <li><codeph>removedHandler()</codeph>: Listener für <codeph>removed</codeph>-Ereignisse, die ausgelöst werden, wenn das Quadrat aus der Anzeigeliste entfernt wird. Dies ist der Fall, wenn Benutzer auf das Quadrat klicken.</li>
        <li><codeph>clickHandler()</codeph>: Listener für <codeph>click</codeph>-Ereignisse, die ausgelöst werden, wenn Benutzer auf das orangefarbene Quadrat klicken.</li>
        <li><codeph>renderHandler()</codeph>: Listener für <codeph>render</codeph>-Ereignisse, die ausgelöst werden, nachdem die Anzeigeliste aktualisiert wurde.</li>
  </ul></li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class DisplayObjectExample extends Sprite {
        public function DisplayObjectExample() {
            var child:CustomDisplayObject = new CustomDisplayObject();
            addChild(child);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.events.*;

class CustomDisplayObject extends Sprite {
    private var bgColor:uint = 0xFFCC00;
    private var size:uint    = 80;

    public function CustomDisplayObject() {
        draw();
        addEventListener(Event.ADDED, addedHandler);
        addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        addEventListener(Event.REMOVED, removedHandler);
        addEventListener(MouseEvent.CLICK, clickHandler);
        addEventListener(Event.RENDER, renderHandler);
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }

    private function clickHandler(event:MouseEvent):void {
        trace("clickHandler: " + event);
        parent.removeChild(this);
    }

    private function addedHandler(event:Event):void {
        trace("addedHandler: " + event);
        stage.scaleMode = StageScaleMode.NO_SCALE;
        stage.align = StageAlign.TOP_LEFT;
        stage.addEventListener("resize", resizeHandler);
    }

    private function enterFrameHandler(event:Event):void {
        trace("enterFrameHandler: " + event);
        removeEventListener("enterFrame", enterFrameHandler);
    }

    private function removedHandler(event:Event):void {
        trace("removedHandler: " + event);
        stage.removeEventListener("resize", resizeHandler);
    }

    private function renderHandler(event:Event):void {
        trace("renderHandler: " + event);
    }

    private function resizeHandler(event:Event):void {
        trace("resizeHandler: " + event);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.RENDER_render"><apiName>render</apiName><shortdesc>
 [broadcast event] Wird ausgelöst, wenn die Anzeigeliste kurz davor steht, aktualisiert und neu gezeichnet zu werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RENDER</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Wird ausgelöst, wenn die Anzeigeliste kurz davor steht, aktualisiert und neu gezeichnet zu werden. Dieses Ereignis bietet für Objekte, die auf dieses Ereignis warten, die letzte Möglichkeit zum Vornehmen von Änderungen, bevor die Anzeigeliste neu gezeichnet (gerendert) wird. Sie müssen die <codeph>invalidate()</codeph>-Methode des Stage-Objekts jedes Mal aufrufen, wenn ein <codeph>render</codeph>-Ereignis ausgelöst werden soll. <codeph>Render</codeph>-Ereignisse werden für ein Objekt nur ausgelöst, wenn ein gegenseitiges Vertrauensverhältnis zwischen diesem Objekt und dem Objekt besteht, das <codeph>Stage.invalidate()</codeph> aufgerufen hat. Bei diesem Ereignis handelt es sich um ein broadcast-Ereignis. Das bedeutet, dass es von allen Anzeigeobjekten ausgelöst wird, die einen Listener für dieses Ereignis registriert haben.
 
 <p><b>Hinweis:</b> Dieses Ereignis wird nicht ausgelöst, wenn die Anzeige nicht dargestellt wird. Dies ist der Fall, wenn der Inhalt entweder minimiert ist oder verdeckt wird. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_FROM_STAGE_removedFromStage"><apiName>removedFromStage</apiName><shortdesc>
 Wird ausgelöst, wenn ein Anzeigeobjekt aus der Anzeigeliste entfernt werden soll. Dies erfolgt entweder direkt oder über das Entfernen einer Unterstruktur, die das Anzeigeobjekt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED_FROM_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Anzeigeobjekt aus der Anzeigeliste entfernt werden soll. Dies erfolgt entweder direkt oder über das Entfernen einer Unterstruktur, die das Anzeigeobjekt enthält. Zwei Methoden aus der DisplayObjectContainer-Klasse erzeugen dieses Ereignis: <codeph>removeChild()</codeph> und <codeph>removeChildAt()</codeph>. 
 
 <p>Auch die folgenden Methoden eines DisplayObjectContainer-Objekts erzeugen dieses Ereignis, wenn ein Objekt entfernt werden muss, um Platz für das neue Objekt zu schaffen: <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph> und <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_removed"><apiName>removed</apiName><shortdesc>
 Wird ausgelöst, wenn ein Objekt aus der Anzeigeliste entfernt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Objekt aus der Anzeigeliste entfernt werden soll. Zwei Methoden aus der DisplayObjectContainer-Klasse erzeugen dieses Ereignis: <codeph>removeChild()</codeph> und <codeph>removeChildAt()</codeph>. 
 
 <p>Auch die folgenden Methoden eines DisplayObjectContainer-Objekts erzeugen dieses Ereignis, wenn ein Objekt entfernt werden muss, um Platz für das neue Objekt zu schaffen: <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph> und <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.EXIT_FRAME_exitFrame"><apiName>exitFrame</apiName><shortdesc>
 [broadcast event] Wird ausgelöst, wenn der Abspielkopf das aktuelle Bild verlässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXIT_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Wird ausgelöst, wenn der Abspielkopf das aktuelle Bild verlässt. Alle Bildskripten wurden ausgeführt. Wenn sich der Abspielkopf gerade nicht bewegt oder wenn es nur ein einziges Bild gibt, wird dieses Ereignis kontinuierlich ausgelöst, und zwar zusammen mit der Bildrate. Bei diesem Ereignis handelt es sich um ein broadcast-Ereignis. Das bedeutet, dass es von allen Anzeigeobjekten ausgelöst wird, die einen Listener für dieses Ereignis registriert haben.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.FRAME_CONSTRUCTED_frameConstructed"><apiName>frameConstructed</apiName><shortdesc>
 [broadcast event] Wird ausgelöst, nachdem die Konstruktoren von Bildanzeigeobjekten ausgeführt wurden, bevor Bildskripten ausgeführt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.FRAME_CONSTRUCTED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Wird ausgelöst, nachdem die Konstruktoren von Bildanzeigeobjekten ausgeführt wurden, bevor Bildskripten ausgeführt wurden. Wenn sich der Abspielkopf gerade nicht bewegt oder wenn es nur ein einziges Bild gibt, wird dieses Ereignis kontinuierlich ausgelöst, und zwar zusammen mit der Bildrate. Bei diesem Ereignis handelt es sich um ein broadcast-Ereignis. Das bedeutet, dass es von allen Anzeigeobjekten ausgelöst wird, die einen Listener für dieses Ereignis registriert haben.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ENTER_FRAME_enterFrame"><apiName>enterFrame</apiName><shortdesc>
 [broadcast event] Wird ausgelöst, wenn der Abspielkopf ein neues Bild erreicht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ENTER_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Wird ausgelöst, wenn der Abspielkopf ein neues Bild erreicht. Wenn sich der Abspielkopf gerade nicht bewegt oder wenn es nur ein einziges Bild gibt, wird dieses Ereignis kontinuierlich ausgelöst, und zwar zusammen mit der Bildrate. Bei diesem Ereignis handelt es sich um ein broadcast-Ereignis. Das bedeutet, dass es von allen Anzeigeobjekten ausgelöst wird, die einen Listener für dieses Ereignis registriert haben.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_TO_STAGE_addedToStage"><apiName>addedToStage</apiName><shortdesc>
 Wird ausgelöst, wenn ein Anzeigeobjekt der Anzeigeliste für die Bühne hinzugefügt wird. Dies erfolgt entweder direkt oder über das Hinzufügen einer Unterstruktur, die das Anzeigeobjekt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED_TO_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Anzeigeobjekt der Anzeigeliste für die Bühne hinzugefügt wird. Dies erfolgt entweder direkt oder über das Hinzufügen einer Unterstruktur, die das Anzeigeobjekt enthält. Die folgenden Methoden lösen dieses Ereignis aus: <codeph>DisplayObjectContainer.addChild()</codeph>, <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_added"><apiName>added</apiName><shortdesc>
 Wird ausgelöst, wenn ein Objekt der Anzeigeliste hinzugefügt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Objekt der Anzeigeliste hinzugefügt wird. Die folgenden Methoden lösen dieses Ereignis aus: <codeph>DisplayObjectContainer.addChild()</codeph>, <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:DisplayObject:getBounds"><apiName>getBounds</apiName><shortdesc>
     Gibt ein Rechteck zurück, das den Bereich des Anzeigeobjekts in Bezug auf das Koordinatensystem des targetCoordinateSpace-Objekts definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das Rechteck, das den Bereich des Anzeigeobjekts in Bezug auf das Koordinatensystem des <codeph>targetCoordinateSpace</codeph>-Objekts definiert.
     
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Das Anzeigeobjekt, das das zu verwendende Koordinatensystem definiert.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt ein Rechteck zurück, das den Bereich des Anzeigeobjekts in Bezug auf das Koordinatensystem des <codeph>targetCoordinateSpace</codeph>-Objekts definiert. Im folgenden Code wird gezeigt, wie das zurückgegebene Rechteck variieren kann, und zwar abhängig von dem Wert, den Sie im Parameter <codeph>targetCoordinateSpace</codeph> an die Methode übergeben:
     
     <codeblock>
     var container:Sprite = new Sprite();
     container.x = 100;
     container.y = 100;
     this.addChild(container);
     var contents:Shape = new Shape();
     contents.graphics.drawCircle(0,0,100);
     container.addChild(contents);
     trace(contents.getBounds(container));
      // (x=-100, y=-100, w=200, h=200)
     trace(contents.getBounds(this));
      // (x=0, y=0, w=200, h=200)
     </codeblock>
     
     
     <p><b>Hinweis:</b> Mit den Methoden <codeph>localToGlobal()</codeph> und <codeph>globalToLocal()</codeph> können Sie die lokalen Koordinaten des Anzeigeobjekts in Anzeigekoordinaten bzw. Anzeigekoordinaten in lokale Koordinaten umwandeln.</p>
     
     <p>Die <codeph>getBounds()</codeph>-Methode ähnelt der <codeph>getRect()</codeph>-Methode. Allerdings umfasst das Rechteck, das von der <codeph>getBounds()</codeph>-Methode zurückgegeben wird, im Gegensatz zum von der <codeph>getRect()</codeph>-Methode zurückgegebenen Rechteck auch Striche auf Formen. Ein Beispiel finden Sie in der Beschreibung der <codeph>getRect()</codeph>-Methode.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getRect()"><linktext>getRect()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:getRect"><apiName>getRect</apiName><shortdesc>
    Gibt ein Rechteck zurück, das die Begrenzung des Anzeigeobjekts (ohne etwaige Striche oder Formen) definiert, und zwar aufgrund des vom Parameter „targetCoordinateSpace“ definierten Koordinatensystems.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das Rechteck, das den Bereich des Anzeigeobjekts in Bezug auf das Koordinatensystem des <codeph>targetCoordinateSpace</codeph>-Objekts definiert.
    
    </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Das Anzeigeobjekt, das das zu verwendende Koordinatensystem definiert.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Gibt ein Rechteck zurück, das die Begrenzung des Anzeigeobjekts (ohne etwaige Striche oder Formen) definiert, und zwar aufgrund des vom Parameter <codeph>targetCoordinateSpace</codeph> definierten Koordinatensystems. Die von der <codeph>getRect()</codeph>-Methode zurückgegebenen Werte sind kleiner oder gleich den von der <codeph>getBounds()</codeph>-Methode zurückgegebenen Werten.
    
    <p><b>Hinweis:</b> Mit den Methoden <codeph>localToGlobal()</codeph> und <codeph>globalToLocal()</codeph> können Sie die lokalen Koordinaten des Anzeigeobjekts in Bühnenkoordinaten bzw. Bühnenkoordinaten in lokale Koordinaten umwandeln.</p>
    
    </apiDesc><example conref="examples\DisplayObject.getRect.1.as"> Das folgende Beispiel zeigt, wie die <codeph>getBounds()</codeph>-Methode ein größeres Rechteck als die <codeph>getRect()</codeph>-Methode zurückgeben kann, da die Striche einen zusätzlichen Bereich einnehmen. In diesem Fall enthält das <codeph>triangle</codeph>-Sprite zusätzliche Striche aufgrund der Werte der <codeph>width</codeph>- und <codeph>jointStyle</codeph>-Parameter der <codeph>lineStyle()</codeph>-Methode. Die <codeph>trace()</codeph>-Ausgabe (in den letzten beiden Zeilen) zeigt die Unterschiede zwischen den Rechtecken <codeph>getRect()</codeph> und <codeph>getBounds()</codeph> an:
<codeblock>

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.geom.Rectangle;

var triangle:Sprite = new Sprite();
var color:uint = 0xFF0044;
var width:Number = 20;
var alpha:Number = 1.0;
var pixelHinting:Boolean = true;
var scaleMode:String = LineScaleMode.NORMAL;
var caps:String = CapsStyle.SQUARE;
var joints:String = JointStyle.MITER;
triangle.graphics.lineStyle(width, color, alpha, pixelHinting, scaleMode, caps, joints);

var triangleSide:Number = 100;
triangle.graphics.moveTo(0, 0);
triangle.graphics.lineTo(0, triangleSide);
triangle.graphics.lineTo(triangleSide, triangleSide);
triangle.graphics.lineTo(0, 0);

addChild(triangle);

trace(triangle.getBounds(this)); // (x=-10, y=-24.1, w=134.10000000000002, h=134.1)
trace(triangle.getRect(this));     // (x=0, y=0, w=100, h=100)
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getBounds()"><linktext>getBounds()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal"><apiName>globalToLocal</apiName><shortdesc>
     Konvertiert das point-Objekt von den (globalen) Bühnenkoordinaten in die (lokalen) Koordinaten des Anzeigeobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein point-Objekt, dessen Koordinaten sich auf das Anzeigeobjekt beziehen.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Ein mit der Point-Klasse erstelltes Objekt. Das point-Objekt gibt die <i>x</i>- und <i>y</i>-Koordinaten als Eigenschaften an.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Konvertiert das <codeph>point</codeph>-Objekt von den (globalen) Bühnenkoordinaten in die (lokalen) Koordinaten des Anzeigeobjekts.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Konvertiert das <codeph>point</codeph>-Objekt von den (globalen) Bühnenkoordinaten in die (lokalen) Koordinaten des Anzeigeobjekts.
     
     <p>Um diese Methode zu verwenden, erstellen Sie zuerst eine Instanz der Point-Klasse. Die <i>x</i>- und <i>y</i>-Werte, die Sie zuweisen, repräsentieren globale Koordinaten, weil sie sich auf den Ursprung (0,0) des Hauptanzeigebereichs beziehen. Dann übergeben Sie die Point-Instanz als Parameter an die <codeph>globalToLocal()</codeph>-Methode. Die Methode gibt ein neues point-Objekt mit <i>x</i>- und <i>y</i>-Werten zurück, die sich auf den Ursprung des Anzeigeobjekts beziehen, anstatt auf den Ursprung der Bühne.</p>
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> Der folgende Code erstellt ein Shape-Objekt und zeigt das Ergebnis des Aufrufens der <codeph>hitTestPoint()</codeph>-Methode an, indem verschiedene Punkte als Parameter verwendet werden. Die <codeph>globalToLocal()</codeph>-Methode konvertiert die Bühnenkoordinaten für den Punkt in den Koordinatenraum der Form:
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point-Klasse</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal3D"><apiName>globalToLocal3D</apiName><shortdesc>
     Konvertiert einen zweidimensionale Punkt von den (globalen) Bühnenkoordinaten in die dreidimensionalen (lokalen) Koordinaten des Anzeigeobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Vector3D-Objekt, dessen Koordinaten sich auf das dreidimensionale Anzeigeobjekt beziehen. 
     
     </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Ein zweidimensionales Point-Objekt, das globale x- und y-Koordinaten darstellt.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Konvertiert einen zweidimensionale Punkt von den (globalen) Bühnenkoordinaten in die dreidimensionalen (lokalen) Koordinaten des Anzeigeobjekts.
     
     <p>Um diese Methode zu verwenden, erstellen Sie zuerst eine Instanz der Point-Klasse. Die x- und y-Werte, die Sie dem Point-Objekt zuweisen, repräsentieren globale Koordinaten, da sie sich auf den Ursprung (0,0) des Hauptanzeigebereichs beziehen. Übergeben Sie das Point-Objekt dann als <codeph>point</codeph>-Parameter an die <codeph>globalToLocal3D()</codeph>-Methode. Die Methode gibt dreidimensionale Koordinaten als Vector3D-Objekt zurück, das die <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Werte enthält, die sich auf den Ursprung des dreidimensionalen Anzeigeobjekts beziehen.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestObject"><apiName>hitTestObject</apiName><shortdesc>
     Untersucht den Begrenzungsrahmen des Anzeigeobjekts, um festzustellen, ob er sich mit dem Begrenzungsrahmen des obj-Anzeigeobjekts überschneidet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Hat den Wert <codeph>true</codeph>, wenn sich die Begrenzungsrahmen der Anzeigeobjekte überschneiden, und den Wert <codeph>false</codeph>, wenn sie sich nicht überschneiden.
     
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Das zu vergleichende Anzeigeobjekt.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Untersucht den Begrenzungsrahmen des Anzeigeobjekts, um festzustellen, ob er sich mit dem Begrenzungsrahmen des obj-Anzeigeobjekts überschneidet, das als Parameter übergeben wird.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Untersucht den Begrenzungsrahmen des Anzeigeobjekts, um festzustellen, ob er sich mit dem Begrenzungsrahmen des <codeph>obj</codeph>-Anzeigeobjekts überschneidet.
     
     </apiDesc><example conref="examples\DisplayObject.hitTestObject.1.as"> Der folgende Code erstellt drei Shape-Objekte und zeigt das Ergebnis des Aufrufens der <codeph>hitTestObject()</codeph>-Methode an. Beachten Sie: Obwohl sich „circle2“ und „circle3“ selbst nicht überschneiden, überschneiden sich die Begrenzungsrahmen der Objekte doch. Deshalb gibt der Test von „circle2“ und „circle3“ den Wert <codeph>true</codeph> zurück.
<codeblock>

import flash.display.Shape;

var circle1:Shape = new Shape();
circle1.graphics.beginFill(0x0000FF);
circle1.graphics.drawCircle(40, 40, 40);
addChild(circle1);

var circle2:Shape = new Shape();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(40, 40, 40);
circle2.x = 50;
addChild(circle2);

var circle3:Shape = new Shape();
circle3.graphics.beginFill(0xFF0000);
circle3.graphics.drawCircle(40, 40, 40);
circle3.x = 100;
circle3.y = 67;
addChild(circle3);

trace(circle1.hitTestObject(circle2)); // true
trace(circle1.hitTestObject(circle3)); // false
trace(circle2.hitTestObject(circle3)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestPoint"><apiName>hitTestPoint</apiName><shortdesc>
     Wertet das Anzeigeobjekt aus, um festzustellen, ob es den durch die Parameter „x“ und „y“ festgelegten Punkt überdeckt oder schneidet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, wenn das Anzeigeobjekt den angegebenen Punkt überdeckt oder schneidet, andernfalls <codeph>false</codeph>.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>x</i>-Koordinate, mit der die x-Koordinate dieses Objekts verglichen werden soll.
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>y</i>-Koordinate, mit der die y-Koordinate dieses Objekts verglichen werden soll.
     
     </apiDesc></apiParam><apiParam><apiItemName>shapeFlag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Bestimmt, ob mit den Pixeln des Objekts (<codeph>true</codeph>) oder der Begrenzungsbox (<codeph>false</codeph>) verglichen werden soll. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Wertet das Anzeigeobjekt aus, um festzustellen, ob es einen durch „x“ und „y“ festgelegten Punkt überdeckt oder schneidet.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Wertet das Anzeigeobjekt aus, um festzustellen, ob es den durch die Parameter <codeph>x</codeph> und <codeph>y</codeph> festgelegten Punkt überdeckt oder schneidet. Die Parameter <codeph>x</codeph> und <codeph>y</codeph> legen einen Punkt im Koordinatenraum der Bühne fest, nicht den Anzeigeobjekt-Container, der das Anzeigeobjekt enthält (es sei denn, bei dem Anzeigeobjekt-Container handelt es sich um die Bühne).
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> Der folgende Code erstellt ein Shape-Objekt und zeigt das Ergebnis des Aufrufens der <codeph>hitTestPoint()</codeph>-Methode an, indem verschiedene Punkte als Parameter verwendet werden. Die <codeph>globalToLocal()</codeph>-Methode konvertiert die Bühnenkoordinaten für den Punkt in den Koordinatenraum der Form:
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:local3DToGlobal"><apiName>local3DToGlobal</apiName><shortdesc>
     Konvertiert einen dreidimensionalen Punkt der dreidimensionalen (lokalen) Koordinaten des Anzeigeobjekts in einen zweidimensionalen Punkt der (globalen) Bühnenkoordinaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein zweidimensionaler Punkt, der einen dreidimensionalen Punkt im zweidimensionalen Raum darstellt.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point3d</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Ein Vector3D-Objekt, das entweder einen dreidimensionalen Punkt oder die Koordinaten eines dreidimensionalen Anzeigeobjekts enthält.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Konvertiert einen dreidimensionalen Punkt der dreidimensionalen (lokalen) Koordinaten des Anzeigeobjekts in einen zweidimensionalen Punkt der (globalen) Bühnenkoordinaten.
     
     <p>Sie können beispielsweise für das Zeichnen mit den <codeph>display.Graphics</codeph>-Methoden nur zweidimensionale Koordinaten (x,y) verwenden. Zum Zeichnen eines dreidimensionalen Objekts müssen Sie die dreidimensionalen Koordinaten eines Anzeigeobjekts zweidimensionalen Koordinaten zuordnen. Erstellen Sie zunächst eine Instanz der Vector3D-Klasse, die die x-, y- und z-Koordinate des dreidimensionalen Anzeigeobjekts enthält. Übergeben Sie dann das Vector3D-Objekt als <codeph>point3d</codeph>-Parameter an die <codeph>local3DToGlobal()</codeph>-Methode. Die Methode gibt ein zweidimensionales Point-Objekt zurück, das mit der Grafik-API zum Zeichnen des dreidimensionalen Objekts verwendet werden kann.</p>
     
     
     </apiDesc><example conref="examples\Local3DToGlobalExample.as"> In diesem Beispiel wird unter Verwendung von <codeph>display.Graphics</codeph>-Methoden ein einfacher dreidimensionaler Würfel in einem zweidimensionalen Raum gezeichnet. Die Position des <codeph>this</codeph>-Anzeigeobjekts ist versetzt, sodass sich der Registrierungspunkt des Würfels in seiner Mitte befindet. Ein Vektor der Vector3D-Klasse enthält die dreidimensionalen Koordinaten des Würfels. Zuerst wird der obere Teil des Würfels gezeichnet, dann der untere, und danach werden die vier Ecken oben und unten verbunden. Damit Sie die <codeph>local3DToGlobal()</codeph>-Methode verwenden können, müssen Sie den Würfel vor dem Zeichnen dem Anzeigeobjektcontainer hinzufügen. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.geom.*;

    public class Local3DToGlobalExample extends MovieClip {
        private var myCube:Sprite = new Sprite();
        private var v8:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(8);

        public function Local3DToGlobalExample():void {
            this.x = -(this.stage.stageWidth / 2);
            this.y = -(this.stage.stageWidth / 2);

            v8[0] = new Vector3D(-40,-40,-40);
            v8[1] = new Vector3D(40,-40,-40);
            v8[2] = new Vector3D(40,-40,40);
            v8[3] = new Vector3D(-40,-40,40);
            v8[4] = new Vector3D(-40,100,-40);
            v8[5] = new Vector3D(40,100,-40);
            v8[6] = new Vector3D(40,100,40);
            v8[7] = new Vector3D(-40,100,40);

            myCube.x = (this.stage.stageWidth / 2);
            myCube.y = (this.stage.stageWidth / 2);
            myCube.z = 1;
            addChild(myCube);

            Cube();         
        }

        private function Cube():void {
            var ps:Point = new Point(0,0);

            myCube.graphics.lineStyle(2,0xFF0000);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:localToGlobal"><apiName>localToGlobal</apiName><shortdesc>
     Konvertiert das point-Objekt von den (lokalen) Koordinaten des Anzeigeobjekts in die (globalen) Bühnenkoordinaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein point-Objekt, dessen Koordinaten sich auf die Bühne beziehen.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Name oder Bezeichner eines Punkts, der mit der Point-Klasse erstellt wurde und die <i>x</i>- und <i>y</i>-Koordinaten als Eigenschaften angibt.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Konvertiert das <codeph>point</codeph>-Objekt von den (lokalen) Koordinaten des Anzeigeobjekts in die (globalen) Bühnenkoordinaten.
     
     <p>Mit dieser Methode können Sie beliebige <i>x</i>- und <i>y</i>-Koordinaten von Werten, die sich auf die obere linke Ecke eines bestimmten Anzeigeobjekts beziehen (lokale Koordinaten), in Werte umwandeln, die sich auf die obere linke Ecke der Bühne beziehen (globale Koordinaten).</p>
     
     <p>Um diese Methode zu verwenden, erstellen Sie zuerst eine Instanz der Point-Klasse. Die <i>x</i>- und <i>y</i>-Werte, die Sie zuweisen, repräsentieren lokale Koordinaten, weil sie sich auf den Ursprung (0,0) des Anzeigeobjekts beziehen.</p>
     
     <p>Dann übergeben Sie die Point-Instanz, die Sie erstellt haben, als Parameter an die <codeph>localToGlobal()</codeph>-Methode. Die Methode gibt ein neues point-Objekt mit <i>x</i>- und <i>y</i>-Werten zurück, die sich auf den Ursprung der Bühne beziehen, anstatt auf den Ursprung des Anzeigeobjekts.</p>
     
     </apiDesc><example conref="examples\DisplayObject.localToGlobal.1.as"> Der folgende Code erstellt ein Sprite-Objekt. Die Eigenschaften <codeph>mouseX</codeph> und <codeph>mouseY</codeph> des Sprites befinden sich im Koordinatenraum des Anzeigeobjekts. Dieser Code verwendet die <codeph>localToGlobal()</codeph>-Methode, um diese Eigenschaften in die globalen Koordinaten (für die Bühne) zu konvertieren:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.Point;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
square.x = 100;
square.y = 200;

addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates)

function traceCoordinates(event:MouseEvent):void {
    var clickPoint:Point = new Point(square.mouseX, square.mouseY);
    trace("display object coordinates:", clickPoint);
    trace("stage coordinates:", square.localToGlobal(clickPoint));
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point-Klasse</linktext></link></related-links></apiOperation><apiValue id="flash.display:DisplayObject:accessibilityProperties:get"><apiName>accessibilityProperties</apiName><shortdesc>
     Die aktuellen Optionen für Eingabehilfen zur Barrierefreiheit dieses Anzeigeobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.accessibility:AccessibilityProperties</apiValueClassifier></apiValueDef><apiDesc>
     Die aktuellen Optionen für Eingabehilfen zur Barrierefreiheit dieses Anzeigeobjekts. Wenn Sie die <codeph>accessibilityProperties</codeph>-Eigenschaft oder eines der Felder innerhalb von <codeph>accessibilityProperties</codeph> ändern, müssen Sie die <codeph>Accessibility.updateProperties()</codeph>-Methode aufrufen, damit diese Änderungen angewendet werden.
     
     <p class="flashonly"><b>Hinweis</b>: Bei einem in der Flash-Authoring-Umgebung erstellten Objekt wird für <codeph>accessibilityProperties</codeph> ein etwaiger Wert aus dem Bedienfeld „Eigenschaften“ für dieses Objekt übernommen.</p>
     
     </apiDesc><example conref="examples\DisplayObject.accessibilityProperties.1.as"> Aus dem folgenden Beispiel geht hervor, wie Sie ein einfaches AccessibilityProperties-Objekt einer TextField-Instanz zuordnen:
<codeblock>

import flash.text.TextField;
import flash.accessibility.AccessibilityProperties;
import flash.accessibility.Accessibility;
import flash.system.Capabilities;

var tf:TextField = new TextField();
tf.text = "hello";

var accessProps:AccessibilityProperties = new AccessibilityProperties();
accessProps.name = "Greeting";

tf.accessibilityProperties = accessProps;

if (Capabilities.hasAccessibility) {
    Accessibility.updateProperties();
}

trace(tf.accessibilityProperties.name); // Greeting
</codeblock></example></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link><link href="flash.accessibility.xml#AccessibilityProperties"><linktext>flash.accessibility.AccessibilityProperties</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:alpha:get"><apiName>alpha</apiName><shortdesc>
     Gibt den Alphatransparenzwert des angegebenen Objekts an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt den Alphatransparenzwert des angegebenen Objekts an. Die zulässigen Werte liegen zwischen 0 (völlig transparent) und 1 (völlig undurchsichtig). Der Standardwert ist 1. Anzeigeobjekte mit einem <codeph>alpha</codeph>-Wert von 0 <i>sind</i> aktiv, auch wenn sie nicht sichtbar sind.
     
     </apiDesc><example conref="examples\DisplayObject.alpha.1.as"> Der folgende Code setzt die <codeph>alpha</codeph>-Eigenschaft eines Sprites auf 50 %, wenn die Maus über das Sprite bewegt wird:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.alpha = 0.5;
}

function restoreObject(event:MouseEvent):void {
    event.target.alpha = 1.0;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:blendMode:get"><apiName>blendMode</apiName><shortdesc>
     Ein Wert aus der BlendMode-Klasse, mit dem angegeben wird, welcher Mischmodus verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert aus der BlendMode-Klasse, mit dem angegeben wird, welcher Mischmodus verwendet werden soll. Eine Bitmap kann intern auf zweierlei Weise gezeichnet werden. Wenn Sie eine Füllmethode oder eine externe Schnittmaske aktiviert haben, wird die Bitmap gezeichnet, indem dem Vektorrenderer ein Quadrat hinzugefügt wird. Wenn Sie versuchen, diese Eigenschaft auf einen ungültigen Wert einzustellen, wird der Wert von Flash Player oder Adobe AIR auf <codeph>BlendMode.NORMAL</codeph> eingestellt.
     
     <p>Die <codeph>blendMode</codeph>-Eigenschaft wirkt sich auf jedes Pixel des Anzeigeobjekts aus. Dabei wird jedes Pixel aus den drei Grundfarben (Rot, Grün und Blau) jeweils mit einem Farbwert zwischen 0x00 und 0xFF zusammengestellt. Flash Player oder Adobe AIR vergleicht jede Grundfarbe eines Pixels im Movieclip mit der entsprechenden Farbe des Pixels im Hintergrund. Wenn <codeph>blendMode</codeph> beispielsweise auf <codeph>BlendMode.LIGHTEN</codeph> eingestellt ist, vergleicht Flash Player oder Adobe AIR den Rotwert des Anzeigeobjekts mit dem Rotwert des Hintergrunds und verwendet den helleren der beiden Werte für die rote Komponente der angezeigten Farbe.</p>
     
     <p>In der folgenden Tabelle werden die Einstellungen von <codeph>blendMode</codeph> beschrieben. Die BlendMode-Klasse definiert String-Werte, die Sie verwenden können. Die Abbildungen in der Tabelle zeigen <codeph>blendMode</codeph>-Werte, die auf ein kreisförmiges Anzeigeobjekt (2) angewendet werden, das ein anderes Anzeigeobjekt (1) überlagert.</p>
     
     
     <p>
      <adobeimage alt="Quadrat Nr. 1" href="../../images/blendMode-0a.jpg"/> <adobeimage alt="Kreis Nr. 2" href="../../images/blendMode-0b.jpg"/>
     
     </p>
     
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="3"><thead><row><entry>BlendMode-Konstante</entry><entry>Abbildung</entry><entry>Beschreibung</entry></row></thead><tbody><row valign="top">
     <entry><codeph>BlendMode.NORMAL</codeph></entry>
     <entry><adobeimage alt="Mischmodus NORMAL" href="../../images/blendMode-1.jpg"/></entry>
     <entry>Das Anzeigeobjekt wird vor dem Hintergrund angezeigt. Die Pixelwerte des Anzeigeobjekts setzen die Werte des Hintergrunds außer Kraft. An den Stellen, an denen das Anzeigeobjekt transparent ist, wird der Hintergrund sichtbar.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LAYER</codeph></entry>
     <entry><adobeimage alt="Mischmodus LAYER" href="../../images/blendMode-2.jpg"/></entry>
     
     <entry>Erzwingt die Erstellung einer Transparenzgruppe für das Anzeigeobjekt. Dies bedeutet, dass das Anzeigeobjekt vorher in einem temporären Puffer zusammengesetzt wird, bevor es weiterverarbeitet wird. Dies geschieht automatisch, wenn das Anzeigeobjekt im Voraus mithilfe der Bitmap-Zwischenspeicherung zwischengespeichert wird oder wenn es sich bei dem Anzeigeobjekt um einen Anzeigeobjekt-Container handelt, der mindestens ein untergeordnetes Objekt besitzt, dessen <codeph>blendMode</codeph>-Einstellung nicht <codeph>BlendMode.NORMAL</codeph> ist.
     </entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.MULTIPLY</codeph></entry>
     <entry><adobeimage alt="Mischmodus MULTIPLY" href="../../images/blendMode-3.jpg"/></entry>
     
     <entry>Multipliziert die Werte der Grundfarben des Anzeigeobjekts mit denen der Hintergrundfarbe und normalisiert das Ergebnis durch Division durch 0xFF. Dies führt zu dunkleren Farben. Diese Einstellung wird im Allgemeinen für Schatten- und Tiefeneffekte verwendet.
     
     <p>Weisen beispielsweise die Grundfarbe (etwa Rot) eines Pixels im Anzeigeobjekt und eines Hintergrund-Pixels den Wert 0x88 auf, lautet das Ergebnis der Multiplikation 0x4840. Die Division durch 0xFF ergibt für diese Grundfarbe 0x48. Dies ist eine dunklere Farbe als die des Anzeigeobjekts bzw. des Hintergrunds.</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SCREEN</codeph></entry>
     <entry><adobeimage alt="Mischmodus SCREEN" href="../../images/blendMode-4.jpg"/></entry>
     
     <entry>Multipliziert die Komplementärfarbe des Anzeigeobjekts mit der Komplementärfarbe der Hintergrundfarbe, was zu helleren Farbtönen führt. Diese Einstellung wird in der Regel für Hervorhebungen bzw. zum Entfernen von schwarzen Bereichen aus dem Anzeigeobjekt verwendet.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LIGHTEN</codeph></entry>
     <entry><adobeimage alt="Mischmodus LIGHTEN" href="../../images/blendMode-5.jpg"/></entry>
     
     <entry>Wählt die hellere Grundfarbe des Anzeigeobjekts und die Farbe des Hintergrunds aus (die Farben mit höheren Werten). Diese Einstellung wird normalerweise für Überlagerungen verwendet.
     
     <p>Weist das Anzeigeobjekt z. B. ein Pixel mit einem RGB-Wert von 0xFFCC33 und das Hintergrund-Pixel einen RGB-Wert von 0xDDF800 auf, lautet der resultierende RGB-Wert für das angezeigte Pixel 0xFFF833 (da 0xFF > 0xDD, 0xCC &lt; 0xF8 und 0x33 > 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DARKEN</codeph></entry>
     <entry><adobeimage alt="Mischmodus DARKEN" href="../../images/blendMode-6.jpg"/></entry>
     
     <entry>Wählt die dunklere Grundfarbe des Anzeigeobjekts und des Hintergrunds aus (die niedrigeren Werte). Diese Einstellung wird normalerweise für Überlagerungen verwendet.
     
     <p>Weist das Anzeigeobjekt z. B. ein Pixel mit einem RGB-Wert von 0xFFCC33 und das Hintergrund-Pixel einen RGB-Wert von 0xDDF800 auf, lautet der resultierende RGB-Wert für das angezeigte Pixel 0xDDCC00 (da 0xFF > 0xDD, 0xCC &lt; 0xF8 und 0x33 > 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DIFFERENCE</codeph></entry>
     <entry><adobeimage alt="Mischmodus DIFFERENCE" href="../../images/blendMode-7.jpg"/></entry>
     
     <entry>Vergleicht die Grundfarben des Anzeigeobjekts mit den Farben des Hintergrunds und subtrahiert für die beiden Grundfarben den dunkleren Wert von dem helleren Wert. Diese Einstellung wird normalerweise zur Farbverstärkung verwendet.
     
     <p>Wenn das Anzeigeobjekt z. B. ein Pixel mit dem RGB-Farbwert 0xFFCC33 aufweist und das Pixel im Hintergrund den RGB-Wert 0xDDf800 hat, dann erhält das angezeigte Pixel den Wert 0x222C33 (da 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C und 0x33 - 0x00 = 0x33 ist).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ADD</codeph></entry>
     <entry><adobeimage alt="Mischmodus ADD" href="../../images/blendMode-8.jpg"/></entry>
     
     <entry>Addiert den Wert der Grundfarben des Anzeigeobjekts zu den Farben des Hintergrunds (mit einem oberen Grenzwert von 0xFF). Diese Einstellung wird im Allgemeinen für Animationen von heller werdenden Auflösungen zwischen zwei Objekten verwendet.
     
     <p>Wenn das Anzeigeobjekt z. B. ein Pixel mit dem RGB-Farbwert 0xAAA633 aufweist und das Pixel im Hintergrund den RGB-Wert 0xDD2200 hat, dann erhält das angezeigte Pixel den Wert 0xFFC833 (da 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8 und 0x33 + 0x00 = 0x33 ist).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.SUBTRACT</codeph></entry>
     <entry><adobeimage alt="Mischmodus SUBTRACT" href="../../images/blendMode-9.jpg"/></entry>
     
     <entry>Subtrahiert die Werte der Grundfarben des Anzeigeobjekts von den Werten der Hintergrundfarbe (mit einem unteren Grenzwert von 0). Diese Einstellung wird im Allgemeinen für Animationen von dunkler werdenden Auflösungen zwischen zwei Objekten verwendet.
     
     <p>Weist das Anzeigeobjekt z. B. ein Pixel mit einem RGB-Wert von 0xAA2233 und das Hintergrund-Pixel einen RGB-Wert von 0xDDA600 auf, lautet der resultierende RGB-Wert für das angezeigte Pixel 0x338400 (da 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84 und 0x00 - 0x33 &lt; 0x00).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.INVERT</codeph></entry>
     <entry><adobeimage alt="Mischmodus INVERT" href="../../images/blendMode-10.jpg"/></entry>
     
     <entry>Kehrt den Hintergrund um.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ALPHA</codeph></entry>
     <entry><adobeimage alt="Mischmodus ALPHA" href="../../images/blendMode-11.jpg"/></entry>
     
     <entry>Wendet den Alphawert jedes Pixels des Anzeigeobjekts auf den Hintergrund an. Dieser Vorgang erfordert, dass die <codeph>blendMode</codeph>-Einstellung des übergeordneten Anzeigeobjekts auf <codeph>BlendMode.LAYER</codeph> gesetzt wird. In dieser Abbildung gilt beispielsweise für das übergeordnete Anzeigeobjekt, einen weißen Hintergrund, die Einstellung <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ERASE</codeph></entry>
     <entry><adobeimage alt="Mischmodus ERASE" href="../../images/blendMode-12.jpg"/></entry>
     
     <entry>Löscht den Hintergrund anhand der Alphawerte des Anzeigeobjekts. Dieser Vorgang erfordert, dass die <codeph>blendMode</codeph>-Einstellung des übergeordneten Anzeigeobjekts auf <codeph>BlendMode.LAYER</codeph> gesetzt wird. In dieser Abbildung gilt beispielsweise für das übergeordnete Anzeigeobjekt, einen weißen Hintergrund, die Einstellung <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.OVERLAY</codeph></entry>
     <entry><adobeimage alt="Mischmodus OVERLAY" href="../../images/blendMode-13.jpg"/></entry>
     
     <entry>Passt die Farbe jedes Pixels entsprechend der Dunkelheit des Hintergrunds an. Wenn der Hintergrund heller ist als 50 % Grau, werden die Farben des Anzeigeobjekts und des Hintergrunds überlagert, um hellere Farben zu erhalten. Ist der Hintergrund dagegen dunkler als 50 % Grau, werden die Farben multipliziert, was zu dunkleren Farben führt. Diese Einstellung wird normalerweise für Schattierungen verwendet.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.HARDLIGHT</codeph></entry>
     <entry><adobeimage alt="Mischmodus HARDLIGHT" href="../../images/blendMode-14.jpg"/></entry>
     
     <entry>Passt die Farbe jedes Pixels entsprechend der Dunkelheit des Anzeigeobjekts an. Ist das Anzeigeobjekt heller als 50 % Grau, werden die Farben von Anzeigeobjekt und Hintergrund überlagert, was zu einer helleren Farbe führt. Ist das Anzeigeobjekt dagegen dunkler als 50 % Grau, werden die Farben multipliziert, was zu dunkleren Farben führt. Diese Einstellung wird normalerweise für Schattierungen verwendet.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SHADER</codeph></entry>
     <entry align="center" valign="middle">N/A</entry>
     
     <entry>Passt die Farbe mithilfe einer Standard-Shaderroutine an. Der verwendete Shader wird als die der <codeph>blendShader</codeph>-Eigenschaft zugewiesene Shader-Instanz festgelegt. Wird die <codeph>blendShader</codeph>-Eigenschaft eines Anzeigeobjekts auf eine Shader-Instanz gesetzt, so wird die <codeph>blendMode</codeph>-Eigenschaft des Anzeigeobjekts automatisch auf <codeph>BlendMode.SHADER</codeph> gesetzt. Wird die <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.SHADER</codeph> gesetzt, ohne vorher die <codeph>blendShader</codeph>-Eigenschaft zu setzen, so wird die <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.NORMAL</codeph> gesetzt.</entry>
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\DisplayObject.blendMode.1.as"> Der folgende Code erstellt zwei Sprite-Objekte, ein Quadrat und einen Kreis, und setzt den Mischmodus des Kreises (im Vordergrund) auf <codeph>BlendMode.SUBTRACT</codeph>, wenn der Mauszeiger auf den Kreis bewegt wird:
<codeblock>
import flash.display.Sprite;
import flash.display.BlendMode;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF88CC);
square.graphics.drawRect(0, 0, 80, 80);
addChild(square);

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.SUBTRACT;
}

function restoreObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.NORMAL;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>blendShader</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:cacheAsBitmap:get"><apiName>cacheAsBitmap</apiName><shortdesc>
     Bei der Einstellung „true“ wird in Flash Player oder Adobe AIR eine interne Bitmapdarstellung des Anzeigeobjekts im Cache zwischengespeichert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Gibt an, ob dieses Anzeigeobjekt als Bitmap zwischengespeichert werden soll.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Bei der Einstellung <codeph>true</codeph> wird in Flash Player oder Adobe AIR eine interne Bitmapdarstellung des Anzeigeobjekts im Cache zwischengespeichert. Diese Zwischenspeicherung kann bei Anzeigeobjekten mit komplexen Vektorgrafiken ggf. die Leistung verbessern.
     
     <p>Alle Vektordaten eines Anzeigeobjekts, das eine zwischengespeicherte Bitmap besitzt, werden nicht in die Hauptanzeige, sondern in eine Bitmap gezeichnet. Anschließend wird die Bitmap mit folgenden Eigenschaften in die Hauptanzeige kopiert: nicht gedehnt, nicht gedreht, Pixel rasten an den nächstgelegenen Pixelgrenzen ein. Die Pixel werden dem übergeordneten Objekt 1 zu 1 zugeordnet. Ändern sich die Grenzen der Bitmap, wird diese nicht gedehnt, sondern neu erstellt.</p>
     
     <p>Interne Bitmaps werden nur erstellt, wenn die <codeph>cacheAsBitmap</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt ist.</p>
     
     <p>Nachdem Sie die <codeph>cacheAsBitmap</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt haben, ändert sich die Wiedergabe nicht. Allerdings führt das Anzeigeobjekt die Ausrichtung an Pixeln automatisch durch. Die Animationsgeschwindigkeit kann je nach Komplexität des Vektorinhalts deutlich schneller bzw. langsamer ablaufen.
     </p>
     
     <p>Die <codeph>cacheAsBitmap</codeph>-Eigenschaft wird jeweils automatisch auf <codeph>true</codeph> gesetzt, wenn Sie einen Filter auf ein Anzeigeobjekt anwenden (vorausgesetzt, sein <codeph>filter</codeph>-Array ist nicht leer). Und wenn auf ein Anzeigeobjekt ein Filter angewendet worden ist, wird <codeph>cacheAsBitmap</codeph> für dieses Anzeigeobjekt als <codeph>true</codeph> gemeldet, selbst wenn Sie die Eigenschaft auf <codeph>false</codeph> setzen. Wenn Sie sämtliche Filter eines Anzeigeobjekts löschen, werden die <codeph>cacheAsBitmap</codeph>-Einstellungen auf ihren vorherigen Stand zurückgesetzt.</p>
     
     <p>In einigen Fällen verwendet ein Anzeigeobjekt keine Bitmap, auch wenn die <codeph>cacheAsBitmap</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt wurde. Stattdessen erfolgt die Wiedergabe aufgrund von Vektordaten, und zwar in den folgenden Fällen:</p>
     
     <ul>
     
       <li>Die Bitmap ist zu groß. In AIR 1.5 und Flash Player 10 ist die maximale Höhe oder Breite eines Bitmapbilds 8.191 Pixel, die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bitmapbild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite.</li>
     
       <li>Der Bitmap kann kein Speicher zugewiesen werden (nicht genügend Arbeitsspeicher vorhanden). </li>
     
     </ul>
     
     <p>Die <codeph>cacheAsBitmap</codeph>-Eigenschaft wird am besten mit Movieclips verwendet, die vorwiegend statischen Inhalt haben und nicht viel skaliert und gedreht werden. Bei solchen Movieclips kann <codeph>cacheAsBitmap</codeph> zu einer deutlichen Performance-Steigerung führen, wenn der Movieclip „übersetzt“ wird (wenn seine <i>x</i>- und <i>y</i>-Position geändert wird).</p>
     
     </apiDesc><example conref="examples\DisplayObject.cacheAsBitmap.1.as"> Im folgenden Beispiel wird einer Shape-Instanz ein Schlagschatten hinzugefügt. Anschließend wird der Wert der <codeph>cacheAsBitmap</codeph>-Eigenschaft verfolgt, die bei Verwendung eines Filters auf <codeph>true</codeph> gesetzt wird:
<codeblock>
import flash.display.Sprite;
import flash.filters.DropShadowFilter

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);

addChild(circle);

trace(circle.cacheAsBitmap); // false

var filter:DropShadowFilter = new DropShadowFilter();
circle.filters = [filter];

trace(circle.cacheAsBitmap); // true
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:filters:get"><apiName>filters</apiName><shortdesc>
     Ein indiziertes Array, das alle dem Anzeigeobjekt derzeit zugeordneten filter-Objekte enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Wenn <codeph>filters</codeph> einen ShaderFilter umfasst und der Shaderausgabetyp mit diesem Vorgang nicht kompatibel ist (der Shader muss eine <codeph>pixel4</codeph>-Ausgabe festlegen).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn <codeph>filters</codeph> einen ShaderFilter umfasst und der Shader keine Bildeingabe festlegt oder die erste Eingabe keine <codeph>image4</codeph>-Eingabe ist.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn <codeph>filters</codeph> einen ShaderFilter enthält und der Shader eine nicht vorhandene Bildeingabe festlegt.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn <codeph>filters</codeph> eine ShaderFilter-, ByteArray- oder Vector.&lt;Number>-Instanz als Shader-Eingabe enthält und die Eigenschaften <codeph>width</codeph> und <codeph>height</codeph> für das ShaderInput-Objekt nicht festgelegt sind, oder wenn die angegebenen Werte nicht mit der Datenmenge in den Eingabedaten übereinstimmen. Weitere Informationen finden Sie im Abschnitt zur <codeph>ShaderInput.input</codeph>-Eigenschaft.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Ein indiziertes Array, das alle dem Anzeigeobjekt derzeit zugeordneten filter-Objekte enthält. Die Klassen im flash.filters-Paket definieren spezifische Filter, die Sie verwenden können.
     
     <p>Filter können entweder während der Entwurfsphase in der Flash-Authoring-Umgebung oder zur Laufzeit durch Verwendung von ActionScript-Code angewendet werden. Damit Sie einen Filter mithilfe von ActionScript anwenden können, müssen Sie zunächst eine temporäre Kopie des gesamten <codeph>filters</codeph>-Arrays erstellen, dann das temporäre Array ändern und schließlich den Wert des temporären Arrays wieder auf das <codeph>filters</codeph>-Array zurücksetzen. Es ist nicht möglich, ein neues filter-Objekt direkt dem <codeph>filters</codeph>-Array hinzuzufügen.</p>
     
     <p>Um einen Filter mithilfe von ActionScript hinzuzufügen, müssen Sie die folgenden Schritte befolgen (wobei <codeph>myDisplayObject</codeph> das Ziel-Anzeigeobjekt ist):</p>
     
     <ol>
     
       <li>Erstellen Sie mithilfe der Konstruktormethode der gewählten Filterklasse ein neues filter-Objekt.</li>
     
       <li>Weisen Sie den Wert des <codeph>myDisplayObject.filters</codeph>-Arrays einem temporären Array zu, z. B. einem Array mit dem Namen <codeph>myFilters</codeph>.</li>
     
       <li>Fügen Sie das neue filter-Objekt dem temporären Array <codeph>myFilters</codeph> hinzu.</li>
     
       <li>Weisen Sie den Wert des temporären Arrays dem <codeph>myDisplayObject.filters</codeph>-Array zu.</li>
     
     </ol>
     
     <p>Wenn das <codeph>filters</codeph>-Array nicht definiert ist, müssen Sie kein temporäres Array verwenden. Stattdessen können Sie direkt ein Array-Literal mit einem oder mehreren selbst definierten Filterobjekten zuweisen. Im ersten Beispiel wird im Abschnitt „Beispiele“ mithilfe von Code, der sowohl definierte als auch undefinierte <codeph>filters</codeph>-Arrays verarbeiten kann, ein Schlagschatten-Filter hinzugefügt.</p>
     
     <p>Um ein vorhandenes filter-Objekt zu ändern, müssen Sie eine Technik anwenden, bei der eine Kopie des <codeph>filters</codeph>-Arrays geändert wird:</p>
     
     <ol>
     
       <li>Weisen Sie den Wert des <codeph>filters</codeph>-Arrays einem temporären Array zu, z. B. einem Array mit dem Namen <codeph>myFilters</codeph>.</li>
     
       <li>Ändern Sie die Eigenschaft mithilfe des temporären Arrays <codeph>myFilters</codeph>. Um beispielsweise die quality-Eigenschaft des ersten Filters im Array zu ändern, können Sie den folgenden Code anwenden: <codeph>myFilters[0].quality = 1;</codeph></li>
     
       <li>Weisen Sie den Wert des temporären Arrays dem <codeph>filters</codeph>-Array zu.</li>
     
     </ol>
     
     <p>Wenn ein Anzeigeobjekt während des Ladevorgangs mit einem Filter verknüpft ist, ist dieses so gekennzeichnet, dass es sich selbst als transparente Bitmap zwischenspeichert. Von diesem Punkt an speichert der Player das Anzeigeobjekt als Bitmap zwischen, solange das Anzeigeobjekt eine zulässige Filterliste besitzt. Diese Quell-Bitmap wird als Quellbild für die Filtereffekte verwendet. Jedes Anzeigeobjekt besitzt in der Regel zwei Bitmaps: eine mit dem ursprünglichen Quellanzeigeobjekt, und eine zweite für das nach dem Filtern entstehende Bild. Dieses Ergebnisbild wird für die Wiedergabe verwendet. Solange sich das Anzeigeobjekt nicht ändert, muss das Ergebnisbild nicht aktualisiert werden.</p>
     
     <p>Das flash.filters-Paket umfasst Klassen für Filter. Um beispielsweise einen DropShadow-Filter zu erstellen, würden Sie folgenden Code schreiben:</p>
     
     <codeblock>
     import flash.filters.DropShadowFilter
     var myFilter:DropShadowFilter = new DropShadowFilter (distance, angle, color, alpha, blurX, blurY, quality, inner, knockout)
     </codeblock>
     
     <p>Mithilfe des Operators <codeph>is</codeph> können Sie festlegen, welcher Filtertyp den einzelnen Indexpositionen im <codeph>filter</codeph>-Array zugewiesen werden soll. Der folgende Code zeigt z. B., wie Sie die Position des ersten Filters im <codeph>filters</codeph>-Array (DropShadowFilter) bestimmen:
     </p>
     
     <codeblock>
     import flash.text.TextField;
     import flash.filters.~~;
     var tf:TextField = new TextField();
     var filter1:DropShadowFilter = new DropShadowFilter();
     var filter2:GradientGlowFilter = new GradientGlowFilter();
     tf.filters = [filter1, filter2];
     
     tf.text = "DropShadow index: " + filterPosition(tf, DropShadowFilter).toString(); // 0
     addChild(tf)
     
     function filterPosition(displayObject:DisplayObject, filterClass:Class):int {
         for (var i:uint = 0; i &lt; displayObject.filters.length; i++) {
             if (displayObject.filters[i] is filterClass) {
                 return i;
             }
         }
         return -1;
     }
     </codeblock>
     <p><b>Hinweis:</b> Da Sie ein neues filter-Objekt dem <codeph>DisplayObject.filters</codeph>-Array nicht direkt hinzufügen können, hat der folgende Code keine Auswirkung auf das Ziel-Anzeigeobjekt <codeph>myDisplayObject</codeph>:</p>
     
     <codeblock>
     myDisplayObject.filters.push(myDropShadow);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="../../flash/filters/package-detail.html"><linktext>flash.filters package</linktext></link><link href="flash.display.xml#ShaderInput/input"><linktext>flash.display.ShaderInput.input</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:height:get"><apiName>height</apiName><shortdesc>
     Gibt die Höhe des Anzeigeobjekts in Pixeln an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Höhe des Anzeigeobjekts in Pixeln an. Die Höhe wird auf Basis der Begrenzungen des Inhalts des Anzeigeobjekts berechnet. Wenn Sie die Eigenschaft <codeph>height</codeph> festsetzen, wird die Eigenschaft <codeph>scaleY</codeph> entsprechend angepasst, wie im folgenden Code gezeigt.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>Abgesehen von TextField- und Video-Objekten, hat ein Anzeigeobjekt ohne Inhalt (z. B. ein leeres Sprite) eine Höhe von 0, selbst wenn Sie versuchen, <codeph>height</codeph> auf einen anderen Wert zu setzen.</p>
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> Der folgende Code erstellt zwei TextField-Objekte und passt die <codeph>height</codeph>-Eigenschaft jeweils basierend auf der <codeph>textHeight</codeph>-Eigenschaft an. Das zweite Textfeld wird angeordnet, indem seine <codeph>y</codeph>-Eigenschaft festgelegt wird:
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:loaderInfo:get"><apiName>loaderInfo</apiName><shortdesc>
     Gibt ein LoaderInfo-Objekt mit Informationen zum Laden der Datei zurück, zu der dieses Anzeigeobjekt gehört.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Gibt ein LoaderInfo-Objekt mit Informationen zum Laden der Datei zurück, zu der dieses Anzeigeobjekt gehört. Die <codeph>loaderInfo</codeph>-Eigenschaft ist nur für das root-Anzeigeobjekt einer SWF-Datei oder für eine geladene Bitmap definiert (nicht jedoch für eine Bitmap, die mit ActionScript gezeichnet wird). Um das <codeph>loaderInfo</codeph>-Objekt zu finden, das der SWF-Datei zugeordnet ist, die das Anzeigeobjekt <codeph>myDisplayObject</codeph> enthält, verwenden Sie <codeph>myDisplayObject.root.loaderInfo</codeph>.
     
     <p>Eine große SWF-Datei kann ihren Download überwachen, indem sie <codeph>this.root.loaderInfo.addEventListener(Event.COMPLETE, func)</codeph> aufruft.</p>
     
     </apiDesc><example conref="examples\DisplayObject.loaderInfo.1.as"> Beim folgenden Code wird angenommen, dass <codeph>this</codeph> sich auf ein Anzeigeobjekt bezieht. Der Code gibt die URL der Stamm-SWF-Datei für das Anzeigeobjekt aus:
<codeblock>
 trace (this.loaderInfo.url);
 
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>LoaderInfo-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:mask:get"><apiName>mask</apiName><shortdesc>
     Das aufrufende Anzeigeobjekt wird durch das angegebene mask-Objekt maskiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Legt eine Maske für das Anzeigeobjekt fest.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Das aufrufende Anzeigeobjekt wird durch das angegebene <codeph>mask</codeph>-Objekt maskiert. Um sicherzustellen, dass das Maskieren bei skalierter Bühne funktioniert, muss sich das <codeph>mask</codeph>-Anzeigeobjekt in einem aktiven Bereich der Anzeigeliste befinden. Das <codeph>mask</codeph>-Objekt selbst wird nicht gezeichnet. Setzen Sie <codeph>mask</codeph> auf <codeph>null</codeph>, um die Maske zu entfernen.
     
     <p>Ein mask-Objekt kann nur skaliert werden, wenn es sich in der Anzeigeliste befindet. Ein mask-Sprite-Objekt kann nur gezogen werden (durch Aufrufen seiner <codeph>startDrag()</codeph>-Methode), wenn es sich in der Anzeigeliste befindet. Um die <codeph>startDrag()</codeph>-Methode eines mask-Sprite-Objekts basierend auf einem <codeph>mouseDown</codeph>-Ereignis aufzurufen, das vom Sprite ausgelöst wurde, setzen Sie die <codeph>buttonMode</codeph>-Eigenschaft des Sprites auf <codeph>true</codeph>.</p>
     
     <p><b>Hinweis:</b> Ein einzelnes <codeph>mask</codeph>-Objekt kann nicht zum Maskieren mehrerer aufrufender Anzeigeobjekte verwendet werden. Wird das <codeph>mask</codeph>-Objekt einem zweiten Anzeigeobjekt zugewiesen, wird es als Maske des ersten Objekts entfernt, dessen <codeph>mask</codeph>-Eigenschaft sich dadurch in <codeph>null</codeph> ändert.</p>  
     
     </apiDesc><example conref="examples\DisplayObject.mask.1.as"> Der folgende Code erstellt ein TextField-Objekt und ein Sprite-Objekt, das als Maske für das TextField-Objekt eingerichtet wird. Wenn Benutzer auf das Textfeld klicken, ruft die <codeph>drag()</codeph>-Ereignis-Listener-Funktion die <codeph>startDrag()</codeph>-Methode des mask-Sprite-Objekts auf:
<codeblock>
import flash.text.TextField;
import flash.display.Sprite;
import flash.events.MouseEvent;

var tf:TextField = new TextField();
tf.text = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " 
            + "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
tf.selectable = false;
tf.wordWrap = true;
tf.width = 150;
addChild(tf);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 40, 40);
addChild(square);

tf.mask = square;

tf.addEventListener(MouseEvent.MOUSE_DOWN, drag);
tf.addEventListener(MouseEvent.MOUSE_UP, noDrag);

function drag(event:MouseEvent):void {
    square.startDrag();
}
function noDrag(event:MouseEvent):void {
    square.stopDrag();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseX:get"><apiName>mouseX</apiName><shortdesc>
     Gibt die x-Koordinate der Mausposition in Pixeln an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die x-Koordinate der Mausposition in Pixeln an.
     
     <p><b>Hinweis:</b> Bei einem gedrehten Anzeigeobjekt spiegelt die zurückgegebene x-Koordinate das nicht gedrehte Objekt wider.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> Der folgende Code erstellt ein Sprite-Objekt und gibt die <codeph>mouseX</codeph>- und <codeph>mouseY</codeph>-Positionen an, wenn Benutzer auf das Sprite klicken:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseY:get"><apiName>mouseY</apiName><shortdesc>
     Gibt die y-Koordinate der Mausposition in Pixeln an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die y-Koordinate der Mausposition in Pixeln an.
     
     <p><b>Hinweis:</b> Bei einem gedrehten Anzeigeobjekt spiegelt die zurückgegebene y-Koordinate das nicht gedrehte Objekt wider.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> Der folgende Code erstellt ein Sprite-Objekt und gibt die <codeph>mouseX</codeph>- und <codeph>mouseY</codeph>-Positionen an, wenn Benutzer auf das Sprite klicken:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:name:get"><apiName>name</apiName><shortdesc>
     Gibt den Instanznamen des Anzeigeobjekts an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn Sie versuchen, diese Eigenschaft für ein Objekt einzustellen, das in der Zeitleiste der Flash-Authoring-Umgebung platziert wurde.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Der Name des Anzeigeobjekts.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Gibt den Instanznamen des Anzeigeobjekts an. Das Objekt kann in der Child-Liste seines übergeordneten Anzeigeobjekt-Containers identifiziert werden, indem die <codeph>getChildByName()</codeph>-Methode des Anzeigeobjekt-Containers aufgerufen wird.
     
     </apiDesc><example conref="examples\DisplayObject.name.1.as"> Der folgende Code erstellt zwei Sprite-Objekte und gibt die dazugehörige <codeph>name</codeph>-Eigenschaft aus, wenn Benutzer auf eines der Objekte klicken:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.name = "circle1";
addChild(circle1);
circle1.addEventListener(MouseEvent.CLICK, traceName);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x0000FF);
circle2.graphics.drawCircle(140, 40, 40);
circle2.name = "circle2";
addChild(circle2);
circle2.addEventListener(MouseEvent.CLICK, traceName);

function traceName(event:MouseEvent):void {
    trace(event.target.name);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:opaqueBackground:get"><apiName>opaqueBackground</apiName><shortdesc>
     Legt fest, ob das Anzeigeobjekt bei einer bestimmten Hintergrundfarbe undurchsichtig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Legt fest, ob das Anzeigeobjekt bei einer bestimmten Hintergrundfarbe undurchsichtig ist. Eine transparente Bitmap enthält Alphakanaldaten und wird durchsichtig gezeichnet. Eine undurchsichtige Bitmap hat keinen Alphakanal (und wird schneller gerendert als eine transparente Bitmap). Wenn die Bitmap durchsichtig ist, geben Sie an, welche Hintergrundfarbe sie verwenden soll.
     
     <p>Wird ein numerischer Wert angegeben, ist die Oberfläche undurchsichtig (nicht transparent) und besitzt die durch diese Nummer bezeichnete RGB-Hintergrundfarbe. Bei einem Wert von <codeph>null</codeph> (dem Standardwert) erhält das Anzeigeobjekt einen transparenten Hintergrund.</p>
     
     <p>Die <codeph>opaqueBackground</codeph>-Eigenschaft ist vorwiegend für den Einsatz mit der <codeph>cacheAsBitmap</codeph>-Eigenschaft gedacht, um die Wiedergabe zu optimieren. Bei Anzeigeobjekten, in denen die <codeph>cacheAsBitmap</codeph>-Eigenschaft auf „true“ gesetzt wurde, kann das Setzen von <codeph>opaqueBackground</codeph> die Wiedergabe-Performance verbessern.</p>
     
     <p>Beim Aufrufen einer <i>hitTestPoint()</i>-Methode, bei der der Parameter <codeph>shapeFlag</codeph> auf <codeph>true</codeph> gesetzt wurde, wird der Bereich für den undurchsichtigen Hintergrund <codeph>nicht</codeph> angepasst.</p>
     
     <p>Der Bereich für den undurchsichtigen Hintergrund reagiert nicht auf Mausereignisse.</p>
     
     </apiDesc><example conref="examples\DisplayObject.opaqueBackground.1.as"> Der folgende Code erstellt ein Shape-Objekt mit einem blauen Kreis und setzt seine <codeph>opaqueBackground</codeph>-Eigenschaft auf Rot (0xFF0000):
<codeblock>
import flash.display.Shape;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.opaqueBackground = 0xFF0000;
addChild(circle);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/hitTestPoint()"><linktext>hitTestPoint()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:parent:get"><apiName>parent</apiName><shortdesc>
     Gibt das DisplayObjectContainer-Objekt an, das dieses Anzeigeobjekt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObjectContainer</apiValueClassifier><apiException><apiDesc>Das übergeordnete Anzeigeobjekt ist Teil einer Sicherheits-Sandbox, auf die Sie keinen Zugriff haben. Sie können diese Situation vermeiden, indem Sie im übergeordneten Film die <codeph>Security.allowDomain()</codeph>-Methode aufrufen.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Gibt das DisplayObjectContainer-Objekt an, das dieses Anzeigeobjekt enthält. Mit der <codeph>parent</codeph>-Eigenschaft können Sie einen relativen Pfad zu Anzeigeobjekten angeben, die in der Anzeigelistenhierarchie über dem aktuellen Anzeigeobjekt liegen.
     
     <p>Sie können <codeph>parent</codeph> verwenden, um sich wie im folgenden Beispiel in der Anzeigeliste um mehrere Stufen nach oben zu bewegen:</p>
     
     <codeblock>
     this.parent.parent.alpha = 20;
     </codeblock>
     
     </apiDesc><example conref="examples\DisplayObject.parent.1.as"> Der folgende Code erstellt drei Sprite-Objekte und zeigt, wie die <codeph>parent</codeph>-Eigenschaft die Hierarchie der Anzeigeliste widerspiegelt:
<codeblock>

import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite2.parent.name); // sprite1
trace(sprite3.parent.name); // sprite2
trace(sprite3.parent.parent.name); // sprite1
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:root:get"><apiName>root</apiName><shortdesc>
     Bei einem Anzeigeobjekt in einer geladenen SWF-Datei ist die root-Eigenschaft das oberste Anzeigeobjekt in dem Teil der Baumstruktur der Anzeigeliste, der diese SWF-Datei repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Gibt das Stamm-Anzeigeobjekt für dieses Objekt zurück.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Bei einem Anzeigeobjekt in einer geladenen SWF-Datei ist die Eigenschaft <codeph>root</codeph> das oberste Anzeigeobjekt in dem Teil der Baumstruktur der Anzeigeliste, der diese SWF-Datei repräsentiert. Bei einem Bitmap-Objekt, das eine geladene Bilddatei repräsentiert, steht die <codeph>root</codeph>-Eigenschaft für das Bitmap-Objekt selbst. Bei der Instanz der Hauptklasse der ersten geladenen SWF-Datei steht die <codeph>root</codeph>-Eigenschaft für das Anzeigeobjekt selbst. Die <codeph>root</codeph>-Eigenschaft des Stage-Objekts steht für das Stage-Objekt selbst. Die <codeph>root</codeph>-Eigenschaft ist für jedes Anzeigeobjekt, das nicht in die Anzeigeliste aufgenommen wurde, auf <codeph>null</codeph> gesetzt. Eine Ausnahme ist, wenn es in einen Anzeigeobjekt-Container eingefügt wurde, der sich zwar nicht in der Anzeigeliste befindet, aber dem obersten Anzeigeobjekt einer geladenen SWF-Datei untergeordnet ist.
     
     <p>Angenommen, Sie erstellen ein neues Sprite-Objekt, indem Sie die Konstruktormethode <codeph>Sprite()</codeph> aufrufen. Seine <codeph>root</codeph>-Eigenschaft hat dann den Wert <codeph>null</codeph>, bis Sie das Objekt in die Anzeigeliste einfügen (oder in einen Objekt-Container, der sich zwar nicht in der Anzeigeliste befindet, aber dem obersten Anzeigeobjekt einer geladenen SWF-Datei untergeordnet ist).</p>
     
     <p>Bei einer geladenen SWF-Datei ist die <codeph>root</codeph>-Eigenschaft des obersten Anzeigeobjekts in der SWF-Datei auf sich selbst gesetzt, auch wenn sich das Loader-Objekt zum Laden der Datei nicht in der Anzeigeliste befindet. Die <codeph>root</codeph>-Eigenschaft des Loader-Objekts ist nicht gesetzt, bis es als untergeordnetes Objekt eines Anzeigeobjekts hinzugefügt wird, dessen <codeph>root</codeph>-Eigenschaft gesetzt ist.</p>
     
     </apiDesc><example conref="examples\DisplayObject.root.1.as"> Der folgende Code zeigt den Unterschied zwischen der <codeph>root</codeph>-Eigenschaft für das Stage-Objekt, für ein Anzeigeobjekt (Loader-Objekt), das nicht geladen ist (sowohl bevor als auch nachdem es der Anzeigeliste hinzugefügt wurde), und für ein geladenes Objekt (ein geladenes Bitmap-Objekt):
<codeblock>
import flash.display.Loader;
import flash.net.URLRequest;
import flash.events.Event;

trace(stage.root); // [object Stage]

var ldr:Loader = new Loader();
trace (ldr.root); // null

addChild(ldr); 
trace (ldr.root); // [object ...]

var urlReq:URLRequest = new URLRequest("example.jpg");
ldr.load(urlReq);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void {
    trace(ldr.content.root); // [object Bitmap]
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotation:get"><apiName>rotation</apiName><shortdesc>
     Gibt die Drehung der DisplayObject-Instanz ausgehend von der ursprünglichen Ausrichtung in Grad an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Drehung der DisplayObject-Instanz ausgehend von der ursprünglichen Ausrichtung in Grad an. Werte zwischen 0 und 180 geben eine Rechtsdrehung, Werte zwischen 0 und -180 eine Linksdrehung an. Werte außerhalb dieses Bereichs werden zu 360 addiert bzw. von 360 subtrahiert, damit sich ein Wert innerhalb des Bereichs ergibt. Die Anweisung <codeph>my_video.rotation = 450</codeph> ist z. B. mit <codeph> my_video.rotation = 90</codeph> identisch.
     
     </apiDesc><example conref="examples\DisplayObject.rotation.1.as"> Der folgende Code erstellt ein Sprite-Objekt und dreht das Objekt, wenn Benutzer darauf klicken:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(-50, -50, 100, 100);
square.x = 150;
square.y = 150;
addChild(square);

square.addEventListener(MouseEvent.CLICK, rotate);

function rotate(event:MouseEvent):void {
        square.rotation += 15;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationX:get"><apiName>rotationX</apiName><shortdesc>
     Gibt die Drehung der x-Achse der DisplayObject-Instanz in Grad an, ausgehend von ihrer ursprünglichen Ausrichtung relativ zum übergeordneten 3D-Container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die x-Achsendrehung der DisplayObject-Instanz in Grad an, und zwar bezogen auf die ursprüngliche Ausrichtung zum übergeordneten 3D-Container. Werte zwischen 0 und 180 geben eine Rechtsdrehung, Werte zwischen 0 und -180 eine Linksdrehung an. Werte außerhalb dieses Bereichs werden zu 360 addiert bzw. von 360 subtrahiert, damit sich ein Wert innerhalb des Bereichs ergibt. 
     
     </apiDesc><example conref="examples\RotationExample1.as"> In diesem Beispiel drehen sich zwei Ellipsen unter Verwendung ihrer <codeph>rotationX</codeph>- und <codeph>rotationY</codeph>-Eigenschaft. Der Registrierungspunkt der ersten Ellipse ist auf ihre Mitte gesetzt. Sie dreht sich um sich selbst. Die zweite Ellipse dreht sich um einen externen Punkt. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationY:get"><apiName>rotationY</apiName><shortdesc>
     Gibt die Drehung der y-Achse der DisplayObject-Instanz in Grad an, ausgehend von ihrer ursprünglichen Ausrichtung relativ zum übergeordneten 3D-Container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die y-Achsendrehung der DisplayObject-Instanz in Grad ab der ursprünglichen Ausrichtung relativ zum übergeordneten 3D-Container an. Werte zwischen 0 und 180 geben eine Rechtsdrehung, Werte zwischen 0 und -180 eine Linksdrehung an. Werte außerhalb dieses Bereichs werden zu 360 addiert bzw. von 360 subtrahiert, damit sich ein Wert innerhalb des Bereichs ergibt. 
     
     
     </apiDesc><example conref="examples\RotationExample1.as"> In diesem Beispiel drehen sich zwei Ellipsen unter Verwendung ihrer <codeph>rotationX</codeph>- und <codeph>rotationY</codeph>-Eigenschaft. Der Registrierungspunkt der ersten Ellipse ist auf ihre Mitte gesetzt. Sie dreht sich um sich selbst. Die zweite Ellipse dreht sich um einen externen Punkt. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationZ:get"><apiName>rotationZ</apiName><shortdesc>
     Gibt die Drehung der z-Achse der DisplayObject-Instanz in Grad an, ausgehend von ihrer ursprünglichen Ausrichtung relativ zum übergeordneten 3D-Container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die z-Achsendrehung der DisplayObject-Instanz in Grad an, und zwar bezogen auf die ursprüngliche Ausrichtung zum übergeordneten 3D-Container. Werte zwischen 0 und 180 geben eine Rechtsdrehung, Werte zwischen 0 und -180 eine Linksdrehung an. Werte außerhalb dieses Bereichs werden zu 360 addiert bzw. von 360 subtrahiert, damit sich ein Wert innerhalb des Bereichs ergibt. 
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scale9Grid:get"><apiName>scale9Grid</apiName><shortdesc>
     Das aktuell verwendete Skalierungsraster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following creates a movie clip that contains a 20-pixel line (which forms a border)
     and a gradient fill. The movie clip scales based on the mouse position, and because of the
     <code>scale9Grid</code> set for the movie clip, the thickness of the 20-pixel line does not
     vary when the clip scales (although the gradient in the movie clip <em>does</em> scale):
     
     <listing version="2.0">
     import flash.geom.Rectangle;
     import flash.geom.Matrix;
     
     this.createEmptyMovieClip("my_mc", this.getNextHighestDepth());
     
     var grid:Rectangle = new Rectangle(20, 20, 260, 260);
     my_mc.scale9Grid = grid ;
     
     my_mc._x = 50;
     my_mc._y = 50;
     
     function onMouseMove()
     {
      my_mc._width  = _xmouse;
      my_mc._height = _ymouse;
     }
     
     my_mc.lineStyle(20, 0xff3333, 100);
     var gradient_matrix:Matrix = new Matrix();
     gradient_matrix.createGradientBox(15, 15, Math.PI, 10, 10);
     my_mc.beginGradientFill("radial", [0xffff00, 0x0000ff],
              [100, 100], [0, 0xFF], gradient_matrix,
              "reflect", "RGB", 0.9);
     my_mc.moveTo(0, 0);
     my_mc.lineTo(0, 300);
     my_mc.lineTo(300, 300);
     my_mc.lineTo(300, 0);
     my_mc.lineTo(0, 0);
     my_mc.endFill();
     </listing>
     
     </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>Wenn Sie an die Methode ein unzulässiges Argument übergeben.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Das aktuell verwendete Skalierungsraster. Ist diese Eigenschaft auf <codeph>null</codeph> gesetzt, wird bei einer Skalierungstransformation das gesamte Anzeigeobjekt normal skaliert.
     
     <p>Wenn Sie dagegen die <codeph>scale9Grid</codeph>-Eigenschaft definieren, wird das Anzeigeobjekt basierend auf dem <codeph>scale9Grid</codeph>-Rechteck in ein Raster mit 9 Feldern eingeteilt, welches den inneren Bereich des Rasters definiert. Dieses Raster besitzt acht weitere Felder: </p>
     
     <ul>
       <li>Das Feld links oben, außerhalb des Rechtecks.</li>
       <li>Das Feld oberhalb des Rechtecks. </li>
       <li>Das Feld rechts oben, außerhalb des Rechtecks.</li>
       <li>Das Feld links vom Rechteck.</li>
       <li>Das Feld rechts vom Rechteck.</li>
       <li>Das Feld links unten, außerhalb des Rechtecks.</li>
       <li>Das Feld unterhalb des Rechtecks.</li>
       <li>Das Feld rechts unten, außerhalb des Rechtecks.</li>
     </ul>
     
     <p>Die acht Felder außerhalb des Rechtecks können Sie sich als einen Bilderrahmen denken, auf den beim Skalieren spezielle Regeln angewendet werden.</p>
     
     <p>Wenn die <codeph>scale9Grid</codeph>-Eigenschaft gesetzt ist und ein Anzeigeobjekt skaliert wird, werden auch alle Texte und Farbverläufe normal skaliert. Für andere Objekttypen gelten allerdings die folgenden Regeln:</p>
     
     <ul>
       <li>Der Inhalt im inneren Feld wird normal skaliert. </li>
       <li>Der Inhalt in den Eckfeldern wird nicht skaliert. </li>
       <li>Der Inhalt im oberen und unteren Feld wird nur horizontal skaliert. Der Inhalt im linken und rechten Feld wird nur vertikal skaliert.</li>
      <li>Alle Füllungen (einschließlich Bitmaps, Videos und Farbverläufe) werden dabei gedehnt, um in ihre jeweiligen Formen zu passen.</li>
     </ul>
     
     <p>Wird das Anzeigeobjekt gedreht, zeigen alle nachfolgende Skalierungen normales Verhalten (und die <codeph>scale9Grid</codeph>-Eigenschaft wird ignoriert).</p>
     
     <p>Betrachten Sie beispielsweise das folgende Anzeigeobjekt und das Rechteck, das als <codeph>scale9Grid</codeph>-Eigenschaft des Anzeigeobjekts angewendet wird:</p>
     
     <adobetable>
     
       
     
     <tgroup cols="2"><tbody><row>
      <entry align="center"><adobeimage alt="Anzeigeobjekt Bild" href="../../images/scale9Grid-a.jpg"/>
     <p>Das Anzeigeobjekt.</p></entry>
     
      <entry align="center"><adobeimage alt="Anzeigeobjekt scale9-Region" href="../../images/scale9Grid-b.jpg"/>
      <p>Im roten Rechteck wird das <codeph>scale9Grid</codeph>-Raster angezeigt.</p></entry>
       </row></tbody></tgroup></adobetable>
     
     <p>Wenn das Anzeigeobjekt skaliert oder gedehnt wird, werden die Objekte innerhalb des Rechtecks normal skaliert, aber die Objekte außerhalb des Rechtecks werden gemäß den Regeln für ein <codeph>scale9Grid</codeph>-Raster skaliert:</p>
     
     <adobetable>
      
     
      
     
      
     
      
     
     <tgroup cols="2"><tbody><row>
      <entry>Auf 75 % skaliert:</entry>
      <entry><adobeimage alt="Anzeigeobjekt bei 75 %" href="../../images/scale9Grid-c.jpg"/></entry>
      </row><row>
      <entry>Auf 50 % skaliert:</entry>
      <entry><adobeimage alt="Anzeigeobjekt bei 50 %" href="../../images/scale9Grid-d.jpg"/></entry>
      </row><row>
      <entry>Auf 25 % skaliert:</entry>
      <entry><adobeimage alt="Anzeigeobjekt bei 25 %" href="../../images/scale9Grid-e.jpg"/></entry>
      </row><row>
      <entry>Horizontal auf 150 % gedehnt: </entry>
      <entry><adobeimage alt="Anzeige auf 150 % gedehnt" href="../../images/scale9Grid-f.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     
     <p>Normalerweise wird die <codeph>scale9Grid</codeph>-Eigenschaft angewendet, um ein Anzeigeobjekt als Komponente einzurichten, deren Randbereiche bei einer Skalierung der Komponente weiterhin in gleicher Breite angezeigt werden sollen.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scale9Grid.1.as"> Der folgende Code erstellt ein Shape-Objekt, für das in seiner <codeph>graphics</codeph>-Eigenschaft ein Rechteck gezeichnet ist. Das Rechteck verfügt über eine Linie mit einer Stärke von 20 Pixel, die als Rahmen dient und mit einem Farbverlauf gefüllt ist. Das timer-Ereignis ruft die <codeph>scale()</codeph>-Funktion auf, die das Shape-Objekt skaliert, indem sie die Eigenschaften <codeph>scaleX</codeph> und <codeph>scaleY</codeph> anpasst. Das <codeph>scale9Grid</codeph>-Raster, das auf das Shape-Objekt angewendet wird, verhindert die Skalierung der Rahmenlinie des Rechtecks. Es wird nur die Farbverlaufsfüllung skaliert:
<codeblock>

import flash.display.Shape;
import flash.display.GradientType;
import flash.display.SpreadMethod;
import flash.display.InterpolationMethod;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var square:Shape = new Shape();
square.graphics.lineStyle(20, 0xFFCC00);
var gradientMatrix:Matrix = new Matrix();
gradientMatrix.createGradientBox(15, 15, Math.PI, 10, 10);
square.graphics.beginGradientFill(GradientType.RADIAL, 
            [0xffff00, 0x0000ff], 
            [100, 100], 
            [0, 0xFF], 
            gradientMatrix, 
            SpreadMethod.REFLECT, 
            InterpolationMethod.RGB, 
            0.9);
square.graphics.drawRect(0, 0, 100, 100);

var grid:Rectangle = new Rectangle(20, 20, 60, 60);
square.scale9Grid = grid ;

addChild(square);

var tim:Timer = new Timer(100);
tim.start();
tim.addEventListener(TimerEvent.TIMER, scale);

var scaleFactor:Number = 1.01;

function scale(event:TimerEvent):void {
    square.scaleX *= scaleFactor;
    square.scaleY *= scaleFactor;
    
    if (square.scaleX > 2.0) {
        scaleFactor = 0.99;
    }
    if (square.scaleX &lt; 1.0) {
        scaleFactor = 1.01;
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scaleX:get"><apiName>scaleX</apiName><shortdesc>
     Gibt die horizontale Skalierung (percentage) des Objekts ausgehend vom Registrierungspunkt an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die horizontale Skalierung (percentage) des Objekts ausgehend vom Registrierungspunkt an. Der Standardregistrierungspunkt liegt bei (0,0). 1,0 entspricht 100 % Skalierung.
     
     <p>Die Skalierung des lokalen Koordinatensystems ändert die Werte der <codeph>x</codeph>- und <codeph>y</codeph>-Eigenschaften, die in ganzen Pixeln angegeben werden. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> Der folgende Code erstellt ein Sprite-Objekt, für das in seiner <codeph>graphics</codeph>-Eigenschaft ein Rechteck gezeichnet ist. Wenn Benutzer auf das Sprite klicken, wird es auf 10 % skaliert:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleY:get"><apiName>scaleY</apiName><shortdesc>
     Gibt die vertikale Skalierung (percentage) eines Objekts ausgehend vom Registrierungspunkt an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die vertikale Skalierung (percentage) eines Objekts ausgehend vom Registrierungspunkt an. Der Standardregistrierungspunkt liegt bei (0,0). 1,0 entspricht 100 % Skalierung.
     
     <p>Die Skalierung des lokalen Koordinatensystems ändert die Werte der <codeph>x</codeph>- und <codeph>y</codeph>-Eigenschaften, die in ganzen Pixeln angegeben werden. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> Der folgende Code erstellt ein Sprite-Objekt, für das in seiner <codeph>graphics</codeph>-Eigenschaft ein Rechteck gezeichnet ist. Wenn Benutzer auf das Sprite klicken, wird es auf 10 % skaliert:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleZ:get"><apiName>scaleZ</apiName><shortdesc>
     Gibt die Tiefenskalierung (Prozentsatz) eines Objekts ausgehend vom Registrierungspunkt an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Tiefenskalierung (Prozentsatz) eines Objekts ausgehend vom Registrierungspunkt an. Der Standardregistrierungspunkt liegt bei (0,0). 1,0 entspricht 100 % Skalierung.
     
     <p>Die Skalierung des lokalen Koordinatensystems ändert die Werte der <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Eigenschaften, die in ganzen Pixeln angegeben werden. </p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/z"><linktext>z</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scrollRect:get"><apiName>scrollRect</apiName><shortdesc>
     Die Begrenzungen des Bildlaufrechtecks für das Anzeigeobjekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     Die Begrenzungen des Bildlaufrechtecks für das Anzeigeobjekt. Das Anzeigeobjekt wird auf die vom Rechteck definierte Größe zugeschnitten. Innerhalb dieses Rechtecks wird ein Bildlauf durchgeführt, wenn Sie die Eigenschaften <codeph>x</codeph> und <codeph>y</codeph> des <codeph>scrollRect</codeph>-Objekts ändern.
     
     <p>Die Eigenschaften des <codeph>scrollRect</codeph>-Rechtecks verwenden den Koordinatenraum des Anzeigeobjekts und werden ebenso wie das Gesamtanzeigeobjekt skaliert. Die Eckbegrenzungen des zugeschnittenen Fensters des Anzeigeobjekts mit Bildlauffunktion liegen auf dem Ursprung des Anzeigeobjekts (0,0) sowie auf dem durch die Rechteckbreite und -höhe definierten Punkt. Diese Punkte sind nicht um den Ursprung zentriert, sondern verwenden den Ursprung, um die linke obere Ecke zu definieren. Ein Anzeigeobjekt mit Bildlauffunktion wird immer pixelweise verschoben. </p>
     
     <p>Sie können den Objektausschnitt nach links und rechts verschieben, indem Sie die <codeph>x</codeph>-Eigenschaft des <codeph>scrollRect</codeph>-Rechteckobjekts setzen. Sie können den Objektausschnitt nach oben und unten verschieben, indem Sie die <codeph>y</codeph>-Eigenschaft des <codeph>scrollRect</codeph>-Rechteckobjekts setzen. Wenn das Anzeigeobjekt um 90° gedreht wird und Sie es nach links und rechts verschieben, wird es nach oben und unten verschoben.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scrollRect.1.as"> Das folgende Beispiel zeigt, wie die <codeph>scrollRect</codeph>-Eigenschaft den Bildlaufbereich für das Anzeigeobjekt <codeph>circle</codeph> definiert. Wenn Sie auf das <codeph>circle</codeph>-Objekt klicken, passt die <codeph>clicked()</codeph>-Ereignisprozedurmethode die <codeph>y</codeph>-Eigenschaft der <codeph>scrollRect</codeph>-Eigenschaft des <codeph>circle</codeph>-Objekts an und bewirkt, dass für das Objekt ein Bildlauf nach unten ausgeführt wird:
<codeblock>

import flash.display.Sprite;
import flash.geom.Rectangle;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(200, 200, 200);
circle.scrollRect = new Rectangle(0, 0, 200, 200);
addChild(circle);

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    var rect:Rectangle = event.target.scrollRect;
    rect.y -= 5;
    event.target.scrollRect = rect;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:stage:get"><apiName>stage</apiName><shortdesc>
     Die Bühne des Anzeigeobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
     Die Bühne des Anzeigeobjekts. Eine Flash-Anwendung besitzt nur ein Stage-Objekt. Sie können z. B. mehrere Anzeigeobjekte erstellen und in die Anzeigeliste laden. Die <codeph>stage</codeph>-Eigenschaft der verschiedenen Anzeigeobjekte verweist dann auf dasselbe Stage-Objekt (auch wenn das Anzeigeobjekt zu einer geladenen SWF-Datei gehört).
     
     <p>Wird ein Anzeigeobjekt nicht in die Anzeigeliste aufgenommen, ist seine <codeph>stage</codeph>-Eigenschaft auf <codeph>null</codeph> gesetzt.</p>
     
     </apiDesc><example conref="examples\DisplayObject.stage.1.as"> Im folgenden Code werden zwei TextField-Objekte erstellt, und es wird die <codeph>width</codeph>-Eigenschaft des Stage-Objekts verwendet, um die Textfelder zu positionieren:
<codeblock>

import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.x = 10;
addChild(tf1);
tf1.width = tf1.stage.stageWidth / 2 - 10;

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.x = tf1.x + tf1.width + 5;
addChild(tf2);
tf2.width = tf2.stage.stageWidth / 2 - 10;

trace(stage.stageWidth);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:transform:get"><apiName>transform</apiName><shortdesc>
    Ein Objekt mit Eigenschaften, die zur Matrix, Farbtransformation und Pixelbegrenzung eines Anzeigeobjekts gehören.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Transform</apiValueClassifier></apiValueDef><apiDesc>
    Ein Objekt mit Eigenschaften, die zur Matrix, Farbtransformation und Pixelbegrenzung eines Anzeigeobjekts gehören. Die spezifischen Eigenschaften – „matrix“, „colorTransform“ und drei schreibgeschützte Eigenschaften (<codeph>concatenatedMatrix</codeph>, <codeph>concatenatedColorTransform</codeph> und <codeph>pixelBounds</codeph>) – werden im Eintrag für die Transform-Klasse erläutert.
    
    <p>Jede Eigenschaft des transform-Objekts ist selbst wiederum ein Objekt. Dies ist wichtig, da für matrix- und colorTransform-Objekte neue Werte nur gesetzt werden können, indem ein neues Objekt erstellt und in die transform.matrix- oder transform.colorTransform-Eigenschaft kopiert wird.</p>
    
    <p>Um etwa den <codeph>tx</codeph>-Wert einer Anzeigeobjekt-Matrix zu erhöhen, müssen Sie eine Kopie des gesamten Matrixobjekts anfertigen und anschließend das neue Objekt in die matrix-Eigenschaft des transform-Objekts kopieren:</p>
    
    <pre><codeph>
    var myMatrix:Matrix = myDisplayObject.transform.matrix;  
    myMatrix.tx += 10; 
    myDisplayObject.transform.matrix = myMatrix;  
    </codeph></pre>
    
    <p>Sie können die <codeph>tx</codeph>-Eigenschaft nicht direkt setzen. Der folgende Code hat keine Auswirkung auf <codeph>myDisplayObject</codeph>: </p>
    
    <pre><codeph>
    myDisplayObject.transform.matrix.tx += 10;
    </codeph></pre>
    
    <p>Eine andere Möglichkeit besteht darin, das gesamte transform-Objekt zu kopieren und es der transform-Eigenschaft eines anderen Anzeigeobjekts zuzuweisen. Der nachfolgende Code kopiert z. B. das gesamte transform-Objekt von <codeph>myOldDisplayObj</codeph> nach <codeph>myNewDisplayObj</codeph>:</p>
    <codeph>myNewDisplayObj.transform = myOldDisplayObj.transform;</codeph>
    <p>Das resultierende Anzeigeobjekt, <codeph>myNewDisplayObj</codeph>, besitzt jetzt für seine Matrix, Farbtransformation und Pixelbegrenzungen dieselben Werte wie das alte Anzeigeobjekt, <codeph>myOldDisplayObj</codeph>.</p>
     
    </apiDesc><example conref="examples\DisplayObject.transform.1.as"> Der folgende Code richtet ein <codeph>square</codeph>-Sprite-Objekt ein. Wenn Benutzer auf das Sprite klicken, passt die <codeph>transformer()</codeph>-Methode die Eigenschaften <codeph>colorTransform</codeph> and <codeph>matrix</codeph> der <codeph>transform</codeph>-Eigenschaft des Sprites an:
<codeblock>

import flash.display.Sprite;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Transform;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.lineStyle(20, 0xFF2200);
square.graphics.beginFill(0x0000DD);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

var resultColorTransform:ColorTransform = new ColorTransform();
resultColorTransform.alphaMultiplier = 0.5;
resultColorTransform.redOffset = 155;
resultColorTransform.greenMultiplier = 0.5;

var skewMatrix:Matrix = new Matrix(1, 1, 0, 1);

square.addEventListener(MouseEvent.CLICK, transformer);

function transformer(event:MouseEvent):void {
    var transformation:Transform = square.transform;
    var tempMatrix:Matrix = square.transform.matrix;
    tempMatrix.concat(skewMatrix);
    square.transform.colorTransform = resultColorTransform;
    
    square.transform.matrix = tempMatrix;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Transform"><linktext>Transform-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:visible:get"><apiName>visible</apiName><shortdesc>
     Gibt an, ob das Anzeigeobjekt sichtbar ist oder nicht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob das Anzeigeobjekt sichtbar ist oder nicht. Nicht sichtbare Anzeigeobjekte sind deaktiviert. Wenn beispielsweise für eine InteractiveObject-Instanz <codeph>visible=false</codeph> gesetzt ist, können Benutzer nicht auf diese Instanz klicken.
     
     </apiDesc><example conref="examples\DisplayObject.visible.1.as"> Der folgende Code verwendet ein Timer-Objekt, um eine Funktion aufzurufen, die die <codeph>visible</codeph>-Eigenschaft eines Anzeigeobjekts regelmäßig ändert, was zu einem Blinkeffekt führt:
<codeblock>

import flash.text.TextField;
import flash.utils.Timer;
import flash.events.TimerEvent;

var tf:TextField = new TextField();
tf.text = "Hello.";
addChild(tf);

var tim:Timer = new Timer(250);
tim.start();
tim.addEventListener(TimerEvent.TIMER, blinker);

function blinker(event:TimerEvent):void {
    tf.visible = !tf.visible;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:width:get"><apiName>width</apiName><shortdesc>
     Gibt die Breite des Anzeigeobjekts in Pixeln an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Breite des Anzeigeobjekts in Pixeln an. Die Breite wird auf Basis der Begrenzungen des Inhalts des Anzeigeobjekts berechnet. Wenn Sie die Eigenschaft <codeph>width</codeph> festsetzen, wird die Eigenschaft <codeph>scaleX</codeph> entsprechend angepasst, wie im folgenden Code gezeigt.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>Abgesehen von TextField- und Video-Objekten, hat ein Anzeigeobjekt ohne Inhalt (z. B. ein leeres Sprite) eine Breite von 0, selbst wenn Sie versuchen, <codeph>width</codeph> auf einen anderen Wert zu setzen.</p>
     
     </apiDesc><example conref="examples\DisplayObject.width.1.as"> Der folgende Code richtet ein <codeph>square</codeph>-Sprite-Objekt ein. Wenn Benutzer auf das Sprite klicken, erhöht die <codeph>widen()</codeph>-Methode die <codeph>width</codeph>-Eigenschaft des Sprites:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, widen);

function widen(event:MouseEvent):void {
    square.width += 10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:x:get"><apiName>x</apiName><shortdesc>
     Gibt die x-Koordinate der DisplayObject-Instanz relativ zu den lokalen Koordinaten des übergeordneten DisplayObjectContainer-Objekts an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die <i>x</i>-Koordinate der DisplayObject-Instanz relativ zu den lokalen Koordinaten des übergeordneten DisplayObjectContainer-Objekts an. Befindet sich das Objekt innerhalb eines transformierten DisplayObjectContainer-Objekts, liegt es im lokalen Koordinatensystem des umgebenden DisplayObjectContainer-Objekts. Wenn also ein DisplayObjectContainer-Objekt um 90° nach links gedreht ist, erben die untergeordneten Objekte des DisplayObjectContainer-Objekts ein Koordinatensystem, das um 90° nach links gedreht ist. Die Koordinaten des Objekts beziehen sich auf die Position des Registrierungspunkts.
     
     </apiDesc><example conref="examples\DisplayObject.x.1.as"> Der folgende Code erstellt ein <codeph>circle</codeph>-Sprite-Objekt. Ein Timer-Objekt wird verwendet, um die <codeph>x</codeph>-Eigenschaft des Sprites alle 50 Millisekunden zu ändern:
<codeblock>

import flash.display.Sprite;
import flash.utils.Timer;
import flash.events.TimerEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(100, 100, 100);
addChild(circle);

var tim:Timer = new Timer(50);
tim.start();
tim.addEventListener(TimerEvent.TIMER, bounce);

var xInc:Number = 2;

function bounce(event:TimerEvent):void {
    circle.x += xInc;
    if (circle.x > circle.width) {
        xInc = -2;
    }
    if (circle.x &lt; 0) {
        xInc = 2;
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:y:get"><apiName>y</apiName><shortdesc>
     Gibt die y-Koordinate der DisplayObject-Instanz relativ zu den lokalen Koordinaten des übergeordneten DisplayObjectContainer-Objekts an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die <i>y</i>-Koordinate der DisplayObject-Instanz relativ zu den lokalen Koordinaten des übergeordneten DisplayObjectContainer-Objekts an. Befindet sich das Objekt innerhalb eines transformierten DisplayObjectContainer-Objekts, liegt es im lokalen Koordinatensystem des umgebenden DisplayObjectContainer-Objekts. Wenn also ein DisplayObjectContainer-Objekt um 90° nach links gedreht ist, erben die untergeordneten Objekte des DisplayObjectContainer-Objekts ein Koordinatensystem, das um 90° nach links gedreht ist. Die Koordinaten des Objekts beziehen sich auf die Position des Registrierungspunkts.
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> Der folgende Code erstellt zwei TextField-Objekte und passt die <codeph>height</codeph>-Eigenschaft jeweils basierend auf der <codeph>textHeight</codeph>-Eigenschaft an. Das zweite Textfeld wird angeordnet, indem seine <codeph>y</codeph>-Eigenschaft festgelegt wird:
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:z:get"><apiName>z</apiName><shortdesc>
     Gibt die z-Koordinatenposition an der z-Achse der DisplayObject-Instanz relativ zum übergeordneten 3D-Container an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die z-Koordinate entlang der z-Achse der DisplayObject-Instanz relativ zum übergeordneten 3D-Container an. Die z-Eigenschaft wird für 3D-Koordinaten verwendet, nicht für Bildschirm- oder Pixelkoordinaten. 
     <p>Wird die <codeph>z</codeph>-Eigenschaft eines Anzeigeobjekts auf einen anderen Wert als den Standardwert <codeph>0</codeph> gesetzt, so wird automatisch das entsprechende Matrix3D-Objekt erstellt. Dient der Anpassung der Position und Ausrichtung eines Anzeigeobjekts in den drei Dimensionen. Beim Arbeiten mit der z-Achse ändert sich das bestehende Verhalten der x- und y-Eigenschaften von Bildschirm- oder Pixelkoordinaten auf Positionen relativ zum übergeordneten 3D-Container.</p>
     <p>Ein untergeordnetes Element von <codeph>_root</codeph> an Position x = 100, y = 100, z = 200 wird nicht an Pixelposition (100,100) gezeichnet. Stattdessen wird die Position des untergeordneten Elements durch die 3D-Projektionsberechnung bestimmt. Folgende Berechnung wird ausgeführt:</p>
     <p><codeph> (x~~cameraFocalLength/cameraRelativeZPosition, y~~cameraFocalLength/cameraRelativeZPosition)</codeph></p>
     
     
     </apiDesc><example conref="examples\ZAxisExample1.as"> In diesem Beispiel werden zwei Ellipsen gezeichnet, die sich entlang der <codeph>z</codeph>-Achse hin und zurück (abwärts und aufwärts) in Richtung Fluchtpunkt bewegen. Eine Ellipse ist so eingestellt, dass sie sich schneller bewegt. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.geom.*;

    public class ZAxisExample1 extends MovieClip {
        private var ellipse1Back:int = 1;
        private var ellipse2Back:int = 1;
        private var depth:int = 1000;
        
        public function ZAxisExample1():void {
            
            var ellipse1 = drawEllipse((this.stage.stageWidth / 2) - 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 10);
            var ellipse2 = drawEllipse((this.stage.stageWidth / 2) + 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 300);

            this.addChild(ellipse1);
            this.addChild(ellipse2);
            
            ellipse1.addEventListener(Event.ENTER_FRAME, ellipse1FrameHandler);
            ellipse2.addEventListener(Event.ENTER_FRAME, ellipse2FrameHandler);
        }

        private function drawEllipse(x:Number, y:Number, w:Number, h:Number, z:Number):Shape {
            var s:Shape = new Shape();                            
            s.z = z;
            s.graphics.beginFill(0xFF0000);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(x, y, w, h);
            s.graphics.endFill();
            return s;
        }

        private function ellipse1FrameHandler(e:Event):void {
            ellipse1Back = setDepth(e, ellipse1Back);
            e.currentTarget.z += ellipse1Back * 10;
        }

        private function ellipse2FrameHandler(e:Event):void {
            ellipse2Back = setDepth(e, ellipse2Back);
            e.currentTarget.z += ellipse2Back * 20;
        }

        private function setDepth(e:Event, d:int):int {
            if(e.currentTarget.z > depth) {
                e.currentTarget.z = depth; 
                d = -1;
            }else if (e.currentTarget.z &lt;  0) {
                e.currentTarget.z = 0;
                d = 1;
            }
            return d;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>transform</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:blendShader:set"><apiName>blendShader</apiName><shortdesc>
     Legt einen Shader fest, der für das Mischen von Vordergrund und Hintergrund verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.display:Shader</apiValueClassifier><apiException><apiDesc>Wenn der Shaderausgabetyp mit diesem Vorgang nicht kompatibel ist (der Shader muss eine <codeph>pixel4</codeph>-Ausgabe festlegen).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Shader weniger als zwei Bildeingaben festlegt oder die ersten beiden Eingaben nicht <codeph>image4</codeph>-Eingaben sind.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Shader eine Bildeingabe festlegt, die nicht vorhanden ist.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn eine ByteArray- oder Vector.&lt;Number>-Instanz als Eingabe verwendet wird und die <codeph>width</codeph>- und <codeph>height</codeph>-Eigenschaft für ShaderInput nicht festgelegt ist oder die festgelegten Werte nicht mit der Datenmenge im Eingabeobjekt übereinstimmen. Weitere Informationen finden Sie im Abschnitt zur <codeph>ShaderInput.input</codeph>-Eigenschaft.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Legt einen Shader fest, der für das Mischen von Vordergrund und Hintergrund verwendet wird. Ist die <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.SHADER</codeph> gesetzt, wird der festgelegte Shader für die Erstellung der Mischmodusausgabe des Anzeigeobjekts verwendet.
     
     <p>Wird die <codeph>blendShader</codeph>-Eigenschaft eines Anzeigeobjekts auf eine Shader-Instanz gesetzt, so wird die <codeph>blendMode</codeph>-Eigenschaft des Anzeigeobjekts automatisch auf <codeph>BlendMode.SHADER</codeph> gesetzt. Wenn die <codeph>blendShader</codeph>-Eigenschaft gesetzt wird (wodurch die <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.SHADER</codeph> gesetzt wird), so wird der Wert der <codeph>blendMode</codeph>-Eigenschaft geändert. Der Mischmodus kann einfach durch Setzen der <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.SHADER</codeph> zur Verwendung des Misch-Shaders neu gesetzt werden. Die <codeph>blendShader</codeph>-Eigenschaft muss nicht neu gesetzt werden, es sei denn, der für den Mischmodus verwendete Shader soll geändert werden.</p>
     
     <p>Der Shader, der der <codeph>blendShader</codeph>-Eigenschaft zugewiesen ist, muss mindestens zwei <codeph>image4</codeph>-Eingaben festlegen. Die Eingaben müssen <b>nicht</b> im Code über die <codeph>input</codeph>-Eigenschaften des verknüpften ShaderInput-Objekts festgelegt werden. Das Anzeigeobjekt im Hintergrund wird automatisch als erste Eingabe (die Eingabe mit <codeph>index</codeph> gleich „0“) verwendet. Das Anzeigeobjekt im Vordergrund wird als zweite Eingabe (die Eingabe mit <codeph>index</codeph> gleich „1“) verwendet. Ein als Misch-Shader verwendeter Shader kann mehr als zwei Eingaben festlegen: In diesem Fall müssen die weiteren Eingaben durch das Setzen der <codeph>imput</codeph>-Eigenschaft der ShaderInput-Instanz festgelegt werden.</p>
     
     <p>Wird dieser Eigenschaft eine Shader-Instanz zugewiesen, so wird der Shader intern kopiert. Der Mischvorgang verwendet diese interne Kopie, anstatt eines Verweises auf den ursprünglichen Shader. Änderungen am Shader (beispielsweise an Parameterwerten, Eingabe oder Bytecode) werden nicht auf die für den Mischmodus verwendete Shaderkopie angewendet.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Loader"><apiName>Loader</apiName><shortdesc>
 Die Loader-Klasse wird dazu verwendet, SWF- oder Bilddateien (im JPG-, PNG- oder GIF-Format) zu laden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Loader-Klasse wird dazu verwendet, SWF- oder Bilddateien (im JPG-, PNG- oder GIF-Format) zu laden. Verwenden Sie die <codeph>load()</codeph>-Methode, um den Ladevorgang einzuleiten. Das geladene Anzeigeobjekt wird dem Loader-Objekt untergeordnet.
 
 <p>Verwenden Sie die URLLoader-Klasse, um Text oder Binärdaten zu laden.</p>
 
 <p>Die Loader-Klasse setzt die folgenden übernommenen Methoden außer Kraft, da ein Loader-Objekt nur ein untergeordnetes Anzeigeobjekt besitzen kann, nämlich das Anzeigeobjekt, das geladen wird. Durch das Aufrufen der folgenden Methoden wird eine Ausnahme ausgelöst: <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph>, <codeph>removeChild()</codeph>, <codeph>removeChildAt()</codeph> und <codeph>setChildIndex()</codeph>. Um ein geladenes Anzeigeobjekt zu entfernen, müssen Sie das <i>Loader</i>-Objekt aus seinem übergeordneten DisplayObjectContainer-Child-Array entfernen. </p>
 
 <p><b>Hinweis:</b> Die ActionScript 2.0-Klassen MovieClipLoader und LoadVars werden in ActionScript 3.0 nicht verwendet. Sie werden durch die Klassen Loader und URLLoader ersetzt.</p>
 
 <p>Beachten Sie bei Verwendung der Loader-Klasse das Sicherheitsmodell von Flash Player und Adobe AIR: </p>
 
 <ul>
  <li>Sie können Inhalte von jeder Quelle laden, zu der Sie Zugang haben. </li>
 
  <li>Das Laden ist nicht erlaubt, wenn sich die aufrufende SWF-Datei in einer Netzwerk-Sandbox befindet und die zu ladende Datei lokal gespeichert ist. </li>
 
  <li>Handelt es sich bei dem geladenen Inhalt um eine in ActionScript 3.0 geschriebene SWF-Datei, kann eine SWF-Datei in einer anderen Sicherheits-Sandbox in ihrem Code nicht darauf verweisen, es sei denn, dieses „Cross-Scripting-Arrangement“ wurde durch einen Aufruf der Methode <codeph>System.allowDomain()</codeph> oder <codeph>System.allowInsecureDomain()</codeph> in der geladenen Inhaltsdatei genehmigt.</li>
  
  <li>Handelt es sich bei dem geladenen Inhalt um eine AVM1-SWF-Datei (die in ActionScript 1.0 oder 2.0 geschrieben wurde), kann eine AVM2-SWF-Datei (in ActionScript 3.0 geschrieben) in ihrem Code nicht darauf verweisen. Dennoch kann eine Kommunikation zwischen den beiden SWF-Dateien stattfinden, und zwar durch Verwendung der LocalConnection-Klasse.</li>
  
  <li>Handelt es sich beim geladenen Inhalt um eine Grafik, so kann eine SWF-Datei außerhalb der Sicherheitssandbox nicht darauf zugreifen, es sein denn, in der Ursprungsdomäne der Grafik wurde die Domäne dieser SWF-Datei in eine URL-Richtliniendatei aufgenommen.</li>
 
  <li>Movieclips in der lokalen Sandbox des Dateisystems können keine Skripten auf Movieclips in der lokalen Netzwerk-Sandbox anwenden (auch umgekehrt ist dies nicht möglich). </li>
 
  <li>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>. </li>
 
 
 </ul>
 
 <p>In AIR unterliegt Inhalt in der Sicherheits-Sandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
 
 <p>Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
 
 </ul>
 
 <p>Wenn Sie eine SWF-Datei aus einer nicht vertrauenswürdigen Quelle laden (etwa einer Domäne, die nicht mit der Stamm-SWF-Datei des Loader-Objekts übereinstimmt), empfiehlt es sich, eine Maske für das Loader-Objekt zu definieren. Dadurch wird verhindert, dass der geladene Inhalt (der dem Loader-Objekt untergeordnet ist) in Bereichen der Bühne gezeichnet wird, die außerhalb dieser Maske liegen. Ein Beispiel hierfür finden Sie im nachfolgenden Code:</p>
 
 <codeblock>import flash.display.~~;
 import flash.net.URLRequest;
 var rect:Shape = new Shape();
 rect.graphics.beginFill(0xFFFFFF);
 rect.graphics.drawRect(0, 0, 100, 100);
 rect.graphics.endFill();
 addChild(rect);
 var ldr:Loader = new Loader();
 ldr.mask = rect;
 var url:String = "http://www.unknown.example.com/content.swf";
 var urlReq:URLRequest = new URLRequest(url);
 ldr.load(urlReq);
 addChild(ldr);
 </codeblock>
 
 </apiDesc><example conref="examples\LoaderExample.as"> Im folgenden Beispiel wird die LoaderExample-Klasse verwendet, um zu zeigen, wie verschiedene Ereignis-Listener verwendet werden. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Es wird eine <codeph>url</codeph>-Eigenschaft erstellt, die den Speicherort und Namen der Grafikdatei angibt.</li>
  <li>Im Konstruktor <codeph>LoaderExample</codeph> wird ein neues Loader-Objekt mit dem Namen <codeph>loader</codeph> erstellt, das dann an die <codeph>configureListeners()</codeph>-Methode übergeben wird. Dies ist in Schritt 3 beschrieben.</li>
  <li>Der Konstruktor erstellt eine neue Instanz eines URLRequest-Objekts, <codeph>request</codeph>, mit Übergabe von <codeph>url</codeph>, damit der Dateiname und -speicherort bekannt sind.</li>
  <li>Das <codeph>request</codeph>-Objekt wird im <codeph>loader</codeph>-Objekt an die <codeph>load()</codeph>-Methode übergeben, die das Bild in die Anzeigeliste lädt.</li>
  <li>Im Loader wird ein <codeph>clickHandler</codeph>-Ereignis-Listener für das <codeph>click</codeph>-Ereignis registriert. Nach einem Klick mit der Maus wird das geladene Bild entfernt.</li>
  <li>Die <codeph>configureListeners()</codeph>-Methode fügt mithilfe der folgenden Methoden sieben Ereignis-Listener hinzu:
  <ul>
      <li>Die <codeph>completeHandler()</codeph>-Methode wird ausgeführt, nachdem das Laden des Bilds beendet ist.</li>
 
      <li>Die <codeph>httpStatusHandler()</codeph>-Methode wird ausgeführt, wenn das Bild nicht lokal geladen wird und nur wenn die Netzwerkanforderung verfügbar ist und der Flash Player diese erkennen kann.</li>
 
      <li>Die <codeph>initHandler()</codeph>-Methode wird vor der <codeph>completeHandler()</codeph>-Methode und nach der <codeph>progressHandler()</codeph>-Methode ausgeführt. Das <codeph>init</codeph>-Ereignis ist in der Regel nützlicher, wenn SWF-Dateien geladen werden.</li>
 
      <li>Die <codeph>ioErrorHandler()</codeph>-Methode wird ausgeführt, wenn die Bilddatei nicht verfügbar oder nicht zugänglich ist.</li>
 
      <li>Die <codeph>openHandler()</codeph>-Methode wird ausgeführt, nachdem die Bilddatei zum ersten Mal geöffnet wurde.</li>
 
      <li>Die <codeph>progressHandler()</codeph>-Methode wird ausgeführt, wenn das Laden der Bilddatei beginnt, und wird erneut ausgeführt, wenn das Laden der Bilddatei abgeschlossen ist.</li>
 
      <li>Die <codeph>unLoadHandler()</codeph>-Methode wird ausgeführt, wenn das Bild entfernt wird, indem die <codeph>unload()</codeph>-Methode verwendet wird, wenn Benutzer auf das Bild klicken.</li>
 
  </ul>
  </li>
 </ol>
 <p> Beachten Sie folgende Bedingungen:</p>
 
 <ul>
  <li>Zur Ausführung dieses Beispiels müssen Sie eine Datei mit dem Namen „Image.gif“ in dem Ordner ablegen, in dem sich auch die kompilierte SWF-Datei befindet. Verwenden Sie ein Bild mit einem Bereich, der in die Abmessungen der SWF-Hauptdatei passt.</li>
 
  <li>Obwohl in diesem Beispiel alle verfügbaren Ereignisse des LoaderInfo-Objekts verwendet werden, ist in den meisten Situationen nur ein Teil davon erforderlich. Beim einfachen Laden einer Bilddatei reicht z. B. das <codeph>complete</codeph>-Ereignis (und ggf. das <codeph>ioError</codeph>-Ereignis) aus, sofern ein lokales Bild geladen wird.</li>
 
 </ul>
 
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderExample() {
            var loader:Loader = new Loader();
            configureListeners(loader.contentLoaderInfo);
            loader.addEventListener(MouseEvent.CLICK, clickHandler);

            var request:URLRequest = new URLRequest(url);
            loader.load(request);

            addChild(loader);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(Event.INIT, initHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(Event.UNLOAD, unLoadHandler);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function initHandler(event:Event):void {
            trace("initHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function unLoadHandler(event:Event):void {
            trace("unLoadHandler: " + event);
        }

        private function clickHandler(event:MouseEvent):void {
            trace("clickHandler: " + event);
            var loader:Loader = Loader(event.target);
            loader.unload();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:Loader:Loader"><apiName>Loader</apiName><shortdesc>
     Erstellt ein Loader-Objekt, das Sie zum Laden von Dateien wie SWF-, JPEG-, GIF- oder PNG-Dateien verwenden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need wording on parent/child relationships, root DisplayObjects, and so on.
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Erstellt ein Loader-Objekt, das Sie zum Laden von Dateien wie SWF-, JPEG-, GIF- oder PNG-Dateien verwenden können. Rufen Sie die <codeph>load()</codeph>-Methode auf, um den Bestandsartikel als Child-Objekt der Loader-Instanz zu laden. Anschließend können Sie das Loader-Objekt in die Anzeigeliste aufnehmen (z. B. indem Sie die <codeph>addChild()</codeph>-Methode einer DisplayObjectContainer-Instanz verwenden). Der Bestandsartikel erscheint auf der Bühne, noch während er geladen wird.
     
     <p>Sie können eine Loader-Instanz auch außerhalb der Liste verwenden, also ohne sie in einen Anzeigeobjekt-Container in der Anzeigeliste einzufügen. In diesem Modus kann die Loader-Instanz zum Laden einer SWF-Datei verwendet werden, die zusätzliche Module einer Anwendung enthält. </p>
     
     <p>Um festzustellen, wann die SWF-Datei vollständig geladen ist, können Sie die Ereignisse des LoaderInfo-Objekts verwenden, das der <codeph>contentLoaderInfo</codeph>-Eigenschaft des Loader-Objekts zugeordnet ist. An diesem Punkt kann der Code in der Modul-SWF-Datei ausgeführt werden, um das Modul zu initialisieren und zu starten. Außerhalb der Liste kann eine Loader-Instanz auch verwendet werden, um eine SWF-Datei zu laden, die Komponenten oder Medienbestände enthält. Wiederum können Sie die Ereignisbenachrichtigungen des LoaderInfo-Objekts verwenden, um festzustellen, wann die Komponenten vollständig geladen sind. An diesem Punkt kann die Anwendung beginnen, mit den Komponenten und Medienbeständen in der Bibliothek der SWF-Datei zu arbeiten, indem die ActionScript 3.0-Klassen, die diese Komponenten und Medienbestände repräsentieren, instanziiert werden.</p>
     
     <p>Um den Status eines Loader-Objekts zu ermitteln, überwachen Sie die folgenden Ereignisse, die das LoaderInfo-Objekt der <codeph>contentLoaderInfo</codeph>-Eigenschaft des Loader-Objekts zugeordnet hat:</p>
     
     <ul>
       
     <li>Das <codeph>open</codeph>-Ereignis wird ausgelöst, wenn der Ladevorgang beginnt.</li>
       
     <li>Die Ereignisse <codeph>ioError</codeph> bzw. <codeph>securityError</codeph> werden ausgelöst, wenn die Datei nicht geladen werden kann oder wenn während des Ladevorgangs ein Fehler aufgetreten ist. </li>
       
     <li>Das <codeph>progress</codeph>-Ereignis wird fortlaufend ausgelöst, während die Datei geladen wird.</li>
       
     <li>Das <codeph>complete</codeph>-Ereignis wird ausgelöst, nachdem eine Datei vollständig heruntergeladen wurde, jedoch noch bevor die Methoden und Eigenschaften des geladenen Movieclips verfügbar sind. </li>
       
     <li>Das <codeph>init</codeph>-Ereignis wird ausgelöst, sobald die Eigenschaften und Methoden der geladenen SWF-Datei verfügbar sind, sodass Sie mit der Bearbeitung der geladenen SWF-Datei beginnen können. Dieses Ereignis wird vor der Prozedur <codeph>complete</codeph> ausgelöst. In gestreamten SWF-Dateien kann das <codeph>init</codeph>-Ereignis um einiges früher eintreten als das <codeph>complete</codeph>-Ereignis. Für die meisten Zwecke ist die <codeph>init</codeph>-Prozedur geeignet.</li>
     
     </ul>
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:Loader:close"><apiName>close</apiName><shortdesc>
     Bricht eine für die Loader-Instanz in Ausführung befindliche Operation der load()-Methode ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Bricht einen aktuell für die Loader-Instanz ausgeführten Vorgang der <codeph>load()</codeph>-Methode ab.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:load"><apiName>load</apiName><shortdesc>
     Lädt eine SWF-, JPEG-, progressive JPEG-, nicht animierte GIF- oder PNG-Datei in ein Objekt, das dem Loader-Objekt untergeordnet ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how to use the <code>MovieClipLoader.loadClip()</code> 
     method by creating a handler for the <code>onLoadInit</code> event and then making the request.
     <p>You should either place the following code directly into a frame action on a Timeline, or 
     paste it into a class that extends MovieClip. This code also expects an image named YourImage.jpg
     to exist in the same directory as the compiled SWF file.</p>
     
     <listing version="2.0">
     var container:MovieClip = createEmptyMovieClip("container", getNextHighestDepth());
     var mcLoader:MovieClipLoader = new MovieClipLoader();
     mcLoader.addListener(this);
     mcLoader.loadClip("YourImage.jpg", container);
     
     function onLoadInit(mc:MovieClip) {
         trace("onLoadInit: " + mc);
     }
     </listing>
     
     </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die <codeph>digest</codeph>-Eigenschaft des <codeph>request</codeph>-Objekts ist nicht <codeph>null</codeph>. Sie sollten die <codeph>digest</codeph>-Eigenschaft eines URLRequest-Objekts nur setzen, wenn Sie beim Laden einer SWZ-Datei (einer Adobe-Plattformkomponente) die <codeph>URLLoader.load()</codeph>-Methode aufrufen.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Der Wert von <codeph>LoaderContext.securityDomain</codeph> muss entweder <codeph>null</codeph> oder <codeph>SecurityDomain.currentDomain</codeph> lauten. Dadurch wird die Tatsache widergespiegelt, dass Sie die geladenen Medien nur in deren „natürlicher“ Sicherheits-Sandbox oder in Ihrer eigenen Sandbox platzieren können (wobei die letztere eine Richtliniendatei erfordert).
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Lokale SWF-Dateien dürfen „LoaderContext.securityDomain“ auf keinen anderen Wert als <codeph>null</codeph> setzen. Es ist nicht zulässig, nicht lokale Medien in eine lokale Sandbox zu importieren oder andere lokale Medien an einem anderen Ort als in ihrer natürlichen Sandbox zu platzieren.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Eigenschaft <codeph>applicationDomain</codeph> oder <codeph>securityDomain</codeph> des Parameters <codeph>context</codeph> aus einer nicht zulässigen Domäne stammt.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn eine lokale SWF-Datei versucht, die <codeph>securityDomain</codeph>-Eigenschaft des Parameters <codeph>context</codeph> zu verwenden.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> Die absolute oder relative URL für die zu ladende SWF-, JPEG-, GIF- oder PNG-Datei. Ein relativer Pfad muss relativ zur Haupt-SWF-Datei angegeben werden. Absolute URLs müssen eine Protokollreferenz wie „http://“ oder „file:///“ enthalten. Dateinamen können keine Laufwerkangaben enthalten.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein LoaderContext-Objekt mit Eigenschaften, die folgende Punkte definieren:
     
     <ul>
     
	 <li>Ob beim Laden des Objekts nach einer Richtliniendatei gesucht werden soll oder nicht</li>
     
     <li>Die ApplicationDomain für das geladene Objekt</li>
     
     <li>Die SecurityDomain für das geladene Objekt</li>
     
     </ul>
     <p>Wenn der <codeph>context</codeph>-Parameter nicht festgelegt ist oder auf ein Null-Objekt verweist, bleibt der Inhalt innerhalb seiner eigenen Sicherheitsdomäne.</p>
     
     <p>Vollständige Angaben finden Sie in der Beschreibung der Eigenschaften in der Klasse <xref href="../system/LoaderContext.html">LoaderContext</xref>.</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Lädt eine SWF- oder Bilddatei in ein Anzeigeobjekt, das dieser Loader-Instanz untergeordnet ist.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Lädt eine SWF-, JPEG-, progressive JPEG-, nicht animierte GIF- oder PNG-Datei in ein Objekt, das dem Loader-Objekt untergeordnet ist. Wenn Sie eine animierte GIF-Datei laden, wird nur das erste Bild angezeigt. Da das Loader-Objekt nur ein einziges untergeordnetes Objekt besitzen darf, beendet eine nachfolgende <codeph>load()</codeph>-Anforderung eine ggf. noch aktive vorherige Anforderung und beginnt einen neuen Ladevorgang.
     
     <p><b>Hinweis</b>: In AIR 1.5 und Flash Player 10 ist die maximale Höhe oder Breite eines geladenen Bilds 8.191 Pixel, die Pixelzahl darf insgesamt 16.777.215 nicht übersteigen. (Wenn ein geladenes Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite.</p>
     
     <p>Eine in ein Loader-Objekt geladene SWF- oder Bilddatei übernimmt die Positions-, Drehungs- und Skalierungseigenschaften der dem Loader-Objekt übergeordneten Anzeigeobjekte. </p>
     
     <p>Mit der <codeph>unload()</codeph>-Methode können Sie mit dieser Methode geladene Filme oder Bilder entfernen oder einen laufenden Ladevorgang abbrechen.</p>
     
     <p>Sie können eine SWF-Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</p>
     
     <p>Wenn Sie diese Methode verwenden, beachten Sie das Flash Player-Sicherheitsmodell, das in der Beschreibung der Loader-Klasse erklärt wird. </p>
     
     <p> Wenn Sie in Flash Player 10 oder höher Inhalte vom Typ „multipart“ verwenden (z. B. „multipart/form-data“), die einen Upload enthalten (gekennzeichnet durch einen „filename“-Parameter in einem „content-disposition“-Header innerhalb des POST-Body), so unterliegt der POST-Vorgang den Sicherheitsregeln für Uploads:</p>
	 <ul>
	 <li>Der POST-Vorgang muss als Reaktion auf eine durch den Benutzer initiierte Aktion, z. B. Mausklick oder Tastendruck, erfolgen.</li>
	 <li>Ist der POST-Vorgang domänenübergreifend (das POST-Ziel befindet sich auf einem anderen Server als die SWF-Datei, die die POST-Anforderung sendet), so muss der Zielserver eine URL-Richtliniendatei bereitstellen, die den domänenübergreifenden Zugriff erlaubt.</li>
	 </ul>
     <p>Bei mehrteiligen Inhaltstypen muss zudem auch die Syntax gemäß Standard RFC2046 gültig sein. Scheint die Syntax ungültig zu sein, so unterliegt der POST-Vorgang den Sicherheitsregeln für Uploads.</p>
     <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
     
     <ul>
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/contentLoaderInfo"><linktext>contentLoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>flash.display.Loader.unload()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><adobeApiEvent id="flash.display:Loader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>-Objekt ausgelöst, wenn die Datei vollständig geladen ist. Das Ereignis <codeph>complete</codeph> wird immer nach dem Ereignis <codeph>init</codeph> ausgelöst.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt ausgelöst, wenn die Datei vollständig geladen ist.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>-Objekt ausgelöst, wenn eine Netzwerkanfrage über HTTP gestellt wird und Flash Player den HTTP-Statuscode ermittelt hat.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt ausgelöst, wenn eine Netzwerkanfrage über HTTP gestellt wird und Flash Player den HTTP-Statuscode ermittelt hat.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_init"><apiName>init</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>-Objekt ausgelöst, wenn die Eigenschaften und Methoden der geladenen SWF-Datei zugänglich sind. Das Ereignis <codeph>init</codeph> wird immer vor dem Ereignis <codeph>complete</codeph> ausgelöst.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt ausgelöst, wenn die Eigenschaften und Methoden der geladenen SWF-Datei zugänglich sind.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>-Objekt beim Auftreten eines Eingabe- oder Ausgabefehlers, durch den der Ladevorgang fehlschlägt, ausgelöst.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt beim Auftreten eines Eingabe- oder Ausgabefehlers, durch den der Ladevorgang fehlschlägt, ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>-Objekt ausgelöst, wenn das Laden der Datei beginnt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt ausgelöst, wenn der Ladevorgang beginnt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>Objekt während des Empfangs von Daten im Zuge des Ladevorgangs ausgelöst.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt während des Empfangs von Daten im Zuge des Ladevorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>-Objekt ausgelöst, wenn eine SWF-Datei in der 
„local-with-filesystem“-Sandbox versucht, Inhalte in der „local-with-networking“-Sandbox zu laden, oder umgekehrt.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt ausgelöst, wenn eine SWF-Datei in der 
„local-with-filesystem“-Sandbox versucht, Inhalte in der „local-with-networking“-Sandbox zu laden, oder umgekehrt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_unload"><apiName>unload</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird vom <codeph>contentLoaderInfo</codeph>-Objekt ausgelöst, wenn ein geladenes Objekt entfernt wird.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird vom contentLoaderInfo-Objekt ausgelöst, wenn ein geladenes Objekt entfernt wird.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:Loader:loadBytes"><apiName>loadBytes</apiName><shortdesc>
     Lädt in einem ByteArray-Objekt gespeicherte Binärdaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Wert der <codeph>length</codeph>-Eigenschaft des ByteArray-Objekts nicht größer als 0 ist.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Eigenschaft <codeph>checkPolicyFile</codeph> bzw. <codeph>securityDomain</codeph> des Parameters <codeph>context</codeph> nicht null ist.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die bereitgestellte <codeph>applicationDomain</codeph>-Eigenschaft der <codeph>context</codeph>-Eigenschaft aus einer nicht zulässigen Domäne stammt.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Ein ByteArray-Objekt. Als Format des ByteArray-Inhalts ist jedes von der Loader-Klasse unterstützte Dateiformat zulässig: SWF, GIF, JPEG oder PNG.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein LoaderContext-Objekt. Nur die <codeph>applicationDomain</codeph>-Eigenschaft des LoaderContext-Objekts kann angewendet werden, nicht jedoch die Eigenschaften <codeph>checkPolicyFile</codeph> und <codeph>securityDomain</codeph> des LoaderContext-Objekts. 
     
     <p>Wenn der <codeph>context</codeph>-Parameter nicht angegeben ist oder auf ein Null-Objekt verweist, werden die Inhalte in die aktuelle Sicherheitsdomäne geladen. Dieser Vorgang wird in der Sicherheitsdokumentation von Flash Player als „importiertes Laden“ bezeichnet. Wenn die ladende SWF-Datei der Remote-SWF-Datei vertraut und sie in ihren Code aufnimmt, können Inhalte direkt in die Sicherheitsdomäne der ladenden SWF-Datei importiert werden.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lädt von Binärdaten, die in einem BytArray-Objekt gespeichert sind.
     
     <p>Wenn Sie diese Methode verwenden, beachten Sie das Flash Player-Sicherheitsmodell, das in der Beschreibung der Loader-Klasse erklärt wird. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unload"><apiName>unload</apiName><shortdesc>
     Entfernt ein untergeordnetes Objekt dieses Loader-Objekts, das mit der load()-Methode geladen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The funky-looking code formatting above is intentional to work around a bug!
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Entfernt ein untergeordnetes Objekt dieses Loader-Objekts, das mit der Methode <codeph>load()</codeph> geladen wurde. Die <codeph>property</codeph> (Eigenschaft) des zugeordneten LoaderInfo-Objekts wird auf <codeph>null</codeph> zurückgesetzt. Das untergeordnete Objekt wird nicht unbedingt gelöscht, da andere Objekte möglicherweise Verweise darauf enthalten. Allerdings ist es dem Loader-Objekt nicht mehr untergeordnet.
     
     <p>Es ist ratsam, vor dem Entladen einer untergeordneten SWF-Datei alle Streams in deren Objekten, z. B. LocalConnection-, NetConnection-, NetStream- oder Sound-Objekte, ausdrücklich zu schließen. Andernfalls kann es passieren, dass Audiodaten in der untergeordneten SWF-Datei unaufhörlich abgespielt werden, obwohl die SWF-Datei selbst bereits entladen worden ist. Um Streams in der untergeordneten SWF-Datei zu schließen, fügen Sie dem untergeordneten Objekt, das auf das <codeph>unload</codeph>-Ereignis wartet, einen Ereignis-Listener hinzu. Wenn das übergeordnete Objekt die <codeph>Loader.unload()</codeph>-Methode aufruft, wird für das untergeordnete Objekt das <codeph>unload</codeph>-Ereignis ausgelöst. Im folgenden Code wird gezeigt, wie Sie dies realisieren können:</p>
<pre>
function closeAllStreams(evt:Event) { 
    myNetStream.close();
    mySound.close();
    myNetConnection.close();
    myLocalConnection.close();
}

myMovieClip.loaderInfo.addEventListener(Event.UNLOAD, closeAllStreams);</pre>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.media.xml#Sound/close()"><linktext>flash.media.Sound.close()</linktext></link><link href="flash.net.xml#LocalConnection/close()"><linktext>flash.net.LocalConnection.close()</linktext></link><link href="flash.net.xml#NetConnection/close()"><linktext>flash.net.NetConnection.close()</linktext></link><link href="flash.net.xml#NetStream/close()"><linktext>flash.net.NetStream.close()</linktext></link><link href="../../operators.html#delete"><linktext>delete operator</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unloadAndStop"><apiName>unloadAndStop</apiName><shortdesc>
     Versucht, die Inhalte der untergeordneten SWF-Datei zu entladen und beendet die Ausführung der Befehle geladener SWF-Dateien.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>gc</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Stellt einen Hinweis für den Garbagekollektor bereit, ob er für die untergeordneten SWF-Objekte ausgeführt werden soll (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). Wenn Sie viele Objekte asynchron entladen, kann das Setzen des <codeph>gc</codeph>-Parameters auf <codeph>false</codeph> die Leistung der Anwendung verbessern. Allerdings kann das Setzen von <codeph>false</codeph> dazu führen, dass Medien und Anzeigeobjekte der untergeordneten SWF-Datei nach dem Ausführen des <codeph>unloadAndStop()</codeph>-Befehls weiterhin im Speicher verbleiben
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Versucht, die Inhalte der untergeordneten SWF-Datei zu entladen und beendet die Ausführung von Befehlen geladener SWF-Dateien. Diese Methode versucht, SWF-Dateien zu entladen, die mithilfe von <codeph>Loader.load()</codeph> oder <codeph>Loader.loadBytes()</codeph> erstellt wurden, indem sie Verweise auf EventDispatcher-, NetConnection-, Timer-, Sound- oder Video-Objekte der untergeordneten SWF-Datei entfernt. Als Ergebnis tritt Folgendes für die untergeordnete SWF-Datei und die Anzeigeliste der untergeordneten SWF-Datei ein:
     <ul><li>Sounds werden gestoppt.</li>
     <li>Stage-Ereignis-Listener werden entfernt.</li>
     <li>Ereignis-Listener für <codeph>enterFrame</codeph>, <codeph>frameConstructed</codeph>, <codeph>exitFrame</codeph>, <codeph>activate</codeph> und <codeph>deactivate</codeph> werden entfernt.</li>
     <li>Timer werden gestoppt.</li>
     <li>Kamera- und Mikrofoninstanzen werden getrennt.</li>
     <li>Movieclips werden gestoppt.</li></ul>
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Loader:content:get"><apiName>content</apiName><shortdesc>
     Enthält das Stamm-Anzeigeobjekt der SWF- oder Bilddatei (JPG, PNG oder GIF), die mit der load()- oder loadBytes()-Methode geladen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>Die geladene SWF- oder Bilddatei ist Teil einer Sicherheits-Sandbox, auf die Sie keinen Zugriff haben. Sie können diese Situation für eine geladene SWF-Datei vermeiden, indem Sie die Datei die <codeph>Security.allowDomain()</codeph>-Methode aufrufen lassen oder die ladende Datei einen Parameter <codeph>loaderContext</codeph> laden lassen (für den die <codeph>securityDomain</codeph>-Eigenschaft auf <codeph>SecurityDomain.currentDomain</codeph> gesetzt ist), wenn Sie die Methode <codeph>load()</codeph> oder <codeph>loadBytes()</codeph> aufrufen.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Enthält das Stamm-Anzeigeobjekt der SWF- oder Bilddatei (JPG, PNG oder GIF), die anhand der Methode <codeph>load()</codeph> oder <codeph>loadBytes()</codeph> geladen worden ist.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:Loader:contentLoaderInfo:get"><apiName>contentLoaderInfo</apiName><shortdesc>
     Gibt ein LoaderInfo-Objekt zurück, das dem zu ladenden Objekt entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Gibt ein LoaderInfo-Objekt zurück, das dem zu ladenden Objekt entspricht. LoaderInfo-Objekte werden sowohl vom Loader-Objekt als auch von geladenen Inhaltsobjekten genutzt. Das LoaderInfo-Objekt stellt Informationen und Statistiken zum Ladefortschritt der geladenen Datei bereit. 
     
     <p>Ereignisse, die sich auf das Laden beziehen, werden durch das LoaderInfo-Objekt ausgelöst, auf das über die <codeph>contentLoaderInfo</codeph>-Eigenschaft des Loader-Objekts verwiesen wird. Die <codeph>contentLoaderInfo</codeph>-Eigenschaft wird bereits auf ein gültiges LoaderInfo-Objekt gesetzt, bevor der Inhalt geladen wird, damit Sie dem Objekt vor dem Laden Ereignis-Listener hinzufügen können.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
     Die NativeMenuItem-Klasse repräsentiert ein einzelnes Element in einem Menü.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     Die NativeMenuItem-Klasse repräsentiert ein einzelnes Element in einem Menü.
     
     <p>Bei einem Menüelement kann es sich um einen Befehl, ein Untermenü oder um eine Trennlinie handeln:</p> 
     
     <ul>
     <li>Zum Erstellen eines Befehls rufen Sie den NativeMenuItem-Konstruktor auf und übergeben dabei einen String für die Bezeichnung sowie den Wert <codeph>false</codeph> für den <codeph>isSeparator</codeph>-Parameter.</li>
     
     <li>Zum Erstellen eines Untermenüs erstellen Sie einen Befehl für das übergeordnete Menü und weisen das NativeMenu-Objekt des Untermenüs der <codeph>submenu</codeph>-Eigenschaft des Befehls zu. Sie können auch die <codeph>addSubmenu()</codeph>-Methode des übergeordneten NativeMenu-Objekts aufrufen, um das Element zu erstellen und gleichzeitig die <codeph>submenu</codeph>-Eigenschaft zu setzen.</li>
     
     <li>Zum Erstellen einer Trennlinie rufen Sie den NativeMenuItem-Konstruktor auf und übergeben dabei einen leeren String für die Bezeichnung sowie den Wert <codeph>true</codeph> für den <codeph>isSeparator</codeph>-Parameter.</li>
     </ul>
     
     <p>Durch Warten auf <codeph>select</codeph>-Ereignisse für einen Befehl oder ein übergeordnetes Menü kann festgestellt werden, wann ein Menübefehl ausgewählt wird. Untermenüs und Trennlinien lösen keine select-Ereignisse aus. Durch Warten auf <codeph>displaying</codeph>-Ereignisse kann festgestellt werden, wann ein Menüelement kurz davor steht, angezeigt zu werden.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Wird von diesem NativeMenuItem-Objekt ausgelöst, unmittelbar bevor das Menü, das das Element enthält, angezeigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Wird von diesem NativeMenuItem-Objekt ausgelöst, unmittelbar bevor das Menü, das das Element enthält, angezeigt wird. 
     
	 <p>Die <codeph>target</codeph>-Eigenschaft des Ereignisobjekts verweist auf das NativeMenu-Objekt, das dieses NativeMenuItem-Objekt enthält. Die <codeph>currentTarget</codeph>-Eigenschaft verweist auf dieses NativeMenuItem-Objekt.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Wird immer ausgelöst, wenn der Benutzer ein Menüelement auswählt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Wird immer ausgelöst, wenn der Benutzer ein Menüelement auswählt. 
     
     <p>Ein <codeph>select</codeph>-Ereignis wird von diesem Element bis zum übergeordneten Menü und weiter durch die Struktur bis zum Stamm-Menüobjekt gesendet (<i>Bubbling</i>). Die <codeph>target</codeph>-Eigenschaft des Ereignisobjekts verweist auf dieses NativeMenuItem-Objekt. Die <codeph>currentTarget</codeph>-Eigenschaft verweist auf das auslösende Objekt (entweder dieses NativeMenuItem-Objekt oder ein übergeordnetes NativeMenu-Objekt).</p>
	 
	 <p><b>Hinweis:</b> Wenn sich das Menü in einem Fenster im Vollbildmodus befindet, löst das NativeMenuItem-Objekt <i>kein</i> <codeph>select</codeph>-Ereignis aus, wenn der Benutzer einen Tastaturbefehl für ein Menüelement eingibt. Sie können jedoch auf ein <codeph>keyDown</codeph>-Ereignis warten, das von der <codeph>stage</codeph>-Eigenschaft des NativeWindow-Objekts ausgelöst wird.</p>
       
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeMenuItem:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
         Erstellt ein neues NativeMenuItem-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Die anzuzeigende Bezeichnung für das Element oder ein leerer String für Trennlinien.
         </apiDesc></apiParam><apiParam><apiItemName>isSeparator</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><codeph>true</codeph>, um eine Trennlinie zu erstellen, andernfalls <codeph>false</codeph>.
         
         </apiDesc></apiParam></apiConstructorDef><apiDesc>
         Erstellt ein neues NativeMenuItem-Objekt.
         
         <p>Zum Erstellen eines Menübefehls stellen Sie den <codeph>label</codeph>-Parameter auf einen String ein, der die anzuzeigende Bezeichnung enthält, und setzen Sie <codeph>isSeparator</codeph> auf <codeph>false</codeph>.</p>
	     
	     <p>Zum Erstellen eines Untermenübefehls erstellen Sie ein Befehlselement und weisen dann das NativeMenu-Objekt des Untermenüs der <codeph>submenu</codeph>-Eigenschaft des Elements zu. Fügen Sie das Element dem übergeordneten Menü hinzu.</p>
		  
	     <p>Zum Erstellen einer Trennlinie stellen Sie den <codeph>label</codeph>-Parameter auf einen leeren String ein und setzen Sie <codeph>isSeparator</codeph> auf <codeph>true</codeph>.</p>
         
         <p>Um Elemente in einem Menü hinzuzufügen oder zu entfernen, verwenden Sie die NativeMenu-Methoden <codeph>addItem()</codeph> und <codeph>removeItem()</codeph>.</p>
         
         </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeMenuItem:clone"><apiName>clone</apiName><shortdesc>
         Erstellt eine Kopie des NativeMenuItem-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Erstellt eine Kopie des NativeMenuItem-Objekts.
         
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenuItem:toString"><apiName>toString</apiName><shortdesc>
         Gibt einen String zurück, der alle Eigenschaften des NativeMenuItem-Objekts enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Ein String, der alle Eigenschaften des Ereignisobjekts enthält.
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Gibt einen String zurück, der alle Eigenschaften des NativeMenuItem-Objekts enthält.
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenuItem:checked:get"><apiName>checked</apiName><shortdesc>
         Steuert, ob für dieses Menüelement ein Häkchen angezeigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Steuert, ob für dieses Menüelement ein Häkchen angezeigt wird.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:data:get"><apiName>data</apiName><shortdesc>
         Ein beliebiges Datenobjekt, das zu diesem Menüelement gehört.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
         Ein beliebiges Datenobjekt, das zu diesem Menüelement gehört.
         
         <p>Sie können dieser Eigenschaft jedes Objekt zuweisen. Das zugewiesene Objekt wird nicht vom Menüsystm verwendet, sondern steht für Ereignisprozedurcode zur Verfügung (über die target-Eigenschaft des Ereignisobjekts). Standardmäßig hat diese Eigenschaft den Wert <codeph>null</codeph>.</p>
           
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:enabled:get"><apiName>enabled</apiName><shortdesc>
         Steuert, ob dieses Menüelement aktiviert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Steuert, ob dieses Menüelement aktiviert ist.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:isSeparator:get"><apiName>isSeparator</apiName><shortdesc>
         Gibt an, ob es sich bei diesem Element um eine Menütrennlinie handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Gibt an, ob es sich bei diesem Element um eine Menütrennlinie handelt.
         
         <p>Zum Erstellen einer Trennlinie stellen Sie den <codeph>isSeparator</codeph>-Parameter im NativeMenuItem-Konstruktor auf <codeph>true</codeph> ein.</p> 
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalent:get"><apiName>keyEquivalent</apiName><shortdesc>
         Der Tastaturbefehl für dieses Menüelement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Der Tastaturbefehl für dieses Menüelement.
		 
		 <p>Setzen Sie <codeph>keyEquivalent</codeph> mit einem Kleinbuchstaben, um einen Kurzbefehl, der keine Betätigung der Umschalttaste erfordert, zuzuweisen. Setzen Sie einen Großbuchstaben, um einen Kurzbefehl, der die Betätigung der Umschalttaste erfordert, zuzuweisen.</p>
		 
		 <p>Standardmäßig erfordern Tastaturbefehle die Betätigung einer Zusatztaste (die Strg-Taste unter Windows und die Befehlstaste unter Mac OS X). Wenn Sie einen Tastaturbefehl ohne Zusatztaste festlegen möchten, setzen Sie die <codeph>keyEquivalentModifiers</codeph>-Eigenschaft auf ein leeres Array.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalentModifiers:get"><apiName>keyEquivalentModifiers</apiName><shortdesc>
         Das Tastencode-Array für die Zusatztasten des Tastaturbefehls.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         Das Tastencode-Array für die Zusatztasten des Tastaturbefehls.
         
         <p>Verwenden Sie die in der Keyboard-Klasse definierten Konstanten, um die Zusatztastencodes anzugeben. Gültige Zusatztasten sind:</p>
         <ul>
         <li><codeph>Keyboard.ALTERNATE</codeph></li>
         <li><codeph>Keyboard.COMMAND</codeph></li>
         <li><codeph>Keyboard.CONTROL</codeph></li>
         </ul>
		 
		 <p>Wenn Sie keine Zusatztaste zuweisen, wird unter Windows oder Linux standardmäßig die <codeph>Keyboard.CONTROL</codeph>-Taste zugewiesen, unter Mac OS X die <codeph>Keyboard.COMMAND</codeph>-Taste. Wenn Sie diese Zusatztasten nicht verwenden möchten, setzen Sie diese Eigenschaft auf ein leeres Array.</p>
		 
		 <p>Wenn Sie der <codeph>keyEquivalent</codeph>-Eigenschaft einen Großbuchstaben zuweisen, wird automatisch die Umschalttaste als Zusatztaste verwendet. Wenn Sie <codeph>keyEquivalentModifier</codeph> auf ein leeres Array setzen, wird die Umschalttaste als Zusatztaste nicht entfernt.</p> 
         
         </apiDesc></apiValueDetail><related-links><link href="flash.ui.xml#Keyboard"><linktext>flash.ui.Keyboard</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeMenuItem:label:get"><apiName>label</apiName><shortdesc>
         Der Anzeigestring dieses Menüelements.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Der Anzeigestring dieses Menüelements.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:menu:get"><apiName>menu</apiName><shortdesc>
         Das Menü, das dieses Element enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         Das Menü, das dieses Element enthält.  
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:mnemonicIndex:get"><apiName>mnemonicIndex</apiName><shortdesc>
         Die Position des Zugriffszeichens in der Bezeichnung des Menüelements.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Die Position des Zugriffszeichens in der Bezeichnung des Menüelements.
         
         <p>Das Zeichen an der angegebenen Position ist das Zugriffszeichen des Menüelements. Der Index basiert auf Null, das heißt, dass das erste Zeichen den Indexwert 0 hat.</p>
         
         <p>Auf Betriebssystemen, die keine Zugriffszeichen für Menüs verwenden, wird diese Eigenschaft ignoriert.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:name:get"><apiName>name</apiName><shortdesc>
         Der Name dieses Menüelements.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Der Name dieses Menüelements.  
         
         <p>Der Namenswert wird nicht angezeigt und kann als vom Gebietsschema unabhängiger Bezeichner verwendet werden. Die Zuweisung von Namen erfolgt nicht automatisch.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:submenu:get"><apiName>submenu</apiName><shortdesc>
		 Das Untermenü, das zu diesem Menüelement gehört.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Das Untermenü, das zu diesem Menüelement gehört.  
		 
		 <p>Wenn dieser Eigenschaft ein NativeMenu-Objekt zugewiesen wird, ändern sich Darstellung und Verhalten des Menüelements. Ein Untermenüelement zeigt das Untermenüsymbol an und löst keine select-Ereignisse mehr aus.</p>
         
        <p><b>Hinweis:</b> Wird ein Menü sich selbst als Untermenü hinzugefügt (Zirkelverweis), kann die Anwendung hängen bleiben.</p>
        
         </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenu"><apiName>NativeMenu</apiName><shortdesc>
     Die NativeMenu-Klasse enthält Methoden und Eigenschaften zur Definition von Menüs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     Die NativeMenu-Klasse enthält Methoden und Eigenschaften zur Definition von Menüs.
     
     <p>AIR unterstützt die folgenden Menütypen:</p>
     <adobetable class="innertable">
     
     
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>Menü</entry><entry>Instanz</entry><entry>Funktionstest</entry><entry>Unterstützt unter</entry><entry>Standard vorgegeben?</entry></row></thead><tbody><row><entry>Anwendung</entry><entry><codeph>NativeApplication.nativeApplication.menu</codeph></entry><entry><codeph>NativeApplication.supportsMenu</codeph></entry><entry>Mac OS X</entry><entry>Ja</entry></row><row><entry>Fenster</entry><entry><codeph>NativeWindow.menu</codeph></entry><entry><codeph>NativeWindow.supportsMenu</codeph></entry><entry>Windows, Linux</entry><entry>Nein</entry></row><row><entry>Dock-Symbol</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsDockIcon</codeph></entry><entry>Mac OS X</entry><entry>Ja</entry></row><row><entry>Symbol in der Systemleiste</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry><entry>Windows, Linux</entry><entry>Nein</entry></row><row><entry>Kontext</entry><entry><codeph>InteractiveObject.contextMenu</codeph></entry><entry>Immer unterstützt</entry><entry>Alle</entry><entry>Nein</entry></row><row><entry>Popup</entry><entry>Alle NativeMenu-Instanzen</entry><entry>Immer unterstützt</entry><entry>Alle</entry><entry>Nein</entry></row></tbody></tgroup></adobetable>
     
     <p>Ein Menü kann Elemente für Befehle, Untermenüs und Trennlinien enthalten. Menüelemente werden einem Menü mit den Methoden <codeph>addItem()</codeph>, <codeph>addItemAt()</codeph>, <codeph>addSubmenu()</codeph> und <codeph>addSubmenuAt()</codeph> hinzugefügt. Die Anzeigereihenfolge der Menüelemente entspricht der Reihenfolge der Elemente im <codeph>items</codeph>-Array des Menüs.</p>
      
     <p>Untermenüs werden ihrem übergeordneten Menü über die <codeph>submenu</codeph>-Eigenschaft des entsprechenden Menüelements im übergeordneten Menü zugeordnet. Das Stammmenü von Fenster- und Anwendungsmenüs darf nur Untermenüelemente enthalten. Elemente ohne Untermenüs dürfen nicht angezeigt werden, da dies den Erwartungen der Benutzer für diese Menütypen widersprechen würde.</p>
     
     <p>Menüs lösen <codeph>select</codeph>-Ereignisse aus, wenn ein Befehl im Menü oder in einem seiner Untermenüs ausgewählt wird. (Untermenü- und Trennlinienelemente können nicht ausgewählt werden.) Die <codeph>target</codeph>-Eigenschaft des Ereignisobjekts verweist auf das ausgewählte Element.</p>
     
     <p>Menüs lösen <codeph>displaying</codeph>-Ereignisse aus, unmittelbar bevor das Menü angezeigt wird. Sie können dieses Ereignis verwenden, um den Inhalt des Menüs auf Grundlage des aktuellen Anwendungsstatus zu aktualisieren.</p> 
     
     <p platform="actionscript"><b>Hinweis:</b> Ein Kontextmenü kann mit einem NativeMenu- oder einem ContextMenu-Objekt festgelegt werden. Flash Player unterstützt nur die ContextMenu-Klasse, nicht aber die NativeMenu-Klasse.
	 </p>
     
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>flash.display.InteractiveObject.contextMenu</linktext></link><link href="flash.display.xml#NativeMenuItem"><linktext>flash.display.NativeMenuItem</linktext></link><link href="flash.display.xml#NativeWindow/menu"><linktext>flash.display.NativeWindow.menu</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/menu"><linktext>flash.desktop.NativeApplication.menu</linktext></link><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Wird von diesem NativeMenu-Objekt ausgelöst, unmittelbar bevor das Menü angezeigt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Wird von diesem NativeMenu-Objekt ausgelöst, unmittelbar bevor das Menü angezeigt werden soll. 
     
     <p>Durch Warten auf dieses Ereignis kann das Menü vor der Anzeige aktualisiert werden. Auch displaying-Ereignisse werden von den Elementen in einem Menü ausgelöst.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Wird von diesem NativeMenu-Objekt ausgelöst, wenn eines seiner Menüelemente oder ein Element in einem seiner nachfolgenden Untermenüs ausgewählt wird.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Wird von diesem NativeMenu-Objekt ausgelöst, wenn eines seiner Menüelemente oder ein Element in einem seiner nachfolgenden Untermenüs ausgewählt wird. 
     
     <p>Ein select-Ereignis wird von diesem Menüelement bis zum übergeordneten Menü und weiter durch die Struktur bis zum Stamm-Menüobjekt gesendet (<i>Bubbling</i>). Die <codeph>target</codeph>-Eigenschaft des Ereignisobjekts verweist auf das ausgewählte NativeMenuItem-Objekt; die <codeph>currentTarget</codeph>-Eigenschaft verweist auf dieses NativeMenu-Objekt.</p>  
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:NativeMenu:addItem"><apiName>addItem</apiName><shortdesc>
         Fügt unten im Menü ein Menüelement hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn ein <codeph>item</codeph> <codeph>null</codeph> ist.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn <codeph>item</codeph> Mitglied eines anderen Menüs ist.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Das NativeMenuItem-Objekt, das im Menü unten hinzugefügt werden soll.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Fügt unten im Menü ein Menüelement hinzu.
         
         <p platform="actionscript">Beim Erstellen eines Kontextmenüs können Sie entweder NativeMenuItem- oder ContextMenuItem-Objekte hinzufügen. Es wrid jedoch empfohlen, dass Sie in einem Kontextmenü nur einen Objekttyp verwenden, damit alle Menüelemente über dieselben Eigenschaften verfügen.</p>
         
         <p><b>Hinweis:</b> Das Hinzufügen eines Elements zu einem Menü kann dazu führren, dass die Anwendung hängen bleibt, wenn das Untermenü des Elements auf das Menü selbst gesetzt ist (Zirkelverweis).</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addItemAt"><apiName>addItemAt</apiName><shortdesc>
         Fügt an der angegebenen Position ein Menüelement hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn ein <codeph>item</codeph> <codeph>null</codeph> ist.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn <codeph>item</codeph> Mitglied eines anderen Menüs ist.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn sich die Indexposition außerhalb der Grenzen des <codeph>items</codeph>-Arrays des Menüs befindet.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Das einzufügende NativeMenuItem-Objekt.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Position in einem Menü (auf null basierend), an der das Menüelement eingefügt wird.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Fügt an der angegebenen Position ein Menüelement hinzu.
         
         <p><b>Hinweis:</b> Das Hinzufügen eines Elements zu einem Menü kann dazu führren, dass die Anwendung hängen bleibt, wenn das Untermenü des Elements auf das Menü selbst gesetzt ist (Zirkelverweis).</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenu"><apiName>addSubmenu</apiName><shortdesc>
        Fügt dem Menü ein Untermenü hinzu, indem ein neues Menüelement eingefügt wird.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das für das Untermenü erstellte NativeMenuItem-Objekt. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>Das NativeMenu-Objekt, das das hinzuzufügende Untermenü definiert.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Bezeichnung, die für das hinzuzufügende Menüelement angezeigt werden soll.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Fügt dem Menü ein Untermenü hinzu, indem ein neues Menüelement eingefügt wird.
        
        <p>Das Aufrufen der <codeph>addSubMenuAt()</codeph>-Methode entspricht der Erstellung eines neuen Menüelements, das dem Menü hinzugefügt wird und dessen <codeph>submenu</codeph>-Eigenschaft ein NativeMenu-Objekt zugewiesen wird.</p>
        
        <p><b>Hinweis:</b> Wird ein Menü sich selbst als Untermenü hinzugefügt (Zirkelverweis), kann die Anwendung hängen bleiben.</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenuAt"><apiName>addSubmenuAt</apiName><shortdesc>
        Fügt dem Menü ein Untermenü hinzu, indem ein neues Menüelement an der angegebenen Position eingefügt wird.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das für das Untermenü erstellte NativeMenuItem-Objekt. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>Das NativeMenu-Objekt, das das hinzuzufügende Untermenü definiert.
        </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Position im <codeph>items</codeph>-Array dieses Menüs, an der das Menüelement hinzugefügt werden soll.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Bezeichnung, die für das hinzuzufügende Menüelement angezeigt werden soll.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Fügt dem Menü ein Untermenü hinzu, indem ein neues Menüelement an der angegebenen Position eingefügt wird.
        
        <p>Das Aufrufen der <codeph>addSubMenuAt()</codeph>-Methode entspricht der Erstellung eines neuen Menüelements, das an der gewünschten Position im Menü eingefügt wird und dessen <codeph>submenu</codeph>-Eigenschaft ein NativeMenu-Objekt zugewiesen wird.</p>
        
        <p><b>Hinweis:</b> Wird ein Menü sich selbst als Untermenü hinzugefügt (Zirkelverweis), kann die Anwendung hängen bleiben.</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:clone"><apiName>clone</apiName><shortdesc>
        
        Erstellt eine Kopie des Menüs und aller Elemente.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
        
        Erstellt eine Kopie des Menüs und aller Elemente.
        
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:containsItem"><apiName>containsItem</apiName><shortdesc>
         Gibt an, ob dieses Menü das angegebene Menüelement enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert ist <codeph>true</codeph>, wenn sich <codeph>item</codeph> in diesem Menü befindet.
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Das zu suchende NativeMenuItem-Objekt.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Gibt an, ob dieses Menü das angegebene Menüelement enthält.
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:display"><apiName>display</apiName><shortdesc>
        Blendet dieses Menü an der angegebenen Position ein.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stage</apiItemName><apiOperationClassifier>flash.display:Stage</apiOperationClassifier><apiDesc>Das Stage-Objekt, für das dieses Menü angezeigt werden soll.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Anzahl horizontaler Pixel in Bezug auf den Ursprungspunkt der Bühne, auf der dieses Menü angezeigt werden soll.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Anzahl vertikaler Pixel in Bezug auf den Ursprungspunkt der Bühne, auf der dieses Menü angezeigt werden soll.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
        Blendet dieses Menü an der angegebenen Position ein.
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemAt"><apiName>getItemAt</apiName><shortdesc>
         Ruft das Menüelement am angegebenen Index ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn sich <codeph>index</codeph> außerhalb der Grenzen des <codeph>items</codeph>-Arrays des Menüs befindet.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das NativeMenuItem-Objekt an der angegebenen Position im Menü.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die (auf null basierende) Position des zurückzugebenden Elements.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Ruft das Menüelement am angegebenen Index ab.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemByName"><apiName>getItemByName</apiName><shortdesc>
         Ruft das Menüelement mit dem angegebenen Namen ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das NativeMenuItem-Objekt mit dem angegebenen Namen oder <codeph>null</codeph>, wenn kein solches Element im Menü existiert.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der zu suchende String.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Ruft das Menüelement mit dem angegebenen Namen ab.
         
         <p><b>Hinweis:</b> Die <codeph>name</codeph>-Eigenschaft von Menüelementen wird standardmäßig nicht zugewiesen.</p>
            
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemIndex"><apiName>getItemIndex</apiName><shortdesc>
         Ruft die Position des angegebenen Elements ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die (auf null basierende) Position des angegebenen Elements in diesem Menü oder <codeph>null</codeph>, wenn das Element nicht in diesem Menü enthalten ist.
         
         </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Das zu suchende NativeMenuItem-Objekt.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Ruft die Position des angegebenen Elements ab. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeAllItems"><apiName>removeAllItems</apiName><shortdesc>
         Entfernt alle Elemente aus dem Menü.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
         Entfernt alle Elemente aus dem Menü.  
         
         
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItem"><apiName>removeItem</apiName><shortdesc>
         Entfernt das angegebene Menüelement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn <codeph>item</codeph> nicht in diesem Menü enthalten ist.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Das NativeMenuItem-Objekt, das aus diesem Menü entfernt werden soll.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Entfernt das angegebene Menüelement. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItemAt"><apiName>removeItemAt</apiName><shortdesc>
         Bewirkt, dass das Menüelement am angegebenen Index entfernt und zurückgegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn <codeph>index</codeph> sich außerhalb der Grenzen des <codeph>items</codeph>-Arrays des Menüs befindet.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das entfernte NativeMenuItem-Objekt.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die (auf null basierende) Position des zu entfernenden Elements.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Bewirkt, dass das Menüelement am angegebenen Index entfernt und zurückgegeben wird.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:setItemIndex"><apiName>setItemIndex</apiName><shortdesc>
         Verschiebt ein Menüelement an die angegebene Position.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn sich <codeph>index</codeph> außerhalb der Grenzen des <codeph>items</codeph>-Arrays des Menüs befindet.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Das zu verschiebende NativeMenuItem-Objekt.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die (auf null basierende) Position im Menü, an die <codeph>item</codeph> verschoben werden soll.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Verschiebt ein Menüelement an die angegebene Position. Ist dieses Element noch nicht im Menü enthalten, wird es diesem durch Aufrufen dieser Methode hinzugefügt.
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenu:items:get"><apiName>items</apiName><shortdesc>
         Das Array der NativeMenuItem-Objekte in diesem Menü.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         Das Array der NativeMenuItem-Objekte in diesem Menü.
         
         <p>Das Array wird in der Anzeigereihenfolge sortiert.</p>
         
         <p><i>Hinweis:</i> Diese Eigenschaft ist in AIR 1.0 schreibgeschützt. In AIR 1.1 wurde der Modus in Lesen/Schreiben geändert.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:numItems:get"><apiName>numItems</apiName><shortdesc>
         Die Anzahl der NativeMenuItem-Objekte in diesem Menü.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Die Anzahl der NativeMenuItem-Objekte in diesem Menü.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:parent:get"><apiName>parent</apiName><shortdesc>
         Das übergeordnete Menü.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         Das übergeordnete Menü.  
         
         <p>Der <codeph>parent</codeph>-Parameter des Stammmenü-Objekts (oberste Ebene) ist <codeph>null</codeph>.</p>
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
Die DisplayObjectContainer-Klasse ist die Basisklasse für alle Objekte, die in der Anzeigeliste als Anzeigeobjekt-Container eingesetzt werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Die abstrakte Basisklasse für alle Anzeigeobjekte, denen andere Objekte untergeordnet werden können.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
Die DisplayObjectContainer-Klasse ist die Basisklasse für alle Objekte, die in der Anzeigeliste als Anzeigeobjekt-Container eingesetzt werden können. Die Anzeigeliste verwaltet alle Objekte, die in Flash Player oder in Adobe AIR angezeigt werden. Um die Anzeigeobjekte innerhalb der Anzeigeliste anzuordnen, verwenden Sie die DisplayObjectContainer-Klasse. Jedes DisplayObjectContainer-Objekt besitzt seine eigene Child-Liste zum Organisieren der z-Reihenfolge der Objekte. Die z-Reihenfolge ist die Anordnung von vorne nach hinten und bestimmt, welches Objekt im Vordergrund angezeigt wird, welches dahinter usw. 
 
 <p>DisplayObject ist eine abstrakte Basisklasse. Daher können Sie DisplayObject nicht direkt aufrufen. Durch das Aufrufen von <codeph>new DisplayObject()</codeph> wird eine <codeph>ArgumentError</codeph>-Ausnahme ausgelöst.</p>
 
 Die DisplayObjectContainer-Klasse ist eine abstrakte Basisklasse für alle Objekte, denen andere Objekte untergeordnet werden können. Sie kann nicht direkt instanziiert werden. Beim Aufrufen des Konstruktors <codeph>new DisplayObjectContainer()</codeph> wird eine <codeph>ArgumentError</codeph>-Ausnahme ausgelöst.
 
 <p>Weitere Informationen finden Sie im Kapitel „Programmierung von Anzeigeobjekten“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
 
 </apiDesc><example conref="examples\DisplayObjectContainerExample.as"> Im folgenden Beispiel wird die Klasse <codeph>DisplayObjectContainerExample</codeph> verwendet, um nacheinander fünf orangefarbene Quadrate zu erstellen. Dies wird in den folgenden Schritten erreicht:
 
 <ol>
     <li>Der Konstruktor ruft die <codeph>configureAssets()</codeph>-Methode auf.</li>
 
  <li>Die <codeph>configureAssets()</codeph>-Methode erstellt <codeph>child</codeph>- und <codeph>lastChild</codeph>-Sprite-Objekte.</li>
 
    <li>Eine <codeph>for</codeph>-Schleife erstellt die fünf orangefarbenen Quadrate und ordnet sie nacheinander an.</li>
 
     <li>Immer wenn ein CustomSprite-Objekt erstellt wird, ruft der dazugehörige Konstruktor die <codeph>draw()</codeph>-Methode des <codeph>CustomSprite</codeph>-Objekts auf. Die Methode erstellt ein Quadrat der Größe 50 x 50 Pixel, indem sie die Methoden <codeph>beginFill()</codeph>, <codeph>drawRect()</codeph> und <codeph>endFill()</codeph> der Graphics-Klasse aufruft. Die <codeph>addChild()</codeph>-Methode fügt die einzelnen Quadrate der Anzeigeliste hinzu.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class DisplayObjectContainerExample extends Sprite {
        private var gutter:uint     = 5;
        private var childCount:uint = 5;

        public function DisplayObjectContainerExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var child:Sprite = new CustomSprite();
            var lastChild:Sprite = child;
            for (var i:uint = 1; i &lt;= childCount; i++) {
                child = new CustomSprite();
                child.x = lastChild.x + lastChild.width + gutter;
                addChild(child);
                lastChild = child;
            }
        }
    }
}

import flash.display.Sprite;

class CustomSprite extends Sprite {
    private var size:uint = 50;
    private var bgColor:uint = 0xFFCC00;

    public function CustomSprite() {
        draw(size, size);
    }

    private function draw(w:uint, h:uint):void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:DisplayObjectContainer:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
	Durch das Aufrufen des Konstruktors „new DisplayObjectContainer()“ wird eine ArgumentError-Ausnahme ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Durch das Aufrufen des Konstruktors <codeph>new DisplayObjectContainer()</codeph> wird eine <codeph>ArgumentError</codeph>-Ausnahme ausgelöst. Sie <i>können</i> jedoch Konstruktoren für die folgenden Unterklassen von „DisplayObjectContainer“ aufrufen:
	
	<ul>
	
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
 	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:DisplayObjectContainer:addChild"><apiName>addChild</apiName><shortdesc>
     Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird ausgelöst, wenn das untergeordnete Objekt mit dem übergeordneten Objekt identisch ist. Wird auch ausgelöst, wenn es sich beim Aufrufer um ein untergeordnetes Objekt (oder ein noch weiter untergeordnetes Objekt usw.) des hinzugefügten untergeordneten Objekts handelt.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die DisplayObject-Instanz, die Sie im Parameter <codeph>child</codeph> übergeben.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die DisplayObject-Instanz, die der DisplayObjectContainer-Instanz untergeordnet werden soll.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Fügt dieser DisplayObjectContainer-Instanz ein untergeordnetes Objekt hinzu.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. Die untergeordnete Instanz wird allen anderen untergeordneten Objekten dieser DisplayObjectContainer-Instanz an der ersten Position (also oben) hinzugefügt. (Um ein untergeordnetes Objekt an einer bestimmten Indexposition hinzuzufügen, verwenden Sie die <codeph>addChildAt()</codeph>-Methode.)
     
	 <p>Wenn Sie ein Child-Objekt hinzufügen, das bereits einem anderen Anzeigeobjektcontainer untergeordnet worden ist, wird es aus dessen Child-Liste entfernt. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> Im folgenden Beispiel werden zwei Sprite-Objekte mit den Namen <codeph>container1</codeph> und <codeph>container2</codeph> festgelegt. Bei einem Sprite-Objekt handelt es sich um eine Art von Anzeigeobjekt-Container. Das Beispiel ruft die <codeph>addChild()</codeph>-Methode auf, um die Anzeigehierarchie festzulegen: <codeph>container1</codeph> ist ein untergeordnetes Objekt von <codeph>container2</codeph>. Zwei andere Anzeigeobjekte, <codeph>circle1</codeph> und <codeph>circle2</codeph>, sind untergeordnete Objekte von <codeph>container1</codeph>. Die Aufrufe der <codeph>trace()</codeph>-Methode zeigen für die einzelnen Objekte jeweils die Anzahl der untergeordneten Objekte an. Dabei ist zu beachten, dass untergeordnete Objekte der Ebenen darunter für die <codeph>numChildren</codeph>-Anzahl nicht berücksichtigt werden:
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChild_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Objekt der Anzeigeliste hinzugefügt wird.
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Objekt der Anzeigeliste hinzugefügt wird.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird ausgelöst, wenn die Indexposition in der untergeordneten Liste nicht existiert.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Wird ausgelöst, wenn das untergeordnete Objekt mit dem übergeordneten Objekt identisch ist. Wird auch ausgelöst, wenn es sich beim Aufrufer um ein untergeordnetes Objekt (oder ein noch weiter untergeordnetes Objekt usw.) des hinzugefügten untergeordneten Objekts handelt.
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die DisplayObject-Instanz, die Sie im Parameter <codeph>child</codeph> übergeben.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die DisplayObject-Instanz, die der DisplayObjectContainer-Instanz untergeordnet werden soll.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Indexposition, an der die untergeordnete Instanz hinzugefügt wird. Wenn Sie eine gerade besetzte Indexposition angeben, werden das untergeordnete Objekt an dieser Stelle sowie alle darüber liegenden Positionen innerhalb der Child-Liste um eine Position nach oben verschoben. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Fügt dieser DisplayObjectContainer-Instanz ein untergeordnetes Objekt hinzu.
     
  	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. Das untergeordnete Objekt wird an der angegebenen Indexposition eingefügt. Die Indexposition 0 bezeichnet das hintere (untere) Ende der Anzeigeliste für dieses DisplayObjectContainer-Objekt.
	 
	 <p>Das folgende Beispiel enthält z. B. drei Anzeigeobjekte mit der Bezeichnung a, b und c jeweils an den Indexpositionen 0, 1 und 2:</p>
	 
	 <p><adobeimage alt="b über c über a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>Wenn Sie ein Child-Objekt hinzufügen, das bereits einem anderen Anzeigeobjektcontainer untergeordnet worden ist, wird es aus dessen Child-Liste entfernt. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.addChildAt.1.as"> Im folgenden Beispiel wird ein <codeph>container</codeph>-Anzeigeobjekt-Container erstellt und der dazugehörigen Anzeigeliste ein <codeph>circle1</codeph>-Objekt eines Anzeigeobjekts hinzugefügt. Durch das Aufrufen von <codeph>container.addChildAt(circle2, 0)</codeph> wird anschließend das <codeph>circle2</codeph>-Objekt an Indexposition null (im Hintergrund) hinzugefügt und das <codeph>circle1</codeph>-Objekt an Indexposition 1 verschoben:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
var circle2:Sprite = new Sprite();

container.addChild(circle1);
container.addChildAt(circle2, 0);

trace(container.getChildAt(0) == circle2); // true
trace(container.getChildAt(1) == circle1); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>addChild()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChildAt_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Objekt der Anzeigeliste hinzugefügt wird.
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Objekt der Anzeigeliste hinzugefügt wird.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:areInaccessibleObjectsUnderPoint"><apiName>areInaccessibleObjectsUnderPoint</apiName><shortdesc>
	 Gibt an, ob aufgrund der Sicherheitseinschränkungen irgendwelche Anzeigeobjekte aus der Liste ausgeschlossen werden, die beim Aufrufen der DisplayObjectContainer.getObjectsUnderPoint()-Methode mit dem angegebenen point-Punkt zurückgegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, wenn der Punkt untergeordnete Anzeigeobjekte mit Sicherheitseinschränkungen enthält.
	 
 	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt, unter dem nachgeschaut werden soll.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob aufgrund der Sicherheitseinschränkungen irgendwelche Anzeigeobjekte aus der Liste ausgeschlossen werden, die beim Aufrufen der <codeph>DisplayObjectContainer.getObjectsUnderPoint()</codeph>-Methode mit dem angegebenen <codeph>point</codeph>-Punkt zurückgegeben wird. Standardmäßig können Inhalte aus der Domäne nicht auf Objekte aus einer anderen Domäne zugreifen, wenn ihnen dies nicht durch den Aufruf der <codeph>Security.allowDomain()</codeph>-Methode ausdrücklich erlaubt worden ist. 
	 
	 <p>Weitere Informationen finden Sie in den folgenden Ressourcen: </p>
	 
     <ul>
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>     
     
	 <p>Der Parameter <codeph>point</codeph> befindet sich im Koordinatenraum der Bühne, der vom Koordinatenraum des Anzeigeobjekt-Containers abweichen kann (wenn der Anzeigeobjekt-Container nicht gerade die Bühne selbst ist). Mithilfe der Methoden <codeph>globalToLocal()</codeph> und <codeph>localToGlobal()</codeph> können Sie Punkte zwischen diesen Koordinatenräumen konvertieren.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.areInaccessibleObjectsUnderPoint.as"> Der folgende Code erstellt einen Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph>. Im nächste Codeblock wird ein Loader-Objekt verwendet, um eine JPEG-Datei mit dem Namen „test.jpg“ von einem Remote-Server zu laden. Beachten Sie, dass die <codeph>checkPolicyFile</codeph>-Eigenschaft des LoaderContext-Objekts, die in der <codeph>load()</codeph>-Methode als Parameter verwendet wird, auf <codeph>false</codeph> gesetzt ist. Nachdem die Datei geladen wurde, ruft der Code die <codeph>loaded()</codeph>-Methode auf, die wiederum <codeph>container.areInaccessibleObjectsUnderPoint()</codeph> aufruft, sodass der Wert <codeph>true</codeph> zurückgegeben wird, da angenommen wird, dass der Inhalt aus einer unzugänglichen Domäne stammt:
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.system.LoaderContext;
import flash.net.URLRequest;
import flash.events.Event;
import flash.geom.Point;

var container:Sprite = new Sprite();

var urlReq:URLRequest = new URLRequest("http://localhost/RemoteFile.swf");
var ldr:Loader = new Loader();
var context:LoaderContext = new LoaderContext();
context.checkPolicyFile = false;
ldr.load(urlReq, context);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);

function loaded(event:Event):void {
    var pt:Point = new Point(1, 1);
    trace(container.areInaccessibleObjectsUnderPoint(pt)); // true
}

function urlNotFound(event:Event):void {
    trace("The URL was not found."); 
}
</codeblock> Bei diesem Beispiel wird außerdem angenommen, dass die von diesem Code erzeugte SWF-Datei aus einer anderen Domäne als die der JPEG-Datei geladen wird und dass die geladene JPEG-Datei den Punkt (1, 1) einnimmt. 
</example></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getObjectsUnderPoint()"><linktext>getObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:contains"><apiName>contains</apiName><shortdesc>
	 Ermittelt, ob das angegebene Anzeigeobjekt der DisplayObjectContainer-Instanz oder der Instanz selbst untergeordnet ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ist auf <codeph>true</codeph> eingestellt, wenn das <codeph>child</codeph>-Objekt ein untergeordnetes Objekt der DisplayObjectContainer-Instanz oder des Containers selbst ist. Andernfalls ist <codeph>false</codeph> eingestellt.
	 
	  
	  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Das zu prüfende untergeordnete Objekt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ermittelt, ob das angegebene Anzeigeobjekt der DisplayObjectContainer-Instanz oder der Instanz selbst untergeordnet ist. Die Suche umfasst die gesamte Anzeigeliste einschließlich dieser DisplayObjectContainer-Instanz. Für Objekte, die über mehrere Ebenen hinweg untergeordnet sind, wird der Wert <codeph>true</codeph> zurückgegeben.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.contains.1.as"> Im folgenden Beispiel werden einige Sprite-Objekte eingerichtet und in einigen Fällen der Child-Liste von anderen Objekten hinzugefügt. (Bei einem Sprite-Objekt handelt es sich um eine Art von Anzeigeobjekt-Container.) Die Beziehung zwischen verschiedenen Objekten wird angezeigt, indem die <codeph>contains()</codeph>-Methode aufgerufen wird:
<codeblock>
import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();
var sprite4:Sprite = new Sprite();

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite1.contains(sprite1)); // true
trace(sprite1.contains(sprite2)); // true
trace(sprite1.contains(sprite3)); // true
trace(sprite1.contains(sprite4)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildAt"><apiName>getChildAt</apiName><shortdesc>
     Gibt die untergeordnete Anzeigeobjektinstanz zurück, die sich an der angegebenen Indexposition befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird ausgelöst, wenn der Index in der Child-Liste nicht existiert.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Das untergeordnete Anzeigeobjekt ist Teil einer Sicherheits-Sandbox, auf die Sie keinen Zugriff haben. Sie können diese Situation vermeiden, indem Sie im untergeordneten Film die <codeph>Security.allowDomain()</codeph>-Methode aufrufen.
     
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das untergeordnete Anzeigeobjekt an der angegebenen Indexposition.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Indexposition des untergeordneten Objekts.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt die untergeordnete Anzeigeobjektinstanz zurück, die sich an der angegebenen Indexposition befindet.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildAt.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt, und der Child-Liste des <codeph>container</codeph>-Objekts werden dann drei Anzeigeobjekte hinzugefügt. Die Aufrufe der <codeph>getChildAt()</codeph>-Methode zeigen für die einzelnen untergeordneten Objekte jeweils die Position an:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();

container.addChild(sprite1);
container.addChild(sprite2);
container.addChildAt(sprite3, 0);

trace(container.getChildAt(0) == sprite3); // true
trace(container.getChildAt(1) == sprite1); // true
trace(container.getChildAt(2) == sprite2); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildByName()"><linktext>getChildByName()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildByName"><apiName>getChildByName</apiName><shortdesc>
     Gibt das untergeordnete Anzeigeobjekt für den angegebenen Namen zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Das untergeordnete Anzeigeobjekt ist Teil einer Sicherheits-Sandbox, auf die Sie keinen Zugriff haben. Sie können diese Situation vermeiden, indem Sie den untergeordneten Film die <codeph>Security.allowDomain()</codeph>-Methode aufrufen lassen.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das untergeordnete Anzeigeobjekt für den angegebenen Namen.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des untergeordneten Objekts, das zurückgegeben werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt das untergeordnete Anzeigeobjekt für den angegebenen Namen zurück. Wenn mehrere untergeordnete Anzeigeobjekte den angegebenen Namen aufweisen, gibt die Methode das erste Objekt in der Child-Liste zurück.
     
	 <p>Die <codeph>getChildAt()</codeph>-Methode ist schneller als die <codeph>getChildByName()</codeph>-Methode. Die <codeph>getChildAt()</codeph>-Methode greift über ein zwischengespeichertes Array auf ein untergeordnetes Objekt zu, während die <codeph>getChildByName()</codeph>-Methode eine verknüpfte Liste durchlaufen muss, um auf ein untergeordnetes Objekt zuzugreifen.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt, dem dann zwei untergeordnete Anzeigeobjekte hinzugefügt werden. Der Code ruft anschließend die Methoden <codeph>getChildByName()</codeph> und <codeph>getChildIndex()</codeph> auf, um die Indexposition für das untergeordnete Objekt des <codeph>container</codeph>-Objekts zurückzugeben, für das <codeph>name "sprite1"</codeph> gilt.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildAt()"><linktext>getChildAt()</linktext></link><link href="flash.display.xml#DisplayObject/name"><linktext>flash.display.DisplayObject.name</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildIndex"><apiName>getChildIndex</apiName><shortdesc>
     Gibt die Indexposition einer untergeordneten DisplayObject-Instanz zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird ausgelöst, wenn der child-Parameter kein untergeordnetes Objekt dieses Objekts ist.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die Indexposition des untergeordneten Anzeigeobjekts, das identifiziert werden soll.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die DisplayObject-Instanz, die identifiziert werden soll.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Indexzahl einer child-DisplayObject-Instanz zurück.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Gibt die Indexposition einer <codeph>child</codeph>-DisplayObject-Instanz zurück.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt, dem dann zwei untergeordnete Anzeigeobjekte hinzugefügt werden. Der Code ruft anschließend die Methoden <codeph>getChildByName()</codeph> und <codeph>getChildIndex()</codeph> auf, um die Indexposition für das untergeordnete Objekt des <codeph>container</codeph>-Objekts zurückzugeben, für das <codeph>name "sprite1"</codeph> gilt.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getObjectsUnderPoint"><apiName>getObjectsUnderPoint</apiName><shortdesc>
     Gibt ein Array an Objekten zurück, die unter dem angegebenen Punkt liegen und dieser DisplayObjectContainer-Instanz untergeordnet sind (auch über mehrere Unterordnungsstufen hinweg).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Array an Objekten, die unter dem angegebenen Punkt liegen und dieser DisplayObjectContainer-Instanz untergeordnet sind (auch über mehrere Unterordnungsstufen hinweg).
     
 	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt, unter dem nachgeschaut werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt ein Array an Objekten zurück, die unter dem angegebenen Punkt liegen und dieser DisplayObjectContainer-Instanz untergeordnet sind (auch über mehrere Unterordnungsstufen hinweg). Untergeordnete Objekte, die aus Sicherheitsgründen nicht zugänglich sind, sind in dem zurückgegebenen Array ausgelassen. Um festzustellen, ob sich diese Sicherheitseinschränkung auf das zurückgegebene Array auswirkt, rufen Sie die <codeph>areInaccessibleObjectsUnderPoint()</codeph>-Methode auf.
	 
	 <p>Der Parameter <codeph>point</codeph> befindet sich im Koordinatenraum der Bühne, der vom Koordinatenraum des Anzeigeobjekt-Containers abweichen kann (wenn der Anzeigeobjekt-Container nicht gerade die Bühne selbst ist). Mithilfe der Methoden <codeph>globalToLocal()</codeph> und <codeph>localToGlobal()</codeph> können Sie Punkte zwischen diesen Koordinatenräumen konvertieren.</p>
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getObjectsUnderPoint.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt, dem dann zwei überlappende untergeordnete Anzeigeobjekte hinzugefügt werden. Der Code ruft <codeph>getObjectsUnderPoint()</codeph> zweimal auf (zuerst unter Verwendung eines Punkts, der nur ein Objekt berührt, und dann mit einem Punkt, an dem die Objekte überlappen) und der <codeph>length</codeph>-Wert des zurückgegebenen Arrays zeigt die Anzahl an Objekten für die einzelnen Punkte des Containers an:
<codeblock>
import flash.display.Sprite;
import flash.geom.Point;

var container:Sprite = new Sprite();

var square1:Sprite = new Sprite();
square1.graphics.beginFill(0xFFCC00);
square1.graphics.drawRect(0, 0, 40, 40);

var square2:Sprite = new Sprite();
square2.graphics.beginFill(0x00CCFF);
square2.graphics.drawRect(20, 0, 30, 40);

container.addChild(square1);
container.addChild(square2);

var pt:Point = new Point(10, 20);
var objects:Array = container.getObjectsUnderPoint(pt); 
trace(objects.length); // 1

pt = new Point(35, 20);
objects = container.getObjectsUnderPoint(pt);
trace(objects.length);  // 2
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/areInaccessibleObjectsUnderPoint()"><linktext>areInaccessibleObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChild"><apiName>removeChild</apiName><shortdesc>
	 Entfernt die angegebene untergeordnete DisplayObject-Instanz aus der Child-Liste der DisplayObjectContainer-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird ausgelöst, wenn der child-Parameter kein untergeordnetes Objekt dieses Objekts ist.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die DisplayObject-Instanz, die Sie im Parameter <codeph>child</codeph> übergeben.
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die zu entfernende DisplayObject-Instanz.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Entfernt ein child-Anzeigeobjekt aus der DisplayObjectContainer-Instanz.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Entfernt die angegebene <codeph>child</codeph>-DisplayObject-Instanz aus der Child-Liste der DisplayObjectContainer-Instanz. Die <codeph>parent</codeph>-Eigenschaft des entfernten untergeordneten Objekts wird auf <codeph>null</codeph> gesetzt, und das Objekt wird vom Garbage Collector entfernt, wenn keine anderen Verweise auf das untergeordnete Objekt existieren. Die Indexpositionen von Anzeigeobjekten über dem untergeordneten Objekt im Anzeigeobjekt-Container werden um jeweils 1 herabgesetzt.
	 
	 <p>Der Garbage Collector weist nicht verwendete Speicherkapazität neu zu. Wenn auf Variablen oder Objekte nicht mehr aktiv verwiesen wird und diese auch nirgends mehr gespeichert sind, werden sie vom Garbage Collector entfernt, und der belegte Arbeitsspeicher wird bereinigt.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChild.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt, dem dann zwei untergeordnete Anzeigeobjekte hinzugefügt werden. Dem <codeph>container</codeph>-Objekt wird ein Ereignis-Listener hinzugefügt, damit beim Klicken auf das untergeordnete Objekt des Containers durch Benutzer die <codeph>removeChild()</codeph>-Methode verwendet wird, um das untergeordnete Objekt zu entfernen, auf das über die Child-Liste des Containers geklickt wurde:
<codeblock>
 
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);

container.addChild(circle1);
container.addChild(circle2);

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    container.removeChild(DisplayObject(event.target)); 
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 Entfernt ein untergeordnetes Anzeigeobjekt aus der angegebenen Indexposition in der Child-Liste des Anzeigeobjekt-Containers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Das untergeordnete Anzeigeobjekt ist Teil einer Sicherheits-Sandbox, auf die das aufrufende Objekt keinen Zugriff hat. Sie können diese Situation vermeiden, indem Sie den untergeordneten Film die <codeph>Security.allowDomain()</codeph>-Methode aufrufen lassen.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wird ausgelöst, wenn der Index in der Child-Liste nicht existiert.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die entfernte DisplayObject-Instanz.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Child-Indexposition des zu entfernenden Anzeigeobjekts.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Entfernt an der angegebenen <codeph>index</codeph>-Position ein untergeordnetes Anzeigeobjekt aus der DisplayObjectContainer-Instanz.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Entfernt ein untergeordnetes Anzeigeobjekt aus der angegebenen <codeph>index</codeph>-Position in der Child-Liste des Anzeigeobjekt-Containers. Die <codeph>parent</codeph>-Eigenschaft des entfernten untergeordneten Objekts wird auf <codeph>null</codeph> gesetzt, und das Objekt wird vom Garbage Collector entfernt, wenn keine anderen Verweise auf das untergeordnete Objekt existieren. Die Indexpositionen von Anzeigeobjekten über dem untergeordneten Objekt im Anzeigeobjekt-Container werden um jeweils 1 herabgesetzt.
	 
	 <p>Der Garbage Collector weist nicht verwendete Speicherkapazität neu zu. Wenn auf Variablen oder Objekte nicht mehr aktiv verwiesen wird und diese auch nirgends mehr gespeichert sind, werden sie vom Garbage Collector entfernt, und der belegte Arbeitsspeicher wird bereinigt.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChildAt.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt, dem dann zwei untergeordnete Anzeigeobjekte hinzugefügt werden. Der Code zeigt, dass beim Aufrufen der <codeph>removeChildAt()</codeph>-Methode zum Entfernen des untergeordneten Objekts an der untersten Indexposition (0) alle anderen untergeordneten Objekte der Liste um eine Position nach unten verschoben werden:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.numChildren) // 2
container.removeChildAt(0); 
trace(container.numChildren) // 1
trace(container.getChildAt(0).name); // sprite2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	Ändert die Position eines vorhandenen untergeordneten Objekts im Anzeigeobjekt-Container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird ausgelöst, wenn der Index in der Child-Liste nicht existiert.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Wird ausgelöst, wenn der child-Parameter kein untergeordnetes Objekt dieses Objekts ist.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die child-DisplayObject-Instanz, deren Indexnummer Sie ändern möchten.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die resultierende Indexnummer für das <codeph>child</codeph>-Anzeigeobjekt.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Ändert die Indexzahl eines vorhandenen untergeordneten Objekts.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Ändert die Position eines vorhandenen untergeordneten Objekts im Anzeigeobjekt-Container. Dies wirkt sich auf die Anordnung der untergeordneten Objekte aus. Das folgende Beispiel enthält z. B. drei Anzeigeobjekte mit der Bezeichnung a, b und c jeweils an den Indexpositionen 0, 1 und 2:
	
	<p><adobeimage alt="c über b über a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>Wenn Sie die <codeph>setChildIndex()</codeph>-Methode verwenden und eine bereits belegte Indexposition angeben, werden nur die Positionen zwischen der alten und der neuen Position des Anzeigeobjekts geändert. Alle anderen Positionen bleiben unverändert. Wenn ein untergeordnetes Objekt an eine NIEDRIGERE Indexposition als bisher verschoben wird, werden alle dazwischen liegenden untergeordneten Objekte für den Indexverweis um 1 ERHÖHT. Wenn ein untergeordnetes Objekt an eine HÖHERE Indexposition als bisher verschoben wird, werden alle dazwischen liegenden untergeordneten Objekte für den Indexverweis um 1 VERRINGERT. Wenn der Anzeigeobjekt-Container im vorigen Beispiel z. B. den Namen <codeph>container</codeph> hat, können Sie die Position der Anzeigeobjekte mit den Bezeichnungen a und b austauschen, indem Sie den folgenden Code aufrufen:</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>Dieser Code führt zur folgenden Objektanordnung:</p>
	
    <p><adobeimage alt="c über a über b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc><example conref="examples\DisplayObjectContainer.setChildIndex.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt, dem dann drei leicht überlappende untergeordnete Anzeigeobjekte hinzugefügt werden. Wenn Benutzer auf eines dieser Objekte klicken, ruft die <codeph>clicked()</codeph>-Methode die <codeph>setChildIndex()</codeph>-Methode auf, um das entsprechende Objekt in der Child-Liste des <codeph>container</codeph>-Objekts an die oberste Position zu verschieben:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.addEventListener(MouseEvent.CLICK, clicked);
 
var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(100, 40, 40);
circle2.addEventListener(MouseEvent.CLICK, clicked);
 
var circle3:Sprite = new Sprite();
circle3.graphics.beginFill(0x0000FF);
circle3.graphics.drawCircle(70, 80, 40);
circle3.addEventListener(MouseEvent.CLICK, clicked);
 
container.addChild(circle1);
container.addChild(circle2);
container.addChild(circle3);
addChild(container);
 
function clicked(event:MouseEvent):void {
    var circle:Sprite = Sprite(event.target);
    var topPosition:uint = container.numChildren - 1;
    container.setChildIndex(circle, topPosition);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getChildIndex()"><linktext>getChildIndex()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildren"><apiName>swapChildren</apiName><shortdesc>
	 Kehrt die z-Reihenfolge (von vorne nach hinten) der beiden angegebenen untergeordneten Objekte um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird ausgelöst, wenn keiner der beiden child-Parameter diesem Objekt untergeordnet ist.
	 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Das erste untergeordnete Objekt.
	 
     </apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Das zweite untergeordnete Objekt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Kehrt die z-Reihenfolge (von vorne nach hinten) der beiden angegebenen untergeordneten Objekte um. Alle anderen untergeordneten Objekte im Anzeigeobjekt-Container bleiben auf derselben Indexposition.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildren.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt. Im nächsten Schritt werden dem Container dann zwei untergeordnete Anzeigeobjekte hinzugefügt, und es wird gezeigt, wie sich das Aufrufen der <codeph>swapChildren()</codeph>-Methode auswirkt:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2

container.swapChildren(sprite1, sprite2);

trace(container.getChildAt(0).name); // sprite2
trace(container.getChildAt(1).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 Kehrt die z-Reihenfolge (von vorne nach hinten) der untergeordneten Objekte an den beiden angegebenen Indexpositionen in der Child-Liste um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn beide Indizes in der Child-Liste nicht existieren.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Indexposition des ersten untergeordneten Objekts.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Indexposition des zweiten untergeordneten Objekts.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Kehrt die z-Reihenfolge (von vorne nach hinten) der untergeordneten Objekte an den beiden angegebenen Indexpositionen in der Child-Liste um. Alle anderen untergeordneten Objekte im Anzeigeobjekt-Container bleiben auf derselben Indexposition.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildrenAt.1.as"> Im folgenden Beispiel wird ein Anzeigeobjekt-Container mit dem Namen <codeph>container</codeph> erstellt. Im nächsten Schritt werden dem Container dann drei untergeordnete Anzeigeobjekte hinzugefügt, und es wird gezeigt, wie das Aufrufen der <codeph>swapChildrenAt()</codeph>-Methode eine neue Anordnung der Child-Liste des Anzeigeobjekt-Containers durchführt.
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

container.addChild(sprite1);
container.addChild(sprite2);
container.addChild(sprite3);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite3

container.swapChildrenAt(0, 2);

trace(container.getChildAt(0).name); // sprite3
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:DisplayObjectContainer:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Maus aktivierbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Maus aktivierbar sind. Ist ein Objekt per Maus aktivierbar, kann ein Benutzer damit in Interaktion treten, indem er eine Maus verwendet. Der Standardwert lautet <codeph>true</codeph>.
	 
	 <p>Diese Eigenschaft ist praktisch, wenn Sie eine Schaltfläche mit einer Instanz der Sprite-Klasse (anstelle der SimpleButton-Klasse) erstellen. Wenn Sie zum Erstellen einer Schaltfläche eine Sprite-Instanz verwenden, können Sie die Schaltfläche ausrüsten und mithilfe der <codeph>addChild()</codeph>-Methode zusätzliche Sprite-Instanzen hinzufügen. Dieser Vorgang kann zu unerwarteten Verhaltensweisen bei Mausereignissen führen, da die untergeordneten Sprite-Instanzen zum Zielobjekt eines Mausereignisses werden können, wenn eigentlich die übergeordnete Instanz des Zielobjekts erwartet wird. Um sicherzustellen, dass die übergeordnete Instanz als Zielobjekt für Mausereignisse dient, können Sie die <codeph>mouseChildren</codeph>-Eigenschaft der übergeordneten Instanz auf <codeph>false</codeph> setzen.</p>
	 <p> Durch das Festlegen dieser Eigenschaft wird kein Ereignis ausgelöst. Um interaktive Funktionalität zu erzielen, müssen Sie die <codeph>addEventListener()</codeph>-Methode verwenden.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.mouseChildren.1.as"> Im folgenden Beispiel wird ein Sprite-Objekt (eine Art von Anzeigeobjekt-Container) mit dem Namen <codeph>container</codeph> eingerichtet. Daran wird gezeigt, dass, wenn Sie dessen <codeph>mouseChildren</codeph>-Eigenschaft auf <codeph>false</codeph> setzen, das Ziel eines <codeph>mouseClick</codeph>-Ereignisses das <codeph>container</codeph>-Objekt ist, anstatt eines der untergeordneten Objekte:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
container.name = "container";
addChild(container);

var circle:Sprite = new Sprite();
circle.name = "circle";
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);

container.addChild(circle);

container.mouseChildren = false;

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace(event.target.name); // container
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>flash.display.Sprite.buttonMode</linktext></link><link href="flash.events.xml#EventDispatcher/addEventListener()"><linktext>flash.events.EventDispatcher.addEventListener()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObjectContainer:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 Liefert die Anzahl der Objekte, die diesem Objekt untergeordnet sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Liefert die Anzahl der Objekte, die diesem Objekt untergeordnet sind.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> Im folgenden Beispiel werden zwei Sprite-Objekte mit den Namen <codeph>container1</codeph> und <codeph>container2</codeph> festgelegt. Bei einem Sprite-Objekt handelt es sich um eine Art von Anzeigeobjekt-Container. Das Beispiel ruft die <codeph>addChild()</codeph>-Methode auf, um die Anzeigehierarchie festzulegen: <codeph>container1</codeph> ist ein untergeordnetes Objekt von <codeph>container2</codeph>. Zwei andere Anzeigeobjekte, <codeph>circle1</codeph> und <codeph>circle2</codeph>, sind untergeordnete Objekte von <codeph>container1</codeph>. Die Aufrufe der <codeph>trace()</codeph>-Methode zeigen für die einzelnen Objekte jeweils die Anzahl der untergeordneten Objekte an. Dabei ist zu beachten, dass untergeordnete Objekte der Ebenen darunter für die <codeph>numChildren</codeph>-Anzahl nicht berücksichtigt werden:
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Tabulatortaste aktivierbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Beim Aufrufen dieser Eigenschaft für das Stage-Objekt wird eine Ausnahme ausgelöst. Das Stage-Objekt hat diese Eigenschaft nicht implementiert.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Tabulatortaste aktivierbar sind. Aktiviert oder deaktiviert die Möglichkeit zur Auswahl von untergeordneten Objekten mithilfe der Tabulatortaste. Der Standardwert lautet <codeph>true</codeph>.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.tabChildren.1.as"> Im folgenden Beispiel wird ein <codeph>container1</codeph>-Anzeigeobjekt-Container erstellt, und der dazugehörigen Anzeigeliste werden zwei Anzeigeobjekte hinzugefügt, <codeph>circle1</codeph> and <codeph>circle2</codeph>. Im Beispiel wird „tabChildren“ für die untergeordneten Objekte auf <codeph>false</codeph> gesetzt, damit mithilfe von <codeph>tabIndex</codeph> eine eigene Tabulatorreihenfolge verwaltet werden kann:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();
container.tabChildren = false;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.tabIndex = 1;

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);
circle2.tabIndex = 0;

container.addChild(circle1);
container.addChild(circle2);
</codeblock> Kompilieren Sie die Datei, und führen Sie sie aus, um die Ergebnisse dieses Beispiels anzuzeigen. Wenn Sie auf einen der Kreise klicken, können Sie die Tabulatortaste drücken, um den Fokus für die Anzeigeobjekte zu wechseln (wird durch ein gelbes Hervorhebungsrechteck angezeigt).
</example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
     Liefert ein TextSnapshot-Objekt für diese DisplayObjectContainer-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier></apiValueDef><apiDesc>
     Liefert ein TextSnapshot-Objekt für diese DisplayObjectContainer-Instanz.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.textSnapshot.1.as"> Das folgende Beispiel funktioniert nur in der Authoring-Umgebung von Flash. Flex enthält keine Möglichkeit zum Hinzufügen von statischem Text zu einer Datei. Fügen Sie dem ersten Bild eines Films ein oder mehrere Felder mit statischem Text hinzu, um die Flash-Datei für dieses Beispiel vorzubereiten. Fügen Sie dann das folgende Skript in das erste Bild ein, und führen Sie die Datei aus. Es wird der statische Text ausgegeben, den Sie hinzugefügt haben:
<codeblock>
trace(this.textSnapshot.getText(0, this.textSnapshot.charCount));
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot"><linktext>flash.text.TextSnapshot</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
 Legt eine Farbverlaufsfüllung fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Legt eine Farbverlaufsfüllung fest. 
 
 <p>
 Verwenden Sie ein GraphicsGradientFill-Objekt mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode. Das Zeichnen eines GraphicsGradientFill-Objekts entspricht dem Aufrufen der <codeph>Graphics.beginGradientFill()</codeph>-Methode.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsGradientFill:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
     Erstellt ein neues GraphicsGradientFill-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>linear</apiData><apiDesc>Ein Wert aus der GradientType-Klasse, mit dem angegeben wird, welcher Farbverlaufstyp verwendet werden soll: <codeph>GradientType.LINEAR</codeph> oder <codeph>GradientType.RADIAL</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit hexadezimalen RGB-Farbwerten, die im Farbverlauf verwendet werden (beispielsweise 0xFF0000 für Rot, 0x0000FF für Blau usw.). Sie können bis zu 15 Farben angeben. Definieren Sie für jede Farbe einen entsprechenden Wert in den Parametern „alphas“ und „ratios“.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit Alphawerten für die entsprechenden Farben im Array „colors“. Gültig sind Werte von 0 bis 1. Ist der Wert kleiner als 0, wird 0 verwendet. Ist der Wert größer als 1, wird 1 verwendet.
     
     </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit Farbverteilungsverhältnissen. Zulässig sind Werte zwischen 0 und 255. Dieser Wert gibt den Breitenanteil an, in dem die Farbe mit 100 % gesampelt wird. Der Wert 0 stellt die linke Position im Farbverlaufsfeld dar, 255 die rechte. 
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine Transformationsmatrix, wie sie von der flash.geom.Matrix-Klasse definiert wird. Die flash.geom.Matrix-Klasse umfasst eine <codeph>createGradientBox()</codeph>-Methode, mit der Sie die Matrix zur Verwendung mit der <codeph>beginGradientFill()</codeph>-Methode auf einfache Weise festlegen können.
     
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>pad</apiData><apiDesc>Ein Wert aus der SpreadMethod-Klasse, der festlegt, welche Auftragstärke zu verwenden ist: <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> oder <codeph>SpreadMethod.REPEAT</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiType value=""/><apiData>rgb</apiData><apiDesc>Ein Wert der InterpolationMethod-Klasse, der festlegt, welcher Wert verwendet werden soll: <codeph>InterpolationMethod.LINEAR_RGB</codeph> oder <codeph>InterpolationMethod.RGB</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiType value=""/><apiData>0.0</apiData><apiDesc>Eine Zahl, die die Position des Farbverlaufsbrennpunkts steuert. Mit dem Wert 0 wird der Brennpunkt auf die Mitte gesetzt. Der Wert 1 bedeutet, dass der Brennpunkt an einem Rand des Farbverlaufskreises liegt. Der Wert -1 bedeutet, dass der Brennpunkt am anderen Rand des Farbverlaufskreises liegt. Werte, die kleiner als -1 oder größer als 1 sind, werden auf -1 bzw. 1 gerundet.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues GraphicsGradientFill-Objekt.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsGradientFill:alphas"><apiName>alphas</apiName><shortdesc>
     Ein Array mit Alphawerten für die entsprechenden Farben im colors-Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array mit Alphawerten für die entsprechenden Farben im colors-Array. Gültig sind Werte zwischen 0 und 1. Ist der Wert kleiner als 0, wird 0 verwendet. Ist der Wert größer als 1, wird 1 verwendet.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:colors"><apiName>colors</apiName><shortdesc>
     Ein Array mit den im Farbverlauf zu verwendenden RGB-Hexadezimalfarbwerten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array mit den im Farbverlauf zu verwendenden RGB-Hexadezimalfarbwerten. Rot beispielsweise hat den Wert 0xFF0000, Blau den Wert 0x0000FF usw. Sie können bis zu 15 Farben angeben. Definieren Sie für jede Farbe einen entsprechenden Wert in den Eigenschaften „alphas“ und „ratios“.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:focalPointRatio"><apiName>focalPointRatio</apiName><shortdesc>
     Eine Zahl, die die Position des Farbverlaufsbrennpunkts steuert. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Eine Zahl, die die Position des Farbverlaufsbrennpunkts steuert. Mit dem Wert 0 wird der Brennpunkt auf die Mitte gesetzt. Der Wert 1 bedeutet, dass der Brennpunkt an einem Rand des Farbverlaufskreises liegt. Der Wert -1 setzt den Brennpunkt an den anderen Rand es Farbverlaufskreises. Werte, die kleiner als -1 oder größer als 1 sind, werden auf -1 bzw. 1 gerundet. Im folgenden Beispiel ist <codeph>focalPointRatio</codeph> z. B. auf 0,75 gesetzt:
     
     <p><adobeimage alt="Radialer Farbverlauf mit focalPointRatio-Wert von 0,75" href="../../images/radial_sketch.jpg"/> </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:matrix"><apiName>matrix</apiName><shortdesc>
     Eine Transformationsmatrix, wie sie in der Matrix-Klasse definiert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Eine Transformationsmatrix, wie sie in der Matrix-Klasse definiert ist. Die flash.geom.Matrix-Klasse umfasst eine <codeph>createGradientBox()</codeph>-Methode, mit der Sie die Matrix zur Verwendung mit der <codeph>beginGradientFill()</codeph>-Methode festlegen können.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:ratios"><apiName>ratios</apiName><shortdesc>
     Ein Array von Farbverteilungsverhältnissen. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Ein Array von Farbverteilungsverhältnissen. Gültig sind Werte zwischen 0 und 255. Dieser Wert gibt den Breitenanteil an, in dem die Farbe mit 100 % gesampelt wird. Der Wert 0 repräsentiert die linke Position im Farbverlaufsfeld, der Wert 255 repräsentiert die rechte. 
     
     <p><b>Hinweis:</b> Dieser Wert repräsentiert Positionen im Farbverlaufsfeld, nicht im Koordinatenraum des endgültigen Farbverlaufs, der breiter oder schmaler als das Farbverlaufsfeld sein kann. Geben Sie für jeden Wert in der <codeph>colors</codeph>-Eigenschaft einen entsprechenden Wert an. </p>
     
     <p>Die folgende Abbildung zeigt für einen linearen Verlauf mit den zwei Farben blau und grün die Farbplatzierung im Verlauf basierend auf den verschiedenen Werten im <codeph>ratios</codeph>-Array:</p>
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Gradient</entry></row></thead><tbody><row>
     
      <entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 0 und 127" href="../../images/gradient-ratios-1.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 0 und 255" href="../../images/gradient-ratios-2.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 127 und 255" href="../../images/gradient-ratios-3.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     <p>Die Werte im Array müssen sich sequenziell erhöhen. Beispiel: <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:interpolationMethod:get"><apiName>interpolationMethod</apiName><shortdesc>
     Ein Wert aus der InterpolationMethod-Klasse, der festlegt, welcher Wert zu verwenden ist. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert aus der InterpolationMethod-Klasse, der festlegt, welcher Wert zu verwenden ist. Gültige Werte sind: <codeph>InterpolationMethod.LINEAR_RGB</codeph> und <codeph>InterpolationMethod.RGB</codeph>
     
     <p>Das folgende Beispiel zeigt einen einfachen linearen Farbverlauf zwischen zwei Farben (wobei der <codeph>spreadMethod</codeph>-Parameter auf <codeph>SpreadMethod.REFLECT</codeph> gesetzt ist). Die verschiedenen Interpolationsmethoden haben die folgenden Auswirkungen auf die Darstellung des Farbverlaufs: </p>
     
      <adobetable>
      
      
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
      </row><row>
      <entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
      <entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
      </row></tbody></tgroup></adobetable>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:spreadMethod:get"><apiName>spreadMethod</apiName><shortdesc>
     Ein Wert aus der SpreadMethod-Klasse, der festlegt, welche Auftragstärke zu verwenden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert aus der SpreadMethod-Klasse, der festlegt, welche Auftragstärke zu verwenden ist. Gültige Werte sind: <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> und <codeph>SpreadMethod.REPEAT</codeph>. 
     
     <p>Das folgende Beispiel zeigt einen einfachen linearen Farbverlauf zwischen zwei Farben:</p>
     
     <codeblock>
     import flash.geom.*
     import flash.display.*
     var fillType:String = GradientType.LINEAR;
     var colors:Array = [0xFF0000, 0x0000FF];
     var alphas:Array = [1, 1];
     var ratios:Array = [0x00, 0xFF];
     var matr:Matrix = new Matrix();
     matr.createGradientBox(20, 20, 0, 0, 0);
     var spreadMethod:String = SpreadMethod.PAD;
     this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       
     this.graphics.drawRect(0,0,100,100);
     </codeblock>
     
      <p>Dieses Beispiel verwendet <codeph>SpreadMethod.PAD</codeph> als Methode für die Auftragstärke, und der Farbverlauf sieht folgendermaßen aus:</p>
     
      <p><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
     
      <p>Mit der Auftragstärke <codeph>SpreadMethod.REFLECT</codeph> sieht die Farbverlaufsfüllung folgendermaßen aus:</p>
     
      <p><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
     
      <p>Mit der Auftragstärke <codeph>SpreadMethod.REPEAT</codeph> sieht die Farbverlaufsfüllung folgendermaßen aus:</p>
     
      <p><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:type:get"><apiName>type</apiName><shortdesc>
     Ein Wert aus der GradientType-Klasse, der angibt, welcher Farbverlaufstyp verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert aus der GradientType-Klasse, der angibt, welcher Farbverlaufstyp verwendet wird. Zulässige Werte sind <codeph>GradientType.LINEAR</codeph> und <codeph>GradientType.RADIAL</codeph>. 
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Sprite"><apiName>Sprite</apiName><shortdesc>
 Die Sprite-Klasse ist ein Grundbaustein der Anzeigeliste: ein Knoten der Anzeigeliste, der Grafiken anzeigen und auch untergeordnete Objekte enthalten kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Das grundlegende Anzeigeobjekt für mit ActionScript erstellte Objekte.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Sprite-Klasse ist ein Grundbaustein der Anzeigeliste: ein Knoten der Anzeigeliste, der Grafiken anzeigen und auch untergeordnete Objekte enthalten kann.
 
 <p>Ein Sprite-Objekt ähnelt einem Movieclip, besitzt aber keine Zeitleiste. Sprite ist die angemessene Basisklasse für Objekte, die keine Zeitleiste benötigen. So wäre Sprite etwa die logische Basisklasse für Komponenten der Benutzeroberfläche (UI, User Interface), die in der Regel keine Zeitleiste verwenden.</p>
 
 <p>Die Sprite-Klasse ist neu in ActionScript 3.0. Sie bietet eine Alternative zur Funktionalität der MovieClip-Klasse, die die gesamte Funktionalität früherer ActionScript-Versionen beibehält, um die Abwärtskompatibilität zu gewährleisten.</p>
 
 </apiDesc><example conref="examples\SpriteExample.as"> Im folgenden Beispiel wird die SpriteExample-Klasse verwendet, um auf der Bühne ein orangefarbenes Quadrat zu zeichnen. Es werden dann jeweils Ereignisse ausgelöst, wenn Benutzer auf das Quadrat klicken oder es verschieben. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Im Beispiel wird die <codeph>size</codeph>-Eigenschaft (100 x 100 Pixel) und die Hintergrundfarbe (Orange) zur späteren Verwendung beim Zeichnen des Quadrats deklariert.</li>
 
  <li>Der Konstruktor erstellt anschließend ein neues <codeph>child</codeph>-Sprite-Objekt und verwendet es, um zwei Ereignis-Listener und die dazugehörigen Methoden hinzuzufügen: <codeph>mouseDownHandler()</codeph> und <codeph>mouseUpHandler()</codeph>.</li>
 
  <li>Das <codeph>child</codeph>-Sprite-Objekt wird dann an die <codeph>draw()</codeph>-Methode übergeben, die das orangefarbene Quadrat zeichnet.</li>
 
  <li>Das child-Objekt wird in die Anzeigeliste eingefügt, indem die <codeph>addChild()</codeph>-Methode aufgerufen wird. </li>
 
  <li>Die Ereignis-Listener funktionieren wie folgt:
 
  <ul>
      <li><codeph>mouseDownHandler()</codeph>: Wenn Benutzer auf das Sprite-Objekt klicken, fügt diese Methode einen mouseMove-Ereignis-Listener hinzu (die <codeph>mouseMoveHandler()</codeph>-Methode), der die Mausbewegungen verarbeitet. Als Nächstes wird die <codeph>startDrag()</codeph>-Methode aufgerufen, die das Ziehen des Sprite-Objekts ermöglicht.</li>
 
      <li><codeph>mouseUpHandler()</codeph>: Wenn die Maustaste losgelassen wird, wird der mouseMove-Ereignis-Listener entfernt, und die <codeph>stopDrag()</codeph>-Methode wird aufgerufen, die das orangefarbene Quadrat an seiner Position fixiert.</li>
 
      <li><codeph>mouseMoveHandler</codeph>: Solange die linke Maustaste gedrückt gehalten wird, weist diese Methode den Player an, das orangefarbene Quadrat neu zu zeichnen.</li>
 
  </ul>
  </li>
 
 </ol>
 
 <p><b>Hinweis: </b> Jede Ereignis-Listener-Methode deklariert eine lokale <codeph>sprite</codeph>-Variable, der die <codeph>target</codeph>-Eigenschaft des Ereignisses zugewiesen wird.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;

    public class SpriteExample extends Sprite {
        private var size:uint    = 100;
        private var bgColor:uint = 0xFFCC00;

        public function SpriteExample() {
            var child:Sprite = new Sprite();
            child.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
            child.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
            draw(child);
            addChild(child);
        }

        private function mouseDownHandler(event:MouseEvent):void {
            trace("mouseDownHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.startDrag();
        }

        private function mouseUpHandler(event:MouseEvent):void {
            trace("mouseUpHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.stopDrag();
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            trace("mouseMoveHandler");
            event.updateAfterEvent();
        }

        private function draw(sprite:Sprite):void {
            sprite.graphics.beginFill(bgColor);
            sprite.graphics.drawRect(0, 0, size, size);
            sprite.graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:Sprite:Sprite"><apiName>Sprite</apiName><shortdesc>
	Erstellt eine neue Sprite-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Erstellt eine neue Sprite-Instanz. Nachdem Sie die Sprite-Instanz erstellt haben, rufen Sie die Methode <codeph>DisplayObjectContainer.addChild()</codeph> oder <codeph>DisplayObjectContainer.addChildAt()</codeph> auf, um die Sprite-Instanz einem übergeordneten „DisplayObjectContainer“ hinzuzufügen.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:Sprite:startDrag"><apiName>startDrag</apiName><shortdesc>
	 Ermöglicht es Benutzern, das angegebene Sprite mit einer Ziehoperation zu verschieben.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.startDrag, startDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lockCenter</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Legt fest, ob das ziehbare Sprite am Mittelpunkt der Mausposition (<codeph>true</codeph>) oder an der Stelle einrastet, an der der Benutzer zum ersten Mal auf das Sprite geklickt hat (<codeph>false</codeph>). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>bounds</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Wert, der zu den Koordinaten des dem Sprite übergeordneten Objekts relativ ist und ein begrenzendes Rechteck für das Sprite angibt. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ermöglicht es Benutzern, das angegebene Sprite mit einer Ziehoperation zu verschieben. Das Sprite bleibt so lange ziehbar, bis die Freigabe durch einen Aufruf der <codeph>Sprite.stopDrag()</codeph>-Methode aufgehoben wird oder bis ein anderes Sprite als ziehbares Objekt definiert wird. Es kann jeweils nur ein Sprite ziehbar sein.
	 <p>Dreidimensionale Anzeigeobjekte folgen der Maus, und <codeph>Sprite.startDrag()</codeph> bewegt das Objekt innerhalb des dreidimensionalen Raums, der durch das Anzeigeobjekt festgelegt ist. Oder, wenn es sich bei dem Anzeigeobjekt um ein zweidimensionales Objekt handelt, das einem dreidimensionalen Objekt untergeordnet ist, bewegt sich das zweidimensionale Objekt innerhalb des dreidimensionalen Raums, der durch das übergeordnete dreidimensionale Objekt festgelegt ist.</p>
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> Im folgenden Beispiel werden ein <codeph>circle</codeph>-Sprite und zwei <codeph>target</codeph>-Sprites erstellt. Die <codeph>startDrag()</codeph>-Methode wird für das <codeph>circle</codeph>-Sprite aufgerufen, wenn Benutzer den Cursor auf das Sprite bewegen und die Maustaste drücken, und die <codeph>stopDrag()</codeph>-Methode wird aufgerufen, wenn Benutzer die Maustaste loslassen. Ermöglicht es Benutzern, das Sprite mit einer Ziehoperation zu verschieben. Wenn der Benutzer die Maustaste loslässt, wird die <codeph>mouseRelease()</codeph>-Methode aufgerufen, die wiederum den <codeph>name</codeph>-Wert des <codeph>dropTarget</codeph>-Objekts verfolgt (das Objekt, auf das der Benutzer das <codeph>circle</codeph>-Sprite gezogen hat):
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Sprite:stopDrag"><apiName>stopDrag</apiName><shortdesc>
	 Beendet die startDrag()-Methode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sprite, movieclip.stopDrag, stopDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Beendet die <codeph>startDrag()</codeph>-Methode. Ein Sprite, das mit der <codeph>startDrag()</codeph>-Methode ziehbar gemacht wurde, bleibt so lange ziehbar, bis die <codeph>stopDrag()</codeph>-Methode hinzugefügt oder ein anderes Sprite ziehbar gemacht wird. Es kann jeweils nur ein Sprite ziehbar sein.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> Im folgenden Beispiel werden ein <codeph>circle</codeph>-Sprite und zwei <codeph>target</codeph>-Sprites erstellt. Die <codeph>startDrag()</codeph>-Methode wird für das <codeph>circle</codeph>-Sprite aufgerufen, wenn Benutzer den Cursor auf das Sprite bewegen und die Maustaste drücken, und die <codeph>stopDrag()</codeph>-Methode wird aufgerufen, wenn Benutzer die Maustaste loslassen. Ermöglicht es Benutzern, das Sprite mit einer Ziehoperation zu verschieben. Wenn der Benutzer die Maustaste loslässt, wird die <codeph>mouseRelease()</codeph>-Methode aufgerufen, die wiederum den <codeph>name</codeph>-Wert des <codeph>dropTarget</codeph>-Objekts verfolgt (das Objekt, auf das der Benutzer das <codeph>circle</codeph>-Sprite gezogen hat):
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Sprite:buttonMode:get"><apiName>buttonMode</apiName><shortdesc>
     Legt den Schaltflächenmodus für dieses Sprite fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Legt den Schaltflächenmodus für dieses Sprite fest.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Legt den Schaltflächenmodus für dieses Sprite fest. Wenn <codeph>true</codeph> eingestellt ist, verhält sich dieses Sprite wie eine Schaltfläche. Dies bedeutet, dass die Anzeige des Handcursors ausgelöst wird, wenn die Maus über das Sprite bewegt wird, und ein <codeph>click</codeph>-Ereignis empfangen werden kann, wenn die Eingabe- oder Leertaste gedrückt wird, während das Sprite den Fokus besitzt. Sie können die Anzeige des Handcursors unterdrücken, indem Sie die <codeph>useHandCursor</codeph>-Eigenschaft auf <codeph>false</codeph> setzen. In diesem Fall wird der Pfeilcursor angezeigt.
     
     <p>Obwohl es besser ist, für die Erstellung von Schaltflächen die SimpleButton-Klasse zu verwenden, können Sie die <codeph>buttonMode</codeph>-Eigenschaft nutzen, um einem Sprite eine schaltflächenähnliche Funktionalität zu verleihen. Um ein Sprite in die Tabulatorreihenfolge einzubinden, setzen Sie die <codeph>tabEnabled</codeph>-Eigenschaft (wurde von der InteractiveObject-Klasse geerbt und ist standardmäßig auf <codeph>false</codeph> gesetzt) auf <codeph>true</codeph>. Zudem sollten Sie sich überlegen, ob die dem Sprite untergeordneten Objekte per Maus aktivierbar sein sollen. Bei den meisten Schaltflächen ist für die untergeordneten Objekte keine Mausinteraktivität aktiviert, da dies beim Ereignisablauf zu Verwirrung führen kann. Um die Mausinteraktivität für alle untergeordneten Objekte zu aktivieren, müssen Sie die <codeph>mouseChildren</codeph>-Eigenschaft auf <codeph>false</codeph> setzen (wird von der DisplayObjectContainer-Klasse übernommen).</p>
     
     <p>Wenn Sie die <codeph>buttonMode</codeph>-Eigenschaft mit der MovieClip-Klasse verwenden (die eine Unterklasse der Sprite-Klasse ist), kann es sein, dass Ihre Schaltfläche zusätzliche Funktionen besitzt. Wenn Sie die Bilder mit den Bezeichnungen „_up“ (auf), „_over“ (darüber) und „_down“ (gedrückt) einschließen, bietet Flash Player automatische Stausänderungen (eine Funktionalität, die in früheren ActionScript-Versionen für Movieclips bereitgestellt wurde, die als Schaltflächen verwendet werden). Diese automatischen Statusänderungen sind für Sprites nicht verfügbar, da diese keine Zeitleiste und somit auch keine Bildbezeichnungen besitzen. </p>
	 
	 </apiDesc><example conref="examples\Sprite.buttonMode.1.as"> Im folgenden Beispiel werden zwei Sprites erstellt, und die <codeph>buttonMode</codeph>-Eigenschaft wird einmal auf <codeph>true</codeph> und einmal auf <codeph>false</codeph> gesetzt. Wenn Sie die Anwendung kompilieren und ausführen, reagieren beide Sprites auf Mausereignisse, aber nur das Sprite, für das <codeph>buttonMode</codeph> auf <codeph>true</codeph> gesetzt ist, verwendet den Handcursor und ist in der Tabulatorreihenfolge enthalten:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton"><linktext>SimpleButton</linktext></link><link href="flash.display.xml#Sprite/useHandCursor"><linktext>Sprite.useHandCursor</linktext></link><link href="flash.display.xml#InteractiveObject/tabEnabled"><linktext>InteractiveObject.tabEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:dropTarget:get"><apiName>dropTarget</apiName><shortdesc>
	 Gibt das Anzeigeobjekt an, über das der Sprite gezogen wird oder auf dem der Sprite abgelegt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Sprite, Sprite.dropTarget, dropTarget
	 
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Legt das Anzeigeobjekt (DisplayObject) fest, über das das Sprite gezogen bzw. auf dem es abgelegt wird.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Gibt das Anzeigeobjekt an, über das der Sprite gezogen wird oder auf dem der Sprite abgelegt wurde.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> Im folgenden Beispiel werden ein <codeph>circle</codeph>-Sprite und zwei <codeph>target</codeph>-Sprites erstellt. Die <codeph>startDrag()</codeph>-Methode wird für das <codeph>circle</codeph>-Sprite aufgerufen, wenn Benutzer den Cursor auf das Sprite bewegen und die Maustaste drücken, und die <codeph>stopDrag()</codeph>-Methode wird aufgerufen, wenn Benutzer die Maustaste loslassen. Ermöglicht es Benutzern, das Sprite mit einer Ziehoperation zu verschieben. Wenn der Benutzer die Maustaste loslässt, wird die <codeph>mouseRelease()</codeph>-Methode aufgerufen, die wiederum den <codeph>name</codeph>-Wert des <codeph>dropTarget</codeph>-Objekts verfolgt (das Objekt, auf das der Benutzer das <codeph>circle</codeph>-Sprite gezogen hat):
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:graphics:get"><apiName>graphics</apiName><shortdesc>
     Legt das Graphics-Objekt fest, das zu diesem Sprite gehört und für das Vektorzeichnungsbefehle zulässig sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Legt ein Graphics-Objekt fest.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Legt das Graphics-Objekt fest, das zu diesem Sprite gehört und für das Vektorzeichnungsbefehle zulässig sind.
     
	 </apiDesc><example conref="examples\Sprite.graphics.1.as"> Im folgenden Beispiel wird ein <codeph>circle</codeph>-Sprite erstellt und seine <codeph>graphics</codeph>-Eigenschaft verwendet, um einen Kreis mit einer gelben Füllung (0xFFCC00) zu zeichnen:
<codeblock>
import flash.display.Sprite;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:hitArea:get"><apiName>hitArea</apiName><shortdesc>
	 Gibt als Kollisionsbereich für ein Sprite ein anderes Sprite an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Sprite</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt als Kollisionsbereich für ein Sprite ein anderes Sprite an. Wenn die <codeph>hitArea</codeph>-Eigenschaft nicht vorhanden ist oder den Wert <codeph>null</codeph> oder <codeph>undefined</codeph> aufweist, wird das Sprite selbst als Kollisionsbereich verwendet. Der Wert der <codeph>hitArea</codeph>-Eigenschaft kann ein Verweis auf ein Sprite-Objekt sein.
	 
	 <p>Die <codeph>hitArea</codeph>-Eigenschaft kann jederzeit geändert werden. Das geänderte Sprite übernimmt sofort das neue Verhalten des Kollisionsbereichs. Das als Kollisionsbereich bestimmte Sprite braucht nicht sichtbar zu sein. Auch wenn es unsichtbar ist, wird seine grafische Form dennoch als Kollisionsbereich erkannt.</p>
	 
	 <p><b>Hinweis:</b> Sie müssen die <codeph>mouseEnabled</codeph>-Eigenschaft des als Kollisionsbereich vorgesehenen Sprites auf <codeph>false</codeph> setzen. Sonst kann es vorkommen, dass Ihre Sprite-Schaltfläche nicht funktioniert, da nicht Ihre Sprite-Schaltfläche, sondern das als Kollisionsbereich bestimmte Sprite die Mausereignisse empfängt.</p>
	 
	 </apiDesc><example conref="examples\Sprite.hitArea.1.as"> Im folgenden Beispiel werden ein <codeph>circle</codeph>-Sprite und ein <codeph>square</codeph>-Sprite erstellt. Das <codeph>square</codeph>-Sprite dient als <codeph>hitArea</codeph> für das <codeph>circle</codeph>-Sprite. Wenn Benutzer auf das <codeph>square</codeph>-Sprite klicken, löst das <codeph>circle</codeph>-Sprite ein <codeph>click</codeph>-Ereignis aus:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xCCFF00);
square.graphics.drawRect(200, 0, 100, 100);

circle.hitArea = square;
square.mouseEnabled = false;

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void{
    trace(event.target == circle); // true
    trace(event.target == square); // false
}

addChild(circle);
addChild(square);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Steuert den Sound innerhalb dieses Sprites.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Steuert den Sound innerhalb dieses Sprites.
	 
	 </apiDesc><example conref="examples\Sprite.soundTransform.1.as"> Im folgenden Beispiel wird ein Sprite mit dem Namen <codeph>container</codeph> erstellt und seiner Liste der untergeordneten Objekte ein Loader-Objekt hinzugefügt. Das Loader-Objekt lädt eine SWF-Datei. Wenn Benutzer im Textfeld <codeph>tf</codeph> durch Klicken auf den Link <codeph>true</codeph> auswählen, legt die <codeph>mute()</codeph>-Methode die <codeph>volume</codeph>-Eigenschaft der <codeph>soundTransform</codeph>-Eigenschaft des <codeph>container</codeph>-Sprites fest:
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.events.IOErrorEvent;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.text.TextField;
import flash.media.SoundTransform;

var container:Sprite = new Sprite();
addChild(container);

var ldr:Loader = new Loader;
var urlReq:URLRequest = new URLRequest("SoundPlayer.swf");
ldr.load(urlReq);

container.addChild(ldr);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);
            
var tf:TextField = new TextField();
tf.htmlText = "&lt;a href = 'event:Mute'>Mute / Unmute&lt;/a>";
addChild(tf);

var mySoundTransform:SoundTransform = new SoundTransform();
mySoundTransform.volume = 1;

tf.addEventListener(MouseEvent.CLICK, mute);

function mute(event:MouseEvent):void {    
    if (mySoundTransform.volume == 0) {
        mySoundTransform.volume = 1;
    } else {
        mySoundTransform.volume = 0;        
    }
    container.soundTransform = mySoundTransform;
}

function urlNotFound(event:IOErrorEvent):void {
    trace("The URL was not found."); 
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
	 Ein boolescher Wert, der angibt, ob der Handcursor angezeigt werden soll, wenn die Maus über ein Sprite-Objekt geführt wird, dessen buttonMode-Eigenschaft auf „true“ gesetzt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Ein boolescher Wert, der angibt, ob der Handcursor angezeigt werden soll, wenn die Maus über ein Sprite-Objekt geführt wird, dessen buttonMode-Eigenschaft auf „true“ gesetzt ist. 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein boolescher Wert, der angibt, ob der Handcursor angezeigt werden soll, wenn die Maus über ein Sprite geführt wird, in dem die <codeph>buttonMode</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt ist. Der Standardwert für die <codeph>useHandCursor</codeph>-Eigenschaft lautet <codeph>true</codeph>. Wenn <codeph>useHandCursor</codeph> auf <codeph>true</codeph> gesetzt ist, erscheint der für Schaltflächen verwendete Handcursor, wenn Benutzer die Maus auf ein Schaltflächen-Sprite bewegen. Wenn <codeph>useHandCursor</codeph> auf <codeph>false</codeph> gesetzt ist, wird stattdessen der Pfeilcursor verwendet.
	 
	 <p>Die <codeph>useHandCursor</codeph>-Eigenschaft kann jederzeit geändert werden. Das geändert Sprite übernimmt sofort das neue Cursorverhalten. </p>
     
     <p product="flex"><b>Hinweis:</b> Wenn das Sprite untergeordnete Sprites enthält, empfiehlt es sich möglicherweise, die <codeph>mouseChildren</codeph>-Eigenschaft auf <codeph>false</codeph> zu setzen. Wenn beispielsweise ein Handcursor über einer Flex-Steuerung &lt;mx:Label> eingeblendet werden soll, stellen Sie die Eigenschaften <codeph>useHandCursor</codeph> und <codeph>buttonMode</codeph> auf <codeph>true</codeph> und die Eigenschaft <codeph>mouseChildren</codeph> auf <codeph>false</codeph> ein.</p>
	 
	 </apiDesc><example conref="examples\Sprite.useHandCursor.1.as"> Im folgenden Beispiel werden zwei Sprites erstellt, für die die <codeph>buttonMode</codeph>-Eigenschaft jeweils auf <codeph>true</codeph> gesetzt wird. Die <codeph>useHandCursor</codeph>-Eigenschaft wird jedoch einmal auf <codeph>true</codeph> und einmal auf <codeph>false</codeph> gesetzt. Wenn Sie die Anwendung kompilieren und ausführen, reagieren beide Sprites als Schaltflächen (und sind in der Tabulatorreihenfolge enthalten), aber nur das Sprite, für das <codeph>useHandCursor</codeph> auf <codeph>true</codeph> gesetzt ist, verwendet den Handcursor:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.useHandCursor = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = true;
circle2.useHandCursor = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>buttonMode</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
 Legt eine Bitmapfüllung fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Legt eine Bitmapfüllung fest. Die Bitmap kann zum Füllen des Bereichs geglättet, wiederholt oder als Kachelmuster dargestellt oder mithilfe einer Transformationsmatrix manipuliert werden.
 <p>
 Verwenden Sie ein GraphicsBitmapFill-Objekt mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode. Das Zeichnen eines GraphicsBitmapFill-Objekts entspricht dem Aufrufen der <codeph>Graphics.beginBitmapFill()</codeph>-Methode.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsBitmapFill:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
     Erstellt ein neues GraphicsBitmapFill-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine transparente oder undurchsichtige Bitmap, die die anzuzeigenden Bits enthält.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Matrix-Objekt (der flash.geom.Matrix-Klasse), mit dem Sie Transformationen der Bitmap definieren können.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Wenn <codeph>true</codeph> eingestellt ist, wird die Bitmap in einem Kachelmuster wiederholt. Bei <codeph>false</codeph> wird die Bitmap nicht wiederholt, und die Kanten der Bitmap werden für alle Füllbereiche verwendet, die über die Bitmap hinausgehen. 
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Wenn <codeph>false</codeph> eingestellt ist, werden vergrößerte Bitmapbilder mithilfe des „Nächster-Nachbar-Algorithmus“ wiedergegeben. Meist sind dann die einzelnen Pixelpunkte zu sehen. Wenn <codeph>true</codeph> eingestellt ist, werden vergrößerte Bitmapbilder anhand eines bilinearen Algorithmus wiedergegeben. Die Wiedergabe mit dem „Nächster-Nachbar-Algorithmus“ ist in der Regel schneller.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues GraphicsBitmapFill-Objekt.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsBitmapFill:bitmapData"><apiName>bitmapData</apiName><shortdesc>
     Ein transparentes oder undurchsichtiges Bitmapbild.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
     Ein transparentes oder undurchsichtiges Bitmapbild.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:matrix"><apiName>matrix</apiName><shortdesc>
     Ein Matrixobjekt (der flash.geom.Matrix-Klasse), das Transformationen der Bitmap definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Ein Matrixobjekt (der flash.geom.Matrix-Klasse), das Transformationen der Bitmap definiert. Die folgende Matrix z. B. dreht eine Bitmap um 45 Grad (pi/4 rad).
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:repeat"><apiName>repeat</apiName><shortdesc>
     Legt fest, ob ein Bitmapbild in einem Kachelmuster wiederholt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Legt fest, ob ein Bitmapbild in einem Kachelmuster wiederholt wird.
     
     <p>
     Wenn <codeph>true</codeph> eingestellt ist, wird die Bitmap in einem Kachelmuster wiederholt. Bei <codeph>false</codeph> wird die Bitmap nicht wiederholt, und die Pixel entlang der äußersten Kanten der Bitmap werden für alle Füllbereiche verwendet, die über die Grenzen der Bitmap hinausgehen.</p>
     
     <p>Nehmen Sie die folgende Bitmap (ein Schachbrettmuster im Format 20 x 20 Pixel) als Beispiel:</p>
     
     <p><adobeimage alt="Schachbrettmuster im Format 20 x 20 Pixel" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
     
     <p>Ist <codeph>repeat</codeph> auf <codeph>true</codeph> gesetzt (wie im folgenden Beispiel), wiederholt die Bitmap-Füllung die Bitmap:</p>
     
     <p><adobeimage alt="Schachbrettmuster im Format 60 x 60 Pixel" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
     
     <p>Ist <codeph>repeat</codeph> auf <codeph>false</codeph> gesetzt, verwendet die Bitmapfüllung die Randpixel für den Füllbereich außerhalb der Bitmap:</p>
     
     <p><adobeimage alt="60-x-60-Pixel-Bild ohne Wiederholung" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsBitmapFill:smooth"><apiName>smooth</apiName><shortdesc>
     Legt fest, ob ein Glättungsalgorithmus auf das Bitmapbild angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Legt fest, ob ein Glättungsalgorithmus auf das Bitmapbild angewendet wird.
     <p>
     Wenn <codeph>false</codeph> eingestellt ist, werden aufwärts skalierte Bilder mithilfe des „Nächster-Nachbar-Algorithmus“ wiedergegeben. Meist sind dann die einzelnen Pixelpunkte zu sehen. Wenn <codeph>true</codeph> eingestellt ist, werden aufwärts skalierte Bilder anhand eines bilinearen Algorithmus wiedergegeben. Eine Wiedergabe mithilfe des „Nächster-Nachbar-Algorithmus“ ist in der Regel schneller.
     </p>
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Definiert einen Linienstil oder Strich.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsStroke</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Definiert einen Linienstil oder Strich. 
 
 <p>
 Verwenden Sie ein GraphicsStroke-Objekt mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode. Das Zeichnen eines GraphicsStroke-Objekts entspricht dem Aufrufen einer der Methoden der Graphics-Klasse, die den Linienstil festlegt, wie z. B. die <codeph>Graphics.lineStyle()</codeph>-Methode, die <codeph>Graphics.lineBitmapStyle()</codeph>Methode oder die <codeph>Graphics.lineGradientStyle()</codeph>-Methode.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>flash.display.Graphics.lineBitmapStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsStroke:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Erstellt ein neues GraphicsStroke-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Eine Ganzzahl, die die Stärke der Linie in Punkt angibt. Gültig sind Werte von 0 bis 255. Wenn keine Zahl angegeben ist oder wenn der Parameter den Wert „undefined“ aufweist, wird keine Linie gezeichnet. Wenn ein kleinerer Wert als 0 übergeben wird, ist der Standardwert 0. Der Wert 0 steht für die geringste Linienstärke. Der Höchstwert beträgt 255. Wenn ein größerer Wert als 255 übergeben wird, ist der Standardwert 255. 
 
 </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein boolescher Wert, der angibt, ob Striche als ganze Pixel angezeigt werden. Dies wirkt sich sowohl auf die Positionen der Anker einer Kurve als auch auf die Linienstärke des Strichs selbst aus. Wenn <codeph>pixelHinting</codeph> auf <codeph>true</codeph> gesetzt ist, stellt Flash Player die Linienstärken auf volle Pixel ein. Ist <codeph>pixelHinting</codeph> auf <codeph>false</codeph> gesetzt, können Kurven und gerade Linien unterbrochen sein. In den folgenden Abbildungen wird veranschaulicht, wie Flash Player zwei Rechtecke mit abgerundeten Ecken darstellt, die identisch sind, abgesehen davon, dass der <codeph>pixelHinting</codeph>-Parameter in der <codeph>lineStyle()</codeph>-Methode anders eingestellt ist (die Abbildungen sind um 200 % vergrößert, um den Unterschied deutlich zu zeigen):
 
 <p><adobeimage alt="pixelHinting-Einstellungen „false“ und „true“" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 <p>Wird kein Wert angegeben, wird die Funktion nicht verwendet.</p>
  
 </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>Ein Wert aus der LineScaleMode-Klasse, mit dem angegeben wird, welcher Skalierungsmodus verwendet werden soll:
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph>: Die Linienstärke wird immer skaliert, wenn das Objekt skaliert wird (der Standard).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph>: Die Linienstärke wird nie skaliert.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph>: Die Linienstärke wird nicht skaliert, wenn das Objekt <i>nur</i> vertikal skaliert wurde. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.VERTICAL</codeph> gesetzt wurde. Der Kreis links wurde nur vertikal skaliert, und der Kreis rechts wurde sowohl vertikal als auch horizontal skaliert.
 
 <p><adobeimage alt="Ein nur vertikal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph>: Die Linienstärke wird nicht skaliert, wenn das Objekt <i>nur</i> vertikal skaliert wurde. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.HORIZONTAL</codeph> gesetzt wurde. Der Kreis links wurde nur horizontal skaliert, und der Kreis rechts wurde sowohl horizontal als auch vertikal skaliert.
 
 <p><adobeimage alt="Ein nur horizontal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 
 </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Ein Wert der CapsStyle-Klasse, der den Stil der Linienenden definiert. Folgende Werte sind zulässig: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> und <codeph>CapsStyle.SQUARE</codeph>. Wird kein Wert angegeben, verwendet Flash runde Enden. 
 <p>Die folgende Abbildung zeigt beispielsweise die verschiedenen Einstellungen für <codeph>capsStyle</codeph>. Die Abbildung zeigt für jede Einstellung eine blaue Linie mit der Stärke 30 (für die <codeph>capsStyle</codeph> gilt) sowie eine überlagerte schwarze Linie mit der Stärke 1 (für die kein <codeph>capsStyle</codeph> gilt):
 </p>
 <p><adobeimage alt="NONE, ROUND und SQUARE" href="../../images/linecap.jpg"/></p>
 
 </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>round</apiData><apiDesc>Ein Wert der JointStyle-Klasse, der den Verbindungsstil für Winkel festlegt. Folgende Werte sind zulässig: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> und <codeph>JointStyle.ROUND</codeph>. Wird kein Wert angegeben, verwendet Flash runde Verbindungen. 
 
 <p>Die folgende Abbildung zeigt beispielsweise die verschiedenen Einstellungen für <codeph>joints</codeph>. Die Abbildung zeigt für jede Einstellung eine blaue Winkellinie mit der Stärke 30 (für die <codeph>jointStyle</codeph> gilt) sowie eine überlagerte schwarze Winkellinie mit der Stärke 1 (für die kein <codeph>jointStyle</codeph> gilt):
 </p>
 
 <p><adobeimage alt="MITER, ROUND und BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Hinweis:</b> Ist <codeph>joints</codeph> auf <codeph>JointStyle.MITER</codeph> gesetzt, können Sie den Parameter <codeph>miterLimit</codeph> verwenden, um die Länge des Winkels einzuschränken.</p>
 
 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3.0</apiData><apiDesc>Eine Zahl, die die Grenze festlegt, an der ein Winkel abgeschnitten wird. Gültige Werte liegen zwischen 1 und 255 (Werte außerhalb dieses Bereichs werden auf 1 bzw. 255 gerundet). Dieser Wert wird nur dann verwendet, wenn <codeph>jointStyle</codeph> auf <codeph>"miter"</codeph> gesetzt wird. Der Wert <codeph>miterLimit</codeph> steht für die Länge, die ein Winkel über jenen Punkt hinausgehen kann, an dem zwei Linien eine Verbindung bilden. Der Wert drückt einen Faktor der Linieneigenschaft <codeph>thickness</codeph> aus. Bei einem <codeph>miterLimit</codeph>-Faktor von 2,5 und einer <codeph>thickness</codeph> von 10 Pixeln, wird der Winkel bei 25 Pixeln abgeschnitten. 
 
 <p>Betrachten Sie beispielsweise die folgenden Winkellinien mit einer <codeph>thickness</codeph> von 20 und mit einem <codeph>miterLimit</codeph> von 1, 2 und 4. Darüber befinden sich schwarze Referenzlinien, die die Schnittpunkte der Verbindungen anzeigen:</p>
 
 <p><adobeimage alt="Linien mit miterLimit-Werten 1, 2 und 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Beachten Sie, dass bei einem gegebenen <codeph>miterLimit</codeph>-Wert ein bestimmter Maximalwinkel existiert, bei dem der Winkel abgeschnitten wird. In der folgenden Tabelle finden Sie einige Beispiele:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph>-Wert:</entry><entry>Winkel, die kleiner sind als dieser Wert, werden abgeschnitten:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 Grad</entry></row><row><entry>2</entry>      <entry>60 Grad</entry></row><row><entry>4</entry>      <entry>30 Grad</entry></row><row><entry>8</entry>      <entry>15 Grad</entry></row></tbody></tgroup></adobetable>
 </apiDesc></apiParam><apiParam><apiItemName>fill</apiItemName><apiOperationClassifier>flash.display:IGraphicsFill</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine iGraphicsFill-Instanz, die Daten zum Füllen eines Strichs enthält. Eine IGraphicsFill-Instanz kann eine Reihe von Füllbefehlen darstellen.
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Erstellt ein neues GraphicsStroke-Objekt.
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsStroke:fill"><apiName>fill</apiName><shortdesc>
 Gibt die Instanz an, die Daten zum Füllen eines Strichs enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:IGraphicsFill</apiValueClassifier></apiValueDef><apiDesc>
 Gibt die Instanz an, die Daten zum Füllen eines Strichs enthält. Eine IGraphicsFill-Instanz kann eine Reihe von Füllbefehlen darstellen.
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:miterLimit"><apiName>miterLimit</apiName><shortdesc>
 Legt den Grenzwert fest, an dem ein Winkel abgeschnitten wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Legt den Grenzwert fest, an dem ein Winkel abgeschnitten wird. Gültige Werte liegen zwischen 1 und 255 (Werte außerhalb dieses Bereichs werden auf 1 bzw. 255 gerundet). Dieser Wert wird nur dann verwendet, wenn <codeph>jointStyle</codeph> auf <codeph>"miter"</codeph> gesetzt wird. Der Wert <codeph>miterLimit</codeph> steht für die Länge, die ein Winkel über jenen Punkt hinausgehen kann, an dem zwei Linien eine Verbindung bilden. Der Wert drückt einen Faktor der Linieneigenschaft <codeph>thickness</codeph> aus. Bei einem <codeph>miterLimit</codeph>-Faktor von 2,5 und einer <codeph>thickness</codeph> von 10 Pixeln, wird der Winkel bei 25 Pixeln abgeschnitten. 
 
 <p>Betrachten Sie beispielsweise die folgenden Winkellinien mit einer <codeph>thickness</codeph> von 20 und mit einem <codeph>miterLimit</codeph> von 1, 2 und 4. Darüber befinden sich schwarze Referenzlinien, die die Schnittpunkte der Verbindungen anzeigen:</p>
 
 <p><adobeimage alt="Linien mit miterLimit-Werten 1, 2 und 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Beachten Sie, dass bei einem gegebenen <codeph>miterLimit</codeph>-Wert ein bestimmter Maximalwinkel existiert, bei dem der Winkel abgeschnitten wird. In der folgenden Tabelle finden Sie einige Beispiele:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph>-Wert:</entry><entry>Winkel, die kleiner sind als dieser Wert, werden abgeschnitten:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 Grad</entry></row><row><entry>2</entry>      <entry>60 Grad</entry></row><row><entry>4</entry>      <entry>30 Grad</entry></row><row><entry>8</entry>      <entry>15 Grad</entry></row></tbody></tgroup></adobetable>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:pixelHinting"><apiName>pixelHinting</apiName><shortdesc>
 Legt fest, ob Striche als ganze Pixel angezeigt werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
 Legt fest, ob Striche als ganze Pixel angezeigt werden. Dies wirkt sich sowohl auf die Positionen der Anker einer Kurve als auch auf die Linienstärke des Strichs selbst aus. Wenn <codeph>pixelHinting</codeph> auf <codeph>true</codeph> gesetzt ist, stellt Flash Player die Linienstärken auf volle Pixel ein. Ist <codeph>pixelHinting</codeph> auf <codeph>false</codeph> gesetzt, können Kurven und gerade Linien unterbrochen sein. In den folgenden Abbildungen wird veranschaulicht, wie Flash Player zwei Rechtecke mit abgerundeten Ecken darstellt, die identisch sind, abgesehen davon, dass der <codeph>pixelHinting</codeph>-Parameter in der <codeph>lineStyle()</codeph>-Methode anders eingestellt ist (die Abbildungen sind um 200 % vergrößert, um den Unterschied deutlich zu zeigen):
 
 <p><adobeimage alt="pixelHinting-Einstellungen „false“ und „true“" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:thickness"><apiName>thickness</apiName><shortdesc>
 Gibt die Stärke der Linie in Punkt an. Gültig sind Werte von 0 bis 255.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Gibt die Stärke der Linie in Punkt an. Gültig sind Werte von 0 bis 255. Wenn keine Zahl angegeben ist oder wenn der Parameter den Wert „undefined“ aufweist, wird keine Linie gezeichnet. Wenn ein kleinerer Wert als 0 übergeben wird, ist der Standardwert 0. Der Wert 0 steht für die geringste Linienstärke. Der Höchstwert beträgt 255. Wenn ein größerer Wert als 255 übergeben wird, ist der Standardwert 255.
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:caps:get"><apiName>caps</apiName><shortdesc>
 Legt die Linienenden fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Legt die Linienenden fest. Folgende Werte sind zulässig: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> und <codeph>CapsStyle.SQUARE</codeph>. Wird kein Wert angegeben, verwendet Flash runde Enden. 
 <p>Die folgende Abbildung zeigt beispielsweise die verschiedenen Einstellungen für <codeph>capsStyle</codeph>. Die Abbildung zeigt für jede Einstellung eine blaue Linie mit der Stärke 30 (für die <codeph>capsStyle</codeph> gilt) sowie eine überlagerte schwarze Linie mit der Stärke 1 (für die kein <codeph>capsStyle</codeph> gilt):
 </p>
 <p><adobeimage alt="NONE, ROUND und SQUARE" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:joints:get"><apiName>joints</apiName><shortdesc>
 Legt den Verbindungsstil für Winkel fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Legt den Verbindungsstil für Winkel fest. Folgende Werte sind zulässig: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> und <codeph>JointStyle.ROUND</codeph>. Wird kein Wert angegeben, verwendet Flash runde Verbindungen. 
 
 <p>Die folgende Abbildung zeigt beispielsweise die verschiedenen Einstellungen für <codeph>joints</codeph>. Die Abbildung zeigt für jede Einstellung eine blaue Winkellinie mit der Stärke 30 (für die <codeph>jointStyle</codeph> gilt) sowie eine überlagerte schwarze Winkellinie mit der Stärke 1 (für die kein <codeph>jointStyle</codeph> gilt):
 </p>
 
 <p><adobeimage alt="MITER, ROUND und BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Hinweis:</b> Ist <codeph>joints</codeph> auf <codeph>JointStyle.MITER</codeph> gesetzt, können Sie den Parameter <codeph>miterLimit</codeph> verwenden, um die Länge des Winkels einzuschränken.</p>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
 Legt die Skalierung der Strichbreite fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Legt die Skalierung der Strichbreite fest. Gültige Werte sind:
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph>: Die Linienstärke wird immer skaliert, wenn das Objekt skaliert wird (der Standard).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph>: Die Linienstärke wird nie skaliert.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph>: Die Linienstärke wird nicht skaliert, wenn das Objekt <i>nur</i> vertikal skaliert wurde. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.VERTICAL</codeph> gesetzt wurde. Der Kreis links wurde nur vertikal skaliert, und der Kreis rechts wurde sowohl vertikal als auch horizontal skaliert.
 
 <p><adobeimage alt="Ein nur vertikal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph>: Die Linienstärke wird nicht skaliert, wenn das Objekt <i>nur</i> vertikal skaliert wurde. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.HORIZONTAL</codeph> gesetzt wurde. Der Kreis links wurde nur horizontal skaliert, und der Kreis rechts wurde sowohl horizontal als auch vertikal skaliert.
 
 <p><adobeimage alt="Ein nur horizontal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Zeigt das Ende einer Grafikfüllung an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Zeigt das Ende einer Grafikfüllung an. Verwenden Sie ein GraphicsEndFill-Objekt mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode.
 
 <p>
 Das Zeichnen eines GraphicsEndFill-Objekts entspricht dem Aufrufen der <codeph>Graphics.endFill()</codeph>-Methode.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsEndFill:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Erstellt ein Objekt zur Verwendung mit der Graphics.drawGraphicsData()-Methode zum expliziten Beenden der Füllung,</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 Erstellt ein Objekt zur Verwendung mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode zum expliziten Beenden der Füllung,
 
 
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderPrecision"><apiName>ShaderPrecision</apiName><shortdesc>
	 Diese Klasse definiert die Konstanten, die die möglichen Werte der precisionHint-Eigenschaft des Shaders darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Diese Klasse definiert die Konstanten, die die möglichen Werte der <codeph>precisionHint</codeph>-Eigenschaft des Shaders darstellen. Jede Konstante stellt einen der Präzisionsmodi für die Ausführung der Shadervorgänge dar.
	 
	 <p>Die Auswahl des Präzisionsmodus wirkt sich auf die folgenden Shadervorgänge aus. Diese Vorgänge sind auf einem Intel-Prozessor schneller, wenn die SSE-Anweisung wie folgt eingestellt ist:</p>
	 
	 <ul>
	   <li><codeph>sin(x)</codeph></li>
	   <li><codeph>cos(x)</codeph></li>
	   <li><codeph>tan(x)</codeph></li>
	   <li><codeph>asin(x)</codeph></li>
	   <li><codeph>acos(x)</codeph></li>
	   <li><codeph>atan(x)</codeph></li>
	   <li><codeph>atan(x, y)</codeph></li>
	   <li><codeph>exp(x)</codeph></li>
	   <li><codeph>exp2(x)</codeph></li>
	   <li><codeph>log(x)</codeph></li>
	   <li><codeph>log2(x)</codeph></li>
	   <li><codeph>pow(x, y)</codeph></li>
	   <li><codeph>reciprocal(x)</codeph></li>
	   <li><codeph>sqrt(x)</codeph></li>
	 </ul>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links><apiValue id="flash.display:ShaderPrecision:FAST"><apiName>FAST</apiName><shortdesc>
		 Stellt den schnellen Präzisionsmodus dar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fast</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Stellt den schnellen Präzisionsmodus dar.
		 
		 <p>Der schnelle Präzisionsmodus gewährleistet maximale Leistung, funktioniert aber nicht konsistent über alle Plattformen und individuellen CPU-Konfigurationen hinweg. Diese Präzisionsebene reicht aus, um Grafikeffekte ohne sichtbare Artefakte zu erstellen.</p>
		 
		 <p>Der schnelle Präzisionsmodus ist normalerweise schneller als die Verwendung von Suchtabellen.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderPrecision:FULL"><apiName>FULL</apiName><shortdesc>
		 Stellt den vollen Präzisionsmodus dar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Stellt den vollen Präzisionsmodus dar.
		 
		 <p>Im vollen Präzisionsmodus berechnet der Shader alle mathematischen Operationen auf Basis des 32-Bit-Gleitkommastandards des IEEE. Dieser Modus gewährleistet konsistentes Verhalten auf allen Plattformen. In diesem Modus können einige mathematische Operationen, wie beispielsweise trigonometrische und Exponentialfunktionen, langsam sein.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:BlendMode"><apiName>BlendMode</apiName><shortdesc>
Eine Klasse, die Konstantenwerte für visuelle Mischmoduseffekte bereitstellt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Eine Klasse, die Konstantenwerte für visuelle Mischmoduseffekte bereitstellt. Diese Konstanten werden in den folgenden Elementen verwendet:

<ul>

	<li> In der <codeph>blendMode</codeph>-Eigenschaft der flash.display.DisplayObject-Klasse.</li>

	<li> Im Parameter <codeph>blendMode</codeph> der <codeph>draw()</codeph>-Methode der flash.display.BitmapData-Klasse.</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiValue id="flash.display:BlendMode:ADD"><apiName>ADD</apiName><shortdesc>
Addiert den Wert der Grundfarben des Anzeigeobjekts zu den Farben des Hintergrunds (mit einem oberen Grenzwert von 0xFF).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>add</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Addiert den Wert der Grundfarben des Anzeigeobjekts zu den Farben des Hintergrunds (mit einem oberen Grenzwert von 0xFF). Diese Einstellung wird im Allgemeinen für Animationen von heller werdenden Auflösungen zwischen zwei Objekten verwendet.

<p>Wenn das Anzeigeobjekt z. B. ein Pixel mit dem RGB-Farbwert 0xAAA633 aufweist und das Pixel im Hintergrund den RGB-Wert 0xDD2200 hat, dann erhält das angezeigte Pixel den Wert 0xFFC833 (da 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8 und 0x33 + 0x00 = 0x33 ist).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ALPHA"><apiName>ALPHA</apiName><shortdesc>
Wendet den Alphawert jedes Pixels des Anzeigeobjekts auf den Hintergrund an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>alpha</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Wendet den Alphawert jedes Pixels des Anzeigeobjekts auf den Hintergrund an. Dieser Vorgang erfordert, dass die <codeph>blendMode</codeph>-Eigenschaft des übergeordneten Anzeigeobjekts auf <codeph>flash.display.BlendMode.LAYER</codeph> gesetzt wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DARKEN"><apiName>DARKEN</apiName><shortdesc>
Wählt die dunklere Grundfarbe des Anzeigeobjekts und des Hintergrunds aus (die niedrigeren Werte).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>darken</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Wählt die dunklere Grundfarbe des Anzeigeobjekts und des Hintergrunds aus (die niedrigeren Werte). Diese Einstellung wird normalerweise für Überlagerungen verwendet. 

<p>Weist das Anzeigeobjekt z. B. ein Pixel mit einem RGB-Wert von 0xFFCC33 und das Hintergrund-Pixel einen RGB-Wert von 0xDDF800 auf, lautet der resultierende RGB-Wert für das angezeigte Pixel 0xDDCC00 (da 0xFF > 0xDD, 0xCC &lt; 0xF8 und 0x33 > 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DIFFERENCE"><apiName>DIFFERENCE</apiName><shortdesc>
Vergleicht die Grundfarben des Anzeigeobjekts mit den Farben des Hintergrunds und subtrahiert für die beiden Grundfarben den dunkleren Wert von dem helleren Wert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>difference</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Vergleicht die Grundfarben des Anzeigeobjekts mit den Farben des Hintergrunds und subtrahiert für die beiden Grundfarben den dunkleren Wert von dem helleren Wert. Diese Einstellung wird normalerweise zur Farbverstärkung verwendet. 

<p>Wenn das Anzeigeobjekt z. B. ein Pixel mit dem RGB-Farbwert 0xFFCC33 aufweist und das Pixel im Hintergrund den RGB-Wert 0xDDf800 hat, dann erhält das angezeigte Pixel den Wert 0x222C33 (da 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C und 0x33 - 0x00 = 0x33 ist).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ERASE"><apiName>ERASE</apiName><shortdesc>
Löscht den Hintergrund anhand der Alphawerte des Anzeigeobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>erase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Löscht den Hintergrund anhand der Alphawerte des Anzeigeobjekts. Dieser Vorgang erfordert, dass die <codeph>blendMode</codeph>-Eigenschaft des übergeordneten Anzeigeobjekts auf <codeph>flash.display.BlendMode.LAYER</codeph> gesetzt wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:HARDLIGHT"><apiName>HARDLIGHT</apiName><shortdesc>
Passt die Farbe jedes Pixels entsprechend der Dunkelheit des Anzeigeobjekts an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>hardlight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Passt die Farbe jedes Pixels entsprechend der Dunkelheit des Anzeigeobjekts an. Ist das Anzeigeobjekt heller als 50 % Grau, werden die Farben von Anzeigeobjekt und Hintergrund überlagert, was zu einer helleren Farbe führt. Ist das Anzeigeobjekt dagegen dunkler als 50 % Grau, werden die Farben multipliziert, was zu dunkleren Farben führt. Diese Einstellung wird normalerweise für Schattierungen verwendet. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:INVERT"><apiName>INVERT</apiName><shortdesc>
Kehrt den Hintergrund um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>invert</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Kehrt den Hintergrund um.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LAYER"><apiName>LAYER</apiName><shortdesc>
Erzwingt die Erstellung einer Transparenzgruppe für das Anzeigeobjekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>layer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Erzwingt die Erstellung einer Transparenzgruppe für das Anzeigeobjekt. Dies bedeutet, dass das Anzeigeobjekt in einem temporären Puffer zusammengesetzt wird, bevor es weiterverarbeitet wird. Diese Zusammensetzung geschieht automatisch, wenn das Anzeigeobjekt im Voraus mithilfe der Bitmap-Zwischenspeicherung zwischengespeichert wird oder wenn es sich bei dem Anzeigeobjekt um einen Anzeigeobjekt-Container handelt, der mindestens ein untergeordnetes Objekt besitzt, dessen <codeph>blendMode</codeph>-Einstellung nicht <codeph>"normal"</codeph> lautet.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LIGHTEN"><apiName>LIGHTEN</apiName><shortdesc>
Wählt die hellere Grundfarbe des Anzeigeobjekts und des Hintergrunds aus (die Farbe mit den höheren Werten).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lighten</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Wählt die hellere Grundfarbe des Anzeigeobjekts und des Hintergrunds aus (die Farbe mit den höheren Werten). Diese Einstellung wird normalerweise für Überlagerungen verwendet. 

<p>Weist das Anzeigeobjekt z. B. ein Pixel mit einem RGB-Wert von 0xFFCC33 und das Hintergrund-Pixel einen RGB-Wert von 0xDDF800 auf, lautet der resultierende RGB-Wert für das angezeigte Pixel 0xFFF833 (da 0xFF > 0xDD, 0xCC &lt; 0xF8 und 0x33 > 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:MULTIPLY"><apiName>MULTIPLY</apiName><shortdesc>
Multipliziert die Werte der Grundfarben des Anzeigeobjekts mit den Grundfarben des Hintergrunds und normalisiert das Ergebnis durch Division durch 0xFF. Dies führt zu dunkleren Farben.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>multiply</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Multipliziert die Werte der Grundfarben des Anzeigeobjekts mit den Grundfarben des Hintergrunds und normalisiert das Ergebnis durch Division durch 0xFF. Dies führt zu dunkleren Farben. Diese Einstellung wird im Allgemeinen für Schatten- und Tiefeneffekte verwendet.

<p>Weisen beispielsweise die Grundfarbe (etwa Rot) eines Pixels im Anzeigeobjekt und eines Hintergrund-Pixels den Wert 0x88 auf, lautet das Ergebnis der Multiplikation 0x4840. Die Division durch 0xFF ergibt für diese Grundfarbe 0x48. Dies ist eine dunklere Farbe als die des Anzeigeobjekts bzw. des Hintergrunds.</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
Das Anzeigeobjekt wird vor dem Hintergrund angezeigt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Das Anzeigeobjekt wird vor dem Hintergrund angezeigt. Die Pixelwerte des Anzeigeobjekts setzen die Pixelwerte des Hintergrunds außer Kraft. An den Stellen, an denen das Anzeigeobjekt transparent ist, wird der Hintergrund sichtbar.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:OVERLAY"><apiName>OVERLAY</apiName><shortdesc>
Passt die Farbe jedes Pixels entsprechend der Dunkelheit des Hintergrunds an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>overlay</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Passt die Farbe jedes Pixels entsprechend der Dunkelheit des Hintergrunds an. Wenn der Hintergrund heller ist als 50 % Grau, werden die Farben des Anzeigeobjekts und des Hintergrunds überlagert, um hellere Farben zu erhalten. Ist der Hintergrund dagegen dunkler als 50 % Grau, werden die Farben multipliziert, was zu dunkleren Farben führt. Diese Einstellung wird normalerweise für Schattierungen verwendet. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SCREEN"><apiName>SCREEN</apiName><shortdesc>
Multipliziert die Komplementärfarbe des Anzeigeobjekts mit der Komplementärfarbe der Hintergrundfarbe, was zu helleren Farbtönen führt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>screen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Multipliziert die Komplementärfarbe des Anzeigeobjekts mit der Komplementärfarbe der Hintergrundfarbe, was zu helleren Farbtönen führt. Diese Einstellung wird in der Regel für Hervorhebungen bzw. zum Entfernen von schwarzen Bereichen aus dem Anzeigeobjekt verwendet. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SHADER"><apiName>SHADER</apiName><shortdesc>
Verwendet einen Shader, um die Angleichung zwischen Objekten zu definieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>shader</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Verwendet einen Shader, um die Angleichung zwischen Objekten zu definieren.

<p>Wird die <codeph>blendShader</codeph>-Eigenschaft auf eine Shader-Instanz gesetzt, so wird die <codeph>blendMode</codeph>-Eigenschaft automatisch auf <codeph>BlendMode.SHADER</codeph> gesetzt. Wird die <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.SHADER</codeph> gesetzt, ohne vorher die <codeph>blendShader</codeph>-Eigenschaft zu setzen, so wird die <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.NORMAL</codeph> gesetzt. Wenn die <codeph>blendShader</codeph>-Eigenschaft gesetzt wird (wodurch die <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.SHADER</codeph> gesetzt wird), so wird der Wert der <codeph>blendMode</codeph>-Eigenschaft geändert. Der Mischmodus kann einfach durch Setzen der <codeph>blendMode</codeph>-Eigenschaft auf <codeph>BlendMode.SHADER</codeph> zur Verwendung des Misch-Shaders neu gesetzt werden. Die <codeph>blendShader</codeph>-Eigenschaft muss nicht neu gesetzt werden, es sei denn, der für den Mischmodus verwendete Shader soll geändert werden.</p>

</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue><apiValue id="flash.display:BlendMode:SUBTRACT"><apiName>SUBTRACT</apiName><shortdesc>
Subtrahiert die Werte der Grundfarben des Anzeigeobjekts von den Werten der Hintergrundfarbe (mit einem unteren Grenzwert von 0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subtract</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Subtrahiert die Werte der Grundfarben des Anzeigeobjekts von den Werten der Hintergrundfarbe (mit einem unteren Grenzwert von 0). Diese Einstellung wird im Allgemeinen für Animationen von dunkler werdenden Auflösungen zwischen zwei Objekten verwendet.

<p>Weist das Anzeigeobjekt z. B. ein Pixel mit einem RGB-Wert von 0xAA2233 und das Hintergrund-Pixel einen RGB-Wert von 0xDDA600 auf, lautet der resultierende RGB-Wert für das angezeigte Pixel 0x338400 (da 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84 und 0x00 - 0x33 &lt; 0x00).</p>
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Graphics"><apiName>Graphics</apiName><shortdesc>
 Die Graphics-Klasse enthält einen Satz an Methoden, mit denen Sie eine Vektorform erstellen können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Graphics-Klasse enthält einen Satz an Methoden, mit denen Sie eine Vektorform erstellen können. Anzeigeobjekte, die das Zeichnen unterstützen, enthalten Sprite- und Shape-Objekte. Jede dieser Klassen enthält eine <codeph>graphics</codeph>-Eigenschaft, die ein Graphics-Objekt darstellt. Die folgenden Funktionen sind Hilfsfunktionen, die eine einfache Verwendung ermöglichen sollen: <codeph>drawRect()</codeph>, <codeph>drawRoundRect()</codeph>, <codeph>drawCircle()</codeph> und <codeph>drawEllipse()</codeph>.
 
 <p>Sie können ein Graphics-Objekt nicht direkt aus ActionScript-Code erstellen. Wenn Sie <codeph>new Graphics()</codeph> aufrufen, wird eine Ausnahme ausgelöst.</p>
 
 <p>Die Graphics-Klasse ist endgültig, d. h., aus ihr können keine Unterklassen abgeleitet werden.</p>
 
 
 </apiDesc><example conref="examples\GraphicsExample.as"> Im folgenden Beispiel wird die GraphicsExample-Klasse verwendet, um einen Kreis, ein abgerundetes Rechteck und ein Quadrat zu zeichnen. Dies wird in den folgenden Schritten erreicht:
 <ol>
    <li>Deklarieren Sie eine <codeph>size</codeph>-Eigenschaft zur späteren Verwendung beim Bestimmen der Größe der einzelnen Formen.</li>
     <li>Deklarieren Sie Eigenschaften, die die Hintergrundfarbe auf Orange, die Rahmenfarbe auf Dunkelgrau, die Rahmenbreite auf 0 Pixel und den Eckradius auf 9 Pixel setzen, und setzen Sie den Abstand zwischen Bühnenrand und anderen Objekten auf 5 Pixel.</li>
    <li>Verwenden Sie die in den vorherigen Schritten deklarierten Eigenschaften zusammen mit den vorhandenen Methoden der Graphics-Klasse, um an den Koordinaten x = 0, y = 0 einen Kreis, ein abgerundetes Rechteck und ein Quadrat zu zeichnen.</li>
    <li>Zeichnen Sie die einzelnen Formen am oberen Rand der Bühne neu, indem Sie an der Position x = 5, y = 5 beginnen und zwischen den Formen einen Abstand von jeweils 5 Pixel einhalten.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class GraphicsExample extends Sprite {
        private var size:uint         = 80;
        private var bgColor:uint      = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function GraphicsExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size / 2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Graphics:beginBitmapFill"><apiName>beginBitmapFill</apiName><shortdesc>
	 Füllt einen Zeichenbereich mit einer Bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Eine transparente oder undurchsichtige Bitmap, die die anzuzeigenden Bits enthält.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Matrix-Objekt (der flash.geom.Matrix-Klasse), mit dem Sie Transformationen an der Bitmap definieren können. Die folgende Matrix können Sie beispielsweise verwenden, um eine Bitmap um 45 Grad (pi/4 rad) zu drehen:
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Wenn <codeph>true</codeph> eingestellt ist, wird die Bitmap in einem Kachelmuster wiederholt. Bei <codeph>false</codeph> wird die Bitmap nicht wiederholt, und die Kanten der Bitmap werden für alle Füllbereiche verwendet, die über die Bitmap hinausgehen. 
	 
	 <p>Nehmen Sie die folgende Bitmap (ein Schachbrettmuster im Format 20 x 20 Pixel) als Beispiel:</p>
	 
     <p><adobeimage alt="Schachbrettmuster im Format 20 x 20 Pixel" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
	 
	 <p>Ist <codeph>repeat</codeph> auf <codeph>true</codeph> gesetzt (wie im folgenden Beispiel), wiederholt die Bitmap-Füllung die Bitmap:</p>
	 
     <p><adobeimage alt="Schachbrettmuster im Format 60 x 60 Pixel" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
	 
	 <p>Ist <codeph>repeat</codeph> auf <codeph>false</codeph> gesetzt, verwendet die Bitmapfüllung die Randpixel für den Füllbereich außerhalb der Bitmap:</p>
	 
     <p><adobeimage alt="60-x-60-Pixel-Bild ohne Wiederholung" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 
   	 
	 </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Wenn <codeph>false</codeph> eingestellt ist, werden aufwärts skalierte Bilder mithilfe des „Nächster-Nachbar-Algorithmus“ wiedergegeben. Meist sind dann die einzelnen Pixelpunkte zu sehen. Wenn <codeph>true</codeph> eingestellt ist, werden aufwärts skalierte Bilder anhand eines bilinearen Algorithmus wiedergegeben. Eine Wiedergabe anhand des „Nächster-Nachbar-Algorithmus“·ist schneller.
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Beginnt eine Form mit Bitmap-Füllung.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Füllt einen Zeichenbereich mit einer Bitmap. Um den Bereich zu füllen, kann das Bild wiederholt oder mehrfach neben- und untereinander angeordnet werden. Die Füllung bleibt wirksam, bis Sie eine der Methoden <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginShaderFill()</codeph> aufrufen. Durch das Aufrufen der <codeph>clear()</codeph>-Methode wird die Füllung gelöscht.
	 
	 <p>Die Anwendung stellt die Füllung immer dann dar, wenn drei oder mehr Punkte gezeichnet werden oder die <codeph>endFill()</codeph>-Methode aufgerufen wird. </p>
	 
	 </apiDesc><example conref="examples\Graphics_beginBitmapFillExample.as"> Im folgenden Beispiel wird ein Bild (<codeph>image1.jpg</codeph>) gedreht und wiederholt, um ein Rechteck auszufüllen.
 
 <ol>
    <li>Die Bilddatei (<codeph>image1.jpg</codeph>) wird mithilfe der <codeph>Loader</codeph>- und <codeph>URLRequest</codeph>-Objekte geladen. Hier befindet sich die Datei im selben Ordner wie die SWF-Datei. Bei der Kompilierung der SWF-Datei muss „Sicherheit bei lokaler Wiedergabe“ auf „Nur auf lokale Dateien zugreifen“ eingestellt sein.</li>
     <li>Nachdem das Bild geladen wurde (<codeph>Event</codeph> ist abgeschlossen), wird die Methode <codeph>drawImage()</codeph> aufgerufen. Die Methode <codeph>ioErrorHandler()</codeph> schreibt einen Nachverfolgungskommentar, wenn das Bild nicht richtig geladen wird.</li>  
  <li>In der Methode <codeph>drawImage()</codeph> wird ein <codeph>BitmapData</codeph>-Objekt instanziiert, und seine Breite und Höhe werden an das Bild (<codeph>image1.jpg</codeph>) angepasst. Das Quellbild wird dann in das BitmapData-Objekt gezeichnet. Als Nächstes wird ein Rechteck in das Sprite-Objekt <codeph>mySprite</codeph> gezeichnet und mit dem BitmapData-Objekt gefüllt. Mithilfe eines <codeph>Matrix</codeph>-Objekts dreht die Methode <codeph>beginBitmapFill()</codeph> das Bild um 45 Grad und füllt das Rechteck dann mit dem Bild.</li> 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.geom.Matrix;

    public class Graphics_beginBitmapFillExample extends Sprite {
 
        private var url:String = "image1.jpg";
        private var loader:Loader = new Loader();

        public function Graphics_beginBitmapFillExample() {

            var request:URLRequest = new URLRequest(url);
            
            loader.load(request);
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, drawImage);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function drawImage(event:Event):void {

            var mySprite:Sprite = new Sprite();
            var myBitmap:BitmapData = new BitmapData(loader.width, loader.height, false);
  
            myBitmap.draw(loader, new Matrix());
            
            var matrix:Matrix = new Matrix();
            matrix.rotate(Math.PI/4);
            
            mySprite.graphics.beginBitmapFill(myBitmap, matrix, true);
            mySprite.graphics.drawRect(100, 50, 200, 90);
            mySprite.graphics.endFill();
            
            addChild(mySprite);
        }
 
         private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }   
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginFill"><apiName>beginFill</apiName><shortdesc>
 	 Gibt eine einfache, einfarbige Füllung an, die bei nachfolgenden Aufrufen anderer Graphics-Methoden (wie „lineTo()“ oder „drawCircle()“) zum Zeichnen verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Die Farbe der Füllung (0xRRGGBB).
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Alphawert der Füllung (0,0 bis 1,0). 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Legt eine einfarbige Füllung fest.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Gibt eine einfache, einfarbige Füllung an, die bei nachfolgenden Aufrufen anderer Graphics-Methoden (wie <codeph>lineTo()</codeph> oder <codeph>drawCircle()</codeph>) zum Zeichnen verwendet wird. Die Füllung bleibt wirksam, bis Sie eine der Methoden <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginShaderFill()</codeph> aufrufen. Durch das Aufrufen der <codeph>clear()</codeph>-Methode wird die Füllung gelöscht.
	 
	 <p>Die Anwendung stellt die Füllung immer dann dar, wenn drei oder mehr Punkte gezeichnet werden oder die <codeph>endFill()</codeph>-Methode aufgerufen wird.</p>
	 
	 </apiDesc><example>Am Ende des Abschnitts über diese Klasse finden Sie in <xref href="Graphics.html#includeExamplesSummary">Beispiel</xref> , in dem die Verwendung dieser Methode veranschaulicht wird. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginGradientFill"><apiName>beginGradientFill</apiName><shortdesc>
	 Gibt eine Farbverlaufsfüllung an, die bei nachfolgenden Aufrufen anderer Graphics-Methoden wie lineTo() oder drawCircle() zum Zeichnen verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Parameter <codeph>type</codeph> nicht gültig ist.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein Wert aus der GradientType-Klasse, mit dem angegeben wird, welcher Farbverlaufstyp verwendet werden soll: <codeph>GradientType.LINEAR</codeph> oder <codeph>GradientType.RADIAL</codeph>. 
	 
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit hexadezimalen RGB-Farbwerten, die im Farbverlauf verwendet werden (beispielsweise 0xFF0000 für Rot, 0x0000FF für Blau usw.). Sie können bis zu 15 Farben angeben. Definieren Sie für jede Farbe einen entsprechenden Wert in den Parametern „alphas“ und „ratios“.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit Alphawerten für die entsprechenden Farben im Array „colors“. Gültig sind Werte von 0 bis 1. Ist der Wert kleiner als 0, ist der Standardwert 0. Ist der Wert größer als 1, ist der Standardwert 1.
     
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit Farbverteilungsverhältnissen. Zulässig sind Werte zwischen 0 und 255. Dieser Wert gibt den Breitenanteil an, in dem die Farbe mit 100 % gesampelt wird. Der Wert 0 stellt die linke Position im Farbverlaufsfeld dar, 255 die rechte. 
	 
	 <p><b>Hinweis:</b> Dieser Wert repräsentiert Positionen im Farbverlaufsfeld, nicht im Koordinatenraum des endgültigen Farbverlaufs, der breiter oder schmaler als das Farbverlaufsfeld sein kann. Geben Sie für jeden Wert im Parameter <codeph>colors</codeph> einen Wert an. </p>
	 
	 <p>Die folgende Abbildung zeigt für einen linearen Verlauf mit den beiden Farben Blau und Grün die Farbplatzierung im Verlauf basierend auf den verschiedenen Werten im <codeph>ratios</codeph>-Array an:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Gradient</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
	 	<entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 0 und 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 0 und 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 127 und 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Die Werte im Array müssen sich sequenziell erhöhen. Beispiel: <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine Transformationsmatrix, wie sie von der flash.geom.Matrix-Klasse definiert wird. Die flash.geom.Matrix-Klasse umfasst eine <codeph>createGradientBox()</codeph>-Methode, mit der Sie die Matrix zur Verwendung mit der <codeph>beginGradientFill()</codeph>-Methode auf einfache Weise festlegen können.
	 
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>Ein Wert aus der SpreadMethod-Klasse, der festlegt, welche Auftragstärke zu verwenden ist: <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> oder <codeph>SpreadMethod.REPEAT</codeph>. 
	 
	 <p>Angenommen, Sie haben einen einfachen linearen Farbverlauf zwischen zwei Farben:</p>
	 
	 <codeblock>
	 import flash.geom.*
	 import flash.display.*
	 var fillType:String = GradientType.LINEAR;
	 var colors:Array = [0xFF0000, 0x0000FF];
	 var alphas:Array = [1, 1];
	 var ratios:Array = [0x00, 0xFF];
	 var matr:Matrix = new Matrix();
	 matr.createGradientBox(20, 20, 0, 0, 0);
	 var spreadMethod:String = SpreadMethod.PAD;
	 this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);		
	 this.graphics.drawRect(0,0,100,100);
	 </codeblock>
	 
	 	<p>Dieses Beispiel verwendet <codeph>SpreadMethod.PAD</codeph> als Methode für die Auftragstärke, und der Farbverlauf sieht folgendermaßen aus:</p>
	 
      <p><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
 	 
	 	<p>Mit der Auftragstärke <codeph>SpreadMethod.REFLECT</codeph> sieht die Farbverlaufsfüllung folgendermaßen aus:</p>
 	 
      <p><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
 	 
	 	<p>Mit der Auftragstärke <codeph>SpreadMethod.REPEAT</codeph> sieht die Farbverlaufsfüllung folgendermaßen aus:</p>
 	 
      <p><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>Ein Wert der InterpolationMethod-Klasse, der festlegt, welcher Wert verwendet werden soll: <codeph>InterpolationMethod.LINEAR_RGB</codeph> oder <codeph>InterpolationMethod.RGB</codeph>.
	 
	 <p>Angenommen, Sie haben einen einfachen linearen Farbverlauf zwischen zwei Farben (wobei der Parameter <codeph>spreadMethod</codeph> auf <codeph>SpreadMethod.REFLECT</codeph> gesetzt ist). Die verschiedenen Interpolationsmethoden haben folgende Auswirkung auf die Darstellung des Farbverlaufs: </p>
	 
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Zahl, die die Position des Farbverlaufsbrennpunkts steuert. Der Wert 0 bedeutet, dass der Brennpunkt in der Mitte liegt. Der Wert 1 bedeutet, dass der Brennpunkt an einem Rand des Farbverlaufskreises liegt. Der Wert -1 bedeutet, dass der Brennpunkt am anderen Rand des Farbverlaufskreises liegt. Werte, die kleiner als -1 oder größer als 1 sind, werden auf -1 bzw. 1 gerundet. Im folgenden Beispiel ist <codeph>focalPointRatio</codeph> z. B. auf 0,75 gesetzt:
	 
     <p><adobeimage alt="Radialer Farbverlauf mit focalPointRatio-Wert von 0,75" href="../../images/radial_sketch.jpg"/> </p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Legt eine Farbverlaufsfüllung fest.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt eine Farbverlaufsfüllung an, die bei nachfolgenden Aufrufen anderer Graphics-Methoden wie <codeph>lineTo()</codeph> oder <codeph>drawCircle()</codeph> zum Zeichnen verwendet wird. Die Füllung bleibt wirksam, bis Sie eine der Methoden <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginShaderFill()</codeph> aufrufen. Durch das Aufrufen der <codeph>clear()</codeph>-Methode wird die Füllung gelöscht.
	 
	 <p>Die Anwendung stellt die Füllung immer dann dar, wenn drei oder mehr Punkte gezeichnet werden oder die <codeph>endFill()</codeph>-Methode aufgerufen wird. </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginShaderFill"><apiName>beginShaderFill</apiName><shortdesc>
 	 Gibt eine Shaderfüllung an, die bei nachfolgenden Aufrufen anderer Graphics-Methoden wie lineTo() oder drawCircle() zum Zeichnen verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Shaderausgabetyp mit diesem Vorgang nicht kompatibel ist (der Shader muss eine <codeph>pixel3</codeph>- oder <codeph>pixel4</codeph>-Ausgabe festlegen).
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Shader eine Bildeingabe festlegt, die nicht vorhanden ist.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn eine ByteArray- oder Vector.&lt;Number>-Instanz als Eingabe verwendet wird und die <codeph>width</codeph>- und <codeph>height</codeph>-Eigenschaft für ShaderInput nicht festgelegt ist oder die festgelegten Werte nicht mit der Datenmenge im Eingabeobjekt übereinstimmen. Weitere Informationen finden Sie im Abschnitt zur <codeph>ShaderInput.input</codeph>-Eigenschaft.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>Der für die Füllung zu verwendende Shader. In dieser Shader-Instanz muss keine Bildeingabe festgelegt werden. Ist im Shader jedoch eine Bildeingabe festgelegt, so muss diese manuell bereitgestellt werden. Um die Eingabe festzulegen, setzen Sie die <codeph>input</codeph>-Eigenschaft der entsprechenden ShaderInput-Eigenschaft der <codeph>Shader.data</codeph>-Eigenschaft.
	 
	 <p>Wird eine Shader-Instanz als Argument übergeben, so wird der Shader intern kopiert. Beim Füllzeichenvorgang wird diese interne Kopie verwendet anstatt des Verweises auf den ursprünglichen Shader. Änderungen am Shader, beispielsweise die Änderung eines Parameterwerts, einer Eingabe, oder des Bytecode, werden nicht auf die Kopie des Shaders angewendet, die für die Füllung verwendet wird.</p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Matrixobjekt (der flash.geom.Matrix-Klasse), mit dem Sie Transformationen am Shader definieren können. Die folgende Matrix können Sie beispielsweise verwenden, um einen Shader um 45 Grad (pi/4 rad) zu drehen:
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 <p>Die vom Shader entgegengenommenen Koordinaten basieren auf der im <codeph>matrix</codeph>-Parameter festgelegten Matrix. Bei der Standardmatrix (<codeph>null</codeph>) sind die Koordinaten im Shader lokale Pixelkoordinaten, die für das Sampling einer Eingabe verwendet werden können.</p>
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Legt eine Shaderfüllung fest.
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Legt eine Shaderfüllung fest, die bei nachfolgenden Aufrufen anderer Graphics-Methoden (wie <codeph>lineTo()</codeph> oder <codeph>drawCircle()</codeph>) für das Objekt verwendet wird. Die Füllung bleibt wirksam, bis Sie eine der Methoden <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginShaderFill()</codeph> aufrufen. Durch das Aufrufen der <codeph>clear()</codeph>-Methode wird die Füllung gelöscht.
	 
	 <p>Die Anwendung stellt die Füllung immer dann dar, wenn drei oder mehr Punkte gezeichnet werden oder die <codeph>endFill()</codeph>-Methode aufgerufen wird.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:clear"><apiName>clear</apiName><shortdesc>
     Löscht die Grafiken, die für dieses Graphics-Objekt gezeichnet worden sind, und setzt die Einstellungen für den Füll- und Linienstil zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Löscht die Grafiken, die für dieses Graphics-Objekt gezeichnet worden sind, und setzt die Einstellungen für den Füll- und Linienstil zurück.
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:copyFrom"><apiName>copyFrom</apiName><shortdesc>
	 Kopiert alle Zeichenbefehle vom Graphics-Quellobjekt in das aufrufende Graphics-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceGraphics</apiItemName><apiOperationClassifier>flash.display:Graphics</apiOperationClassifier><apiDesc>Das Graphics-Objekt, von dem die Zeichenbefehle kopiert werden.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Kopiert alle Zeichenbefehle vom Graphics-Quellobjekt in das aufrufende Graphics-Objekt.
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:curveTo"><apiName>curveTo</apiName><shortdesc>
	 Zeichnet eine Kurve im aktuellen Linienstil von der aktuellen Zeichnungsposition zu (anchorX, anchorY) unter Verwendung des durch (controlX, controlY) angegebenen Steuerpunkts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine horizontale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine vertikale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine horizontale Position des nächsten Ankerpunkts relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine vertikale Position des nächsten Ankerpunkts relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Zeichnet eine Kurve von der aktuellen Zeichnungsposition zu (anchorX, anchorY) unter Verwendung des durch (controlX, controlY) angegebenen Steuerpunkts.
     
	 
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Zeichnet eine Kurve im aktuellen Linienstil von der aktuellen Zeichnungsposition zu (anchorX, anchorY) unter Verwendung des durch (<codeph>controlX</codeph>, <codeph>controlY</codeph>) angegebenen Steuerpunkts. Die aktuelle Zeichnungsposition wird dann auf (<codeph>anchorX</codeph>, <codeph>anchorY</codeph>) gesetzt. Wenn der Movieclip, in dem Sie zeichnen, einen mit den Flash-Zeichenwerkzeugen erstellten Inhalt enthält, werden die Ergebnisse von Aufrufen der <codeph>curveTo()</codeph>-Methode unterhalb dieses Inhalts gezeichnet. Wenn Sie die <codeph>curveTo()</codeph>-Methode vor der <codeph>moveTo()</codeph>-Methode aufrufen, ist der Standardwert der aktuellen Zeichnungsposition (0, 0). Wenn ein Parameter fehlt, schlägt die Ausführung dieser Methode fehl, und die aktuelle Zeichnungsposition wird beibehalten.
	 
	 <p>Die gezeichnete Kurve ist eine quadratische Bézierkurve. Quadratische Bézierkurven bestehen aus zwei Ankerpunkten und einem Steuerpunkt. Die Kurve interpoliert die zwei Ankerpunkte und neigt sich zum Steuerpunkt hin. </p>
	 
	 <p><adobeimage alt="Quadratische Bézierkurve und kubische Bézierkurve" href="../../images/quad_bezier.jpg"/></p>
	 
  	 </apiDesc><example conref="examples\Graphics_curveToExample1.as"> Im folgenden Beispiel wird ein grünes kreisförmiges Objekt mit einer Breite und Höhe von 100 Pixel an der Position 250 Pixel rechts vom Registrierungspunkt (0, 0) des Sprite-Anzeigeobjekts gezeichnet. 
 <p>Zeichnen Sie vier Kurven, um einen Kreis zu erzeugen, und füllen Sie ihn grün aus.</p>
   
 <p>Beachten Sie, dass aufgrund der Beschaffenheit der quadratischen Bezier-Gleichung kein perfekter Kreis entsteht. Am besten zeichnen Sie einen Kreis mit der Methode <codeph>drawCircle()</codeph> der Graphics-Klasse.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_curveToExample1 extends Sprite
    {
        public function Graphics_curveToExample1():void
        {
            var roundObject:Shape = new Shape();

            roundObject.graphics.beginFill(0x00FF00);
            roundObject.graphics.moveTo(250, 0);
            roundObject.graphics.curveTo(300, 0, 300, 50);
            roundObject.graphics.curveTo(300, 100, 250, 100);
            roundObject.graphics.curveTo(200, 100, 200, 50);
            roundObject.graphics.curveTo(200, 0, 250, 0);
            roundObject.graphics.endFill();
            
            this.addChild(roundObject);
        }
    }
}
</codeblock></example><example conref="examples\Graphics_curveToExample2.as"> Im folgenden Beispiel wird mithilfe der Methode <codeph>curveTo()</codeph> ein Neumond gezeichnet.
 
 <p>Es werden zwei Kurven mit einer Linienstärke von 1 Pixel gezeichnet und der Raum zwischen den Kurven wird weiß ausgefüllt. Mit der Methode <codeph>moveTo()</codeph> wird die aktuelle Zeichenposition auf die Koordinaten (100, 100) festgelegt. Die erste Kurve verschiebt die Zeichenposition auf (100, 200), den Zielpunkt der Kurve. Die zweite Kurve bringt die Position zurück zum Startpunkt (100, 100), der zugleich der Zielpunkt der zweiten Kurve ist. Die horizontalen Steuerpunkte bestimmten die unterschiedlichen Kurvengrößen. </p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_curveToExample2 extends Sprite
    {
        public function Graphics_curveToExample2() {
            var newMoon:Shape = new Shape();
            
            newMoon.graphics.lineStyle(1, 0);
            newMoon.graphics.beginFill(0xFFFFFF);
            newMoon.graphics.moveTo(100, 100); 
            newMoon.graphics.curveTo(30, 150, 100, 200);    
            newMoon.graphics.curveTo(50, 150, 100, 100);
            graphics.endFill();
            
            this.addChild(newMoon);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:drawCircle"><apiName>drawCircle</apiName><shortdesc>
	 Zeichnet einen Kreis.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>x</i>-Position des Kreismittelpunkts relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>y</i>-Position des Kreismittelpunkts relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>radius</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Radius des Kreises (in Pixel).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Zeichnet einen Kreis.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Zeichnet einen Kreis. Setzen Sie den Linienstil oder die Füllung oder beides, bevor Sie die <codeph>drawCircle()</codeph>-Methode aufrufen. Dazu rufen Sie die Methode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginBitmapFill()</codeph> auf.
	 
	 </apiDesc><example>Am Ende des Abschnitts über diese Klasse finden Sie in <xref href="Graphics.html#includeExamplesSummary">Beispiel</xref> , in dem die Verwendung dieser Methode veranschaulicht wird. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawEllipse()"><linktext>drawEllipse()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawEllipse"><apiName>drawEllipse</apiName><shortdesc>
	 Zeichnet eine Ellipse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>x</i>-Position der linken oberen Ecke des Begrenzungsrahmens der Ellipse relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts (in Pixel).
	
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>y</i>-Position der linken oberen Ecke des Begrenzungsrahmens der Ellipse relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts (in Pixel).
	
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Breite der Ellipse (in Pixel).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Höhe der Ellipse (in Pixel).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Zeichnet eine Ellipse.
         
         </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Zeichnet eine Ellipse. Setzen Sie den Linienstil oder die Füllung oder beides, bevor Sie die <codeph>drawEllipse()</codeph>-Methode aufrufen. Dazu rufen Sie die Methode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginBitmapFill()</codeph> auf.
	 
	 </apiDesc><example conref="examples\Graphics_drawEllipseExample.as"> Im folgenden Beispiel werden mithilfe der Funktion <codeph>drawEgg()</codeph> drei unterschiedlich große Eier (drei Ellipsen verschiedener Größe) gezeichnet. Die Größe ist vom Parameter <codeph>eggSize</codeph> abhängig.  
 <ol>
 <li>Der Konstruktor ruft die Funktion <codeph>drawEgg()</codeph> auf und übergibt die horizontalen und vertikalen Parameter für die Position, an der das Ei gezeichnet werden soll, sowie den Typ des Eis (<codeph>eggSize</codeph>). (Die Höhe und Breite der Eier (der Ellipsen) kann verwendet werden, um festzulegen, wo sie angezeigt werden.)</li> 
 <li>Die Funktion <codeph>drawEgg()</codeph> zeichnet die Ellipsen unterschiedlicher Größe und füllt sie mithilfe der Methode <codeph>beginFill()</codeph>. Für diese Funktion wurde keine erweiterte Fehlerverarbeitung geschrieben.</li>
 </ol>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_drawEllipseExample extends Sprite
    {
        public static const SMALL:uint = 0;
        public static const MEDIUM:uint = 1;
        public static const LARGE:uint = 2;

        public function Graphics_drawEllipseExample()
        {
            drawEgg(SMALL, 0, 100);
            drawEgg(MEDIUM, 100, 60);
            drawEgg(LARGE, 250, 35);    
        }

        public function drawEgg(eggSize:uint, x:Number, y:Number):void  {
            
            var myEgg:Shape = new Shape();
            
            myEgg.graphics.beginFill(0xFFFFFF);
            myEgg.graphics.lineStyle(1);

            switch(eggSize) {
                case SMALL:
                    myEgg.graphics.drawEllipse(x, y, 60, 70);
                    break;
                case MEDIUM:
                    myEgg.graphics.drawEllipse(x, y, 120, 150);    
                    break;
                case LARGE:
                    myEgg.graphics.drawEllipse(x, y, 150, 200);
                    break;
                default:
                    trace ("Wrong size! There is no egg.");
                break;            
            }
            
            myEgg.graphics.endFill();
    
            this.addChild(myEgg);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawCircle()"><linktext>drawCircle()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawGraphicsData"><apiName>drawGraphicsData</apiName><shortdesc>
	 Sendet eine Reihe von IGraphicsData-Instanzen für das Zeichnen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>graphicsData</apiItemName><apiType value="Vector$flash.display:IGraphicsData"/><apiDesc>Ein Vektor mit Grafikobjekten, die die IGraphicsData-Schnittstelle implementieren.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sendet eine Reihe von IGraphicsData-Instanzen für das Zeichnen. Diese Methode akzeptiert einen Vektor mit Objekten, einschließlich Pfade, Füllungen und Striche, die die IGraphicsData-Schnittstelle implementieren. Ein Vektor mit IGraphicsData-Instanzen kann sich auf einen Teil einer Form beziehen, kann aber auch ein komplexer, umfangreicher Datensatz sein, der eine Form vollständig darstellt.
     
     
     <p>
     Grafikpfade können andere Grafikpfade enthalten. Enthält der <codeph>graphicsData</codeph>-Vektor einen Pfad, so wird dieser während dieses Vorgangs mit allen seinen Unterpfaden dargestellt.
     </p>
     
     </apiDesc><example conref="examples\Graphics_DrawGraphicsDataExample.as"> Im folgenden Beispiel wird ein GraphicsGradientFill-Objekt für die Festlegung der Fülleigenschaften eines Quadrats erstellt. Danach wird für die Festlegung der Eigenschaften der Begrenzungslinie des Quadrats ein GraphicsStroke-Objekt (für die Linienstärke) und ein GraphicsSolidFill-Objekt (für die Linienfarbe) erstellt. Weiterhin wird ein GraphicsPath-Objekt erstellt, das die Werte zum Zeichnen der Form enthält. Diese Objekte werden alle in einem IGraphicsData-Objekt gespeichert und für die Darstellung der Form an den <codeph>drawGraphicsData()</codeph>-Befehl übergeben.
<codeblock>
package{
    import flash.display.*;
    import flash.geom.*;
    
    public class DrawGraphicsDataExample extends Sprite {

    public function DrawGraphicsDataExample(){    

    // establish the fill properties
    var myFill:GraphicsGradientFill = new GraphicsGradientFill();
    myFill.colors = [0xEEFFEE, 0x0000FF];
    myFill.matrix = new Matrix();
    myFill.matrix.createGradientBox(100, 100, 0);
 
    // establish the stroke properties
    var myStroke:GraphicsStroke = new GraphicsStroke(2);
    myStroke.fill = new GraphicsSolidFill(0x000000);
 
    // establish the path properties
    var myPath:GraphicsPath = new GraphicsPath(new Vector.&lt;int>(), new Vector.&lt;Number>());
    myPath.commands.push(1,2,2,2,2);
    myPath.data.push(10,10, 10,100, 100,100, 100,10, 10,10);
 
    // populate the IGraphicsData Vector array
    var myDrawing:Vector.&lt;IGraphicsData> = new Vector.&lt;IGraphicsData>();
    myDrawing.push(myFill, myStroke, myPath);
 
    // render the drawing 
    graphics.drawGraphicsData(myDrawing);
    }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#IGraphicsData"><linktext>flash.display.IGraphicsData</linktext></link><link href="flash.display.xml#GraphicsBitmapFill"><linktext>flash.display.GraphicsBitmapFill</linktext></link><link href="flash.display.xml#GraphicsEndFill"><linktext>flash.display.GraphicsEndFill</linktext></link><link href="flash.display.xml#GraphicsGradientFill"><linktext>flash.display.GraphicsGradientFill</linktext></link><link href="flash.display.xml#GraphicsPath"><linktext>flash.display.GraphicsPath</linktext></link><link href="flash.display.xml#GraphicsShaderFill"><linktext>flash.display.GraphicsShaderFill</linktext></link><link href="flash.display.xml#GraphicsSolidFill"><linktext>flash.display.GraphicsSolidFill</linktext></link><link href="flash.display.xml#GraphicsStroke"><linktext>flash.display.GraphicsStroke</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawPath"><apiName>drawPath</apiName><shortdesc>
	 Sendet eine Reihe von Befehlen für das Zeichnen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiDesc>Ein Ganzzahlvektor, der Befehle darstellt, die in der GraphicsPathCommand-Klasse definiert sind. Die GraphicsPathCommand-Klasse ordnet Befehle numerischen Bezeichnern für dieses Vektor-Array zu.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiDesc>Ein Zahlenvektor, bei dem jedes Zahlenpaar als Koordinatenposition behandelt wird (ein Paar bestehend aus x und y). Die Wertepaare aus x- und y-Koordinaten sind keine Point-Objekte. Der <codeph>data</codeph>-Vektor besteht aus einer Reihe von Zahlen, bei dem jede Zweiergruppe eine Koordinatenposition darstellt. 
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Legt die Windungsregel mithilfe eines in der GraphicsPathWinding-Klasse definierten Werts fest.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sendet eine Reihe von Befehlen für das Zeichnen. Die <codeph>drawPath()</codeph>-Methode verwendet Vektor-Arrays, um einzelne <codeph>moveTo()</codeph>-, <codeph>lineTo()</codeph>- und <codeph>curveTo()</codeph>-Zeichenbefehle in einem einzigen Aufruf zusammenzufassen. Die Parameter der <codeph>drawPath()</codeph>-Methode kombinieren Zeichenbefehle mit Wertepaaren aus x- und y-Koordinaten und einer Zeichenrichtung. Die Zeichenbefehle sind Werte der GraphicsPathCommand-Klasse. Die Wertepaare aus x- und y-Koordinaten sind Zahlen in einem Array, wobei jedes Paar eine Koordinatenposition festlegt. Die Zeichenrichtung ist ein Wert aus der GraphicsPathWinding-Klasse.
     
	 <p>
	 Generell ist die Darstellung von Zeichnungen mithilfe von <codeph>drawPath()</codeph> schneller als mit einer Reihe einzelner <codeph>lineTo()</codeph>- und <codeph>curveTo()</codeph>-Methoden. 
	 </p>
     
	 <p>
     Die <codeph>drawPath()</codeph>-Methode verwendet eine gleitende Berechnung, sodass die Drehung und Skalierung von Formen genauer ist und ein besseres Ergebnis erzielt. Andererseits können Kurven, die mithilfe der <codeph>drawPath()</codeph>-Methode gesendet wurden, geringfügige Ausrichtungsfehler auf der Subpixelebene aufweisen, wenn sie gemeinsam mit der <codeph>lineTo()</codeph>- oder <codeph>curveTo()</codeph>-Methode verwendet werden.
     </p>
     
	 <p>
	 Die <codeph>drawPath()</codeph>-Methode verwendet auch leicht unterschiedliche Regeln für das Füllen und Zeichnen von Linien. Diese sind nachfolgend beschrieben:
     </p>
     
	 <ul>
     <li>Beim Anwenden einer Füllung beim Darstellen eines Pfads:
	  <ul>
          <li>Ein Unterpfad, der kürzer als 3 Punkte ist, wird nicht dargestellt. (Beachten Sie jedoch, dass der Strich trotzdem dargestellt wird, und zwar in Übereinstimmung mit den Regeln für Striche, siehe unten.)</li>
	      <li>Ein nicht geschlossener Unterpfad (Endpunkt und Anfangspunkt stimmen nicht überein) wird implizit geschlossen.</li>
	   </ul>
     </li>
     <li>Beim Anwenden eines Strichs beim Darstellen eines Pfads:
       <ul>
	     <li>Der Unterpfad kann aus einer beliebigen Anzahl an Punkten bestehen.</li>
	     <li>Der Unterpfad wird niemals implizit geschlossen.</li>
        </ul>
     </li>
     </ul>
     
     </apiDesc><example conref="examples\Graphics_DrawPathExample.as"> Im folgenden Beispiel werden zwei Vector-Objekte mit Daten gefüllt und dann zum Zeichnen eines blauen Sterns an die <codeph>drawPath()</codeph>-Methode übergeben. Der erste Vektor, <codeph>star_commands</codeph>, enthält eine Reihe von Ganzzahlen, die Zeichenbefehle aus der flash.display.GraphicsPathCommand-Klasse darstellen. Dabei entspricht der Wert 1 einem <codeph>MoveTo()</codeph>-und der Wert 2 einem <codeph>LineTo()</codeph>-Befehl. Der zweite Vektor, <codeph>star_coord</codeph>, enthält fünf Sätze aus x- und y-Koordinatenpaaren. Die <codeph>drawPath()</codeph>-Methode gleicht zum Zeichnen des Sterns die Befehle mit den Positionen ab.
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {

    public function DrawPathExample(){

    var star_commands:Vector.&lt;int> = new Vector.&lt;int>(5, true);
    
    star_commands[0] = 1;
    star_commands[1] = 2;
    star_commands[2] = 2;
    star_commands[3] = 2;
    star_commands[4] = 2;

    var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>(10, true);
    star_coord[0] = 66; //x
    star_coord[1] = 10; //y 
    star_coord[2] = 23; 
    star_coord[3] = 127; 
    star_coord[4] = 122; 
    star_coord[5] = 50; 
    star_coord[6] = 10; 
    star_coord[7] = 49; 
    star_coord[8] = 109; 
    star_coord[9] = 127;


    graphics.beginFill(0x003366);
    graphics.drawPath(star_commands, star_coord);

    }

    }
}

</codeblock></example><example conref="examples\Graphics_DrawPathExample2.as"> Im Beispiel oben wird jeder Befehl und jedes Koordinatenpaar einzeln zugewiesen, damit Ihre Position im Array gezeigt werden kann. Sie können jedoch auch ein einer einzigen Anweisung zugewiesen werden. Im folgenden Beispiel wird derselbe Stern gezeichnet, indem die Werte für die Arrays in einer einzigen <codeph>push()</codeph>-Anweisung zugewiesen werden:
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {
    public function DrawPathExample(){
        var star_commands:Vector.&lt;int> = new Vector.&lt;int>();
        star_commands.push(1, 2, 2, 2, 2);

           var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>();
           star_coord.push(66,10, 23,127, 122,50, 10,49, 109,127);

        graphics.beginFill(0x003366);
        graphics.drawPath(star_commands, star_coord);
    }
    }
}


</codeblock> <b>Hinweis:</b> Standardmäßig verwendet die <codeph>drawPath()</codeph>-Methode den Windungstyp „Gerade-Ungerade“. Dadurch wird die Mitte des Sterns nicht gefüllt. Legen Sie im dritten Parameter den Windungstyp „Nicht null“ fest, damit die Mitte des Sterns gefüllt wird:
 <codeblock>
 graphics.drawPath(star_commands, star_coord, GraphicsPathWinding.NON_ZERO);
 </codeblock>
 
</example></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRect"><apiName>drawRect</apiName><shortdesc>
	 Zeichnet ein Rechteck.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Parameter <codeph>width</codeph> oder <codeph>height</codeph> etwas anderes als eine Zahl enthält (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die horizontale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die vertikale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Breite des Rechtecks (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Höhe des Rechtecks (in Pixel).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Zeichnet ein abgerundetes Rechteck.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Zeichnet ein Rechteck. Setzen Sie den Linienstil oder die Füllung oder beides, bevor Sie die <codeph>drawRect()</codeph>-Methode aufrufen. Dazu rufen Sie die Methode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginBitmapFill()</codeph> auf.
	 
	 </apiDesc><example>Am Ende des Abschnitts über diese Klasse finden Sie in <xref href="Graphics.html#includeExamplesSummary">Beispiel</xref> , in dem die Verwendung dieser Methode veranschaulicht wird. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRoundRect()"><linktext>drawRoundRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRoundRect"><apiName>drawRoundRect</apiName><shortdesc>
	 Zeichnet ein abgerundetes Rechteck.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Parameter <codeph>width</codeph>, <codeph>height</codeph>, <codeph>ellipseWidth</codeph> oder <codeph>ellipseHeight</codeph> etwas anderes als eine Zahl enthält (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die horizontale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die vertikale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Breite des abgerundeten Rechtecks (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Höhe des abgerundeten Rechtecks (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Breite der Ellipse, die zum Zeichnen der abgerundeten Ecken verwendet wird (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Die Höhe der Ellipse, die zum Zeichnen der abgerundeten Ecken verwendet wird (in Pixel). Optional. Wird kein Wert angegeben, wird als Standardwert der Wert verwendet, der für den Parameter <codeph>ellipseWidth</codeph> angegeben wurde.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Zeichnet ein abgerundetes Rechteck.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Zeichnet ein abgerundetes Rechteck. Setzen Sie den Linienstil oder die Füllung oder beides, bevor Sie die <codeph>drawRoundRect()</codeph>-Methode aufrufen. Dazu rufen Sie die Methode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginBitmapFill()</codeph> auf.
	 
	 </apiDesc><example>Am Ende des Abschnitts über diese Klasse finden Sie in <xref href="Graphics.html#includeExamplesSummary">Beispiel</xref> , in dem die Verwendung dieser Methode veranschaulicht wird. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRect()"><linktext>drawRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawTriangles"><apiName>drawTriangles</apiName><shortdesc>
	 Stellt einen Satz an Dreiecken dar, normalerweise, um Bitmaps zu verzerren und ihnen ein dreidimensionales Aussehen zu verleihen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiDesc>Ein Zahlenvektor, bei dem jedes Zahlenpaar als Koordinatenposition behandelt wird (ein Paar bestehend aus x und y). Der <codeph>vertices</codeph>-Parameter wird benötigt.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Ein Ganzzahl- oder Indexvektor, bei dem jeweils drei Indexwerte ein Dreieck definieren. Ist der <codeph>indexes</codeph>-Parameter null, so definieren jeweils drei Scheitelpunkte (sechs x,y-Paare im <codeph>vertices</codeph>-Vektor) ein Dreieck. Andernfalls bezieht sich jede Indexposition auf einen Scheitelpunkt, d. h. ein Zahlenpaar im <codeph>vertices</codeph>-Vektor. Beispiel: <codeph>indexes[1]</codeph> verweist auf (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>). Der <codeph>indexes</codeph>-Parameter ist optional, allgemein verringern Indizes jedoch die gesendete und berechnete Datenmenge. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Ein Vektor normalisierter Koordinaten, der für die Anwendung von Texturmapping verwendet wird. Jede Koordinate verweist auf einen Punkt in der Bitmap, der für die Füllung verwendet wird. Für jeden Scheitelpunkt muss es eine UV- oder UVT-Koordinate geben. Die UV-Koordinaten (0,0) entsprechen dem linken oberen Bereich der Bitmap, während (1,1) dem rechten unteren Bereich entspricht. 
     <p>Entspricht die Länge dieses Vektors der doppelten Länge des <codeph>vertices</codeph>-Vektors, so werden die normalisierten Koordinaten ohne Perspektivenkorrektur verwendet. </p>
     <p>Entspricht die Länge dieses Vektors der dreifachen Länge des <codeph>vertices</codeph>-Vektors, so wird die dritte Koordinate als „t“ interpretiert, als Entfernung zwischen Auge und Textur im Sichtraum. Dies ermöglicht der Wiedergabe-Engine die korrekte Anwendung von Perspektiven beim Texturmapping im 3D-Raum.</p>
     <p>Ist der <codeph>uvtData</codeph>-Parameter null, werden die normalen Füllregeln (und beliebigen Füllungstypen) angewendet.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Legt fest, ob Dreiecke, die in eine festgelegte Richtung zeigen, dargestellt werden sollen. Dieser Parameter verhindert die Darstellung von Dreiecken, die in der aktuellen Ansicht nicht sichtbar sind. Dieser Parameter kann auf einen beliebigen in der TriangleCulling-Klasse festgelegten Wert gesetzt werden. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt einen Satz an Dreiecken dar, normalerweise, um Bitmaps zu verzerren und ihnen ein dreidimensionales Aussehen zu verleihen. Die <codeph>drawTriangles()</codeph>-Methode ordnet den Flächen von Dreiecken entweder die aktuelle oder eine Bitmapfüllung als Satz von Koordinaten (u,v) zu. 
     <p>
     Es kann jeder Füllungstyp verwendet werden, aber wenn die Füllung über eine Transformationsmatrix verfügt, wird diese Transformationsmatrix ignoriert.
     </p>
     
     <p>
     Ein <codeph>uvt</codeph>-Parameter verbessert bei der Verwendung einer Bitmapfüllung das Texturmapping. 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:endFill"><apiName>endFill</apiName><shortdesc>
	 Versieht die Linien und Kurven, die seit dem letzten Aufruf der Methode „beginFill()“, „beginGradientFill()“ oder „beginBitmapFill()“ hinzugefügt wurden, mit einer Füllung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a square with red fill on the Stage:
	 
	 <listing>
	 this.createEmptyMovieClip("square_mc", this.getNextHighestDepth());
	 square_mc.beginFill(0xFF0000);
	 square_mc.moveTo(10, 10);
	 square_mc.lineTo(100, 10);
	 square_mc.lineTo(100, 100);
	 square_mc.lineTo(10, 100);
	 square_mc.lineTo(10, 10);
	 square_mc.endFill();
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Versieht die Linien und Kurven mit einer Füllung.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Versieht die Linien und Kurven, die seit dem letzten Aufruf der Methode <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginBitmapFill()</codeph> hinzugefügt wurden, mit einer Füllung. Flash verwendet die im vorherigen Aufruf der Methode <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> oder <codeph>beginBitmapFill()</codeph> angegebene Füllung. Wenn die aktuelle Zeichnungsposition nicht der in einer <codeph>moveTo()</codeph>-Methode angegebenen vorherigen Position entspricht und eine Füllung definiert ist, wird der Pfad mit einer Linie geschlossen und dann gefüllt.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineBitmapStyle"><apiName>lineBitmapStyle</apiName><shortdesc>
	 Legt eine Bitmap fest, die beim Zeichnen von Linien für den Linienstrich verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die Bitmap, die für den Linienstrich verwendet wird.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine optionale Transformationsmatrix, wie sie in der flash.geom.Matrix-Klasse definiert ist. Die Matrix wird verwendet, um die Bitmap zu skalieren oder anderweitig zu bearbeiten, bevor sie auf den Linienstil angewendet wird.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Ob eine Bitmap in einem Kachelmuster wiederholt wird.
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ob auf die Bitmap eine Glättung angewendet wird.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt eine Bitmap fest, die beim Zeichnen von Linien für den Linienstrich verwendet wird. 
     
     <p>Der Bitmaplinienstil wird für nachfolgende Aufrufe von Graphics-Methoden, z. B. <codeph>lineTo()</codeph> oder <codeph>drawCircle()</codeph>, verwendet. Der Linienstil bleibt wirksam, bis Sie die <codeph>lineStyle()</codeph>- oder<codeph>lineGradientStyle()</codeph>-Methode oder wieder die <codeph>lineBitmapStyle()</codeph>-Methode mit anderen Parametern aufrufen. </p>
     
     <p>Sie können die <codeph>lineBitmapStyle()</codeph>-Methode während des Zeichnens eines Pfads aufrufen, um für unterschiedliche Linienabschnitte in einem Pfad unterschiedliche Stile zu verwenden. </p>
     
     <p>Rufen Sie die <codeph>lineStyle()</codeph>-Methode vor der <codeph>lineBitmapStyle()</codeph>-Methode auf, um einen Strich zu aktivieren, andernfalls ist der Linienstil <codeph>undefined</codeph>.</p>
     
     <p>Wenn Sie die <codeph>clear()</codeph>-Methode aufrufen, wird der Linienstil wieder auf <codeph>undefined</codeph> gesetzt.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineGradientStyle"><apiName>lineGradientStyle</apiName><shortdesc>
	 Legt einen Verlauf für den Strich beim Zeichnen von Linien fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein Wert aus der GradientType-Klasse, mit dem angegeben wird, welcher Farbverlaufstyp verwendet werden soll, entweder „GradientType.LINEAR“ oder „GradientType.RADIAL“.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit hexadezimalen RGB-Farbwerten, die im Farbverlauf verwendet werden sollen (beispielsweise 0xFF0000 für Rot, 0x0000FF für Blau usw.).
	 
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit Alphawerten für die entsprechenden Farben im Array „colors“. Gültig sind Werte von 0 bis 1. Ist der Wert kleiner als 0, ist der Standardwert 0. Ist der Wert größer als 1, ist der Standardwert 1.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit Farbverteilungsverhältnissen. Die zulässigen Werte liegen zwischen 0 und 255. Dieser Wert gibt den Breitenanteil an, in dem die Farbe mit 100 % gesampelt wird. Der Wert 0 stellt die linke Position im Farbverlaufsfeld dar, 255 die rechte. Dieser Wert repräsentiert Positionen im Farbverlaufsfeld, nicht im Koordinatenraum des endgültigen Farbverlaufs, der breiter oder schmaler als das Farbverlaufsfeld sein kann. Geben Sie für jeden Wert im Parameter <codeph>colors</codeph> einen Wert an. 
	 
	 <p>Die folgende Abbildung zeigt für einen linearen Verlauf mit den beiden Farben Rot und Blau die Farbplatzierung im Verlauf basierend auf den verschiedenen Werten im <codeph>ratios</codeph>-Array:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Gradient</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 0 und 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 0 und 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="Linearer Farbverlauf blau-grün mit ratios-Werten von 127 und 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Die Werte im Array müssen sich sequenziell erhöhen. Beispiel: <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
   	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine Transformationsmatrix, wie sie von der flash.geom.Matrix-Klasse definiert wird. Die flash.geom.Matrix-Klasse umfasst eine <codeph>createGradientBox()</codeph>-Methode, mit der Sie die Matrix zur Verwendung mit der <codeph>lineGradientStyle()</codeph>-Methode auf einfache Weise festlegen können.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>Ein Wert aus der SpreadMethod-Klasse, der festlegt, welche Auftragstärke zu verwenden ist: 
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="3"><tbody><row><entry align="center"><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>
      <entry align="center"><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>
      <entry align="center"><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>Ein Wert aus der InterpolationMethod-Klasse, der festlegt, welcher Wert zu verwenden ist. Angenommen, Sie haben einen einfachen linearen Farbverlauf zwischen zwei Farben (wobei der Parameter <codeph>spreadMethod</codeph> auf <codeph>SpreadMethod.REFLECT</codeph> gesetzt ist). Die verschiedenen Interpolationsmethoden haben folgende Auswirkung auf die Darstellung des Farbverlaufs:
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine Zahl, die die Position des Farbverlaufsbrennpunkts steuert. Der Wert 0 bedeutet, dass der Brennpunkt in der Mitte liegt. Der Wert 1 bedeutet, dass der Brennpunkt an einem Rand des Farbverlaufskreises liegt. Der Wert -1 bedeutet, dass der Brennpunkt am anderen Rand des Farbverlaufskreises liegt. Werte, die kleiner als -1 oder größer als 1 sind, werden auf -1 bzw. 1 gerundet. Das folgende Bild zeigt einen Farbverlauf mit einem <codeph>focalPointRatio</codeph> von -0,75:
   	 
     <p><adobeimage alt="Radialer Farbverlauf mit focalPointRatio-Wert von 0,75" href="../../images/radial_sketch.jpg"/> </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt einen Verlauf für den Strich beim Zeichnen von Linien fest.
     
     <p>Der Linienverlaufsstil wird für nachfolgende Aufrufe von Graphics-Methoden, z. B. <codeph>lineTo()</codeph> oder <codeph>drawCircle()</codeph>, verwendet. Der Linienstil bleibt wirksam, bis Sie die <codeph>lineStyle()</codeph>- oder<codeph>lineBitmapStyle()</codeph>-Methode oder wieder die <codeph>lineGradientStyle()</codeph>-Methode mit anderen Parametern aufrufen. </p>
     
     <p>Sie können <codeph>lineGradientStyle()</codeph> beim Zeichnen eines Pfads aufrufen, um für unterschiedliche Liniensegmente in einem Pfad unterschiedliche Linientypen zu verwenden. </p>
     
     <p>Rufen Sie die <codeph>lineStyle()</codeph>-Methode vor der <codeph>lineGradientStyle()</codeph>-Methode auf, um einen Strich zu aktivieren, andernfalls ist der Linienstil <codeph>undefined</codeph>.</p>
     
     <p>Wenn Sie die <codeph>clear()</codeph>-Methode aufrufen, wird der Linienstil wieder auf <codeph>undefined</codeph> gesetzt.
     </p>
	 
	 </apiDesc><example conref="examples\Graphics_lineGradientStyleExample.as"> Im folgenden Beispiel werden ein Rechteck und ein Kreis mit einem Farbverlaufsstrich von Rot über Grün zu Blau gezeichnet.
 
 <p>Mit der Methode <codeph>createGradientBox()</codeph> aus der <codeph>Matrix</codeph>-Klasse wird das Verlaufsfeld auf eine Breite von 200 und eine Höhe von 40 festgelegt. Die Stärke der Linie wird auf 5 Pixel festgelegt. Die Strichstärke muss für die Methode <codeph>lineGradientStyle()</codeph> definiert werden. Der Verlauf ist als linear festgelegt. Als Farben für den Verlauf sind Rot, Grün und Blau angegeben. Die Transparenz (der Alphawert) für die Farben wird auf 1 (deckend) festgelegt Die Verteilung des Verlaufs ist gleichmäßig, wobei die Farben mit 100 % bei 0 (links im Verlaufsfeld), 128 (Mitte des Feldes) und 255 (rechts im Feld) gesampelt werden. Die Breite des Rechtecks umfasst das gesamte Spektrum des Verlaufs, während der Kreis 50 % ab der Mitte des Spektrums umfasst.</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    import flash.geom.Matrix; 
    import flash.display.GradientType;
    
    public class Graphics_lineGradientStyleExample extends Sprite
    {
        public function Graphics_lineGradientStyleExample()
        {
            var myShape:Shape = new Shape();
            var gradientBoxMatrix:Matrix = new Matrix();
  
            gradientBoxMatrix.createGradientBox(200, 40, 0, 0, 0);  
            
            myShape.graphics.lineStyle(5);
  
            myShape.graphics.lineGradientStyle(GradientType.LINEAR, [0xFF0000,
            0x00FF00, 0x0000FF], [1, 1, 1], [0, 128, 255], gradientBoxMatrix);
            
            myShape.graphics.drawRect(0, 0, 200, 40);
            myShape.graphics.drawCircle(100, 120, 50);  
             
            this.addChild(myShape);
    
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineShaderStyle"><apiName>lineShaderStyle</apiName><shortdesc>
	 Legt einen Shader für den Linienstrich beim Zeichnen von Linien fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>Der für den Linienstrich zu verwendende Shader.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine optionale Transformationsmatrix, wie sie in der flash.geom.Matrix-Klasse definiert ist. Die Matrix wird verwendet, um die Bitmap zu skalieren oder anderweitig zu bearbeiten, bevor sie auf den Linienstil angewendet wird.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt einen Shader für den Linienstrich beim Zeichnen von Linien fest. 
     
     <p>Der Shaderlinienstil wird für nachfolgende Aufrufe von Graphics-Methoden, z. B. <codeph>lineTo()</codeph> oder <codeph>drawCircle()</codeph>, verwendet. Der Linienstil bleibt wirksam, bis Sie die <codeph>lineStyle()</codeph>- oder<codeph>lineGradientStyle()</codeph>-Methode oder wieder die <codeph>lineBitmapStyle()</codeph>-Methode mit anderen Parametern aufrufen. </p>
     
     <p>Sie können die <codeph>lineShaderStyle()</codeph>-Methode während des Zeichnens eines Pfads aufrufen, um für unterschiedliche Linienabschnitte in einem Pfad unterschiedliche Stile zu verwenden. </p>
     
     <p>Rufen Sie die <codeph>lineStyle()</codeph>-Methode vor der <codeph>lineShaderStyle()</codeph>-Methode auf, um einen Strich zu aktivieren, andernfalls ist der Linienstil <codeph>undefined</codeph>.</p>
     
     <p>Wenn Sie die <codeph>clear()</codeph>-Methode aufrufen, wird der Linienstil wieder auf <codeph>undefined</codeph> gesetzt.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineStyle"><apiName>lineStyle</apiName><shortdesc>
     Legt einen Linienstil fest, der für nachfolgende Aufrufe von Graphics-Methoden, z. B. lineTo() oder drawCircle(), verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following code draws a triangle with a 5-pixel, solid magenta line with 
	 no fill, with pixel hinting, no stroke scaling, no caps, and miter joints with 
	 <code>miterLimit</code> set to 1:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", this.getNextHighestDepth());
	 triangle_mc.lineStyle(5, 0xff00ff, 100, true, "none", "round", "miter", 1);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 </listing>
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Eine Ganzzahl, die die Stärke der Linie in Punkt angibt. Gültig sind Werte von 0 bis 255. Wenn keine Zahl angegeben ist oder wenn der Parameter den Wert „undefined“ aufweist, wird keine Linie gezeichnet. Wenn ein kleinerer Wert als 0 übergeben wird, ist der Standardwert 0. Der Wert 0 steht für die geringste Linienstärke. Der Höchstwert beträgt 255. Wenn ein größerer Wert als 255 übergeben wird, ist der Standardwert 255. 
     
     </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der hexadezimale Farbwert der Linie (Rot ist beispielsweise 0xFF0000, Blau 0x0000FF usw.). Wird kein Wert angegeben, ist der Standardwert 0x000000 (Schwarz). Optional. 
	 
 	 
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Eine Ganzzahl, die den Alphawert der Linienfarbe angibt. Gültig sind Werte von 0 bis 1. Wird kein Wert angegeben, ist der Standardwert 1 (einfarbige vollständige Füllung). Ist der Wert kleiner als 0, ist der Standardwert 0. Ist der Wert größer als 1, ist der Standardwert 1. 
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein boolescher Wert, der angibt, ob Striche als ganze Pixel angezeigt werden. Dies wirkt sich sowohl auf die Positionen der Anker einer Kurve als auch auf die Linienstärke des Strichs selbst aus. Wenn <codeph>pixelHinting</codeph> auf <codeph>true</codeph> gesetzt ist, werden die Linienstärken auf volle Pixel eingestellt. Ist <codeph>pixelHinting</codeph> auf <codeph>false</codeph> gesetzt, können Kurven und gerade Linien unterbrochen sein. In den folgenden Abbildungen wird veranschaulicht, wie Flash Player oder Adobe AIR zwei Rechtecke mit abgerundeten Ecken darstellen, die identisch sind, abgesehen davon, dass der <codeph>pixelHinting</codeph>-Parameter in der <codeph>lineStyle()</codeph>-Methode anders eingestellt ist (die Abbildungen sind um 200 % vergrößert, um den Unterschied deutlich zu zeigen):
	 
	 <p><adobeimage alt="pixelHinting-Einstellungen „false“ und „true“" href="../../images/lineStyle_pixelHinting.jpg"/></p>
	 
	 <p>Wird kein Wert angegeben, wird die Funktion nicht verwendet.</p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>Ein Wert aus der LineScaleMode-Klasse, mit dem angegeben wird, welcher Skalierungsmodus verwendet werden soll:
	 
	 <ul>
	 
	 <li>
	 <codeph>LineScaleMode.NORMAL</codeph>: Die Linienstärke wird immer skaliert, wenn das Objekt skaliert wird (der Standard).
	 </li>
	 
	 <li>
	 <codeph>LineScaleMode.NONE</codeph>: Die Linienstärke wird nie skaliert.
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.VERTICAL</codeph>: Die Linienstärke wird nicht skaliert, wenn das Objekt <i>nur</i> vertikal skaliert wurde. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.VERTICAL</codeph> gesetzt wurde. Der Kreis links wurde nur vertikal skaliert, und der Kreis rechts wurde sowohl vertikal als auch horizontal skaliert.
	 
     <p><adobeimage alt="Ein nur vertikal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	 
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.HORIZONTAL</codeph>: Die Linienstärke wird nicht skaliert, wenn das Objekt <i>nur</i> vertikal skaliert wurde. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.HORIZONTAL</codeph> gesetzt wurde. Der Kreis links wurde nur horizontal skaliert, und der Kreis rechts wurde sowohl horizontal als auch vertikal skaliert.
	 
     <p><adobeimage alt="Ein nur horizontal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	 
	 </li>
	 
	 
	 </ul>
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Wert der CapsStyle-Klasse, der den Stil der Linienenden definiert. Folgende Werte sind zulässig: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> und <codeph>CapsStyle.SQUARE</codeph>. Wird kein Wert angegeben, verwendet Flash runde Enden. 
	 <p>Die folgende Abbildung zeigt beispielsweise die verschiedenen Einstellungen für <codeph>capsStyle</codeph>. Die Abbildung zeigt für jede Einstellung eine blaue Linie mit der Stärke 30 (für die <codeph>capsStyle</codeph> gilt) sowie eine überlagerte schwarze Linie mit der Stärke 1 (für die kein <codeph>capsStyle</codeph> gilt):
	 </p>
	 <p><adobeimage alt="NONE, ROUND und SQUARE" href="../../images/linecap.jpg"/></p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Wert der JointStyle-Klasse, der den Verbindungsstil für Winkel festlegt. Folgende Werte sind zulässig: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> und <codeph>JointStyle.ROUND</codeph>. Wird kein Wert angegeben, verwendet Flash runde Verbindungen. 
	 
	 <p>Die folgende Abbildung zeigt beispielsweise die verschiedenen Einstellungen für <codeph>joints</codeph>. Die Abbildung zeigt für jede Einstellung eine blaue Winkellinie mit der Stärke 30 (für die <codeph>jointStyle</codeph> gilt) sowie eine überlagerte schwarze Winkellinie mit der Stärke 1 (für die kein <codeph>jointStyle</codeph> gilt):
	 </p>
	 
     <p><adobeimage alt="MITER, ROUND und BEVEL" href="../../images/linejoin.jpg"/></p>
	 
	 <p><b>Hinweis:</b> Ist <codeph>joints</codeph> auf <codeph>JointStyle.MITER</codeph> gesetzt, können Sie den Parameter <codeph>miterLimit</codeph> verwenden, um die Länge des Winkels einzuschränken.</p>
 	 
	 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3</apiData><apiDesc>Eine Zahl, die die Grenze festlegt, an der ein Winkel abgeschnitten wird. Gültige Werte liegen zwischen 1 und 255 (Werte außerhalb dieses Bereichs werden auf 1 bzw. 255 gerundet). Dieser Wert wird nur dann verwendet, wenn <codeph>jointStyle</codeph> auf <codeph>"miter"</codeph> gesetzt wird. Der Wert <codeph>miterLimit</codeph> steht für die Länge, die ein Winkel über jenen Punkt hinausgehen kann, an dem zwei Linien eine Verbindung bilden. Der Wert drückt einen Faktor der Linieneigenschaft <codeph>thickness</codeph> aus. Bei einem <codeph>miterLimit</codeph>-Faktor von 2,5 und einer <codeph>thickness</codeph> von 10 Pixeln, wird der Winkel bei 25 Pixeln abgeschnitten. 
	 
	 <p>Betrachten Sie beispielsweise die folgenden Winkellinien mit einer <codeph>thickness</codeph> von 20 und mit einem <codeph>miterLimit</codeph> von 1, 2 und 4. Darüber befinden sich schwarze Referenzlinien, die die Schnittpunkte der Verbindungen anzeigen:</p>
	 
     <p><adobeimage alt="Linien mit miterLimit-Werten 1, 2 und 4" href="../../images/miterLimit.jpg"/></p>
	 
	 <p>Beachten Sie, dass bei einem gegebenen <codeph>miterLimit</codeph>-Wert ein bestimmter Maximalwinkel existiert, bei dem der Winkel abgeschnitten wird. In der folgenden Tabelle finden Sie einige Beispiele:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph>-Wert:</entry><entry>Winkel, die kleiner sind als dieser Wert, werden abgeschnitten:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 Grad</entry></row><row><entry>2</entry>      <entry>60 Grad</entry></row><row><entry>4</entry>      <entry>30 Grad</entry></row><row><entry>8</entry>      <entry>15 Grad</entry></row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Legt den Linienstil fest, den Flash zum Zeichnen von Linien verwendet.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Legt einen Linienstil fest, der für nachfolgende Aufrufe von Graphics-Methoden, z. B. <codeph>lineTo()</codeph> oder <codeph>drawCircle()</codeph>, verwendet wird. Der Linienstil bleibt wirksam, bis Sie die <codeph>lineGradientStyle()</codeph>-Methode, die <codeph>lineBitmapStyle()</codeph>-Methode oder wieder die <codeph>lineStyle()</codeph>-Methode mit anderen Parametern aufrufen. 
     
     <p>Sie können die <codeph>lineStyle()</codeph>-Methode während des Zeichnens eines Pfads aufrufen, um für unterschiedliche Linienabschnitte in einem Pfad unterschiedliche Stile zu verwenden.</p> 
	 
	 <p><b>Hinweis: </b> Wenn Sie die <codeph>clear()</codeph>-Methode aufrufen, wird der Linienstil wieder auf <codeph>undefined</codeph> gesetzt.</p>
     
	 </apiDesc><example>Die Verwendung der Methode <codeph>getStyle()</codeph> wird im Beispiel für die Methode <xref href="Graphics.html#lineTo()">lineTo()</xref> oder <xref href="Graphics.html#moveTo()">moveTo()</xref> veranschaulicht. 
     
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineBitmapStyle"><linktext>lineBitmapStyle</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle"><linktext>lineGradientStyle</linktext></link><link href="flash.display.xml#LineScaleMode"><linktext>LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>JointStyle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineTo"><apiName>lineTo</apiName><shortdesc>
	 Zeichnet eine Linie im aktuellen Linienstil von der aktuellen Zeichnungsposition zu (x, y). Die aktuelle Zeichnungsposition wird dann auf (x, y) gesetzt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill.
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die horizontale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die vertikale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Zeichnet eine Linie von der aktuellen Zeichnungsposition zu (x, y).
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Zeichnet eine Linie im aktuellen Linienstil von der aktuellen Zeichnungsposition zu (<codeph>x</codeph>, <codeph>y</codeph>). Die aktuelle Zeichnungsposition wird dann auf (<codeph>x</codeph>, <codeph>y</codeph>) gesetzt. Wenn das Anzeigeobjekt, in dem Sie zeichnen, mit den Flash-Zeichenwerkzeugen erstellte Objekte enthält, werden die Ergebnisse von Aufrufen der <codeph>lineTo()</codeph>-Methode unter diesen Objekten gezeichnet. Wenn Sie <codeph>lineTo()</codeph> vor der <codeph>moveTo()</codeph>-Methode aufrufen, wird die aktuelle Zeichnungsposition standardmäßig auf (<i>0, 0</i>) gesetzt. Wenn ein Parameter fehlt, schlägt die Ausführung dieser Methode fehl, und die aktuelle Zeichnungsposition wird beibehalten.
	 
	 </apiDesc><example conref="examples\Graphics_lineToExample.as"> Im folgenden Beispiel wird mithilfe der Methode <codeph>lineTo()</codeph> ein Trapezoid gezeichnet, das bei Pixel (100, 100) beginnt. 
 <p>Die Linienstärke wird auf 10 Pixel, die Farbe auf gold und deckend gesetzt, es werden keine Linienabschlüsse verwendet (da alle Linien verbunden sind), und die Verbindung zwischen den Linien wird auf <codeph>MITER</codeph> mit einer Winkelgrenze von 10 gesetzt, um spitze Ecken zu erhalten.</p>     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.LineScaleMode;
    import flash.display.CapsStyle;
    import flash.display.JointStyle;
    import flash.display.Shape;


    public class Graphics_lineToExample extends Sprite {

        public function Graphics_lineToExample() {

            var trapezoid:Shape = new Shape();    

            trapezoid.graphics.lineStyle(10, 0xFFD700, 1, false, LineScaleMode.VERTICAL,
                               CapsStyle.NONE, JointStyle.MITER, 10);

            trapezoid.graphics.moveTo(100, 100);
 
            trapezoid.graphics.lineTo(120, 50);
            trapezoid.graphics.lineTo(200, 50);
            trapezoid.graphics.lineTo(220, 100);
            trapezoid.graphics.lineTo(100, 100); 

            this.addChild(trapezoid);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:moveTo"><apiName>moveTo</apiName><shortdesc>
     Verschiebt die aktuelle Zeichnungsposition auf (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
	 
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die horizontale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die vertikale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt (in Pixel).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Verschiebt die aktuelle Zeichnungsposition auf (x, y).
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Verschiebt die aktuelle Zeichnungsposition auf (<codeph>x</codeph>, <codeph>y</codeph>). Wenn ein Parameter fehlt, schlägt die Ausführung dieser Methode fehl, und die aktuelle Zeichnungsposition wird beibehalten.
     
	 </apiDesc><example conref="examples\Graphics_moveToExample.as"> Im folgenden Beispiel wird eine gestrichelte Linie mit einer Strichstärke von drei Pixel gezeichnet. Dazu werden die Methoden <codeph>moveTo()</codeph> und <codeph>lineTo()</codeph> verwendet.
 
 <p>Mithilfe der Methode <codeph>lineStyle()</codeph> wird die Linienstärke auf 3 Pixel festgelegt. Außerdem wird festgelegt, dass keine Skalierung erfolgen soll. Die Farbe wird auf Rot mit 25 Prozent Deckkraft festgelegt. Die Eigenschaft <codeph>CapsStyle</codeph> wird auf „square“ gesetzt (die Standardeinstellung ist „round“).</p>
 
 <p>Da es sich bei <codeph>Graphics_moveToExample</codeph> um eine Instanz der <codeph>Sprite</codeph>-Klasse handelt, ist der Zugriff auf alle Methoden der Graphics-Klasse möglich. Mit den Methoden der Graphics-Klasse kann direkt im Sprite-Objekt <codeph>Graphic_moveToExample</codeph> gezeichnet werden. Wenn dem Vektorzeichenobjekt jedoch keine Form (<codeph>Shape</codeph>) gegeben wird, sind die Möglichkeiten des Verwaltens, Verschiebens oder Änderns beschränkt.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.CapsStyle;
    import flash.display.LineScaleMode;

    public class Graphics_moveToExample extends Sprite
    {
        public function Graphics_moveToExample() {
            
            graphics.lineStyle(3, 0x990000, 0.25, false, 
                            LineScaleMode.NONE, CapsStyle.SQUARE);

            graphics.moveTo(10, 20);
            graphics.lineTo(20, 20);
            graphics.moveTo(30, 20);
            graphics.lineTo(50, 20);
            graphics.moveTo(60, 20);
            graphics.lineTo(80, 20);
            graphics.moveTo(90, 20);
            graphics.lineTo(110, 20);            
            graphics.moveTo(120, 20);
            graphics.lineTo(130, 20);           
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.display:NativeWindowType"><apiName>NativeWindowType</apiName><shortdesc>
	 Die NativeWindowType-Klasse definiert Konstanten für die type-Eigenschaft des NativeWindowInitOptions-Objekts, das für die Erstellung von nativen Fenstern verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die NativeWindowType-Klasse definiert Konstanten für die <codeph>type</codeph>-Eigenschaft des NativeWindowInitOptions-Objekts, das für die Erstellung von nativen Fenstern verwendet wird.
	 
	 <p><b>Hinweis:</b> Der Wert der type-Eigenschaft wird bei der Erstellung eines Fensters festgelegt und kann später nicht mehr geändert werden.</p>
	 	  
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowType:LIGHTWEIGHT"><apiName>LIGHTWEIGHT</apiName><shortdesc>
		 Ein minimales Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lightweight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Ein minimales Fenster.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
		 Ein typisches Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Ein typisches Fenster.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:UTILITY"><apiName>UTILITY</apiName><shortdesc>
		 Ein Dienstprogrammfenster.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>utility</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Ein Dienstprogrammfenster.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowDisplayState"><apiName>NativeWindowDisplayState</apiName><shortdesc>
     Die NativeWindowDisplayState-Klasse definiert Konstanten für die Namen von Fensteranzeigestatus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     Die NativeWindowDisplayState-Klasse definiert Konstanten für die Namen von Fensteranzeigestatus.
     
     <p><b>Hinweis:</b> Die Vollbildmodi werden mithilfe der <codeph>displayState</codeph>-Eigenschaft des Stage-Objekts gesetzt, nicht mit der <codeph>displayState</codeph>-Eigenschaft des Fensters.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link></related-links><apiValue id="flash.display:NativeWindowDisplayState:MAXIMIZED"><apiName>MAXIMIZED</apiName><shortdesc>
         Der maximierte Anzeigestatus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>maximized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Der maximierte Anzeigestatus.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:MINIMIZED"><apiName>MINIMIZED</apiName><shortdesc>
         Der minimierte Anzeigestatus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>minimized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Der minimierte Anzeigestatus.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
         Der normale Anzeigestatus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Der normale Anzeigestatus.
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Screen"><apiName>Screen</apiName><shortdesc>
	 Die Screen-Klasse stellt Informationen über die Anzeigebildschirme bereit, die für diese Anwendung verfügbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die Screen-Klasse stellt Informationen über die Anzeigebildschirme bereit, die für diese Anwendung verfügbar sind.
	 
	 <p>Bei Bildschirmen handelt es sich um unabhängige Desktop-Bereiche innerhalb eines möglicherweise größeren virtuellen Desktops. Der Ursprung des virtuellen Desktops ist die obere linke Ecke des vom Betriebssystem festgelegten Hauptbildschirms. Deshalb können die Koordinaten für die Begrenzungen eines einzelnen Anzeigebildschirms negativ sein. Der virtuelle Desktop kann auch Bereiche enthalten, die sich nicht in einem der Anzeigebildschirme befinden.</p>
	 
	 <p>Die Screen-Klasse enthält statische Klassenmitglieder für den Zugriff auf die verfügbaren Bildschirmobjekte sowie Instanzmitglieder für den Zugriff auf die Eigenschaften eines einzelnen Bildschirms. Bildschirminformationen sollten nicht zwischengespeichert werden, da sie jederzeit von einem Benutzer geändert werden können.</p>
	  
	 <p>Beachten Sie, dass die Bildschirme und die an den Computer angeschlossenen Monitore sich nicht unbedingt 1:1 entsprechen. Beispielsweise kann ein Bildschirm auf zwei Monitoren angezeigt werden.</p>
	 
	 <p>Die Screen-Klasse kann nicht direkt instanziiert werden. Aufrufe des <codeph>new Screen()</codeph>-Konstruktors geben eine <codeph>ArgumentError</codeph>-Ausnahme aus.</p>
	 
	 </apiDesc><example conref="examples\ScreenExample.as"> Im folgenden Beispiel wird die DockingWindow-Klasse verwendet, um ein Fenster zu erstellen, das an den Bildschirmseiten angedockt wird. Dies wird in den folgenden Schritten erreicht:
 
 <ol>
     <li>Reaktion auf Tastaturereignisse, um zu bestimmen, an welcher Seite des Bildschirms das Fenster angedockt werden soll.</li>
 
    <li>Zugriff auf die statische <codeph>getScreensForRectangle()</codeph>-Methode der Screen-Klasse, um das Screen-Objekt für den Bildschirm abzurufen, auf dem das Fenster derzeit angezeigt wird.</li>
 
    <li>Zurücksetzen der Fenstergrenzen auf Grundlage der Bildschirmabmessungen.</li>
 
    <li>Neuzeichnen des Fensterinhalts auf Grundlage der neuen Fensterabmessungen.</li>
 
 </ol>
 
 <p>Hinweis: Diese Klasse ist als Stammklasse einer AIR-Anwendung mit den Einstellungen <codeph>SystemChrome="none"</codeph> und <codeph>transparent="true"</codeph> vorgesehen. Um diese Klasse bei einem Fenster mit Systemchrom zu verwenden, müssen Sie die Chromestärke und Mindestbreite des Fensters bei der Berechnung der Fensterposition und -größe berücksichtigen.</p>
<codeblock>

package
{
    import flash.display.Screen;
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.KeyboardEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;

    public class DockingWindow extends Sprite
    {
        private const dockedWidth:uint = 80;
        private const dockedHeight:uint = 80;
        
        public function DockingWindow():void{
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onKey);
            dockLeft();
        }
        
        private function onKey(event:KeyboardEvent):void{
            switch(event.keyCode){
                case Keyboard.LEFT :
                    dockLeft();
                    break;
                case Keyboard.RIGHT :
                    dockRight();
                    break;
                case Keyboard.UP :
                    dockTop();
                    break;
                case Keyboard.DOWN :
                    dockBottom();
                    break;
                case Keyboard.SPACE :
                    stage.nativeWindow.close();
            }    
        }
        
        public function dockLeft():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.height = screen.visibleBounds.height;
            stage.stageWidth = dockedWidth;
            drawContent();
        }
        
        public function dockRight():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.width - dockedWidth;            
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.stageWidth = dockedWidth;
            stage.nativeWindow.height = screen.visibleBounds.height;
            drawContent();
        }
        
        public function dockTop():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;
            drawContent();
        }
        
        public function dockBottom():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.height - dockedHeight;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;    
            drawContent();        
        }
        
        private function getCurrentScreen():Screen{
            return Screen.getScreensForRectangle(stage.nativeWindow.bounds)[0];
        }
        
        private function drawContent():void{
            const size:int = 60;
            const pad:int = 10;
            var numHSquares:int = Math.floor(stage.stageWidth/(size + pad));
            var numVSquares:int = Math.floor(stage.stageHeight/(size + pad));
            with (graphics){
                clear();
                lineStyle(1);
                beginFill(0x3462d5,.7);
                for(var i:int = 0; i &lt; numHSquares; i++){
                    for(var j:int = 0; j &lt; numVSquares; j++){                
                            drawRect((i * (size + pad)) + pad, (j * (size + pad)) + pad, size, size);
                    }
                }
                endFill();
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Screen:getScreensForRectangle"><apiName>getScreensForRectangle</apiName><shortdesc>
		 Gibt den (möglicherweise leeren) Satz der Bildschirme zurück, die das angegebene Rechteck schneiden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Ein Array mit Screen-Objekten, die die Bildschirme enthalten, die einen beliebigen Teil des vom <codeph>rect</codeph>-Parameter definierten Bereichs enthalten.
		 
		 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck mit Koordinaten relativ zum Ursprung des virtuellen Desktops. Bei diesem Ursprung handelt es sich um die linke obere Ecke des primären Bildschirms.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Gibt den (möglicherweise leeren) Satz der Bildschirme zurück, die das angegebene Rechteck schneiden.
		  
		 </apiDesc><example conref="examples\Screen.getScreensForRectangle.1.as"> Das folgende Beispiel zeigt, wie das Array der Bildschirme abgerufen wird, die mindestens einen Teil eines gegebenen Rechtecks enthalten:
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var rect:Rectangle = new Rectangle(-200, 100, 1000, 600);
var intersectedScreens:Array = Screen.getScreensForRectangle(rect);
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:Screen:bounds:get"><apiName>bounds</apiName><shortdesc>
		 Die Begrenzungen dieses Bildschirms.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 Die Begrenzungen dieses Bildschirms.
		 
		 <p>Die Bildschirmposition ist relativ zum virtuellen Desktop.</p>
		 
		 </apiDesc><example conref="examples\Screen.bounds.1.as"> Das folgende Beispiel zeigt, wie die Begrenzungen eines Bildschirms abgerufen werden (in diesem Fall der primäre Anzeigebildschirm):
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.bounds;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:colorDepth:get"><apiName>colorDepth</apiName><shortdesc>
		 Die Farbtiefe dieses Bildschirms in Bit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Die Farbtiefe dieses Bildschirms in Bit.
		 
		 </apiDesc><example conref="examples\Screen.colorDepth.1.as"> Das folgende Beispiel zeigt, wie die Farbtiefe eines Bildschirms abgerufen wird (in diesem Fall der primäre Anzeigebildschirm):
<codeblock>

var mainScreen:Screen = Screen.mainScreen;
var colors:uint = mainScreen.colorDepth;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:mainScreen:get"><apiName>mainScreen</apiName><shortdesc>
		 Die primäre Anzeige.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Screen</apiValueClassifier></apiValueDef><apiDesc>
		 Die primäre Anzeige.
		 
		 </apiDesc><example conref="examples\Screen.mainScreen.1.as"> Das folgende Beispiel zeigt, wie das Screen-Objekt abgerufen wird, das den Hauptbildschirm dieses Computers repräsentiert:
<codeblock>

var primaryScreen:Screen = Screen.mainScreen;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:screens:get"><apiName>screens</apiName><shortdesc>
		 Das Array der derzeit verfügbaren Bildschirme.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3."/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 Das Array der derzeit verfügbaren Bildschirme. 
		 
		 <p>Eine Änderung des zurückgegebenen Arrays hat keinerlei Auswirkungen auf die verfügbaren Bildschirme.</p>
		 
		 </apiDesc><example conref="examples\Screen.screens.1.as"> Das folgende Beispiel zeigt, wie das Array mit den verfügbaren Bildschirmen abgerufen wird:
<codeblock>

var screenArray:Array = Screen.screens;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:visibleBounds:get"><apiName>visibleBounds</apiName><shortdesc>
		 Die Begrenzungen des Bereichs auf diesem Bildschirm, in dem Fenster sichtbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 Die Begrenzungen des Bereichs auf diesem Bildschirm, in dem Fenster sichtbar sind.
		 
		 <p>Die <codeph>visibleBounds</codeph> eines Bildschirms schließen unter Windows die Taskleiste (und andere angedockte Desktopleisten) aus, ebenso wie die Menüleiste und, abhängig von den Systemeinstellungen, das Dock unter Mac OS X. Bei manchen Linuxkonfigurationen ist es nicht möglich, die Sichtbarkeitsgrenzen zu bestimmen. In diesem Fall gibt die <codeph>visibleBounds</codeph>-Eigenschaft denselben Wert zurück wie die <codeph>screenBounds</codeph>-Eigenschaft.</p>
		 
		 </apiDesc><example conref="examples\Screen.usableBounds.1.as"> Das folgende Beispiel zeigt, wie die nutzbaren Begrenzungen eines Bildschirms abgerufen werden (in diesem Fall der primäre Anzeigebildschirm):
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.visibleBounds;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Bitmap"><apiName>Bitmap</apiName><shortdesc>
 Die Bitmap-Klasse repräsentiert Anzeigeobjekte, die Bitmaps darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Repräsentiert Anzeigeobjekte, die von Bildern abgeleitet sind.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Bitmap-Klasse repräsentiert Anzeigeobjekte, die Bitmaps darstellen. Dabei kann es sich um Bilder handeln, die Sie mit der flash.display.Loader-Klasse laden, oder auch um Bilder, die Sie mit dem Konstruktor <codeph>Bitmap()</codeph> erstellen. 
 
 <p>Mit dem Konstruktor <codeph>Bitmap()</codeph> können Sie ein Bitmap-Objekt zu erstellen, das einen Verweis auf ein BitmapData-Objekt enthält. Verwenden Sie nach der Erstellung eines Bitmap-Objekts die Methode <codeph>addChild()</codeph> oder <codeph>addChildAt()</codeph> des übergeordneten DisplayObjectContainer-Objekts, um die Bitmap in die Anzeigeliste aufzunehmen.</p>
 
 <p>Ein Bitmap-Objekt kann seinen BitmapData-Verweis auf mehrere Bitmap-Objekte aufteilen, und zwar unabhängig von Übersetzungs- oder Drehungseigenschaften. Da Sie mehrere Bitmap-Objekte erstellen können, die auf dasselbe BitmapData-Objekt verweisen, können mehrere Anzeigeobjekte dasselbe komplexe BitmapData-Objekt verwenden, ohne die Speicherbelastung des BitmapData-Objekts für jede Anzeigeobjektinstanz berücksichtigen zu müssen.</p>
 
 <p>Ein BitmapData-Objekt kann von einem Bitmap-Objekt auf zweierlei Weise auf den Bildschirm gezeichnet werden: Entweder, indem der Vektorrenderer als eine Form mit Bitmap-Füllung verwendet wird, oder indem Sie eine schnellere Pixelkopierroutine einsetzen. Die Pixelkopierroutine ist wesentlich schneller als der Vektorrenderer, doch muss das Bitmap-Objekt bestimmte Bedingungen erfüllen, damit sie eingesetzt werden kann:</p>
 
 <ul>
 
 <li> Auf das Bitmap-Objekt darf keine Dehnung, Drehung oder Neigung angewendet werden.</li>
 <li> Auf das Bitmap-Objekt darf keine Farbtransformation angewendet werden. </li>
 <li> Auf das Bitmap-Objekt darf kein Mischmodus angewendet werden. </li>
 <li> Das Bild darf nicht über Maskenebenen oder <codeph>setMask()</codeph>-Methoden zugeschnitten werden. </li>
 <li> Das Bild selbst darf keine Maske sein. </li>
 <li> Die Zielkoordinaten müssen sich auf einer ganzen Pixelbegrenzung befinden. </li>
 
 </ul>
 
 <p>Wenn Sie ein Bitmap-Objekt aus einer anderen Domäne als der des Loader-Objekts verwenden, mit dem das Bild geladen wurde, und es keine URL-Richtliniendatei gibt, die den Zugriff auf die Domäne des Loader-Objekts erlaubt, kann ein Skript in dieser Domäne nicht auf die Bitmap-Objekte und deren Eigenschaften und Methoden zugreifen. Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
 </ul>
 
 
 <p><b>Hinweis:</b> Die Bitmap-Klasse ist keine Unterklasse der InteractiveObject-Klasse, sodass keine Mausereignisse ausgelöst werden können. Sie können jedoch die <codeph>addEventListener()</codeph>-Methode des Anzeigeobjekt-Containers verwenden, der das Bitmap-Objekt enthält.</p>
 
 </apiDesc><example conref="examples\BitmapExample.as"> Im folgenden Beispiel wird die BitmapExample-Klasse verwendet, um die Grafik „Image.gif“ an der Standardposition (<i>x = 0, y = 0</i>) in ein „DisplayObject“ zu laden. Eine Kopie von „Image.gif“ wird rechts vom Original positioniert, für das neue Farben auf Pixel angewendet werden, die einen Test mit der <codeph>threshold()</codeph>-Methode bestanden haben. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Es wird eine <codeph>url</codeph>-Eigenschaft erstellt, die den Speicherort und Namen der Bilddatei angibt.</li>
  <li>Der Klassenkonstruktor ruft die <codeph>configureAssets()</codeph>-Methode auf, die wiederum die <codeph>completeHandler()</codeph>-Methode aufruft.</li>
  <li><codeph>configureAssets()</codeph> erstellt ein Loader-Objekt, das dann einen Ereignis-Listener instanziiert. Der Ereignis-Listener wird ausgelöst, wenn die <codeph>completeHandler()</codeph>-Methode die Bildbearbeitung abgeschlossen hat.</li>
  <li>Als Nächstes erstellt die <codeph>buildChild()</codeph>-Methode eine neue Instanz eines URLRequest-Objekts, <codeph>request</codeph>, mit Übergabe von <codeph>url</codeph>, damit der Dateiname und -speicherort bekannt sind.</li>
  <li>Das <codeph>request</codeph>-Objekt wird an die <codeph>loader.load()</codeph>-Methode übergeben, die das Bild über ein Anzeigeobjekt in den Speicher lädt.</li>
  <li>Das Bild wird in die Anzeigeliste eingefügt, die das Bild sofort auf dem Bildschirm bei den Koordinaten <i>x = 0, y = 0</i> anzeigt.</li>
  <li>Die <codeph>completeHandler()</codeph>-Methode führt dann Folgendes aus:
  <ol outputclass="A">
      <li>Sie erstellt ein zweites Loader-Objekt und ein Bitmap-Objekt, das über das Loader-Objekt initialisiert wird.</li>
      <li>Sie erstellt ein zweites Bitmap-Objekt, <codeph>duplicate</codeph>, das wiederum die <codeph>duplicateImage()</codeph>-Methode aufruft, die ein Duplikat des Originalbilds erzeugt. </li>
      <li>Sie erstellt ein BitmapData-Objekt, das dem BitmapData-Objekt des <codeph>duplicate</codeph>-Objekts zugeordnet ist.</li>
      <li>Sie erstellt ein neues Rechteckobjekt, das mit denselben Werten für Koordinaten, Breite und Höhe wie das Originalbild initialisiert wird.</li>
      <li>Sie erstellt ein neues Point-Objekt mit der Standardeinstellung <i>x = 0, y = 0</i>.</li>
      <li>Sie erstellt die folgenden Variablen:
      <ul>
          <li><codeph>operation</codeph>: Wendet die neue Farbe an, wenn der Schwellenwert größer oder gleich dem Original ist.</li>
          <li><codeph>threshold</codeph>: Der Wert, mit dem jedes Pixel verglichen wird, wird auf Hellgrau mit einem Alphawert von 0xCC gesetzt. </li>
          <li><codeph>color</codeph>: Die Farbe, auf die die Pixel eingestellt werden, die den Schwellentest bestehen. In diesem Fall ist dies reines Gelb.</li>
          <li><codeph>mask</codeph>: Die genau entgegengesetzte Farbe (durchsichtiges Blau).</li>
          <li><codeph>copySource</codeph>: Auf „false“ gesetzt. Dies zeigt an, dass die Pixelwerte nicht kopiert werden, wenn der Schwellenwert den Test nicht besteht. Dieser Wert hat keine Bedeutung, da das Bild dupliziert wird und nur Pixel geändert werden, die den Schwellenwerttest bestehen.</li>
      </ul></li>
      <li>Ruft mithilfe der vorherigen Variablen die <codeph>threshold()</codeph>-Methode auf. Es ergibt sich die folgende Schwellenwertgleichung: <codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>. </li>
  </ol></li>
 </ol>
 <p> <b>Hinweise:</b>
 <ul>
  <li>Für die Kompilierung der SWF-Datei müssen Sie die Option „Sicherheit bei lokaler Wiedergabe“ auf „Nur auf lokale Dateien zugreifen“ einstellen.
 </li>
  <li>Zur Ausführung dieses Beispiels müssen Sie eine Datei mit dem Namen „Image.gif“ in dem Ordner ablegen, in dem sich die SWF-Datei befindet.
 </li>
  <li>Es wird empfohlen, ein Bild mit einer Breite von bis zu 80 Pixel zu verwenden. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiConstructor id="flash.display:Bitmap:Bitmap"><apiName>Bitmap</apiName><shortdesc>
     Initialisiert ein Bitmap-Objekt, das auf das angegebene BitmapData-Objekt verweisen soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Das BitmapData-Objekt, auf das verwiesen wird. 
     
     </apiDesc></apiParam><apiParam><apiItemName>pixelSnapping</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>auto</apiData><apiDesc>Gibt an, ob das Bitmap-Objekt am nächsten Pixel ausgerichtet wird.
     
     </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob die Bitmap beim Skalieren geglättet wird. Im folgenden Beispiel wird dieselbe Bitmap um den Faktor 3 skaliert angezeigt, wobei <codeph>smoothing</codeph> auf <codeph>false</codeph> (links) und <codeph>true</codeph> (rechts) gesetzt ist:
     
     <p>
      <adobetable>
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="Eine Bitmap ohne Glättung." href="../../images/bitmap_smoothing_off.jpg"/></entry>
      <entry align="center"><adobeimage alt="Eine Bitmap mit Glättung." href="../../images/bitmap_smoothing_on.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     </p>
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Initialisiert ein Bitmap-Objekt, das auf das angegebene BitmapData-Objekt verweisen soll.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Bitmap:bitmapData:get"><apiName>bitmapData</apiName><shortdesc>
    Das BitmapData-Objekt, auf das verwiesen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
    Das BitmapData-Objekt, auf das verwiesen wird.
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:pixelSnapping:get"><apiName>pixelSnapping</apiName><shortdesc>
    Steuert, ob das Bitmap-Objekt am nächsten Pixel ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Steuert, ob das Bitmap-Objekt am nächsten Pixel ausgerichtet wird. Die PixelSnapping-Klasse umfasst die folgenden zulässigen Werte:
    
    <ul>
    
      <li><codeph>PixelSnapping.NEVER</codeph>: Keine Ausrichtung an Pixeln.</li>
    
      <li><codeph>PixelSnapping.ALWAYS</codeph>: Die Grafik wird immer am nächsten Pixel ausgerichtet, und zwar unabhängig von einer etwaigen Transformation.</li>
    
      <li><codeph>PixelSnapping.AUTO</codeph>: Das Bild wird am nächsten Pixel ausgerichtet, wenn es ohne Drehung oder Neigung gezeichnet wird, und mit einem Skalierungsfaktor von 99,9 % bis 100,1 % gezeichnet. Sind diese Bedingungen erfüllt, wird die Bitmap bei einhundertprozentiger Skalierung gezeichnet und am nächstgelegenen Pixel ausgerichtet. Intern ermöglicht es dieser Wert, dass die Grafik so schnell wie möglich gezeichnet wird, indem der Vektorrenderer verwendet wird.</li>
    
    </ul>
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:smoothing:get"><apiName>smoothing</apiName><shortdesc>
    Steuert, ob die Bitmap beim Skalieren geglättet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    Steuert, ob die Bitmap beim Skalieren geglättet wird. Wenn <codeph>true</codeph> angegeben ist, wird die Bitmap beim Skalieren geglättet. Wenn <codeph>false</codeph> angegeben ist, wird die Bitmap beim Skalieren nicht geglättet.
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Scene"><apiName>Scene</apiName><shortdesc>
	Die Scene-Klasse umfasst Eigenschaften für das Identifizieren von Name, Bildbezeichnungen und Anzahl der Bilder in einer Szene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die Scene-Klasse umfasst Eigenschaften für das Identifizieren von Name, Bildbezeichnungen und Anzahl der Bilder in einer Szene. Die MovieClip-Klasse umfasst eine <codeph>currentScene</codeph>-Eigenschaft, die ein Scene-Objekt bezeichnet, nämlich die aktuelle Szene in der Zeitleiste der MovieClip-Instanz, in der sich der Abspielkopf gerade befindet. Die <codeph>scenes</codeph>-Eigenschaft der MovieClip-Klasse ist ein Array von Scene-Objekten. Auch die Methoden <codeph>gotoAndPlay()</codeph> und <codeph>gotoAndStop()</codeph> der MovieClip-Klasse verwenden Scene-Objekte als Parameter.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:Scene:labels:get"><apiName>labels</apiName><shortdesc>
		Ein Array an FrameLabel-Objekten für die Szene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		Ein Array an FrameLabel-Objekten für die Szene. Jedes FrameLabel-Objekt umfasst eine <codeph>frame</codeph>-Eigenschaft, die die Bildnummer angibt, die der Bezeichnung entspricht, sowie eine <codeph>name</codeph>-Eigenschaft.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:Scene:name:get"><apiName>name</apiName><shortdesc>
		Der Name der Szene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Der Name der Szene.
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Scene:numFrames:get"><apiName>numFrames</apiName><shortdesc>
		Die Anzahl der Bilder in der Szene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		Die Anzahl der Bilder in der Szene.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageDisplayState"><apiName>StageDisplayState</apiName><shortdesc>
Die StageDisplayState-Klasse stellt Werte für die Stage.displayState-Eigenschaft bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die StageDisplayState-Klasse stellt Werte für die <codeph>Stage.displayState</codeph>-Eigenschaft bereit. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link></related-links><apiValue id="flash.display:StageDisplayState:FULL_SCREEN"><apiName>FULL_SCREEN</apiName><shortdesc>
Legt fest, dass die Bühne im Vollbildmodus angezeigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne im Vollbildmodus angezeigt wird. Die Tastaturinteraktion ist in diesem Modus deaktiviert.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:FULL_SCREEN_INTERACTIVE"><apiName>FULL_SCREEN_INTERACTIVE</apiName><shortdesc>
Legt fest, dass die Bühne im Vollbildmodus angezeigt wird und die Tastaturinteraktion aktiviert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreenInteractive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne im Vollbildmodus angezeigt wird und die Tastaturinteraktion aktiviert ist. <ph platform="actionscript">Diese Funktionalität wird nur von AIR-Anwendungen unterstützt.</ph>

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
Legt fest, dass die Bühne im normalen Modus angezeigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne im normalen Modus angezeigt wird. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderData"><apiName>ShaderData</apiName><shortdesc>
	 Ein ShaderData-Objekt enthält Eigenschaften, die beliebige Parameter und Eingaben für ein Shaderkernel darstellen, sowie Eigenschaften, die für den Shader festgelegte Metadaten enthalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Ein ShaderData-Objekt enthält Eigenschaften, die beliebige Parameter und Eingaben für ein Shaderkernel darstellen, sowie Eigenschaften, die für den Shader festgelegte Metadaten enthalten.
	 
	 <p>Diese Eigenschaften werden dem ShaderData-Objekt bei der Erstellung hinzugefügt. Die Namen der Eigenschaften stimmen mit den im Shaderquellcode festgelegten Namen überein. Die Datentypen der verschiedenen Eigenschaften sind unterschiedlich, je nachdem, welchen Aspekt des Shaders die Eigenschaft darstellt. Die Eigenschaften, die Shaderparameter darstellen, sind ShaderParameter-Instanzen; die Eigenschaften, die Eingabebilder darstellen sind ShaderInput-Instanzen; die Eigenschaften, die Shadermetadaten darstellen, sind Instanzen der ActionScript-Klasse, die dem jeweiligen Datentyp entsprechen (Beispiel: eine String-Instanz für Metadaten im Textformat, eine uint-Instanz für uint-Metadaten).</p>
	 
	 <p>Sehen Sie sich beispielsweise diesen Shader an, der durch ein Eingabebild (<codeph>src</codeph>), zwei Parameter (<codeph>size</codeph> und <codeph>radius</codeph>) und drei Metadatenwerte (<codeph>nameSpace</codeph>, <codeph>version</codeph> und <codeph>description</codeph>) definiert ist:</p>
	 
	 <codeblock>
	 &lt;languageVersion : 1.0;>
	 
	 kernel DoNothing
	 &lt;
	     namespace: "Adobe::Example";
	     vendor: "Adobe examples";
	     version: 1;
	     description: "A shader that does nothing, but does it well.";
	 >
	 {
	     input image4 src;
	 
	     output pixel4 dst;
	     
	     parameter float2 size
	     &lt;
	         description: "The size of the image to which the kernel is applied";
	         minValue: float2(0.0, 0.0);
	         maxValue: float2(100.0, 100.0);
	         defaultValue: float2(50.0, 50.0);
	     >;
	     
	     parameter float radius
	     &lt;
	         description: "The radius of the effect";
	         minValue: 0.0;
	         maxValue: 50.0;
	         defaultValue: 25.0;
	     >;
	 
	     void evaluatePixel()
	     {
	         float2 one = (radius / radius) ∗ (size / size);
	         dst = sampleNearest(src, outCoord());
	     }
	 }
	 </codeblock>
	 
	 <p>Wenn Sie eine Shader-Instanz durch Laden des Bytecodes für diesen Shader erstellen, enthält die ShaderData-Instanz in ihren <codeph>data</codeph>-Eigenschaften diese Eigenschaften:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Eigenschaft</entry><entry>Datentyp</entry><entry>Wert</entry></row></thead><tbody><row>
	   <entry>name</entry>
	   <entry>String</entry>
	   <entry>„DoNothing“</entry>
	 </row><row>
	   <entry>nameSpace</entry>
	   <entry>String</entry>
	   <entry>„Adobe::Example“</entry>
	 </row><row>
	   <entry>version</entry>
	   <entry>String</entry>
	   <entry>„1“</entry>
	 </row><row>
	   <entry>description</entry>
	   <entry>String</entry>
	   <entry>„A shader that does nothing, but does it well.“</entry>
	 </row><row>
	   <entry>src</entry>
	   <entry>ShaderInput</entry>
	   <entry><i>[Eine ShaderInput-Instanz]</i></entry>
	 </row><row>
	   <entry>size</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[Eine ShaderParameter-Instanz mit Eigenschaften für die Parametermetadaten]</i></entry>
	 </row><row>
	   <entry>radius</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[Eine ShaderParameter-Instanz mit Eigenschaften für die Parametermetadaten]</i></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Beachten Sie: Eingabebilder oder Parameter, die zwar im Shaderquellcode definiert sind, aber in der <codeph>evaluatePixel()</codeph>-Funktion des Shaders nicht verwendet werden, werden entfernt, wenn der Shader in Form von Bytecode kompiliert wird. In diesem Fall wird keine entsprechende ShaderInput- oder ShaderParameter-Instanz als Eigenschaft der ShaderData-Instanz hinzugefügt.</p> 
	 
	 <p>Im Allgemeinen wird eine ShaderData-Instanz nicht durch Entwicklercode erstellt. Eine ShaderData-Instanz, die Daten, Parameter und Eingaben für einen Shader enthält, ist als <codeph>data</codeph>-Eigenschaft der Shader-Instanz verfügbar.</p>
	 
	 </apiDesc><example conref="examples\ShaderDataExample.1.as"> Das folgende Beispiel zeigt, wie Sie einen Shader laden und die ShaderData-Instanz in der <codeph>data</codeph>-Eigenschaft auflisten, um die Shadereigenschaften für Eingabe, Parameter und Metadaten anzuzeigen.
 
 <p>Beachten Sie, dass im Beispiel davon ausgegangen wird, dass im selben Ordner wie dem Ausgabeordner der Anwendung eine Shaderbytecodedatei mit dem Namen „donothing.pbj“ vorhanden ist.</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel DoNothing
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "A shader that does nothing, but does it well.";
>
{
    input image4 src;
    
    output pixel4 dst;
    
    parameter float2 size
    &lt;
        description: "The size of the image to which the shader is applied";
        minValue: float2(0.0, 0.0);
        maxValue: float2(100.0, 100.0);
        defaultValue: float2(50.0, 50.0);
    >;
    
    parameter float radius
    &lt;
        description: "The radius of the effect";
        minValue: float(0.0);
        maxValue: float(50.0);
        defaultValue: float(25.0);
    >;

    void evaluatePixel()
    {
        float2 one = (radius / radius) * (size / size);
        dst = sampleNearest(src, outCoord());
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderDataExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function ShaderDataExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            for (var p:String in shader.data) {
                trace(p, ":", shader.data[p]);
                for (var d:String in shader.data[p]) {
                    trace("\t", d, ":", shader.data[p][d]);
                }
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links><apiConstructor id="flash.display:ShaderData:ShaderData"><apiName>ShaderData</apiName><shortdesc>
		 Erstellt eine ShaderData-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>byteCode</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Der Bytecode des Shaders.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Erstellt eine ShaderData-Instanz. Im Allgemeinen wird der ShaderData-Konstruktor nicht direkt durch Entwicklercode aufgerufen. Der Zugriff auf eine ShaderData-Instanz, die Daten, Parameter und Eingaben für eine Shader-Instanz enthält, erfolgt über deren <codeph>data</codeph>-Eigenschaft.
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
	 Eine ShaderJob-Instanz wird für die Ausführung eines Shadervorgangs im eigenständigen Modus verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Eine ShaderJob-Instanz wird für die Ausführung eines Shadervorgangs im eigenständigen Modus verwendet. Der Shadervorgang wird ausgeführt und gibt die Ergebnisdaten zurück. Der Entwickler entscheidet, wie er das Ergebnis verwendet.
	 
	 <p>Es gibt zwei Hauptgründe für die Verwendung des Shaders im eigenständigen Modus:</p>
	 
	 <ul>
	   <li>Verarbeitung von Nicht-Bilddaten: Durch die ShaderJob-Instanz können Sie die Eingabewerte bestimmen und entscheiden, wie die Shaderergebnisse verwendet werden. Der Shader kann das Ergebnis anstatt in Bilddaten als Binärdaten oder Zahlendaten zurückgeben.</li>
	   <li>Verarbeitung im Hintergrund: Manche Shader sind komplex und ihre Ausführung erfordert einige Zeit. Die Ausführung eines komplexen Shaders in der Hauptausführung einer Anwendung kann andere Teile der Anwendung, etwa Benutzerinteraktionen oder die Aktualisierung des Bildschirms, beträchtlich verlangsamen. Mit der ShaderJob-Instanz können Sie den Shader im Hintergrund ausführen. Auf diese Weise läuft der Shadervorgang unabhängig von der Hautpausführung der Anwendung ab.</li>
	 </ul>
	 
	 <p>Die <codeph>shader</codeph>-Eigenschaft (oder der constructor-Parameter) gibt die Shader-Instanz an, die den für diesen Vorgang verwendeten Shader darstellt. Parameter oder Eingaben, die der Shader benötigt, stellen Sie mithilfe der verknüpften ShaderParameter- oder ShaderInput-Instanzen bereit.</p>
	 
	 <p>Vor Ausführung des ShaderJob-Vorgangs stellen Sie ein Objekt bereit, in das das Ergebnis geschrieben wird. Dazu setzen Sie das Objekt als Wert für die <codeph>target</codeph>-Eigenschaft. Bei Abschluss des Shadervorgangs wird das Ergebnis in das <codeph>target</codeph>-Objekt geschrieben.</p>
	 
	 <p>Zum Starten eines Shadervorgangs im Hintergrund rufen Sie die <codeph>start()</codeph>-Methode auf. Bei Abschluss des Shadervorgangs wird das Ergebnis in das <codeph>target</codeph>-Objekt geschrieben. Dabei löst die ShaderJob-Instanz ein <codeph>complete</codeph>-Ereignis aus, das Listener informiert, dass das Ergebnis bereitsteht.</p>
	 
	 <p>Um einen Shader synchron auszuführen (also nicht im Hintergrund), führen Sie die <codeph>start()</codeph>-Methode aus und übergeben <codeph>true</codeph> als Argument. Der Shader läuft im Hauptausführungs-Thread und Ihr Code wird angehalten, bis der Vorgang abgeschlossen ist. Am Ende wird das Ergebnis in das <codeph>target</codeph>-Objekt geschrieben. Dann wird die Ausführung der Anwendung bei der nächsten Codezeile fortgesetzt.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader"><linktext>Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>ShaderParameter</linktext></link><link href="flash.events.xml#ShaderEvent"><linktext>ShaderEvent</linktext></link></related-links><adobeApiEvent id="flash.display:ShaderJob_flash.events.ShaderEvent.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	 Wird ausgelöst, wenn ein asynchron ausgeführter ShaderJob die Datenverarbeitung mithilfe des Shaders beendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ShaderEvent.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Wird ausgelöst, wenn ein asynchron ausgeführter ShaderJob die Datenverarbeitung mithilfe des Shaders beendet. Eine ShaderJob-Instanz wird asynchron ausgeführt, wenn die <codeph>start()</codeph>-Methode mit dem Wert <codeph>false</codeph> für den <codeph>waitForCompletion</codeph>-Parameter aufgerufen wird.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:ShaderJob:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
		 
		 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Der für den Vorgang verwendete Shader.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Objekt, in das das Ergebnis des Shadervorgangs geschrieben wird. Dieses Argument muss eine BitmapData-, ByteArray- oder Vector.&lt;Number>-Instanz sein.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Breite der Ergebnisdaten im <codeph>target</codeph>, wenn es sich dabei um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt. Die Größe der ByteArray- oder Vector.&lt;Number>-Instanz wird bei Bedarf erhöht und bestehende Daten werden überschrieben.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Höhe der Ergebnisdaten im <codeph>target</codeph>, wenn es sich dabei um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt. Die Größe der ByteArray- oder Vector.&lt;Number>-Instanz wird bei Bedarf erhöht und bestehende Daten werden überschrieben.
         
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:ShaderJob:cancel"><apiName>cancel</apiName><shortdesc>
		 Bricht den aktuell laufenden Shadervorgang ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Bricht den aktuell laufenden Shadervorgang ab. Bereits berechnete Ergebnisdaten werden dabei gelöscht. Das <codeph>complete</codeph>-Ereignis wird nicht ausgelöst.
		 
		 <p>Mehrfaches Aufrufen von <codeph>cancel()</codeph> hat keine Auswirkungen.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:ShaderJob:start"><apiName>start</apiName><shortdesc>
		 Startet einen Shadervorgang im synchronen oder asynchronen Modus, entsprechend dem Wert des waitForCompletion-Parameters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die <codeph>target</codeph>-Eigenschaft <codeph>null</codeph> oder keine BitmapData-, ByteArray- oder Vector.&lt;Number>-Instanz ist.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Shader eine Bildeingabe festlegt, die nicht vorhanden ist.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn eine ByteArray- oder Vector.&lt;Number>-Instanz als Eingabe verwendet wird und die <codeph>width</codeph>- und <codeph>height</codeph>-Eigenschaft für ShaderInput nicht festgelegt ist oder die festgelegten Werte nicht mit der Datenmenge im Eingabeobjekt übereinstimmen. Weitere Informationen finden Sie im Abschnitt zur <codeph>ShaderInput.input</codeph>-Eigenschaft.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>waitForCompletion</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Legt fest, ob der Shader im Hintergrund (<codeph>false</codeph>, Standardwert) oder in der Hauptausführung des Programms (<codeph>true</codeph>) ausgeführt wird.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Startet einen Shadervorgang im synchronen oder asynchronen Modus, entsprechend dem Wert des <codeph>waitForCompletion</codeph>-Parameters.
		 
		 <p>Im asynchronen Modus (wenn <codeph>waitForCompletion</codeph> den Wert <codeph>false</codeph> hat) wird der ShaderJob im Hintergrund ausgeführt. Dies ist der Standardmodus. Der Shadervorgang hat keine Auswirkungen auf die Reaktionszeit der Anzeige oder andere Vorgänge. Im asynchronen Modus wird der <codeph>start()</codeph>-Aufruf sofort zurückgegeben und das Programm setzt mit der nächsten Codezeile fort. Nach Abschluss eines asynchronen Shadervorgangs steht das Ergebnis bereit und das <codeph>complete</codeph>-Ereignis wird ausgelöst.</p>
		 
		 <p>Es kann jeweils nur ein ShaderJob-Vorgang im Hintergrund ausgeführt werden. Shadervorgänge werden bis zu ihrer Ausführung in eine Warteschlange gereiht. Wird während der Ausführung eines Shadervorgangs die <codeph>start()</codeph>-Methode aufgerufen, so wird der neue Vorgang an das Ende der Warteschlange gereiht. Er wird ausgeführt, wenn er an der Reihe ist.</p>
		 
		 <p>Ein Shadervorgang wird synchron ausgeführt, wenn die <codeph>start()</codeph>-Methode aufgerufen wird und sie den Wert <codeph>true</codeph> für den <codeph>waitForCompletion</codeph>-Parameter (den einzigen Parameter) aufweist. Ihr Code wird vom Zeitpunkt, zu dem <codeph>start()</codeph> aufgerufen wird, bis zum Abschluss des Shadervorgangs angehalten. Dann steht das Ergebnis zur Verfügung und die Ausführung wird bei der nächsten Codezeile fortgesetzt.</p>
		 
		 <p>Wenn Sie die <codeph>start()</codeph>-Methode aufrufen, wird die Shader-Instanz in der <codeph>shader</codeph>-Eigenschaft intern kopiert. Für den Shadervorgang wird statt eines Verweises auf den ursprünglichen Shader die interne Kopie verwendet. Änderungen am Shader (beispielsweise an Parameterwerten, Eingabe oder Bytecode) werden nicht auf die für den Shadervorgang verwendete Shaderkopie angewendet. Um Änderungen am Shader in den Shadervorgang einzubeziehen, rufen Sie, falls erforderlich, die <codeph>cancel()</codeph>-Methode auf und dann nochmals die <codeph>start()</codeph>-Methode, um den Shadervorgang neu zu starten.</p>
		 
		 <p>Während der Ausführung eines Shadervorgangs wird der Wert des <codeph>target</codeph>-Objekts nicht geändert. Wenn der Vorgang abgeschlossen (und im asynchronen Modus das <codeph>complete</codeph>-Ereignis ausgelöst) wird, wird das Gesamtergebnis direkt in das <codeph>target</codeph>-Objekt geschrieben. Wenn es sich beim <codeph>target</codeph>-Objekt um eine BitmapData-Instanz handelt und die zugehörige <codeph>dispose()</codeph>-Methode vor Abschluss des Vorgangs aufgerufen wird, wird das <codeph>complete</codeph>-Ereignis dennoch im asynchronen Modus ausgelöst. Die Ergebnisdaten werden jedoch nicht in das BitmapData-Objekt geschrieben, da es entfernt wurde.</p>
         
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.display:ShaderJob:start_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Abschluss eines Vorgangs aufgerufen, wenn die <codeph>start()</codeph>-Methode mit einem <codeph>waitForCompletion</codeph>-Argument gleich <codeph>true</codeph> aufgerufen wurde.
		 
		 </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Abschluss eines Vorgangs aufgerufen, wenn die start()-Methode mit einem waitForCompletion-Argument gleich „true“ aufgerufen wurde.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.display:ShaderJob:height:get"><apiName>height</apiName><shortdesc>
		 Die Höhe der Ergebnisdaten im target, wenn es sich dabei um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Die Höhe der Ergebnisdaten im <codeph>target</codeph>, wenn es sich dabei um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt. Die Größe der ByteArray- oder Vector.&lt;Number>-Instanz wird bei Bedarf erhöht und bestehende Daten werden überschrieben.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:progress:get"><apiName>progress</apiName><shortdesc>
		 Der Fortschritt eines Shaders, der ausgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Der Fortschritt eines Shaders, der ausgeführt wird. Diese Eigenschaft ist ein Wert zwischen 0 und 1. Null ist der Ausgangswert (0 % abgeschlossen). Eins gibt an, dass der Shadervorgang abgeschlossen ist.
		 
		 <p>Wenn die <codeph>cancel()</codeph>-Methode aufgerufen wird, erhält diese Eigenschaft den Wert <codeph>undefined</codeph> und ihr Wert ist unzuverlässig, bis der Shadervorgang erneut startet.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:shader:get"><apiName>shader</apiName><shortdesc>
		 Der für den Vorgang verwendete Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 Der für den Vorgang verwendete Shader. Eingaben oder Parameter, die der Shader benötigt, müssen mithilfe der ShaderInput- oder ShaderParameter-Eigenschaft der <codeph>data</codeph>-Eigenschaft der Shader-Instanz angegeben werden. Eine Eingabe muss mit dem entsprechenden ShaderInput bereitgestellt werden, auch, wenn es dasselbe Objekt wie das <codeph>target</codeph>-Objekt ist.
		 
		 <p>Um ein ByteArray zu verarbeiten, das ein lineares Daten-Array (im Gegensatz zu Bilddaten) enthält, setzen Sie für die entsprechende ShaderInput-Instanz <codeph>height</codeph> auf 1 und <codeph>width</codeph> auf die Wertzahl der 32-Bit-Gleitkommazahl im ByteArray. In diesem Fall muss die Shadereingabe mithilfe des <codeph>image1</codeph>-Datentyps definiert werden.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderJob:target:get"><apiName>target</apiName><shortdesc>
		 Das Objekt, in das das Ergebnis des Shadervorgangs geschrieben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 Das Objekt, in das das Ergebnis des Shadervorgangs geschrieben wird. Dieses Objekt muss eine BitmapData-, ByteArray- oder Vector.&lt;Number>-Instanz sein.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:width:get"><apiName>width</apiName><shortdesc>
		 Die Breite der Ergebnisdaten im „target“, wenn es sich beim Ziel um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Die Breite der Ergebnisdaten im <codeph>target</codeph>, wenn es sich dabei um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt. Die Größe der ByteArray- oder Vector.&lt;Number>-Instanz wird bei Bedarf erhöht und bestehende Daten werden überschrieben.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowSystemChrome"><apiName>NativeWindowSystemChrome</apiName><shortdesc>
	 Die NativeWindowSystemChrome-Klasse definiert Konstanten für die systemChrome-Eigenschaft des NativeWindowInitOptions-Objekts, das für die Erstellung eines nativen Fensters verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die NativeWindowSystemChrome-Klasse definiert Konstanten für die <codeph>systemChrome</codeph>-Eigenschaft des NativeWindowInitOptions-Objekts, das für die Erstellung eines nativen Fensters verwendet wird.  
	 
	 <p>Systemchrom bezieht sich auf die betriebssystemspezifischen Elemente eines Fensters, wie die Titelleiste sowie die Schaltflächen zum Minimieren, Maximieren und Schließen.</p>
  	 
	 <p><b>Hinweis:</b> Der Typ des verwendeten Systemchroms wird bei der Erstellung des Fensters angegeben und kann später nicht mehr geändert werden.</p>
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowSystemChrome:NONE"><apiName>NONE</apiName><shortdesc>
	 Kein Systemchrom.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Kein Systemchrom. 
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowSystemChrome:STANDARD"><apiName>STANDARD</apiName><shortdesc>
	 Das Standardchrom für das Hostbetriebssystem.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Das Standardchrom für das Hostbetriebssystem.
	 
	 <p>Mit dieser Einstellung können Sie die Gestaltung des nativen Betriebssystems nachahmen.</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsStroke"><apiName>IGraphicsStroke</apiName><shortdesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Strichparameter in der flash.display.Graphics-Methode und Klassen für das Zeichnen verwendet werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Strichparameter in der flash.display.Graphics-Methode und Klassen für das Zeichnen verwendet werden können. Verwenden Sie Klassen, die diese Schnittstelle implementieren, um Stricheigenschaftsdaten zu erstellen und zu verwalten und diese Daten in verschiedenen Instanzen wiederzuverwenden.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
 Die SimpleButton-Klasse ermöglicht die Steuerung aller Instanzen von Schaltflächensymbolen in einer SWF-Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Die SimpleButton-Klasse ermöglicht die Steuerung aller Instanzen von Schaltflächensymbolen in einer SWF-Datei.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die SimpleButton-Klasse ermöglicht die Steuerung aller Instanzen von Schaltflächensymbolen in einer SWF-Datei. Nachdem Sie in der Authoring-Umgebung eine Instanz einer Schaltfläche erstellt haben, können Sie die Methoden und Eigenschaften der SimpleButton-Klasse verwenden, um Schaltflächen mit ActionScript zu bearbeiten.
 
 <p product="flash">Im Eigenschafteninspektor können Sie einer Schaltfläche einen Instanznamen zuweisen. SimpleButton-Instanznamen werden im Film-Explorer und im Dialogfeld „Zielpfad einfügen“ des Bedienfelds „Aktionen“ angezeigt.</p>
 
 <p>In ActionScript 3.0 erstellen Sie eine SimpleButton-Instanz mithilfe des Konstruktors <codeph>new SimpleButton()</codeph>:</p>
 
 <p>Die SimpleButton-Klasse übernimmt ihre Eigenschaften von der InteractiveObject-Klasse.</p>
 
 </apiDesc><example conref="examples\SimpleButtonExample.as"> Im folgenden Beispiel wird die SimpleButtonExample-Klasse verwendet, die wiederum die CustomSimpleButton-Klasse verwendet, die vier ButtonDisplayState-Objekte instanziiert. Das Ergebnis ist eine Schaltfläche, die als Quadrat angelegt wird und deren Hintergrund sich je nach Mausstatus ändert, indem Instanzeigenschaften der SimpleButton-Klasse außer Kraft gesetzt werden. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Im Konstruktor <codeph>SimpleButtonExample()</codeph> wird ein neues CustomSimpleButton-Objekt vom Typ „SimpleButton“ mit dem Namen <codeph>button</codeph> erstellt. Dieses Objekt ruft die <codeph>CustomSimpleButton</codeph>-Konstruktormethode auf. Das <codeph>button</codeph>-Objekt wird der Anzeigeliste hinzugefügt. Farbe und Größe der Schaltfläche werden in den darauf folgenden Schritten festgelegt.</li>
 
  <li>In der CustomSimpleButton-Klasse werden Instanzeigenschaften deklariert, die später verwendet werden, um die Größe und Hintergrundfarbe von <codeph>button</codeph> zu steuern. Dies erfolgt basierend auf dem jeweiligen Status (orange im normalen Status, dunkelgelb im Mouseover-Status und hellblau im Mousedown-Status). Für jeden Status von <codeph>button</codeph> ist die Größe des Quadrats auf 80 Pixel festgelegt, indem die <codeph>size</codeph>-Eigenschaft verwendet wird.</li>
 
  <li>Die Konstruktorfunktion für die CustomSimpleButton-Klasse setzt die Eigenschaften <codeph>downState</codeph>, <codeph>overState</codeph>, <codeph>upState</codeph>, <codeph>hitTestState</codeph> und <codeph>useHandCursor</codeph> mit vier Instanzen der ButtonDisplayState-Klasse.</li>
 
  <li>In der ButtonDisplayState-Klasse setzt der Konstruktor den Wert des Quadrats für Größe und Hintergrundfarbe und ruft die <codeph>draw()</codeph>-Methode auf.</li>
 
  <li>Die <codeph>draw()</codeph>-Methode zeichnet das Quadrat unter Verwendung der im Konstruktor angegebenen Größe und Hintergrundfarbe basierend auf dem Status der Schaltfläche neu.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class SimpleButtonExample extends Sprite {
        public function SimpleButtonExample() {
            var button:CustomSimpleButton = new CustomSimpleButton();
            addChild(button);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.SimpleButton;

class CustomSimpleButton extends SimpleButton {
    private var upColor:uint   = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;
    private var size:uint      = 80;

    public function CustomSimpleButton() {
        downState      = new ButtonDisplayState(downColor, size);
        overState      = new ButtonDisplayState(overColor, size);
        upState        = new ButtonDisplayState(upColor, size);
        hitTestState   = new ButtonDisplayState(upColor, size * 2);
        hitTestState.x = -(size / 4);
        hitTestState.y = hitTestState.x;
        useHandCursor  = true;
    }
}

class ButtonDisplayState extends Shape {
    private var bgColor:uint;
    private var size:uint;

    public function ButtonDisplayState(bgColor:uint, size:uint) {
        this.bgColor = bgColor;
        this.size    = size;
        draw();
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject"><linktext>InteractiveObject-Klasse</linktext></link></related-links><apiConstructor id="flash.display:SimpleButton:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
	Erstellt eine neue SimpleButton-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>upState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Der ursprüngliche Wert für den SimpleButton-Status „up“.
	</apiDesc></apiParam><apiParam><apiItemName>overState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Der ursprüngliche Wert für den SimpleButton-Status „over“.
	</apiDesc></apiParam><apiParam><apiItemName>downState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Der ursprüngliche Wert für den SimpleButton-Status „down“.
	</apiDesc></apiParam><apiParam><apiItemName>hitTestState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Der ursprüngliche Wert für den SimpleButton-Status „hitTest“.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt eine neue SimpleButton-Instanz.
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Erstellt eine neue SimpleButton-Instanz. Ein oder alle Anzeigeobjekte, die die verschiedenen Schaltflächenzustände repräsentieren, können als Parameter im Konstruktor gesetzt werden.  
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:SimpleButton:downState:get"><apiName>downState</apiName><shortdesc>
	 Legt ein Anzeigeobjekt fest, das als visuelles Objekt für den Schaltflächenzustand „down“ verwendet wird. Dies ist der Zustand der Schaltfläche, wenn Benutzer auf das hitTestState-Objekt klicken.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Legt einen DisplayObject-Wert fest, der für den Schaltflächenzustand „down“ verwendet wird.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Legt ein Anzeigeobjekt fest, das als visuelles Objekt für den Schaltflächenzustand „down“ verwendet wird. Dies ist der Zustand der Schaltfläche, wenn Benutzer auf das <codeph>hitTestState</codeph>-Objekt klicken.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Ein boolescher Wert, der angibt, ob eine Schaltfläche aktiviert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button.enabled, enabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Gibt an, ob eine Schaltfläche aktiviert (true) oder deaktiviert (false) ist.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein boolescher Wert, der angibt, ob eine Schaltfläche aktiviert ist. Wenn eine Schaltfläche deaktiviert ist (ihre enabled-Eigenschaft also auf <codeph>false</codeph> gesetzt wurde), dann ist diese Schaltfläche zwar sichtbar, aber das Klicken darauf hat keine Auswirkung. Der Standardwert ist <codeph>true</codeph>. Diese Eigenschaft ist nützlich, wenn Sie einen Teil der Navigation deaktivieren möchten, z. B. wenn Sie eine Schaltfläche auf der gerade angezeigten Seite deaktivieren möchten, damit nicht darauf geklickt werden und die Seite nicht erneut geladen werden kann.
	 
	 <p><b>Hinweis:</b> Um Mausklicks auf eine Schaltfläche zu verhindern, setzen Sie sowohl die <codeph>enabled</codeph>- als auch die <codeph>mouseEnabled</codeph>-Eigenschaft auf <codeph>false</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:hitTestState:get"><apiName>hitTestState</apiName><shortdesc>
	 Legt ein Anzeigeobjekt fest, das als Kollisionserkennungsobjekt für die Schaltfläche verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier></apiValueDef><apiDesc>
	 Legt ein Anzeigeobjekt fest, das als Kollisionserkennungsobjekt für die Schaltfläche verwendet wird. Für eine normale Schaltfläche setzen Sie die <codeph>hitTestState</codeph>-Eigenschaft auf dasselbe Anzeigeobjekt wie die <codeph>overState</codeph>-Eigenschaft. Wenn Sie die <codeph>hitTestState</codeph>-Eigenschaft nicht setzen, ist die SimpleButton-Schaltfläche nicht aktiv. Sie reagiert also nicht auf Maus- und Tastaturereignisse.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:overState:get"><apiName>overState</apiName><shortdesc>
	 Legt ein Anzeigeobjekt fest, das als visuelles Objekt für den Schaltflächenstatus „over“ verwendet wird. Dies ist der Status, den die Schaltfläche aufweist, wenn sich der Mauszeiger über der Schaltfläche befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Legt einen DisplayObject-Wert fest, der für den Schaltflächenzustand „over“ verwendet wird.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Legt ein Anzeigeobjekt fest, das als visuelles Objekt für den Schaltflächenstatus „over“ verwendet wird. Dies ist der Status, den die Schaltfläche aufweist, wenn sich der Mauszeiger über der Schaltfläche befindet.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 Das SoundTransform-Objekt, das dieser Schaltfläche zugewiesen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should information from AS2 setTransform be here? e.g. percentage values indicating
	 how much of the left input to play in the left speaker or right speaker; it is generally
	 best to use 22-KHZ 6-bit mono sounds?
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 Das SoundTransform-Objekt, das dieser Schaltfläche zugewiesen wurde. Ein SoundTransform-Objekt enthält Eigenschaften zum Festlegen von Lautstärke, Schwenkung sowie Zuordnung von linkem und rechtem Lautsprecher. Dieses SoundTransform-Objekt wird auf alle Statuszustände der Schaltfläche angewendet. Dieses SoundTransform-Objekt wirkt sich nur auf eingebettete Sounds aus.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Zeigt an, ob andere Anzeigeobjekte, die SimpleButton- oder MovieClip-Objekte sind, durch das Loslassen der Maustaste erzeugte Ereignisse empfangen können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Zeigt an, ob andere Anzeigeobjekte, die SimpleButton- oder MovieClip-Objekte sind, durch das Loslassen der Maustaste erzeugte Ereignisse empfangen können. Die <codeph>trackAsMenu</codeph>-Eigenschaft dient zum Erstellen von Menüs. Sie können die <codeph>trackAsMenu</codeph>-Eigenschaft für jedes SimpleButton- oder MovieClip-Objekt setzen. Wenn die <codeph>trackAsMenu</codeph>-Eigenschaft nicht vorhanden ist, lautet das Standardverhalten <codeph>false</codeph>. 
	 
	 <p>Sie können die <codeph>trackAsMenu</codeph>-Eigenschaft jederzeit ändern. Die geänderte Schaltfläche übernimmt sofort das neue Verhalten. </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:upState:get"><apiName>upState</apiName><shortdesc>
	 Legt ein Anzeigeobjekt fest, das als visuelles Objekt für den Schaltflächenstatus „up“ verwendet wird. Dies ist der Status, den die Schaltfläche aufweist, wenn sich der Mauszeiger nicht über der Schaltfläche befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Legt einen DisplayObject-Wert fest, der für den Schaltflächenzustand „up“ verwendet wird.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Legt ein Anzeigeobjekt fest, das als visuelles Objekt für den Schaltflächenstatus „up“ verwendet wird. Dies ist der Status, den die Schaltfläche aufweist, wenn sich der Mauszeiger nicht über der Schaltfläche befindet.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
     Ein Boolescher Wert, der bei der Einstellung „true“ angibt, ob der Handcursor angezeigt wird, wenn die Maus über eine Schaltfläche bewegt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create two buttons on the Stage with the instance names <code>myBtn1_btn</code> and <code>myBtn2_btn</code>. Enter the following ActionScript in Frame 1 of the Timeline:
	 <listing>
	 myBtn1_btn.useHandCursor = false;
	 myBtn1_btn.onRelease = buttonClick;
	 myBtn2_btn.onRelease = buttonClick;
	 function buttonClick() {
	   trace(this._name);
	 }
	 </listing>
	 <p>When the mouse is over and clicks <code>myBtn1_btn</code>, there is no pointing hand. However, you see the pointing hand when the button is over and clicks <code>myBtn2_btn</code>.</p>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Zeigt einen Handcursor an, wenn der Wert „true“ ist.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Ein Boolescher Wert, der bei der Einstellung <codeph>true</codeph> angibt, ob der Handcursor angezeigt wird, wenn die Maus über eine Schaltfläche bewegt wird. Wenn diese Eigenschaft auf <codeph>false</codeph> gesetzt ist, wird stattdessen der Pfeilcursor angezeigt. Der Standardwert lautet <codeph>true</codeph>.
	 
	 <p>Sie können die Eigenschaft <codeph>useHandCursor</codeph> jederzeit ändern. Die geänderte Schaltfläche übernimmt sofort das neue Cursorverhalten. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:TriangleCulling"><apiName>TriangleCulling</apiName><shortdesc>
 Definiert Codes für Cullingalgorithmen, die festlegen, welche Dreiecke beim Zeichnen von Dreieckpfaden nicht dargestellt werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Definiert Codes für Cullingalgorithmen, die festlegen, welche Dreiecke beim Zeichnen von Dreieckpfaden nicht dargestellt werden.
 
 <p>
 Die Bezeichnungen <codeph>POSITIVE</codeph> und <codeph>NEGATIVE</codeph> beziehen sich auf das Vorzeichen der Normalen eines Dreiecks entlang der z-Achse. Die Normale ist ein 3D-Vektor, der senkrecht zur Oberfläche des Dreiecks verläuft.
 </p>
 
 <p>
 Bei einem Dreieck, dessen Scheitelpunkte 0, 1 und 2 im Uhrzeigersinn angeordnet sind, hat die Normale einen positiven Wert. Mit anderen Worten: Die Normale zeigt in eine positiven z-Achsenrichtung, vom aktuellen Blickpunkt weg. Wenn der Algorithmus <codeph>TriangleCulling.POSITIVE</codeph> verwendet wird, werden Dreiecke mit positiven Normalen nicht dargestellt. Dies wird auch als Backface Culling (Unterdrücken von Rückflächen) bezeichnet.
 </p>
 
 <p>
 Bei einem Dreieck, dessen Scheitelpunkte entgegen dem Uhrzeigersinn angeordnet sind, hat die Normale einen negativen Wert. Mit anderen Worten: Die Normale zeigt in einer negativen z-Achsenrichtung, zum aktuellen Blickpunkt hin. Wenn der Algorithmus <codeph>TriangleCulling.NEGATIVE</codeph> verwendet wird, werden Dreiecke mit negativen Normalen nicht dargestellt.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTrianglePath()"><linktext>flash.display.Graphics.drawTrianglePath()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="http://www.gamedev.net/reference/articles/article1089.asp"><linktext>Einführung in 3D-Vektoren</linktext></link><link href="http://www.gamedev.net/reference/articles/article1088.asp"><linktext>3D Backface Culling</linktext></link></related-links><apiValue id="flash.display:TriangleCulling:NEGATIVE"><apiName>NEGATIVE</apiName><shortdesc>
     Gibt an, dass alle Dreiecke unterdrückt werden, die zum aktuellen Blickpunkt hin zeigen.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>negative</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, dass alle Dreiecke unterdrückt werden, die zum aktuellen Blickpunkt hin zeigen.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:NONE"><apiName>NONE</apiName><shortdesc>
     Gibt an, dass kein Culling erfolgt, also keine Flächen unterdrückt werden.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, dass kein Culling erfolgt, also keine Flächen unterdrückt werden. Alle Dreiecke im Pfad werden dargestellt.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:POSITIVE"><apiName>POSITIVE</apiName><shortdesc>
     Gibt an, dass alle Dreiecke unterdrückt werden, die vom aktuellen Blickpunkt weg zeigen.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>positive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, dass alle Dreiecke unterdrückt werden, die vom aktuellen Blickpunkt weg zeigen. Dies wird auch als Backface Culling (Unterdrücken von Rückflächen) bezeichnet.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
 Die NativeWindow-Klasse bietet eine Schnittstelle zum Erstellen und Steuern von nativen Desktop-Fenstern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die NativeWindow-Klasse bietet eine Schnittstelle zum Erstellen und Steuern von nativen Desktop-Fenstern.
  
 <p platform="actionscript">Ein Verweis auf die NativeWindow-Instanz wird vom Fensterkonstruktor zurückgegeben. Der Zugriff auf einen Verweis auf eine NativeWindow-Instanz ist auch mit der <codeph>stage.nativeWindow</codeph>-Eigenschaft eines beliebigen Anzeigeobjekts auf der Bühne des jeweiligen Fensters möglich:
 </p>
 
 <pre platform="actionscript">var window:NativeWindow = displayObject.stage.nativeWindow;</pre>
 
 <p platform="javascript">Ein Verweis auf die NativeWindow-Instanz wird vom Fensterkonstruktor zurückgegeben. JavaScript in einer HTML-Seite kann unter Verwendung der <codeph>window.nativeWindow</codeph>-Eigenschaft auf die NativeWindow-Instanz verweisen.
 </p>
 
 <p>Der Zugriff auf die Eigenschaften einer NativeWindow-Instanz ist nur nach Anwendungsinhalt möglich. Wenn anwendungsfremder Inhalt versucht, auf ein NativeWindow-Objekt zuzugreifen, wird ein Sicherheitsfehler ausgegeben.</p>
 
 <p>Inhalte können einem Fenster hinzugefügt werden, indem DisplayObjectContainer-Methoden des Stage-Objekts, z. B. <codeph>addChild()</codeph> verwendet werden.</p>
 
 <p platform="actionscript">Flex-Komponenten können der Anzeigeliste einer NativeWindow-Instanz nicht direkt hinzugefügt werden. Erstellen Sie Ihre Fenster stattdessen mit den Flex-Komponenten „mx:WindowedApplication“ und „mx:Window“ und fügen Sie ihnen die anderen Flex-Komponenten als untergeordnete Objekte hinzu. Sie können einem NativeWindow-Fenster Flex-basierte SWF-Inhalte direkt hinzufügen, sofern die SWF-Datei Anwendungsinhalt ist und in ihre eigene Anwendungsdomäne geladen wird.
 </p>
 
 <p>Ein HTML-Stammfenster zur Anzeige von HTML-Inhalt lässt sich meist mit <codeph>HTMLLoader.createRootContent()</codeph> einfacher erstellen. Mit dieser Methode erstellte Fenster verfügen automatisch über ein HTMLLoader-Objekt. (Bei JavaScript-Code können Sie auch die <codeph>window.open()</codeph>-Funktion verwenden. Mit dieser Methode haben Sie jedoch weniger Kontrolle über das Erscheinungsbild und das Verhalten des Fensters.) </p>
 
 <p>
 Die folgenden Vorgänge für NativeWindow-Objekte sind asynchron: Änderungen von <codeph>close()</codeph>, <codeph>maximize()</codeph>, <codeph>minimize()</codeph>, <codeph>restore()</codeph> und <codeph>bounds</codeph>. Eine Anwendung kann durch Warten auf die jeweiligen Ereignisse feststellen, wann diese Operationen abgeschlossen wurden.
 </p>
 
 <p>
 Wenn die <codeph>NativeApplication.autoExit</codeph>-Eigenschaft auf den Standardwert <codeph>true</codeph>eingestellt ist, wird die Anwendung geschlossen, wenn ihr letztes Fenster geschlossen wird (und alle <codeph>close</codeph>-Ereignisprozeduren zurückgegeben wurden). Wenn <codeph>autoExit</codeph> auf <codeph>false</codeph> eingestellt ist, muss <codeph>NativeApplication.nativeApplication.exit()</codeph> aufgerufen werden, um die Anwendung zu beenden.
 </p>
 <p>
 NativeWindow-Objekte werden nicht vom Garbage Collector entfernt, nachdem der Fensterkonstruktor und bevor <codeph>close()</codeph> aufgerufen wurde. Die Anwendung ist dafür verantwortlich, ihre eigenen Fenster zu schließen.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/nativeWindow"><linktext>flash.display.Stage.nativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="flash.desktop.xml#NativeApplication"><linktext>flash.desktop.NativeApplication</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster deaktiviert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster deaktiviert wurde.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster aktiviert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster aktiviert wurde.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster geschlossen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster geschlossen wurde.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSING_closing"><apiName>closing</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor das Fenster geschlossen werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor das Fenster geschlossen werden soll. Dieses Ereignis kann abgebrochen werden, um das Schließen des Fensters zu verhindern.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE_displayStateChange"><apiName>displayStateChange</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem sich die displayState-Eigenschaft des Fensters geändert hat.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem die <codeph>displayState</codeph>-Eigenschaft des Fensters sich geändert hat.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING_displayStateChanging"><apiName>displayStateChanging</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor sich die display-Eigenschaft des Fensters ändert.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor sich die display-Eigenschaft des Fensters ändert. Dieses Ereignis kann abgebrochen werden, um die Änderung zu verhindern.
 
 </apiDesc><example conref="examples\NativeWindow.displayStateChanging.1.as"> Das folgende Beispiel zeigt, wie ein <codeph> displayStateChanging</codeph>-Ereignis abgebrochen wird.
<codeblock>
function displayStateChanging_handler(displayStateEvent:NativeWindowDisplayStateEvent):void
{
  //shouldStopStateChange is an application-defined Boolean indicating 
  //that display state changes should be canceled
  if (displayStateEvent.type == NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING 
                                  &amp;&amp;    shouldStopStateChange)
  {
    displayStateEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem die Größe des Fensters geändert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem die Größe des Fensters geändert wurde. Ein <codeph>resize</codeph>-Ereignis wird immer ausgelöst, wenn sich die Größe (<codeph>width</codeph>- oder <codeph>height</codeph>-Eigenschaft) ändert. Verursacht werden kann dies durch eine systemgesteuerte Größenänderung des Fensters, durch Minimieren, Maximieren oder Wiederherstellen des Fensters oder die Änderung der Fenstergröße durch das Setzen der <codeph>width</codeph>-, <codeph>height</codeph>- oder <codeph>bounds</codeph>-Eigenschaft. <codeph>resize</codeph>-Ereignisse für NativeWindow werden während systemgesteuerter resize-Schleifen ausgelöst. Im Gegensatz dazu werden <codeph>resize</codeph>-Ereignisse für Stage-Objekte ausgelöst, wenn die Bühne für das Zeichnen bereit ist.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Stage/resize"><linktext>flash.display.Stage.resize</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZING_resizing"><apiName>resizing</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor die Größe des Fensters auf dem Desktop geändert werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor die Größe des Fensters auf dem Desktop geändert werden soll. Dieses Ereignis kann abgebrochen werden, um die Größenänderung zu verhindern oder zu ändern.
 
 </apiDesc><example conref="examples\NativeWindow.resizing.1.as"> Das folgende Beispiel zeigt, wie ein <codeph>resizing</codeph>-Ereignis abgebrochen wird.
<codeblock>
function boundsChanging_handler(boundsEvent:NativeWindowBoundsEvent):void
{
  //shouldStopResize is an application-defined Boolean indicating 
  //that resize operations should be canceled
  if (boundsEvent.type == NativeWindowBoundsEvent.RESIZING &amp;&amp; shouldStopResize)
  {
    boundsEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVE_move"><apiName>move</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster auf dem Desktop verschoben wurde.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, nachdem das Fenster auf dem Desktop verschoben wurde.
 <p>
 Ein <codeph>move</codeph>-Ereignis wird immer ausgelöst, wenn sich der Ursprung (<codeph>x</codeph>- oder <codeph>y</codeph>-Eigenschaft) des Fensters ändert. Verursacht werden kann dies durch eine systemgesteuerte Fensterverschiebung, durch Minimieren, Maximieren oder Wiederherstellen des Fensters oder durch die Änderung der Fensterposition durch Setzen der <codeph>x</codeph>-, <codeph>y</codeph>- oder <codeph>bounds</codeph>-Eigenschaft.
 </p>
 <p><b>Hinweis:</b> Vermeiden Sie Aktionen, die möglicherweise gleichzeitig Betriebssystem-Dialogfelder in den Prozedurfunktionen für die beiden Ereignisse <codeph>moving</codeph> und <codeph>move</codeph> eines NativeWindow-Objekts öffnen. Dies kann beispielsweise auftreten, wenn beide Prozedurfunktionen einen Fehler ausgeben. Wenn das passiert, reagiert das zweite geöffnete Dialogfeld nicht auf Mausklicks und muss mithilfe der Tastatur geschlossen werden.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVING_moving"><apiName>moving</apiName><shortdesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor das Fenster auf dem Desktop verschoben werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von diesem NativeWindow-Objekt ausgelöst, unmittelbar bevor das Fenster auf dem Desktop verschoben werden soll. Dieses Ereignis kann abgebrochen werden, um die Verschiebung zu verhindern oder zu ändern.
 
 <p><b>Hinweis:</b> Vermeiden Sie Aktionen, die möglicherweise gleichzeitig Betriebssystem-Dialogfelder in den Prozedurfunktionen für die beiden Ereignisse <codeph>moving</codeph> und <codeph>move</codeph> eines NativeWindow-Objekts öffnen. Dies kann beispielsweise auftreten, wenn beide Prozedurfunktionen einen Fehler ausgeben. Wenn das passiert, reagiert das zweite geöffnete Dialogfeld nicht auf Mausklicks und muss mithilfe der Tastatur geschlossen werden.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeWindow:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
    Erstellt eine neue NativeWindow-Instanz und ein entsprechendes Betriebssystem-Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Wenn der <codeph>initOptions</codeph>-Parameter ungültig ist.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiParam><apiItemName>initOptions</apiItemName><apiOperationClassifier>flash.display:NativeWindowInitOptions</apiOperationClassifier><apiDesc>Ein Objekt, das die Initialisierungseigenschaften für dieses Fenster enthält.
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Erstellt eine neue NativeWindow-Instanz und ein entsprechendes Betriebssystem-Fenster.
    <p>
    Die im <codeph>initOptions</codeph>-Parameter definierten Einstellungen können nach der Erstellung des Fensters nicht mehr geändert werden. Ungültige <codeph>initOptions</codeph>-Einstellungen geben einen Fehler aufgrund eines ungültigen Vorgangs aus. Einstellungen, die zwar gültig, aber auf dem aktuellen System nicht verfügbar sind, verursachen keinen Ausnahmefehler. Die spezifischen Fensterfunktionen des aktuellen Betriebssystems lassen sich bei Bedarf über die statischen NativeWindow-Mitglieder ermitteln, wie beispielsweise <codeph>systemMaxSize</codeph>.
    </p>
    
    <p>Die Standardfenstergröße wird vom Betriebssystem bestimmt, kann aber durch Festlegen der Fenstergrenzen geändert werden. Diese Änderung ist nicht sichtbar, wenn die <codeph>visible</codeph>-Eigenschaft des Fensters auf <codeph>false</codeph> eingestellt ist.</p>
    
    </apiDesc><example conref="examples\NativeWindow.constructor.1.as"> Das folgende Beispiel zeigt, wie eine neue NativeWindow-Instanz erstellt und aktiviert wird:
<codeblock>
import flash.display.NativeWindowInitOptions;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowType;
import flash.display.NativeWindow;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.geom.Rectangle;

var windowOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
windowOptions.systemChrome = NativeWindowSystemChrome.STANDARD;
windowOptions.type = NativeWindowType.NORMAL;

var newWindow:NativeWindow = new NativeWindow(windowOptions);
newWindow.stage.scaleMode = StageScaleMode.NO_SCALE;
newWindow.stage.align = StageAlign.TOP_LEFT;
newWindow.bounds = new Rectangle(100, 100, 800, 800);

newWindow.activate();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeWindow:activate"><apiName>activate</apiName><shortdesc>
	 Aktiviert dieses Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Aktiviert dieses Fenster. 
	 
	 <p>Die Aktivierung eines Fensters hat folgende Auswirkungen:</p>
	 <ul> 
	 <li>Das Fenster wird sichtbar.</li>
	 <li>Das Fenster wird in den Vordergrund gestellt.</li> 
	 <li>Das Fenster erhält Tastatur- und Mausfokus.</li>
	 </ul>
	 
	 <p>Unter Linux ist <codeph>activate()</codeph> ein asynchroner Vorgang.</p>
	 
	 <p>Das NativeWindow-Objekt löst auf allen Plattformen ein <codeph>activate</codeph>-Ereignis aus.</p>
	 
	 </apiDesc><example conref="examples\NativeWindow.activate.1.as"> Das folgende Beispiel zeigt, wie ein Fenster aktiviert wird.
  
 <p>Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:</p>
<codeblock>
displayObject.stage.nativeWindow.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.2.as"> Mit einem Verweis auf eine Instanz der NativeWindow-Klasse:
<codeblock>
windowObj.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.3.as"> Von JavaScript in einer HTML-Seite, die im Fenster dargestellt wird (wobei <codeph>window</codeph> das globale JavaScript-Fensterobjekt ist):
<codeblock>
window.nativeWindow.activate();
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/visible"><linktext>visible</linktext></link><link href="flash.display.xml#NativeWindow/orderToFront"><linktext>orderToFront</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:close"><apiName>close</apiName><shortdesc>
      Schließt dieses Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Schließt dieses Fenster. 
      
      <p>Ein <codeph>close</codeph>-Ereignis wird ausgelöst, sobald der Schließvorgang beendet wurde. Ein <codeph>closing</codeph>-Ereignis wird nicht ausgelöst. Wenn das Abbrechen des Schließvorgangs zulässig sein soll, lösen Sie ein <codeph>closing</codeph>-Ereignis aus und überprüfen Sie, ob registrierte Listener das Standardverhalten vor dem Aufruf der <codeph>close</codeph>-Methode abbrechen.
      </p>
      <p>
      Wenn auf Anzeigeobjektinstanzen , die sich aktuell im Fenster befinden, nicht anderswo verwiesen wird, werden sie vom Garbagekollektor eingesammelt und zerstört, mit Ausnahme des ursprünglichen mit AIR erstellten Anwendungsfensters. Damit Anzeigeobjekte vom Garbagekollektor aus dem ursprünglichen Fenster entfernt werden können, müssen Sie sie von der Fensterbühne entfernen.
      </p>
      <p>
      Nach dem Schließen ist das NativeWindow-Objekt zwar immer noch ein gültiger Verweis, aber beim Zugriff auf die meisten Eigenschaften und Methoden wird ein Fehler aufgrund eines ungültigen Vorgangs ausgegeben.
      </p>
      <p>
      Geschlossene Fenster können nicht erneut geöffnet werden. Wenn das Fenster bereits geschlossen ist, werden keine Aktionen ausgeführt und keine Ereignisse ausgelöst.
      </p>
      
      <p>Hinweis: Um ein Fenster auszublenden, ohne es zu schließen, stellen Sie seine <codeph>visible</codeph>-Eigenschaft auf <codeph>false</codeph> ein.
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.close.1.as"> Das folgende Beispiel zeigt, wie ein Fenster geschlossen wird.
  
 <p>Mit einem Verweis auf die NativeWindow-Instanz (<codeph>windowObj</codeph>):</p>
<codeblock>
windowObj.close();

</codeblock></example><example conref="examples\NativeWindow.close.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObj.stage.nativeWindow.close();
</codeblock></example><example conref="examples\NativeWindow.close.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.close(); //overriddable in HTMLHost
</codeblock></example><example conref="examples\NativeWindow.close.4.as"> Oder:
<codeblock>
window.nativeWindow.close(); //not overriddable
</codeblock></example><example conref="examples\NativeWindow.close.5.as">  
 Das folgende Beispiel zeigt, wie das Abbrechen einer close-Operation zugelassen werden kann (dabei ist <codeph>windowObj</codeph> die NativeWindow-Instanz, die geschlossen werden soll):
<codeblock>
public function closeCommand():Boolean{
    var closeEvent:Event = new Event(Event.CLOSING,true,true);
    windowObj.dispatchEvent(closeEvent);
    if(!closeEvent.isDefaultPrevented()){
        windowObj.close();
        return true;
    } else {
      return false;
    }
}
</codeblock></example><example conref="examples\NativeWindow.close.6.as"> Das folgende Beispiel veranschaulicht das Schließen eines Fensters mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt (oder HTML-Stammfenster) ausgeführt wird, wobei das Abbrechen des Vorgangs zulässig ist:
<codeblock>
&lt;script src="AIRAliases.js" type="text/javascript">&lt;/script>
&lt;script type="text/javascript">
    var dirtyData = false;
    function closeWindow(){
            var closingEvent = new air.Event(air.Event.CLOSING,true,true);
            window.nativeWindow.dispatchEvent(closingEvent);
               if(!closingEvent.isDefaultPrevented()){
                   window.nativeWindow.close();
                //or use: window.close(); 
               return true;
           } else {
               return false;
        }
    }
        
    function onClosing(event){
        if(dirtyData){
            event.preventDefault();
            //Save data...
        }
    }    

    window.nativeWindow.addEventListener(air.Event.CLOSING,onClosing);        
&lt;/script>
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/closed"><linktext>flash.display.NativeWindow.closed</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>flash.html.HTMLLoader</linktext></link><link href="../../flash/html/HTMLHost.html"><linktext>flash.html.HTMLHost</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:globalToScreen"><apiName>globalToScreen</apiName><shortdesc>
      Konvertiert einen Punkt in Pixelkoordinaten relativ zum Ursprung der Fensterbühne (ein globaler Punkt hinsichtlich der Anzeigeliste) in einen Punkt auf dem virtuellen Desktop</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der angegebene globale Punkt relativ zum Desktop.
      
      </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>globalPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt auf der Bühne, der in einen Punkt auf dem Bildschirm konvertiert werden soll.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Konvertiert einen Punkt in Pixelkoordinaten relativ zum Ursprung der Fensterbühne (ein globaler Punkt hinsichtlich der Anzeigeliste) in einen Punkt auf dem virtuellen Desktop
      
      <p>Virtuelle Desktop-Koordinaten sind relativ zur oberen linken Ecke des primären Monitors.</p>
      
      </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:maximize"><apiName>maximize</apiName><shortdesc>
      Maximiert dieses Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die <codeph>maximizable</codeph>-Eigenschaft dieses Fensters <codeph>false</codeph> ist oder die Methode nach dem Schließen dieses Fensters aufgerufen wird.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Maximiert dieses Fenster.  
      <p>
      Ein Aufruf der <codeph>maximize()</codeph>-Methode löst ein <codeph>displayStateChange</codeph>-Ereignis und ggf. auch ein <codeph>move</codeph>- und ein <codeph>resize</codeph>-Ereignis aus. Während das Systemchrom ein <codeph>displayStateChanging</codeph>-Ereignis ausgelöst wird, das abgebrochen werden kann, wenn der Benutzer einen Maximierungsbefehl initiiert, muss Ihre Maximierungslogik dieses Verhalten, falls erwünscht, erst implementieren.
      </p>
      <p>
      Die <codeph>maximize()</codeph>-Methode wird asynchron ausgeführt. Durch Warten auf das <codeph>displayStateChange</codeph>-Ereignis kann festgestellt werden, ob die Statusänderung abgeschlossen wurde.
      </p>
      <p>Wenn das Fenster bereits maximiert ist, werden keine Aktionen ausgeführt und keine Ereignisse ausgelöst.</p>
      
      <p><b>Hinweise:</b></p> 
      <ul>
      <li>Hinweis: Auf Betriebssystemen, unter denen die Maximierung des Fensters eine Größenänderung nicht verhindert (wie beispielsweise Mac OS X), wird das Fenster beim Aufruf von <codeph>maximize()</codeph> auf die volle Bildschirmgröße vergrößert, was jedoch eine anschließende Größenänderung nicht verhindert. Bei der Größenänderung eines vergrößerten Fensters wird auch der Anzeigestatus wiederhergestellt.</li>
      
      <li>Auf manchen Betriebssystemen, wie Mac OS X oder manchen Linux-Fenstermanagern, werden Fenster beim Maximieren nicht über die in der <codeph>maxSize</codeph>-Eigenschaft angegebenen Breite und Höhe hinaus vergrößert. Auf anderen vergrößern sich Fenster und füllen den ganzen Bildschirm aus, auch wenn er größer ist als die in <codeph>maxSize</codeph> angegebene Größe.</li>
      
      <li>Bei manchen Linux-Fenstermanagern können Fenster von Dienstprogrammen nicht maximiert werden.</li>
      
      </ul>
      
      </apiDesc><example conref="examples\NativeWindow.maximize.1.as">  
 Das folgende Beispiel zeigt, wie das Abbrechen eines Maximierungsvorgangs zugelassen werden kann:  
<codeblock>
public function maximizeWindow(nativeWin:NativeWindow):Boolean{
  if(nativeWin.displayState != NativeWindowDisplayState.MAXIMIZED){
    var beforeState:String = nativeWin.displayState;
    var afterState:String = NativeWindowDisplayState.MAXIMIZED;
    var displayStateEvent:NativeWindowDisplayStateEvent = 
        new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
    nativeWin.dispatchEvent(displayStateEvent);
    if(!displayStateEvent.isDefaultPrevented()){
        nativeWin.maximize();
        return true;
    } else {
      return false;
    }
  }
  return false;
}
</codeblock></example><example conref="examples\NativeWindow.maximize.2.as">  
 Das folgende Beispiel zeigt, wie das Abbrechen eines maximize-Vorgangs mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder einem HTML-Fenster) ausgeführt wird, zugelassen werden kann:  
<codeblock>
function maximizeWindow(nativeWin){
    if(nativeWin.displayState != air.NativeWindowDisplayState.MAXIMIZED){
        var beforeState = nativeWin.displayState;
        var afterState = air.NativeWindowDisplayState.MAXIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.maximize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:minimize"><apiName>minimize</apiName><shortdesc>
      Minimiert dieses Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die <codeph>minimizable</codeph>-Eigenschaft des Fensters <codeph>false</codeph> ist oder die Methode nach dem Schließen dieses Fensters aufgerufen wird.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Minimiert dieses Fenster. 
      <p>
      Ein Aufruf von <codeph>minimize()</codeph> löst ein <codeph>displayStateChange</codeph>-Ereignis und ggf. auch ein <codeph>move</codeph>- und ein <codeph>resize</codeph>-Ereignis aus. Während für das Systemchrom ein <codeph>displayStateChanging</codeph>-Ereignis ausgelöst wird, das abgebrochen werden kann, wenn der Benutzer einen Minimierungsbefehl ausgibt, ist dies beim direkten Aufruf von <codeph>minimize()</codeph> nicht der Fall. Dieses Verhalten kann in der Minimierungslogik implementiert werden.
      </p>
      
      <p>Die <codeph>minimize()</codeph>-Methode wird asynchron ausgeführt. Durch Warten auf das <codeph>displayStateChange</codeph>-Ereignis kann festgestellt werden, ob die Statusänderung abgeschlossen wurde. Wenn das Fenster bereits minimiert ist, werden keine Aktionen ausgeführt und keine Ereignisse ausgelöst.</p>
      
      <p>Bei manchen Linux-Fenstermanagern können Fenster von Dienstprogrammen nicht minimiert werden.</p>
      
	  </apiDesc><example conref="examples\NativeWindow.minimize.1.as"> Das folgende Beispiel zeigt, wie das Abbrechen eines Aufrufs von <codeph>minimize()</codeph> zugelassen werden kann, indem ein <codeph>DisplayStateChangingEvent</codeph>-Ereignis ausgelöst wird: 
<codeblock>
public function minimizeWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.MINIMIZED){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.minimize.2.as"> Das folgende Beispiel zeigt, wie das Abbrechen eines Aufrufs von <codeph>minimize</codeph> mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt (oder einem HTML-Fenster) ausgeführt wird, zugelassen werden kann: 
<codeblock> 
function minimizeWindow(){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.MINIMIZED){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:notifyUser"><apiName>notifyUser</apiName><shortdesc>
      Löst über das Betriebssystem einen visuellen Hinweis aus, der anzeigt, dass ein wichtiges Ereignis aufgetreten ist.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String, der die Dringlichkeit der Benachrichtigung repräsentiert.   
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      Löst über das Betriebssystem einen visuellen Hinweis aus, der anzeigt, dass ein wichtiges Ereignis aufgetreten ist.
      
      <p>Wenn <codeph>NativeWindow.supportsNotification</codeph> auf <codeph>true</codeph> eingestellt ist, entspricht der visuelle Hinweis den Konventionen des nativen Betriebssystems. Unter Windows blinkt beispielsweise das Symbol in der Taskleiste.</p>
      
      <p>Der <codeph>type</codeph>-Parameter bestimmt die Intensität des visuellen Hinweises. Konstanten für die zulässigen Werte sind in der NotificationType-Klasse definiert und können folgendermaßen lauten:</p>
      <ul>
      <li><codeph>NotificationType.INFORMATIONAL</codeph></li>
      <li><codeph>NotificationType.CRITICAL</codeph></li>
      </ul>
      <p>Visuelle Hinweise, die nur zur Information dienen, werden nur kurz angezeigt. Dagegen werden visuelle Hinweise für kritische Benachrichtigungen so lange angezeigt, bis der Benutzer dieses Fenster aktiviert. Nicht alle Linux-Fenstermanager unterstützen zwei Benachrichtigungsebenen: Bei solchen Fenstermanagern hat <codeph>notifyUser()</codeph> die gleichen Auswirkungen, egal, welche Option festgelegt ist.</p>
      
      <p><b>Hinweis:</b> <codeph>notifyUser()</codeph> kann zwar aufgerufen werden, wenn <codeph>NativeWindow.supportsNotification</codeph> auf <codeph>false</codeph> eingestellt ist, hat in diesem Fall jedoch keine Wirkung.</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInBackOf"><apiName>orderInBackOf</apiName><shortdesc>
      Stellt dieses Fenster direkt hinter das angegebene Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, wenn dieses Fenster erfolgreich in den Hintergrund gestellt wurde; <codeph>false</codeph>, wenn dieses Fenster unsichtbar oder minimiert ist.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>Ein Anwendungsfenster.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Stellt dieses Fenster direkt hinter das angegebene Fenster.
      
      <p>Weder das Fenster noch die Anwendung wird aktiviert oder erhält den Fokus. Minimierte oder ausgeblendete Fenster (<codeph>visible</codeph> ist <codeph>false</codeph>) können nicht neu angeordnet werden.</p>
      
      <p>Bei manchen Linux-Fenstermanagern können Fenster von Dienstprogrammen nicht hinter normalen Fenstern angeordnet werden.</p>
      
      </apiDesc><example conref="NativeWindow.orderInBackOf.1.as"> Die folgenden Beispiele zeigen, wie ein Fenster mit Verweisen auf die NativeWindow-Instanzen direkt unter ein anderes Fenster verschoben wird:
<codeblock>
windowBehind.orderInBackOf(windowFront);
</codeblock></example><example conref="NativeWindow.orderInBackOf.2.as"> Mit Verweisen auf Anzeigeobjekte auf den Fensterbühnen:
<codeblock>
displayObjBehind.stage.nativeWindow.orderInBackOf(displayObjectFront.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInBackOf.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt (oder HTML-Stammfenster) ausgeführt wird, unter Verwendung von Verweisen auf zwei JavaScript-Fensterobjekte:
<codeblock>
jsWindowObjBehind.nativeWindow.orderInBackOf(jsWindowObjFront.nativeWindow);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInFrontOf"><apiName>orderInFrontOf</apiName><shortdesc>
      Stellt dieses Fenster direkt vor das angegebene Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, wenn dieses Fenster in den Vordergrund gestellt wurde; <codeph>false</codeph>, wenn dieses Fenster unsichtbar oder minimiert ist.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>Ein Anwendungsfenster.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Stellt dieses Fenster direkt vor das angegebene Fenster.
      
      <p>Weder das Fenster noch die Anwendung wird aktiviert oder erhält den Fokus. Minimierte oder ausgeblendete Fenster (<codeph>visible</codeph> ist <codeph>false</codeph>) können nicht neu angeordnet werden.</p>
      
      <p>Bei manchen Linux-Fenstermanagern können normale Fenster nicht vor Fenstern von Dienstprogrammen angeordnet werden.</p>
      
      </apiDesc><example conref="NativeWindow.orderInFrontOf.1.as"> Die folgenden Beispiele zeigen, wie ein Fenster mit Verweisen auf die NativeWindow-Instanzen direkt über ein anderes Fenster verschoben wird:
<codeblock>
windowFront.orderInFrontOf(windowBehind);
</codeblock></example><example conref="NativeWindow.orderInFrontOf.2.as"> Mit Verweisen auf Anzeigeobjekte auf den Fensterbühnen:
<codeblock>
displayObjFront.stage.nativeWindow.orderInFrontOf(displayObjectBehind.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInFrontOf.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt (oder HTML-Stammfenster) ausgeführt wird, unter Verwendung von Verweisen auf zwei JavaScript-Fensterobjekte:
<codeblock>
jsWindowObjFront.nativeWindow.orderInFrontOf(jsWindowObjBehind.nativeWindow);

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToBack"><apiName>orderToBack</apiName><shortdesc>
      Stellt dieses Fenster hinter alle anderen sichtbaren Fenster in den Hintergrund.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, wenn dieses Fenster in den Hintergrund gestellt wurde; <codeph>false</codeph>, wenn dieses Fenster unsichtbar oder minimiert ist.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Stellt dieses Fenster hinter alle anderen sichtbaren Fenster in den Hintergrund.
      
      <p>Weder das Fenster noch die Anwendung wird aktiviert oder erhält den Fokus. Minimierte oder ausgeblendete Fenster (<codeph>visible</codeph> ist <codeph>false</codeph>) können nicht neu angeordnet werden.</p>
      
      <p>Wenn <codeph>alwaysInFront</codeph> den Wert <codeph>true</codeph> hat, wird dieses Fenster beim Aufruf dieser Methode nicht hinter Fenster gestellt, für die <codeph>alwaysInFront</codeph> gleich <codeph>false</codeph> gilt.</p>
      
      <p>Bei manchen Linux-Fenstermanagern können Fenster von Dienstprogrammen nicht hinter normalen Fenstern angeordnet werden.</p>
      
      </apiDesc><example conref="NativeWindow.orderToBack.1.as"> Das folgende Beispiel zeigt, wie ein Fenster hinter alle anderen Fenster (mit derselben <codeph>alwaysInFront</codeph>-Einstellung) in der Anwendung gestellt wird:
<codeblock>
windowObj.orderToBack();

</codeblock></example><example conref="NativeWindow.orderToBack.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObj.stage.nativeWindow.orderToBack();
</codeblock></example><example conref="NativeWindow.orderToBack.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.nativeWindow.orderToBack();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToFront"><apiName>orderToFront</apiName><shortdesc>
      Stellt dieses Fenster vor alle anderen sichtbaren Fenster in den Vordergrund.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, wenn dieses Fenster in den Vordergrund gestellt wurde; <codeph>false</codeph>, wenn dieses Fenster unsichtbar oder minimiert ist.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Stellt dieses Fenster vor alle anderen sichtbaren Fenster in den Vordergrund. 
      
      <p>Weder das Fenster noch die Anwendung wird aktiviert oder erhält den Fokus. Minimierte oder ausgeblendete Fenster (<codeph>visible</codeph> ist <codeph>false</codeph>) können nicht neu angeordnet werden.</p>
       
      <p>Wenn <codeph>alwaysInFront</codeph> auf <codeph>false</codeph> gesetzt ist, wird dieses Fenster beim Aufruf dieser Methode nicht vor Fenster gestellt, für die <codeph>alwaysInFront</codeph> gleich <codeph>true</codeph> gilt.</p>
      
      <p>Bei manchen Linux-Fenstermanagern können normale Fenster nicht vor Fenstern von Dienstprogrammen angeordnet werden.</p> 
      
      </apiDesc><example conref="NativeWindow.orderToFront.1.as"> Das folgende Beispiel zeigt, wie ein Fenster vor alle anderen Fenster in der Anwendung (mit derselben <codeph>alwaysInFront</codeph>-Einstellung) gestellt wird:
<codeblock>
windowObj.orderToFront();

</codeblock></example><example conref="NativeWindow.orderToFront.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObj.stage.nativeWindow.orderToFront();
</codeblock></example><example conref="NativeWindow.orderToFront.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.nativeWindow.orderToFront();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:restore"><apiName>restore</apiName><shortdesc>
      Stellt dieses Fenster von einem minimierten oder maximierten Zustand wieder her.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die Methode nach dem Schließen dieses Fensters aufgerufen wird.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Stellt dieses Fenster von einem minimierten oder maximierten Zustand wieder her.
      
      <p>Ein Aufruf von <codeph>restore()</codeph> löst ein <codeph>displayStateChange</codeph>-Ereignis und ggf. auch ein <codeph>move</codeph>- und ein <codeph>resize</codeph>-Ereignis aus. Während für das Systemchrom ein <codeph>displayStateChanging</codeph>-Ereignis ausgelöst wird, das abgebrochen werden kann, wenn der Benutzer einen Minimierungsbefehl initiiert, muss Ihre Maximierungslogik dieses Verhalten, falls erwünscht, erst implementieren.
      </p>
      
      <p>Wenn das Fenster sich bereits im Status <codeph>NativeWindowDisplayState.NORMAL</codeph> befindet, werden keine Aktionen ausgeführt und keine Ereignisse ausgelöst.</p>
      
      <p>
      Durch Warten auf das <codeph>displayStateChange</codeph>-Ereignis, das auf allen Plattformen ausgelöst wird, kann festgestellt werden, ob die Statusänderung abgeschlossen wurde.
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.restore.1.as">  
 Das folgende Beispiel zeigt, wie das Abbrechen eines Wiederherstellungsvorgangs zugelassen wird: 
<codeblock>
public function restoreWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.NORMAL){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.NORMAL;
        var displayStateChangingEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateChangingEvent);
        if(!displayStateChangingEvent.isDefaultPrevented()){
            nativeWin.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.restore.2.as"> Das folgende Beispiel zeigt, wie das Abbrechen eines Wiederherstellungsvorgangs mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder einem HTML-Fenster) ausgeführt wird, zugelassen wird: 
<codeblock>
function restoreWindow(nativeWin){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.NORMAL){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.NORMAL;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:startMove"><apiName>startMove</apiName><shortdesc>
      Startet eine systemgesteuerte Verschiebung dieses Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die Methode nach dem Schließen dieses Fensters aufgerufen wird.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, wenn die Verschiebung erfolgreich ausgeführt wurde, und <codeph>false</codeph>, wenn das Fenster maximiert ist.
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Startet eine systemgesteuerte Verschiebung dieses Fensters.
      <p>
      Beim Aufruf von einem <codeph>mouseDown</codeph>-Ereignis startet diese Methode eine mausgesteuerte Verschiebesequenz, die bis zum Auftreten eines <codeph>mouseUp</codeph>-Ereignisses fortgesetzt wird. 
      </p>
      <p>
      Beim Aufruf von anderem Code startet diese Methode eine tastatur- oder mausgesteuerte Verschiebesequenz gemäß der Standardsequenz des Betriebssystems.
      </p>
      
      <p>Bei einer Verschiebesequenz werden mehrere Ereignisse ausgelöst, während der Fensterursprung sich verschiebt. Für jeden Verschiebungsschritt wird zunächst ein <codeph>moving</codeph>-Ereignis ausgelöst. Wird dieses <codeph>moving</codeph>-Ereignis nicht abgebrochen, wird die Fensterposition aktualisiert und ein <codeph>move</codeph>-Ereignis ausgelöst. Wenn das <codeph>moving</codeph>-Ereignis abgebrochen wird, wird die Verschiebesequenz umgehend beendet.</p>
      
      </apiDesc><example conref="NativeWindow.startMove.1.as"> Das folgende Beispiel zeigt, wie ein Fenster als Reaktion auf ein <codeph>mouseDown</codeph>-Ereignis verschoben wird:
<codeblock>
var initOpts:NativeWindowInitOptions = new NativeWindowInitOptions();
var win:NativeWindow = new NativeWindow(initOpts);
win.activate();
win.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);

function mouseDownHandler(event:MouseEvent):void
{
    win.startMove();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:startResize"><apiName>startResize</apiName><shortdesc>
      Startet eine systemgesteuerte Größenänderung dieses Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn die Methode nach dem Schließen dieses Fensters aufgerufen wird.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, wenn die Größenänderung erfolgreich ausgeführt wurde, und <codeph>false</codeph>, wenn das Fenster maximiert ist.

      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>edgeOrCorner</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Eine Konstante der NativeWindowResize-Klasse, die angibt, an welcher Kante oder Ecke dieses Fensters die Größe geändert werden soll. Folgende Werte sind gültig:
      
      <p>
      <adobetable class="innertable">
          
           
           
           
           
            
            
            
            
            
           
      <tgroup cols="3"><thead><row><entry>Wert</entry><entry>Vertical alignment</entry><entry>Horizontal alignment</entry></row></thead><tbody><row><entry><codeph>NativeWindowResize.TOP</codeph></entry>
           <entry>Top</entry>
           <entry>Center</entry>
           </row><row><entry><codeph>NativeWindowResize.BOTTOM</codeph></entry>
           <entry>Bottom</entry>
           <entry>Center</entry>
           </row><row><entry><codeph>NativeWindowResize.LEFT</codeph></entry>
           <entry>Center</entry>
           <entry>Left</entry>
           </row><row><entry><codeph>NativeWindowResize.RIGHT</codeph></entry>
           <entry>Center</entry>
           <entry>Right</entry>
           </row><row><entry><codeph>NativeWindowResize.TOP_LEFT</codeph></entry>
            <entry>Top</entry>
            <entry>Left</entry>
            </row><row><entry><codeph>NativeWindowResize.TOP_RIGHT</codeph></entry>
            <entry>Top</entry>
            <entry>Right</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_LEFT</codeph></entry>
            <entry>Bottom</entry>
            <entry>Left</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_RIGHT</codeph></entry>
            <entry>Bottom</entry>
            <entry>Right</entry>
            </row><row><entry><codeph>NativeWindowResize.NONE</codeph></entry>
            <entry>Bottom</entry>
            <entry>Right</entry>
            </row></tbody></tgroup></adobetable>
      </p>
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Startet eine systemgesteuerte Größenänderung dieses Fensters.
      <p>
      Beim Aufruf von einer <codeph>mouseDown</codeph>-Ereignisprozedur startet diese Methode eine mausgesteuerte Größenänderungssequenz, die bis zum Auftreten eines <codeph>mouseUp</codeph>-Ereignisses fortgesetzt wird.  
      </p>
      <p>
      Beim Aufruf von anderem Code startet diese Methode eine tastatur- oder mausgesteuerte Größenänderungssequenz gemäß der Standardsequenz des Betriebssystems.
      </p>
      <p>Bei der Größenänderungssequenz werden mehrere Ereignisse ausgelöst, während die Fensterabmessungen sich ändern. Für jeden Änderungsschritt wird zunächst ein <codeph>resizing</codeph>-Ereignis ausgelöst. Wird dieses <codeph>resizing</codeph>-Ereignis nicht abgebrochen, werden die Fensterabmessungen aktualisiert und ein <codeph>resize</codeph>-Ereignis wird ausgelöst. Wenn das <codeph>resizing</codeph>-Ereignis abgebrochen wird, wird die Sequenz umgehend beendet.</p>
      
      </apiDesc><example conref="NativeWindow.startResize.1.as"> Das folgende Beispiel zeigt, wie ein Fenster als Reaktion auf ein <codeph>mouseDown</codeph>-Ereignis verschoben wird:
<codeblock>
stage.addEventListener(MouseEvent.MOUSE_DOWN, onResizeCommand);

function onResizeCommand(event:MouseEvent):void
{
    var win:NativeWindow = event.target.nativeWindow;
    var resizeFrom:String = "";
    if (event.stageY &lt; win.height * .33)
    {
        resizeFrom = NativeWindowResize.TOP;
    }
    else if (event.stageY > win.height * .66)
    {
        resizeFrom = NativeWindowResize.BOTTOM;
    }
    if (event.stageX &lt; win.width * .33)
    {
        resizeFrom += NativeWindowResize.LEFT;
    }
    else if (event.stageX > win.width * .66)
    {
        resizeFrom += NativeWindowResize.RIGHT;
    }
    win.startResize(resizeFrom);    
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeWindow:active:get"><apiName>active</apiName><shortdesc>
      Gibt an, ob es sich bei diesem Fenster um das aktive Anwendungsfenster handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Gibt an, ob es sich bei diesem Fenster um das aktive Anwendungsfenster handelt.
      
      <p>Verwenden Sie die <codeph>activate()</codeph>-Methode, um ein Fenster zu aktivieren.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate"><linktext>flash.display.NativeWindow.activate</linktext></link><link href="flash.desktop.xml#NativeApplication/activate"><linktext>flash.desktop.NativeApplication.activate</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:alwaysInFront:get"><apiName>alwaysInFront</apiName><shortdesc>
      Gibt an, ob dieses Fenster sich stets vor anderen Fenstern befindet (auch vor Fenstern anderer Anwendungen).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Gibt an, ob dieses Fenster sich stets vor anderen Fenstern befindet (auch vor Fenstern anderer Anwendungen).
      
      <p>Die Tiefenanordnung des Systems lässt sich in zwei Fenstergruppen einteilen. Fenster in der Gruppe <codeph>alwaysInFront</codeph> werden immer vor allen anderen Fenstern angezeigt. Die Tiefenanordnung der Fenster in derselben Gruppe wird normal bestimmt. Das heißt, dass ein Fenster durch Aktivieren vor die anderen Fenster in seiner Gruppe gestellt wird.</p>
      
      <p>Wird <codeph>alwaysInFront</codeph> von <codeph>false</codeph> zu <codeph>true</codeph> geändert, wird das Fenster vor alle anderen Fenster gestellt. Beim Ändern der Eigenschaft von <codeph>true</codeph> zu <codeph>false</codeph> wird das Fenster hinter die Fenster gestellt, die auf „alwaysInFront“ eingestellt sind, es befindet sich jedoch immer noch vor allen anderen Fenstern. Wenn die Eigenschaft auf ihren aktuellen Wert eingestellt wird, ändert sich die Tiefenanordnung der Fenster nicht.</p>
      
      <p>Die <codeph>alwaysInFront</codeph>-Eigenschaft sollte nur selten auf <codeph>true</codeph> gesetzt werden, da Fenster mit dieser Einstellung auch vor den Fenstern anderer Anwendungen angezeigt werden, selbst wenn die andere Anwendung aktiv ist.</p>
      
      <p>Manche Linux-Fenstermanager zeigen Dienstfenster immer vor normalen Fenstern an.</p>
      
      <p><b>Hinweis:</b> Unter Mac<sup>®</sup> OS X hat die Einstellung von <codeph>alwaysInFront</codeph> auf <codeph>true</codeph> keine Wirkung, wenn die <codeph>displayState</codeph>-Eigenschaft der Fensterbühne entweder <codeph>fullScreen</codeph> oder <codeph>fullScreenInteractive</codeph> lautet. Unter Linux werden Vollbildfenster mit <codeph>alwaysInFront</codeph> auf <codeph>true</codeph> immer vor anderen Fenstern angezeigt, bei denen <codeph>alwaysInFront</codeph> auf <codeph>true</codeph> gesetzt ist.</p> 
      
      </apiDesc><example conref="NativeWindow.alwaysInFront.1.as"> Das folgende Beispiel zeigt, wie erzwungen wird, dass ein Fenster vor allen anderen Fenstern angezeigt wird (bei denen die Anzeige im Vordergrund nicht erzwungen wird):
<codeblock>
windowObj.alwaysInFront = true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObject.stage.nativeWindow.alwaysInFront=true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.nativeWindow.alwaysInFront = true;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:bounds:set"><apiName>bounds</apiName><shortdesc>
      Die Größe und Position dieses Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>Wenn das Rechteck null ist oder ungültige Werte enthält.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die bounds-Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Die Größe und Position dieses Fensters.  
      <p>
      Die Abmessungen eines Fensters umfassen auch ggf. vorhandenes Systemchrom. Die Abmessungen der Fensterbühne entsprechen den Fensterabmessungen abzüglich der Größe des ggf. vorhandenen Systemchroms. Wenn die Breite und die Höhe des Fensters geändert werden, ändern sich auch die Eigenschaften <codeph>stageWidth</codeph> und <codeph>stageHeight</codeph> der Bühne. Umgekehrt wird bei einer Änderung der Bühnenabmessungen auch die Fenstergröße geändert.
      </p>
      <p>In einem HTML-Stammfenster entsprechen die <codeph>outerWidth</codeph>- und <codeph>outerHeight</codeph>-Eigenschaften den Fenstereigenschaften <codeph>height</codeph> und <codeph>width</codeph>. Die Eigenschaften <codeph>innerWidth</codeph> und <codeph>innerHeight</codeph> entsprechen den Eigenschaften <codeph>stage.stageWidth</codeph> und <codeph>stage.stageHeight</codeph> abzüglich der Dicke der automatischen Bildlaufleisten, die ggf. im Fenster angezeigt werden.</p>
      <p>
      Ein <codeph>resize</codeph>-Ereignis wird immer ausgelöst, wenn sich die Breite oder die Höhe dieses Fensters ändert. Gleichermaßen wird ein <codeph>move</codeph>-Ereignis ausgelöst, wenn sich der Ursprung (x,y) dieses Fensters ändert. Unter Mac OS und Windows löst das direkte Setzen der <codeph>bounds</codeph>-Eigenschaft kein <codeph>moving</codeph>- oder <codeph>resizing</codeph>-Ereignis aus. Unter Linux <i>löst</i> das NativeWindow <codeph>moving</codeph>- und <codeph>resizing</codeph>-Ereignisse aus, wenn Sie die <codeph>bounds</codeph>-Eigenschaft setzen. 
      </p>
      <p>
      Das Setzen der <codeph>bounds</codeph>-Eigenschaft für ein Fenster entspricht dem Setzen der Eigenschaften <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph>. Ähnlich entspricht das Setzen der einzelnen Abmessungen dem Setzen der <codeph>bounds</codeph>-Eigenschaft. Wenn Sie alle Abmessungen unter Verwendung der <codeph>bounds</codeph>-Eigenschaft gleichzeitig setzen, werden weniger Ereignisse ausgelöst. 
      </p>
      <p>Die Reihenfolge, in der die einzelnen Abmessungswerte gesetzt werden, ist nicht garantiert. Bei Linux-Fenstermanagern, die die Vergrößerung von Fenstern über den Desktopbereich hinaus nicht erlauben, kann die Änderung einer einzelnen Eigenschaft blockiert werden, selbst wenn der Gesamteffekt bei Anwendung aller Eigenschaftenänderungen ein gültiges Fenster ergeben hätte.</p>
      
      <p>Wenn die angegebene Breite bzw. Höhe den erlaubten Mindest- oder Höchstwert unter- bzw. überschreitet, wird die Fensterbreite oder -höhe auf den nächsten zulässigen Wert gesetzt. Folgende Faktoren bestimmen die minimale und maximale Breite bzw. Höhe:</p>
      
      <ul>
      
      	<li>Die <codeph>minSize</codeph>- und <codeph>maxSize</codeph>-Eigenschaft des NativeWindow-Objekts</li>
      	<li>Die Mindest- und Höchstgrenze des Betriebssystems, die den Werten von <codeph>NativeWindow.systemMinSize</codeph> und <codeph>NativeWindow.systemMaxSize</codeph> entspricht.</li>
      	<li>Die maximale Breite und Höhe eines Fensters in Adobe AIR, die je 2.880 Pixel beträgt.</li>
      	<li>Die minimale Breite und Höhe für ein beliebiges angezeigtes Systemchrom.</li>
      
      </ul>
      
	  </apiDesc><example conref="examples\NativeWindow.bounds.1.as"> Im folgenden Beispiel wird gezeigt, wie die Grenzen eines Fensters mit Verweis auf ein NativeWindow-Objekt gesetzt werden können:
<codeblock>
windowObj.bounds = new Rectangle(200, 200, 1000, 800);
</codeblock></example><example conref="examples\NativeWindow.bounds.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObject.stage.nativeWindow.bounds = new Rectangle(20, 20, 800, 600);
</codeblock></example><example conref="examples\NativeWindow.bounds.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.nativeWindow.bounds = new air.Rectangle(20, 20, 800, 600);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:closed:get"><apiName>closed</apiName><shortdesc>
      Gibt an, ob dieses Fenster geschlossen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Gibt an, ob dieses Fenster geschlossen wurde.  
      
      <p>Beim Zugriff auf die folgenden Eigenschaften für ein geschlossenes Fenster wird ein Fehler aufgrund eines ungültigen Vorgangs ausgegeben:</p>
      <ul> 
      <li><codeph>title</codeph></li>
      <li><codeph>bounds</codeph></li>
      <li><codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, <codeph>height</codeph></li>
      <li><codeph>displayState</codeph></li>
      <li><codeph>visible</codeph></li>
      </ul>
      <p>Gleichermaßen wird beim Aufrufen der folgenden Methoden für ein geschlossenes Fenster ein Fehler aufgrund eines ungültigen Vorgangs ausgegeben:</p>
      <ul>
      <li><codeph>minimize()</codeph></li>
      <li><codeph>maximize()</codeph></li>
      <li><codeph>restore()</codeph></li>
      <li><codeph>startResize()</codeph></li>
      <li><codeph>startMove()</codeph></li>
      </ul>
      
      </apiDesc><example conref="NativeWindow.closed.1.as"> Im folgenden Beispiel wird gezeigt, wie auf die <codeph>closed</codeph>-Eigenschaft eines Fensters zugegriffen wird:
<codeblock>
var isWindowClosed:Boolean = windowObj.closed;
</codeblock></example><example conref="NativeWindow.closed.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
var isWindowClosed:Boolean = displayObject.stage.nativeWindow.closed;
</codeblock></example><example conref="NativeWindow.closed.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
var isWindowClosed = window.nativeWindow.closed;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:displayState:get"><apiName>displayState</apiName><shortdesc>
     Der Anzeigestatus dieses Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff auf die <codeph>displayState</codeph>-Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Der Anzeigestatus dieses Fensters.
     <p>
     Konstanten für die möglichen Werte sind in der NativeWindowDisplayState-Klasse definiert: 
     </p>
     <ul>
     <li><codeph>NativeWindowDisplayState.NORMAL</codeph></li>
     <li><codeph>NativeWindowDisplayState.MINIMIZED</codeph></li>
     <li><codeph>NativeWindowDisplayState.MAXIMIZED</codeph></li>
     </ul> 
     
     </apiDesc><example conref="examples\NativeWindow.displayState.1.as"> Das folgende Beispiel zeigt, wie der aktuelle Anzeigestatus des Fensters mit einem Verweis auf das Fensterobjekt abgerufen werden kann:
<codeblock>
var state:String = windowObj.displayState;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:height:get"><apiName>height</apiName><shortdesc>
      Die Höhe dieses Fensters in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Wenn der eingestellte Wert <codeph>null</codeph> oder ungültig ist.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Die Höhe dieses Fensters in Pixel.
      
      <p>Die Abmessungen eines Fensters umfassen auch ggf. angezeigtes Systemfensterchrom. Die Höhe des nutzbaren Anzeigebereichs innerhalb eines Fensters ist über die <codeph>Stage.stageHeight</codeph>-Eigenschaft verfügbar.</p>
      
      <p>Das Ändern der <codeph>height</codeph>-Eigenschaft eines Fensters entspricht dem Ändern der Höhe über die <codeph>bounds</codeph>-Eigenschaft.</p>
      
      <p>Wenn die angegebene Höhe den erlaubten Mindest- oder Höchstwert unter- bzw überschreitet, wird die Fensterhöhe auf den nächsten zulässigen Wert gesetzt. Folgende Faktoren bestimmen die minimale und maximale Höhe:</p>
      
      <ul>
      
      	<li>Die <codeph>minSize.x</codeph>- und <codeph>maxSize.x</codeph>-Eigenschaft des NativeWindow-Objekts</li>
      	<li>Die Mindest- und Höchstgrenze des Betriebssystems, die den Werten von <codeph>NativeWindow.systemMinSize</codeph> und <codeph>NativeWindow.systemMaxSize</codeph> entspricht.</li>
      	<li>Die maximale Höhe eines Fensters in Adobe AIR, die 2.880 Pixel beträgt.</li>
      
      </ul>
      
      <p>Unter Linux ist das Setzen der <codeph>height</codeph>-Eigenschaft ein asynchroner Vorgang.</p>
     
      <p>
      Durch Warten auf das <codeph>resize</codeph>-Ereignis, das auf allen Plattformen ausgelöst wird, kann festgestellt werden, ob die Höhenänderung abgeschlossen wurde.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageHeight"><linktext>flash.display.Stage.stageHeight</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maxSize:get"><apiName>maxSize</apiName><shortdesc>
      Die maximale Größe dieses Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Wenn die zugewiesene Größe nicht den minimalen und maximalen Werten für die Fenstergröße des Betriebssystems entspricht. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn „size“ für die aktuellen Berechtigungen des Inhalts nicht zulässig ist.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Größe <codeph>null</codeph> ist oder ungültige Werte enthält.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die <codeph>maxSize</codeph>-Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Die maximale Größe dieses Fensters.  
      
      <p>Der Größengrenzwert wird über die Koordinaten eines Point-Objekts festgelegt. Die<codeph>x</codeph>-Eigenschaft des Punkts entspricht der Fensterbreite, und die <codeph>y</codeph>-Eigenschaft der Fensterhöhe.</p>
      
      <p>
      Die <codeph>maxSize</codeph>-Einschränkung wird für Änderungsvorgänge der Fenstergröße erzwungen, die über <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph>-Code und über das Betriebssystem aufgerufen werden.
      </p>
      <p>
      Beim Einstellen von <codeph>maxSize</codeph> werden die Fenstergrenzen geändert, wenn die aktuellen Begrenzungen größer als die neue Maximalgröße sind.
      </p>
      
      <p>Wenn die angegebene Breite bzw. Höhe den erlaubten Höchstwert überschreitet, wird der Wert oder auf den nächsten zulässigen Wert gesetzt. Folgende Faktoren bestimmen die maximale Breite bzw. Höhe:</p>
      
      <ul>
      
      	<li>Der maximal zulässige Wert des Betriebssystems, also der <codeph>NativeWindow.systemMaxSize</codeph>-Wert.</li>
      	<li>Die maximale Breite und Höhe eines Fensters in Adobe AIR, die je 2.880 Pixel beträgt.</li>
      
      </ul>
      
      <p>
      <b>Hinweis:</b> Unter manchen Betriebssystemen, beispielsweise Mac OS X, werden Fenster beim Vergrößern nur auf den <codeph>maxSize</codeph>-Wert maximiert, selbst wenn das maximierte Fenster kleiner ist als das Betriebssystemfenster. Das Fenster befindet sich dennoch im maximierten Anzeigestatus.
      </p>
      
      </apiDesc><example conref="NativeWindow.maxSize.1.as"> Das folgende Beispiel zeigt, wie die maximal zulässige Größe für ein Fenster festgelegt wird.
<codeblock>
windowObj.maxSize = new Point(1040,920);
</codeblock></example><example conref="NativeWindow.maxSize.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObject.stage.nativeWindow.maxSize = new Point(800,600);
</codeblock></example><example conref="NativeWindow.maxSize.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.nativeWindow.maxSize = new air.Point(960,960);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maximizable:get"><apiName>maximizable</apiName><shortdesc>
	 Gibt die maximizable-Einstellung an, mit der dieses Fenster erstellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Beim Versuch, die Eigenschaft ohne entsprechende Berechtigung auf <codeph>false</codeph> einzustellen.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gibt die <codeph>maximizable</codeph>-Einstellung an, mit der dieses Fenster erstellt wurde.
	  
	 <p>Die <codeph>maximizable</codeph>-Einstellung kann nach der Erstellung des Fensters nicht mehr geändert werden.</p>
	 
	 <p>Nicht alle Linux-Fenstermanager befolgen die <codeph>maximizable</codeph>-Einstellung.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/maximizable"><linktext>flash.display.NativeWindowInitOptions.maximizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:menu:get"><apiName>menu</apiName><shortdesc>
      Das native Menü für dieses Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
      Das native Menü für dieses Fenster. 
      
      <p>Wenn der <codeph>menu</codeph>-Eigenschaft des Fensters ein NativeMenu-Objekt zugewiesen ist, wird ein natives Menü für das Fenster angezeigt, wenn <codeph>NativeWindow.supportsMenu</codeph> auf <codeph>true</codeph> eingestellt ist, es sei denn, die <codeph>systemChrome</codeph>-Eigenschaft des Fensters lautet <codeph>NativeWindowSystemChrome.NONE</codeph>.</p>
      
      <p><b>Hinweis:</b> Wenn <codeph>NativeWindow.supportsMenu</codeph> auf <codeph>false</codeph> eingestellt ist oder wenn die <codeph>systemChrome</codeph>-Eigenschaft des Fensters <codeph>NativeWindowSystemChrome.NONE</codeph> lautet, darf einem Fenster zwar ein Menü zugewiesen werden, dies hat jedoch keine Wirkung. Sie sollten die <codeph>NativeWindow.supportsMenu</codeph>-Eigenschaft verwenden, um festzulegen, ob das Betriebssystem Fenstermenüs unterstützt. Die Verwendung anderer Vorgehensweisen (z. B. <codeph>Capabilities.os</codeph>) zur Festlegung der Unterstützung kann zu Programmierfehlern führen (beispielsweise dann, wenn mögliche Zielbetriebssysteme nicht berücksichtigt werden).</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minSize:get"><apiName>minSize</apiName><shortdesc>
      Die Mindestgröße dieses Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Wenn die zugewiesene Größe nicht innerhalb der minimalen und maximalen Betriebssystemwerte für die Fenstergröße liegt. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn „size“ für die aktuellen Berechtigungen des Inhalts nicht zulässig ist.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Größe <codeph>null</codeph> ist oder ungültige Werte enthält.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die <codeph>minSize</codeph>-Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Die Mindestgröße dieses Fensters. 
       
      <p>Der Größengrenzwert wird über die Koordinaten eines Point-Objekts festgelegt. Die<codeph>x</codeph>-Eigenschaft des Punkts entspricht der Fensterbreite, und die <codeph>y</codeph>-Eigenschaft der Fensterhöhe.</p>
      <p>
      Beim Einstellen von <codeph>minSize</codeph> werden die Fenstergrenzen geändert, wenn die aktuellen Begrenzungen kleiner als die neue Mindestgröße sind.
      </p>
      <p>
      Die <codeph>minSize</codeph>-Einschränkung wird für Änderungsvorgänge der Fenstergröße erzwungen, die über <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph>-Code und über das Betriebssystem aufgerufen werden.
      </p>
      <p>
      <b>Hinweis:</b> Die Breite und Höhe von ggf. angezeigtem Systemchrom können möglicherweise dazu führen, dass ein Fenster nicht auf die angegebene minimale Größe eingestellt werden kann. 
      </p>
      
      </apiDesc><example conref="NativeWindow.minSize.1.as"> Das folgende Beispiel zeigt, wie die minimal zulässige Größe für ein Fenster festgelegt wird:
<codeblock>
windowObj.minSize = new Point(200,80);
</codeblock></example><example conref="NativeWindow.minSize.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObject.stage.nativeWindow.minSize = new Point(120,60);
</codeblock></example><example conref="NativeWindow.minSize.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.nativeWindow.minSize = new air.Point(80,60);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minimizable:get"><apiName>minimizable</apiName><shortdesc>
	 Gibt die minimizable-Einstellung an, mit der dieses Fenster erstellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Beim Versuch, die Eigenschaft ohne entsprechende Berechtigung auf <codeph>false</codeph> einzustellen.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gibt die <codeph>minimizable</codeph>-Einstellung an, mit der dieses Fenster erstellt wurde.
	 
	 <p>Die <codeph>minimizable</codeph>-Einstellung kann nach der Erstellung des Fensters nicht mehr geändert werden.</p>
	 
	 <p>Nicht alle Linux-Fenstermanager befolgen die <codeph>minimizable</codeph>-Einstellung.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/minimizable"><linktext>flash.display.NativeWindowInitOptions.minimizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:resizable:get"><apiName>resizable</apiName><shortdesc>
	 Gibt die resizable-Einstellung an, mit der dieses Fenster erstellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Beim Versuch, die Eigenschaft ohne entsprechende Berechtigung auf <codeph>false</codeph> einzustellen.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gibt die <codeph>resizable</codeph>-Einstellung an, mit der dieses Fenster erstellt wurde.
	 
	 <p>Die <codeph>resizable</codeph>-Einstellung kann nach der Erstellung des Fensters nicht mehr geändert werden.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:stage:get"><apiName>stage</apiName><shortdesc>
      Das Stage-Objekt für dieses Fenster.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
      Das Stage-Objekt für dieses Fenster. <ph platform="actionscript">Das Stage-Objekt ist das Stammobjekt in der Anzeigelistenarchitektur, die in ActionScript 3.0-basiertem SWF-Inhalt verwendet wird.</ph>
      
      <p>
      Die Bühne bildet den Stamm der Anzeigeliste für das Fenster. Visuelle Anzeigeobjekte können einem Fenster hinzugefügt werden, indem sie der Bühne hinzugefügt werden oder einem anderen Objekt, das sich bereits in der Anzeigeliste dieser Bühne befindet. Die Bühnenabmessungen entsprechen denen des Fensterclientbereichs, wenn Systemchrom für das Fenster verwendet wird. Die Bühnenabmessungen sind mit denen des Fensters identisch, wenn kein Systemchrom verwendet wird.
      </p>
      
      <p platform="javascript">Das HTMLLoader-Objekt, das den HTML-Inhalt darstellt, bildet einen einzelnen Endknoten in der Struktur der Anzeigeliste. Mit ActionScript definierte Anzeigeobjekte können sich oberhalb und unterhalb des HTMLLoader-Objekts in der Darstellungsordnung befinden, nicht aber zwischen den visuellen Elementen, die vom HTMLLoader-Objekt dargestellt werden.</p>
      
      </apiDesc><example conref="NativeWindow.stage.1.as"> Das folgende Beispiel zeigt, wie Bühneneigenschaften für eine NativeWindow-Instanz festgelegt werden:
<codeblock>
import flash.display.StageAlign;

windowObj.stage.align = StageAlign.TOP_LEFT;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage"><linktext>flash.display.Stage</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
      Gibt an, ob AIR native Fenstermenüs auf dem aktuellen Computersystem unterstützt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Gibt an, ob AIR native Fenstermenüs auf dem aktuellen Computersystem unterstützt.
      
      <p>Wenn <codeph>NativeWindow.supportsMenu</codeph> auf <codeph>true</codeph> eingestellt ist, wird ein natives Menü für ein Fenster angezeigt, wenn der <codeph>menu</codeph>-Eigenschaft des Fensters ein NativeMenu-Objekt zugewiesen ist, es sei denn, die <codeph>systemChrome</codeph>-Eigenschaft des Fensters ist auf <codeph>NativeWindowSystemChrome.NONE</codeph> eingestellt). Sie sollten die <codeph>NativeWindow.supportsMenu</codeph>-Eigenschaft verwenden, um festzulegen, ob das Betriebssystem native Fenstermenüs unterstützt. Die Verwendung anderer Vorgehensweisen (z. B. <codeph>Capabilities.os</codeph>) zur Festlegung der Unterstützung kann zu Programmierfehlern führen (beispielsweise dann, wenn mögliche Zielbetriebssysteme nicht berücksichtigt werden).</p>
      
      <p><b>Hinweis:</b> Wenn <codeph>NativeWindow.supportsMenu</codeph> auf <codeph>false</codeph> eingestellt ist oder wenn die <codeph>systemChrome</codeph>-Eigenschaft des Fensters <codeph>NativeWindowSystemChrome.NONE</codeph> lautet, darf einem Fenster zwar ein Menü zugewiesen werden, dies hat jedoch keine Wirkung.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsMenu"><linktext>flash.desktop.NativeApplication.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsNotification:get"><apiName>supportsNotification</apiName><shortdesc> 
      Gibt an, ob AIR Fensterbenachrichtigungshinweise auf dem aktuellen Computersystem unterstützt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Gibt an, ob AIR Fensterbenachrichtigungshinweise auf dem aktuellen Computersystem unterstützt.
      
      <p>Wenn <codeph>NativeWindow.supportsNotification</codeph> auf <codeph>true</codeph> eingestellt ist, bewirkt ein Aufruf der <codeph>notifyUser()</codeph>-Methode des Fensters, dass der Benutzer in einem visuellen Hinweis auf ein wichtiges Ereignis aufmerksam gemacht wird. Der visuelle Hinweis entspricht den Konventionen des nativen Betriebssystems. So blinkt unter Windows<sup>®</sup> beispielsweise das Taskleistensymbol auf.</p>
      
      <p><b>Hinweis:</b> <codeph>notifyUser()</codeph> kann zwar aufgerufen werden, wenn <codeph>NativeWindow.supportsNotification</codeph> auf <codeph>false</codeph> eingestellt ist, hat in diesem Fall jedoch keine Wirkung.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsTransparency:get"><apiName>supportsTransparency</apiName><shortdesc> 
      Gibt an, ob AIR native Fenster mit transparenten Pixeln unterstützt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Gibt an, ob AIR native Fenster mit transparenten Pixeln unterstützt.
      
      <p>Wenn <codeph>NativeWindow.supportsTransparency</codeph> auf <codeph>true</codeph> gesetzt ist, wird Pixeltransparenz befolgt, sofern die <codeph>transparent</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt ist. Die Deckkraft aller Pixel wird auf 1 gesetzt, wenn <codeph>NativeWindow.supportsTransparency</codeph> auf <codeph>false</codeph> gesetzt ist, unabhängig vom Wert der <codeph>transparent</codeph>-Eigenschaft des Fensters. Voll transparente Pixel werden schwarz dargestellt, wenn <codeph>NativeWindow.supportsTransparency</codeph> auf <codeph>false</codeph> gesetzt ist. Sie sollten die <codeph>NativeWindow.supportsTransparency</codeph>-Eigenschaft verwenden, um festzulegen, ob das Betriebssystem Transparenz unterstützt. Die Verwendung anderer Vorgehensweisen (z. B. <codeph>Capabilities.os</codeph>) zur Festlegung der Unterstützung kann zu Programmierfehlern führen (beispielsweise dann, wenn mögliche Zielbetriebssysteme nicht berücksichtigt werden).</p>
      
      <p><b>Hinweis:</b> Der Wert dieser Eigenschaft kann sich aufgrund von Benutzereinstellungen für das Betriebssystem ändern, während die Anwendung ausgeführt wird.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/transparent"><linktext>flash.display.NativeWindow.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
	 Gibt die Systemchromeinstellung an, mit der dieses Fenster erstellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Beim Versuch, die Eigenschaft ohne entsprechende Berechtigung auf <codeph>false</codeph> einzustellen.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gibt die Systemchromeinstellung an, mit der dieses Fenster erstellt wurde.
	 
	 <p>Bei den von <codeph>NativeWindow.systemChrome</codeph> zurückgegebenen Werten handelt es sich um eine der Konstanten, die in der NativeWindowSystemChrome-Klasse definiert sind.</p>
	 
	 <p>Die Systemchromeinstellung kann nach der Erstellung des Fensters nicht mehr geändert werden.</p>
	 
	 </apiDesc><example conref="NativeWindow.systemChrome.1.as"> Im folgenden Beispiel wird gezeigt, wie Sie den Systemchromtyp für ein Fenster erhalten:
<codeblock>
var sysChromeType:String = windowObj.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
var sysChromeType:String = displayObject.stage.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
var sysChromeType = window.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.4.as"> Das folgende Beispiel zeigt, wie Sie die angezeigten Systemchrom- und Transparenzeinstellungen ändern, indem Sie ein neues Fenster erstellen und alle untergeordneten Anzeigeobjekte in das neue Fenster verschieben:
<codeblock>
import flash.display.NativeWindow;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowInitOptions;

public function deChromeWindow(oldWindow:NativeWindow):NativeWindow{
    if(oldWindow.systemChrome != NativeWindowSystemChrome.NONE){
        var newOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
        newOptions.systemChrome = NativeWindowSystemChrome.NONE;
        newOptions.transparent = true;
        
        var newWindow:NativeWindow = new NativeWindow(newOptions);
        newWindow.stage.stageWidth = oldWindow.stage.stageWidth;
        newWindow.stage.stageHeight = oldWindow.stage.stageHeight;
        newWindow.stage.align = oldWindow.stage.align;
        newWindow.stage.scaleMode = oldWindow.stage.scaleMode;
        
        for(var i:int = 0; i &lt; oldWindow.stage.numChildren; i++){
            newWindow.stage.addChild(oldWindow.stage.getChildAt(i));
        }
        newWindow.activate();
        oldWindow.close();
        
        return newWindow;
    }
    return oldWindow;
}

</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/systemChrome"><linktext>flash.display.NativeWindowInitOptions.systemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemMaxSize:get"><apiName>systemMaxSize</apiName><shortdesc>
	 Die größte Fenstergröße, die unter dem Betriebssystem zulässig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 Die größte Fenstergröße, die unter dem Betriebssystem zulässig ist.
	 
      <p>Der Größengrenzwert wird über die Koordinaten eines Point-Objekts festgelegt. Die<codeph>x</codeph>-Eigenschaft des Punkts entspricht der Fensterbreite, und die <codeph>y</codeph>-Eigenschaft der Fensterhöhe.</p>
      
      <p>Zusätzlich zu den Größenbeschränkungen des Betriebssystems beschränkt AIR die maximale Fenstergröße auf 2.880 x 2.880 Pixel. Des Weiteren kann eine Anwendung mithilfe der <codeph>maxSize</codeph>-Eigenschaft des NativeWindow-Objekts einen Grenzwert setzen.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:systemMinSize:get"><apiName>systemMinSize</apiName><shortdesc>
	 Die kleinste Fenstergröße, die unter dem Betriebssystem zulässig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 Die kleinste Fenstergröße, die unter dem Betriebssystem zulässig ist.
	 
      <p>Der Größengrenzwert wird über die Koordinaten eines Point-Objekts festgelegt. Die<codeph>x</codeph>-Eigenschaft des Punkts entspricht der Fensterbreite, und die <codeph>y</codeph>-Eigenschaft der Fensterhöhe.</p>
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:title:set"><apiName>title</apiName><shortdesc>
      Der Fenstertitel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Low-privilege apps will probably have a string appended to all of their title strings
      
      </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Der Fenstertitel.  
      <p>
      Der Titel wird im Systemchrom des Fensters eingeblendet, sofern angezeigt, sowie in anderen systemabhängigen Orten (beispielsweise in der Taskleiste).
      </p>
      
      </apiDesc><example conref="NativeWindow.title.1.as"> Das folgende Beispiel zeigt, wie der Titel eines Fensterobjekts eingestellt wird:
<codeblock>
windowObj.title = "Window Title";
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Gibt die Transparenzeinstellung an, mit der dieses Fenster erstellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Beim Versuch, die Eigenschaft ohne entsprechende Berechtigung auf <codeph>false</codeph> einzustellen.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gibt die Transparenzeinstellung an, mit der dieses Fenster erstellt wurde.
	 
     <p>Die <codeph>transparent</codeph>-Eigenschaft kann nach der Erstellung des Fensters nicht mehr geändert werden. Die Transparenz wirkt sich sowohl auf die visuelle Darstellung als auch auf das Mausverhalten des Fensters aus. Unter Windows und Max OS X kann ein Fenster Mausereignisse nicht wahrnehmen, wenn der Alphawert der Pixel unter einer bestimmten Grenze liegt. Diese Grenze liegt je nach Betriebssystem ungefähr zwischen ,06 und ,01. Unter Linux nimmt das Fenster Mausereignisse oberhalb volltransparenter Bereiche wahr und hindert Benutzer dadurch daran, auf andere Fenster und Elemente auf dem Desktop zuzugreifen.</p>
     
     <p><b>Hinweis:</b> Die Fenstertransparenz kann nicht in allen Fällen unterstützt werden. Ist aufgrund der Betriebssystemkonfiguration des Benutzers die Transparenz nicht verfügbar, so wird das Fenster ohne Transparenz erstellt. Bereiche, die transparent hätten sein sollen, werden mit Schwarz zusammengesetzt. Verwenden Sie die <codeph>NativeWindow.supportsTransparency</codeph>-Eigenschaft um festzulegen, ob die Fenstertransparenz unterstützt wird.</p>
	 
	 </apiDesc><example conref="NativeWindow.transparent.1.as"/><example conref="NativeWindow.transparent.2.as"/><example conref="NativeWindow.transparent.3.as"/></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/transparent"><linktext>flash.display.NativeWindowInitOptions.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:type:get"><apiName>type</apiName><shortdesc>
	 Gibt die Fenstertypeinstellung an, mit der dieses Fenster erstellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Beim Versuch, die Eigenschaft ohne entsprechende Berechtigung auf <codeph>false</codeph> einzustellen.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gibt die <codeph>type</codeph>-Einstellung an, mit der dieses Fenster erstellt wurde.
	 
	 <p>Bei den von <codeph>NativeWindow.type</codeph> zurückgegebenen Werten handelt es sich um eine der Konstanten, die in der NativeWindowType-Klasse definiert sind.</p>
	 
	 <p>Die <codeph>type</codeph>-Einstellung kann nach der Erstellung des Fensters nicht mehr geändert werden.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/type"><linktext>flash.display.NativeWindowInitOptions.type</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:visible:get"><apiName>visible</apiName><shortdesc> 
      Gibt an, ob dieses Fenster sichtbar ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Beim Versuch, die Eigenschaft ohne entsprechende Berechtigung auf <codeph>false</codeph> einzustellen.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
      Gibt an, ob dieses Fenster sichtbar ist.  
      
      <p>
      Ein unsichtbares Fenster wird nicht auf dem Desktop angezeigt, aber alle Eigenschaften und Methoden des Fensters sind gültig.
      </p> 
      <p>
      Standardmäßig ist <codeph>visible</codeph> auf <codeph>false</codeph> eingestellt. Um ein Fenster anzuzeigen, stellen Sie <codeph>visible</codeph> auf <codeph>true</codeph> ein oder rufen Sie <codeph>NativeWindow.activate()</codeph> auf.
      </p>
      <p>
      <b>Hinweis:</b> Unter Mac OS X hat die Einstellung <codeph>visible=false</codeph> für ein minimiertes Fenster nicht zur Folge, dass das Fenstersymbol aus dem Dock entfernt wird. Wenn der Benutzer anschließend auf das Symbol im Dock klickt, kehrt das Fenster zum visible-Status zurück und wird auf dem Desktop angezeigt.
      </p>
      
      </apiDesc><example conref="NativeWindow.visible.1.as"> In den folgenden Beispielen wird gezeigt, wie auf die <codeph>visible</codeph>-Eigenschaft eines Fensters zugegriffen wird:
<codeblock>
windowObj.visible = true;
</codeblock></example><example conref="NativeWindow.visible.2.as"> Mit einem Verweis auf ein Anzeigeobjekt auf der Fensterbühne:
<codeblock>
displayObj.stage.nativeWindow.visible = true;
</codeblock></example><example conref="NativeWindow.visible.3.as"> Mit einer JavaScript-Routine, die in einem HTMLLoader-Objekt im Fenster (oder HTML-Stammfenster) ausgeführt wird:
<codeblock>
window.nativeWindow.visible = true;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate()"><linktext>activate()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:width:get"><apiName>width</apiName><shortdesc>
      Die Breite dieses Fensters in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Wenn der eingestellte Wert <codeph>null</codeph> oder ungültig ist.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Die Breite dieses Fensters in Pixel.
      
      <p>Die für ein natives Fenster protokollierten Abmessungen umfassen alle angezeigten Systemfensterchrome. Die Breite des nutzbaren Anzeigebereichs innerhalb eines Fensters ist über die <codeph>Stage.stageWidth</codeph>-Eigenschaft verfügbar.</p>
      
      <p>Das Ändern der <codeph>width</codeph>-Eigenschaft eines Fensters entspricht dem Ändern der Breite über die <codeph>bounds</codeph>-Eigenschaft.</p>
      
      <p>Wenn die angegebene Breite den erlaubten Mindest- oder Höchstwert unter- bzw überschreitet, wird die Fensterbreite auf den nächsten zulässigen Wert gesetzt. Folgende Faktoren bestimmen die minimale und maximale Breite:</p>
      
      <ul>
      
      	<li>Die <codeph>minSize.y</codeph>- und <codeph>maxSize.y</codeph>-Eigenschaft des NativeWindow-Objekts</li>
      	<li>Die Mindest- und Höchstgrenze des Betriebssystems, die den Werten von <codeph>NativeWindow.systemMinSize.y</codeph> und <codeph>NativeWindow.systemMaxSize.y</codeph> entspricht.</li>
      	<li>Die maximale Höhe eines Fensters in Adobe AIR, die 2.880 Pixel beträgt.</li>
      
      </ul>
      
      <p>Unter Linux ist das Setzen der <codeph>width</codeph>-Eigenschaft ein asynchroner Vorgang.</p>
      
      <p>
      Durch Warten auf das <codeph>resize</codeph>-Ereignis, das auf allen Plattformen ausgelöst wird, kann festgestellt werden, ob die Höhenänderung abgeschlossen wurde.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageWidth"><linktext>flash.display.Stage.stageWidth</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:x:get"><apiName>x</apiName><shortdesc>
      Die horizontale Achsenkoordinate der linken oberen Ecke dieses Fensters relativ zur linken oberen Ecke des Betriebssystemdesktops.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Wenn der eingestellte Wert <codeph>null</codeph> oder ungültig ist.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Die horizontale Achsenkoordinate der linken oberen Ecke dieses Fensters relativ zur linken oberen Ecke des Betriebssystemdesktops.
      
      <p>Auf Systemen mit mehreren Monitoren kann <codeph>x</codeph> negativ sein. Wenn Sie den Wert speichern, etwa um ein Fenster wieder an seiner vorherigen Position zu platzieren, sollten Sie sicherstellen, dass die wiederhergestellte Position brauchbar ist. Änderungen der Bildschirmauflösung oder Monitoranordnung können dazu führen, dass ein Fenster außerhalb des Bildschirms platziert wird. Verwenden Sie die Screen-Klasse, um Informationen über die Desktopgeometrie zu erhalten.</p> 
      
      <p>Das Ändern der <codeph>x</codeph>-Eigenschaft eines Fensters entspricht dem Ändern der Position über die <codeph>bounds</codeph>-Eigenschaft.</p>
      
      <p>Unter Linux ist das Setzen der <codeph>x</codeph>-Eigenschaft ein asynchroner Vorgang.</p>
      
      <p>
      Durch Warten auf das <codeph>move</codeph>-Ereignis, das auf allen Plattformen ausgelöst wird, kann die Fertigstellung der Positionsänderung entdeckt werden.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:y:get"><apiName>y</apiName><shortdesc>
      Die vertikale Achsenkoordinate der oberen linken Ecke dieses Fensters relativ zur oberen linken Ecke des Betriebssystem-Desktops.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Wenn der eingestellte Wert <codeph>null</codeph> oder ungültig ist.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn der Zugriff auf die Eigenschaft erfolgt, nachdem dieses Fenster bereits geschlossen wurde.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Die vertikale Achsenkoordinate der oberen linken Ecke dieses Fensters relativ zur oberen linken Ecke des Betriebssystem-Desktops.
      
      <p>Auf Systemen mit mehreren Monitoren kann <codeph>y</codeph> negativ sein. Wenn Sie den Wert speichern, etwa um ein Fenster wieder an seiner vorherigen Position zu platzieren, sollten Sie sicherstellen, dass die wiederhergestellte Position brauchbar ist. Änderungen der Bildschirmauflösung oder Monitoranordnung können dazu führen, dass ein Fenster außerhalb des Bildschirms platziert wird. Verwenden Sie die Screen-Klasse, um Informationen über die Desktopgeometrie zu erhalten.</p> 
      
      <p>Das Ändern der <codeph>y</codeph>-Eigenschaft eines Fensters entspricht dem Ändern der Position über die <codeph>bounds</codeph>-Eigenschaft.</p>
      
      <p>Unter Linux ist das Setzen der <codeph>y</codeph>-Eigenschaft ein asynchroner Vorgang.</p>
       
      <p>
      Durch Warten auf das <codeph>move</codeph>-Ereignis, das auf allen Plattformen ausgelöst wird, kann die Fertigstellung der Positionsänderung entdeckt werden.
      </p>
     
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Stage"><apiName>Stage</apiName><shortdesc>
 Die Stage-Klasse repräsentiert den Hauptzeichenbereich.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Stage-Klasse repräsentiert den Hauptzeichenbereich. 
 
 <p platform="actionscript">Für SWF-Inhalt, der im Browser angezeigt wird (in Flash<sup>®</sup> Player), repräsentiert die Bühne den gesamten Bereich, in dem der Inhalt angezeigt wird. Für Inhalt, der in AIR ausgeführt wird, hat jedes NativeWindow-Objekt ein zugehöriges Stage-Objekt.</p>
 
 <p platform="actionscript">Das Stage-Objekt ist nicht global zugänglich. Sie müssen über die <codeph>stage</codeph>-Eigenschaft einer DisplayObject-Instanz darauf zugreifen.</p> 
 
 <p platform="actionscript">Die Stage-Klasse besitzt mehrere übergeordneten Klassen (DisplayObjectContainer, InteractiveObject, DisplayObject und EventDispatcher), von denen sie Eigenschaften und Methoden übernimmt. Viele dieser Eigenschaften und Methoden lassen sich entweder gar nicht auf Stage-Objekte anwenden oder erfordern eine Sicherheitsüberprüfung, wenn sie für ein Stage-Objekt aufgerufen werden. Die Eigenschaften und Methoden, die eine Sicherheitsüberprüfung benötigen, sind als Teil der Stage-Klasse dokumentiert.</p>
 
 <p platform="actionscript">Darüber hinaus sind die folgenden geerbten Eigenschaften auf Stage-Objekte nicht anwendbar. Wenn Sie versuchen, diese Eigenschaften zu setzen, wird ein Fehler vom Typ „IllegalOperationError“ ausgelöst. Diese Eigenschaften werden zwar immer gelesen, doch da sie nicht gesetzt werden können, enthalten sie stets die Standardwerte.</p>
 
 <ul platform="actionscript">
 <li><codeph>accessibilityProperties</codeph></li>
 <li><codeph>alpha</codeph></li>
 <li><codeph>blendMode</codeph></li>
 <li><codeph>cacheAsBitmap</codeph></li>
 <li><codeph>contextMenu</codeph></li>
 <li><codeph>filters</codeph></li>
 <li><codeph>focusRect</codeph></li>
 <li><codeph>loaderInfo</codeph></li>
 <li><codeph>mask</codeph></li>
 <li><codeph>mouseEnabled</codeph></li>
 <li><codeph>name</codeph></li>
 <li><codeph>opaqueBackground</codeph></li>
 <li><codeph>rotation</codeph></li>
 <li><codeph>scale9Grid</codeph></li>
 <li><codeph>scaleX</codeph></li>
 <li><codeph>scaleY</codeph></li>
 <li><codeph>scrollRect</codeph></li>
 <li><codeph>tabEnabled</codeph></li>
 <li><codeph>tabIndex</codeph></li>
 <li><codeph>transform</codeph></li>
 <li><codeph>visible</codeph></li>
 <li><codeph>x</codeph></li>
 <li><codeph>y</codeph></li>
 </ul>
 
 <p>Manche Ereignisse, von denen Sie erwarten würden, dass Sie zur Stage-Klasse gehören, z. B. <codeph>enterFrame</codeph>, <codeph>exitFrame</codeph>, <codeph>frameConstructed</codeph> und <codeph>render</codeph>, können keine Stage-Ereignisse sein, da in den Situationen, in denen sie verwendet werden, keine Verweis auf das Stage-Objekt garantiert werden kann. Da diese Ereignisse nicht vom Stage-Objekt ausgelöst werden können, werden sie stattdessen von jeder DisplayObject-Instanz ausgelöst. Das bedeutet, dass Sie jeder beliebigen DisplayObjekt-Instanz einen Ereignis-Listener hinzufügen können, der auf die Ereignisse wartet. Diese Ereignisse, die zur DisplayObject-Klasse gehören, werden broadcast-Ereignisse genannt, um sie von Ereignissen zu unterscheiden, die bei einer spezifischen DisplayObject-Instanz vorkommen. Zwei andere broadcast-Ereignisse, <codeph>activate</codeph> und <codeph>deactivate</codeph>, gehören zu EventDispatcher, der Superklasse von DisplayObject. Die <codeph>activate</codeph>- und <codeph>deactivate</codeph>-Ereignisse verhalten sich ähnlich wie die broadcast-Ereignisse von DisplayObject, mit der Ausnahme, dass sie nicht nur von allen DisplayObject-Instanzen ausgelöst werden sondern auch von allen EventDispatcher-Instanzen und den Instanzen anderer Unterklassen von EventDispatcher. Weitere Informationen zu broadcast-Ereignissen finden Sie im Abschnitt zur DisplayObject-Klasse.</p>
 
 </apiDesc><example conref="examples\StageExample.as"> Im folgenden Beispiel wird die Klasse <codeph>StageExample</codeph> verwendet, um Ereignisse auszulösen, wenn die Bühne aktiviert oder wenn deren Größe geändert wird. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Der Klassenkonstruktor richtet zuerst die Flash-Anwendung ein, die unabhängig von der Größe des Flash Player-Fensters fixiert werden soll, und fügt unter Verwendung der Methoden <codeph>activateHandler()</codeph> und <codeph>resizeHandler()</codeph> dann zwei Ereignis-Listener hinzu.</li>
 
  <li>Die <codeph>activateHandler()</codeph>-Methode wird ausgeführt, sobald die linke Maustaste gedrückt wird.</li>
 
  <li>Die <codeph>resizeHandler()</codeph>-Methode wird ausgeführt, wenn die Größe der Bühne geändert wird.</li>
 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.Event;

    public class StageExample extends Sprite {

        public function StageExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.addEventListener(Event.ACTIVATE, activateHandler);
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function activateHandler(event:Event):void {
            trace("activateHandler: " + event);
        }

        private function resizeHandler(event:Event):void {
            trace("resizeHandler: " + event);
            trace("stageWidth: " + stage.stageWidth + " stageHeight: " + stage.stageHeight);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><adobeApiEvent id="flash.display:Stage_flash.events.FullScreenEvent.FULL_SCREEN_fullScreen"><apiName>fullScreen</apiName><shortdesc>
 Wird ausgelöst, wenn der Vollbildmodus für das Stage-Objekt aktiviert oder deaktiviert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FullScreenEvent.FULL_SCREEN</apiEventType><adobeApiEventClassifier>flash.events.FullScreenEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Vollbildmodus für das Stage-Objekt aktiviert oder deaktiviert wird. Ein Änderung des Vollbildmodus kann initiiert werden, indem ActionScript verwendet wird, indem Benutzer einen Tastaturbefehl drücken oder indem das Vollbildfenster den Fokus abgibt.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Wird ausgelöst, wenn die scaleMode-Eigenschaft des Stage-Objekts auf „StageScaleMode.NO_SCALE“ gesetzt und die Größe der SWF-Datei verändert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn die <codeph>scaleMode</codeph>-Eigenschaft des Stage-Objekts auf <codeph>StageScaleMode.NO_SCALE</codeph> gesetzt und die Größe der SWF-Datei verändert wird. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.MOUSE_LEAVE_mouseLeave"><apiName>mouseLeave</apiName><shortdesc>
 Wird vom Stage-Objekt ausgelöst, wenn der Mauszeiger aus dem Bühnenbereich verschoben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.MOUSE_LEAVE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird vom Stage-Objekt ausgelöst, wenn der Mauszeiger aus dem Bühnenbereich verschoben wird. Wenn die Maustaste gedrückt wird, wird das Ereignis nicht abgesetzt.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:Stage:addChild"><apiName>addChild</apiName><shortdesc>
	 
     Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufrufen der <codeph>addChild()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die DisplayObject-Instanz, die Sie im Parameter <codeph>child</codeph> übergeben.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die DisplayObject-Instanz, die der DisplayObjectContainer-Instanz untergeordnet werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
     Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. Die untergeordnete Instanz wird allen anderen untergeordneten Objekten dieser DisplayObjectContainer-Instanz an der ersten Position (also oben) hinzugefügt. (Um ein untergeordnetes Objekt an einer bestimmten Indexposition hinzuzufügen, verwenden Sie die <codeph>addChildAt()</codeph>-Methode.)
     
	 <p>Wenn Sie ein Child-Objekt hinzufügen, das bereits einem anderen Anzeigeobjektcontainer untergeordnet worden ist, wird es aus dessen Child-Liste entfernt. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 
	 Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufrufen der <codeph>addChildAt()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die DisplayObject-Instanz, die Sie im Parameter <codeph>child</codeph> übergeben.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die DisplayObject-Instanz, die der DisplayObjectContainer-Instanz untergeordnet werden soll.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Indexposition, an der die untergeordnete Instanz hinzugefügt wird. Wenn Sie eine gerade besetzte Indexposition angeben, werden das untergeordnete Objekt an dieser Stelle sowie alle darüber liegenden Positionen innerhalb der Child-Liste um eine Position nach oben verschoben. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Fügt dieser DisplayObjectContainer-Instanz eine untergeordnete DisplayObject-Instanz hinzu. Das untergeordnete Objekt wird an der angegebenen Indexposition eingefügt. Die Indexposition 0 bezeichnet das hintere (untere) Ende der Anzeigeliste für dieses DisplayObjectContainer-Objekt.
	 
	 <p>Das folgende Beispiel enthält z. B. drei Anzeigeobjekte mit der Bezeichnung a, b und c jeweils an den Indexpositionen 0, 1 und 2:</p>
	 
	 <p><adobeimage alt="b über c über a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>Wenn Sie ein Child-Objekt hinzufügen, das bereits einem anderen Anzeigeobjektcontainer untergeordnet worden ist, wird es aus dessen Child-Liste entfernt. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	 
	Registriert ein Ereignis-Listener-Objekt bei einem EventDispatcher-Objekt, sodass der Listener über ein Ereignis benachrichtigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufrufen der <codeph>addEventListener</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Typ des Ereignisses.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Listener-Funktion, die das Ereignis verarbeitet. Diese Funktion muss, wie das nachfolgende Beispiel zeigt, ein Ereignisobjekt als einzigen Parameter akzeptieren und keinen<ph platform="actionscript"> Wert zurückgeben: </ph> <ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Der Name der Funktion ist beliebig.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Dieser Parameter gilt für Anzeigeobjekte in der ActionScript 3.0-Anzeigelistenarchitektur, die von SWF-Material verwendet wird.</ph> <ph platform="actionscript">Legt fest, ob der Listener in der Aufnahmephase oder in der Ziel- und Bubbling-Phase arbeitet. Ist <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt, so verarbeitet der Listener das Ereignis nur während der Aufnahmephase und nicht während der Ziel- oder Bubbling-Phase. Hat <codeph>useCapture</codeph> hingegen den Wert <codeph>false</codeph>, verarbeitet der Listener das Ereignis nur während der Ziel- oder Bubbing-Phase. Um auf das Ereignis in allen drei Phasen zu warten, rufen Sie <codeph>addEventListener()</codeph> zweimal auf; einmal ist <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt, und beim zweiten Mal hat <codeph>useCapture</codeph> den Wert <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Prioritätsstufe des Ereignis-Listeners. Die Priorität wird durch eine vorzeichenbehaftete 32-Bit-Ganzzahl zugewiesen. Je höher die Zahl, desto höher die Priorität. Alle Listener mit der Priorität <i>n</i> werden vor Listenern mit der Priorität <i>n</i> -1 verarbeitet. Wenn zwei oder mehr Listener die gleiche Priorität aufweisen, werden sie in der Reihenfolge verarbeitet, in der sie hinzugefügt wurden. Die Standardpriorität ist 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Legt fest, ob der Verweis auf den Listener stark oder schwach ist. Ein starker Verweis (der Standard) verhindert, dass der Listener von einem Garbage Collector entfernt wird. Ein schwacher Verweis hingegen nicht. <p>Funktionen von Mitgliedern auf Klassenebene werden nicht vom Garbagekollektor entfernt. Daher können Sie <codeph>useWeakReference</codeph> für Mitgliedsfunktionen auf Klassenebene auf <codeph>true</codeph> setzen, ohne dass sie vom Garbagekollektor entfernt werden. Wenn Sie <codeph>useWeakReference</codeph> auf <codeph>true</codeph> setzen bei einem Listener, der eine verschachtelte innere Funktion ist, wird die Funktion vom Garbagekollektor entfernt. Indem Sie Verweise auf die innere Funktion erstellen (d. h sie in einer anderen Variable speichern), umgehen Sie die Garbage Collection, sodass die Funktion permanent gespeichert bleibt.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Registriert ein Ereignis-Listener-Objekt bei einem EventDispatcher-Objekt, sodass der Listener über ein Ereignis benachrichtigt wird. <ph platform="actionscript">Sie können Ereignis-Listener bei allen Knoten in der Anzeigeliste für eine bestimmte Art von Ereignis, Phase oder Priorität registrieren.</ph>
	
	<p platform="javascript">JavaScript-Code in der AIR-Laufzeitumgebung verwendet diese Methode, um Ereignis-Listener für Ereignisse, die von den AIR-APIs definiert werden, zu registrieren. Bei anderen JavaScript-Ereignissen (wie z. B. dem <codeph>onload</codeph>-Ereignis des DOM-<codeph>body</codeph>-Objekts) können Sie Standardtechniken für Ereignisprozeduren verwenden, wie bei Inhalten, die im Browser ausgeführt werden.</p>
	
	<p>Nachdem Sie einen Ereignis-Listener erfolgreich registriert haben, können Sie seine Priorität nicht durch weitere Aufrufe von <codeph>addEventListener()</codeph> ändern. Um die Priorität eines Listeners zu ändern, müssen Sie zunächst <codeph>removeListener()</codeph> aufrufen. Anschließend können Sie den Listener mit der neuen Prioritätsstufe erneut aufrufen. </p>
	
	<p>Nach der Registrierung des Listeners haben nachfolgende Aufrufe von <codeph>addEventListener()</codeph> mit einem anderen <codeph>type</codeph>- oder <codeph>useCapture</codeph>-Wert eine separate Listener-Registrierung zur Folge. <ph platform="actionscript">Wenn Sie beispielsweise zuerst einen Listener registrieren, für den <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt ist, wird dieser nur während der Aufnahmephase aktiv sein. Wenn Sie <codeph>addEventListener()</codeph> für dasselbe Listener-Objekt erneut aufrufen, diesmal aber <codeph>useCapture</codeph> auf <codeph>false</codeph> gesetzt ist, werden zwei separate Listener angelegt: einer, der während der Aufnahmephase aktiv ist und ein zweiter, der während der Ziel- und Bubbling-Phase aktiv ist.</ph>
	</p>
	
	<p platform="actionscript">Sie können einen Ereignis-Listener nicht nur für die Ziel- oder Bubbling-Phase registrieren. Die beiden Phasen hängen während der Registrierung immer zusammen, da Bubbling nur für übergeordnete Elemente des Zielknotens gilt.</p>
	
	<p>Wenn Sie einen Ereignis-Listener nicht mehr brauchen, entfernen sie ihn, indem Sie <codeph>removeEventListener()</codeph> aufrufen. Andernfalls könnte es zu Speicherproblemen kommen. Ereignis-Listener werden nicht automatisch aus dem Speicher entfernt, da der Garbage Collector den Listener nicht entfernt, solange das auslösende Objekt vorhanden ist (sofern der <codeph>useWeakReference</codeph>-Parameter auf <codeph>true</codeph> gesetzt ist).</p>
		
	<p>Beim Kopieren einer EventDispatcher-Instanz werden zugewiesene Ereignis-Listener nicht kopiert. (Wenn ein neu angelegter Knoten einen Ereignis-Listener benötigt, müssen Sie den Listener nach dem Erstellen des Knotens zuweisen.) Wenn Sie jedoch eine EventDispatcher-Instanz verschieben, werden zugewiesene Ereignis-Listener ebenfalls verschoben.</p>
	
	
	<p platform="actionscript">Wenn der Ereignis-Listener bei einem Knoten registriert wird, während mit diesem Knoten ein Ereignis durchgeführt wird, so wird der Ereignis-Listener während der aktuellen Phase nicht ausgelöst, kann aber während einer späteren Phase im Ereignisablauf ausgelöst werden, etwa während der Bubbling-Phase.</p>
	
	<p platform="actionscript">Wird ein Ereignis-Listener von einem Knoten entfernt, während mit dem Knoten ein Ereignis durchgeführt wird, so wird er von den aktuellen Aktionen immer noch ausgelöst. Nachdem er entfernt worden ist, wird der Ereignis-Listener nicht wieder aufgerufen (es sei denn er wird für spätere Verarbeitungsvorgänge erneut aufgerufen). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:assignFocus"><apiName>assignFocus</apiName><shortdesc>
	 Stellt den Tastaturfokus auf das interaktive Objekt ein, das vom objectToFocus-Parameter angegeben wird. Dabei wird die Richtung des Fokus vom direction-Parameter bestimmt. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Fokus nicht auf das Ziel eingestellt werden kann oder wenn die Richtung keinen gültigen Typ aufweist.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>objectToFocus</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>Das Objekt, das den Fokus erhalten soll, oder <codeph>null</codeph>, um den Fokus von einem beliebigen Element auf der Bühne zu entfernen.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>direction</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Richtung, aus der das <codeph>objectToFocus</codeph>-Objekt den Fokus erhält. Gültige Werte werden als Konstanten in der FocusDirection-Klasse aufgelistet.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Weist einem interaktiven Objekt den Tastaturfokus zu und gibt die Richtung an, aus der das Objekt den Fokus erhält.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Stellt den Tastaturfokus auf das interaktive Objekt ein, das vom <codeph>objectToFocus</codeph>-Parameter angegeben wird. Dabei wird die Richtung des Fokus vom <codeph>direction</codeph>-Parameter bestimmt. 
	 
	 <p>Das Konzept der Fokusrichtung muss von der Anwendung (oder vom Anwendungsframework) definiert werden. Es existiert keine inhärente Funktionalität zum Sortieren des Fokus von interaktiven Objekten, Sie können jedoch über andere verfügbare Eigenschaften ein Anordnungsprinzip definieren. Beispielsweise können Sie interaktive Objekte nach ihren Positionen auf der Bühne oder in der Anzeigeliste sortieren. Ein Aufruf von <codeph>assignFocus()</codeph> entspricht dem Einstellen der <codeph>Stage.focus</codeph>-Eigenschaft, bietet jedoch zusätzlich die Möglichkeit, die Richtung anzugeben, aus der der Fokus eingestellt wird.</p>
	 
	 <p>Das <codeph>objectToFocus</codeph>-Objekt löst beim Erhalt des Fokus ein <codeph>focusIn</codeph>-Ereignis aus. Die <codeph>direction</codeph>-Eigenschaft des FocusEvent-Objekts gibt die Einstellung des <codeph>direction</codeph>-Parameters an.</p>
	 
	 <p>Wenn Sie das HTMLLoader-Objekt dem <codeph>objectToFocus</codeph>-Parameter zuweisen, wählt das HTMLLoader-Objekt im HTML-DOM das richtige zu fokussierende Objekt auf Basis des <codeph>direction</codeph>-Parameterwerts. Wenn es sich dabei um <codeph>FocusDirection.BOTTOM</codeph> handelt, erhält im HTML-DOM das zu fokussierende Objekt am Ende der Lesereihefolge den Fokus. Wenn es sich dabei um <codeph>FocusDirection.TOP</codeph> handelt, erhält im HTML-DOM das zu fokussierende Objekt zu Beginn der Lesereihenfolge den Fokus. Wenn es sich dabei um <codeph>NONE</codeph> handelt, erhält das HTMLLoader-Objekt den Fokus, ohne dass sein aktuell fokussiertes Element geändert wird.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link><link href="flash.display.xml#FocusDirection"><linktext>flash.display.FocusDirection</linktext></link><link href="flash.events.xml#FocusEvent"><linktext>flash.events.FocusEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
	 
	Sendet ein Ereignis in den Ereignisablauf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufrufen der <codeph>dispatchEvent()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn das Ereignis erfolgreich ausgelöst wurde. Der Wert <codeph>false</codeph> weist entweder auf einen Fehler hin oder auf die Tatsache, dass <codeph>preventDefault()</codeph> für das Ereignis aufgerufen worden ist.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>Das Ereignisobjekt, das in den Ereignisablauf integriert wird. Wenn das Ereignis zurückgesendet wird, wird automatisch ein Klon des Ereignisses erstellt. Nachdem ein Ereignis ausgelöst wurde, lässt sich seine <codeph>target</codeph>-Eigenschaft nicht mehr ändern, daher funktioniert ein Zurücksenden des Ereignisses nur, wenn Sie eine neue Kopie des Ereignisses erstellen.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Sendet ein Ereignis in den Ereignisablauf. Das Ereignisziel ist das EventDispatcher-Objekt, für das die Methode <codeph>dispatchEvent()</codeph> aufgerufen wird.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:hasEventListener"><apiName>hasEventListener</apiName><shortdesc>
	 
	Überprüft, ob das EventDispatcher-Objekt Listener für einen bestimmten Ereignistyp registriert hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufrufen der <codeph>hasEventListener()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn ein Listener des angegebenen Typs registriert ist; andernfalls <codeph>false</codeph>.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Typ des Ereignisses.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Überprüft, ob das EventDispatcher-Objekt Listener für einen bestimmten Ereignistyp registriert hat. Dadurch können Sie bestimmen, wo ein EventDispatcher-Objekt die Verarbeitung eines Ereignistyps in der Ereignisablaufhierarchie geändert hat. Um festzustellen, ob ein bestimmter Ereignistyp einen Ereignis-Listener auslöst, verwenden Sie <codeph>willTrigger()</codeph>.
	
	<p>Der Unterschied zwischen <codeph>hasEventListener()</codeph> und <codeph>willTrigger()</codeph> besteht darin, dass <codeph>hasEventListener()</codeph> nur das Objekt untersucht, zu dem es gehört, während <codeph>willTrigger()</codeph> den gesamten Ereignisablauf auf das im Parameter <codeph>type</codeph> angegebene Ereignis untersucht. <ph platform="javascript">Der Ereignisablauf gilt für die ActionScript 3.0-Anzeigeliste, die in SWF-Inhalt verwendet wird.</ph>
	</p>
	
	<p>Wird <codeph>hasEventListener()</codeph> von einem LoaderInfo-Objekt aus aufgerufen, werden nur die Listener berücksichtigt, die dem Aufrufer zugänglich sind.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:invalidate"><apiName>invalidate</apiName><shortdesc>
     Durch Aufrufen der invalidate()-Methode wird Flash Player signalisiert, dass bei nächster Gelegenheit die Anzeigeliste neu gezeichnet werden muss (z. B., wenn der Abspielkopf in ein neues Bild tritt).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Signalisiert Flash Player, dass die Eigenschaften von Anzeigeobjekten aktualisiert werden müssen, sobald sich die Gelegenheit bietet, die Bühne zu aktualisieren.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Durch Aufrufen der <codeph>invalidate()</codeph>-Methode wird Flash Player signalisiert, dass bei nächster Gelegenheit die Anzeigeliste neu gezeichnet werden muss (z. B., wenn der Abspielkopf in ein neues Bild tritt). Nachdem Sie die <codeph>invalidate()</codeph>-Methode aufgerufen haben und die Anzeigeliste neu gezeichnet worden ist, sendet Flash Player ein <codeph>render</codeph>-Ereignis an jedes Anzeigeobjekt, das gemäß seiner Registrierung auf das <codeph>render</codeph>-Ereignis wartet. Sie müssen die <codeph>invalidate()</codeph>-Methode immer dann aufrufen, wenn Flash Player <codeph>render</codeph>-Ereignisse senden soll. 
     
     <p>Das <codeph>render</codeph>-Ereignis gibt Ihnen die Gelegenheit, Änderungen an der Anzeigeliste vorzunehmen, und zwar unmittelbar bevor sie neu gezeichnet wird. Dadurch haben Sie die Möglichkeit, Aktualisierungen an der Anzeigeliste bis zur letzten Gelegenheit zurückzustellen. Auf diese Weise wird die Performance verbessert, da unnötige Bildschirmaktualisierungen vermieden werden.</p>
     
     <p>Das <codeph>render</codeph>-Ereignis wird nur ausgelöst, um Objekte anzuzeigen, die sich in derselben Sicherheitsdomäne befinden wie der Code, der die <codeph>stage.invalidate()</codeph>-Methode aufruft, oder um Anzeigeobjekte aus einer Sicherheitsdomäne anzuzeigen, der die Berechtigung über die <codeph>Security.allowDomain()</codeph>-Methode erteilt wurde.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/RENDER"><linktext>flash.events.Event.RENDER</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:isFocusInaccessible"><apiName>isFocusInaccessible</apiName><shortdesc>
	 Legt fest, ob die Stage.focus-Eigenschaft aus Sicherheitsgründen den Wert „null“ zurückgibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, wenn das Objekt mit dem Fokus zu einer Sicherheits-Sandbox gehört, auf die die SWF-Datei keinen Zugriff hat.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Legt fest, ob die <codeph>Stage.focus</codeph>-Eigenschaft aus Sicherheitsgründen den Wert <codeph>null</codeph> zurückgibt.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Legt fest, ob die <codeph>Stage.focus</codeph>-Eigenschaft aus Sicherheitsgründen den Wert <codeph>null</codeph> zurückgibt. Anders ausgedrückt: <codeph>isFocusInaccessible</codeph> gibt den Wert <codeph>true</codeph> zurück, wenn das Objekt mit dem Fokus zu einer Sicherheits-Sandbox gehört, auf die die SWF-Datei keinen Zugriff hat.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 
	 Entfernt ein untergeordnetes Anzeigeobjekt aus der angegebenen Indexposition in der Child-Liste des Anzeigeobjekt-Containers.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch das Aufrufen der <codeph>removeChildAt()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie das zu entfernende Objekt befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Objekteigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die entfernte DisplayObject-Instanz.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Child-Indexposition des zu entfernenden Anzeigeobjekts.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Entfernt ein untergeordnetes Anzeigeobjekt aus der angegebenen <codeph>index</codeph>-Position in der Child-Liste des Anzeigeobjekt-Containers. Die <codeph>parent</codeph>-Eigenschaft des entfernten untergeordneten Objekts wird auf <codeph>null</codeph> gesetzt, und das Objekt wird vom Garbage Collector entfernt, wenn keine anderen Verweise auf das untergeordnete Objekt existieren. Die Indexpositionen von Anzeigeobjekten über dem untergeordneten Objekt im Anzeigeobjekt-Container werden um jeweils 1 herabgesetzt.
	 
	 <p>Der Garbage Collector weist nicht verwendete Speicherkapazität neu zu. Wenn auf Variablen oder Objekte nicht mehr aktiv verwiesen wird und diese auch nirgends mehr gespeichert sind, werden sie vom Garbage Collector entfernt, und der belegte Arbeitsspeicher wird bereinigt.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	 
	Ändert die Position eines vorhandenen untergeordneten Objekts im Anzeigeobjekt-Container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufrufen der <codeph>setChildIndex()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Die child-DisplayObject-Instanz, deren Indexnummer Sie ändern möchten.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die resultierende Indexnummer für das <codeph>child</codeph>-Anzeigeobjekt.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Ändert die Position eines vorhandenen untergeordneten Objekts im Anzeigeobjekt-Container. Dies wirkt sich auf die Anordnung der untergeordneten Objekte aus. Das folgende Beispiel enthält z. B. drei Anzeigeobjekte mit der Bezeichnung a, b und c jeweils an den Indexpositionen 0, 1 und 2:
	
	<p><adobeimage alt="c über b über a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>Wenn Sie die <codeph>setChildIndex()</codeph>-Methode verwenden und eine bereits belegte Indexposition angeben, werden nur die Positionen zwischen der alten und der neuen Position des Anzeigeobjekts geändert. Alle anderen Positionen bleiben unverändert. Wenn ein untergeordnetes Objekt an eine NIEDRIGERE Indexposition als bisher verschoben wird, werden alle dazwischen liegenden untergeordneten Objekte für den Indexverweis um 1 ERHÖHT. Wenn ein untergeordnetes Objekt an eine HÖHERE Indexposition als bisher verschoben wird, werden alle dazwischen liegenden untergeordneten Objekte für den Indexverweis um 1 VERRINGERT. Wenn der Anzeigeobjekt-Container im vorigen Beispiel z. B. den Namen <codeph>container</codeph> hat, können Sie die Position der Anzeigeobjekte mit den Bezeichnungen a und b austauschen, indem Sie den folgenden Code aufrufen:</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>Dieser Code führt zur folgenden Objektanordnung:</p>
	
    <p><adobeimage alt="c über a über b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 
	 Kehrt die z-Reihenfolge (von vorne nach hinten) der untergeordneten Objekte an den beiden angegebenen Indexpositionen in der Child-Liste um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufruf der <codeph>swapChildrenAt()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Eigentümer eines der auszutauschenden Objekte befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Objekteigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Indexposition des ersten untergeordneten Objekts.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Indexposition des zweiten untergeordneten Objekts.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Kehrt die z-Reihenfolge (von vorne nach hinten) der untergeordneten Objekte an den beiden angegebenen Indexpositionen in der Child-Liste um. Alle anderen untergeordneten Objekte im Anzeigeobjekt-Container bleiben auf derselben Indexposition.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:willTrigger"><apiName>willTrigger</apiName><shortdesc>
	 
	Überprüft, ob bei diesem EventDispatcher-Objekt oder bei einem seiner übergeordneten Objekte ein Ereignis-Listener für einen bestimmten Ereignistyp registriert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Durch Aufrufen der <codeph>willTrigger()</codeph>-Methode eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn ein Listener des angegebenen Typs ausgelöst wird; andernfalls <codeph>false</codeph>.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Typ des Ereignisses.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Überprüft, ob bei diesem EventDispatcher-Objekt oder bei einem seiner übergeordneten Objekte ein Ereignis-Listener für einen bestimmten Ereignistyp registriert ist. Diese Methode liefert den Wert <codeph>true</codeph>, wenn während irgendeiner Phase des Ereignisablaufs ein Ereignis-Listener aufgerufen wird, wenn ein Ereignis des angegebenen Typs für dieses EventDispatcher-Objekt oder eines seiner nachfolgenden Elemente ausgelöst wird.
	
	<p>Der Unterschied zwischen der <codeph>hasEventListener()</codeph>- und der <codeph>willTrigger()</codeph>-Methode besteht darin, dass die Methode <codeph>hasEventListener()</codeph> nur das Objekt untersucht, zu dem sie gehört, während die <codeph>willTrigger()</codeph>-Methode den gesamten Ereignisablauf auf das im Parameter <codeph>type</codeph> angegebene Ereignis untersucht. <ph platform="javascript">Der Ereignisablauf gilt für die ActionScript 3.0-Anzeigeliste, die in SWF-Inhalt verwendet wird.</ph></p>
	
	<p>Wird <codeph>willTrigger()</codeph> von einem LoaderInfo-Objekt aus aufgerufen, werden nur die Listener berücksichtigt, die dem Aufrufer zugänglich sind.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:Stage:align:get"><apiName>align</apiName><shortdesc>
	 Ein Wert aus der StageAlign-Klasse, der die Ausrichtung der Bühne im Flash Player oder Browser bestimmt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Wert aus der StageAlign-Klasse, der die Ausrichtung der Bühne im Flash Player oder Browser bestimmt. Folgende Werte sind gültig:
	 
	 <p>
	 <adobetable class="innertable">
	 	
	 	 
	 	 
	 	 
	 	 
	 	  
	 	  
	 	  
	 	  
	 	 
	 <tgroup cols="3"><thead><row><entry>Wert</entry><entry>Vertical Alignment</entry><entry>Horizontal</entry></row></thead><tbody><row><entry><codeph>StageAlign.TOP</codeph></entry>
	 	 <entry>Top</entry>
	 	 <entry>Center</entry>
	 	 </row><row><entry><codeph>StageAlign.BOTTOM</codeph></entry>
	 	 <entry>Bottom</entry>
	 	 <entry>Center</entry>
	 	 </row><row><entry><codeph>StageAlign.LEFT</codeph></entry>
	 	 <entry>Center</entry>
	 	 <entry>Left</entry>
	 	 </row><row><entry><codeph>StageAlign.RIGHT</codeph></entry>
	 	 <entry>Center</entry>
	 	 <entry>Right</entry>
	 	 </row><row><entry><codeph>StageAlign.TOP_LEFT</codeph></entry>
	 	  <entry>Top</entry>
	 	  <entry>Left</entry>
	 	  </row><row><entry><codeph>StageAlign.TOP_RIGHT</codeph></entry>
	 	  <entry>Top</entry>
	 	  <entry>Right</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_LEFT</codeph></entry>
	 	  <entry>Bottom</entry>
	 	  <entry>Left</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_RIGHT</codeph></entry>
	 	  <entry>Bottom</entry>
	 	  <entry>Right</entry>
	 	  </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>Die Eigenschaft <codeph>align</codeph> ist nur für ein Objekt verfügbar, das sich in derselben Sicherheits-Sandbox befindet wie der Bühneneigentümer (die Haupt-SWF-Datei). Um dies zu verhindern, kann der Bühneneigentümer der Domäne des aufrufenden Objekts die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.alowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageAlign"><linktext>flash.display.StageAlign</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrection:get"><apiName>colorCorrection</apiName><shortdesc>
 	 Steuert die Flash Player-Farbkorrektur für Anzeigen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Versucht, die Monitorfarbkorrektur zu verwenden
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
 	 Steuert die Flash Player-Farbkorrektur für Anzeigen. Die Farbkorrektur funktioniert nur, wenn dem Hauptmonitor ein gültiges ICC-Farbprofil zugewiesen ist, in dem die speziellen Farbattribute des Geräts angegeben sind. Standardmäßig versucht Flash Player, die Farbkorrektur des Hosts (normalerweise ein Browser) nachzubilden.
     
     <p>Verwenden Sie die <codeph>Stage.colorCorrectionSupport</codeph>-Eigenschaft, um festzustellen, ob die Farbkorrektur auf dem aktuellen System verfügbar und als Standard festgelegt ist. Ist die Farbkorrektur verfügbar, wird davon ausgegangen, dass alle Farben der Bühne im sRGB-Farbraum, dem am weitesten verbreiteten Farbraum, liegen. Quellprofile von Eingabegeräten werden bei der Farbkorrektur nicht berücksichtigt. Es erfolgt keine Farbkorrektur der Eingabe. Es wird lediglich die Bühnenausgabe dem ICC-Farbprofil des Hauptmonitors zugeordnet.</p>
      
     <p>Allgemein gesagt sind die Vorteile des Farbmanagements folgende: berechenbare und konsistente Farbe, bessere Konvertierung, genaueres Proofing und effizientere Ausgabe über mehrere Medien hinweg. Beachten Sie jedoch, dass das Farbmanagement keine perfekten Konvertierungen leisten kann, da Geräte oder Ausgangsbilder einen unterschiedlichen Farbumfang haben. Weiterhin ist trotz Farbmanagement das Einrichten benutzerdefinierter oder bearbeiteter Profile nötig. Farbprofile sind abhängig von Browsern, Betriebssystemen (OS), Betriebssystemerweiterungen, Ausgabegeräten und dem Anwendungssupport.</p>
     
     <p>Die Anwendung von Farbkorrektur beeinträchtigt die Leistung von Flash Player. Die Farbkorrektur von Flash Player ist eine Farbkorrektur im Dokumentstil, da alle SWF-Filme als Dokumente mit impliziten sRGB-Profilen betrachtet werden. Verwenden Sie die <codeph>Stage.colorCorrectionSupport</codeph>-Eigenschaft, um Flash Player anzuweisen, dass er Farben beim Anzeigen eines SWF (Dokuments) so gut wie möglich in Bezug auf den Farbraum der Anzeige korrigieren soll. Flash Player kompensiert nur Unterschiede zwischen Monitoren, nicht zwischen Eingabegeräten (Kamera, Scanner usw.)
     </p>
     
 	 <p>Die drei möglichen Werte sind Strings mit entsprechenden Konstanten in der flash.display.ColorCorrection-Klasse:</p>
 	  <ul><li><codeph>"default"</codeph>: Verwendet dieselbe Farbkorrektur wie das Hostsystem</li> 
 	 <li><codeph>"on"</codeph>: Farbkorrektur immer durchführen</li>
 	 <li><codeph>"off"</codeph>: Farbkorrektur nie durchführen</li>
 	 </ul>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrection"><linktext>flash.display.ColorCorrection</linktext></link><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>colorCorrectionSupport</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrectionSupport:get"><apiName>colorCorrectionSupport</apiName><shortdesc>
      Gibt an, ob das Betriebssystem, auf dem Flash Player ausgeführt wird, Farbkorrektur unterstützt, und ob das Farbprofil des Hauptmonitors (primären Monitors) von Flash Player gelesen und verstanden wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>ColorCorrection
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
      Gibt an, ob das Betriebssystem, auf dem Flash Player ausgeführt wird, Farbkorrektur unterstützt, und ob das Farbprofil des Hauptmonitors (primären Monitors) von Flash Player gelesen und verstanden wird. Diese Eigenschaft gibt auch den Standardstatus der Farbkorrektur des Hostsystems (normalerweise der Browser) zurück. Aktuell gültige Rückgabewerte sind:
 	  <p>Die drei möglichen Werte sind Strings mit entsprechenden Konstanten in der flash.display.ColorCorrectionSupport-Klasse:</p>
 	   <ul><li><codeph>"unsupported"</codeph>: Die Farbkorrektur ist nicht verfügbar.</li> 
 	  <li><codeph>"defaultOn"</codeph>: Farbkorrektur immer ausführen.</li>
 	  <li><codeph>"defaultOff"</codeph>: Farbkorrektur nie ausführen.</li>
 	  </ul>      
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrectionSupport"><linktext>flash.display.ColorCorrectionSupport</linktext></link><link href="flash.display.xml#Stage/colorCorrection"><linktext>colorCorrection</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:displayState:get"><apiName>displayState</apiName><shortdesc>
	 Ein Wert aus der StageDisplayState-Klasse, der festlegt, welcher Anzeigestatus zu verwenden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>displayState</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>. Es wird ein Sicherheitsfehler ausgelöst, wenn versucht wird, die <codeph>displayState</codeph>-Eigenschaft bei angezeigtem Einstellungsdialogfeld einzurichten, ohne dass eine Benutzerreaktion erfolgt, oder wenn das <codeph>allowFullScreen</codeph>-Attribut des HTML-Tags <codeph>param</codeph> oder <codeph>embed</codeph> nicht auf <codeph>true</codeph> gesetzt ist.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Ein Wert aus der StageDisplayState-Klasse, der festlegt, welcher Anzeigestatus zu verwenden ist. Folgende Werte sind gültig: 
	 
	 <ul>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN</codeph>: Legt fest, dass die AIR-Anwendung oder Flash Player die Bühne auf den gesamten Bildschirm des Benutzers ausdehnt, wobei die Tastatureingabe deaktiviert ist.</li>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph>: Legt fest, dass die AIR-Anwendung die Bühne auf den gesamten Bildschirm des Benutzers ausdehnt, wobei die Tastatureingabe erlaubt ist. <ph platform="actionscript">(Nicht verfügbar für Inhalte, die in Flash Player ausgeführt werden.)</ph></li>
	 
     <li><codeph>StageDisplayState.NORMAL</codeph>: Setzt den Player auf den Standardanzeigemodus für die Bühne zurück.</li>
	 
	 </ul> 
	 
     <p platform="actionscript">Das Skalierverhalten des Films im Vollbildmodus wird durch die <codeph>scaleMode</codeph>-Einstellung bestimmt (diese wird mithilfe der <codeph>Stage.scaleMode</codeph>-Eigenschaft oder der <codeph>embed</codeph>-Tageinstellungen der SWF-Datei in der HTML-Datei eingerichtet). Wenn die <codeph>scaleMode</codeph>-Eigenschaft auf <codeph>noScale</codeph> gesetzt wird, während die Anwendung in den Vollbildmodus wechselt, wird die <codeph>width</codeph>- und <codeph>height</codeph>-Eigenschaft der Bühne aktualisiert und das <codeph>Stage.resize</codeph>-Ereignis ausgelöst.</p>
     
     <p platform="actionscript">Die folgenden Einschränkungen gelten für SWF-Dateien, die innerhalb einer HTML-Seite wiedergegeben werden (nicht für SWF-Dateien, die den eigenständigen Flash Player verwenden oder die in der AIR-Laufzeitumgebung ausgeführt werden):</p>
     
     <ul platform="actionscript">
	 
	 <li>Um den Vollbildmodus zu aktivieren, fügen Sie den Parameter <codeph>allowFullScreen</codeph> den Tags <codeph>object</codeph> und <codeph>embed</codeph> auf der HTML-Seite hinzu, die die SWF-Datei enthält. Dabei muss <codeph>allowFullScreen</codeph> wie im folgenden Beispiel auf <codeph>"true"</codeph> gesetzt sein:
	 
	 <codeblock>&lt;param name="allowFullScreen" value="true" />
	        ...
	 &lt;embed src="example.swf" allowFullScreen="true" ... ></codeblock>
	 
	 <p>Auf einer HTML-Seite können die Tags zum Einbetten von SWF auch mithilfe eines Skripts erzeugt werden. Sie müssen das Skript ändern, damit die richtigen <codeph>allowFullScreen</codeph>-Einstellungen eingefügt werden.  Von Flash und FlexBuilder erzeugte HTML-Seiten verwenden die <codeph>AC_FL_RunContent()</codeph>-Funktion, um Verweise auf SWF-Dateien einzubetten. Sie müssen dann die <codeph>allowFullScreen</codeph>-Parametereinstellungen wie folgt hinzufügen:</p>
	 
	 <codeblock>AC_FL_RunContent( ... "allowFullScreen", "true", ... )</codeblock></li>
	 
     <li>Der Vollbildmodus wird als Reaktion auf einen Mausklick oder das Drücken einer Taste durch Benutzer initiiert. Der Film kann <codeph>Stage.displayState</codeph> nicht ohne Eingabe von Benutzern ändern. Flash Player beschränkt im Vollbildmodus Tastatureingaben: Zu den gültigen Eingaben gehören Tastaturbefehle, die den Vollbildmodus beenden sowie Tasten für nicht druckbare Zeichen wie Pfeiltasten, Leertaste, Umschalt-Taste und Tabulatortasten. Tastaturbefehle zum Beenden des Vollbildmodus sind: Escape (Windows, Linux, Mac), Strg+W (Windows), Befehlstaste+W (Mac) und Alt+F4.
     <p>Im Film wird ein Flash Player-Dialogfeld angezeigt, wenn Benutzer den Vollbildmodus aktivieren, um Benutzer darüber zu informieren und darauf hinzuweisen, dass der Vollbildmodus durch Drücken der Esc-Taste beendet werden kann.</p></li>
     <li>Ab Flash Player 9.0.115.0 und höher funktioniert der Vollbildmodus im fensterlosen Modus genau wie im Fenstermodus. Wenn Sie den Fenstermodus (<codeph>wmode</codeph> im HTML-Code) auf „Undurchsichtig ohne Fenster“ (<codeph>opaque</codeph>) oder „Transparent ohne Fenster“ (<codeph>transparent</codeph>) einstellen, kann das Vollbild initiiert werden, das Vollbildfenster ist jedoch immer undurchsichtig.</li> 
	 
     </ul>
     
 	 <p platform="actionscript">Diese Einschränkungen gelten <i>nicht</i> für SWF-Inhalt, der im eigenständigen Flash Player oder in AIR ausgeführt wird. AIR unterstützt einen interaktiven Vollbildmodus, der Tastatureingaben zulässt.</p>  
	 
	 <p>Für <ph platform="actionscript">AIR</ph>-Inhalt, der im Vollbildmodus ausgeführt wird, werden der Bildschirmschoner und die Stromsparoptionen während der Wiedergabe von Video-Inhalt deaktiviert, bis das Video gestoppt oder der Vollbildmodus beendet wird.</p>
 	 
	 <p>Unter Linux ist das Setzen von <codeph>displayState</codeph> auf <codeph>StageDisplayState.FULL_SCREEN</codeph> oder <codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> ein asynchroner Vorgang.</p>
    
	 </apiDesc><example conref="examples\StageExample2.as"> Im folgenden Beispiel wird interaktiv gezeigt, wie Sie den Vollbildmodus einrichten können, indem Sie die <codeph>displayState</codeph>-Eigenschaft ändern. <p><b>Hinweis</b>: Aufgrund von Sicherheitsbeschränkungen kann der Vollbildmodus nur in bestimmten Situationen ausgelöst werden, z. B. wenn Benutzer auf die entsprechende Option klicken oder eine Taste drücken. Wenn die allowFullScreen-Eigenschaft in einem Browser ausgeführt wird, muss sie auf „true“ gesetzt sein.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Stage;
    import flash.events.*;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.media.Video;
    
    public class FullScreenExample extends Sprite
    {
        private var videoURL:String = "testVideo.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var video:Video;        
        
        public function FullScreenExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
            
            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK,toggleFullScreen);
        }        
        
        private function toggleFullScreen(event:MouseEvent):void {
            switch(stage.displayState) {
                case "normal":
                    stage.displayState = "fullScreen";    
                    break;
                case "fullScreen":
                default:
                    stage.displayState = "normal";    
                    break;
            }
        }    
        
        // Video related:
        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }
        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);

            video = new Video(stage.stageWidth,stage.stageHeight);
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:focus:get"><apiName>focus</apiName><shortdesc>
	 Das interaktive Objekt mit Tastaturfokus bzw. „null“, wenn der Fokus nicht gesetzt ist oder wenn das Objekt mit dem Fokus zu einer Sicherheits-Sandbox gehört, auf die mit dem aufrufenden Objekt nicht zugegriffen werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier><apiException><apiDesc>Gibt eine Fehlermeldung aus, wenn der Fokus nicht auf das Ziel gesetzt werden kann.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Das Objekt mit dem Tastaturfokus.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Das interaktive Objekt mit Tastaturfokus bzw. <codeph>null</codeph>, wenn der Fokus nicht gesetzt ist oder wenn das Objekt mit dem Fokus zu einer Sicherheits-Sandbox gehört, zu der das aufrufende Objekt keinen Zugang hat.
	 
	 </apiDesc><example conref="Stage.focus.as"> <codeph/>  
<codeblock>
var myTF:TextField = new TextField();
myTF.border =true;
myTF.type = TextFieldType.INPUT;

addChild(myTF);
stage.focus= myTF;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Stage:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 Ruft die Bildrate der Bühne ab und setzt sie gegebenenfalls neu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>frameRate</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Ruft die Bildrate der Bühne ab und setzt sie gegebenenfalls neu. Die Bildrate wird als Bilder pro Sekunde definiert. Standardmäßig wird die Bildrate von der zuerst geladenen SWF-Datei übernommen. Der zulässige Bereich für die Bildrate liegt zwischen 0,01 und 1000 Bildern pro Sekunde. 
	 
	 <p><codeph>Hinweis:</codeph> Eine hohe Bildrate kann von einer Anwendung möglicherweise nicht eingehalten werden, entweder weil die Zielplattform nicht schnell genug ist oder weil der Player mit der vertikalen Austastlücke des Anzeigegeräts (in der Regel 60 Hz auf LCD-Geräten) synchronisiert ist. In manchen Fällen ist es auch möglich, dass die Zielplattform die maximale Bildrate herabsetzt, wenn eine hohe CPU-Auslastung erwartet wird.</p>
	 
	 <p>Bei Inhalt, der in Adobe AIR ausgeführt wird, gilt Folgendes: Wenn die <codeph>frameRate</codeph>-Eigenschaft für ein Stage-Objekt eingestellt wird, ändert dies die Bildrate für alle Stage-Objekte (von unterschiedlichen NativeWindow-Objekten verwendet).
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:fullScreenHeight:get"><apiName>fullScreenHeight</apiName><shortdesc>
  Setzt die Höhe des Monitors, der verwendet wird, wenn der Vollbildmodus aktiviert wird, zurück, falls dieser Modus sofort aufgerufen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Setzt die Höhe des Monitors, der verwendet wird, wenn der Vollbildmodus aktiviert wird, zurück, falls dieser Modus sofort aufgerufen wird. Wenn der Benutzer über mehrere Monitore verfügt, wird der Monitor verwendet, auf dem sich zu diesem Zeitpunkt der größte Teil der Bühne befindet.
  
  <p><b>Hinweis</b>: Falls der Benutzer die Möglichkeit hat, zwischen dem Abrufen des Wertes und dem Wechseln in den Vollbildmodus den Browser von einem Monitor zu einem anderen zu verschieben, könnte der Wert inkorrekt sein. Wenn Sie den Wert in eine Ereignisprozedur abrufen, die <codeph>Stage.displayState</codeph> auf <codeph>StageDisplayState.FULL_SCREEN</codeph> setzt, ist der Wert korrekt.</p>
  
  <p>Dies ist die Höhe des Monitors in Pixel; dieser Wert ist identisch mit der Höhe der Bühne, wenn <codeph>Stage.align</codeph> auf den Wert <codeph>StageAlign.TOP_LEFT</codeph> und <codeph>Stage.scaleMode</codeph> auf den Wert <codeph>StageScaleMode.NO_SCALE</codeph> gesetzt ist.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> In diesem Beispiel wird ein grünes Rechteck in der Größe der Bühne erstellt. Darauf wird ein rotes Quadrat platziert, das als Schaltfläche aktiviert wird. Durch Klicken auf das rote Quadrat wird die Ereignisprozedur <codeph>enterFullScreen()</codeph> ausgelöst, die die Eigenschaft <codeph>fullScreenSourceRect</codeph> festlegt und den Vollbildmodus aktiviert. Um die Eigenschaft <codeph>fullScreenSourceRect</codeph> festzulegen, beginnt die Ereignisprozedur mit der Position und den Abmessungen des roten Quadrats. Danach wird das Seitenverhältnis (Breite durch Höhe) des roten Quadrats mit dem Seitenverhältnis der Bühne im Vollbild verglichen, sodass das Rechteck (<codeph>fullScreenSourceRect</codeph>) dem Seitenverhältnis des Bildschirms entsprechend erweitert werden kann. Im Ergebnis nimmt das rote Quadrat die gesamte Höhe des Bildschirms ein, während an beiden Seiten der grüne Hintergrund sichtbar ist. Wenn das Seitenverhältnis nicht angepasst worden wäre, wäre anstelle des grünen Hintergrunds auf beiden Seiten die Hintergrundfarbe der Bühne (standardmäßig weiß) zu sehen.
 
 <p><b>Hinweis</b>: Testen Sie dieses Beispiel im Browser. Wählen Sie auf der Registerkarte „HTML“ des Dialogfelds „Einstellungen für Veröffentlichungen“ die Vorlage „Nur Flash - Vollbild zulassen“. Geben Sie 9.0.115.0 bei der Flash Player-Version an und achten Sie darauf, dass auf der Registerkarte „Format“ die Formate „Flash“ und „HTML“ ausgewählt sind. Die resultierende HTML-Datei lässt sich im Browser veröffentlichen und öffnen.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/fullScreenWidth"><linktext>fullScreenWidth</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenSourceRect:get"><apiName>fullScreenSourceRect</apiName><shortdesc>
  Legt fest, dass Flash Player einen bestimmten Bereich der Bühne auf den Vollbildmodus skaliert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
  Legt fest, dass Flash Player einen bestimmten Bereich der Bühne auf den Vollbildmodus skaliert. Falls verfügbar, verwendet Flash Player die Hardwareskalierung, wobei die Grafik- und Videokarte des Computers genutzt wird und Inhalte im Allgemeinen schneller als bei der Softwareskalierung angezeigt werden.
  
  <p>Wenn diese Eigenschaft auf ein gültiges Rechteck und die Eigenschaft <codeph>displayState</codeph> auf den Vollbildmodus gesetzt wird, skaliert Flash Player den angegebenen Bereich. Die tatsächliche Größe der Bühne in Pixeln innerhalb von ActionScript wird nicht geändert. Flash Player erzwingt eine Mindestgröße des Rechtecks, damit die standardmäßige Meldung „Vollbildmodus mit Esc beenden䙓 darin Platz findet. Diese Mindestgröße beträgt normalerweise ca. 260 x 30 Pixel, kann jedoch je nach Plattform und Flash Player-Version variieren.</p>
  
  <p>Diese Eigenschaft kann nur festgelegt werden, wenn sich Flash Player nicht im Vollbildmodus befindet. Um diese Eigenschaft richtig zu verwenden, legen Sie sie zuerst fest und setzen Sie dann die Eigenschaft <codeph>displayState</codeph> auf den Vollbildmodus, wie in den Codebeispielen dargestellt.</p>
  <p>Um die Skalierung zu aktivieren, legen Sie die Eigenschaft <codeph>fullScreenSourceRect</codeph> auf ein Rechteckobjekt fest:</p>
  <codeblock>  
  // valid, will enable hardware scaling
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240); 
  </codeblock>
  
  <p>Um die Skalierung zu deaktivieren, legen Sie in ActionScript 3.0 <codeph>fullScreenSourceRect=null</codeph> und in ActionScript 2.0 <codeph>undefined</codeph> fest.</p>
  <codeblock>
  stage.fullScreenSourceRect = null;
  </codeblock>
  
  <p>Der Endbenutzer kann die Hardwareskalierung, die standardmäßig aktiviert ist, in den Flash Player-Anzeigeeinstellungen auch deaktivieren. Weitere Informationen finden Sie unter <xref href="http://www.adobe.com/go/display_settings_de" scope="external">www.adobe.com/go/display_settings_de</xref>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenSourceRect.1.as"> Um die Vorteile der Hardwareskalierung zu nutzen, setzen Sie die gesamte Bühne oder einen Teil der Bühne in den Vollbildmodus. Im folgenden ActionScript 3.0-Code wird die gesamte Bühne in den Vollbildmodus gesetzt:
<codeblock>
 
import flash.geom.*; 
{
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240);
  stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example><example conref="examples\Stage_fullScreenSourceRectExample2.as"> Im folgenden Beispiel kann der Benutzer zwischen dem Abspielen eines Videos im Vollbildmodus oder im normalen Bildschirmmodus wechseln, indem er auf die Bühne klickt. Wenn die SWF-Datei für dieses Beispiel in Flash Player 9.0.115.0 oder höher abgespielt wird, wird Hardwarebeschleunigung verwendet, um die Vollbildskalierung der Anzeige zu verbessern.
  
 <p>Damit der Vollbildmodus mit Hardwarebeschleunigung verwendet werden kann, müssen folgende Bedingungen erfüllt sein:</p>
 
 <ol>
 <li>Flash Player 9.0.115.0 oder höher wird benötigt, ebenso ein Authoring-Tool, das diese Version unterstützt.</li>
 <li>HTML-Vorlagen müssen modifiziert werden, damit sie den Vollbildmodus unterstützen. Das Attribut <codeph>allowFullScreen</codeph> muss für die Tags <codeph>object</codeph> und <codeph>embed</codeph> auf <codeph>true</codeph> gesetzt werden. (Die Skripten, die SWF-Einbettungs-Tags generieren, müssen ebenfalls den Vollbildmodus zulassen.) Beispieldateien, die für Flex Builder verwendet werden können, finden Sie im Artikel <xref href="http://www.adobe.com/devnet/flashplayer/articles/full_screen_mode.html" scope="external">Exploring full-screen mode in Flash Player 9</xref>.</li>
 <li>Ihre Anwendung muss über Zugriffsberechtigungen für eine FLV-Videodatei verfügen. In diesem Beispiel wird davon ausgegangen, dass sich die Flash Video-Datei (FLV) im selben Ordner wie die SWF-Datei befindet.</li>
 <li>Der Benutzer muss den Zugriff auf den Vollbildmodus zulassen.</li>
 <li>Weitere Informationen zur Hardwareskalierung finden Sie im Artikel <xref href="http://www.adobe.com/go/hardware_scaling_de" scope="external">Exploring Flash Player support for high-definition H.264 video and AAC audio</xref> für Flash Player.</li>
 </ol>
 
 <p>Eine FLV-Datei wird mit den Objekten NetConnection und NetStream geladen. Da sich die FLV-Datei im selben Ordner wie die SWF-Datei befindet und die Verbindung über HTTP hergestellt wird, wird der Parameter der <codeph>NetConnection.connect()</codeph>-Methode auf <codeph>null</codeph> gesetzt. Das NetConnection-Objekt <codeph>connect</codeph> meldet seinen Status, indem ein <codeph>netStatus</codeph>-Ereignis ausgelöst wird, welches die <codeph>netStatusHandler()</codeph>-Methode aufruft. Die <codeph>netStatusHandler()</codeph>-Methode überprüft, ob die Verbindung erfolgreich hergestellt wurde, und ruft die <codeph>connectStream()</codeph>-Methode auf, die ein NetStream-Objekt erstellt, welches das NetConnection-Objekt als Parameter annimmt. Sie erstellt auch ein Video-Objekt und fügt das NetStream-Objekt dem Video-Objekt hinzu. Das Video-Objekt wird dann der Anzeigeliste hinzugefügt, und der Stream wird für das Abspielen eingerichtet. Da die FLV-Videodatei keine Metadaten oder Cue-Point-Informationen enthält, wird ein <codeph>AsyncError</codeph>-Ereignis ausgelöst. Es muss ein Listener für die Verarbeitung des Ereignisses eingerichtet werden. Hier wurde der Listener erstellt und ignoriert das Ereignis. Ein weiterer Listener für das Ereignis <codeph>netStatus</codeph> wurde für das NetStream-Objekt eingerichtet. Er zeigt eine Fehlermeldung an, wenn der Stream nicht gefunden wurde. (Beachten Sie, dass <codeph>netStatusHandler()</codeph> für die Verarbeitung beliebig vieler unterschiedlicher Statusinformationen, die für den Stream oder die Verbindung gemeldet werden, verwendet werden könnte.)</p>
 
 <p>Wenn auf die Eigenschaften und Methoden einer geladenen SWF-Datei zugegriffen werden kann, wird die <codeph>createMouseListener()</codeph>-Methode aufgerufen. Sie richtet einen Ereignis-Listener für das Klicken auf die Bühne ein. Die <codeph>toggleFullScreen()</codeph>-Methode überprüft, ob der Anzeigestatus im Vollbild oder im normalen Modus ist. Für den normalen Modus wird die Größe des Video-Objekts auf die Größe des Videostreams gesetzt. Die <codeph>fullScreenSourceRect</codeph>-Eigenschaft wird auf ein Rechteck gesetzt, das den Abmessungen des Video-Objekts entspricht. Dann wird die <codeph>Stage.displayMode</codeph>-Eigenschaft auf den Vollbildmodus gesetzt, wodurch das Video im ursprünglichen Rechteck erweitert wird, um den gesamten Vollbildbereich auszufüllen. Wenn die Systemanforderungen erfüllt sind, wird die Grafikhardware des Computers verwendet, um die Leistung der Videodarstellung im Vollbild zu verbessern, und der Anzeigestatus wird auf den Vollbildmodus gesetzt. Um Sicherheitsfehler abzufangen, die beim Wechsel in den Vollbildmodus auftreten könnten, wird eine <codeph>try...catch</codeph>-Anweisung verwendet. (Beachten Sie, dass der Anzeigestatus auf den Vollbildmodus gesetzt werden muss, nach die Eigenschaft <codeph>fullScreenSourceRect</codeph> gesetzt wurde.) Vor dem Wechsel in den normalen Modus werden die Breite und Höhe des Video-Objekts auf die Werte des gespeicherten ursprünglichen Video-Objekts zurückgesetzt. Andernfalls bestimmen die für den Vollbildmodus am Video-Objekt vorgenommenen Änderungen die Breite und Höhe.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageDisplayState;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.NetStatusEvent;
    import flash.events.AsyncErrorEvent;
    import flash.events.SecurityErrorEvent;
    import flash.events.MouseEvent;
    import flash.events.Event;
    import flash.geom.Rectangle;
    
    public class Stage_fullScreenSourceRectExample2 extends Sprite {
        private var videoURL:String = "testVideo1.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var myVideo:Video;        
        private    var savedWidth:uint;
        private    var savedHeight:uint;
 
        public function Stage_fullScreenSourceRectExample2() {
    
            connection = new NetConnection();
             connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);    
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);

            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK, toggleFullScreen);
        }        

        private function toggleFullScreen(event:MouseEvent):void {

            if(stage.displayState == StageDisplayState.NORMAL) {
                myVideo.width = myVideo.videoWidth;
                  myVideo.height = myVideo.videoHeight;

                try {
                    stage.fullScreenSourceRect = new Rectangle(myVideo.x, myVideo.y, 
                                                           myVideo.width, myVideo.height);
                     stage.displayState = StageDisplayState.FULL_SCREEN;

                 } catch (e:SecurityError) {
                     trace ("A security error occurred while switching to full screen: " + event);
                    myVideo.width = savedWidth;
                    myVideo.height = savedHeight;
                 }

            }else {
                myVideo.width = savedWidth;
                myVideo.height = savedHeight;
                stage.displayState = StageDisplayState.NORMAL;
            }
        }    

       private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace ("Unable to locate video: " + videoURL);
                    break;
            }
        }

       private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);     

             myVideo = new Video();
            myVideo.attachNetStream(stream);
            stream.play(videoURL);

            savedWidth = myVideo.width;
            savedHeight = myVideo.height;

            addChild(myVideo);
        }
       
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);    
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/displayState"><linktext>Stage.displayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenWidth:get"><apiName>fullScreenWidth</apiName><shortdesc>
  Setzt die Breite des Monitors, der verwendet wird, wenn der Vollbildmodus aktiviert wird, zurück, falls dieser Modus sofort aufgerufen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Setzt die Breite des Monitors, der verwendet wird, wenn der Vollbildmodus aktiviert wird, zurück, falls dieser Modus sofort aufgerufen wird. Wenn der Benutzer über mehrere Monitore verfügt, wird der Monitor verwendet, auf dem sich zu diesem Zeitpunkt der größte Teil der Bühne befindet. 
  
  <p><b>Hinweis</b>: Falls der Benutzer die Möglichkeit hat, zwischen dem Abrufen des Wertes und dem Wechseln in den Vollbildmodus den Browser von einem Monitor zu einem anderen zu verschieben, könnte der Wert inkorrekt sein. Wenn Sie den Wert in eine Ereignisprozedur abrufen, die <codeph>Stage.displayState</codeph> auf <codeph>StageDisplayState.FULL_SCREEN</codeph> setzt, ist der Wert korrekt.</p>
  
  <p>Dies ist die Breite des Monitors in Pixel; dieser Wert ist identisch mit der Breite der Bühne, wenn <codeph>Stage.align</codeph> auf den Wert <codeph>StageAlign.TOP_LEFT</codeph> und <codeph>Stage.scaleMode</codeph> auf den Wert <codeph>StageScaleMode.NO_SCALE</codeph> gesetzt ist.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> In diesem Beispiel wird ein grünes Rechteck in der Größe der Bühne erstellt. Darauf wird ein rotes Quadrat platziert, das als Schaltfläche aktiviert wird. Durch Klicken auf das rote Quadrat wird die Ereignisprozedur <codeph>enterFullScreen()</codeph> ausgelöst, die die Eigenschaft <codeph>fullScreenSourceRect</codeph> festlegt und den Vollbildmodus aktiviert. Um die Eigenschaft <codeph>fullScreenSourceRect</codeph> festzulegen, beginnt die Ereignisprozedur mit der Position und den Abmessungen des roten Quadrats. Danach wird das Seitenverhältnis (Breite durch Höhe) des roten Quadrats mit dem Seitenverhältnis der Bühne im Vollbild verglichen, sodass das Rechteck (<codeph>fullScreenSourceRect</codeph>) dem Seitenverhältnis des Bildschirms entsprechend erweitert werden kann. Im Ergebnis nimmt das rote Quadrat die gesamte Höhe des Bildschirms ein, während an beiden Seiten der grüne Hintergrund sichtbar ist. Wenn das Seitenverhältnis nicht angepasst worden wäre, wäre anstelle des grünen Hintergrunds auf beiden Seiten die Hintergrundfarbe der Bühne (standardmäßig weiß) zu sehen.
 
 <p><b>Hinweis</b>: Testen Sie dieses Beispiel im Browser. Wählen Sie auf der Registerkarte „HTML“ des Dialogfelds „Einstellungen für Veröffentlichungen“ die Vorlage „Nur Flash - Vollbild zulassen“. Geben Sie 9.0.115.0 bei der Flash Player-Version an und achten Sie darauf, dass auf der Registerkarte „Format“ die Formate „Flash“ und „HTML“ ausgewählt sind. Die resultierende HTML-Datei lässt sich im Browser veröffentlichen und öffnen.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenHeight"><linktext>fullScreenHeight</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:height:get"><apiName>height</apiName><shortdesc>
	 
     Gibt die Höhe des Anzeigeobjekts in Pixeln an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Durch das Verweisen auf die <codeph>height</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Es ist niemals zulässig, die <codeph>height</codeph>-Eigenschaft eines Stage-Objekts zu setzen, selbst wenn das aufrufende Objekt der Bühneneigentümer (die Haupt-SWF-Datei) ist.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Gibt die Höhe des Anzeigeobjekts in Pixeln an. Die Höhe wird auf Basis der Begrenzungen des Inhalts des Anzeigeobjekts berechnet. Wenn Sie die Eigenschaft <codeph>height</codeph> festsetzen, wird die Eigenschaft <codeph>scaleY</codeph> entsprechend angepasst, wie im folgenden Code gezeigt.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>Abgesehen von TextField- und Video-Objekten, hat ein Anzeigeobjekt ohne Inhalt (z. B. ein leeres Sprite) eine Höhe von 0, selbst wenn Sie versuchen, <codeph>height</codeph> auf einen anderen Wert zu setzen.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Maus aktivierbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Durch das Verweisen auf die <codeph>mouseChildren</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Maus aktivierbar sind. Ist ein Objekt per Maus aktivierbar, kann ein Benutzer damit in Interaktion treten, indem er eine Maus verwendet. Der Standardwert lautet <codeph>true</codeph>.
	 
	 <p>Diese Eigenschaft ist praktisch, wenn Sie eine Schaltfläche mit einer Instanz der Sprite-Klasse (anstelle der SimpleButton-Klasse) erstellen. Wenn Sie zum Erstellen einer Schaltfläche eine Sprite-Instanz verwenden, können Sie die Schaltfläche ausrüsten und mithilfe der <codeph>addChild()</codeph>-Methode zusätzliche Sprite-Instanzen hinzufügen. Dieser Vorgang kann zu unerwarteten Verhaltensweisen bei Mausereignissen führen, da die untergeordneten Sprite-Instanzen zum Zielobjekt eines Mausereignisses werden können, wenn eigentlich die übergeordnete Instanz des Zielobjekts erwartet wird. Um sicherzustellen, dass die übergeordnete Instanz als Zielobjekt für Mausereignisse dient, können Sie die <codeph>mouseChildren</codeph>-Eigenschaft der übergeordneten Instanz auf <codeph>false</codeph> setzen.</p>
	 <p> Durch das Festlegen dieser Eigenschaft wird kein Ereignis ausgelöst. Um interaktive Funktionalität zu erzielen, müssen Sie die <codeph>addEventListener()</codeph>-Methode verwenden.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:nativeWindow:get"><apiName>nativeWindow</apiName><shortdesc>
	 Ein Verweis auf das NativeWindow-Objekt, das diese Bühne enthält.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Verweis auf das NativeWindow-Objekt, das diese Bühne enthält. 
	 
	 <p>Das Fenster repräsentiert das Fenster des nativen Betriebssystems; die Bühne repräsentiert den Inhalt des Fensters. Diese Eigenschaft ist nur für Inhalt gültig, der in AIR ausgeführt wird. In Flash Player (in einem Browser ausgeführter Inhalt) ist diese Eigenschaft <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 
	 Liefert die Anzahl der Objekte, die diesem Objekt untergeordnet sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Durch das Verweisen auf die <codeph>numChildren</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Liefert die Anzahl der Objekte, die diesem Objekt untergeordnet sind.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:quality:get"><apiName>quality</apiName><shortdesc>
	 Ein Wert der StageQuality-Klasse, der die verwendete Wiedergabequalität angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>quality</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Ein Wert der StageQuality-Klasse, der die verwendete Wiedergabequalität angibt. Folgende Werte sind gültig:
	 
	 <ul>
	 
	 <li><codeph>StageQuality.LOW</codeph>: Niedrige Wiedergabequalität. Für Grafiken wird kein Anti-Aliasing und für Bitmaps keine Glättung durchgeführt, aber in Laufzeitumgebungen wird weiterhin MIP-Mapping verwendet. Diese Einstellung wird in Adobe AIR nicht unterstützt.</li>
	 
	 <li><codeph>StageQuality.MEDIUM</codeph>: Mittlere Wiedergabequalität. Für Grafiken wird ein Anti-Aliasing mit einem 2x2-Pixelraster durchgeführt. Das Glätten von Bitmaps hängt von der Einstellung <codeph>Bitmap.smoothing</codeph> ab. Für Laufzeitumgebungen wird MIP-Mapping verwendet. Diese Einstellung ist für Filme geeignet, die keinen Text enthalten. Diese Einstellung wird in Adobe AIR nicht unterstützt.</li>
	 
	 <li><codeph>StageQuality.HIGH</codeph>: Hohe Wiedergabequalität. Für Grafiken wird ein Anti-Aliasing mit einem 4x4-Pixelraster durchgeführt. Das Glätten von Bitmaps hängt von der Einstellung <codeph>Bitmap.smoothing</codeph> ab. Für Laufzeitumgebungen wird MIP-Mapping verwendet. Dies ist die von Flash Player verwendete Standardeinstellung für die Wiedergabequalität.</li>
	 
	 <li><codeph>StageQuality.BEST</codeph>: Maximale Wiedergabequalität. Für Grafiken wird ein Anti-Aliasing mit einem 4x4-Pixelraster durchgeführt. Wenn <codeph>Bitmap.smoothing</codeph> den Wert <codeph>true</codeph> aufweist, verwendet die Laufzeitumgebung einen hochwertigen Algorithmus für die Verkleinerung, durch den weniger Artefakte entstehen (bei Verwendung von <codeph>StageQuality.BEST</codeph> mit <codeph>Bitmap.smoothing</codeph> und dem Wert <codeph>true</codeph> verringert sich die Leistung jedoch erheblich; daher wird diese Einstellung nicht empfohlen).</li>
	 
	 </ul>
	 
	 <p>Bei höheren Qualitätseinstellungen werden skalierte Bitmaps besser dargestellt. Höhere Qualitätseinstellungen beanspruchen jedoch auch mehr Computerressourcen. Besonders bei der Wiedergabe von skaliertem Video kann eine hohe Qualitätseinstellung die Bildrate verringern.
	 </p>
	 
	 <p>Für Inhalt, der in Adobe AIR ausgeführt wird, kann <codeph>quality</codeph> auf <codeph>StageQuality.BEST</codeph> oder <codeph>StageQuality.HIGH</codeph> eingestellt werden (der Standardwert lautet <codeph>StageQuality.HIGH</codeph>). Der Versuch, die Eigenschaft auf einen anderen Wert einzustellen, hat keinerlei Auswirkungen (und die Eigenschaft wird nicht geändert).
	 </p>
	 
	 <p>Bei Inhalt, der in Adobe AIR ausgeführt wird, gilt Folgendes: Wenn die <codeph>quality</codeph>-Eigenschaft für ein Stage-Objekt eingestellt wird, ändert dies die Wiedergabequalität für alle Stage-Objekte (von unterschiedlichen NativeWindow-Objekten verwendet).
	 </p>
	 
	 <b><i>Hinweis:</i></b> Da das Betriebssystem die Geräteschriften zeichnet, hat die <codeph>quality</codeph>-Eigenschaft darauf keine Auswirkung.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageQuality"><linktext>flash.display.StageQuality</linktext></link><link href="flash.display.xml#Bitmap/smoothing"><linktext>flash.display.Bitmap.smoothing</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
	 Ein Wert aus der StageScaleMode-Klasse, mit dem angegeben wird, welcher Skalierungsmodus verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>scaleMode</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ein Wert aus der StageScaleMode-Klasse, mit dem angegeben wird, welcher Skalierungsmodus verwendet werden soll.
 	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein Wert aus der StageScaleMode-Klasse, mit dem angegeben wird, welcher Skalierungsmodus verwendet werden soll. Folgende Werte sind gültig:
	 
     <ul>
     
     <li><codeph>StageScaleMode.EXACT_FIT</codeph>: Die gesamte Anwendung wird im angegebenen Bereich angezeigt. Das ursprüngliche Seitenverhältnis wird nicht beibehalten. Verzerrungen können auftreten und die Anwendung erscheint möglicherweise gestreckt oder gestaucht.
     </li>
     
     <li><codeph>StageScaleMode.SHOW_ALL</codeph>: Die gesamte Anwendung wird im angegebenen Bereich verzerrungsfrei angezeigt. Dabei bleibt das ursprüngliche Seitenverhältnis der Anwendung erhalten. Unter Umständen werden an zwei Seiten der Anwendung Ränder angezeigt.   
     </li>
     
	 <li><codeph>StageScaleMode.NO_BORDER</codeph>: Die gesamte Anwendung füllt den angegebenen Bereich so, dass er ohne Verzerrung in den angegebenen Bereich passt. Bei Bedarf wird jedoch zugeschnitten. Das ursprüngliche Seitenverhältnis der Anwendung bleibt erhalten.
	 </li>
	 
	 <li><codeph>StageScaleMode.NO_SCALE</codeph>: Die gesamte Anwendung wird fixiert und bleibt auch dann unverändert, wenn sich die Größe des Player-Fensters ändert. Ist das Player-Fenster kleiner als der Flash-Inhalt, wird der Inhalt zugeschnitten.
	 </li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:showDefaultContextMenu:get"><apiName>showDefaultContextMenu</apiName><shortdesc>
     Gibt an, ob die Standardelemente im Kontextmenü des Flash Players ein- oder ausgeblendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>showDefaultContextMenu</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Gibt an, ob die Standardelemente im Kontextmenü des Flash Players ein- oder ausgeblendet werden.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Gibt an, ob die Standardelemente im Kontextmenü des Flash Players ein- oder ausgeblendet werden.
     
     <p>Wenn die <codeph>showDefaultContextMenu</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt ist (die Standardeinstellung), werden alle Elemente des Kontextmenüs eingeblendet. Wenn die <codeph>showDefaultContextMenu</codeph>-Eigenschaft auf <codeph>false</codeph> gesetzt ist, werden nur die Befehle „Einstellungen“ und „Über Adobe Flash Player“ angezeigt.</p>
     
 	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageFocusRect:get"><apiName>stageFocusRect</apiName><shortdesc>
	 Bestimmt, ob Objekte mit leuchtendem Rahmen angezeigt werden, wenn sie den Fokus besitzen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>stageFocusRect</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Bestimmt, ob Objekte mit leuchtendem Rahmen angezeigt werden, wenn sie den Fokus besitzen.
	 
 	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Bestimmt, ob Objekte mit leuchtendem Rahmen angezeigt werden, wenn sie den Fokus besitzen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageHeight:get"><apiName>stageHeight</apiName><shortdesc>
     Die aktuelle Höhe der Bühne in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>stageHeight</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Die aktuelle Höhe der Bühne in Pixel.
     
     <p>Wenn der Wert der <codeph>Stage.scaleMode</codeph>-Eigenschaft auf <codeph>StageScaleMode.NO_SCALE</codeph> eingestellt ist und der Benutzer die Fenstergröße ändert, behält der Bühneninhalt seine definierte Größe bei, während die <codeph>stageHeight</codeph>-Eigenschaft sich ändert und dann der neuen Höhe des Bildschirmbereichs entspricht, in dem die SWF-Datei angezeigt wird. (Bei den anderen Skalierungsmodi entspricht die <codeph>stageHeight</codeph>-Eigenschaft immer der Originalhöhe der SWF-Datei.) Sie können einen Ereignis-Listener für das <codeph>resize</codeph>-Ereignis hinzufügen und dann über die <codeph>stageHeight</codeph>-Eigenschaft der Stage-Klasse die tatsächlichen Pixelabmessungen des Flash Player-Fensters bestimmen, dessen Größe geändert wurde. Über den Ereignis-Listener können Sie steuern, wie der Bildschirminhalt angepasst wird, wenn der Benutzer die Fenstergröße ändert.</p>
	 
	 <p><b>Hinweis:</b> Auf einer HTML-Seite, die die SWF-Datei enthält, muss für die beiden Tags <codeph>object</codeph> und <codeph>embed</codeph> das zugehörige <codeph>height</codeph>-Attribut auf einen Prozentwert eingestellt werden (wie <codeph>100 %</codeph>), nicht auf Pixel. Wenn die Einstellungen von JavaScript-Code generiert werden, muss der <codeph>height</codeph>-Parameter der <codeph>AC_FL_RunContent()</codeph>-Methode ebenfalls auf einen Prozentwert eingestellt werden. Dieser Prozentsatz wird auf den Wert von <codeph>stageHeight</codeph> angewendet.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:stageWidth:get"><apiName>stageWidth</apiName><shortdesc>
     Bestimmt die aktuelle Breite der Bühne in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Durch Aufrufen der <codeph>stageWidth</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Bestimmt die aktuelle Breite der Bühne in Pixel.
     
     
     <p>Wenn der Wert der <codeph>Stage.scaleMode</codeph>-Eigenschaft auf <codeph>StageScaleMode.NO_SCALE</codeph> eingestellt ist und der Benutzer die Fenstergröße ändert, behält der Bühneninhalt seine definierte Größe bei, während die <codeph>stageWidth</codeph>-Eigenschaft sich ändert und dann der neuen Breite des Bildschirmbereichs entspricht, in dem die SWF-Datei angezeigt wird. (Bei den anderen Skalierungsmodi entspricht die <codeph>stageWidth</codeph>-Eigenschaft immer der Originalbreite der SWF-Datei.) Sie können einen Ereignis-Listener für das <codeph>resize</codeph>-Ereignis hinzufügen und dann über die <codeph>stageWidth</codeph>-Eigenschaft der Stage-Klasse die tatsächlichen Pixelabmessungen des Flash Player-Fensters bestimmen, dessen Größe geändert wurde. Über den Ereignis-Listener können Sie steuern, wie der Bildschirminhalt angepasst wird, wenn der Benutzer die Fenstergröße ändert.</p>
	 
     <p><b>Hinweis:</b> Auf einer HTML-Seite, die die SWF-Datei enthält, muss für die beiden Tags <codeph>object</codeph> und <codeph>embed</codeph> das zugehörige <codeph>width</codeph>-Attribut auf einen Prozentwert eingestellt werden (wie <codeph>100 %</codeph>), nicht auf Pixel. Wenn die Einstellungen von JavaScript-Code generiert werden, muss der <codeph>width</codeph>-Parameter der <codeph>AC_FL_RunContent()</codeph>-Methode ebenfalls auf einen Prozentwert eingestellt werden. Dieser Prozentsatz wird auf den Wert von <codeph>stageWidth</codeph> angewendet.</p>
     
 	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Tabulatortaste aktivierbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Durch das Verweisen auf die <codeph>tabChildren</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Bestimmt, ob die dem Objekt untergeordneten Objekte per Tabulatortaste aktivierbar sind. Aktiviert oder deaktiviert die Möglichkeit zur Auswahl von untergeordneten Objekten mithilfe der Tabulatortaste. Der Standardwert lautet <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
	 
     Liefert ein TextSnapshot-Objekt für diese DisplayObjectContainer-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier><apiException><apiDesc>Ein Verweis auf die <codeph>textSnapshot</codeph>-Eigenschaft eines Stage-Objekts löst eine Ausnahme aus, da diese Eigenschaft nicht in der Stage-Klasse implementiert ist. Um dies zu verhindern, rufen Sie die <codeph>textSnapshot</codeph>-Eigenschaft eines Anzeigeobjekt-Containers auf, der nicht das Stage-Objekt ist.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Liefert ein TextSnapshot-Objekt für diese DisplayObjectContainer-Instanz.
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:width:get"><apiName>width</apiName><shortdesc>
	 
     Gibt die Breite des Anzeigeobjekts in Pixeln an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Durch das Verweisen auf die <codeph>width</codeph>-Eigenschaft eines Stage-Objekts wird für jeden Aufrufer, der sich nicht in derselben Sicherheits-Sandbox wie der Bühneneigentümer (die Haupt-SWF-Datei) befindet, eine Ausnahme ausgelöst. Um dies zu verhindern, kann der Bühneneigentümer der Domäne des Aufrufers die entsprechende Berechtigung erteilen, indem er die Methode <codeph>Security.allowDomain()</codeph> oder <codeph>Security.allowInsecureDomain()</codeph> aufruft. Weitere Informationen finden Sie im Kapitel „Sicherheit“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Es ist niemals zulässig, die <codeph>width</codeph>-Eigenschaft eines Stage-Objekts zu setzen, selbst wenn Sie der Bühneneigentümer sind.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Gibt die Breite des Anzeigeobjekts in Pixeln an. Die Breite wird auf Basis der Begrenzungen des Inhalts des Anzeigeobjekts berechnet. Wenn Sie die Eigenschaft <codeph>width</codeph> festsetzen, wird die Eigenschaft <codeph>scaleX</codeph> entsprechend angepasst, wie im folgenden Code gezeigt.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>Abgesehen von TextField- und Video-Objekten, hat ein Anzeigeobjekt ohne Inhalt (z. B. ein leeres Sprite) eine Breite von 0, selbst wenn Sie versuchen, <codeph>width</codeph> auf einen anderen Wert zu setzen.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:wmodeGPU:get"><apiName>wmodeGPU</apiName><shortdesc>
	 Gibt an, ob GPU-Compositing verfügbar ist und verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob GPU-Compositing verfügbar ist und verwendet wird. Der Wert von <codeph>wmodeGPU</codeph> ist <i>nur</i> dann <codeph>true</codeph>, wenn alle drei der folgenden Bedingungen erfüllt sind:
	 <p><ul><li>GPU-Compositing wurde angefordert.</li>
	 <li>GPU-Compositing ist verfügbar.</li>
	 <li>GPU-Compositing wird verwendet.</li></ul></p>
	 <p>Insbesondere die <codeph>wmodeGPU</codeph>-Eigenschaft gibt einen der folgenden Fälle an:</p>
	 <p><ol><li>GPU-Compositing wurde nicht angefordert oder ist nicht verfügbar. In diesem Fall hat die <codeph>wmodeGPU</codeph>-Eigenschaft den Wert <codeph>false</codeph>.</li>
	 <li>GPU-Compositing wurde angefordert (falls zutreffend und verfügbar), die Umgebung arbeitet aufgrund von Einschränkungen des Inhalts jedoch im „Fallbackmodus“ (keine optimale Darstellung). In diesem Fall hat die <codeph>wmodeGPU</codeph>-Eigenschaft den Wert <codeph>true</codeph>.</li>
	 <li>GPU-Compositing wurde angefordert (falls zutreffend und verfügbar), die Umgebung arbeitet im besten Modus. In diesem Fall hat die <codeph>wmodeGPU</codeph>-Eigenschaft ebenfalls den Wert <codeph>true</codeph>.</li></ol></p>
	 <p>Anders ausgedrückt identifiziert die <codeph>wmodeGPU</codeph>-Eigenschaft die Fähigkeiten und den Status der Darstellungsumgebung. Bei Laufzeitumgebungen, die GPU-Compositing nicht unterstützen, wie AIR 1.5.2, ist der Wert immer <codeph>false</codeph>, da (wie oben beschrieben) der Wert nur dann <codeph>true</codeph> ist, wenn GPU-Compositing angefordert wurde, verfügbar ist und verwendet wird.</p>
	 <p>Die <codeph>wmodeGPU</codeph>-Eigenschaft ist hilfreich, um zur Laufzeit festzustellen, ob GPU-Compositing verwendet wird oder nicht. Der Wert von <codeph>wmodeGPU</codeph> gibt an, ob Ihr Inhalt von der Hardware skaliert wird oder nicht, sodass Sie Grafiken in der richtigen Größe präsentieren können. Sie können auch feststellen, ob Sie über einen schnellen Pfad rendern oder nicht, sodass Sie die Komplexität Ihrer Inhalte entsprechend anpassen können.</p>
	 <p>Für Flash Player, der in einem Browser ausgeführt wird, kann GPU-Compositing durch den Wert <codeph>gpu</codeph> für den <codeph>wmode</codeph>-HTML-Parameter auf der Seite, die den SWF-Datei hostet, angefordert werden. Bei anderen Konfigurationen kann GPU-Compositing im Header einer SWF-Datei angefordert werden (die Einstellung erfolgt über SWF-Authoring-Tools).</p>	 
	 <p>Die <codeph>wmodeGPU</codeph>-Eigenschaft identifiziert nicht die aktuelle Renderingleistung. Auch wenn GPU-Compositing „verwendet wird“, läuft der Renderingvorgang nicht unbedingt im besten Modus. Um den Inhalt für die optimale Darstellung anzupassen, verwenden Sie eine Debugger-Version einer Flash-Laufzeitumgebung und stellen Sie <codeph>DisplayGPUBlendsetting</codeph> in Ihrer Datei „mm.cfg“ ein.</p>
	 
	 <p><b>Hinweis:</b> Diese Eigenschaft hat immer den Wert <codeph>false</codeph>, wenn aus ActionScript darauf verwiesen wird, das ausgeführt wird, bevor die Laufzeitumgebung ihren ersten Renderingdurchgang ausführt. Wenn Sie <codeph>wmodeGPU</codeph> zum Beispiel von einem Skript in Bild 1 in Adobe Flash Professional untersuchen und Ihre SWF-Datei die erste SWF-Datei ist, die in eine neue Instanz der Laufzeitumgebung geladen wird, ist hat <codeph>wmodeGPU</codeph> den Wert <codeph>false</codeph>. Um einen genauen Wert zu erhalten, warten Sie, bis wenigstens ein Renderingdurchgang erfolgt ist. Wenn Sie einen Ereignis-Listener für das <codeph>exitFrame</codeph>-Eigenschaft eines <codeph>DisplayObject</codeph> schreiben, hat <codeph>wmodeGPU</codeph> den korrekten Wert.</p>
	 
	 </apiDesc><example conref="examples\Stage.wmodeGPU.as"> Im folgenden Beispiel wird die <codeph>wmodeGPU</codeph>-Eigenschaft untersucht, nachdem das mySprite-Anzeigeobjekt gerendert wurde, sodass Sie einen genauen Wert erhalten.
<codeblock>
mySprite.addEventListener(EXIT_FRAME, exithandler):

function exithandler(exiteventobject:Event):void {
                trace(stage.wmodeGPU);
}
</codeblock></example></apiValueDetail><related-links><link href="DisplayObject.html#event:exitFrame"><linktext>DisplayObject-exitFrame-Ereignis</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	 Die NativeWindowInitOptions-Klasse definiert die Initialisierungsoptionen, die für die Erstellung einer neuen NativeWindow-Instanz verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die NativeWindowInitOptions-Klasse definiert die Initialisierungsoptionen, die für die Erstellung einer neuen NativeWindow-Instanz verwendet werden. 
	 <p>Die in den Initialisierungsoptionen definierten Eigenschaften können nach der Erstellung eines Fensters nicht mehr geändert werden.</p>
	 
	 <p><b>Hinweis:</b> Für das von AIR automatisch erstellte erste Anwendungsfenster sind alle diese Eigenschaften (mit Ausnahme von <codeph>type</codeph>) im Anwendungsdeskriptor festgelegt. Das ursprüngliche Fenster hat immer den Typ normal.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links><apiConstructor id="flash.display:NativeWindowInitOptions:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	    Erstellt ein neues NativeWindowInitOptions-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	    Erstellt ein neues NativeWindowInitOptions-Objekt.
	    
        <p>Die Standardwerte des neu erstellten Objekts lauten:</p>
	    <ul>
        <li><codeph>systemChrome = NativeWindowSystemChrome.STANDARD</codeph></li>
        <li><codeph>type = NativeWindowType.NORMAL</codeph></li>
	    <li><codeph>transparent = false</codeph></li>
	    <li><codeph>resizable = true</codeph></li>
	    <li><codeph>maximizable = true</codeph></li>
	    <li><codeph>minimizable = true</codeph></li>
	    </ul>
	    
	    </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:NativeWindowInitOptions:maximizable:get"><apiName>maximizable</apiName><shortdesc>
		 Legt fest, ob ein Fenster durch den Benutzer maximiert werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MAXIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Legt fest, ob ein Fenster durch den Benutzer maximiert werden kann.  
		 
		 <p>
		 Bei Fenstern mit Systemchrom beeinflusst diese Einstellung die Darstellung der Maximierungsschaltfläche des Fensters. Sie beeinflusst zudem andere Teile der systemverwalteten Benutzeroberfläche, wie das Fenster-Menü unter Microsoft Windows.
		 </p>
		 
		 <p>
		 Wenn diese Eigenschaft auf <codeph>false</codeph> gesetzt ist, kann das Fenster durch den Benutzer nicht maximiert werden. Durch das Aufrufen der <codeph>maximize()</codeph>-Methode von NativeWindow wird das Fenster unmittelbar maximiert.
		 </p>
		 
		 <p><b>Hinweis:</b> Unter Betriebssystemen wie Mac OS X, bei denen eine Maximierung des Fensters die Größenänderung nicht verhindert, müssen sowohl <codeph>maximizable</codeph> als auch <codeph>resizable</codeph> auf <codeph>false</codeph> eingestellt werden, um zu verhindern, dass die Fenstergröße geändert wird.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:minimizable:get"><apiName>minimizable</apiName><shortdesc>
		 Legt fest, ob ein Fenster durch den Benutzer minimiert werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MINIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Legt fest, ob ein Fenster durch den Benutzer minimiert werden kann.
		 
		 <p>
		 Bei Fenstern mit Systemchrom beeinflusst diese Einstellung die Darstellung der Minimierungsschaltfläche des Fensters. Sie beeinflusst zudem andere Teile der systemverwalteten Benutzeroberfläche, wie das Fenster-Menü unter Microsoft Windows.
		 </p>
		 
		 <p>
		 Wenn diese Eigenschaft auf <codeph>false</codeph> gesetzt ist, kann das Fenster durch den Benutzer nicht minimiert werden. Durch das Aufrufen der <codeph>minimize()</codeph>-Methode von NativeWindow wird das Fenster unmittelbar minimiert.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:resizable:get"><apiName>resizable</apiName><shortdesc>
		 Legt fest, ob die Fenstergröße durch den Benutzer geändert werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_SIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Legt fest, ob die Fenstergröße durch den Benutzer geändert werden kann.
		 
		 <p>
		 Wenn diese Eigenschaft auf <codeph>false</codeph> gesetzt ist, kann die Fenstergröße durch einen Benutzer, der Systemchrom verwendet, nicht geändert werden. Durch Aufrufen der <codeph>startResize()</codeph>-Methode von NativeWindow als Antwort auf ein Mausereignis kann der Benutzer die Größe des Fensters ändern. Die Fenstergröße kann auch durch das direkte Setzen der Fenstergrenzen geändert werden.
		 </p>
		 
		 <p><b>Hinweis:</b> Unter Betriebssystemen wie Mac OS X, bei denen die Fenstermaximierung eine Größenänderungsoperation ist, müssen sowohl <codeph>maximizable</codeph> als auch <codeph>resizable</codeph> auf <codeph>false</codeph> eingestellt werden, um zu verhindern, dass die Fenstergröße geändert wird.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
		 Legt fest, ob Systemchrom für das Fenster zur Verfügung steht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowSystemChrome.STANDARD
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Legt fest, ob Systemchrom für das Fenster zur Verfügung steht. 
		  
		 <p> Chrom bezieht sich auf die Fenstersteuerungen, über die der Benutzer die Desktop-Eigenschaften eines Fensters steuern kann. Das Systemchrom verwendet die Standardsteuerungen der Desktop-Umgebung, in der die AIR-Anwendung ausgeführt wird, und entspricht der standardmäßigen Gestaltung des nativen Betriebssystems.</p>
		 <p>
		 Um von einem Framework (wie Flex) bereitgestelltes Chrom zu verwenden oder um eigenes Fensterchrom anzugeben, stellen Sie <codeph>systemChrome</codeph> auf <codeph>NativeWindowSystemChrome.NONE</codeph> ein.
		 </p>
		 <p>Konstanten für die gültigen Werte dieser Eigenschaft sind in der NativeWindowSystemChrome-Klasse definiert:
         </p>
		 <ul>
         <li><codeph>NativeWindowSystemChrome.NONE</codeph></li>
		 <li><codeph>NativeWindowSystemChrome.STANDARD</codeph></li>
		 </ul>
		 
		 <p>Wird keine Angabe gemacht, gilt für <codeph>systemChrome</codeph> der Standardwert <codeph>NativeWindowSystemChrome.STANDARD</codeph>.
		 </p>
		 
		 <p>Bei Fenstern mit Systemchrom kann die <codeph>transparent</codeph>-Eigenschaft nicht auf <codeph>true</codeph> gesetzt werden.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:transparent:get"><apiName>transparent</apiName><shortdesc>
		 Gibt an, ob das Fenster Transparenz und Alpha-Blending zum Desktop unterstützt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
		 
	     </apiDefaultValue></apiValueDef><apiDesc>
		 Gibt an, ob das Fenster Transparenz und Alpha-Blending zum Desktop unterstützt.
		 
		 <p>
		 Bei der Einstellung <codeph>true</codeph> wird die Fensteranzeige vor dem Desktop zusammengesetzt. Fensterbereiche, die nicht von einem Anzeigeobjekt bedeckt werden oder die von einem Anzeigeobjekt mit einer Alpha-Einstellung von fast Null bedeckt werden, sind praktisch unsichtbar und erfassen keine Mausereignisse (die Mausereignisse werden von dem Desktop-Objekt unter dem Fenster empfangen). Der Alpha-Wert, bei dem ein Objekt keine Mausereignisse mehr erfasst, liegt je nach Betriebssystem zwischen ca. 0,06 und 0,01.
		 </p>  
		 
		 <p>Bei Fenstern mit Systemchrom kann die <codeph>transparent</codeph>-Eigenschaft nicht auf <codeph>true</codeph> gesetzt werden.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowInitOptions:type:get"><apiName>type</apiName><shortdesc>
		 Gibt den Typ des zu erstellenden Fensters an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowType.NORMAL
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Gibt den Typ des zu erstellenden Fensters an.  
		 
		 <p>Konstanten für die gültigen Werte dieser Eigenschaft sind in der NativeWindowType-Klasse definiert:
         </p>
         
		 <ul>
		 <li><codeph>NativeWindowType.NORMAL</codeph>: Ein typisches Fenster. Normale Fenster verwenden das Chrom in voller Größe und werden in der Windows- oder Linux-Taskleiste und im Menü „Fenster“ von Mac OS X angezeigt.</li>
		 
		 <li><codeph>NativeWindowType.UTILITY</codeph>: Eine Werkzeugpalette. Dienstfenster verwenden eine schmalere Version des Systemchroms und werden nicht in der Windows-Taskleiste und im Menü „Fenster“ von Mac OS X angezeigt.</li>
		 
		 <li><codeph>NativeWindowType.LIGHTWEIGHT</codeph>: Lightweight-Fenster können kein Systemchrom verwenden und werden nicht in der Windows-Taskleiste und im Menü „Fenster“ von Mac OS X angezeigt. Zudem verfügen Lightweight-Fenster nicht über das System-Menü (Alt+Leertaste) unter Windows. Lightweight-Fenster eignen sich für Benachrichtigungen und Steuerungen wie Kombinationsfelder, die einen Anzeigebereich öffnen, der nur für einen kurzen Zeitraum eingeblendet wird. Bei Verwendung des Lightweight-Typs muss <codeph>systemChrome</codeph> auf <codeph>none</codeph> eingestellt werden.</li>
		 </ul>
		 
		 <p>
		 Wenn kein Wert angegeben wird, hat <codeph>type</codeph> den Standardwert <codeph>NativeWindowType.NORMAL</codeph>.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
	 Eine ShaderParameter-Instanz stellt einen einzelnen Eingabeparameter für ein Shaderkernel dar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Eine ShaderParameter-Instanz stellt einen einzelnen Eingabeparameter für ein Shaderkernel dar. Ein Kernel kann so definiert sein, dass es null, einen oder mehrere Parameter akzeptiert, die bei der Kernelausführung verwendet werden. Ein ShaderParameter stellt Informationen zum Parameter bereit, z. B. welcher Datentyp erwartet wird. Er stellt auch einen Mechanismus für das Einstellen des Parameterwerts, der bei der Shaderausführung verwendet wird, bereit. Um einen oder mehrere Werte für den Shaderparameter anzugeben, erstellen Sie ein Array mit dem Wert bzw. den Werten und weisen es der <codeph>value</codeph>-Eigenschaft zu.
	 
	 <p>Auf eine ShaderParameter-Instanz, die einen Parameter für eine Shader-Instanz darstellt, wird als Eigenschaft der <codeph>data</codeph>-Eigenschaft der Shader-Instanz zugegriffen. Der Name der ShaderParameter-Eigenschaft ist derselbe wie der Parametername im Shadercode. Wenn beispielsweise in einem Shader ein Parameter namens <codeph>radius</codeph> definiert ist, ist die ShaderParameter-Instanz, die den <codeph>radius</codeph>-Parameter darstellt, als <codeph>radius</codeph>-Eigenschaft verfügbar, wie hier zu sehen ist:</p>
	 
	 <codeblock>var radiusParam:ShaderParameter = myShader.data.radius;</codeblock>
	 
	 <p>Zusätzlich zu den definierten Eigenschaften der ShaderParameter-Klasse hat jede ShaderParameter-Instanz weitere Eigenschaften, die den für den Parameter festgelegten Metadaten entsprechen. Diese Eigenschaften werden dem ShaderParameter-Objekt bei der Erstellung hinzugefügt. Die Namen der Eigenschaften stimmen mit den im Shaderquellcode festgelegten Metadatennamen überein. Der Datentyp der Eigenschaft hängt vom Datentyp der jeweils entsprechenden Metadaten ab. Ein Textmetadatenwert wie etwa „description“ ist eine String-Instanz. Eine Metadateneigenschaft mit einem Wert, der kein String ist (wie z. B. <codeph>minValue</codeph> oder <codeph>defaultValue</codeph>) wird als Array-Instanz dargestellt. Die Anzahl an Elementen und Elementdatentypen entspricht den Metadatenwerten.</p>
	 
	 <p>Gehen Sie etwa von einem Shader mit den folgenden beiden Parameterdeklarationen aus:</p>
	 
	 <codeblock>
	 parameter float2 size
	 &lt;
	     description: "The size of the image to which the kernel is applied";
	     minValue: float2(0.0, 0.0);
	     maxValue: float2(100.0, 100.0);
	     defaultValue: float2(50.0, 50.0);
	 >;
	 
	 parameter float radius
	 &lt;
	     description: "The radius of the effect";
	     minValue: 0.0;
	     maxValue: 50.0;
	     defaultValue: 25.0;
	 >;
	 </codeblock>
	 
	 <p>Die dem <codeph>size</codeph>-Parameter entsprechende ShaderParameter-Instanz verfügt zusätzlich zu ihren integrierten Eigenschaften über die folgenden Metadateneigenschaften:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Eigenschaftsname</entry><entry>Datentyp</entry><entry>Wert</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"size"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"The size of the image to which the kernel is applied"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0, 0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[100, 100]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50, 50]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Der dem <codeph>radius</codeph>-Parameter entsprechende ShaderParameter hat die folgenden zusätzlichen Eigenschaften:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Eigenschaftsname</entry><entry>Datentyp</entry><entry>Wert</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"radius"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"The radius of the effect"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[25]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Im Allgemeinen wird eine ShaderParameter-Instanz nicht direkt durch Entwicklercode erstellt. Bei der Erstellung der Shader-Instanz wird für jeden Shaderparameter eine ShaderParameter-Instanz erstellt.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links><apiConstructor id="flash.display:ShaderParameter:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
		 Erstellt eine ShaderParameter-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Erstellt eine ShaderParameter-Instanz. Der ShaderParameter-Konstruktor wird nicht direkt durch den Entwicklercode aufgerufen. Bei der Erstellung der Shader-Instanz wird für jeden Shaderparameter eine ShaderParameter-Instanz erstellt.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderParameter:index:get"><apiName>index</apiName><shortdesc>
         Die auf null basieremde Indexposition des Parameters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Die auf null basieremde Indexposition des Parameters.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameter:type:get"><apiName>type</apiName><shortdesc>
		Der Datentyp des Parameters, wie im Shader definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Der Datentyp des Parameters, wie im Shader definiert. Der Satz der möglichen Werte für die <codeph>type</codeph>-Eigenschaft wird durch die Konstanten in der ShaderParameterType-Klasse definiert.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameterType"><linktext>flash.display.ShaderParameterType</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameter:value:get"><apiName>value</apiName><shortdesc>
		Der Wert bzw. die Werte, die als Parameterwerte an den Shader übergeben werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		Der Wert bzw. die Werte, die als Parameterwerte an den Shader übergeben werden. Die <codeph>value</codeph>-Eigenschaft ist ein indiziertes Array. Anzahl und Typ der Elemente im Array entsprechen dem Datentyp des Parameters, der mithilfe der <codeph>type</codeph>-Eigenschaft festgelegt wird.
		
		<p>Die folgende Tabelle zeigt den Parametertyp und die zugehörige Anzahl sowie den zugehörigen Datentyp der Elemente im <codeph>value</codeph>-Arrays an:</p>
		
		<adobetable class="innertable">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		<tgroup cols="3"><thead><row><entry>Parametertyp</entry><entry>Anzahl Elemente</entry><entry>Datentyp Elemente</entry></row></thead><tbody><row>
		  <entry>float (<codeph>ShaderParameterType.FLOAT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float2 (<codeph>ShaderParameterType.FLOAT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3 (<codeph>ShaderParameterType.FLOAT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4 (<codeph>ShaderParameterType.FLOAT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>int (<codeph>ShaderParameterType.INT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>int oder uint</entry>
		</row><row>
		  <entry>int2 (<codeph>ShaderParameterType.INT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>int oder uint</entry>
		</row><row>
		  <entry>int3 (<codeph>ShaderParameterType.INT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>int oder uint</entry>
		</row><row>
		  <entry>int4 (<codeph>ShaderParameterType.INT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>int oder uint</entry>
		</row><row>
		  <entry>bool (<codeph>ShaderParameterType.BOOL</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Boolescher Ausdruck</entry>
		</row><row>
		  <entry>bool2 (<codeph>ShaderParameterType.BOOL2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Boolescher Ausdruck</entry>
		</row><row>
		  <entry>bool3 (<codeph>ShaderParameterType.BOOL3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Boolescher Ausdruck</entry>
		</row><row>
		  <entry>bool4 (<codeph>ShaderParameterType.BOOL4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Boolescher Ausdruck</entry>
		</row><row>
		  <entry>float2x2 (<codeph>ShaderParameterType.MATRIX2X2</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3x3 (<codeph>ShaderParameterType.MATRIX3X3</codeph>)</entry>
		  <entry>9</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4x4 (<codeph>ShaderParameterType.MATRIX4X4</codeph>)</entry>
		  <entry>16</entry>
		  <entry>Number</entry>
		</row></tbody></tgroup></adobetable>
		
		<p>Bei den Matrixparametertypen füllen die Arrayelemente zuerst die Zeilen der Matrix, dann die Spalten aus. Angenommen, mit der folgenden Zeile ActionScript-Code soll ein <codeph>2x2</codeph>-Parameter namens <codeph>myMatrix</codeph> gefüllt werden:</p>
		
		<codeblock>myShader.data.myMatrix.value = [.1, .2, .3, .4];</codeblock>
		
		<p>Im Shader haben die Matrixelemente die folgenden Werte:</p>
		
		<ul>
		  <li><codeph>myMatrix[0][0]</codeph>: .1</li>
		  <li><codeph>myMatrix[0][1]</codeph>: .2</li>
		  <li><codeph>myMatrix[1][0]</codeph>: .3</li>
		  <li><codeph>myMatrix[1][1]</codeph>: .4</li>
		</ul>
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GradientType"><apiName>GradientType</apiName><shortdesc>
Die GradientType-Klasse stellt Werte für den Parameter „type“ in den Methoden „beginGradientFill()“ und „lineGradientStyle()“ der flash.display.Graphics-Klasse bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die GradientType-Klasse stellt Werte für den Parameter <codeph>type</codeph> in den Methoden <codeph>beginGradientFill()</codeph> und <codeph>lineGradientStyle()</codeph> der flash.display.Graphics-Klasse bereit.

</apiDesc></apiClassifierDetail><apiValue id="flash.display:GradientType:LINEAR"><apiName>LINEAR</apiName><shortdesc>
	Ein Wert, der zur Festlegung einer linearen Farbverlaufsfüllung verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linear</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Ein Wert, der zur Festlegung einer linearen Farbverlaufsfüllung verwendet wird.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GradientType:RADIAL"><apiName>RADIAL</apiName><shortdesc>
	Ein Wert, der zur Festlegung einer radialen Farbverlaufsfüllung verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>radial</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Ein Wert, der zur Festlegung einer radialen Farbverlaufsfüllung verwendet wird.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InterpolationMethod"><apiName>InterpolationMethod</apiName><shortdesc>
Die InterpolationMethod-Klasse stellt für den Parameter „interpolationMethod“ in den Methoden „Graphics.beginGradientFill()“ und „Graphics.lineGradientStyle()“ Werte bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die InterpolationMethod-Klasse stellt für den Parameter <codeph>interpolationMethod</codeph> in den Methoden <codeph>Graphics.beginGradientFill()</codeph> und <codeph>Graphics.lineGradientStyle()</codeph> Werte bereit. Dieser Parameter bestimmt den RGB-Farbraum, der für die Darstellung des Farbverlaufs verwendet werden soll. 

 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:InterpolationMethod:LINEAR_RGB"><apiName>LINEAR_RGB</apiName><shortdesc>
	Legt fest, dass die lineare RGB-Interpolationsmethode verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linearRGB</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Legt fest, dass die lineare RGB-Interpolationsmethode verwendet werden soll. Dies bedeutet, dass ein RGB-Farbraum auf Basis eines linearen RGB-Farbmodells verwendet wird. 
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/RGB"><linktext>RGB</linktext></link></related-links></apiValue><apiValue id="flash.display:InterpolationMethod:RGB"><apiName>RGB</apiName><shortdesc>
	Legt fest, dass die RGB-Interpolationsmethode verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>rgb</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Legt fest, dass die RGB-Interpolationsmethode verwendet werden soll. Dies bedeutet, dass der Farbverlauf mit dem exponentiellen sRGB-Farbraum (Standard-RGB) dargestellt wird. Der sRGB-Raum ist ein vom W3C zugelassener Standard, der eine nicht lineare Konvertierung zwischen den Komponentenwerten Rot, Grün und Blau und der Intensität der sichtbaren Komponentenfarbe definiert.
	
	<p>Angenommen, Sie haben einen einfachen linearen Farbverlauf zwischen zwei Farben (wobei der Parameter <codeph>spreadMethod</codeph> auf <codeph>SpreadMethod.REFLECT</codeph> gesetzt ist). Die verschiedenen Interpolationsmethoden haben folgende Auswirkung auf die Darstellung des Farbverlaufs: </p>
	
		<adobetable>
		
      
		
		
		
		<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="Linearer Farbverlauf mit InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
		</row><row>
		<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
		<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
		</row></tbody></tgroup></adobetable>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/LINEAR_RGB"><linktext>LINEAR_RGB</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsPath"><apiName>IGraphicsPath</apiName><shortdesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Pfadparameter in der flash.display.Graphics-Methode und Klassen für das Zeichnen verwendet werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Pfadparameter in der flash.display.Graphics-Methode und Klassen für das Zeichnen verwendet werden können. Verwenden Sie Klassen, die diese Schnittstelle implementieren, um Pfadeigenschaftsdaten zu erstellen und zu verwalten und dieselben Daten in verschiedenen Instanzen wiederzuverwenden.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:IGraphicsFill"><apiName>IGraphicsFill</apiName><shortdesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Füllparameter in der flash.display.Graphics-Methode und Klassen für das Zeichnen verwendet werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Füllparameter in der flash.display.Graphics-Methode und Klassen für das Zeichnen verwendet werden können. Verwenden Sie Klassen, die diese Schnittstelle implementieren, um Fülleigenschaftsdaten zu erstellen und zu verwalten und dieselben Daten in verschiedenen Instanzen wiederzuverwenden.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#GraphicsStroke/fill"><linktext>flash.display.GraphicsStroke.fill</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:LoaderInfo"><apiName>LoaderInfo</apiName><shortdesc>
 Die LoaderInfo-Klasse liefert Informationen zu einer geladenen SWF- oder Grafikdatei (JPEG, GIF oder PNG).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion><Exclude kind="method" name="dispatchEvent"/></asMetadata><asCustoms><internal>Update the places LoaderInfo can be obtained from (playerglobal.as) and double-check loader vs. loadee.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die LoaderInfo-Klasse liefert Informationen zu einer geladenen SWF- oder Grafikdatei (JPEG, GIF oder PNG). LoaderInfo-Objekte sind für jedes Anzeigeobjekt verfügbar. Die bereitgestellten Informationen sind Ladefortschritt, die URLs des Loaders und des geladenen Inhalts, Gesamtanzahl der Bytes für das Medium und die nominelle Höhe und Breite des Mediums.
 
 <p>Sie haben zwei Möglichkeiten, LoaderInfo-Objekte zu laden: </p>
 
 <ul>
 
 	<li>Über die <codeph>contentLoaderInfo</codeph>-Eigenschaft des flash.display.Loader-Objekts. Die <codeph>contentLoaderInfo</codeph>-Eigenschaft ist für jedes Loader-Objekt stets verfügbar. Wenn ein Loader-Objekt, das weder die <codeph>load()</codeph>-Methode noch die <codeph>loadBytes()</codeph>-Methode aufgerufen hat oder dessen Ladevorgang noch nicht weit genug vorangeschritten ist, versucht, auf Eigenschaften der <codeph>contentLoaderInfo</codeph>-Eigenschaft zuzugreifen, wird für viele Eigenschaften ein Fehler ausgelöst.</li>
 
 	<li>Über die <codeph>loaderInfo</codeph>-Eigenschaft eines Anzeigeobjekts. </li>
 
 </ul>
 
 <p>Die <codeph>contentLoaderInfo</codeph>-Eigenschaft eines Loader-Objekts liefert Informationen zum Inhalt, der vom Loader-Objekt geladen wird, während die <codeph>loaderInfo</codeph>-Eigenschaft eines Anzeigeobjekts Informationen zur SWF-Stammdatei für dieses Anzeigeobjekt liefert. </p>
 
 <p>Wenn Sie ein Loader-Objekt zum Laden eines Anzeigeobjekts (z. B. einer SWF-Datei oder Bitmap) verwenden, ist die <codeph>loaderInfo</codeph>-Eigenschaft des Anzeigeobjekts identisch mit der <codeph>contentLoaderInfo</codeph>-Eigenschaft des Loader-Objekts (<codeph>DisplayObject.loaderInfo = Loader.contentLoaderInfo</codeph>). Da die Instanz der Hauptklasse der SWF-Datei kein Loader-Objekt besitzt, besteht ihre einzige Möglichkeit, auf das LoaderInfo-Objekt zuzugreifen, in der <codeph>loaderInfo</codeph>-Eigenschaft.</p>
 
 <p>Das folgende Diagramm zeigt die verschiedenen Einsatzmöglichkeiten des LoaderInfo-Objekts, und zwar für die Instanz der Hauptklasse der SWF-Datei, für die <codeph>contentLoaderInfo</codeph>-Eigenschaft eines Loader-Objekts und für die <codeph>loaderInfo</codeph>-Eigenschaft eines geladenen Objekts:</p>
 
 <p>
 <adobeimage alt="Verschiedene Loaderinfo-Situationen" href="../../images/loaderInfo_object.jpg"/>
 </p>
 
 <p>Ist ein Ladevorgang noch nicht abgeschlossen, sind einige Eigenschaften der <codeph>contentLoaderInfo</codeph>-Eigenschaft eines Loader-Objekts nicht verfügbar. Einige Eigenschaften können Sie abrufen, z. B. <codeph>bytesLoaded</codeph>, <codeph>bytesTotal</codeph>, <codeph>url</codeph>, <codeph>loaderURL</codeph> und <codeph>applicationDomain</codeph>. Sobald das <codeph>loaderInfo</codeph>-Objekt das Ereignis <codeph>init</codeph> auslöst, können Sie auf alle Eigenschaften des <codeph>loaderInfo</codeph>-Objekts sowie der geladenen Grafik- oder SWF-Datei zugreifen.</p>
 
 <p><b>Hinweis:</b> Alle Eigenschaften der LoaderInfo-Objekte sind schreibgeschützt.</p>
 
 <p>Die <codeph>EventDispatcher.dispatchEvent()</codeph>-Methode gilt nicht für LoaderInfo-Objekte. Wenn Sie <codeph>dispatchEvent()</codeph> für ein LoaderInfo-Objekt aufrufen, wird eine IllegalOperationError-Ausnahme ausgelöst.</p>
 
 
 
 </apiDesc><example conref="examples\LoaderInfoExample.as"> Im folgenden Beispiel wird die LoaderInfoExample-Klasse verwendet, um auf der Bühne ein Bild anzuzeigen. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Es wird eine <codeph>url</codeph>-Eigenschaft erstellt, die den Speicherort und Namen der Bilddatei angibt.</li>
 
  <li>Der Klassenkonstruktor erstellt ein Loader-Objekt mit der Bezeichnung <codeph>loader</codeph>.</li>
 
  <li>Das <codeph>loader</codeph>-Objekt instanziiert einen Ereignis-Listener, um sicherzustellen, dass das Bild richtig geladen wird.</li>
 
  <li>Der Konstruktor erstellt eine neue Instanz eines URLRequest-Objekts, <codeph>request</codeph>, mit Übergabe von <codeph>url</codeph>, damit der Dateiname und -speicherort bekannt sind.</li>
 
  <li>Das <codeph>request</codeph>-Objekt wird an die <codeph>load()</codeph>-Methode des <codeph>loader</codeph>-Objekts übergeben, die das Bild in die Anzeigeliste lädt.</li>
 
 </ol>
 <p><b>Wichtig:</b> Zur Ausführung dieses Beispiels müssen Sie eine Datei mit dem Namen „Image.gif“ in dem Ordner ablegen, in dem sich auch die kompilierte SWF-Datei befindet. Verwenden Sie ein Bild mit einem Bereich, der in die Abmessungen der SWF-Hauptdatei passt.</p>
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.LoaderInfo;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderInfoExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderInfoExample() {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function initHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var info:LoaderInfo = LoaderInfo(loader.contentLoaderInfo);
            trace("initHandler: loaderURL=" + info.loaderURL + " url=" + info.url);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObject/loaderInfo"><linktext>flash.display.DisplayObject.loaderInfo</linktext></link></related-links><adobeApiEvent id="flash.display:LoaderInfo_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Wird ausgelöst, wenn eine Netzwerkanforderung über HTTP erfolgt und der HTTP-Statuscode erkannt werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn eine Netzwerkanforderung über HTTP erfolgt und der HTTP-Statuscode erkannt werden kann.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.UNLOAD_unload"><apiName>unload</apiName><shortdesc>
 Wird von einem LoaderInfo-Objekt ausgelöst, wenn ein geladenes Objekt mit der unload()-Methode des Loader-Objekts entfernt wird oder wenn von demselben Loader-Objekt ein zweiter Ladevorgang durchgeführt und der ursprüngliche Inhalt vor dem Ladebeginn entfernt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.UNLOAD</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird von einem LoaderInfo-Objekt ausgelöst, wenn ein geladenes Objekt mit der <codeph>unload()</codeph>-Methode des Loader-Objekts entfernt wird oder wenn von demselben Loader-Objekt ein zweiter Ladevorgang durchgeführt und der ursprüngliche Inhalt vor dem Ladebeginn entfernt wird.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>Loader.unload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Wird beim Start eines Ladevorgangs ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Start eines Ladevorgangs ausgelöst.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird beim Auftreten eines Eingabe- oder Ausgabefehlers ausgelöst, durch den der Ladevorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Auftreten eines Eingabe- oder Ausgabefehlers ausgelöst, durch den der Ladevorgang fehlschlägt. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.INIT_init"><apiName>init</apiName><shortdesc>
 Wird ausgelöst, wenn die Eigenschaften und Methoden einer geladenen SWF-Datei zugänglich sind und verwendet werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.INIT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn die Eigenschaften und Methoden einer geladenen SWF-Datei zugänglich sind und verwendet werden können. Es kann jedoch sein, dass der Inhalt noch immer heruntergeladen wird. Ein LoaderInfo-Objekt löst das <codeph>init</codeph>-Ereignis aus, wenn die folgenden Bedingungen erfüllt sind:
 <ul>
     <li>Alle dem geladenen Objekt und dem LoaderInfo-Objekt zugeordneten Eigenschaften und Methoden sind zugänglich.</li>
     <li>Die Konstruktoren für alle untergeordneten Objekte sind abgeschlossen.</li>
     <li>Der gesamte ActionScript-Code im ersten Bild der Hauptzeitleiste der geladenen SWF-Datei wurde ausgeführt.</li>
 </ul>
 
 <p>Zum Beispiel wird ein <codeph>Event.INIT</codeph>-Ereignis ausgelöst, wenn das erste Bild eines Films oder einer Animation geladen wird. Der Film ist dann zugänglich und kann der Anzeigeliste hinzugefügt werden. Es kann jedoch länger dauern, bis der gesamte Film heruntergeladen wurde. <codeph>Event.COMPLETE</codeph> wird erst ausgelöst, wenn der gesamte Film geladen wurde.</p>
 
 <p>Das Ereignis <codeph>init</codeph> wird immer vor dem Ereignis <codeph>complete</codeph> ausgelöst.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Wird nach dem erfolgreichen Laden von Daten ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird nach dem erfolgreichen Laden von Daten ausgelöst. Anders ausgedrückt wird es ausgelöst, wenn alle Inhalte heruntergeladen wurden und das Laden beendet ist. Das Ereignis <codeph>complete</codeph> wird immer nach dem Ereignis <codeph>init</codeph> ausgelöst. Das <codeph>init</codeph>-Ereignis wird ausgelöst, wenn auf das Objekt zugegriffen werden kann, selbst, wenn noch Inhalte heruntergeladen werden.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:LoaderInfo:getLoaderInfoByDefinition"><apiName>getLoaderInfoByDefinition</apiName><shortdesc>
     Gibt das LoaderInfo-Objekt zurück, das mit einer als Objekt definierten SWF-Datei verknüpft ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Der Aufrufer wird nicht in der lokalen vertrauenswürdigen Sandbox ausgeführt.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das zugeordnete LoaderInfo-Objekt. Gibt <codeph>null</codeph> zurück, wenn der Aufruf in Builds ohne Debugger erfolgt (oder wenn das Debugging nicht aktiviert ist) oder wenn dem <codeph>object</codeph>, auf das verwiesen wird, kein LoaderInfo-Objekt zugeordnet ist (wie dies bei einigen Objekten der Fall ist, die in der AIR-Laufzeitumgebung verwendet werden).
	 
	 </apiDesc><apiOperationClassifier>flash.display:LoaderInfo</apiOperationClassifier></apiReturn><apiParam><apiItemName>object</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das Objekt, für das ein zugeordnetes LoaderInfo-Objekt abgerufen werden soll.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt das LoaderInfo-Objekt zurück, das mit einer als Objekt definierten SWF-Datei verknüpft ist.
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:LoaderInfo:actionScriptVersion:get"><apiName>actionScriptVersion</apiName><shortdesc>
	 Die ActionScript-Version der geladenen SWF-Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Wenn der heruntergeladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Datei keine SWF-Datei ist.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Die ActionScript-Version der geladenen SWF-Datei. Die Sprachversion wird anhand der Zusammenfassung in der ActionScriptVersion-Klasse angegeben, z. B. <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> und <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>.
	 
	 <p><b>Hinweis:</b> Diese Eigenschaft besitzt immer entweder den Wert <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> oder <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>. ActionScript 1.0 und 2.0 fallen beide unter den Wert <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> (Version 2.0). Diese Eigenschaft unterscheidet nur zwischen ActionScript 1.0/2.0 und ActionScript 3.0.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ActionScriptVersion"><linktext>flash.display.ActionScriptVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:applicationDomain:get"><apiName>applicationDomain</apiName><shortdesc>
	 Wenn eine externe SWF-Datei geladen wird, werden alle in der geladenen Klasse enthaltenen ActionScript 3.0-Definitionen in der applicationDomain-Eigenschaft gespeichert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need better description and example.  
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier><apiException><apiDesc>Dieser Sicherheits-Sandbox des Aufrufers ist es nicht gestattet, auf diese Anwendungsdomäne zuzugreifen.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Wenn eine externe SWF-Datei geladen wird, werden alle in der geladenen Klasse gespeicherten ActionScript 3.0-Definitionen in der Eigenschaft <codeph>applicationDomain</codeph> gespeichert.
	 
	 <p>Der gesamte Code in einer SWF-Datei ist so definiert, dass er sich in einer Anwendungsdomäne befindet. Die aktuelle Anwendungsdomäne ist die Domäne, in der die Hauptanwendung ausgeführt wird. Die Systemdomäne enthält alle Anwendungsdomänen, einschließlich der aktuellen Domäne, und alle Klassen, die von Flash Player oder Adobe AIR verwendet werden.</p>
	 
	 <p>Mit Ausnahme der Systemdomäne sind alle Anwendungsdomänen mit einer übergeordneten Domäne verknüpft. Die Systemdomäne ist die übergeordnete Domäne der <codeph>applicationDomain</codeph>-Eigenschaft der Hauptanwendung. Geladene Klassen werden nur definiert, wenn sie in der jeweils übergeordneten Klasse nicht bereits definiert sind. Die Definition einer geladenen Klasse kann nicht mit einer neueren Definition überschrieben werden.</p>
	 
	 <p>Beispiele für die Verwendung von Anwendungsdomänen finden Sie im Handbuch <i>Programmieren mit ActionScript 3.0</i> im Kapitel „Clientsystem-Umgebung“.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:bytes:get"><apiName>bytes</apiName><shortdesc>
	 Die einem LoaderInfo-Objekt zugeordneten Bytes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>Wenn dem Objekt, das auf diese API zugreift, der Zugriff auf das geladene Objekt aufgrund von Sicherheitsbeschränkungen verweigert wird. Dies kann beispielsweise geschehen, wenn ein Loader-Objekt auf die <codeph>contentLoaderInfo.content</codeph>-Eigenschaft zugreifen möchte und ihm die Sicherheitsberechtigung für den Zugriff auf den geladenen Inhalt nicht erteilt wird.
	 
	 <p>Weitere Informationen finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Die einem LoaderInfo-Objekt zugeordneten Bytes. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 Die Anzahl der für das Medium geladenen Bytes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl der für das Medium geladenen Bytes. Wenn diese Zahl mit dem Wert von <codeph>bytesTotal</codeph> identisch ist, ist das Medium vollständig geladen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 Die Anzahl der komprimierten Bytes in der gesamten Mediendatei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl der komprimierten Bytes in der gesamten Mediendatei.
	 
	 <p>Bevor das erste <codeph>progress</codeph>-Ereignis von dem entsprechenden Loader-Objekt dieses LoaderInfo-Objekts ausgelöst wird, hat <codeph>bytesTotal</codeph> den Wert 0. Nach dem ersten <codeph>progress</codeph>-Ereignis des Loader-Objekts entspricht <codeph>bytesTotal</codeph> der tatsächlich herunterzuladenden Anzahl von Bytes.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:childAllowsParent:get"><apiName>childAllowsParent</apiName><shortdesc>
	 Drückt die Vertrauensbeziehung von Inhalt (untergeordnetes Objekt) zu Loader (übergeordnetes Objekt) aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Wird ausgelöst, wenn der geladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Drückt die Vertrauensbeziehung von Inhalt (untergeordnetes Objekt) zu Loader (übergeordnetes Objekt) aus. Hat das untergeordnete Objekt den Zugriff durch das übergeordnete Objekt erlaubt, gilt <codeph>true</codeph>, sonst gilt <codeph>false</codeph>. Diese Eigenschaft wird auf <codeph>true</codeph> gesetzt, wenn das untergeordnete Objekt die <codeph>allowDomain()</codeph>-Methode aufgerufen hat, um der übergeordneten Domäne die Berechtigung zu erteilen, oder wenn von der untergeordneten Domäne eine URL-Richtlinie geladen wird, die der übergeordneten Domäne die Berechtigung erteilt. Befinden sich das untergeordnete und das übergeordnete Objekt in derselben Domäne, wird diese Eigenschaft auf <codeph>true</codeph> gesetzt.
	 
	 <p>Weitere Informationen finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:childSandboxBridge:get"><apiName>childSandboxBridge</apiName><shortdesc>
	 Ein Objekt, das über Code des geladenen Inhalts festgelegt werden kann, um Eigenschaften und Methoden bereitzustellen, auf die der Code in der Sandbox des Loader-Objekts zugreifen kann.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Nur Inhalt in der Sandbox des geladenen Inhalts kann diese Eigenschaft einstellen.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Ein Objekt, das über Code des geladenen Inhalts festgelegt werden kann, um Eigenschaften und Methoden bereitzustellen, auf die der Code in der Sandbox des Loader-Objekts zugreifen kann. Diese <i>Sandbox-Brücke</i> ermöglicht Inhalt aus einer nicht zu einer Anwendung gehörigen Domäne den gesteuerten Zugriff auf Skripten in der Sandbox der AIR-Anwendung und umgekehrt. Die Sandbox-Brücke dient als Schnittstelle zwischen den Sandboxes und ermöglicht eine explizite Interaktion zwischen Sicherheits-Sandboxes der Anwendung und anderen Sicherheits-Sandboxes. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/parentSandboxBridge"><linktext>parentSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:content:get"><apiName>content</apiName><shortdesc>
	 Das diesem LoaderInfo-Objekt zugeordnete geladene Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>Wenn dem Objekt, das auf diese API zugreift, der Zugriff auf das geladene Objekt aufgrund von Sicherheitsbeschränkungen verweigert wird. Dies kann beispielsweise geschehen, wenn ein Loader-Objekt auf die <codeph>contentLoaderInfo.content</codeph>-Eigenschaft zugreifen möchte und ihm die Sicherheitsberechtigung für den Zugriff auf den geladenen Inhalt nicht erteilt wird.
	 
	 <p>Weitere Informationen finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Das diesem LoaderInfo-Objekt zugeordnete geladene Objekt. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:contentType:get"><apiName>contentType</apiName><shortdesc>
	 Der MIME-Typ der geladenen Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Der MIME-Typ der geladenen Datei. Der Wert ist <codeph>null</codeph>, wenn der geladene Anteil der Datei nicht ausreicht, um den Typ zu bestimmen. In der folgenden Liste sind die möglichen Werte enthalten:
	 
	 <ul>
	 	
	 	<li><codeph>"application/x-shockwave-flash"</codeph></li>
	 
	 	<li><codeph>"image/jpeg"</codeph></li>
	 
	 	<li><codeph>"image/gif"</codeph></li>
	 
	 	<li><codeph>"image/png"</codeph></li>
	 
	 </ul>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 Die nominelle Bildrate der geladenen SWF-Datei, in Bildern pro Sekunde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Wenn der heruntergeladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Datei keine SWF-Datei ist. 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Die nominelle Bildrate der geladenen SWF-Datei, in Bildern pro Sekunde. Diese Zahl ist häufig eine Ganzzahl, was aber nicht zwingend notwendig ist.
	 
	 <p>Dieser Wert kann von der tatsächlich verwendeten Bildrate abweichen. Flash Player oder Adobe AIR verwendet zu einem bestimmten Zeitpunkt immer nur eine einzige Bildrate für alle geladenen SWF-Dateien. Diese Bildrate wird von der nominellen Bildrate der Haupt-SWF-Datei bestimmt. Die Hauptbildrate kann möglicherweise nicht erreicht werden, je nach Hardware, Tonsynchronisierung und anderen Faktoren.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:height:get"><apiName>height</apiName><shortdesc>
	 Die nominelle Höhe der geladenen Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Wenn der heruntergeladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Die nominelle Höhe der geladenen Datei. Dieser Wert kann von der tatsächlichen Höhe abweichen, in der der Inhalt angezeigt wird, da der geladene Inhalt oder seine übergeordneten Anzeigeobjekte auch skaliert sein können.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loader:get"><apiName>loader</apiName><shortdesc>
	 Das diesem LoaderInfo-Objekt zugeordnete Loader-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Loader</apiValueClassifier><apiException><apiDesc>Wenn dem Objekt, das auf diese API zugreift, der Zugriff auf das Loader-Objekt aufgrund von Sicherheitseinschränkungen verweigert wird. Dies kann beispielsweise geschehen, wenn eine geladene SWF-Datei auf seine <codeph>loaderInfo.loader</codeph>-Eigenschaft zugreifen möchte und ihr die Sicherheitsberechtigung für den Zugriff auf die ladende SWF-Datei nicht erteilt wird.
	 
	 <p>Weitere Informationen finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Das diesem LoaderInfo-Objekt zugeordnete Loader-Objekt. Wenn es sich bei diesem LoaderInfo-Objekt um die <codeph>loaderInfo</codeph>-Eigenschaft der Instanz der SWF-Datei-Hauptklasse handelt, wird kein Loader-Objekt zugeordnet.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loaderURL:get"><apiName>loaderURL</apiName><shortdesc>
	 Die URL der SWF-Datei, die das Laden des von diesem LoaderInfo-Objekt beschriebenen Mediums initiiert hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Die URL der SWF-Datei, die das Laden des von diesem LoaderInfo-Objekt beschriebenen Mediums initiiert hat. Für die Instanz der Hauptklasse der SWF-Datei entspricht diese URL der URL der SWF-Datei selbst.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parameters:get"><apiName>parameters</apiName><shortdesc>
	 Ein Objekt, das Name/Wert-Paare enthält, die die Parameter der geladenen SWF-Datei repräsentieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Objekt, das Name/Wert-Paare enthält, die die Parameter der geladenen SWF-Datei repräsentieren.
	 
	 <p>Sie können eine <codeph>for-in</codeph>-Schleife verwenden, um alle Namen und Werte aus dem <codeph>parameters</codeph>-Objekt zu extrahieren.</p>
	 
	 <p>Die beiden Quellen für die Parameter sind: der Abfragestring in der URL der Haupt-SWF-Datei und der Wert des <codeph>FlashVars</codeph>-HTML-Parameters (dies betrifft nur die Haupt-SWF-Datei).</p>
	 
	 <p>Die <codeph>parameters</codeph>-Eigenschaft ersetzt das in ActionScript 1.0 und 2.0 verwendete Verfahren, bei dem SWF-Dateiparameter als Eigenschaften der Hauptzeitleiste bereitgestellt wurden.</p>
	 
	 <p>Der Wert der Eigenschaft <codeph>parameters</codeph> ist null für Loader-Objekte, die SWF-Dateien enthalten, die ActionScript 1.0 oder 2.0 verwenden. Der Wert ist nur für solche Loader-Objekte ungleich null, die SWF-Dateien enthalten, die ActionScript 3.0 verwenden.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentAllowsChild:get"><apiName>parentAllowsChild</apiName><shortdesc>
	 Drückt die Vertrauensbeziehung von Loader (übergeordnetes Objekt) zu Inhalt (untergeordnetes Objekt) aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Wird ausgelöst, wenn der geladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Drückt die Vertrauensbeziehung von Loader (übergeordnetes Objekt) zu Inhalt (untergeordnetes Objekt) aus. Hat das übergeordnete Objekt den Zugriff durch das untergeordnete Objekt erlaubt, gilt <codeph>true</codeph>, sonst gilt <codeph>false</codeph>. Diese Eigenschaft wird auf <codeph>true</codeph> gesetzt, wenn das übergeordnete Objekt die <codeph>allowDomain()</codeph>-Methode aufgerufen hat, um der untergeordneten Domäne die Berechtigung zu erteilen, oder wenn von der übergeordneten Domäne eine URL-Richtliniendatei geladen wird, die der untergeordneten Domäne die Berechtigung erteilt. Befinden sich das untergeordnete und das übergeordnete Objekt in derselben Domäne, wird diese Eigenschaft auf <codeph>true</codeph> gesetzt.
	 
	 <p>Weitere Informationen finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentSandboxBridge:get"><apiName>parentSandboxBridge</apiName><shortdesc>
	 Ein Objekt, das in der Sandbox des Loader-Objekts über Code festgelegt werden kann, um Eigenschaften und Methoden bereitzustellen, auf die der Code des geladenen Inhalts zugreifen kann.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Nur Inhalt in der Sandbox des Loader-Objekts kann diese Eigenschaft einstellen.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Ein Objekt, das in der Sandbox des Loader-Objekts über Code festgelegt werden kann, um Eigenschaften und Methoden bereitzustellen, auf die der Code des geladenen Inhalts zugreifen kann. Diese <i>Sandbox-Brücke</i> ermöglicht Inhalt aus einer nicht zu einer Anwendung gehörigen Domäne den gesteuerten Zugriff auf Skripten in der Sandbox der AIR-Anwendung und umgekehrt. Die Sandbox-Brücke dient als Schnittstelle zwischen den Sandboxes und ermöglicht eine explizite Interaktion zwischen Sicherheits-Sandboxes der Anwendung und anderen Sicherheits-Sandboxes. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/childSandboxBridge"><linktext>childSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:sameDomain:get"><apiName>sameDomain</apiName><shortdesc>
	 Drückt die Domänenbeziehung zwischen dem Loader und dem Inhalt aus: „true“, wenn beide aus derselben Domäne stammen, sonst „false“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Wird ausgelöst, wenn der geladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Drückt die Domänenbeziehung zwischen dem Loader und dem Inhalt aus: <codeph>true</codeph>, wenn beide aus derselben Domäne stammen, sonst <codeph>false</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:sharedEvents:get"><apiName>sharedEvents</apiName><shortdesc>
	 Eine EventDispatcher-Instanz, die zum Austauschen von Ereignissen über Sicherheitsgrenzen hinweg verwendet werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.events:EventDispatcher</apiValueClassifier></apiValueDef><apiDesc>
	 Eine EventDispatcher-Instanz, die zum Austauschen von Ereignissen über Sicherheitsgrenzen hinweg verwendet werden kann. Auch wenn das Loader-Objekt und der geladene Inhalt aus Sicherheitsdomänen stammen, die sich gegenseitig nicht vertrauen, können beide auf <codeph>sharedEvents</codeph> zugreifen und Ereignisse über dieses Objekt senden und empfangen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:swfVersion:get"><apiName>swfVersion</apiName><shortdesc>
	 Die Dateiformatversion der geladenen SWF-Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Wenn der heruntergeladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Datei keine SWF-Datei ist.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Die Dateiformatversion der geladenen SWF-Datei. Das Dateiformat wird anhand der Zusammenfassung in der SWFVersion-Klasse angegeben, z. B. <codeph>SWFVersion.FLASH7</codeph> und <codeph>SWFVersion.FLASH9</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SWFVersion"><linktext>flash.display.SWFVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:url:get"><apiName>url</apiName><shortdesc>
	 Die URL des Mediums, das gerade geladen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Die URL des Mediums, das gerade geladen wird.
	 
	 <p>Bevor das erste <codeph>progress</codeph>-Ereignis von dem entsprechenden Loader-Objekt des LoaderInfo-Objekts ausgelöst wird, kann es sein, dass der Wert der <codeph>url</codeph>-Eigenschaft nur die ursprünglich in der <codeph>load()</codeph>-Methode des Loader-Objekts angegebene URL widerspiegelt. Nach dem ersten <codeph>progress</codeph>-Ereignis spiegelt die <codeph>url</codeph>-Eigenschaft die endgültige URL des Mediums wider, nachdem etwaige Weiterleitungen und relative URLs aufgelöst wurden.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:width:get"><apiName>width</apiName><shortdesc>
	 Die nominelle Breite des geladenen Inhalts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Wenn der heruntergeladene Anteil der Datei nicht ausreicht, um die angeforderten Informationen abzurufen.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Die nominelle Breite des geladenen Inhalts. Dieser Wert kann von der tatsächlichen Breite abweichen, in der der Inhalt angezeigt wird, da der geladene Inhalt oder seine übergeordneten Anzeigeobjekte auch skaliert sein können.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageQuality"><apiName>StageQuality</apiName><shortdesc>
Die StageQuality-Klasse stellt Werte für die Stage.quality-Eigenschaft bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die StageQuality-Klasse stellt Werte für die <codeph>Stage.quality</codeph>-Eigenschaft bereit. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/quality"><linktext>flash.display.Stage.quality</linktext></link></related-links><apiValue id="flash.display:StageQuality:BEST"><apiName>BEST</apiName><shortdesc>
Legt eine sehr hohe Wiedergabequalität fest: Bei Grafiken erfolgt ein Anti-Aliasing mithilfe eines 4 x 4 Pixel großen Rasters, und Bitmaps werden immer geglättet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>best</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt eine sehr hohe Wiedergabequalität fest: Bei Grafiken erfolgt ein Anti-Aliasing mithilfe eines 4 x 4 Pixel großen Rasters, und Bitmaps werden immer geglättet.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
Legt eine hohe Wiedergabequalität fest: Bei Grafiken erfolgt ein Anti-Aliasing mithilfe eines 4 x 4 Pixel großen Rasters, und Bitmaps werden bei statischen Filmen geglättet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>high</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt eine hohe Wiedergabequalität fest: Bei Grafiken erfolgt ein Anti-Aliasing mithilfe eines 4 x 4 Pixel großen Rasters, und Bitmaps werden bei statischen Filmen geglättet. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:LOW"><apiName>LOW</apiName><shortdesc>
Legt eine niedrige Wiedergabequalität fest: Bei Grafiken erfolgt kein Anti-Aliasing, und Bitmaps werden nicht geglättet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>low</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt eine niedrige Wiedergabequalität fest: Bei Grafiken erfolgt kein Anti-Aliasing und Bitmaps werden nicht geglättet. Diese Einstellung wird in Adobe AIR nicht unterstützt.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
Legt eine mittlere Wiedergabequalität fest: Bei Grafiken erfolgt ein Anti-Aliasing mithilfe eines 2 x 2 Pixel großen Rasters, Bitmaps werden jedoch nicht geglättet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>medium</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt eine mittlere Wiedergabequalität fest: Bei Grafiken erfolgt ein Anti-Aliasing mithilfe eines 2 x 2 Pixel großen Rasters, Bitmaps werden jedoch nicht geglättet. Diese Einstellung ist für Filme geeignet, die keinen Text enthalten. Diese Einstellung wird in Adobe AIR nicht unterstützt.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 Die BitmapData-Klasse ermöglicht Ihnen die Arbeit mit den Daten (Pixeln) des Bitmapbildes eines Bitmap-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Ermöglicht Ihnen die Arbeit mit den Bitmap-Daten eines Bitmap-Objekts.
 
 </apiTipText></apiTipTexts><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die BitmapData-Klasse ermöglicht Ihnen die Arbeit mit den Daten (Pixeln) des <ph platform="javascript">Bitmapbildes</ph> eines <ph platform="actionscript">Bitmap</ph>-Objekts. Sie können die Methoden der BitmapData-Klasse verwenden, um transparente oder undurchsichtige Bitmaps mit beliebig festgelegter Größe zu erstellen und zur Laufzeit auf verschiedene Weise zu bearbeiten. <ph platform="actionscript">Sie können auch auf die Bitmap-Daten einer Bitmap zugreifen, die Sie mit der <codeph>flash.display.Loader</codeph>-Klasse laden.</ph> 
 
 <p platform="actionscript">Mit dieser Klasse können Sie Bitmap-Wiedergabeoperationen von den internen Anzeigeaktualisierungsroutinen von Flash Player trennen. Mit einer unmittelbaren Bearbeitung der BitmapData-Objekte können Sie komplexe Bilder erstellen, ohne bei jedem Bild den Aufwand für die ständig erneuerte Darstellung der Vektordaten berücksichtigen zu müssen.</p>
 
 <p platform="actionscript">Die Methoden der BitmapData-Klasse unterstützen Effekte, die über die Filter für Nicht-Bitmap-Anzeigeobjekte nicht verfügbar sind.</p>
 
 <p>Ein BitmapData-Objekt enthält eine ganze Reihe von Pixeldaten. Diese Daten repräsentieren entweder eine vollständig transparente oder eine vollständig undurchsichtige Bitmap mit Alphakanaldaten. Jeder BitmapData-Objekttyp wird als Puffer mit 32-Bit-Ganzzahlen gespeichert. Dabei bestimmt jede 32-Bit-Ganzzahl die Eigenschaften eines Pixels in der Bitmap.</p>
 
 <p>Bei diesen Zahlen handelt es sich um eine Kombination von vier 8-Bit-Kanalwerten zwischen 0 und 255, mit denen die Alphatransparenz sowie die Werte für Rot, Grün und Blau (ARGB) des Pixels bezeichnet werden. (Für ARGB-Werte repräsentiert das höchstwertige Byte den Alphakanalwert, gefolgt von Rot, Grün und Blau.)</p>
 
 <p>Die vier Kanäle (Alpha, Rot, Grün und Blau) werden durch Zahlen repräsentiert, wenn Sie sie mit der <codeph>BitmapData.copyChannel()</codeph>-Methode oder den Eigenschaften <codeph>DisplacementMapFilter.componentX</codeph> und <codeph>DisplacementMapFilter.componentY</codeph> verwenden. Diese Zahlen werden in der BitmapDataChannel-Klasse durch die folgenden Konstanten repräsentiert:</p>
 
 <ul>
 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
  <li><codeph>BitmapDataChannel.RED</codeph></li>
 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
</ul>
 
 <p platform="actionscript">Sie können BitmapData-Objekte mit einem Bitmap-Objekt verbinden, indem Sie die <codeph>bitmapData</codeph>-Eigenschaft des Bitmap-Objekts verwenden.</p>
 
 <p platform="actionscript">Sie können ein BitmapData-Objekt verwenden, um ein Graphics-Objekt zu füllen, indem Sie die <codeph>Graphics.beginBitmapFill()</codeph>-Methode verwenden.</p>
 
 <p>In der AIR-Laufzeitumgebung umfassen die DockIcon-, Icon-, InteractiveIcon- und SystemTrayIcon-Klassen eine <codeph>bitmaps</codeph>-Eigenschaft, bei der es sich um ein Array der BitmapData-Objekte handelt, die die Bitmapbilder für ein Symbol definieren.</p>
 
 <p>In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite eines BitmapData-Objekts 8.191 Pixel, die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein BitmapData-Objekt also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite.</p>
 
 <p>Aufrufe von Methoden oder Eigenschaften eines BitmapData-Objekts lösen einen ArgumentError-Fehler aus, wenn das BitmapData-Objekt ungültig ist (wenn z. B. <codeph>height == 0</codeph> und <codeph>width == 0</codeph> ist) oder wenn es mithilfe von „dispose()“ entfernt worden ist. </p>
 
 </apiDesc><example conref="examples\BitmapDataExample.as"> Im folgenden Beispiel wird die BitmapDataExample-Klasse verwendet, um die Grafik „Image.gif“ an der Standardposition (0, 0) in ein Anzeigeobjekt (DisplayObject) zu laden. Eine Kopie von „Image.gif“ wird rechts vom Original positioniert, für das neue Farben auf Pixel angewendet werden, die einen Test mit der <codeph>threshold()</codeph>-Methode bestanden haben. Dies wird in den folgenden Schritten erreicht:
 <ol>
     <li>Es wird eine <codeph>url</codeph>-Eigenschaft erstellt, die den Speicherort und Namen der Grafikdatei angibt.</li>
     <li>Der Klassenkonstruktor erstellt ein Loader-Objekt, das dann einen Ereignis-Listener instanziiert. Der Ereignis-Listener wird ausgelöst, wenn die <codeph>completeHandler()</codeph>-Methode die Bildbearbeitung abgeschlossen hat.</li>
        <li>Anschließend wird das <codeph>request</codeph>-URLRequest-Objekt an <codeph>loader.load()</codeph> übergeben, um das Bild mit einem Anzeigeobjekt in den Speicher zu laden.</li>
     <li>Das Bild wird in die Anzeigeliste eingefügt, die das Bild auf dem Bildschirm bei den Koordinaten <i>x = 0, y = 0</i> anzeigt.</li>
     <li>Die <codeph>completeHandler()</codeph>-Methode führt dann Folgendes aus: 
     <ul>
         <li>Sie erstellt zusammen mit einem Bitmap-Objekt einen zweiten „Loader“, der über das Loader-Objekt initialisiert wird.</li>
         <li>Sie erstellt ein zweites Bitmap-Objekt, <codeph>duplicate</codeph>, das wiederum die <codeph>duplicateImage()</codeph>-Methode aufruft, die ein Duplikat des Originalbilds erzeugt. </li>
         <li>Sie erstellt ein BitmapData-Objekt, das dem BitmapData-Objekt des <codeph>duplicate</codeph>-Objekts zugeordnet ist.</li>
         <li>Sie erstellt ein neues Rechteckobjekt, das mit denselben Werten für Koordinaten, Breite und Höhe wie das Originalbild initialisiert wird.</li>
         <li>Sie erstellt ein neues Point-Objekt mit der Standardeinstellung <i>x = 0, y = 0</i>.</li>
         <li>Sie erstellt die folgenden Variablen:
         <ul>
             <li><codeph>operation</codeph>: Wendet die neue Farbe an, wenn der Schwellenwert größer oder gleich dem Original ist.</li>
             <li><codeph>threshold</codeph>: Der Wert, mit dem jedes Pixel verglichen wird (in diesem Beispiel Hellgrau mit einem Alphawert von 0xCC). </li>
             <li><codeph>color</codeph> : Die Farbe, auf die die Pixel eingestellt sind, die den Schwellentest bestehen. In diesem Fall ist dies reines Gelb.</li>
             <li><codeph>mask</codeph>: Die genau entgegengesetzte Farbe (durchsichtiges Blau).</li>
             <li><codeph>copySource</codeph>: Ist auf <codeph>false</codeph> gesetzt, um anzuzeigen, dass die Pixelwerte nicht kopiert werden, wenn der Schwellenwert den Test nicht besteht. Dieser Wert hat keine Bedeutung, da das Bild dupliziert wird und nur Pixel geändert werden, die den Schwellenwerttest bestehen.</li>
      </ul></li>
         <li>Ruft mithilfe der vorherigen Variablen die <codeph>threshold()</codeph>-Methode auf. Es ergibt sich die folgende Schwellenwertgleichung: <codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>. </li>
  </ul></li>
 </ol>
 <p> <b>Hinweise:</b>
 <ul>
     <li>Für die Kompilierung der SWF-Datei müssen Sie die Option „Sicherheit bei lokaler Wiedergabe“ auf „Nur auf lokale Dateien zugreifen“ einstellen.
 </li>
     <li>Zur Ausführung dieses Beispiels müssen Sie eine Datei mit dem Namen „Image.gif“ in dem Ordner ablegen, in dem sich die SWF-Datei befindet.
 </li>
  <li>Es wird empfohlen, eine Grafik mit einer Breite von bis zu etwa 80 Pixel zu verwenden. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example><example conref="examples\BitmapDataExample2.as"/></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/bitmapData"><linktext>flash.display.Bitmap.bitmapData</linktext></link><link href="flash.desktop.xml#DockIcon/bitmaps"><linktext>flash.desktop.DockIcon.bitmaps</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.desktop.xml#Icon/bitmaps"><linktext>flash.desktop.Icon.bitmaps</linktext></link><link href="flash.desktop.xml#InteractiveIcon/bitmaps"><linktext>flash.desktop.InteractiveIcon.bitmaps</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.desktop.xml#SystemTrayIcon/bitmaps"><linktext>flash.desktop.SystemTrayIcon.bitmaps</linktext></link></related-links><apiConstructor id="flash.display:BitmapData:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 	 Erstellt ein neues BitmapData-Objekt mit der angegebenen Breite und Höhe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Breite und/oder Höhe übersteigen die maximalen Abmessungen.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Breite der Bitmap in Pixel.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Höhe der Bitmap in Pixel.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>transparent</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Gibt an, ob die Bitmap Transparenz pro Pixel unterstützt. Der Standardwert lautet <codeph>true</codeph> (transparent). Um eine vollständig transparente Bitmap zu erstellen, setzen Sie den Wert des Parameters <codeph>transparent</codeph> auf <codeph>true</codeph> und den Wert des Parameters <codeph>fillColor</codeph> auf 0x00000000 (bzw. auf 0). Die Einstellung der <codeph>transparent</codeph>-Eigenschaft auf <codeph>false</codeph> kann eine leichte Verbesserung der Wiedergabe-Performance zur Folge haben. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>Ein 32-Bit-ARGB-Farbwert, der die Füllfarbe des Bitmap-Bereichs angibt. Der Standardwert lautet 0xFFFFFF (reines Weiß).
	 
 	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Erstellt ein neues BitmapData-Objekt mit der angegebenen Breite und Höhe. Wenn Sie einen Wert für den Parameter <codeph>fillColor</codeph> eingeben, wird jedes Pixel der Bitmap auf diese Farbe eingestellt.
	 
	 <p>In der Standardeinstellung wird die Bitmap als transparente Grafik erstellt, es sei denn, Sie übergeben für den Parameter <codeph>false</codeph> den Wert <codeph>transparent</codeph>. Eine als undurchsichtiges Bild erstellte Bitmap kann nicht mehr in eine transparente Bitmap umgewandelt werden. Jedes Pixel einer undurchsichtigen Bitmap verwendet nur 24 Bit der Farbkanaldaten. Wenn Sie eine Bitmap dagegen als transparent definieren, müssen für jedes Pixel, einschließlich der Alphatransparenzdaten, 32 Bit an Farbkanaldaten verwendet werden.</p>
	 
	 <p>In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite eines BitmapData-Objekts 8.191 Pixel, die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein BitmapData-Objekt also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Falls Sie für „width“ oder „height“ höhere Werte als 2.880 angeben, wird keine neue Instanz erstellt.</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:BitmapData:applyFilter"><apiName>applyFilter</apiName><shortdesc>
	 Erstellt anhand eines Quellbilds und eines filter-Objekts das gefilterte Bild.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceBitmapData“, „sourceRect“, „destPoint“ oder „filter“ haben den Wert null.
 	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Die Transparenzwerte der BitmapData-Objekte sind nicht kompatibel mit der filter-Operation.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>Eine Zahl, die angibt, ob der Filter erfolgreich angewendet wurde. Wird 0 (null) zurückgegeben, wurde der Filter erfolgreich angewendet. Bei Rückgabe einer negativen Zahl ist während der Anwendung des Filters ein Fehler aufgetreten.
	 
	 </apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.

	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>Das filter-Objekt, mit dem die Filteroperation durchgeführt wird. Jeder Filtertyp hat bestimmte Grundvoraussetzungen, und zwar:
	 
	 <ul><li><b>BlurFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind. Sollten die Formate der Bilder nicht übereinstimmen, entspricht die Kopie des Quellbilds, die während der Filterung angelegt wird, dem Format des Zielbilds.</li>
	 
	 <li><b>BevelFilter, DropShadowFilter, GlowFilter, ChromeFilter</b>: Das Zielbild dieser Filter muss ein transparentes Bild sein. Der Aufruf von „DropShadowFilter“ bzw. „GlowFilter“ erstellt ein Bild mit den Alphakanaldaten des Schlagschattens bzw. des Glühens. Er erstellt aber nicht den Schlagschatten auf dem Zielbild selbst. Werden diese Filter bei einem undurchsichtigen Zielbild angewendet, wird eine Ausnahme ausgelöst.</li>
	 
	 <li><b>ConvolutionFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind.</li>
	 
	 <li><b>ColorMatrixFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind.</li>
	 
	 <li><b>DisplacementMapFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind, aber die Formate der Quell- und Zielbilder müssen dabei identisch sein.</li></ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erstellt anhand eines Quellbilds und eines filter-Objekts das gefilterte Bild.
	 
	 <p>Diese Methode greift auf das Verhalten integrierter filter-Objekte zurück, mit deren Code das Zielrechteck bestimmt werden kann, das durch ein Eingabequellrechteck geändert wird.</p>
	 
	 <p>Nach dem Anwenden des Filters ist das Ergebnis unter Umständen größer als das Ausgangsbild. Wenn beispielsweise ein Eingabequellrechteck mit den Werten (50,50,100,100) und dem Zielpunkt (10,10) mithilfe einer BlurFilter-Klasse weichgezeichnet wird, wird der geänderte Bereich im Zielbild wegen der Weichzeichnung größer als (10,10,60,60). Dies geschieht intern während des Aufrufs von <codeph>applyFilter()</codeph>.</p>
	 
	 <p>Wenn der Parameter <codeph>sourceRect</codeph> des Parameters <codeph>sourceBitmapData</codeph> einen inneren Bereich wie (50,50,100,100) in einer Grafik der Größe 200 x 200 Pixel angibt, generiert der Filter das Zielrechteck anhand der Quellpixel außerhalb des Parameters <codeph>sourceRect</codeph>.</p>
	 
	 <p>Wenn es sich bei dem BitmapData-Objekt und dem als <codeph>sourceBitmapData</codeph>-Parameter festgelegten Objekt um dasselbe Objekt handelt, verwendet die Anwendung eine temporäre Kopie des Objekts, um den Filter anzuwenden. Die beste Performance erhalten Sie jedoch, wenn Sie diese Situation vermeiden.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.applyFilter.1.as"> Aus dem folgenden Beispiel geht hervor, wie Sie einen Weichzeichnungsfilter auf eine BitmapData-Instanz anwenden:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>flash.filters.BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>flash.filters.BlurFilter</linktext></link><link href="flash.filters.xml#ColorMatrixFilter"><linktext>flash.filters.ColorMatrixFilter</linktext></link><link href="flash.filters.xml#ConvolutionFilter"><linktext>flash.filters.ConvolutionFilter</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>flash.filters.DropShadowFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>flash.filters.GlowFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:clone"><apiName>clone</apiName><shortdesc>
	 Gibt ein neues BitmapData-Objekt zurück, das ein Klon der ursprünglichen Instanz ist, mit einer exakten Kopie der enthaltenen Bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein mit dem Original identisches neues BitmapData-Objekt.
	 
	 </apiDesc><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt ein neues BitmapData-Objekt mit einer exakten Kopie der ursprünglichen Bitmap zurück.

	  

	  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt ein neues BitmapData-Objekt zurück, das ein Klon der ursprünglichen Instanz ist, mit einer exakten Kopie der enthaltenen Bitmap.
	 
	 </apiDesc><example conref="examples\BitmapData.clone.1.as"> Das folgende Beispiel zeigt das Klonen einer BitmapData-Instanz. Außerdem zeigt es, dass sich das Original beim Ändern der geklonten BitmapData-Instanz nicht ändert:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:colorTransform"><apiName>colorTransform</apiName><shortdesc>
	 Passt die Farbwerte in einem angegebenen Bereich einer Bitmap mithilfe eines ColorTransform-Objekts an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„rect“ oder „colorTransform“ haben den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteckobjekt, das den Bereich des Bilds definiert, auf den das ColorTransform-Objekt angewendet wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>Ein ColorTransform-Objekt, das die anzuwendenden Werte für die Farbtransformation beschreibt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Passt die Farbwerte in einem angegebenen Bereich einer Bitmap mithilfe eines <codeph>ColorTransform</codeph>-Objekts an. Falls das Rechteck mit den Begrenzungen der Bitmap übereinstimmt, wandelt diese Methode die Farbwerte des gesamten Bilds um.
	 
	 </apiDesc><example conref="examples\BitmapData.colorTransform.1.as"> Aus dem folgenden Beispiel geht hervor, wie Sie eine Farbtransformation auf die linke Hälfte (Rechteck) eines BitmapData-Objekts anwenden:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:compare"><apiName>compare</apiName><shortdesc>
	 
	 Vergleicht zwei BitmapData-Objekte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„otherBitmapData“ hat den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Besitzen die beiden BitmapData-Objekte dieselben Abmessungen (Breite und Höhe), gibt die Methode ein neues BitmapData-Objekt zurück, das den Unterschied zwischen den beiden Objekten enthält (siehe Hauptthema). Sind die BitmapData-Objekte gleich, gibt die Methode die Zahl 0 zurück. Wenn die Breiten der BitmapData-Objekte ungleich sind, gibt die Methode die Zahl -3 zurück. Wenn die Höhen der BitmapData-Objekte ungleich sind, gibt die Methode die Zahl -4 zurück. 
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>otherBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Das BitmapData-Objekt, das mit dem BitmapData-Quellobjekt verglichen werden soll.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Vergleicht zwei BitmapData-Objekte. Besitzen die beiden BitmapData-Objekte dieselben Abmessungen (Breite und Höhe), gibt die Methode ein neues BitmapData-Objekt zurück, in dem jedes Pixel die „Differenz“ zwischen den Pixeln in den beiden Quellobjekten beschreibt:
	 
	 <ul>
	 
	 	<li>Sind zwei Pixel gleich, hat das Differenzpixel den Wert 0x00000000. </li>
	 
	 	<li>Besitzen zwei Pixel unterschiedliche RGB-Werte (ohne den Alphawert zu berücksichtigen), hat das Differenzpixel den Wert 0xFFRRGGBB, wobei RR/GG/BB die einzelnen Differenzwerte zwischen den Rot-, Grün- und Blaukanälen darstellen (Pixelwert im Quellobjekt minus Pixelwert im <codeph>otherBitmapData</codeph>-Objekt). Alphakanaldifferenzen werden in diesem Fall ignoriert. </li> 
	 
	 	<li>Weist nur der Alphakanal einen anderen Wert auf, ist der Pixelwert 0x<i>ZZ</i>FFFFFF, wobei <i>ZZ</i> den Unterschied zwischen den Alphawerten darstellt (Alphawert im Quellobjekt minus Alphawert im <codeph>otherBitmapData</codeph>-Objekt).</li>
	 
	 </ul>
	 
	 <p>Betrachten Sie beispielsweise die folgenden beiden BitmapData-Objekte:</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
     </codeblock>
	 
	 <p><b>Hinweis:</b> Die zum Füllen der beiden BitmapData-Objekte verwendeten Farben haben leicht abweichende RGB-Werte (0xFF0000 und 0xFFAA00). Das Ergebnis der <codeph>compare()</codeph>-Methode ist ein neues BitmapData-Objekt, in dem jedes Pixel die Abweichung zwischen den beiden Bitmaps in den RGB-Werten aufzeigt.</p>
	 
	 <p>Betrachten Sie die folgenden beiden BitmapData-Objekte, in denen die RGB-Farben gleich sind, der Alphawert aber unterschiedlich ist:</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
	 </codeblock>
	 
	 <p>Das Ergebnis der <codeph>compare()</codeph>-Methode ist ein neues BitmapData-Objekt, in dem jedes Pixel die Abweichung zwischen den beiden Bitmaps in den Alphawerten aufzeigt.</p>
	 
	 <p>Sind die beiden BitmapData-Objekte gleich (mit derselben Breite, Höhe und identischen Pixelwerten), gibt die Methode die Zahl 0 zurück.</p>
	 
	 <p>Wenn die Breiten der BitmapData-Objekte ungleich sind, gibt die Methode die Zahl -3 zurück. </p>
	 
	 <p>Ist die Höhe der beiden BitmapData-Objekte nicht gleich, dafür jedoch die Breite, gibt die Methode die Zahl -4 zurück.</p>
	 
	 <p>Das folgende Beispiel vergleicht zwei Bitmap-Objekte mit unterschiedlicher Breite (50 und 60):</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 </apiDesc><example conref="examples\BitmapData.compare.1.as"> Das folgende Beispiel zeigt den Wert eines Pixels im BitmapData-Objekt, das sich aus dem Vergleich zweier BitmapData-Objekte mit gleichen Abmessungen ergibt:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:copyChannel"><apiName>copyChannel</apiName><shortdesc>
	 Überträgt Daten innerhalb des aktuellen BitmapData-Objekts aus einem Kanal in einen anderen bzw. überträgt Daten in einen Kanal des aktuellen BitmapData-Objekts, die aus einem Kanal eines anderen BitmapData-Objekts stammen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf das aktuelle BitmapData-Objekt sein.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Das Quellrechteckobjekt. Um nur die Kanaldaten eines kleineren Bereichs innerhalb der Bitmap zu kopieren, geben Sie ein Quellrechteck an, das kleiner ist als das ganze BitmapData-Objekt. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Das Point-Zielobjekt, das die linke obere Ecke des Rechteckbereichs darstellt, in den die neuen Kanaldaten eingefügt werden. Um nur die Kanaldaten eines Bereichs im Zielbild in einen anderen Bereich dieses Zielbilds zu kopieren, geben Sie einen anderen Punkt als (0,0) an.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Der Quellkanal. Verwenden Sie einen Wert aus der BitmapDataChannel-Klasse (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Der Zielkanal. Verwenden Sie einen Wert aus der BitmapDataChannel-Klasse (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Überträgt Daten innerhalb des aktuellen BitmapData-Objekts aus einem Kanal in einen anderen bzw. überträgt Daten in einen Kanal des aktuellen BitmapData-Objekts, die aus einem Kanal eines anderen BitmapData-Objekts stammen. Alle Daten der anderen Kanäle im BitmapData-Zielobjekt bleiben erhalten.
	 
	 <p>Die Einstellungen für den Quell- und Zielkanal können einen der folgenden Werte annehmen: </p>
	 <ul>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 </ul>

	 
	 </apiDesc><example conref="examples\BitmapData.copyChannel.1.as"> Das folgende Beispiel zeigt, wie Sie den roten Kanal eines BitmapData-Objekts für einen Pixelbereich der Größe 20 x 20 in seinen blauen Kanal kopieren:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:copyPixels"><apiName>copyPixels</apiName><shortdesc>
	 Bietet eine schnelle Routine zur Bearbeitung von Pixeln zwischen Bildern ohne Dehnung, Drehung oder Farbeffekte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceBitmapData“, „sourceRect“  „destPoint“ haben den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die Eingabe-Bitmap, aus der die Pixel kopiert werden sollen. Das Quellbild kann eine andere BitmapData-Instanz oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Zielpunkt, der die linke obere Ecke des Rechteckbereichs darstellt, in den die kopierten Pixel eingefügt werden.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein zweites BitmapData-Objekt als Alphaquelle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Punkt in der BitmapData-Objektquelle, der der linken oberen Ecke des <codeph>sourceRect</codeph>-Parameters entspricht.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mergeAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Um den Alphakanal zu verwenden, setzen Sie den Wert auf <codeph>true</codeph>. Um die Pixel ohne Alphadaten zu kopieren, setzen Sie den Wert auf <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bietet eine schnelle Routine zur Bearbeitung von Pixeln zwischen Bildern ohne Dehnung, Drehung oder Farbeffekte. Diese Methode kopiert einen Rechteckbereich eines Quellbilds in einen Rechteckbereich gleicher Größe an den Zielpunkt im BitmapData-Zielobjekt.
	 
	 <p>Wenn Sie auch die Parameter <codeph>alphaBitmap</codeph> und <codeph>alphaPoint</codeph> angeben, können Sie ein zweites Bild als Alphaquelle für das Quellbild verwenden. Verfügt auch das Quellbild über Alphadaten, werden die Alphadaten beider Bilder verwendet, um die Pixel des Quellbilds in das Zielbild zu projizieren. Der Parameter <codeph>alphaPoint</codeph> gibt dabei den Punkt innerhalb des Zielbilds an, der der linken oberen Ecke des Quellrechtecks entspricht. Sämtliche Pixel außerhalb des Überschneidungsbereichs von Quell- und Alphabild werden nicht in das Zielbild kopiert.</p>
	 
	 <p>Die <codeph>mergeAlpha</codeph>-Eigenschaft steuert, ob das Kopieren eines transparenten Bilds auf ein anderes transparentes Bild unter Berücksichtigung des Alphakanals durchgeführt wird. Um die Pixel mit Alphakanaldaten zu kopieren, setzen Sie die <codeph>mergeAlpha</codeph>-Eigenschaft auf <codeph>true</codeph>. In der Standardeinstellung hat die <codeph>mergeAlpha</codeph>-Eigenschaft den Wert <codeph>false</codeph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.copyPixels.1.as"> Das folgende Beispiel zeigt, wie Sie Pixel aus einem Pixelbereich der Größe 20 x 20 eines BitmapData-Objekts in ein anderes BitmapData-Objekt kopieren:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:dispose"><apiName>dispose</apiName><shortdesc>
	 Gibt Speicher frei, der zum Speichern des BitmapData-Objekts verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Gibt Speicher frei, der zum Speichern des BitmapData-Objekts verwendet wird. 
	 
	 <p>Wenn die <codeph>dispose()</codeph>-Methode für ein Bild aufgerufen wird, werden Breite und Höhe des Bilds auf 0 gesetzt. Alle nachfolgenden Aufrufe von Methoden und Eigenschaften für diese BitmapData-Instanz schlagen fehl, und eine Ausnahme wird ausgelöst. </p>
	 <p><codeph>BitmapData.dispose()</codeph> gibt den Arbeitsspeicher, der von den tatsächlichen Bitmapdaten belegt wird, sofort frei (ein Bitmap kann bis zu 64 MB Arbeitsspeicher belegen). Nach der Verwendung von <codeph>BitmapData.dispose()</codeph> kann das BitmapData-Objekt nicht mehr verwendet werden und die Flash-Laufzeitumgebung gibt eine Ausnahme aus, wenn Sie Funktionen für das BitmapData-Objekt aufrufen. Mit <codeph>BitmapData.dispose()</codeph> wird jedoch nicht das BitmapData-Objekt (ca. 128 Byte) aus dem Speicher entfernt; der vom eigentlichen BitmapData-Objekt belegte Arbeitsspeicher wird frei, wenn das BitmapData-Objekt vom Garbage Collector aus dem Speicher entfernt wird.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.dispose.1.as"> Das folgende Beispiel zeigt, wie sich das Aufrufen einer Methode eines BitmapData-Objekts nach einem Aufruf der <codeph>dispose()</codeph>-Methode auswirkt (es wird eine Ausnahme ausgelöst):
<codeblock>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.system.xml#System/gc()"><linktext>flash.system.System.gc()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:draw"><apiName>draw</apiName><shortdesc>
	 Zeichnet das source-Anzeigeobjekt mit dem Vektorrenderer von Flash Player oder AIR auf das Bitmapbild.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Beim <codeph>source</codeph>-Parameter handelt es sich nicht um ein BitmapData- oder DisplayObject-Objekt.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Das <codeph>source</codeph>-Objekt und (bei einem Sprite- oder MovieClip-Objekt) alle seine untergeordneten Objekte stammen nicht aus derselben Domäne wie der Aufrufer oder befinden sich nicht in Inhalt, auf den der Aufrufer über einen Aufruf der <codeph>Security.allowDomain()</codeph>-Methode zugreifen kann. Diese Einschränkung gilt nicht für AIR-Inhalt in der Sicherheits-Sandbox der Anwendung.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Die Quelle ist null oder kein zulässiges IBitmapDrawable-Objekt.
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>flash.display:IBitmapDrawable</apiOperationClassifier><apiDesc>Das Anzeigeobjekt oder BitmapData-Objekt, das in das BitmapData-Objekt gezeichnet werden soll. (Die Klassen DisplayObject und BitmapData implementieren die IBitmapDrawable-Schnittstelle.)
	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Matrix-Objekt, mit dem die Koordinaten der Bitmap skaliert, gedreht oder umgesetzt werden können. Wenn Sie auf das Bild keine Matrixtransformation anwenden möchten, setzen Sie diesen Parameter auf eine Identitätsmatrix, die mit dem Standardkonstruktor <codeph>new Matrix()</codeph> erstellt wurde, oder übergeben Sie einen <codeph>null</codeph>-Wert.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein ColorTransform-Objekt, mit dem die Farbwerte der Bitmap angepasst werden können. Falls kein Objekt vorhanden ist, findet keine Transformation der Bitmap-Farben statt. Wenn Sie diesen Parameter übergeben müssen, das Bild aber nicht transformieren möchten, setzen Sie diesen Parameter auf ein ColorTransform-Objekt, das mit dem Standardkonstruktor <codeph>new ColorTransform()</codeph> erstellt worden ist.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>blendMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein String-Wert aus der flash.display.BlendMode-Klasse, der den Mischmodus festlegt, der auf die resultierende Bitmap angewendet werden soll. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Rechteckobjekt, das den Bereich des zu zeichnenden Quellobjekts definiert. Wenn Sie diesen Wert nicht angeben, wird das Bild nicht abgeschnitten, und das gesamte Quellobjekt wird gezeichnet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein boolescher Wert, der festlegt, ob ein BitmapData-Objekt bei der Skalierung oder Drehung aufgrund einer Skalierung oder Drehung im Parameter <codeph>matrix</codeph> geglättet wird. Der Parameter <codeph>smoothing</codeph> ist nur anwendbar, wenn es sich beim Parameter <codeph>source</codeph> um ein BitmapData-Objekt handelt. Wenn <codeph>smoothing</codeph> auf <codeph>false</codeph> gesetzt ist, wirkt das gedrehte bzw. skalierte BitmapData-Bild grobkörnig oder ungeglättet. Die folgenden beiden Bilder verwenden z. B. beide das gleiche BitmapData-Objekt als <codeph>source</codeph>-Parameter, aber der Parameter <codeph>smoothing</codeph> ist links auf <codeph>true</codeph> und rechts auf <codeph>false</codeph> gesetzt:
	 
	 <p><adobeimage alt="Zwei Bilder: das linke mit und das rechte ohne Glättung." href="../../images/bitmapData_draw_smoothing.jpg"/></p>
	 
	 <p>Das Zeichnen einer Bitmap dauert länger, wenn <codeph>smoothing</codeph> auf <codeph>true</codeph> gesetzt ist, und geht schneller, wenn <codeph>smoothing</codeph> auf <codeph>false</codeph> gesetzt ist.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Zeichnet das <codeph>source</codeph>-Anzeigeobjekt mit dem Vektorrenderer von <ph platform="actionscript">Flash Player oder </ph>AIR auf das Bitmapbild. Sie können <codeph>matrix</codeph>, <codeph>colorTransform</codeph>, <codeph>blendMode</codeph> und einen Zielparameter <codeph>clipRect</codeph> angeben, der steuert, wie das Rendern durchgeführt wird. Optional können Sie auch festlegen, ob die Bitmap beim Skalieren geglättet werden soll (dies funktioniert nur, wenn es sich beim Quellobjekt um ein BitmapData-Objekt handelt).
	  
	 <p>Diese Methode entspricht der Einstellung des Zeichnungsverfahrens mithilfe des Standardvektorrenderers für Objekte in der Authoring-Umgebung.</p>
	 
	 <p>Das Quellanzeigeobjekt verwendet bei diesem Aufruf keines seiner angewendeten Transformationsverfahren. Es wird so verarbeitet, wie es in der Bibliothek oder Datei vorliegt. Dabei werden keine Matrix- oder Farbtransformationen durchgeführt und keine Mischmodi verwendet. Wenn Sie beim Zeichnen des Anzeigeobjekts (etwa eines Movieclips) seine eigenen Transformationseigenschaften verwenden möchten, können Sie das entsprechende <codeph>transform</codeph>-Eigenschaftsobjekt in die <codeph>transform</codeph>-Eigenschaft des Bitmap-Objekts kopieren, die das BitmapData-Objekt verwendet.</p>
	 
     <p>Diese Methode wird in <ph platform="actionscript">Flash Player 9.0.115.0 und höher sowie in </ph>Adobe AIR über RTMP unterstützt. Sie können den Zugriff auf Streams auf Flash Media Server in einem serverseitigen Skript steuern. Weitere Informationen finden Sie in den Abschnitten zu den Eigenschaften <codeph>Client.audioSampleAccess</codeph> und <codeph>Client.videoSampleAccess</codeph> in <xref href="http://www.adobe.com/go/documentation_de" scope="external"> <i>Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></xref>.</p>
	 
	 <p platform="actionscript">Wenn das source-Objekt und (bei einem Sprite- oder MovieClip-Objekt) alle seine untergeordneten Objekte nicht aus derselben Domäne wie der Aufrufer stammen oder sich nicht in Inhalt befinden, auf den der Aufrufer über einen Aufruf der <codeph>Security.allowDomain()</codeph>-Methode zugreifen kann, tritt bei einem Aufruf von <codeph>draw()</codeph> eine SecurityError-Ausnahme auf. Diese Einschränkung gilt nicht für AIR-Inhalt in der Sicherheits-Sandbox der Anwendung.</p>
	 
	 <p platform="actionscript">Es gibt auch Beschränkungen für die Verwendung eines geladenen Bitmapbilds als <codeph>source</codeph>. Das Aufrufen der <codeph>draw()</codeph>-Methode ist erfolgreich, wenn das geladene Bild aus derselben Domäne stammt wie der Aufrufer. Des Weiteren kann eine domänenübergreifende Richtliniendatei auf dem Server des Bilds der Domäne des SWF-Inhalts, der die <codeph>draw()</codeph>-Methode aufruft, die Berechtigung erteilen. In diesem Fall setzen Sie die <codeph>checkPolicyFile</codeph>-Eigenschaft eines LoaderContext-Objekts und verwenden dieses Objekt als <codeph>context</codeph>-Parameter beim Aufrufen der <codeph>load()</codeph>-Methode des Loader-Objekts, das für das Laden des Bilds verwendet wird. Diese Sicherheitseinschränkungen gelten nicht für AIR-Inhalte in der Sicherheitssandbox der Anwendung.</p>
	 
	 <p>Unter Windows kann die <codeph>draw()</codeph>-Methode keinen SWF-Inhalt erfassen, der in einer HTML-Seite<ph platform="actionscript"> in einem HTMLLoader-Objekt in Adobe AIR</ph> eingebettet ist.</p>
	 
	 <p>Die <codeph>draw()</codeph>-Methode kann keinen PDF-Inhalt<ph platform="actionscript"> in Adobe AIR</ph> erfassen. Sie kann auch keinen in HTML eingebetteten SWF-Inhalt erfassen, bei dem das <codeph>wmode</codeph>-Attribut auf <codeph>"window"</codeph> gesetzt ist<ph platform="actionscript"> in Adobe AIR</ph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.draw.1.as"> Aus dem folgenden Beispiel geht hervor, wie Sie ein TextField-Objekt für ein BitmapData-Objekt zeichnen:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:fillRect"><apiName>fillRect</apiName><shortdesc>
	 Füllt einen rechteckigen Pixelbereich mit der angegebenen ARGB-Farbe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„rect“ hat den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Der zu füllende rechteckige Bereich.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Der ARGB-Farbwert, mit dem der Bereich gefüllt werden soll. ARGB-Farben werden häufig in einem hexadezimalen Format dargestellt, z. B. 0xFF336699.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Füllt einen rechteckigen Pixelbereich mit der angegebenen ARGB-Farbe.
	 
	 </apiDesc><example conref="examples\BitmapData.fillRect.1.as"> Aus dem folgenden Beispiel geht hervor, wie Sie einen rechteckigen Bereich eines BitmapData-Objekts blau füllen:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:floodFill"><apiName>floodFill</apiName><shortdesc>
	 Führt für ein Bild ausgehend von einer (x, y)-Koordinate einen Flood-Fill-Vorgang mit einer bestimmten Farbe durch.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>x</i>-Koordinate des Bilds.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>y</i>-Koordinate des Bilds.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Die ARGB-Farbe, die zum Füllen verwendet wird.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Führt für ein Bild ausgehend von einer (x, y)-Koordinate einen Flood-Fill-Vorgang durch.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Führt für ein Bild ausgehend von einer (<i>x</i>, <i>y</i>)-Koordinate einen Flood-Fill-Vorgang mit einer bestimmten Farbe durch. Die <codeph>floodFill()</codeph>-Methode ist mit dem Farbeimerwerkzeug verschiedener Mal- und Zeichenprogramme vergleichbar. Als Farbe wird eine ARGB-Farbe einschließlich Alpha- und Farbdaten angegeben.
	 
	 </apiDesc><example conref="examples\BitmapData.floodFill.1.as"> Aus dem folgenden Beispiel geht hervor, wie Sie einen Bereich eines BitmapData-Objekts rot füllen. Dabei geht es um den Bereich rund um das Pixel, das durch den Punkt <codeph>(10, 10)</codeph> definiert ist und bei dem alle Farben mit der Farbe dieses Punkts übereinstimmen.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:generateFilterRect"><apiName>generateFilterRect</apiName><shortdesc>
	 Bestimmt das Zielrechteck, auf das sich der Aufruf der applyFilter()-Methode auswirkt. Die Angaben beziehen sich auf ein BitmapData-Objekt, ein Quellrechteck und ein filter-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceRect“ oder „filter“ haben den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Zielrechteck, das aus einem Bild, dem Parameter <codeph>sourceRect</codeph> und einem Filter berechnet wird.
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>Ein filter-Objekt, das zur Berechnung des Zielrechtecks verwendet wird.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Legt das Zielrechteck fest, auf das sich der applyFilter()-Aufruf auswirkt.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Bestimmt das Zielrechteck, auf das sich der Aufruf der <codeph>applyFilter()</codeph>-Methode auswirkt. Die Angaben beziehen sich auf ein BitmapData-Objekt, ein Quellrechteck und ein filter-Objekt.
	 
	 <p>So bezieht sich ein Weichzeichnungsfilter normalerweise auf einen Bereich, der größer als das ursprüngliche Bild ist. Ein 100 x 200 Pixel großes Bild, das mit einer normalen BlurFilter-Instanz mit dem Wert <codeph>blurX = blurY = 4</codeph> gefiltert wird, erzeugt ein Zielrechteck von <codeph>(-2,-2,104,204)</codeph>. Mit der <codeph>generateFilterRect()</codeph>-Methode können Sie die Größe des Zielrechtecks vorherbestimmen und die Größe des Zielbilds vor der Filterung entsprechend anpassen.</p>
	 
	 <p>Einige Filter schneiden das Zielrechteck entsprechend der Größe des Zielbilds aus. So wird beispielsweise bei einem inneren <codeph>DropShadow</codeph>-Objekt kein größeres Bild als das Quellbild erzeugt. In dieser API wird das BitmapData-Objekt als Quellbegrenzung und nicht als <codeph>rect</codeph>-Quellparameter verwendet.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.generateFilterRect.1.as"> Aus diesem Beispiel geht die Verwendung der <codeph>generateFilterRect()</codeph>-Methode hervor, mit der Sie den rechteckigen Bereich bestimmen, auf den sich ein Weichzeichnungsfilter auswirkt. Die Ergebnisse der <codeph>generateFilterRect()</codeph>-Methode werden über die <codeph>trace()</codeph>-Funktion ausgegeben:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock> Beachten Sie, dass die <codeph>generateFilterRect()</codeph>-Methode den Filter nicht anwendet. Rufen Sie die <codeph>applyFilter()</codeph>-Methode auf, um den Filter anzuwenden. 
</example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getColorBoundsRect"><apiName>getColorBoundsRect</apiName><shortdesc>
	 Legt einen rechteckigen Bereich fest, der entweder innerhalb der Bitmap alle Pixel einer bestimmten Farbe vollständig umschließt (wenn der findColor-Parameter auf „true“ gesetzt ist) oder alle Pixel vollständig umschließt, die die angegebene Farbe nicht enthalten (wenn der findColor-Parameter auf „false“ gesetzt ist).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Bereich des Bilds, der die angegebene Farbe enthält. 
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Ein Hexadezimalwert, der die Bits der zu berücksichtigenden ARGB-Farbe festlegt. Der Farbwert wird durch Verwendung des <codeph>&amp;</codeph> (bitweises AND) mit diesem Hexadezimalwert kombiniert.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Ein Hexadezimalwert, der die ARGB-Farbe festlegt, die übereinstimmen soll (wenn <codeph>findColor</codeph> auf <codeph>true</codeph> gesetzt ist) bzw. <i>nicht</i> übereinstimmen soll (wenn <codeph>findColor</codeph> auf <codeph>false</codeph> gesetzt ist).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>findColor</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Wenn der Wert auf <codeph>true</codeph> gesetzt ist, werden die Begrenzungen eines bestimmten Farbwerts in einem Bild zurückgegeben. Wenn der Wert auf <codeph>false</codeph> gesetzt ist, werden die Begrenzungen der Bereiche zurückgegeben, in denen der betreffende Farbwert im Bild nicht vorkommt. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt einen rechteckigen Bereich fest, der entweder innerhalb der Bitmap alle Pixel einer bestimmten Farbe vollständig umschließt (wenn der Parameter <codeph>findColor</codeph> auf <codeph>true</codeph> gesetzt ist) oder alle Pixel vollständig umschließt, die die angegebene Farbe nicht enthalten (wenn der Parameter <codeph>findColor</codeph> auf <codeph>false</codeph> gesetzt ist). 
	 
	 <p>Wenn Sie beispielsweise mit einem Quellbild arbeiten und das Rechteck des Bilds bestimmen möchten, das Alphakanaldaten ungleich 0 (null) enthält, übergeben Sie <codeph>{mask: 0xFF000000, color: 0x00000000}</codeph> als Parameter. Ist der Parameter <codeph>findColor</codeph> auf <codeph>true</codeph> gesetzt, wird das gesamte Bild nach den Begrenzungen der Pixel durchsucht, für die <codeph>(value &amp; mask) == color</codeph> gilt (wobei <codeph>value</codeph> dem Farbwert der Pixel entspricht). Ist der Parameter <codeph>findColor</codeph> auf <codeph>false</codeph> gesetzt, wird das gesamte Bild nach den Begrenzungen der Pixel durchsucht, für die <codeph>(value &amp; mask) != color</codeph> gilt (wobei <codeph>value</codeph> dem Farbwert der Pixel entspricht). Wenn Sie also den weißen Bereich ermitteln möchten, der um ein Bild angeordnet ist, übergeben Sie <codeph>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</codeph>, um nach der Begrenzung aller nicht-weißen Pixel zu suchen.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getColorBoundsRect.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt erstellt, dessen Pixel in der oberen Hälfte rot sind. Als Nächstes wird die <codeph>getColorBoundsRect()</codeph>-Methode aufgerufen, um das Rechteck zu bestimmen, dessen Pixel rot sind (0xFF0000). Im nächsten Schritt wird dieselbe Methode aufgerufen, um das Rechteck zu bestimmen, dessen Pixel nicht rot sind (indem der Parameter <codeph>findColor</codeph> auf <codeph>false</codeph> gesetzt wird):
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getPixel"><apiName>getPixel</apiName><shortdesc>
	 Gibt eine Ganzzahl zurück, die einen RGB-Pixelwert eines BitmapData-Objekts an einem bestimmten Punkt (x, y) darstellt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine Zahl, die für den RGB-Pixelwert steht. Falls die <i>x</i>- und <i>y</i>-Koordinaten außerhalb der Bildbegrenzung liegen, gibt die Methode 0 (null) zurück. 
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>x</i>-Position eines Pixels.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>y</i>-Position eines Pixels.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt eine Ganzzahl zurück, die einen RGB-Pixelwert eines BitmapData-Objekts an einem bestimmten Punkt darstellt.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt eine Ganzzahl zurück, die einen RGB-Pixelwert eines BitmapData-Objekts an einem bestimmten Punkt (<i>x</i>, <i>y</i>) darstellt. Die <codeph>getPixel()</codeph>-Methode gibt einen nicht multiplizierten Pixelwert zurück. Es werden keine Alphadaten zurückgegeben.
	 
	 <p>Sämtliche Pixel eines BitmapData-Objekts werden als vormultiplizierte Farbwerte gespeichert. Bei diesen vormultiplizierten Bildpixeln sind die Farbkanalwerte für Rot, Grün und Blau bereits mit den Alphadaten multipliziert worden. Wenn also beispielsweise der Alphawert 0 (null) ist, lauten die Werte der RGB-Kanäle, unabhängig von ihren ursprünglichen Werten, ebenfalls 0 (null). Bei bestimmten Vorgängen kann dieser Datenverlust zu Problemen führen. Alle BitmapData-Methoden akzeptieren nicht multiplizierte Werte und geben diese auch zurück. Vor der Rückgabe der Werte wird die interne Pixeldarstellung von vormultipliziert in nicht multipliziert konvertiert. Vor dem Einstellen der Pixelrohdaten des Bilds wird der Pixelwert im Verlauf einer set-Operation vormultipliziert.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt mit roter Füllung erstellt und anschließend die <codeph>getPixel()</codeph>-Methode verwendet, um den Farbwert des linken oberen Pixels zu bestimmen.
<codeblock>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(1, 1);
trace(pixelValue.toString(16)); // ff0000;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixel32"><apiName>getPixel32</apiName><shortdesc>
	 Gibt einen ARGB-Farbwert zurück, der Alphakanal- und RGB-Daten enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine Zahl, die einen ARGB-Pixelwert darstellt. Falls die <i>x</i>- und <i>y</i>-Koordinaten außerhalb der Bildbegrenzung liegen, wird 0 (null) zurückgegeben.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>x</i>-Position eines Pixels.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>y</i>-Position eines Pixels.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen ARGB-Farbwert zurück, der Alphakanal- und RGB-Daten enthält. Diese Methode ähnelt der <codeph>getPixel()</codeph>-Methode, die einen RGB-Farbwert ohne Alphakanaldaten zurückgibt.
	 
	 <p>Sämtliche Pixel eines BitmapData-Objekts werden als vormultiplizierte Farbwerte gespeichert. Bei diesen vormultiplizierten Bildpixeln sind die Farbkanalwerte für Rot, Grün und Blau bereits mit den Alphadaten multipliziert worden. Wenn also beispielsweise der Alphawert 0 (null) ist, lauten die Werte der RGB-Kanäle, unabhängig von ihren ursprünglichen Werten, ebenfalls 0 (null). Bei bestimmten Vorgängen kann dieser Datenverlust zu Problemen führen. Alle BitmapData-Methoden akzeptieren nicht multiplizierte Werte und geben diese auch zurück. Vor der Rückgabe der Werte wird die interne Pixeldarstellung von vormultipliziert in nicht multipliziert konvertiert. Vor dem Einstellen der Pixelrohdaten des Bilds wird der Pixelwert im Verlauf einer set-Operation vormultipliziert.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel32.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt mit Farbfüllung erstellt und anschließend die <codeph>getPixel32()</codeph>-Methode verwendet, um den Farbwert des linken oberen Pixels zu bestimmen. Danach werden die hexadezimalen Werte für die einzelnen Farbkomponenten (Alpha, Rot, Grün und Blau) bestimmt:
<codeblock>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(1, 1);
var alphaValue:uint = pixelValue >> 24 &amp; 0xFF;
var red:uint = pixelValue >> 16 &amp; 0xFF;
var green:uint = pixelValue >> 8 &amp; 0xFF;
var blue:uint = pixelValue &amp; 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixels"><apiName>getPixels</apiName><shortdesc>
	 Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„rect“ hat den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Byte-Array, das die Pixel im gegebenen Rechteck repräsentiert.
	 
	 </apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein rechteckiger Bereich im aktuellen BitmapData-Objekt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten. Schreibt eine vorzeichenlose Ganzzahl (ein nicht multiplizierter 32-Bit-Pixelwert) für jedes Pixel in das Byte-Array.
	 
	 </apiDesc><example conref="examples\BitmapData.getPixels.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt mit zufälligen Störungspixeln erstellt und anschließend die <codeph>getPixels()</codeph>-Methode verwendet, um ein ByteArray-Objekt mit den Pixelwerten des BitmapData-Objekts zu füllen.
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getVector"><apiName>getVector</apiName><shortdesc>
	 Erzeugt ein Vektorarray aus einem rechteckigen Bereich mit Pixeldaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„rect“ hat den Wert null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Vektor, der das Rechteck darstellt.
	 </apiDesc><apiType value="Vector$uint"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein rechteckiger Bereich im aktuellen BitmapData-Objekt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erzeugt ein Vektor-Array aus einem rechteckigen Bereich mit Pixeldaten. Gibt ein Vector-Objekt aus vorzeichenlosen Ganzzahlen (ein nicht multiplizierter 32-Bit-Pixelwert) für das angegebene Rechteck zurück.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:histogram"><apiName>histogram</apiName><shortdesc>
	 Berechnet ein Histogramm mit 256 Binärzahlwerten für ein BitmapData-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Vector$Vector$Number"/></apiReturn><apiParam><apiItemName>hRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Bereich des BitmapData-Objekts, der verwendet wird.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Berechnet ein Histogramm mit 256 Binärzahlwerten für ein BitmapData-Objekt. Diese Methode gibt ein Vector-Objekt zurück, das vier Vector.&lt;Number>-Instanzen enthält (vier Vector-Objekte, die Number-Objekte enthalten). Die vier Vector-Instanzen stellen die rote, grüne, blaue und Alphakomponente in dieser Reihenfolge dar. Jede Vector-Instanz enthält 256 Werte, die die Zählung eines einzelnen Komponentenwerts zwischen 0 und 255 enthalten.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:hitTest"><apiName>hitTest</apiName><shortdesc>
	 Führt zwischen einer Bitmap und einem Punkt, einem Rechteck oder einer anderen Bitmap eine Kollisionserkennung auf Pixelebene durch.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der Parameter <codeph>secondObject</codeph> ist kein Point-, Rectangle-, Bitmap- oder BitmapData-Objekt.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>„firstPoint“ hat den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Es gilt <codeph>true</codeph>, wenn eine Kollisionserkennung stattfindet, andernfalls gilt <codeph>false</codeph>.
	    
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>firstPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc> Eine Position in der linken oberen Ecke des BitmapData-Bilds in einem beliebigen Koordinatenraum. Derselbe Koordinatenraum wird beim Definieren des Parameters <codeph>secondBitmapPoint</codeph> verwendet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>firstAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Der niedrigste Alphakanalwert, der für diese Kollisionserkennung als undurchsichtig gewertet wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein Rectangle-, Point-, Bitmap- oder BitmapData-Objekt.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondBitmapDataPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Punkt, der die Position eines Pixels im zweiten BitmapData-Objekt angibt. Sie sollten diesen Parameter nur verwenden, wenn der Wert von <codeph>secondObject</codeph> ein BitmapData-Objekt ist.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>1</apiData><apiDesc>Der niedrigste Alphakanalwert, der im zweiten BitmapData-Objekt als undurchsichtig gewertet wird. Sie sollten diesen Parameter nur verwenden, wenn der Wert von <codeph>secondObject</codeph> ein BitmapData-Objekt ist und beide BitmapData-Objekte transparent sind.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Führt zwischen einer Bitmap und einem Punkt, einem Rechteck oder einer anderen Bitmap eine Kollisionserkennung auf Pixelebene durch. Eine Kollision ist als Überlappung eines Punkts oder Rechtecks mit einem undurchsichtigen Pixel oder als Überlappung zweier undurchsichtiger Pixel definiert. Bei dieser Kollisionserkennung werden keine Dehnungen, Drehungen oder anderen Transformationen der Objekte berücksichtigt. 
	 
	 <p>Handelt es sich bei einem Bild um ein undurchsichtiges Bild, wird es bei dieser Methode als vollständig undurchsichtiges Rechteck betrachtet. Beide Bilder müssen transparent sein, damit eine Kollisionserkennung auf Pixelebene durchgeführt werden kann, bei der die Transparenz berücksichtigt wird. Wenn Sie zwei transparente Bilder testen, steuern die Parameter für die Alphaschwellen, welche Alphakanalwerte zwischen 0 und 255 als undurchsichtig betrachtet werden.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.hitTest.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt erstellt, das nur in einem rechteckigen Bereich (20, 20, 40, 40) undurchsichtig ist und die <codeph>hitTest()</codeph>-Methode mit einem Point-Objekt als <codeph>secondObject</codeph> aufruft. Beim ersten Aufruf definiert das Point-Objekt die obere linke Ecke des BitmapData-Objekts, die nicht undurchsichtig ist, und im zweiten Aufruf definiert das Point-Objekt den Mittelpunkt des BitmapData-Objekts, der undurchsichtig ist.
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:lock"><apiName>lock</apiName><shortdesc>
	 Sperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z. B. Bitmap-Objekte, nicht aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Sperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z. B. Bitmap-Objekte, nicht aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert. Um die Performance zu verbessern, verwenden Sie diese Methode zusammen mit der <codeph>unlock()</codeph>-Methode vor und nach mehreren Aufrufen der Methode <codeph>setPixel()</codeph> oder <codeph>setPixel32()</codeph>.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt basierend auf der <codeph>bitmapData</codeph>-Eigenschaft eines Bitmap-Objekts (<codeph>picture</codeph>) erstellt. Das Objekt ruft dann die <codeph>lock()</codeph>-Methode auf, bevor eine komplizierte benutzerdefinierte Funktion (<codeph>complexTransformation()</codeph>) aufgerufen wird, die das BitmapData-Objekt ändert. (Das <codeph>picture</codeph>-Objekt und die <codeph>complexTransformation()</codeph>-Funktion sind in diesem Beispiel nicht definiert.) Auch wenn die <codeph>complexTransformation()</codeph>-Funktion die <codeph>bitmapData</codeph>-Eigenschaft des <codeph>picture</codeph>-Objekts aktualisiert, werden die Änderungen erst wirksam, wenn der Code die <codeph>unlock()</codeph>-Methode des <codeph>bitmapData</codeph>-Objekts aufruft:
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:merge"><apiName>merge</apiName><shortdesc>
     Führt von einem Quellbild zu einem Zielbild eine Mischung pro Kanal durch.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf das aktuelle BitmapData-Objekt sein.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
     </apiDesc></apiParam><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Ein Hexadezimalwert, mit dem der Wert des Farbkanals Rot multipliziert wird. 
     </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Ein Hexadezimalwert, mit dem der Wert des Farbkanals Grün multipliziert wird. 
     </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Ein Hexadezimalwert, mit dem der Wert des Farbkanals Blau multipliziert wird.
     </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Ein Hexadezimalwert, mit dem der Alphatransparenzwert multipliziert wird.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Führt von einem Quellbild zu einem Zielbild eine Mischung pro Kanal durch. Für jeden Kanal und jedes Pixel wird ein neuer Wert berechnet. Dieser basiert auf den Kanalwerten der Quell- und Zielpixel. Im roten Kanal wird der neue Wert zum Beispiel wie folgt berechnet (wobei <codeph>redSrc</codeph> der Wert des roten Kanals für ein Pixel im Quellbild ist und <codeph>redDest</codeph> der Wert des roten Kanals für das entsprechende Pixel im Zielbild): 
	 <p>
	 <codeph> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </codeph>
	 </p>
	 
	 <p>Die Werte <codeph>redMultiplier</codeph>, <codeph>greenMultiplier</codeph>, <codeph>blueMultiplier</codeph> und <codeph>alphaMultiplier</codeph> sind die für die einzelnen Farbkanäle verwendeten Multiplikatoren. Verwenden Sie einen Hexadezimalwert zwischen <codeph>0</codeph> und <codeph>0x100</codeph> (256), wobei <codeph>0</codeph> festlegt, dass der volle Wert aus dem Ziel im Ergebnis verwendet wird, <codeph>0x100</codeph> festlegt, dass der volle Wert aus der Quelle verwendet wird, und Zahlen dazwischen festlegen, dass eine Mischung verwendet wird (zum Beispiel <codeph>0x80</codeph> für 50 %).</p>
	 
	 </apiDesc><example conref="examples\BitmapData.merge.1.as"> Im folgenden Beispiel werden zwei neue BitmapData-Objekte erstellt. Beide haben eine Größe von 100 x 80 Pixel. Das erste Objekt ist grün gefüllt, und das zweite Objekt ist rot gefüllt. Der Code ruft die <codeph>merge()</codeph>-Methode auf und führt die Pixel des zweiten BitmapData-Objekts mit den Pixeln des ersten BitmapData-Objekts zusammen. Dieser Schritt wird jedoch nur für einen angegebenen rechteckigen Bereich durchgeführt:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:noise"><apiName>noise</apiName><shortdesc>
	 Füllt ein Bild mit Pixeln, die zufällige Störungen darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der zu verwendende Anfangswert für den Zufallsgenerator. Wenn Sie alle anderen Parameter beibehalten, können Sie nur durch Änderung dieses Anfangswerts unterschiedliche pseudo-zufällige Ergebnisse erzielen. Bei der Störungsfunktion handelt es sich nicht um einen echten Zufallszahlengenerator, sondern eher um eine Zuordnungsfunktion, die mit gleich bleibendem Anfangswert immer dasselbe Ergebnis liefert.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>low</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der niedrigste zu erzeugende Wert für jeden Kanal (0 bis 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>high</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>255</apiData><apiDesc>Der höchste zu erzeugende Wert für jeden Kanal (0 bis 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc>Eine Zahl als beliebige Kombination der vier Farbkanalwerte (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph> und <codeph>BitmapDataChannel.ALPHA</codeph>). Sie können die Kanalwerte auch mithilfe des logischen OR-Operators (<codeph>|</codeph>) kombinieren. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein boolescher Wert. Ist der Wert <codeph>true</codeph>, wird durch die Einstellung aller Farbkanäle auf den gleichen Wert ein Graustufenbild erstellt. Der Wert des Alphakanals ist von der Einstellung dieses Parameters auf <codeph>true</codeph> nicht betroffen. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Füllt ein Bild mit Pixeln, die zufällige Störungen darstellen.
	 
	 </apiDesc><example conref="examples\BitmapData.noise.1.as"> Im folgenden Beispiel werden zwei BitmapData-Objekte erstellt, für die jeweils die <codeph>noise()</codeph>-Methode aufgerufen wird. Der Parameter <codeph>grayscale</codeph> wird jedoch auf <codeph>false</codeph> gesetzt, um den Aufruf der <codeph>noise()</codeph>-Methode des ersten Objekts durchzuführen, und er wird auf <codeph>true</codeph> gesetzt, um den Aufruf der <codeph>noise()</codeph>-Methode des zweiten Objekts durchzuführen:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapDataChannel/RED"><linktext>flash.display.BitmapDataChannel.RED</linktext></link><link href="flash.display.xml#BitmapDataChannel/BLUE"><linktext>flash.display.BitmapDataChannel.BLUE</linktext></link><link href="flash.display.xml#BitmapDataChannel/GREEN"><linktext>flash.display.BitmapDataChannel.GREEN</linktext></link><link href="flash.display.xml#BitmapDataChannel/ALPHA"><linktext>flash.display.BitmapDataChannel.ALPHA</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:paletteMap"><apiName>paletteMap</apiName><shortdesc>
	 Ordnet die Farbkanalwerte in einem Bild mit maximal vier Arrays von Farbpalettendaten neu zu, wobei die einzelnen Arrays jeweils einen Kanal darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt innerhalb des Zielbilds (das aktuelle BitmapData-Objekt), der der linken oberen Ecke des Quellrechtecks entspricht.
	 </apiDesc></apiParam><apiParam><apiItemName>redArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Wenn <codeph>redArray</codeph> nicht <codeph>null</codeph> ist, gilt <codeph>red = redArray[source red value] else red = source rect value</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>greenArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Wenn <codeph>greenArray</codeph> nicht <codeph>null</codeph> ist, gilt <codeph>green = greenArray[source green value] else green = source green value</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>blueArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Wenn <codeph>blueArray</codeph> nicht <codeph>null</codeph> ist, gilt <codeph>blue = blueArray[source blue value] else blue = source blue value</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Wenn <codeph>alphaArray</codeph> nicht <codeph>null</codeph> ist, gilt <codeph>alpha = alphaArray[source alpha value] else alpha = source alpha value</codeph>.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ordnet die Farbkanalwerte in einem Bild mit maximal vier Arrays von Farbpalettendaten neu zu, wobei die einzelnen Arrays jeweils einen Kanal darstellen. 
	 
	 <p><ph platform="actionscript">Flash Player oder</ph> AIR erzeugt das Ergebnisbild mit den folgenden Schritten:</p>
	 
	 <ol>
	 
	 <li>Nach der Berechnung der einzelnen Werte für Rot, Grün, Blau und Alpha werden diese mithilfe einer standardisierten 32-Bit-Ganzzahlarithmetik addiert. </li>
	 
	 <li>Die Kanalwerte jedes Pixels für Rot, Grün, Blau und Alpha werden in einzelne Werte zwischen 0 und 255 extrahiert. Mithilfe dieser Werte werden dann die neuen Farbwerte im entsprechenden Array ermittelt: <codeph>redArray</codeph>, <codeph>greenArray</codeph>, <codeph>blueArray</codeph> und <codeph>alphaArray</codeph>. Jedes dieser vier Arrays sollte 256 Werte enthalten. </li>
	 
	 <li>Nach der Ermittlung der neuen Kanalwerte werden diese in einem ARGB-Standardwert zusammengefasst, der auf das Pixel angewendet wird.</li>
	 
	 </ol>
	 
	 <p>Mit dieser Methode können auch kanalübergreifende Effekte unterstützt werden. Jedes Eingabe-Array kann dabei vollständige 32-Bit-Werte enthalten, und beim Addieren der Werte treten keine Verschiebungen auf. Allerdings unterstützt diese Routine keine Festsetzung pro Kanal. </p>
	 
	 <p>Wird für einen Kanal kein Array angegeben, wird der Farbkanal vom Quellbild in das Zielbild kopiert.</p>
	 
	 <p>Diese Methode kann für eine ganze Reihe von Effekten genutzt werden, wie zum Beispiel eine allgemeine Palettenzuordnung (Auswählen einzelner Kanäle und deren Umwandlung in ein Falschfarbenbild). Sie können diese Methode auch für eine Reihe von komplexen Farbänderungsalgorithmen verwenden, z. B. Gamma, Kurven, Ebenen und Quantisierung.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.paletteMap.1.as"> Im folgenden Beispiel wird ein grünes BitmapData-Objekt mit rotem Mittelquadrat erstellt und anschließend die <codeph>paletteMap()</codeph>-Methode verwendet, um in der unteren rechteckigen Hälfte des BitmapData-Objekts Rot durch Grün zu ersetzen:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:perlinNoise"><apiName>perlinNoise</apiName><shortdesc>
	 Erstellt ein Perlin-Störungsbild.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>baseX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Häufigkeit der Verwendung in <i>x</i>-Richtung. Übergeben Sie zur Erstellung einer Störung für ein Bild der Größe 64 x 128 Pixel als <codeph>baseX</codeph>-Wert beispielsweise die Zahl 64. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>baseY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Häufigkeit der Verwendung in <i>y</i>-Richtung. Übergeben Sie zur Erstellung einer Störung für ein Bild der Größe 64 x 128 Pixel als <codeph>baseY</codeph>-Wert beispielsweise die Zahl 128. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numOctaves</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Anzahl der Oktaven bzw. einzelnen Störungsfunktionen die zur Erstellung der Störung kombiniert werden. Größere Anzahlen führen zur Erstellung von detaillierteren Bildern. Allerdings benötigen größere Oktavenanzahlen auch mehr Verarbeitungszeit.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der zu verwendende Anfangswert für den Zufallsgenerator. Wenn Sie alle anderen Parameter beibehalten, können Sie nur durch Änderung dieses Anfangswerts unterschiedliche pseudo-zufällige Ergebnisse erzielen. Bei der Perlin-Störungsfunktion handelt es sich nicht um einen echten Zufallszahlengenerator, sondern eher um eine Zuordnungsfunktion, die mit gleich bleibendem Anfangswert immer dasselbe Ergebnis liefert.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>stitch</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Ein boolescher Wert. Ist der Wert <codeph>true</codeph>, werden die Übergänge des Bilds geglättet, um einen nahtlosen Texturenübergang für Füllmuster zu erstellen, mit denen Bitmaps gefüllt werden können.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fractalNoise</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Ein boolescher Wert. Ist der Wert <codeph>true</codeph>, wird eine fraktale Störung erzeugt, ansonsten eine Turbulenz. In einem Bild mit Turbulenzen gibt es sichtbare Bruchstellen in den Farbverläufen, die sich gut für scharf abgegrenzte visuelle Effekte eignen, wie Flammen oder Wellen.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc> Eine Zahl als beliebige Kombination der vier Farbkanalwerte (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph> und <codeph>BitmapDataChannel.ALPHA</codeph>). Sie können die Kanalwerte auch mithilfe des logischen OR-Operators (<codeph>|</codeph>) kombinieren.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein boolescher Wert. Ist der Wert <codeph>true</codeph>, wird durch die Einstellung aller Werte für Rot, Grün und Blau auf den gleichen Wert ein Graustufenbild erstellt. Der Wert von Alpha ist nicht betroffen, wenn dieser Wert auf <codeph>true</codeph> gesetzt ist.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>offsets</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array von Punkten, die dem <i>x</i>- und <i>y</i>-Offset jeder einzelnen Oktave entsprechen. Durch Änderung der Offset-Werte können Sie bei perlinNoise-Bildern glatte Ebenenübergänge erzielen. Jeder Punkt im Offset-Array bezieht sich auf eine bestimmte Oktavenstörfunktion.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erstellt ein Perlin-Störungsbild.
	 
	 <p>Der Perlin-Störungsalgorithmus interpoliert und kombiniert mehrere zufällige als Oktaven bezeichnete Störungsfunktionen in einer Funktion, die natürlicher wirkende Zufallsstörungen erzeugt. Genau wie in der Musik weist auch hier jede Oktavenfunktion die doppelte Frequenz der jeweils untergeordneten Oktave auf. Die Perlin-Störungen werden als „Fraktalsumme der Störungen“ bezeichnet, da sie mehrere Arten von Störungsdaten unterschiedlicher Detailstufen zusammenfassen.</p>
	 
	 <p>Durch Anwendung von Perlin-Störungsfunktionen können Naturphänomene und Landschaften simuliert werden, wie Holzmaserung, Wolken oder Bergketten. Zumeist werden die Ergebnisse einer Perlin-Störungsfunktion nicht direkt angezeigt, sondern dienen zur Optimierung anderer Bilder sowie zum Erzeugen von pseudo-zufälligen Variationen.</p>
	 
	 <p>Einfache digital-zufällige Störungsfunktionen produzieren häufig Bilder mit scharfen Kontrasten, die in der Natur aber nicht allzu häufig vorkommen. Der Perlin-Störungsalgorithmus arbeitet mit einer Überlagerung von mehreren Störungsfunktionen mit unterschiedlicher Detailstufe und erzielt damit glattere Werteänderungen bei benachbarten Pixeln.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.perlinNoise.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt der Größe 200 x 200 Pixel erstellt, das die <codeph>perlinNoise()</codeph>-Methode aufruft, um einen roten und blauen Wasserfarbeneffekt zu erzielen:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:pixelDissolve"><apiName>pixelDissolve</apiName><shortdesc>
	 Führt eine Pixelauflösung von einem Quellbild zu einem Zielbild oder anhand desselben Bilds durch.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Der Wert von „numPixels“ ist negativ.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der neue Anfangswert für den Zufallsgenerator für nachfolgende Aufrufe.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Anfangswert des Zufallsgenerators für die Pixelauflösung. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numPixels</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Standardwert beträgt 1/30 des Quellbereichs (Breite x Höhe).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Ein ARGB-Farbwert, mit dem Sie die Pixel anfüllen können, deren Quellwerte mit den Zielwerten übereinstimmen. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Führt eine Pixelauflösung von einem Quellbild zu einem Zielbild oder anhand desselben Bilds durch. <ph platform="actionscript">Flash Player oder</ph> AIR verwendet einen <codeph>randomSeed</codeph>-Wert, um eine zufällige Pixelauflösung zu erzeugen. Der Rückgabewert dieser Funktion muss bei nachfolgenden Aufrufen übergeben werden, um die Pixelauflösung bis zum Ende beizubehalten.
	 
	 <p>Stimmen Quell- und Zielbild nicht überein, werden die Pixel vom Quellbild mit all ihren Eigenschaften in das Zielbild kopiert. Dieser Vorgang ermöglicht das Anfüllen mit Pixeln von einem leeren Bild zu einem vollständig ausgefüllten Bild.</p>
	 
	 <p>Falls das Quell- und das Zielbild identisch sind, werden die Pixel mit dem Parameter <codeph>color</codeph> gefüllt. Dieser Vorgang ermöglicht ein Auflösen eines vollständig angefüllten Bilds. In diesem Modus wird der Zielparameter <codeph>point</codeph> ignoriert.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.pixelDissolve.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>pixelDissolve()</codeph>-Methode ein graues BitmapData-Objekt durch Auflösung in Schritten von je 40 Pixeln in ein rotes Objekt umgewandelt, bis die Farbe aller Pixel geändert wurde:
<codeblock>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 &amp;&amp; grayRegion.height == 0 ) {
        tim.stop();
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:scroll"><apiName>scroll</apiName><shortdesc>
	 Führt für ein Bild einen Bildlauf anhand eines bestimmten Pixelbetrags (x, y) durch.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Betrag, um den ein horizontaler Bildlauf durchgeführt werden soll.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Betrag, um den ein vertikaler Bildlauf durchgeführt werden soll.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Führt für ein Bild einen Bildlauf anhand eines bestimmten Pixelbetrags (<i>x</i>, <i>y</i>) durch. Die Randzonen außerhalb des Bildlaufbereichs bleiben unverändert.
	 
	 </apiDesc><example conref="examples\BitmapData.scroll.1.as"> Das folgende Beispiel zeigt die Auswirkung eines Bildlaufs für ein BitmapData-Objekt um 40 Pixel nach rechts:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:setPixel"><apiName>setPixel</apiName><shortdesc>
	 Legt den Farbwert eines einzelnen Pixels eines BitmapData-Objekts fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>x</i>-Position des Pixels, dessen Wert geändert wird.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>y</i>-Position des Pixels, dessen Wert geändert wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Die resultierende RGB-Farbe für das Pixel. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt den Farbwert eines einzelnen Pixels eines BitmapData-Objekts fest. Der aktuelle Alphakanalwert des Bildpixels bleibt während dieses Vorgangs erhalten. Der Wert des RGB-Farbparameters wird als nicht multiplizierter Farbwert angesehen.
	 
	 <p><b>Hinweis:</b> Um die Performance zu verbessern, wenn Sie die Methode <codeph>setPixel()</codeph> oder <codeph>setPixel32()</codeph> wiederholt verwenden, rufen Sie die <codeph>lock()</codeph>-Methode auf, bevor Sie die Methode <codeph>setPixel()</codeph> oder <codeph>setPixel32()</codeph> aufrufen. Rufen Sie anschließend die <codeph>unlock()</codeph>-Methode auf, nachdem Sie alle Pixeländerungen vorgenommen haben. Dieser Vorgang verhindert, dass Objekte, die auf diese BitmapData-Instanz verweisen, erst aktualisiert werden, wenn Sie die Pixeländerungen abgeschlossen haben.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>setPixel()</codeph>-Methode in einem BitmapData-Objekt eine rote Linie gezeichnet:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixel32"><apiName>setPixel32</apiName><shortdesc>
	 Legt den Farb- und Alphatransparenzwert eines einzelnen Pixels eines BitmapData-Objekts fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>x</i>-Position des Pixels, dessen Wert geändert wird.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die <i>y</i>-Position des Pixels, dessen Wert geändert wird.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Die resultierende ARGB-Farbe für das Pixel. Ist die Bitmap undurchsichtig (also nicht transparent), wird der Alphatransparenzwert in diesem Farbwert ignoriert.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt den Farb- und Alphatransparenzwert eines einzelnen Pixels eines BitmapData-Objekts fest. Diese Methode ähnelt der <codeph>setPixel()</codeph>-Methode. Der Hauptunterschied besteht darin, dass die <codeph>setPixel32()</codeph>-Methode einen ARGB-Farbwert mit Alphakanaldaten als Eingabe benötigt.
	 
	 <p>Sämtliche Pixel eines BitmapData-Objekts werden als vormultiplizierte Farbwerte gespeichert. Bei diesen vormultiplizierten Bildpixeln sind die Farbkanalwerte für Rot, Grün und Blau bereits mit den Alphadaten multipliziert worden. Wenn also beispielsweise der Alphawert 0 (null) ist, lauten die Werte der RGB-Kanäle, unabhängig von ihren ursprünglichen Werten, ebenfalls 0 (null). Bei bestimmten Vorgängen kann dieser Datenverlust zu Problemen führen. Alle BitmapData-Methoden akzeptieren nicht multiplizierte Werte und geben diese auch zurück. Vor der Rückgabe der Werte wird die interne Pixeldarstellung von vormultipliziert in nicht multipliziert konvertiert. Vor dem Einstellen der Pixelrohdaten des Bilds wird der Pixelwert im Verlauf einer set-Operation vormultipliziert.</p>
	 
	 <p><b>Hinweis:</b> Um die Performance zu verbessern, wenn Sie die Methode <codeph>setPixel()</codeph> oder <codeph>setPixel32()</codeph> wiederholt verwenden, rufen Sie die <codeph>lock()</codeph>-Methode auf, bevor Sie die Methode <codeph>setPixel()</codeph> oder <codeph>setPixel32()</codeph> aufrufen. Rufen Sie anschließend die <codeph>unlock()</codeph>-Methode auf, nachdem Sie alle Pixeländerungen vorgenommen haben. Dieser Vorgang verhindert, dass Objekte, die auf diese BitmapData-Instanz verweisen, erst aktualisiert werden, wenn Sie die Pixeländerungen abgeschlossen haben.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel32.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>setPixel32()</codeph>-Methode in einem BitmapData-Objekt eine transparente rote Linie gezeichnet (alpha == 0x60):
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixels"><apiName>setPixels</apiName><shortdesc>
	 Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Das <codeph>inputByteArray</codeph>-Objekt enthält nicht genügend Daten, um den Bereich des <codeph>rect</codeph>-Rechtecks zu füllen. Die Methode füllt so viele Pixel wie möglich, bevor die Ausnahme ausgelöst wird.
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>„rect“ oder „inputByteArray“ haben den Wert null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Legt den rechteckigen Bereich des BitmapData-Objekts fest.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputByteArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Ein ByteArray-Objekt, das aus nicht multiplizierten 32-Bit-Pixelwerten besteht, die im rechteckigen Bereich verwendet werden sollen.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten. Für jedes Pixel wird die <codeph>ByteArray.readUnsignedInt()</codeph>-Methode aufgerufen, und der Rückgabewert wird in das Pixel geschrieben. Endet das Byte-Array, bevor das gesamte Rechteck geschrieben ist, gibt die Funktion den Wert zurück. Im Byte-Array werden als Daten 32-Bit-ARGB-Pixelwerte erwartet. Bevor oder nachdem die Pixel gelesen werden, wird im Byte-Array keine Suche durchgeführt.  
	 
	 </apiDesc><example conref="examples\BitmapData.setPixels.1.as"> Im folgenden Beispiel werden mit den Methoden <codeph>getPixels()</codeph> und <codeph>setPixels()</codeph> Pixel aus einem BitmapData-Objekt in ein anderes kopiert:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/readUnsignedInt()"><linktext>flash.utils.ByteArray.readUnsignedInt()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setVector"><apiName>setVector</apiName><shortdesc>
	 Konvertiert einen Vektor in einen rechteckigen Bereich mit Pixeldaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Das Vectorarray ist nicht groß genug, um alle Pixeldaten zu lesen.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Legt den rechteckigen Bereich des BitmapData-Objekts fest.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputVector</apiItemName><apiType value="Vector$uint"/><apiDesc>Ein Vector-Objekt, das aus nicht multiplizierten 32-Bit-Pixelwerten besteht, die im rechteckigen Bereich verwendet werden.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Konvertiert einen Vektor in einen rechteckigen Bereich mit Pixeldaten. Pro Pixel wird ein Vector-Element gelesen und in das BitmapData-Pixel geschrieben. Im Vector werden als Daten 32-Bit-ARGB-Pixelwerte erwartet. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:threshold"><apiName>threshold</apiName><shortdesc>
	 Prüft die Pixelwerte eines Bilds für einen angegebenen Schwellenwert und weist den Pixeln, die die Bedingung des Tests erfüllen, neue Farbwerte zu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>„sourceBitmapData“, „sourceRect“, „destPoint“ oder „operation“ haben den Wert null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Der operation-String ist keine zulässige Operation. 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die Anzahl der geänderten Pixel.
 	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Einer der folgenden Vergleichsoperatoren, der als String übergeben wird: „&lt;“, „&lt;=“, „>“, „>=“, „==“, „!=“
	 
	 </apiDesc></apiParam><apiParam><apiItemName>threshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Der Wert, auf den jedes Pixel geprüft wird, um festzustellen, ob der Schwellenwert eingehalten oder überschritten wird.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Farbwert, auf den ein Pixel gesetzt wird, falls der Schwellentest erfolgreich ist. Der Standardwert lautet 0x00000000.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>Die Maske, die zum Isolieren einer Farbkomponente verwendet wird. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>copySource</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Lautet der Wert <codeph>true</codeph>, werden Pixelwerte aus dem Quellbild auch in das Zielobjekt kopiert, wenn der Schwellentest fehlschlägt. Lautet der Wert <codeph>false</codeph>, wird das Quellbild nicht kopiert, wenn der Schwellentest fehlschlägt. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Prüft die Pixelwerte eines Bilds für einen angegebenen Schwellenwert und weist den Pixeln, die die Bedingung des Tests erfüllen, neue Farbwerte zu. Mithilfe der <codeph>threshold()</codeph>-Methode können Sie in einem Bild ganze Farbbereiche isolieren und ersetzen sowie andere logische Operationen auf Bildpixel anwenden. 
	 
	 <p>Die Testlogik der <codeph>threshold()</codeph>-Methode lautet wie folgt:</p> 
	 
	 <ol> 
	 
	 	<li>Wenn <codeph>((pixelValue &amp; mask) operation (threshold &amp; mask))</codeph> gilt, wird das Pixel auf <codeph>color</codeph> gesetzt.</li>
	 
	 	<li>Wenn hingegen <codeph>copySource == true</codeph> gilt, wird das Pixel auf den entsprechenden Pixelwert aus <codeph>sourceBitmap</codeph> gesetzt.</li>
	 </ol>
	 
	 <p>Der Parameter <codeph>operation</codeph> gibt den Vergleichsoperator für den Schwellentest an. Wenn Sie beispielsweise „==“ als <codeph>operation</codeph>-Parameter eingeben, können Sie in einem Bild eine Farbe mit einem bestimmten Wert isolieren. Oder wenn Sie <codeph>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</codeph> verwenden, können Sie alle Pixel im Zielbild auf vollständig transparent einstellen, wenn der Alphawert des Quellbildpixels kleiner als 0x7F ist. Sie können dieses Verfahren für animierte Übergänge und andere Effekte verwenden.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.threshold.1.as"> Im folgenden Beispiel wird mithilfe der <codeph>perlinNoise()</codeph>-Methode einem BitmapData-Objekt ein blaues und rotes Muster hinzugefügt und anschließend die <codeph>threshold()</codeph>-Methode verwendet, um die entsprechenden Pixel aus dem ersten BitmapData-Objekt in ein zweites Objekt zu kopieren. Dabei werden die Pixel, bei denen der Rotwert größer als 0x80 (50 %) ist, durch ein Pixel mit transparentem Rot (0x20FF0000) ersetzt:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, ">", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:unlock"><apiName>unlock</apiName><shortdesc>
	 Entsperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z. B. Bitmap-Objekte, aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>changeRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Bereich des BitmapData-Objekts, der sich geändert hat. Wenn Sie für diesen Parameter keinen Wert angeben, wird der gesamte Bereich des BitmapData-Objekts als geändert betrachtet. Dieser Parameter erfordert Flash Player 9.0.115.0 oder höher.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Entsperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z. B. Bitmap-Objekte, aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert. Um die Performance zu verbessern, verwenden Sie diese Methode zusammen mit der <codeph>lock()</codeph>-Methode vor und nach mehreren Aufrufen der Methode <codeph>setPixel()</codeph> oder <codeph>setPixel32()</codeph>.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> Im folgenden Beispiel wird ein BitmapData-Objekt basierend auf der <codeph>bitmapData</codeph>-Eigenschaft eines Bitmap-Objekts (<codeph>picture</codeph>) erstellt. Das Objekt ruft dann die <codeph>lock()</codeph>-Methode auf, bevor eine komplizierte benutzerdefinierte Funktion (<codeph>complexTransformation()</codeph>) aufgerufen wird, die das BitmapData-Objekt ändert. (Das <codeph>picture</codeph>-Objekt und die <codeph>complexTransformation()</codeph>-Funktion sind in diesem Beispiel nicht definiert.) Auch wenn die <codeph>complexTransformation()</codeph>-Funktion die <codeph>bitmapData</codeph>-Eigenschaft des <codeph>picture</codeph>-Objekts aktualisiert, werden die Änderungen erst wirksam, wenn der Code die <codeph>unlock()</codeph>-Methode des <codeph>bitmapData</codeph>-Objekts aufruft:
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiValue id="flash.display:BitmapData:height:get"><apiName>height</apiName><shortdesc>
	 Die Höhe der Bitmap in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Höhe der Bitmap in Pixel.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:rect:get"><apiName>rect</apiName><shortdesc>
	 Das Rechteck, das die Größe und Lage der Bitmap definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
	 Das Rechteck, das die Größe und Lage der Bitmap definiert. Der obere und linke Rand des Rechtecks liegen jeweils an der Position 0 (null). Die Werte für Breite und Höhe sind mit der Breite und Höhe des BitmapData-Objekts identisch.
   	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Gibt an, ob die Bitmap Transparenz pro Pixel unterstützt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob die Bitmap Transparenz pro Pixel unterstützt. Sie können diesen Wert nur dann einstellen, wenn Sie beim Erstellen des BitmapData-Objekts den Wert <codeph>true</codeph> für den Parameter <codeph>transparent</codeph> des Konstruktors übergeben. Nachdem Sie ein BitmapData-Objekt erstellt haben, können Sie dieses Objekt auf die Unterstützung der Transparenz pro Pixel prüfen, indem Sie feststellen, ob die <codeph>transparent</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt ist.
   	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:width:get"><apiName>width</apiName><shortdesc>
	 Die Breite der Bitmap in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Breite der Bitmap in Pixel.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:JointStyle"><apiName>JointStyle</apiName><shortdesc>
Die JointStyle-Klasse ist eine Zusammenfassung von Konstantenwerten, die den beim Zeichnen von Linien zu verwendenden Verbindungstyp festlegen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die JointStyle-Klasse ist eine Zusammenfassung von Konstantenwerten, die den beim Zeichnen von Linien zu verwendenden Verbindungstyp festlegen. Diese Konstanten werden als Werte im Parameter <codeph>joints</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode verwendet. Die Methode unterstützt drei Verbindungstypen: Winkel, Rund und Abgeflacht (vgl. die folgenden Beispiele): 

<p><adobeimage alt="MITER, ROUND und BEVEL" href="../../images/linejoin.jpg"/></p> 

 
</apiDesc><example conref="examples\JointStyleExample.as"> Im folgenden Beispiel wird die JointStyleExample-Klasse verwendet, um das Ergebnis von drei verschiedenen Verbindungsstilen zu verdeutlichen, die auf die drei verbundenen Linien angewendet werden. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Die Eigenschaften der Linien sind wie folgt festgelegt:
  <ul>
      <li>Die Linienlänge ist auf 80 Pixel festgelegt.</li>
      <li>Die Rahmenfarbe ist auf Orange gesetzt.</li>
      <li>Die Rahmenbreite ist auf 30 Pixel festgelegt.</li>
      <li>Die Hervorhebungsfarbe ist auf Grau gesetzt.</li>
      <li>Die Hervorhebungsgröße ist auf 0 Pixel festgelegt.</li>
      <li>Alpha ist auf 1 (also vollständige Füllung) gesetzt.</li>
      <li>Die Funktion „pixelHinting“ ist auf „false“ gesetzt (Striche werden nicht als ganze Pixel angezeigt).</li>
      <li>Als Modus für die Linienskalierung ist „normal“ angegeben, sodass die Stärke skaliert wird.</li>
      <li>Die Rahmenabschlüsse und Winkelgrenze sind deklariert, jedoch nicht gesetzt, sodass die Standardwerte verwendet werden.</li>
  </ul></li>
  <li>Der Klassenkonstruktor erstellt drei Gruppen von jeweils zwei verbundenen Liniensegmenten. Die Segmente beginnen bei x = 0, y = 0, indem für die drei Verbindungsstile (Winkel, Rund und Abgeflacht) jeweils die <codeph>doDrawCorner()</codeph>-Methode aufgerufen wird. Bei jedem der drei Aufrufe der <codeph>doDrawCorner()</codeph>-Methode werden die vorher aufgeführten Verbindungsstile und Eigenschaften verwendet, um zwei verbundene Liniensegmente und die dazugehörigen Linienhervorhebungen zu zeichnen. Dazu wird zuerst ein neues <codeph>child</codeph>-Shape-Objekt erstellt, und dann werden die Methoden der Graphics-Klasse verwendet, um den Linienstil festzulegen und die Linien und Hervorhebungen zu zeichnen. Jede Instanz von <codeph>child</codeph> wird der Anzeigeliste hinzugefügt und sofort auf der Bühne gezeichnet.</li>
  <li>Die verbundenen Liniensegmente werden erneut gezeichnet, indem die <codeph>refreshLayout()</codeph>-Methode mit dem Wert y = 80 Pixel und dem Anfangspunkt bei x = 80 Pixel mit einem Abstand von 25 Pixel zwischen den Liniensegmenten verwendet wird.</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class JointStyleExample extends Sprite {
        private var size:uint                  = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderCaps:String;
        private var borderMiterLimit:uint;

        public function JointStyleExample() {
            doDrawCorner(JointStyle.MITER);
            doDrawCorner(JointStyle.ROUND);
            doDrawCorner(JointStyle.BEVEL);
            refreshLayout();
        }

        private function doDrawCorner(jointStyle:String):void {
            var halfSize:uint = Math.round(size / 2);
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     borderCaps,
                                     jointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = size;
            lastChild.y = size;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = size;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:JointStyle:BEVEL"><apiName>BEVEL</apiName><shortdesc>
	
	Legt im Parameter „joints“ der flash.display.Graphics.lineStyle()-Methode abgeschrägte Verbindungen fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bevel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Legt im Parameter <codeph>joints</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode abgeflachte Verbindungen fest.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:MITER"><apiName>MITER</apiName><shortdesc>
	
	Legt im Parameter „joints“ der flash.display.Graphics.lineStyle()-Methode gewinkelte Verbindungen fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>miter</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Legt im Parameter <codeph>joints</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode gewinkelte Verbindungen fest.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	
	Legt im Parameter „joints“ der flash.display.Graphics.lineStyle()-Methode runde Verbindungen fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Legt im Parameter <codeph>joints</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode runde Verbindungen fest.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:AVM1Movie"><apiName>AVM1Movie</apiName><shortdesc>
	„AVM1Movie“ ist eine einfache Klasse, die AVM1-Movieclips repräsentiert, die noch ActionScript 1.0 oder 2.0 verwenden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
	„AVM1Movie“ ist eine einfache Klasse, die AVM1-Movieclips repräsentiert, die noch ActionScript 1.0 oder 2.0 verwenden. (AVM1 ist die ActionScript-Virtual-Machine zum Ausführen von ActionScript 1.0 und 2.0. AVM2 ist die ActionScript-Virtual-Machine zum Ausführen von ActionScript 3.0). Wenn von einem Loader-Objekt eine SWF-Datei für Flash Player 8 oder eine frühere Version geladen wird, wird ein AVM1Movie-Objekt erstellt. Das AVM1Movie-Objekt kann aus der DisplayObject-Klasse übernommene Methoden und Eigenschaften verwenden (wie <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> usw.). Allerdings ist zwischen dem AVM1Movie-Objekt und AVM2-Objekten keine Interoperabilität (wie etwa das Aufrufen von Methoden oder Verwenden von Parametern) zulässig.
	
	<p>Es gibt verschiedene Einschränkungen für eine von einer AVM2-SWF-Datei geladene AVM1-SWF-Datei:</p>
	
	<ul>
	
	<li>Das geladene AVM1Movie-Objekt betreibt ein Pseudo-Stammobjekt für die AVM1-SWF-Datei und alle darüber geladenen AVM1-SWF-Dateien (als ob die ActionScript 1.0-Eigenschaft <codeph>lockroot</codeph> auf <codeph>true</codeph> gesetzt worden wäre). Der AVM1-Film befindet sich immer über einer etwaigen ActionScript 1.0- oder 2.0-Codeausführung in untergeordneten Objekten. Der Wert der <codeph>_root</codeph>-Eigenschaft ist für geladene untergeordnete Objekte immer diese AVM1-SWF-Datei, es sei denn, in einer geladenen AVM1-SWF-Datei ist die <codeph>lockroot</codeph>-Eigenschaft gesetzt worden.</li>
	
	<li>AVM1-Inhalte können Dateien nicht in Ebenen laden. Beispielsweise ist dies nicht möglich, indem <codeph>loadMovieNum("url", levelNum)</codeph> aufgerufen wird.</li>
	
	<li>Die AVM1-SWF-Datei, die von einer AVM2-SWF-Datei geladen worden ist, kann in <codeph>this</codeph> keine weitere SWF-Datei mehr laden. D. h., sie kann keine andere SWF-Datei auf sich selbst laden. Allerdings ist es für Sprite- oder MovieClip-Objekte und andere AVM1-SWF-Dateien, die von dieser SWF-Datei geladen worden sind, durchaus möglich, andere Dateien in <codeph>this</codeph> zu laden.</li>
	
	</ul>
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>DisplayObject</linktext></link><link href="flash.display.xml#Loader"><linktext>Loader</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
	 Eine ShaderInput-Instanz stellt ein einzelnes Eingabebild für ein Shaderkernel dar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Eine ShaderInput-Instanz stellt ein einzelnes Eingabebild für ein Shaderkernel dar. Ein Kernel kann so definiert sein, dass es null, ein oder mehrere Quellbilder akzeptiert, die bei der Kernelausführung verwendet werden. Eine ShaderInput-Instanz stellt einen Mechanismus für das Festlegen des Eingabebilds, das bei der Shaderausführung verwendet wird, bereit. Zum Festlegen eines Eingabewerts erstellen Sie eine BitmapData-, ByteArray- oder Vector.&lt;Number>-Instanz, die die Bilddaten enthält, und weisen sie der <codeph>input</codeph>-Eigenschaft zu.
	 
	 <p>Auf eine ShaderInput-Instanz, die ein Eingabebild für eine Shader-Instanz darstellt, wird als Eigenschaft der <codeph>data</codeph>-Eigenschaft der Shader-Instanz zugegriffen. Die ShaderInput-Eigenschaft hat denselben Namen wie die Eingabe im Shadercode. Wenn ein Shader z. B. eine Eingabe namens <codeph>src</codeph> festlegt, ist die ShaderInput-Instanz, die die <codeph>src</codeph>-Eingabe darstellt, als <codeph>src</codeph>-Eigenschaft verfügbar, wie im Beispiel zu sehen ist:</p>
	 
	 <codeblock>myShader.data.src.image = new BitmapData(50, 50, true, 0xFF990000);</codeblock>
	 
	 <p>Bei manchen Verwendungen einer Shader-Instanz müssen Sie kein Eingabebild festlegen, weil es durch den Vorgang automatisch festgelegt wird. Sie müssen nur dann eine Eingabe festlegen, wenn der Shader wie folgt wird:</p>
	 
	 <ul>
	   <li>Shaderfüllung</li>
	   <li>ShaderFilter, nur für die zweite oder weitere Eingaben, wenn festgelegt ist, dass der Shader mehr als eine Eingabe verwendet. (Das Objekt, auf das der Filter angewendet wird, wird automatisch als erste Eingabe verwendet.)</li>
	   <li>Shadermischmodus, nur für die dritte oder weitere Eingaben, wenn festgelegt ist, dass der Shader mehr als zwei Eingaben verwendet. (Die Objekte, die gemischt werden, werden automatisch als erste und zweite Eingabe verwendet.)</li>
	   <li>Ausführung eines ShaderJobs im Hintergrund</li>
	 </ul>
	 
	 <p>Wenn der Shader bei der Ausführung eine ShaderJob-Instanz zur Verarbeitung eines ByteArrays verwendet, das eine lineare Anordnung von Daten enthält, setzen Sie <codeph>height</codeph> der ShaderInput-Instanz auf 1 und <codeph>width</codeph> auf die Anzahl der 32-Bit-Gleitkommawerte im ByteArray. In diesem Fall muss die Shadereingabe mithilfe des <codeph>image1</codeph>-Datentyps definiert werden.</p>
	 
	 <p>Im Allgemeinen wird eine ShaderParameter-Instanz nicht direkt durch Entwicklercode erstellt. Bei der Erstellung der Shader-Instanz wird für jede Shadereingabe eine ShaderInput-Instanz erstellt.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link></related-links><apiConstructor id="flash.display:ShaderInput:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
		 Erstellt eine ShaderInput-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Erstellt eine ShaderInput-Instanz. Der ShaderInput-Konstruktor wird nicht direkt durch den Entwicklercode aufgerufen. Bei der Erstellung der Shader-Instanz wird für jede Shadereingabe eine ShaderInput-Instanz erstellt.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderInput:channels:get"><apiName>channels</apiName><shortdesc>
         Die Anzahl der Kanäle, die eine Shadereingabe erwartet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Die Anzahl der Kanäle, die eine Shadereingabe erwartet. Diese Eigenschaft muss berücksichtigt werden, wenn es sich bei den Eingabedaten um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:height:get"><apiName>height</apiName><shortdesc>
		 Die Höhe der Shadereingabe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Die Höhe der Shadereingabe. Diese Eigenschaft wird nur verwendet, wenn es sich bei den Eingabedaten um eine ByteArray- oder Vector.&lt;Number>-Instanz handelt. Wenn es sich bei der Eingabe um eine BitmapData-Instanz handelt, wird die Höhe automatisch festgelegt.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:index:get"><apiName>index</apiName><shortdesc>
         Die auf null basierende Indexposition der Eingabe im Shader, die die Reihenfolge der Eingabedefinitionen im Shader angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Die auf null basierende Indexposition der Eingabe im Shader, die die Reihenfolge der Eingabedefinitionen im Shader angibt.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:input:get"><apiName>input</apiName><shortdesc>
		 
		 Die Eingabedaten, die bei der Ausführung des Shaders verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 
		 Die Eingabedaten, die bei der Ausführung des Shaders verwendet werden. Diese Eigenschaft kann eine BitmapData-Instanz, eine ByteArray-Instanz oder eine Vector.&lt;Number>-Instanz sein.
		 
		 <p>Wenn der <codeph>input</codeph>-Eigenschaft ein ByteArray-Wert zugewiesen wird, müssen die folgenden Bedingungen erfüllt sein:</p>
		 
		 <ul>
		   <li>Die <codeph>height</codeph>- und <codeph>width</codeph>-Eigenschaft muss gesetzt sein.</li>
		   <li>Der Inhalt des Bytearrays darf nur aus 32-Bit-Gleitkommawerten bestehen. Diese Werte können mit der <codeph>ByteArray.writeFloat()</codeph>-Methode geschrieben werden.</li>
		   <li>Die Gesamtlänge des ByteArrays in Byte muss genau <codeph>width</codeph> x <codeph>height</codeph> x <codeph>channels </codeph> x 4 sein.</li>
		   <li>Die <codeph>endian</codeph>-Eigenschaft des Bytearrays muss <codeph>Endian.LITTLE_ENDIAN</codeph> sein.</li>
		 </ul>
		 
		 <p>Wenn der <codeph>input</codeph>-Eigenschaft eine Vector.&lt;Number>-Instanz zugewiesen wird, muss die Länge des Vektors gleich <codeph>width</codeph> x <codeph>height</codeph> x <codeph>channels</codeph> sein.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:width:get"><apiName>width</apiName><shortdesc>
		 Die Breite der Shadereingabe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Die Breite der Shadereingabe. Diese Eigenschaft wird nur verwendet, wenn es sich bei den Eingabedaten eine ByteArray- oder Vector.&lt;Number>-Instanz handelt. Wenn es sich bei der Eingabe um eine BitmapData-Instanz handelt, wird die Breite automatisch festgelegt.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrection"><apiName>ColorCorrection</apiName><shortdesc>
Die ColorCorrection-Klasse stellt Werte für die flash.displayStage.colorCorrection-Eigenschaft bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die ColorCorrection-Klasse stellt Werte für die <codeph>flash.displayStage.colorCorrection</codeph>-Eigenschaft bereit. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrection"><linktext>flash.display.Stage.colorCorrection</linktext></link></related-links><apiValue id="flash.display:ColorCorrection:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
Verwendet die Standardfarbkorrektur des Hosts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Verwendet die Standardfarbkorrektur des Hosts. Beim Webplayer ist der Host meist ein Browser und Flash Player versucht, dieselbe Farbkorrektur wie die Webseite zu verwenden, die die SWF-Datei hostet. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:OFF"><apiName>OFF</apiName><shortdesc>
Schaltet die Farbkorrektur unabhängig von der Player-Hostumgebung aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>off</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Schaltet die Farbkorrektur unabhängig von der Player-Hostumgebung aus. Diese Einstellung erhöht die Leistung. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:ON"><apiName>ON</apiName><shortdesc>
Schaltet die Farbkorrektur unabhängig von der Player-Hostumgebung ein.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>on</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Schaltet die Farbkorrektur unabhängig von der Player-Hostumgebung ein. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:LineScaleMode"><apiName>LineScaleMode</apiName><shortdesc>
Die LineScaleMode-Klasse stellt Werte für den Parameter „scaleMode“ in der Graphics.lineStyle()-Methode bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die LineScaleMode-Klasse stellt Werte für den Parameter <codeph>scaleMode</codeph> in der <codeph>Graphics.lineStyle()</codeph>-Methode bereit.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:LineScaleMode:HORIZONTAL"><apiName>HORIZONTAL</apiName><shortdesc>
	Mit dieser Einstellung, die als Parameter „scaleMode“ der lineStyle()-Methode verwendet wird, wird die Stärke der Linie nur vertikal skaliert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>horizontal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Mit dieser Einstellung, die als Parameter <codeph>scaleMode</codeph> der <codeph>lineStyle()</codeph>-Methode verwendet wird, wird die Stärke der Linie <i>nur</i> vertikal skaliert. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.VERTICAL</codeph> gesetzt wurde. Der Kreis links wurde nur vertikal skaliert, und der Kreis rechts wurde sowohl vertikal als auch horizontal skaliert.
	
    <p><adobeimage alt="Ein nur vertikal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NONE"><apiName>NONE</apiName><shortdesc>
	Mit dieser Einstellung, die als Parameter „scaleMode“ der lineStyle()-Methode verwendet wird, wird die Stärke der Linie niemals skaliert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Mit dieser Einstellung, die als <codeph>scaleMode</codeph>-Parameter der <codeph>lineStyle()</codeph>-Methode verwendet wird, wird die Stärke der Linie niemals skaliert.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	Mit dieser Einstellung, die als Parameter „scaleMode“ der lineStyle()-Methode verwendet wird, wird die Stärke der Linie immer skaliert, wenn das Objekt skaliert wird (Standardeinstellung).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Mit dieser Einstellung, die als Parameter <codeph>scaleMode</codeph> der <codeph>lineStyle()</codeph>-Methode verwendet wird, wird die Stärke der Linie immer skaliert, wenn das Objekt skaliert wird (Standardeinstellung).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:VERTICAL"><apiName>VERTICAL</apiName><shortdesc>
	Mit dieser Einstellung, die als Parameter „scaleMode“ der lineStyle()-Methode verwendet wird, wird die Stärke der Linie nur horizontal skaliert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>vertical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Mit dieser Einstellung, die als Parameter <codeph>scaleMode</codeph> der <codeph>lineStyle()</codeph>-Methode verwendet wird, wird die Stärke der Linie <i>nur</i> horizontal skaliert. Betrachten Sie beispielsweise die folgenden Kreise, die mit einer 1 Pixel starken Linie gezeichnet wurden und bei denen der Parameter <codeph>scaleMode</codeph> jeweils auf <codeph>LineScaleMode.HORIZONTAL</codeph> gesetzt wurde. Der Kreis links wurde nur horizontal skaliert, und der Kreis rechts wurde sowohl horizontal als auch vertikal skaliert.
	
    <p><adobeimage alt="Ein nur horizontal und ein vertikal und horizontal skalierter Kreis." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Shader"><apiName>Shader</apiName><shortdesc>
	 Eine Shader-Instanz stellt ein Pixel Bender-Shaderkernel in ActionScript dar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Eine Shader-Instanz stellt ein Pixel Bender-Shaderkernel in ActionScript dar. Um in Ihrer Anwendung einen Shader zu verwenden, erstellen Sie dafür eine Shader-Instanz. Dann verwenden Sie diese Shader-Instanz entsprechend dem Effekt, den Sie erstellen möchten. Um den Shader beispielsweise als Filter·zu verwenden, weisen Sie die Shader-Instanz der <codeph>shader</codeph>-Eigenschaft eines ShaderFilter-Objekts zu.
	 
	 <p>Ein Shader definiert eine Funktion, die für alle Pixel in einem Bild ausgeführt wird, jeweils ein Pixel nach dem anderen. Das Ergebnis eines jeden Aufrufs der Funktion ist die Ausgabefarbe an der jeweiligen Pixelkoordinate im Bild. Ein Shader kann ein oder mehrere Eingabebilder festlegen, deren Inhalt zum Bestimmen der Ausgabe der Funktion verwendet wird. Ein Shader kann auch einen oder mehrere Parameter festlegen, die als Eingabewerte für die Berechnung der Funktionsausgabe verwendet werden können. Bei einer einzelnen Shaderausführung sind Eingabe- und Parameterwerte konstant.
Es ändert sich lediglich die Koordinate des Pixels, dessen Farbe das Ergebnis der Funktion ist. Shaderfunktionsaufrufe für mehrere Ausgabepixelkoordinaten werden gleichzeitig ausgeführt, damit die Shaderausgabeleistung verbessert wird.</p>
	 
	 <p>Der Shaderbytecode kann zur Laufzeit mit einer URLLoader-Instanz geladen werden. Das folgende Beispiel zeigt, wie eine Bytecode-Datei für einen Shader zur Laufzeit geladen und mit einer Shader-Instanz verknüpft wird.</p>
	 
	 <codeblock>
	 var loader:URLLoader = new URLLoader();
	 loader.dataFormat = URLLoaderDataFormat.BINARY;
	 loader.addEventListener(Event.COMPLETE, onLoadComplete);
	 loader.load(new URLRequest("myShader.pbj"));
	  
	 var shader:Shader;
	  
	 function onLoadComplete(event:Event):void {
	     // Create a new shader and set the loaded data as its bytecode
	     shader = new Shader();
	     shader.byteCode = loader.data;
	     
	     // You can also pass the bytecode to the Shader() constructor like this:
	     // shader = new Shader(loader.data);
	     
	     // do something with the shader
	 }
	 </codeblock>
	 
	 <p>Sie können den Shader auch beim Kompilieren in die SWF einbetten, indem sie das <codeph>[Embed]</codeph>-Metadaten-Tag verwenden. Das <codeph>[Embed]</codeph>-Metadaten-Tag ist nur verfügbar, wenn Sie die SWF-Datei mit Flex SDK kompilieren. Der <codeph>source</codeph>-Parameter des <codeph>[Embed]</codeph>-Tags verweist auf die Shaderdatei und der <codeph>mimeType</codeph>-Parameter lautet <codeph>"application/octet-stream"</codeph>, wie im Beispiel gezeigt wird:</p>
	 
	 <codeblock>
	 [Embed(source="myShader.pbj", mimeType="application/octet-stream)]
	 var MyShaderClass:Class;
	  
	 // ...
	 
	 // create a new shader and set the embedded shader as its bytecode
	 var shaderShader = new Shader();
	 shader.byteCode = new MyShaderClass();
	  
	 // You can also pass the bytecode to the Shader() constructor like this:
	 // var shader:Shader = new Shader(new MyShaderClass());
	  
	 // do something with the shader
	 </codeblock>
	 
	 <p>In beiden Fällen verknüpfen Sie den unformatierten Shaderbytecode (die <codeph>URLLoader.data</codeph>-Eigenschaft oder eine Instanz der <codeph>[Embed]</codeph>-Datenklasse) mit der Shader-Instanz. Wie im Beispiel oben gezeigt wird, können Sie das auf zwei Arten tun. Sie können den Shaderbytecode als Argument an den <codeph>Shader()</codeph>-Konstruktor übergeben. Oder Sie legen ihn als <codeph>byteCode</codeph>-Eigenschaft der Shader-Instanz fest.</p>
	 
	 <p>Sobald eine Shader-Instanz erstellt wurde, kann Sie auf mehrere Arten verwendet werden:</p>
	 
	 <ul>
	   <li>Als Shaderfüllung: Die Ausgabe des Shaders wird als Füllung für Inhalte verwendet, die mit der Zeichnungs-API gezeichnet wurden. Übergeben Sie die Shader-Instanz als Argument an die <codeph>Graphics.beginShaderFill()</codeph>-Methode.</li>
	   <li>Als Shaderfilter: Die Ausgabe des Shaders wird als Grafikfilter auf ein Anzeigeobjekt angewendet. Weisen Sie die Shader-Instanz der <codeph>shader</codeph>-Eigenschaft einer ShaderFilter-Instanz zu.</li>
	   <li>Als Mischmodus: Die Ausgabe des Shaders wird als Mischung zwischen zwei überlappenden Anzeigeobjekten dargestellt. Weisen Sie die Shader-Instanz der <codeph>blendShader</codeph>-Eigenschaft des oberen der beiden Anzeigeobjekte zu.</li>
	   <li>Shaderverarbeitung im Hintergrund: Der Shader wird im Hintergrund ausgeführt, wodurch ein mögliches Hängenbleiben der Bildschirmanzeige verhindert wird, und löst nach Beenden der Verarbeitung ein Ereignis aus. Weisen Sie die Shader-Instanz der <codeph>shader</codeph>-Eigenschaft einer ShaderJob-Instanz zu.</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\ShaderExample.1.as"> Im folgenden Beispiel wird zur Laufzeit eine Shaderbytecodedatei geladen und eine Shader-Instanz damit verknüpft.
 
 <p>Beachten Sie, dass im Beispiel davon ausgegangen wird, dass im selben Ordner wie dem Ausgabeordner der Anwendung eine Shaderbytecodedatei mit dem Namen „donothing.pbj“ vorhanden ist. Der Pixel Bender-Quellcode for den DoNothing-Shader ist im <xref href="ShaderData.html#includeExamplesSummary">Beispiel zur ShaderData-Klasse</xref> verfügbar.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class LoadedShaderExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function LoadedShaderExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example><example conref="examples\ShaderExample.2.as"> Im folgenden Beispiel wird eine Shaderbytecodedatei durch Kompilieren in die SWF eingebettet und eine Shader-Instanz damit verknüpft.
 
 <p>Bei diesem Beispiel wird davon ausgegangen, dass im selben Ordner, in dem der Quellcode für die Anwendung liegt, eine Shaderbytecodedatei namens „donothing.pbj“ vorhanden ist und dass Flex SDK für das Kompilieren der SWF verwendet wird. Der Pixel Bender-Quellcode for den DoNothing-Shader ist im <xref href="ShaderData.html#includeExamplesSummary">Beispiel zur ShaderData-Klasse</xref> verfügbar.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;

    public class EmbeddedShaderExample extends Sprite {
        
        [Embed(source="donothing.pbj", mimeType="application/octet-stream")]
        private static var DoNothingShader:Class;
        
        public function EmbeddedShaderExample() {
            var shader:Shader = new Shader();
            shader.byteCode = new DoNothingShader();
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link><link href="flash.filters.xml#ShaderFilter"><linktext>flash.filters.ShaderFilter</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><apiConstructor id="flash.display:Shader:flash.display:Shader"><apiName>Shader</apiName><shortdesc>
		 Erstellt eine neue Shader-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Der unformatierte Bytecode, der mit dem Shader verknüpft wird.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Erstellt eine neue Shader-Instanz.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shader:data:set"><apiName>data</apiName><shortdesc>
		 Gewährt Zugriff auf Parameter, Eingabebilder und Metadaten für die Shader-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:ShaderData</apiValueClassifier></apiValueDef><apiDesc>
		 Gewährt Zugriff auf Parameter, Eingabebilder und Metadaten für die Shader-Instanz. ShaderParameter-Objekte stellen Parameter für den Shader dar, Shaderinput-Objekte stellen die Eingabebilder für den Shader dar und andere Werte stellen die Metadaten des Shaders dar, die beim Erstellen der Shaderinstanz als Eigenschaften des <codeph>data</codeph>-Eigenschaftsobjekts dynamisch hinzugefügt werden. Diese Eigenschaften können zum Untersuchen des Shaders und zum Setzen von Parametern und Eingabewerten verwendet werden.
		 
		 <p>Informationen über den Zugriff auf und die Änderung der dynamischen Eigenschaften des <codeph>data</codeph>-Objekts finden Sie in der Beschreibung der ShaderData-Klasse.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:precisionHint:set"><apiName>precisionHint</apiName><shortdesc>
		 Die Präzision der vom Shader ausgeführten mathematischen Operationen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Die Präzision der vom Shader ausgeführten mathematischen Operationen.
		 
		 <p>Der Satz der möglichen Werte für die <codeph>precisionHint</codeph>-Eigenschaft wird durch die Konstanten in der ShaderPrecision-Klasse definiert.</p>
		 
		 <p>Der Standartwert ist <codeph>ShaderPrecision.FULL</codeph>. Mathematische Operationen können zulasten der Präzision beschleunigt werden, indem Sie die Präzision auf <codeph>ShaderPrecision.FAST</codeph> setzen.</p>
		 
		 <p>Im vollen Präzisionsmodus (<codeph>ShaderPrecision.FULL</codeph>) werden alle mathematischen Operationen basierend auf dem 32-Bit-Gleitkommastandard des IEEE berechnet. Dieser Modus gewährleistet konsistentes Verhalten über alle Plattformen hinweg. In diesem Modus können einige mathematische Operationen, wie beispielsweise trigonometrische und Exponentialfunktionen, langsam sein.</p>
		 
		 <p>Der schnelle Präzisionsmodus (<codeph>ShaderPrecision.FAST</codeph>) gewährleistet maximale Leistung, funktioniert aber nicht konsistent über alle Plattformen und individuellen CPU-Konfigurationen hinweg. Diese Präzisionsebene reicht aus, um Grafikeffekte ohne sichtbare Artefakte zu erstellen.</p>
		 
		 <p>Die Auswahl des Präzisionsmodus wirkt sich auf die folgenden Shadervorgänge aus. Diese Vorgänge sind auf einem Intel-Prozessor schneller, wenn die SSE-Anweisung wie folgt eingestellt ist:</p>
		 
		 <ul>
		   <li><codeph>sin(x)</codeph></li>
		   <li><codeph>cos(x)</codeph></li>
		   <li><codeph>tan(x)</codeph></li>
		   <li><codeph>asin(x)</codeph></li>
		   <li><codeph>acos(x)</codeph></li>
		   <li><codeph>atan(x)</codeph></li>
		   <li><codeph>atan(x, y)</codeph></li>
		   <li><codeph>exp(x)</codeph></li>
		   <li><codeph>exp2(x)</codeph></li>
		   <li><codeph>log(x)</codeph></li>
		   <li><codeph>log2(x)</codeph></li>
		   <li><codeph>pow(x, y)</codeph></li>
		   <li><codeph>reciprocal(x)</codeph></li>
		   <li><codeph>sqrt(x)</codeph></li>
		 </ul>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderPrecision"><linktext>flash.display.ShaderPrecision</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:byteCode:set"><apiName>byteCode</apiName><shortdesc>
		 Der unformatierte Shaderbytecode für die Shader-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier></apiValueDef><apiDesc>
		 Der unformatierte Shaderbytecode für die Shader-Instanz.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsData"><apiName>IGraphicsData</apiName><shortdesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Parameter in der flash.display.Graphics-Methode verwendet werden können, einschließlich Füllungen, Striche und Pfade.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Diese Schnittstelle wird für die Definition von Objekten verwendet, die als Parameter in der flash.display.Graphics-Methode verwendet werden können, einschließlich Füllungen, Striche und Pfade. Verwenden Sie Klassen, die diese Schnittstelle implementieren, um Zeichnungseigenschaftsdaten zu erstellen und zu verwalten und diese Daten in verschiedenen Instanzen wiederzuverwenden. Verwenden Sie anschließend die Methoden der Graphics-Klasse zum Darstellen der gezeichneten Objekte.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:MovieClip"><apiName>MovieClip</apiName><shortdesc>
 Die MovieClip-Klasse erbt von folgenden Klassen: Sprite, DisplayObjectContainer, InteractiveObject, DisplayObject und EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Das grundlegende Anzeigeobjekt für mit ActionScript erstellte Objekte.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:Sprite</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die MovieClip-Klasse erbt von folgenden Klassen: Sprite, DisplayObjectContainer, InteractiveObject, DisplayObject und EventDispatcher.
 
 <p>Im Gegensatz zum Sprite-Objekt besitzt ein MovieClip-Objekt eine Zeitleiste.</p>
 
 <p product="flash">Die Methoden für die MovieClip-Klasse bieten dieselbe Funktionalität wie Aktionen für Movieclips. Für einige zusätzliche Methoden liegen in der Werkzeugleiste für Aktionen der Flash-Authoring-Umgebung keine entsprechenden Aktionen vor. </p>
 
 <p>Auf untergeordnete Instanzen, die in der Flash-Authoring-Umgebung auf der Bühne platziert werden, kann nicht durch Code von einem Konstruktor einer übergeordneten Instanz aus zugegriffen werden, da an diesem Punkt der Codeausführung nicht erstellt wurden. Vor dem Zugriff auf die untergeordnete Instanz muss die übergeordnete Instanz die untergeordnete entweder mithilfe von Code erstellen oder den Zugriff auf eine Callback-Funktion verzögern, die überwacht, wann die untergeordnete Instanz ihr Ereignis <codeph>Event.ADDED_TO_STAGE</codeph> auslöst.</p>
 
 <p>Wenn Sie eine der folgenden Eigenschaften eines MovieClip-Objekts mit einem Bewegungs-Tween ändern, wird der Abspielkopf in diesem MovieClip-Objekt gestoppt: <codeph>alpha</codeph>, <codeph>blendMode</codeph>, <codeph>filters</codeph>, <codeph>height</codeph>, <codeph>opaqueBackground</codeph>, <codeph>rotation</codeph>, <codeph>scaleX</codeph>, <codeph>scaleY</codeph>, <codeph>scale9Grid</codeph>, <codeph>scrollRect</codeph>, <codeph>transform</codeph>, <codeph>visible</codeph>, <codeph>width</codeph>, <codeph>x</codeph> oder <codeph>y</codeph>. Der Abspielkopf wird in untergeordneten MovieClip-Objekten des betreffenden MovieClip-Objekts jedoch nicht angehalten.</p>
 
 </apiDesc><example conref="examples\MovieClipExample.as"> Im folgenden Beispiel wird die MovieClipExample-Klasse verwendet, um zu zeigen, wie verschiedene Eigenschaften eines MovieClip-Objekts überwacht werden. Dies wird in den folgenden Schritten erreicht:
 
 <ol>
 
  <li>Die Konstruktorfunktion definiert ein Textfeld, das verwendet wird, um die Werte der Eigenschaften des MovieClipExample-Objekts anzuzeigen (das „MovieClip“ erweitert).</li>
 
  <li>Der Rückgabewert der <codeph>getPropertiesString()</codeph>-Methode wird als Text für das <codeph>outputText</codeph>-Textfeld verwendet. Die <codeph>getPropertiesString()</codeph>-Methode gibt einen String zurück, der mit Werten der folgenden Eigenschaften des Movieclips gefüllt wird: <codeph>currentFrame</codeph>, <codeph>currentLabel</codeph>, <codeph>currentScene</codeph>, <codeph>framesLoaded</codeph>, <codeph>totalFrames</codeph> und <codeph>trackAsMenu</codeph>.</li>
 
  <li>Zwei Codezeilen in der Konstruktorfunktion passen die Eigenschaften <codeph>width</codeph> und <codeph>height</codeph> des Textfelds <codeph>outputText</codeph> an.</li>
 
  <li>Die letzte Zeile der Konstruktorfunktion fügt das Textfeld <codeph>outputText</codeph> der Anzeigeliste hinzu.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.MovieClip;
    import flash.text.TextField;

    public class MovieClipExample extends MovieClip {

        public function MovieClipExample() {
            var outputText:TextField = new TextField();
            outputText.text = getPropertiesString();
            outputText.width = stage.stageWidth;
            outputText.height = outputText.textHeight;
            addChild(outputText);
        }

        private function getPropertiesString():String {
            var str:String = ""
                + "currentFrame: " + currentFrame + "\n"
                + "currentLabel: " + currentLabel + "\n"
                + "currentScene: " + currentScene + "\n"
                + "framesLoaded: " + framesLoaded + "\n"
                + "totalFrames: " + totalFrames + "\n"
                + "trackAsMenu: " + trackAsMenu + "\n";
            return str;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:MovieClip:MovieClip"><apiName>MovieClip</apiName><shortdesc>
	Erstellt eine neue MovieClip-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Erstellt eine neue MovieClip-Instanz. Nachdem Sie den Movieclip erstellt haben, rufen Sie für einen Anzeigeobjekt-Container, der sich auf der Bühne befindet, die Methode <codeph>addChild()</codeph> oder <codeph>addChildAt()</codeph> auf.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:MovieClip:gotoAndPlay"><apiName>gotoAndPlay</apiName><shortdesc>
	 Startet die Wiedergabe der SWF-Datei beim angegebenen Bild.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandplay, gotoandplay
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Eine Zahl für die Bildnummer oder ein String zur Bezeichnung des Bilds, zu dem der Abspielkopf springen soll. Wenn Sie eine Zahl angeben, ist diese relativ zur angegebenen Szene zu verstehen. Wenn Sie keine Szene angeben, bestimmt die aktuelle Szene die globale Nummer des abzuspielenden Bildes. Haben Sie eine Szene angegeben, springt der Abspielkopf in dieser Szene zum Bild mit der angegebenen Nummer.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Name der abzuspielenden Szene. Dieser Parameter ist optional.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Startet die Wiedergabe der SWF-Datei beim angegebenen Bild. Dies passiert, nachdem alle im Bild verbleibenden Aktionen ganz ausgeführt worden sind. Um eine Szene und ein Bild anzugeben, geben Sie einen Wert für den Parameter <codeph>scene</codeph> an.
	 
	 </apiDesc><example conref="examples\MovieClip.gotoAndPlay.1.as"> Im folgenden Code wird der Abspielkopf des Movieclips <codeph>gotoAndPlay()</codeph> mithilfe der <codeph>mc1</codeph>-Methode angewiesen, um fünf Bilder weiter zu springen als das aktuelle Bild:
<codeblock>
mc1.gotoAndPlay(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndPlay.2.as"> Im folgenden Code wird mithilfe der <codeph>gotoAndPlay()</codeph>-Methode der Abspielkopf des Movieclips <codeph>mc1</codeph> angewiesen, zum Bild mit der Bezeichnung <codeph>"intro"</codeph> in der Szene <codeph>"Scene 12"</codeph> weiter zu springen:
<codeblock>
mc1.gotoAndPlay("intro", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:gotoAndStop"><apiName>gotoAndStop</apiName><shortdesc>
	  Verschiebt den Abspielkopf zum angegebenen Bild im Movieclip und hält ihn dort an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandstop, gotoandstop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Dies gilt, wenn für den betreffenden Movieclip der <codeph>scene</codeph>- oder <codeph>frame</codeph>-Wert nicht gefunden werden kann.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Eine Zahl für die Bildnummer oder ein String zur Bezeichnung des Bilds, zu dem der Abspielkopf springen soll. Wenn Sie eine Zahl angeben, ist diese relativ zur angegebenen Szene zu verstehen. Wenn Sie keine Szene angeben, bestimmt die aktuelle Szene die globale Nummer des Bildes, an das der Abspielkopf springen und bei dem er anhalten soll. Haben Sie eine Szene angegeben, springt der Abspielkopf in dieser Szene zum Bild mit der angegebenen Nummer und hält an.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Name der Szene. Dieser Parameter ist optional.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Verschiebt den Abspielkopf zum angegebenen Bild im Movieclip und hält ihn dort an. Dies passiert, nachdem alle im Bild verbleibenden Aktionen ganz ausgeführt worden sind. Wenn Sie eine Szene zusätzlich zu einem Bild angeben möchten, verwenden Sie den Parameter <codeph>scene</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> Im folgenden Code wird der Abspielkopf des Movieclips <codeph>gotoAndStop()</codeph> mithilfe der <codeph>currentFrame</codeph>-Methode und der <codeph>mc1</codeph>-Eigenschaft angewiesen, um fünf Bilder über das aktuelle Bild hinaus zu springen und dort anzuhalten:
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndStop.1.as"> Im folgenden Code wird mithilfe der <codeph>gotoAndStop()</codeph>-Methode der Abspielkopf des Movieclips <codeph>mc1</codeph> angewiesen, zum Bild mit der Bezeichnung <codeph>"finale"</codeph> in der Szene <codeph>"Scene 12"</codeph> zu springen und dort anzuhalten:
<codeblock>
mc1.gotoAndStop("finale", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:nextFrame"><apiName>nextFrame</apiName><shortdesc>
	 Verschiebt den Abspielkopf zum nächsten Bild und stoppt die Wiedergabe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.nextframe, nextframe
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Verschiebt den Abspielkopf zum nächsten Bild und stoppt die Wiedergabe. Dies passiert, nachdem alle im Bild verbleibenden Aktionen ganz ausgeführt worden sind.
	 
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> Im folgenden Beispiel wird die Zeitleiste über zwei SimpleButton-Objekte gesteuert. Die Schaltfläche <codeph>prev</codeph> verschiebt den Abspielkopf in das vorige Bild, und die Schaltfläche <codeph>nextBtn</codeph> verschiebt den Abspielkopf in das nächste Bild:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/prevFrame()"><linktext>prevFrame()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:nextScene"><apiName>nextScene</apiName><shortdesc>
	 Verschiebt den Abspielkopf in die nächste Szene der Movieclip-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Verschiebt den Abspielkopf in die nächste Szene der Movieclip-Instanz. Dies passiert, nachdem alle im Bild verbleibenden Aktionen ganz ausgeführt worden sind.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> Im folgenden Beispiel wird die Zeitleiste über zwei SimpleButton-Objekte gesteuert. Die Schaltfläche <codeph>prevBtn</codeph> verschiebt den Abspielkopf in die vorige Szene, und die Schaltfläche <codeph>nextBtn</codeph> verschiebt den Abspielkopf in die nächste Szene:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:play"><apiName>play</apiName><shortdesc>
	 Verschiebt den Abspielkopf in der Zeitleiste des Movieclips.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.play, play
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Verschiebt den Abspielkopf in der Zeitleiste des Movieclips.
	 
	 </apiDesc><example conref="examples\MovieClip.play.1.as"> Der folgende Code verwendet die <codeph>stop()</codeph>-Methode, um einen Movieclip mit dem Namen <codeph>mc1</codeph> zu stoppen und die Wiedergabe wieder zu starten, wenn Benutzer auf das Textfeld mit dem Namen <codeph>continueText</codeph> klicken:
<codeblock>

import flash.text.TextField;
import flash.events.MouseEvent;

var continueText:TextField = new TextField();
continueText.text = "Play movie...";
addChild(continueText);

mc1.stop();
continueText.addEventListener(MouseEvent.CLICK, resumeMovie);

function resumeMovie(event:MouseEvent):void {
    mc1.play();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>gotoAndPlay()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:prevFrame"><apiName>prevFrame</apiName><shortdesc>
	 Verschiebt den Abspielkopf zum vorigen Bild und stoppt die Wiedergabe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.prevframe, prevframe, previous frame
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Verschiebt den Abspielkopf zum vorigen Bild und stoppt die Wiedergabe. Dies passiert, nachdem alle im Bild verbleibenden Aktionen ganz ausgeführt worden sind.
	  
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> Im folgenden Beispiel wird die Zeitleiste über zwei SimpleButton-Objekte gesteuert. Die Schaltfläche <codeph>prev</codeph> verschiebt den Abspielkopf in das vorige Bild, und die Schaltfläche <codeph>nextBtn</codeph> verschiebt den Abspielkopf in das nächste Bild:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:prevScene"><apiName>prevScene</apiName><shortdesc>
	 Verschiebt den Abspielkopf in die vorige Szene der MovieClip-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Verschiebt den Abspielkopf in die vorige Szene der MovieClip-Instanz. Dies passiert, nachdem alle im Bild verbleibenden Aktionen ganz ausgeführt worden sind.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> Im folgenden Beispiel wird die Zeitleiste über zwei SimpleButton-Objekte gesteuert. Die Schaltfläche <codeph>prevBtn</codeph> verschiebt den Abspielkopf in die vorige Szene, und die Schaltfläche <codeph>nextBtn</codeph> verschiebt den Abspielkopf in die nächste Szene:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:stop"><apiName>stop</apiName><shortdesc>
	 Stoppt den Abspielkopf im Movieclip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.stop, stop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Stoppt den Abspielkopf im Movieclip.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:MovieClip:currentFrame:get"><apiName>currentFrame</apiName><shortdesc>
	 Gibt die Nummer des Bilds in der Zeitleiste der MovieClip-Instanz zurück, bei dem sich der Abspielkopf gerade befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.currentFrame, currentFrame, currentFrame
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Nummer des Bilds in der Zeitleiste der MovieClip-Instanz zurück, bei dem sich der Abspielkopf gerade befindet. Umfasst der Movieclip mehrere Szenen, bezeichnet dieser Wert die Bildnummer in der aktuellen Szene.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> Im folgenden Code wird der Abspielkopf des Movieclips <codeph>gotoAndStop()</codeph> mithilfe der <codeph>currentFrame</codeph>-Methode und der <codeph>mc1</codeph>-Eigenschaft angewiesen, um fünf Bilder über das aktuelle Bild hinaus zu springen und dort anzuhalten:
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentFrameLabel:get"><apiName>currentFrameLabel</apiName><shortdesc>
	 Die Beschriftung des aktuellen Bilds in der Zeitleiste der MovieClip-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Die Beschriftung des aktuellen Bilds in der Zeitleiste der MovieClip-Instanz. Wenn das aktuelle Bild keine Beschriftung hat, hat <codeph>currentLabel</codeph> den Wert <codeph>null</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrameLabel.1.as"/></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabel:get"><apiName>currentLabel</apiName><shortdesc>
	 Die aktuelle Bezeichnung der Szene in der Zeitleiste der MovieClip-Instanz, in der sich der Abspielkopf gerade befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Die aktuelle Bezeichnung der Szene in der Zeitleiste der MovieClip-Instanz, in der sich der Abspielkopf gerade befindet. Wenn das aktuelle Bild keine Bezeichnung aufweist, wird <codeph>currentLabel</codeph> auf den Namen eines vorherigen Bilds gesetzt, das über eine Bezeichnung verfügt. Wenn das aktuelle Bild und die vorherigen Bilder keine Bezeichnung enthalten, wird für <codeph>currentLabel</codeph> der Wert <codeph>null</codeph> zurückgegeben.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabel.1.as"> Der folgende Code zeigt den Zugriff auf die <codeph>currentLabel</codeph>-Eigenschaft eines MovieClip-Objekts mit dem Namen <codeph>mc1</codeph>:
<codeblock>
trace(mc1.currentLabel);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabels:get"><apiName>currentLabels</apiName><shortdesc>
	 Gibt ein Array an FrameLabel-Objekten aus der aktuellen Szene zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt ein Array an FrameLabel-Objekten aus der aktuellen Szene zurück. Verwendet die MovieClip-Instanz keine Szenen, enthält das Array alle Bildbezeichnungen aus der gesamten MovieClip-Instanz.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabels.1.as"> Der folgende Code zeigt die Verwendung der <codeph>currentLabels</codeph>-Eigenschaft eines MovieClip-Objekts mit dem Namen <codeph>mc1</codeph>:
<codeblock>
import flash.display.FrameLabel;
 
var labels:Array = mc1.currentLabels;

for (var i:uint = 0; i &lt; labels.length; i++) {
    var label:FrameLabel = labels[i];
    trace("frame " + label.frame + ": " + label.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>flash.display.FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:currentScene:get"><apiName>currentScene</apiName><shortdesc>
	 Die aktuelle Szene in der Zeitleiste der MovieClip-Instanz, in der sich der Abspielkopf gerade befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Scene</apiValueClassifier></apiValueDef><apiDesc>
	 Die aktuelle Szene in der Zeitleiste der MovieClip-Instanz, in der sich der Abspielkopf gerade befindet.
	 
	 </apiDesc><example conref="examples\MovieClip.currentScene.1.as"> Der folgende Code zeigt die Verwendung der <codeph>currentScene</codeph>-Eigenschaft eines MovieClip-Objekts mit dem Namen <codeph>mc1</codeph>:
<codeblock>
import flash.display.Scene;
 
var scene:Scene = mc1.currentScene;
trace(scene.name + ": " + scene.numFrames + " frames");
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Ein boolescher Wert, der angibt, ob ein Movieclip aktiviert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Ein boolescher Wert, der angibt, ob ein Movieclip aktiviert ist. Der Standardwert von <codeph>enabled</codeph> lautet <codeph>true</codeph>. Wenn <codeph>enabled</codeph> auf <codeph>false</codeph> gesetzt ist, werden die Bilder „Over“, „Down“ und „Up“ des Movieclips deaktiviert. Der Movieclip empfängt auch weiterhin Ereignisse (beispielsweise <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>, <codeph>keyDown</codeph> und <codeph>keyUp</codeph>).
	 
	 <p>Die <codeph>enabled</codeph>-Eigenschaft steuert nur die schaltflächenähnlichen Eigenschaften eines Movieclips. Sie können die <codeph>enabled</codeph>-Eigenschaft jederzeit ändern. Der geänderte Movieclip wird dann sofort aktiviert oder deaktiviert. Wenn <codeph>enabled</codeph> auf <codeph>false</codeph> gesetzt ist, wird das Objekt bei der automatischen Tabulatorreihenfolge nicht berücksichtigt.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.enabled.1.as"> Der folgende Code zeigt die Verwendung der <codeph>enabled</codeph>-Eigenschaft zum Deaktivieren der schaltflächenähnlichen Eigenschaften eines MovieClip-Objekts mit dem Namen <codeph>mc1</codeph>:
<codeblock>
mc1.enabled = false;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:framesLoaded:get"><apiName>framesLoaded</apiName><shortdesc>
	 Die Anzahl der Bilder, die aus einer SWF-Streaming-Datei geladen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.framesLoaded, framesLoaded, framesloaded
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl der Bilder, die aus einer SWF-Streaming-Datei geladen werden. Mithilfe der <codeph>framesLoaded</codeph>-Eigenschaft können Sie feststellen, ob die Inhalte eines bestimmten Bildes und aller vorausgehenden Bilder geladen wurden und im Browser lokal zur Verfügung stehen. Außerdem kann damit der Download großer SWF-Dateien überwacht werden. Beispielsweise können Sie eine Meldung anzeigen lassen, die dem Benutzer mitteilt, dass die SWF-Datei geladen wird, bis ein bestimmtes Bild in der SWF-Datei vollständig geladen ist.
	 
	 <p>Umfasst der Movieclip mehrere Szenen, gibt die <codeph>framesLoaded</codeph>-Eigenschaft die Anzahl der für <i>alle</i> Szenen im Movieclip geladenen Bilder zurück.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.framesLoaded.1.as"> Der folgende Code zeigt, wie Sie die <codeph>framesLoaded</codeph>-Eigenschaft und die <codeph>totalFrames</codeph>-Eigenschaft verwenden, um zu bestimmen, ob ein Streaming-MovieClip-Objekt mit dem Namen <codeph>mc1</codeph> vollständig geladen wurde:
<codeblock>
if (mc1.framesLoaded == mc1.totalFrames) {
    trace("OK.");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>Loader-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:scenes:get"><apiName>scenes</apiName><shortdesc>
	 Ein Array an Scene-Objekten, von denen jedes den Namen, die Anzahl der Bilder und die Bildbezeichnungen für eine Szene in der MovieClip-Instanz auflistet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Array an Scene-Objekten, von denen jedes den Namen, die Anzahl der Bilder und die Bildbezeichnungen für eine Szene in der MovieClip-Instanz auflistet.
	 
	 </apiDesc><example conref="examples\MovieClip.scenes.1.as"> Der folgende Code zeigt die Verwendung der <codeph>scenes</codeph>-Eigenschaft eines MovieClip-Objekts mit dem Namen <codeph>mc1</codeph>:
<codeblock>
import flash.display.Scene;
 
for (var i:uint = 0; i &lt; mc1.scenes.length; i++) {
    var scene:Scene = mc1.scenes[i];
    trace("scene " + scene.name + ": " + scene.numFrames + " frames");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:totalFrames:get"><apiName>totalFrames</apiName><shortdesc>
	 Die Anzahl aller Bilder in der MovieClip-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.totalFrames, totalFrames, totalFrames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl aller Bilder in der MovieClip-Instanz.
	 
	 <p>Umfasst der Movieclip mehrere Szenen, gibt die <codeph>totalFrames</codeph>-Eigenschaft die Anzahl der Bilder in <i>allen</i> Szenen im Movieclip zurück.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.totalFrames.1.as"> Der folgende Code zeigt die Verwendung der <codeph>totalFrames</codeph>-Eigenschaft eines MovieClip-Objekts mit dem Namen <codeph>mc1</codeph>:
<codeblock>
 trace(mc1.totalFrames);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Zeigt an, ob andere Anzeigeobjekte, die SimpleButton- oder MovieClip-Objekte sind, durch das Loslassen der Maustaste erzeugte Ereignisse empfangen können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Zeigt an, ob andere Anzeigeobjekte, die SimpleButton- oder MovieClip-Objekte sind, durch das Loslassen der Maustaste erzeugte Ereignisse empfangen können. Die <codeph>trackAsMenu</codeph>-Eigenschaft dient zum Erstellen von Menüs. Sie können die <codeph>trackAsMenu</codeph>-Eigenschaft für jedes SimpleButton- oder MovieClip-Objekt setzen. Der Standardwert der <codeph>trackAsMenu</codeph>-Eigenschaft lautet <codeph>false</codeph>. 
	 
	 <p>Sie können die <codeph>trackAsMenu</codeph>-Eigenschaft jederzeit ändern. Der geänderte Movieclip übernimmt sofort das neue Verhalten.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.trackAsMenu.1.as"> Der folgende Code zeigt die Verwendung der <codeph>trackAsMenu</codeph>-Eigenschaft, um durch das Loslassen der Maustaste erzeugte Ereignisse für ein MovieClip-Objekt mit dem Namen <codeph>mc1</codeph> zu aktivieren:
<codeblock>
 mc1.trackAsMenu = true;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SWFVersion"><apiName>SWFVersion</apiName><shortdesc>
	Die SWFVersion-Klasse ist eine Zusammenfassung von Konstantenwerten, die die Dateiformatversion einer geladenen SWF-Datei anzeigen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die SWFVersion-Klasse ist eine Zusammenfassung von Konstantenwerten, die die Dateiformatversion einer geladenen SWF-Datei anzeigen. Die verfügbaren SWFVersion-Konstanten erhalten Sie, indem Sie die <codeph>swfVersion</codeph>-Eigenschaft eines flash.display.LoaderInfo-Objekts prüfen.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/swfVersion"><linktext>flash.display.LoaderInfo.swfVersion</linktext></link></related-links><apiValue id="flash.display:SWFVersion:FLASH1"><apiName>FLASH1</apiName><shortdesc>
		SWF-Dateiformatversion 1.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 1.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH10"><apiName>FLASH10</apiName><shortdesc>
		SWF-Dateiformatversion 10.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>10</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 10.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH2"><apiName>FLASH2</apiName><shortdesc>
		SWF-Dateiformatversion 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 2.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH3"><apiName>FLASH3</apiName><shortdesc>
		SWF-Dateiformatversion 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 3.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH4"><apiName>FLASH4</apiName><shortdesc>
		SWF-Dateiformatversion 4.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 4.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH5"><apiName>FLASH5</apiName><shortdesc>
		SWF-Dateiformatversion 5.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 5.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH6"><apiName>FLASH6</apiName><shortdesc>
		SWF-Dateiformatversion 6.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>6</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 6.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH7"><apiName>FLASH7</apiName><shortdesc>
		SWF-Dateiformatversion 7.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>7</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 7.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH8"><apiName>FLASH8</apiName><shortdesc>
		SWF-Dateiformatversion 8.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 8.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH9"><apiName>FLASH9</apiName><shortdesc>
		SWF-Dateiformatversion 9.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>9</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF-Dateiformatversion 9.0. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowResize"><apiName>NativeWindowResize</apiName><shortdesc>
Die NativeWindowsResize-Klasse definiert Konstanten für die möglichen Werte des edgeOrCorner-Parameters der startResize()-Methode von NativeWindow.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die NativeWindowsResize-Klasse definiert Konstanten für die möglichen Werte des <codeph>edgeOrCorner</codeph>-Parameters der <codeph>startResize()</codeph>-Methode von NativeWindow. 
<p>Eine Konstante ist zur Benennung von jeder Kante und Ecke eines Fensters definiert.</p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow/startResize()"><linktext>flash.display.NativeWindow.startResize()</linktext></link></related-links><apiValue id="flash.display:NativeWindowResize:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
Die untere Kante des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die untere Kante des Fensters. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
Die untere linke Ecke des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die untere linke Ecke des Fensters. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
Die untere rechte Ecke des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die untere rechte Ecke des Fensters. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:LEFT"><apiName>LEFT</apiName><shortdesc>
Die linke Kante des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die linke Kante des Fensters.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:NONE"><apiName>NONE</apiName><shortdesc>
Weist das System nicht an, von welcher Ecke oder Kante die Größenänderung ausgehen soll, sodass das Standardverhalten ausgeführt werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Weist das System nicht an, von welcher Ecke oder Kante die Größenänderung ausgehen soll, sodass das Standardverhalten ausgeführt werden kann.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:RIGHT"><apiName>RIGHT</apiName><shortdesc>
Die rechte Kante des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die rechte Kante des Fensters. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP"><apiName>TOP</apiName><shortdesc>
Die obere Kante des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die obere Kante des Fensters. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
Die obere linke Ecke des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die obere linke Ecke des Fensters. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
Die obere rechte Ecke des Fensters.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Die obere rechte Ecke des Fensters. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapDataChannel"><apiName>BitmapDataChannel</apiName><shortdesc>
Die BitmapDataChannel-Klasse ist eine Zusammenfassung von Konstantenwerten, die angeben, welcher Kanal zu verwenden ist: Rot, Grün, Blau oder Alphatransparenz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die BitmapDataChannel-Klasse ist eine Zusammenfassung von Konstantenwerten, die angeben, welcher Kanal zu verwenden ist: Rot, Grün, Blau oder Alphatransparenz. 

<p>Wenn Sie mehrere Methoden aufrufen, können Sie den Bit-für-Bit-Operator OR (<codeph>|</codeph>) verwenden, um BitmapDataChannel-Konstanten zu kombinieren und so mehrere Farbkanäle anzugeben.</p>

<p>Die BitmapDataChannel-Konstanten werden bereitgestellt, um sie als Werte in den folgenden Methoden und Eigenschaften zu verwenden:</p>

<ul>

	<li>Parameter <codeph>sourceChannel</codeph> und <codeph>destChannel</codeph> der <codeph>flash.display.BitmapData.copyChannel()</codeph>-Methode</li>

	<li>Parameter <codeph>channelOptions</codeph> der <codeph>flash.display.BitmapData.noise()</codeph>-Methode</li>

	<li>Eigenschaften <codeph>flash.filters.DisplacementMapFilter.componentX</codeph> und <codeph>flash.filters.DisplacementMapFilter.componentY</codeph></li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/copyChannel()"><linktext>flash.display.BitmapData.copyChannel()</linktext></link><link href="flash.display.xml#BitmapData/noise()"><linktext>flash.display.BitmapData.noise()</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentX"><linktext>flash.filters.DisplacementMapFilter.componentX</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentY"><linktext>flash.filters.DisplacementMapFilter.componentY</linktext></link></related-links><apiValue id="flash.display:BitmapDataChannel:ALPHA"><apiName>ALPHA</apiName><shortdesc>
		Der Alphakanal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Der Alphakanal. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:BLUE"><apiName>BLUE</apiName><shortdesc> 
		Der blaue Kanal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		Der blaue Kanal. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:GREEN"><apiName>GREEN</apiName><shortdesc>
		Der grüne Kanal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Der grüne Kanal.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:RED"><apiName>RED</apiName><shortdesc>
		Der rote Kanal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Der rote Kanal. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Legt eine einfarbige Füllung fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Legt eine einfarbige Füllung fest. 
 
 <p>
 Verwenden Sie ein GraphicsSolidFill-Objekt mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode. Das Zeichnen eines GraphicsSolidFill-Objekts entspricht dem Aufrufen der <codeph>Graphics.beginFill()</codeph>-Methode.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>flash.display.Graphics.beginFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsSolidFill:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Erstellt ein neues GraphicsSolidFill-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Farbwert. Gültige Werte werden im Hexadezimalformat 0xRRGGBB angegeben.  
 </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Alphatransparenzwert. Die zulässigen Werte liegen zwischen 0 (völlig transparent) und 1 (völlig undurchsichtig). 
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Erstellt ein neues GraphicsSolidFill-Objekt. 
 
 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:GraphicsSolidFill:alpha"><apiName>alpha</apiName><shortdesc>
 Gibt den Alphatransparenzwert der Füllung an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Gibt den Alphatransparenzwert der Füllung an. Die zulässigen Werte liegen zwischen 0 (völlig transparent) und 1 (völlig undurchsichtig). Der Standardwert ist 1. Anzeigeobjekte mit einem alpha-Wert von 0 sind aktiv, auch wenn sie nicht sichtbar sind. 
 
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsSolidFill:color"><apiName>color</apiName><shortdesc>
 Die Farbe der Füllung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
 Die Farbe der Füllung. GültigeWerte werden im Hexadezimalformat 0xRRGGBB angegeben. Der Standardwert ist 0xFF0000 (oder uint 0). 
 
 
 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IBitmapDrawable"><apiName>IBitmapDrawable</apiName><shortdesc>
	Die IBitmapDrawable-Schnittstelle wird von Objekten implementiert, die als source-Parameter der draw()-Methode der BitmapData-Klasse übergeben werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Die IBitmapDrawable-Schnittstelle wird von Objekten implementiert, die als <codeph>source</codeph>-Parameter der <codeph>draw()</codeph>-Methode der BitmapData-Klasse übergeben werden können. Diese Objekt sind vom Typ „BitmapData“ oder „DisplayObject“. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:CapsStyle"><apiName>CapsStyle</apiName><shortdesc>
 Die CapsStyle-Klasse ist eine Zusammenfassung von Konstantenwerten, die den beim Zeichnen von Linien zu verwendenden Abschlussstil festlegen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die CapsStyle-Klasse ist eine Zusammenfassung von Konstantenwerten, die den beim Zeichnen von Linien zu verwendenden Abschlussstil festlegen. Diese Konstanten werden als Werte im Parameter <codeph>caps</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode verwendet. Sie können die folgenden drei Abschlussstile verwenden:
 
 <p><adobeimage alt="Die drei Abschlussstile: NONE, ROUND und SQUARE." href="../../images/linecap.jpg"/></p> 
 
 </apiDesc><example conref="examples\CapsStyleExample.as"> Im folgenden Beispiel werden mit der Klasse <codeph>CapsStyleExample</codeph> drei parallele Linien gezeichnet, die alle über einen anderen Abschlussstil verfügen.
 <ol>
     <li>Die Eigenschaften der Linien sind wie folgt festgelegt:
     <ul>
         <li>Die Linienlänge ist auf 80 Pixel festgelegt.</li>
         <li>Die Rahmenfarbe ist auf Orange gesetzt.</li>
         <li>Die Rahmenbreite ist auf 30 Pixel festgelegt. </li>
         <li>Die Hervorhebungsfarbe ist auf Grau gesetzt. </li>
         <li>Die Hervorhebungsgröße ist auf 0 Pixel festgelegt.</li>
         <li>Alpha ist auf 1 (also vollständige Füllung) gesetzt.</li>
         <li>Die Funktion „pixelHinting“ ist auf „false“ gesetzt (Striche werden nicht als ganze Pixel angezeigt).</li>
         <li>Als Modus für die Linienskalierung ist „normal“ angegeben, sodass die Stärke skaliert wird. </li>
         <li>Der Verbindungsstil der Rahmenabschlüsse ist auf <codeph>MITER</codeph> gesetzt.</li>
         <li>Der Wert für die Winkelgrenze ist auf 1 gesetzt. Dies bedeutet, das der Winkel nah an der Linie abgeschnitten wird.</li>
     </ul></li>
    <li>Der Klassenkonstruktor erstellt drei vertikale Linien, die an der Position <i>x = 0, y = 0</i> beginnen, indem er dreimal die <codeph>drawLine()</codeph>-Methode aufruft und drei verschiedene Linienabschlussstile verwendet („none“, „round“ und „square“ – keiner, abgerundet und eckig). Bei jedem der drei Aufrufe der <codeph>drawLine()</codeph>-Methode werden die vorher aufgeführten Abschlussstile und Eigenschaften verwendet, um eine vertikale Linie und die zugehörige Linienhervorhebung zu zeichnen. Durch die Aufrufe wird zuerst ein neues <codeph>child</codeph>-Shape-Objekt erstellt, und dann werden die Methoden der Graphics-Klasse verwendet, um den Linienstil festzulegen und die Linien und Hervorhebungen zu zeichnen. Jede Instanz von <codeph>child</codeph> wird der Anzeigeliste hinzugefügt und auf der Bühne gezeichnet.</li>
     <li>Die verbundenen Liniensegmente werden erneut gezeichnet, indem die <codeph>refreshLayout()</codeph>-Methode mit dem Wert <i>y = 80</i> Pixel und dem Anfangspunkt bei <i>x = 80</i> Pixel mit einem Abstand von 25 Pixel zwischen den Liniensegmenten verwendet wird.</li>
 </ol>
<codeblock>
package {
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class CapsStyleExample extends Sprite {
        private var lineLength:uint            = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderJointStyle:String    = JointStyle.MITER;
        private var borderMiterLimit:uint      = 1;

        public function CapsStyleExample() {
            drawLine(CapsStyle.NONE);
            drawLine(CapsStyle.ROUND);
            drawLine(CapsStyle.SQUARE);
            refreshLayout();
        }

        private function drawLine(capsStyle:String):void {
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     capsStyle,
                                     borderJointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = lineLength;
            lastChild.y = lineLength;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = lineLength;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:CapsStyle:NONE"><apiName>NONE</apiName><shortdesc>
	 
	 Wird verwendet, um im Parameter „caps“ der flash.display.Graphics.lineStyle()-Methode keine Abschlüsse festzulegen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Wird verwendet, um im Parameter <codeph>caps</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode keine Abschlüsse festzulegen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	 
	 Wird verwendet, um im Parameter „caps“ der flash.display.Graphics.lineStyle()-Methode runde Abschlüsse festzulegen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Wird verwendet, um im Parameter <codeph>caps</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode runde Abschlüsse festzulegen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:SQUARE"><apiName>SQUARE</apiName><shortdesc>
	 
	 Wird verwendet, um im Parameter „caps“ der flash.display.Graphics.lineStyle()-Methode eckige Abschlüsse festzulegen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>square</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Wird verwendet, um im Parameter <codeph>caps</codeph> der <codeph>flash.display.Graphics.lineStyle()</codeph>-Methode eckige Abschlüsse festzulegen.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageScaleMode"><apiName>StageScaleMode</apiName><shortdesc>
Die StageScaleMode-Klasse stellt Werte für die Stage.scaleMode-Eigenschaft bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die StageScaleMode-Klasse stellt Werte für die <codeph>Stage.scaleMode</codeph>-Eigenschaft bereit. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/scaleMode"><linktext>flash.display.Stage.scaleMode</linktext></link></related-links><apiValue id="flash.display:StageScaleMode:EXACT_FIT"><apiName>EXACT_FIT</apiName><shortdesc>
Legt fest, dass die gesamte Anwendung im angegebenen Bereich sichtbar ist, wobei nicht versucht wird, das ursprüngliche Seitenverhältnis beizubehalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exactFit</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die gesamte Anwendung im angegebenen Bereich sichtbar ist, wobei nicht versucht wird, das ursprüngliche Seitenverhältnis beizubehalten. Dadurch kann es zu Verzerrungen kommen.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_BORDER"><apiName>NO_BORDER</apiName><shortdesc>
Legt fest, dass die gesamte Anwendung den angegebenen Bereich so füllt, dass sie ohne Verzerrung in den angegebenen Bereich passt. Bei Bedarf wird jedoch zugeschnitten. Das ursprüngliche Seitenverhältnis der Anwendung bleibt erhalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noBorder</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die gesamte Anwendung den angegebenen Bereich so füllt, dass sie ohne Verzerrung in den angegebenen Bereich passt. Bei Bedarf wird jedoch zugeschnitten. Das ursprüngliche Seitenverhältnis der Anwendung bleibt erhalten.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_SCALE"><apiName>NO_SCALE</apiName><shortdesc>
Legt fest, dass die Größe der Anwendung fixiert wird und auch dann unverändert bleibt, wenn sich die Größe des Player-Fensters ändert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noScale</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Größe der Anwendung festgelegt wird und auch dann unverändert bleibt, wenn sich die Größe des Player-Fensters ändert. Ist das Player-Fenster kleiner als der Flash-Inhalt, wird der Inhalt zugeschnitten.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:SHOW_ALL"><apiName>SHOW_ALL</apiName><shortdesc>
Legt fest, dass die gesamte Anwendung im angegebenen Bereich verzerrungsfrei sichtbar ist. Dabei bleibt das ursprüngliche Seitenverhältnis der Anwendung erhalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>showAll</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die gesamte Anwendung im angegebenen Bereich verzerrungsfrei sichtbar ist. Dabei bleibt das ursprüngliche Seitenverhältnis der Anwendung erhalten. Unter Umständen werden an zwei Seiten der Anwendung Ränder angezeigt.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SpreadMethod"><apiName>SpreadMethod</apiName><shortdesc>
Die SpreadMethod-Klasse stellt Werte für den Parameter „spreadMethod“ in den Methoden „beginGradientFill()“ und „lineGradientStyle()“ der Graphics-Klasse bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die SpreadMethod-Klasse stellt Werte für den Parameter <codeph>spreadMethod</codeph> in den Methoden <codeph>beginGradientFill()</codeph> und <codeph>lineGradientStyle()</codeph> der Graphics-Klasse bereit.

<p>Das folgende Beispiel zeigt dieselbe Farbverlaufsfüllung bei Verwendung verschiedener Auftragstärken:</p>

<adobetable>





<tgroup cols="3"><tbody><row>

	<entry align="center"><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>

  <entry align="center"><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>

  <entry align="center"><adobeimage alt="Linearer Farbverlauf mit SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>

</row><row>

	 <entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>


</row></tbody></tgroup></adobetable>


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:SpreadMethod:PAD"><apiName>PAD</apiName><shortdesc>
Legt fest, dass der Farbverlauf die Auftragstärke „pad“ verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pad</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass der Farbverlauf die Auftragstärke <i>pad</i> verwendet.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REFLECT"><apiName>REFLECT</apiName><shortdesc>
Legt fest, dass der Farbverlauf die Auftragstärke „reflect“ verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reflect</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass der Farbverlauf die Auftragstärke <i>reflect</i> verwendet.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REPEAT"><apiName>REPEAT</apiName><shortdesc>
Legt fest, dass der Farbverlauf die Auftragstärke „repeat“ verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>repeat</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass der Farbverlauf die Auftragstärke <i>repeat</i> verwendet.
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:FocusDirection"><apiName>FocusDirection</apiName><shortdesc>
 In der FocusDirection-Klasse werden Werte aufgelistet, die für den direction-Parameter der assignFocus()-Methode eines Stage-Objekts und für die direction-Eigenschaft eines FocusEvent-Objekts verwendet werden können.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 In der FocusDirection-Klasse werden Werte aufgelistet, die für den <codeph>direction</codeph>-Parameter der <codeph>assignFocus()</codeph>-Methode eines Stage-Objekts und für die <codeph>direction</codeph>-Eigenschaft eines FocusEvent-Objekts verwendet werden können.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#FocusEvent/direction"><linktext>flash.events.FocusEvent.direction</linktext></link><link href="flash.display.xml#Stage/assignFocus()"><linktext>flash.display.Stage.assignFocus()</linktext></link></related-links><apiValue id="flash.display:FocusDirection:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
		Gibt an, dass das Objekt am Ende der Lesereihenfolge den Fokus erhalten soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bottom</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Gibt an, dass das Objekt am Ende der Lesereihenfolge den Fokus erhalten soll.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:NONE"><apiName>NONE</apiName><shortdesc>
		Gibt an, sich das Fokusobjekt innerhalb des interaktiven Objekts nicht ändern soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Gibt an, sich das Fokusobjekt innerhalb des interaktiven Objekts nicht ändern soll.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:TOP"><apiName>TOP</apiName><shortdesc>
		Gibt an, dass das Objekt zu Beginn der Lesereihenfolge den Fokus erhalten soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>top</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Gibt an, dass das Objekt zu Beginn der Lesereihenfolge den Fokus erhalten soll.
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageAlign"><apiName>StageAlign</apiName><shortdesc>
Die StageAlign-Klasse stellt Konstantenwerte für die Stage.align-Eigenschaft bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die StageAlign-Klasse stellt Konstantenwerte für die <codeph>Stage.align</codeph>-Eigenschaft bereit. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/align"><linktext>flash.display.Stage.align</linktext></link></related-links><apiValue id="flash.display:StageAlign:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
Legt fest, dass die Bühne unten ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne unten ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
Legt fest, dass die Bühne unten links ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne unten links ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
Legt fest, dass die Bühne unten rechts ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne unten rechts ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
Legt fest, dass die Bühne links ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne links ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
Legt fest, dass die Bühne rechts ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne rechts ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP"><apiName>TOP</apiName><shortdesc>
Legt fest, dass die Bühne oben ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne oben ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
Legt fest, dass die Bühne oben links ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne oben links ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
Legt fest, dass die Bühne oben rechts ausgerichtet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt fest, dass die Bühne oben rechts ausgerichtet wird. 
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrectionSupport"><apiName>ColorCorrectionSupport</apiName><shortdesc>
Die ColorCorrectionSupport-Klasse stellt Werte für die flash.display.Stage.colorCorrectionSupport-Eigenschaft bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die ColorCorrectionSupport-Klasse stellt Werte für die <codeph>flash.display.Stage.colorCorrectionSupport</codeph>-Eigenschaft bereit. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>flash.display.Stage.colorCorrectionSupport</linktext></link></related-links><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_OFF"><apiName>DEFAULT_OFF</apiName><shortdesc>
Farbkorrektur wird unterstützt, ist aber standardmäßig deaktiviert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOff</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Farbkorrektur wird unterstützt, ist aber standardmäßig deaktiviert. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_ON"><apiName>DEFAULT_ON</apiName><shortdesc>
Farbkorrektur wird unterstützt und ist standardmäßig aktiviert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOn</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Farbkorrektur wird unterstützt und ist standardmäßig aktiviert. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:UNSUPPORTED"><apiName>UNSUPPORTED</apiName><shortdesc>
Farbkorrektur wird von der Hostumgebung nicht unterstützt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>unsupported</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Farbkorrektur wird von der Hostumgebung nicht unterstützt. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
 Legt eine Shaderfüllung fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Legt eine Shaderfüllung fest. 
 
 <p>
 Verwenden Sie ein GraphicsShaderFill-Objekt mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode. Das Zeichnen eines GraphicsShaderFill-Objekts entspricht dem Aufrufen der <codeph>Graphics.beginShaderFill()</codeph>-Methode.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsShaderFill:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
     Erstellt ein neues GraphicsShaderFill-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Der für die Füllung zu verwendende Shader. In dieser Shader-Instanz muss keine Bildeingabe festgelegt werden. Wenn jedoch im Shader eine Bildeingabe festgelegt ist, muss die Eingabe manuell bereitgestellt werden, indem die <codeph>input</codeph>-Eigenschaft der entsprechenden ShaderInput-Eigenschaft der <codeph>Shader.data</codeph>-Eigenschaft gesetzt wird.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Matrixobjekt (der flash.geom.Matrix-Klasse), mit dem Sie Transformationen am Shader definieren können. 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues GraphicsShaderFill-Objekt.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsShaderFill:matrix"><apiName>matrix</apiName><shortdesc>
     Ein Matrixobjekt (der flash.geom.Matrix-Klasse), mit dem Sie Transformationen am Shader definieren können.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Ein Matrixobjekt (der flash.geom.Matrix-Klasse), mit dem Sie Transformationen am Shader definieren können. Die folgende Matrix können Sie beispielsweise verwenden, um einen Shader um 45 Grad (pi/4 rad) zu drehen:
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     <p>Die vom Shader entgegengenommenen Koordinaten basieren auf der im <codeph>matrix</codeph>-Parameter festgelegten Matrix. Bei der Standardmatrix (<codeph>null</codeph>) sind die Koordinaten im Shader lokale Pixelkoordinaten, die für das Sampling einer Eingabe verwendet werden können.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsShaderFill:shader"><apiName>shader</apiName><shortdesc>
     Der für die Füllung zu verwendende Shader.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
     Der für die Füllung zu verwendende Shader. In dieser Shader-Instanz muss keine Bildeingabe festgelegt werden. Wenn jedoch im Shader eine Bildeingabe festgelegt ist, muss die Eingabe manuell bereitgestellt werden, indem die <codeph>input</codeph>-Eigenschaft der entsprechenden ShaderInput-Eigenschaft der <codeph>Shader.data</codeph>-Eigenschaft gesetzt wird.
     
     <p>Wenn Sie eine Shader-Instanz als Argument übergeben, wird der Shader intern kopiert und der Zeichnungsfüllvorgang verwendet anstatt eines Verweises auf den ursprünglichen Shader die interne Kopie. Änderungen am Shader, beispielsweise die Änderung eines Parameterwerts, einer Eingabe, oder des Bytecode, werden nicht auf die Kopie des Shaders angewendet, die für die Füllung verwendet wird.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Shape"><apiName>Shape</apiName><shortdesc>
 Diese Klasse dient zur Erstellung von Lightweight-Formen mit der ActionScript-Zeichen-API (Application Programming Interface).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Ein für Formen verwendetes Anzeigeobjekt.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Diese Klasse dient zur Erstellung von Lightweight-Formen mit der ActionScript-Zeichen-API (Application Programming Interface). Die Shape-Klasse enthält eine <codeph>graphics</codeph>-Eigenschaft, mit der Sie auf Methoden der Graphics-Klasse zugreifen können.
 
 <p>Die Sprite-Klasse umfasst ebenfalls eine <codeph>graphics</codeph>-Eigenschaft sowie weitere Funktionen, die in der Shape-Klasse nicht verfügbar sind. Ein Sprite-Objekt ist beispielsweise ein Anzeigeobjekt-Container, ein Shape-Objekt hingegen nicht (und kann auch keine untergeordneten Anzeigeobjekte enthalten). Aus diesem Grund verbrauchen Shape-Objekte weniger Speicherplatz als Sprite-Objekte, die dieselben Grafiken enthalten. Ein Sprite-Objekt unterstützt jedoch im Gegensatz zu einem Shape-Objekt Ereignisse, die mit einem Mausklick verknüpft sind.</p>
 
 </apiDesc><example conref="examples\ShapeExample.as"> Im folgenden Beispiel werden mit der Klasse <codeph>ShapeExample</codeph> ein Kreis, ein abgerundetes Rechteck und ein Quadrat gezeichnet. Dies wird in den folgenden Schritten erreicht:
 
 <ol>
    <li>Deklarieren Sie eine <codeph>size</codeph>-Eigenschaft zur späteren Verwendung beim Bestimmen der Größe der einzelnen Formen.</li>
 
     <li>Deklarieren Sie Eigenschaften, die die Hintergrundfarbe auf Orange, die Rahmenfarbe auf Dunkelgrau, die Rahmenbreite auf 0 Pixel und den Eckradius auf 9 Pixel setzen, und setzen Sie den Abstand zwischen Bühnenrand und anderen Objekten auf 5 Pixel.</li>
 
    <li>Verwenden Sie die in den vorherigen Schritten deklarierten Eigenschaften zusammen mit den vorhandenen Methoden der Graphics-Klasse, um an den Koordinaten x = 0, y = 0 einen Kreis, ein abgerundetes Rechteck und ein Quadrat zu zeichnen.</li>
 
    <li>Zeichnen Sie die einzelnen Formen am oberen Rand der Bühne neu, indem Sie an der Position x = 5, y = 5 beginnen und zwischen den Formen einen Abstand von jeweils 5 Pixel einhalten, indem Sie die <codeph>refreshLayout()</codeph>-Methode verwenden.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class ShapeExample extends Sprite {
        private var size:uint           = 80;
        private var bgColor:uint       = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function ShapeExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size/2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#Sprite"><linktext>flash.display.Sprite</linktext></link></related-links><apiConstructor id="flash.display:Shape:Shape"><apiName>Shape</apiName><shortdesc>
     Erstellt ein neues Shape-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Erstellt ein neues Shape-Objekt.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shape:graphics:get"><apiName>graphics</apiName><shortdesc>
     Legt das Graphics-Objekt fest, das zu diesem Shape-Objekt gehört und für das Vektorzeichnungsbefehle zulässig sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Legt das Graphics-Objekt für das Shape-Objekt fest.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Legt das Graphics-Objekt fest, das zu diesem Shape-Objekt gehört und für das Vektorzeichnungsbefehle zulässig sind.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameterType"><apiName>ShaderParameterType</apiName><shortdesc>
	 Diese Klasse definiert die Konstanten, die die möglichen Werte der type-Eigenschaft der ShaderParameter-Klasse darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Diese Klasse definiert die Konstanten, die die möglichen Werte der <codeph>type</codeph>-Eigenschaft der ShaderParameter-Klasse darstellen. Jede Konstante stellt einen Datentyp dar, der in Flash Player für Parameter in der Pixel Bender-Shadersprache verfügbar ist.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links><apiValue id="flash.display:ShaderParameterType:BOOL"><apiName>BOOL</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als bool-Wert definiert ist, der in ActionScript einer einzelnen Boolean-Instanz entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>bool</codeph>-Wert definiert ist, der in ActionScript einer einzelnen Boolean-Instanz entspricht.
		 
		 <p>Beachten Sie: Obwohl der Parameter nur einen einzelnen Wert erwartet, ist die <codeph>ShaderParameter.value</codeph>-Eigenschaft ein Array. Deshalb muss der einzelne Wert das einzige Element in dem der <codeph>value</codeph>-Eigenschaft zugewiesenen Array sein. Siehe folgendes Beispiel:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is bool
		 myShader.data.param.value = [true];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL2"><apiName>BOOL2</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als bool2-Wert definiert ist, der in ActionScript einem Array von zwei Boolean-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>bool2</codeph>-Wert definiert ist, der in ActionScript einem Array von zwei Boolean-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL3"><apiName>BOOL3</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als bool3-Wert definiert ist, der in ActionScript einem Array von drei Boolean-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>bool3</codeph>-Wert definiert ist, der in ActionScript einem Array von drei Boolean-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL4"><apiName>BOOL4</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als bool4-Wert definiert ist, der in ActionScript einem Array von vier Boolean-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>bool4</codeph>-Wert definiert ist, der in ActionScript einem Array von vier Boolean-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT"><apiName>FLOAT</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als float-Wert definiert ist, der in ActionScript einer einzelnen Number-Instanz entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt·an,·dass·der·Shaderparameter·als·￼￼<codeph>float</codeph>-Wert·definiert·ist,·der in ActionScript einer einzelnen Number-Instanz entspricht.
		 
		 <p>Beachten Sie: Obwohl der Parameter nur einen einzelnen Wert erwartet, ist die <codeph>ShaderParameter.value</codeph>-Eigenschaft ein Array. Deshalb muss der einzelne Wert das einzige Element in dem der <codeph>value</codeph>-Eigenschaft zugewiesenen Array sein. Siehe folgendes Beispiel:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is float
		 myShader.data.param.value = [22.5];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT2"><apiName>FLOAT2</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als float2-Wert definiert ist, der in ActionScript einem Array von zwei Number-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>float2</codeph>-Wert definiert ist, der in ActionScript einem Array von 2 Number-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT3"><apiName>FLOAT3</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als float3-Wert definiert ist, der in ActionScript einem Array von drei Number-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>float3</codeph>-Wert definiert ist, der in ActionScript einem Array von drei Number-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT4"><apiName>FLOAT4</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als float4-Wert definiert ist, der in ActionScript einem Array von vier Number-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>float4</codeph>-Wert definiert ist, der in ActionScript einem Array von vier Number-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT"><apiName>INT</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als int-Wert definiert ist, der in ActionScript einer einzelnen int- oder uint-Instanz entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>int</codeph>-Wert definiert ist, der in ActionScript einer einzelnen int- oder uint-Instanz entspricht.
		 
		 <p>Beachten Sie: Obwohl der Parameter nur einen einzelnen Wert erwartet, ist die <codeph>ShaderParameter.value</codeph>-Eigenschaft ein Array. Deshalb muss der einzelne Wert das einzige Element in dem der <codeph>value</codeph>-Eigenschaft zugewiesenen Array sein. Siehe folgendes Beispiel:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is int
		 myShader.data.param.value = [275];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT2"><apiName>INT2</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als int2-Wert definiert ist, der in ActionScript einem Array von zwei int- oder uint-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>int2</codeph>-Wert definiert ist, der in ActionScript einem Array von zwei int- oder uint-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT3"><apiName>INT3</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als int3-Wert definiert ist, der in ActionScript einem Array von drei int- oder uint-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>int3 </codeph>-Wert definiert ist, der in ActionScript einem Array von drei int- oder uint-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT4"><apiName>INT4</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als int4-Wert definiert ist, der in ActionScript einem Array von vier int- oder uint-Instanzen entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>int4</codeph>-Wert definiert ist, der in ActionScript einem Array von vier int- oder uint-Instanzen entspricht.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX2X2"><apiName>MATRIX2X2</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als float2x2-Wert definiert ist, der einer 2x2-Matrix entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix2x2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>float2x2</codeph>-Wert definiert ist, der einer 2x2-Matrix entspricht. Diese Matrix wird in ActionScript als Array von vier Number-Instanzen dargestellt.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX3X3"><apiName>MATRIX3X3</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als float3x3-Wert definiert ist, der einer 3x3-Matrix entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix3x3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>float3x3</codeph>-Wert definiert ist, der einer 3x3-Matrix entspricht. Diese Matrix wird in ActionScript als Array von neun Number-Instanzen dargestellt.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX4X4"><apiName>MATRIX4X4</apiName><shortdesc>
		 Gibt an, dass der Shaderparameter als float4x4-Wert definiert ist, der einer 4x4-Matrix entspricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix4x4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass der Shaderparameter als <codeph>float4x4</codeph>-Wert definiert ist, der einer 4x4-Matrix entspricht. Diese Matrix wird in ActionScript als Array von 16 Number-Instanzen dargestellt.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathWinding"><apiName>GraphicsPathWinding</apiName><shortdesc>
Die GraphicsPathWinding-Klasse stellt Werte für die flash.display.GraphicsPath.winding-Eigenschaft und die flash.display.Graphics.drawPath()-Methode zur Ermittlung der Richtung bereit, in die ein Pfad gezeichnet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die GraphicsPathWinding-Klasse stellt Werte für die <codeph>flash.display.GraphicsPath.winding</codeph>-Eigenschaft und die <codeph>flash.display.Graphics.drawPath()</codeph>-Methode zur Ermittlung der Richtung bereit, in die ein Pfad gezeichnet werden soll. Ein Pfad im Uhrzeigersinn ist positiv gewunden, ein Pfad gegen den Uhrzeigersinn ist negativ gewunden:
<p><adobeimage alt="Positive und negative Windungsrichtung" href="../../images/winding_positive_negative.gif"/></p>
<p> Wenn sich Pfade schneiden oder überlappen, bestimmt die Windungsrichtung die Regeln für das Füllen der Bereiche, die durch die Überschneidung bzw. Überlappung entstanden sind.</p>
<p><adobeimage alt="Vergleich der Windungsregeln „Gerade-Ungerade“ und „Nicht null“" href="../../images/winding_rules_evenodd_nonzero.gif"/></p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#GraphicsPath/winding"><linktext>flash.display.GraphicsPath.winding</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiValue id="flash.display:GraphicsPathWinding:EVEN_ODD"><apiName>EVEN_ODD</apiName><shortdesc>
Legt den Windungstyp „Gerade-Ungerade“ fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>evenOdd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt den Windungstyp „Gerade-Ungerade“ fest. Der Windungstyp „Gerade-Ungerade“ ist der Regelfall bei allen ursprünglichen Zeichnungs-APIs und ist der Standardwert für die <codeph>flash.display.Graphics.drawPath()</codeph>-Methode. Überlappende Pfade wechseln zwischen offenen und geschlossenen Füllungen. Wenn sich zwei Quadrate mit derselben Füllung überschneiden, wird der Bereich der Überschneidung nicht gefüllt. Angrenzende Bereiche sind unterschiedlich (weder beide gefüllt noch nicht gefüllt). 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathWinding:NON_ZERO"><apiName>NON_ZERO</apiName><shortdesc>
Legt den Windungstyp „Nicht null“ fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>nonZero</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Legt den Windungstyp „Nicht null“ fest. Der Windungstyp „Nicht null“ legt fest, dass, wenn sich zwei Pfade mit entgegengesetzter Windung überschneiden, der Überschneidungsbereich nicht gefüllt wird (wie beim Windungstyp „Gerade-Ungerade“. Bei Pfaden mit derselben Windung wird der Überschneidungsbereich gefüllt.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ActionScriptVersion"><apiName>ActionScriptVersion</apiName><shortdesc>
	Die ActionScriptVersion-Klasse ist eine Zusammenfassung von Konstantenwerten, die die Sprachversion einer geladenen SWF-Datei anzeigen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die ActionScriptVersion-Klasse ist eine Zusammenfassung von Konstantenwerten, die die Sprachversion einer geladenen SWF-Datei anzeigen. Die verfügbaren Sprachversionkonstanten erhalten Sie, indem Sie die <codeph>actionScriptVersion</codeph>-Eigenschaft eines flash.display.LoaderInfo-Objekts prüfen.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/actionScriptVersion"><linktext>flash.display.LoaderInfo.actionScriptVersion</linktext></link></related-links><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT2"><apiName>ACTIONSCRIPT2</apiName><shortdesc>
		ActionScript-Sprachversion 2.0 und frühere Versionen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript-Sprachversion 2.0 und frühere Versionen. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT3"><apiName>ACTIONSCRIPT3</apiName><shortdesc>
		ActionScript-Sprachversion 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript-Sprachversion 3.0. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
 Eine Sammlung von Befehlen für das Zeichnen und die Koordinatenparameter für diese Befehle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Eine Sammlung von Befehlen für das Zeichnen und die Koordinatenparameter für diese Befehle.
 <p>
 Verwenden Sie ein GraphicsPath-Objekt mit der <codeph>Graphics.drawGraphicsData()</codeph>-Methode. Das Zeichnen eines GraphicsPath-Objekts entspricht dem Aufrufen der <codeph>Graphics.drawPath()</codeph>-Methode.
 </p>
 <p>Die GraphicsPath-Klasse verfügt über einen eigenen Satz an Methoden (<codeph>curveTo()</codeph>, <codeph>lineTo()</codeph>, <codeph>moveTo()</codeph>, <codeph>wideLineTo()</codeph> und <codeph>wideMoveTo()</codeph>), die ähnlich sind wie die Methoden der Graphics-Klasse zum Anpassen der <codeph>GraphicsPath.commands</codeph>- und <codeph>GraphicsPath.data</codeph>-Vektorarrays.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsPath:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
     Erstellt ein neues GraphicsPath-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Ein Ganzzahlvektor, der Befehle darstellt, die in der GraphicsPathCommand-Klasse definiert sind.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Ein Zahlenvektor, bei dem jedes Zahlenpaar als Punkt behandelt wird (ein Paar bestehend aus x und y).
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Legt die Windungsregel mithilfe eines in der GraphicsPathWinding-Klasse definierten Werts fest.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues GraphicsPath-Objekt.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:GraphicsPath:curveTo"><apiName>curveTo</apiName><shortdesc>
     Fügt dem commands-Vektor einen neuen curveTo-Befehl und dem data-Vektor neue Koordinaten hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine horizontale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine vertikale Position relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine horizontale Position des nächsten Ankerpunkts relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die eine vertikale Position des nächsten Ankerpunkts relativ zum Registrierungspunkt des übergeordneten Anzeigeobjekts angibt.
     
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt dem <codeph>commands</codeph>-Vektor einen neuen curveTo-Befehl und dem <codeph>data</codeph>-Vektor neue Koordinaten hinzu.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/CURVE_TO"><linktext>flash.display.GraphicsPathCommand.CURVE_TO</linktext></link><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:lineTo"><apiName>lineTo</apiName><shortdesc>
     Fügt dem commands-Vektor einen neuen lineTo-Befehl und dem data-Vektor neue Koordinaten hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die x-Koordinate des Zielpunkts der Linie.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die y-Koordinate des Zielpunkts der Linie.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt dem <codeph>commands</codeph>-Vektor einen neuen lineTo-Befehl und dem <codeph>data</codeph>-Vektor neue Koordinaten hinzu.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>flash.display.GraphicsPathCommand.LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:moveTo"><apiName>moveTo</apiName><shortdesc>
     Fügt dem commands-Vektor einen neuen moveTo-Befehl und dem data-Vektor neue Koordinaten hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die x-Koordinate des Zielpunkts.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die y-Koordinate des Zielpunkts.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt dem <codeph>commands</codeph>-Vektor einen neuen moveTo-Befehl und dem <codeph>data</codeph>-Vektor neue Koordinaten hinzu.
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>flash.display.GraphicsPathCommand.MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideLineTo"><apiName>wideLineTo</apiName><shortdesc>
     Fügt dem commands-Vektor einen neuen wideLineTo-Befehl und dem data-Vektor neue Koordinaten hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die x-Koordinate des Zielpunkts der Linie.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die y-Koordinate des Zielpunkts der Linie.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt dem <codeph>commands</codeph>-Vektor einen neuen wideLineTo-Befehl und dem <codeph>data</codeph>-Vektor neue Koordinaten hinzu.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_LINE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_LINE_TO</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideMoveTo"><apiName>wideMoveTo</apiName><shortdesc>
     Fügt dem commands-Vektor einen neuen wideMoveTo-Befehl und dem data-Vektor neue Koordinaten hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die x-Koordinate des Zielpunkts.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die y-Koordinate des Zielpunkts.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt dem <codeph>commands</codeph>-Vektor einen neuen wideMoveTo-Befehl und dem <codeph>data</codeph>-Vektor neue Koordinaten hinzu.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_MOVE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_MOVE_TO</linktext></link></related-links></apiOperation><apiValue id="flash.display:GraphicsPath:commands"><apiName>commands</apiName><shortdesc>
     Ein Ganzzahlvektor von Zeichenbefehlen, die den Pfad darstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     Ein Ganzzahlvektor von Zeichenbefehlen, die den Pfad darstellen. Jeder Befehl kann einen der in der GraphicsPathCommand-Klasse definierten Werte haben.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPath:data"><apiName>data</apiName><shortdesc>
     Ein Zahlenvektor mit den Parametern, die für die Zeichenbefehle verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Ein Zahlenvektor mit den Parametern, die für die Zeichenbefehle verwendet werden.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPath:winding:get"><apiName>winding</apiName><shortdesc>
     Legt die Windungsregel mithilfe eines in der GraphicsPathWinding-Klasse definierten Werts fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Legt die Windungsregel mithilfe eines in der GraphicsPathWinding-Klasse definierten Werts fest.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:MorphShape"><apiName>MorphShape</apiName><shortdesc>
 Die Klasse „MorphShape“ steht für MorphShape-Objekte in der Anzeigeliste.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Klasse „MorphShape“ steht für MorphShape-Objekte in der Anzeigeliste. MorphShape-Objekte lassen sich nicht direkt in ActionScript erstellen. Sie werden angelegt, wenn Sie in der Flash-Authoring-Umgebung einen Form-Tween erstellen.
 
 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="flash.display:PixelSnapping"><apiName>PixelSnapping</apiName><shortdesc>

Die PixelSnapping-Klasse ist eine Zusammenfassung von Konstantenwerten für die Ausrichtung an Pixeln mithilfe der pixelSnapping-Eigenschaft eines Bitmap-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

Die PixelSnapping-Klasse ist eine Zusammenfassung von Konstantenwerten für die Ausrichtung an Pixeln mithilfe der <codeph>pixelSnapping</codeph>-Eigenschaft eines Bitmap-Objekts.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/pixelSnapping"><linktext>flash.display.Bitmap.pixelSnapping</linktext></link></related-links><apiValue id="flash.display:PixelSnapping:ALWAYS"><apiName>ALWAYS</apiName><shortdesc>
	Ein in der pixelSnapping-Eigenschaft verwendeter Konstantenwert für ein Bitmap-Objekt. Mit diesem Wert wird festgelegt, dass die Bitmap immer am nächsten Pixel ausgerichtet wird, und zwar unabhängig von etwaigen Transformationen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>always</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Ein in der Eigenschaft <codeph>pixelSnapping</codeph> verwendeter Konstantenwert für ein Bitmap-Objekt. Mit diesem Wert wird festgelegt, dass die Bitmap immer am nächsten Pixel ausgerichtet wird, und zwar unabhängig von etwaigen Transformationen.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:AUTO"><apiName>AUTO</apiName><shortdesc>
	Ein in der pixelSnapping-Eigenschaft verwendeter Konstantenwert für ein Bitmap-Objekt. Mit diesem Wert wird festgelegt, dass die Bitmap am nächsten Pixel ausgerichtet wird, wenn es ohne Drehung oder Neigung und mit einem Skalierungsfaktor zwischen 99,9 % und 100,1 % gezeichnet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>auto</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Ein in der <codeph>pixelSnapping</codeph>-Eigenschaft verwendeter Konstantenwert für ein Bitmap-Objekt. Mit diesem Wert wird festgelegt, dass die Bitmap am nächsten Pixel ausgerichtet wird, wenn es ohne Drehung oder Neigung und mit einem Skalierungsfaktor zwischen 99,9 % und 100,1 % gezeichnet wird. Sind diese Bedingungen erfüllt, wird das Bild bei 100 %-iger Skalierung gezeichnet und am nächstgelegenen Pixel ausgerichtet. Intern ermöglicht es diese Einstellung, dass das Bild so schnell wie möglich gezeichnet wird, indem der Vektorrenderer verwendet wird.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:NEVER"><apiName>NEVER</apiName><shortdesc>
	Ein in der pixelSnapping-Eigenschaft verwendeter Konstantenwert für ein Bitmap-Objekt. Mit diesem Wert wird festgelegt, dass keine Ausrichtung an Pixeln erfolgt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Ein in der <codeph>pixelSnapping</codeph>-Eigenschaft verwendeter Konstantenwert für ein Bitmap-Objekt. Mit diesem Wert wird festgelegt, dass keine Ausrichtung an Pixeln erfolgt.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathCommand"><apiName>GraphicsPathCommand</apiName><shortdesc>
 Definiert die Werte, die Zeichenbefehle für Pfade festlegen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Definiert die Werte, die Zeichenbefehle für Pfade festlegen. 
 
 <p>Die Werte in dieser Klasse werden von der <codeph>Graphics.drawPath()</codeph>Methode verwendet oder im <codeph>commands</codeph>-Vektor eines GraphicsPath-Objekts gespeichert.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link><link href="flash.display.xml#GraphicsPath/commands"><linktext>flash.display.GraphicsPath.commands</linktext></link></related-links><apiValue id="flash.display:GraphicsPathCommand:CURVE_TO"><apiName>CURVE_TO</apiName><shortdesc>
     Legt einen Zeichenbefehl fest, der mithilfe eines Steuerpunkts eine Kurve von der aktuellen Zeichenposition zu den im Datenvektor festgelegten x- und y-Koordinaten zeichnet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Legt einen Zeichenbefehl fest, der mithilfe eines Steuerpunkts eine Kurve von der aktuellen Zeichenposition zu den im Datenvektor festgelegten x- und y-Koordinaten zeichnet. Dieser Befehl hat denselben Effekt wie die <codeph>GraphicslineTo()</codeph>-Methode und verwendet zwei Punkte im data-Vektor-Steuerelement und -Anker: (cx, cy, ax, ay).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:LINE_TO"><apiName>LINE_TO</apiName><shortdesc>
     Legt einen Zeichenbefehl fest, der eine Linie von der aktuellen Zeichenposition zu den im Datenvektor festgelegten x- und y-Koordinaten zeichnet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Legt einen Zeichenbefehl fest, der eine Linie von der aktuellen Zeichenposition zu den im Datenvektor festgelegten x- und y-Koordinaten zeichnet. Dieser Befehl hat denselben Effekt wie die <codeph>Graphics.lineTo()</codeph>-Methode und verwendet einen Punkt im data-Vektor: (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:MOVE_TO"><apiName>MOVE_TO</apiName><shortdesc>
     Legt einen Zeichenbefehl fest, der die aktuelle Zeichenposition auf die im Datenvektor festgelegten x- und y-Koordinaten verschiebt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Legt einen Zeichenbefehl fest, der die aktuelle Zeichenposition auf die im Datenvektor festgelegten x- und y-Koordinaten verschiebt. Dieser Befehl hat denselben Effekt wie die <codeph>Graphics.moveTo()</codeph>-Methode und verwendet einen Punkt im data-Vektor: (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:NO_OP"><apiName>NO_OP</apiName><shortdesc>
     Stellt den standardmäßigen „do nothing“-Befehl dar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Stellt den standardmäßigen „do nothing“-Befehl dar.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_LINE_TO"><apiName>WIDE_LINE_TO</apiName><shortdesc>
     Legt einen „line to“-Zeichenbefehl fest, verwendet aber zwei Koordinatensätze (vier Werte) statt einem.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Legt einen „line to“-Zeichenbefehl fest, verwendet aber zwei Koordinatensätze (vier Werte) statt einem. Mit diesem Befehl können Sie zwischen „line to“- und „curve to“-Befehlen umschalten, ohne die Anzahl der pro Befehl verwendeten Datenwerte zu ändern. Dieser Befehl verwendet im Datenvektor zwei Sätze: eine Dummy-Position und eine (x, y)-Position.
     
     <p>Die Befehlsvarianten <codeph>WIDE_LINE_TO</codeph> und <codeph>WIDE_MOVE_TO</codeph> verwenden dieselbe Parameterzahl wie der <codeph>CURVE_TO</codeph>-Befehl.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_MOVE_TO"><apiName>WIDE_MOVE_TO</apiName><shortdesc>
     Legt einen „move to“-Zeichenbefehl fest, verwendet aber zwei Koordinatensätze (vier Werte) statt einem.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Legt einen „move to“-Zeichenbefehl fest, verwendet aber zwei Koordinatensätze (vier Werte) statt einem. Mit diesem Befehl können Sie zwischen „move to“- und „curve to“-Befehlen umschalten, ohne die Anzahl der pro Befehl verwendeten Datenwerte zu ändern. Dieser Befehl verwendet im Datenvektor zwei Sätze: eine Dummy-Position und eine (x, y)-Position.
     
     <p>Die Befehlsvarianten <codeph>WIDE_LINE_TO</codeph> und <codeph>WIDE_MOVE_TO</codeph> verwenden dieselbe Parameterzahl wie der <codeph>CURVE_TO</codeph>-Befehl.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>