<?xml version="1.0"?>
<apiPackage id="flash.filters"><apiName>flash.filters</apiName><apiDetail/><apiClassifier id="flash.filters:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
Mithilfe der ColorMatrixFilter-Klasse können Sie eine 4 x 5-Matrixtransformation auf den RGBA-Farb- und Alphawert jedes Pixels eines Eingabebilds anwenden, um ein neues RGBA-Farb- und Alphamuster zu erhalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Wendet eine farbliche Matrixtransformation auf die Farb- und Alphatransparenzwerte jedes Pixels an.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Mithilfe der ColorMatrixFilter-Klasse können Sie eine 4 x 5-Matrixtransformation auf den RGBA-Farb- und Alphawert jedes Pixels eines Eingabebilds anwenden, um ein neues RGBA-Farb- und Alphamuster zu erhalten. Dies ermöglicht Änderungen der Sättigung, des Farbtons und der Luminanz sowie viele andere Effekte. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.

<p><b>Hinweis:</b> Bei RGBA-Werten steht das höchstwertige Byte für den Wert des Rotkanals, gefolgt von Grün, Blau und schließlich Alpha.</p>

<p>Verwenden Sie zum Erstellen eines neuen Farbmatrixfilters die Syntax <codeph>new ColorMatrixFilter()</codeph>. Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
<ul><li>Um Filter auf Movieclips, Textfelder, Schaltflächen und Videosequenzen anzuwenden, verwenden Sie die Eigenschaft <codeph>filters</codeph> (von DisplayObject übernommen). Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>

<li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
</ul>

<p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird die <codeph>cacheAsBitmap</codeph>-Eigenschaft des Anzeigeobjekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>

<p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen erreicht.</p>

</apiDesc><example conref="examples\ColorMatrixFilterExample.as"> Im folgenden Beispiel werden verschiedene Farbmatrixfilter auf eine Bilddatei angewendet. Der Filterkonstruktor ruft <codeph>buildChild()</codeph> viermal auf, um vier Instanzen des Bildes zu laden und anzuzeigen. Beim ersten Aufrufen von <codeph>buildChild()</codeph> wird <codeph>null</codeph> als Argument angenommen und kein Filter auf die erste Instanz angewendet. Bei jedem folgenden Aufruf von <codeph>buildChild()</codeph> wird eine Funktion als Argument angenommen, mit der ein anderer Farbmatrixfilter auf jede folgende Instanz des Bildes angewendet wird.
 <p>Mit der Funktion <codeph>buildChild()</codeph> wird ein neues Loader-Objekt namens <codeph>loader</codeph> erstellt. Bei jedem Aufruf von <codeph>buildChild()</codeph> wird ein Ereignis-Listener an das Loader-Objekt angehängt. Auf diese Weise werden <codeph>complete</codeph>-Ereignisse erfasst, die von der an <codeph>buildChild()</codeph> übergebenen Funktion bearbeitet werden.</p>
 
 <p>Die Funktionen <codeph>applyRed()</codeph>, <codeph>applyGreen()</codeph> und <codeph>applyBlue()</codeph> verwenden verschiedene Werte für das <codeph>matrix</codeph>-Array, um unterschiedliche Effekte zu erzielen.</p>
 <p><b>Hinweis</b>: Die besten Ergebnisse erzielen Sie mit einem Bild mit ca. 80 Pixel Breite. Der Name und Speicherort der Bilddatei sollten dem an die <codeph>url</codeph>-Eigenschaft übergebenen Wert entsprechen. Beispielsweise verweist der an <codeph>url</codeph> übergebene Wert auf eine Datei mit dem Namen „Image.jpg“, die sich im selben Ordner wie die SWF-Datei befindet.
 </p>
 <codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.filters.ColorMatrixFilter;
    import flash.net.URLRequest;

    public class ColorMatrixFilterExample extends Sprite {
        private var size:uint  = 140;
        private var url:String = "Image.jpg";

        public function ColorMatrixFilterExample() {
            buildChild(null);
            buildChild(applyRed);
            buildChild(applyGreen);
            buildChild(applyBlue);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if (loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyRed(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([1, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyGreen(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 1, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyBlue(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>flash.display.BitmapData.getPixel()</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:ColorMatrixFilter:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
	Initialisiert eine neue ColorMatrixFilter-Instanz mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array von 20 Elementen, die als 4 x 5-Matrix angeordnet sind.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Initialisiert eine neue ColorMatrixFilter-Instanz.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Initialisiert eine neue ColorMatrixFilter-Instanz mit den angegebenen Parametern.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ColorMatrixFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
 	clones it using the <code>clone</code> method. The <code>matrix</code> property cannot be changed directly (for example,
	<code>clonedFilter.matrix[2] = 1;</code>). Instead, you must get a reference
	to the array, make the change, and reset the value using
	<code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter:       " + filter.matrix);
	
	var clonedFilter:ColorMatrixFilter = filter.clone();
	matrix = clonedFilter.matrix;
	matrix[2] = 1;
	clonedFilter.matrix = matrix;
	trace("clonedFilter: " + clonedFilter.matrix);
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue ColorMatrixFilter-Instanz mit allen Eigenschaften der ursprünglichen Instanz.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ColorMatrixFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	Ein Array von 20 Elementen für eine Farbtransformierung des Typs 4 x 5.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
  	changes its <code>matrix</code> property. The <code>matrix</code> property cannot be changed by directly modifying
  	its value (for example, <code>clonedFilter.matrix[2] = 1;</code>). Instead, you must
  	get a reference to the array, make the change to the reference, and reset the
	value using <code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter: " + filter.matrix);
	var changedMatrix:Array = filter.matrix;
	changedMatrix[2] = 1;
	filter.matrix = changedMatrix;
	trace("filter: " + filter.matrix);
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Ein Array von 20 Elementen für eine Farbtransformierung des Typs 4 x 5. Die <codeph>matrix</codeph>-Eigenschaft kann nicht unmittelbar durch Änderung ihres Werts geändert werden (z. B. durch <codeph>myFilter.matrix[2] = 1;</codeph>). Sie müssen stattdessen einen Verweis auf das Array erstellen, dort die Änderungen vornehmen und dann den Wert zurücksetzen.
	
	<p>Der Farbmatrixfilter trennt die Rot-, Grün-, Blau- und Alpha-Komponenten aller Quellpixel in srcR, srcG, srcB und srcA. Zum Berechnen der Ergebnisse für jeden der vier Kanäle wird der Wert jedes Bildpixels mit den Werten in der Transformationsmatrix multipliziert. Zu jedem Ergebnis kann optional ein Versatzwert zwischen -255 und 255 addiert werden (das fünfte Element jeder Matrixzeile). Der Filter fasst alle Farbkomponenten wieder zu einem Pixel zusammen und gibt das Ergebnis aus. In der folgenden Formel entsprechen a[0] bis a[19] den Einträgen 0 bis 19 in einem Array von 20 Elementen, das der <codeph>matrix</codeph>-Eigenschaft übergeben wird:</p>
	<pre>
	redResult   = (a[0]  ~~ srcR) + (a[1]  ~~ srcG) + (a[2]  ~~ srcB) + (a[3]  ~~ srcA) + a[4]
	greenResult = (a[5]  ~~ srcR) + (a[6]  ~~ srcG) + (a[7]  ~~ srcB) + (a[8]  ~~ srcA) + a[9]
	blueResult  = (a[10] ~~ srcR) + (a[11] ~~ srcG) + (a[12] ~~ srcB) + (a[13] ~~ srcA) + a[14]
	alphaResult = (a[15] ~~ srcR) + (a[16] ~~ srcG) + (a[17] ~~ srcB) + (a[18] ~~ srcA) + a[19]
	</pre>
	
	<p>Für alle Farbwerte im Array bedeutet der Wert 1, dass dieser Kanal zu 100 % in die Ausgabe übernommen wird und der Wert des Farbkanals somit erhalten bleibt.</p>
	
	<p>Die Berechnungen werden für die nicht multiplizierten Farbwerte durchgeführt. Wenn die Eingabegrafiken vormultiplizierte Farbwerte enthalten, werden diese Werte bei dieser Operation automatisch in nicht multiplizierte Farbwerte umgewandelt.</p>
	
	<p>Es stehen zwei optimierte Modi zur Verfügung:</p>
	
	<p><b>Nur Alpha.</b> Wenn Sie dem Filter eine Matrix übergeben, mit der wie in der folgenden Darstellung nur die Alpha-Komponente geändert wird, optimiert der Filter die Leistung:</p>
	<pre>
	    1 0 0 0 0
	    0 1 0 0 0
	    0 0 1 0 0
	    0 0 0 N 0  (where N is between 0.0 and 1.0)
	</pre>
	
	<p><b>Schnellere Version</b>: Steht nur bei SSE-/AltiVec-beschleunigten Prozessoren zur Verfügung (wie Intel<sup>®</sup> Pentium<sup>®</sup> 3 und höher bzw. Apple<sup>®</sup> G4 und höher). Der Beschleuniger wird verwendet, wenn die Multiplikatoren zwischen -15,99 und 15,99 und die Additionsterme a[4], a[9], a[14] und a[19] zwischen -8.000 und 8.000 liegen.</p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
 Mit der GradientGlowFilter-Klasse können Sie einen Glühen-Effekt mit Farbverlauf auf Anzeigeobjekte anwenden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Ermöglicht das Erstellen eines Glühen-Effekts mit Farbverlauf.
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der GradientGlowFilter-Klasse können Sie einen Glühen-Effekt mit Farbverlauf auf Anzeigeobjekte anwenden. Ein Glühen-Effekt mit Farbverlauf ist ein Glühen mit realistischem Aussehen in einem von Ihnen festgelegten Farbverlauf. Ein solcher Effekt kann um den inneren oder um den äußeren Rand eines Objekts oder über einem Objekt angewendet werden. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.
 
 <p>Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
 <ul><li>Um Filter auf Anzeigeobjekte anzuwenden, verwenden Sie die <codeph>filters</codeph>-Eigenschaft. Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>
 
 <li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
 </ul>
 
 <p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird die <codeph>cacheAsBitmap</codeph>-Eigenschaft des Anzeigeobjekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p> 
 
 <p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden dagegen nicht unterstützt. Wenn das Objekt selbst skaliert wird (also <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 1,0 sind), wird der Filtereffekt nicht skaliert. Er wird nur dann skaliert, wenn die Bühne vergrößert dargestellt wird.</p>
 
 <p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>
 
 </apiDesc><example conref="examples\GradientGlowFilterExample.as"> Im folgenden Beispiel wird ein Quadrat gezeichnet, auf das ein Glühen-Effekt mit Farbverlauf angewendet wird. Der allgemeine Workflow dieses Beispiels lautet wie folgt:
 <ol>
  <li>Importieren Sie die erforderlichen Klassen.</li>
  <li>Deklarieren Sie die globalen Variablen, mit denen das Quadrat und der Filter definiert werden.</li>
  <li>Erstellen Sie die Konstruktorfunktion, die Folgendes bewirkt:
      <ul>
          <li>Ruft die <codeph>draw()</codeph>-Methode auf. Diese Methode verwendet Methoden der Graphics-Klasse, auf die über die Eigenschaft <codeph>graphics</codeph> der Sprite-Klasse zugegriffen wird, um ein Quadrat zu zeichnen.</li>
          <li>Erstellt ein BitmapFilter-Objekt mit dem Namen <codeph>filter</codeph> und weist ihm den Wert zu, der sich aus dem Aufruf von <codeph>getBitmapFilter()</codeph> ergibt, mit dem der Filter erstellt wird.</li>
          <li>Erstellt ein neues Array mit dem Namen <codeph>myFilters</codeph> und fügt <codeph>filter</codeph> hinzu.</li>
          <li>Weist <codeph>myFilters</codeph> der <codeph>filters</codeph>-Eigenschaft des GradientGlowFilterExample-Objekts zu. Dadurch werden alle in <codeph>myFilters</codeph> vorgefundenen Filter angewendet; in diesem Fall nur <codeph>filter</codeph>.</li>
      </ul>
  </li>
 </ol>
<codeblock>
package {
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientGlowFilter;
    import flash.display.Sprite;

    public class GradientGlowFilterExample extends Sprite {
        private var bgColor:uint = 0xCCCCCC;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        private var distance:Number  = 0;
        private var angleInDegrees:Number = 45;
        private var colors:Array     = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
        private var alphas:Array     = [0, 1, 1, 1];
        private var ratios:Array     = [0, 63, 126, 255];
        private var blurX:Number     = 50;
        private var blurY:Number     = 50;
        private var strength:Number  = 2.5;
        private var quality:Number   = BitmapFilterQuality.HIGH;
        private var type:String      = BitmapFilterType.OUTER;
        private var knockout:Boolean = false;

        public function GradientGlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientGlowFilter(distance,
                                          angleInDegrees,
                                          colors,
                                          alphas,
                                          ratios,
                                          blurX,
                                          blurY,
                                          strength,
                                          quality,
                                          type,
                                          knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter-Klasse</linktext></link></related-links><apiConstructor id="flash.filters:GradientGlowFilter:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
	Initialisiert den Filter mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a gradient glow filter, assigns 
	its values, and applies it to a flat rectangle image.
	
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var art:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	var distance:Number = 0;
	var angleInDegrees:Number = 45;
 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
 	var alphas:Array = [0, 1, 1, 1];
 	var ratios:Array = [0, 63, 126, 255];
	var blurX:Number = 50;
	var blurY:Number = 50;
	var strength:Number = 2.5;
	var quality:Number = 3;
	var type:String = "outer";
	var knockout:Boolean = false;
	
	var filter:GradientGlowFilter = new GradientGlowFilter(distance, 
														 angleInDegrees, 
														 colors, 
														 alphas, 
														 ratios, 
														 blurX, 
														 blurY, 
														 strength, 
														 quality, 
														 type, 
														 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	art.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
	mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Offset des Glühen-Effekts. 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Der Winkel in Grad. Die zulässigen Werte liegen zwischen 0 und 360. 
	
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array von Farben, das einen Farbverlauf definiert. Rot beispielsweise hat den Wert 0xFF0000, Blau den Wert 0x0000FF usw.
	
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit Alphatransparenzwerten für die entsprechenden Farben im <codeph>colors</codeph>-Array. Die zulässigen Werte der einzelnen Elemente des Arrays liegen zwischen 0 und 1. Mit dem Wert 0,25 wird die Alphatransparenz beispielsweise auf 25 % gesetzt.
	
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array von Farbverteilungsverhältnissen. Die zulässigen Werte liegen zwischen 0 und 255. Dieser Wert gibt den Breitenanteil an, in dem die Farbe mit 100 % gesampelt wird.
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen dem Glühen und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255. Je höher der Wert, desto mehr Farbe wird aufgedruckt. Der Wert 0 bedeutet, dass der Filter nicht angewendet wird.
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Gibt an, wie oft der Filter angewendet werden soll. Verwenden Sie die BitmapFilterQuality-Konstanten:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Weitere Informationen finden Sie in der Beschreibung der <codeph>quality</codeph>-Eigenschaft.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Die Platzierung des Filtereffekts. Mögliche Werte sind die flash.filters.BitmapFilterType-Konstanten:
	<ul>
	<li><codeph>BitmapFilterType.OUTER</codeph> – Glühen-Effekt am äußeren Rand des Objekts</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – Glühen-Effekt am inneren Rand des Objekts (die Standardeinstellung)</li>
	<li><codeph>BitmapFilterType.FULL</codeph> – Glühen-Effekt über dem Objekt</li>
	</ul>
	
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde. Mit einem Aussparungseffekt wird eine transparente Füllung des Objekts definiert, die Hintergrundfarbe des Dokuments wird sichtbar. Der Wert <codeph>true</codeph> gibt an, dass ein Aussparungseffekt angewendet werden soll. Der Standardwert lautet <codeph>false</codeph> (kein Aussparungseffekt).
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialisiert den Filter mit den angegebenen Parametern.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:GradientGlowFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GradientGlowFilter objects and compares them; <code>filter_1</code>
	is created by using the GradientGlowFilter construtor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example below modifies the <code>knockout</code> property of <code>filter_1</code>. Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue GradientGlowFilter-Instanz mit allen Eigenschaften der ursprünglichen GradientGlowFilter-Instanz.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientGlowFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	Ein Array mit Alphatransparenzwerten für die entsprechenden Farben im colors-Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alphas</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAlphas");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var alphas:Array = filter.alphas;
		alphas.pop();
		alphas.pop();
		alphas.push(.3);
		alphas.push(1);
		filter.alphas = alphas;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ein Array von Alphatransparenzwerten.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Ein Array mit Alphatransparenzwerten für die entsprechenden Farben im <codeph>colors</codeph>-Array. Die zulässigen Werte der einzelnen Elemente des Arrays liegen zwischen 0 und 1. Mit dem Wert 0,25 wird beispielsweise ein Alphatransparenzwert von 25 % festgelegt.
	
	<p>Die <codeph>alphas</codeph>-Eigenschaft kann nicht unmittelbar durch Änderung ihrer Werte geändert werden. Sie müssen vielmehr einen Verweis auf <codeph>alphas</codeph> erstellen, dort die Änderungen vornehmen und dann <codeph>alphas</codeph> auf den Verweis setzen.</p>
	
	<p>Die Eigenschaften <codeph>colors</codeph>, <codeph>alphas</codeph> und <codeph>ratios</codeph> stehen miteinander in Zusammenhang. Das erste Element im <codeph>colors</codeph>-Array entspricht dem jeweils ersten Element im <codeph>alphas</codeph>- und im <codeph>ratios</codeph>-Array usw.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Der Winkel in Grad.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAngle");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 50;
		filter.angle = 90;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Winkel in Grad. Die zulässigen Werte liegen zwischen 0 und 360. Der Standardwert ist 45. 
	
	<p>Dieser Wert stellt den Winkel einer imaginären, das Objekt beleuchtenden Lichtquelle dar und gibt die Position des Effekts relativ zu diesem Objekt an. Falls <codeph>distance</codeph> auf 0 (null) gesetzt wird, ist der Versatz des Effekts gleich null und die <codeph>angle</codeph>-Eigenschaft hat keine Auswirkungen.</p>
        
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	 Der Grad der horizontalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	 Der Grad der vertikalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:colors:get"><apiName>colors</apiName><shortdesc>
	 Ein Array von Farben, das einen Farbverlauf definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>colors</code> property on an existing movie clip 
	 when a user clicks it.
	 <listing version="2.0">
	 import flash.filters.GradientGlowFilter;
	 var mc:MovieClip = createGradientGlowRectangle("GlowColors");
	 mc.onRelease = function() {
	 	var filter:GradientGlowFilter = this.filters[0];
	 	var colors:Array = filter.colors;
	 	colors.pop();
	 	colors.push(0xFF00FF);
	 	filter.colors = colors;
	 	this.filters = new Array(filter);
	 }
	 
	 function createGradientGlowRectangle(name:String):MovieClip {
	 	var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
	 	var w:Number = 100;
	 	var h:Number = 100;
	 	art.beginFill(0x003366);
	 	art.lineTo(w, 0);
	 	art.lineTo(w, h);
	 	art.lineTo(0, h);
	 	art.lineTo(0, 0);
	 	art._x = 20;
	 	art._y = 20;
	 
	 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	 	var alphas:Array = [0, 1, 1, 1];
	 	var ratios:Array = [0, 63, 126, 255];
	 	var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	 	var filterArray:Array = new Array();
	 	filterArray.push(filter);
	 	art.filters = filterArray;
	 	return art;
	 }
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Ein Array von Farben, das einen Farbverlauf definiert. Rot beispielsweise hat den Wert 0xFF0000, Blau den Wert 0x0000FF usw.
	 
	 <p>Die <codeph>colors</codeph>-Eigenschaft kann nicht direkt durch Bearbeiten der entsprechenden Werte geändert werden. Sie müssen vielmehr einen Verweis auf <codeph>colors</codeph> erstellen, dort die Änderungen vornehmen und dann <codeph>colors</codeph> auf den Verweis setzen.</p>
	 
	 <p>Die Eigenschaften <codeph>colors</codeph>, <codeph>alphas</codeph> und <codeph>ratios</codeph> stehen miteinander in Zusammenhang. Das erste Element im <codeph>colors</codeph>-Array entspricht dem jeweils ersten Element im <codeph>alphas</codeph>- und im <codeph>ratios</codeph>-Array usw.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Der Offset des Glühen-Effekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowDistance");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 20;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Offset des Glühen-Effekts. Der Standardwert ist 4.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowKnockout");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}

	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde. Mit einem Aussparungseffekt wird eine transparente Füllung des Objekts definiert, die Hintergrundfarbe des Dokuments wird sichtbar. Der Wert <codeph>true</codeph> gibt an, dass ein Aussparungseffekt angewendet werden soll. Der Standardwert lautet <codeph>false</codeph> (kein Aussparungseffekt).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Gibt an, wie oft der Filter angewendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowQuality");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.quality = 3;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, wie oft der Filter angewendet werden soll. Der Standardwert lautet <codeph>BitmapFilterQuality.LOW</codeph>, was einer einmaligen Anwendung des Filters entspricht. Mit dem Wert <codeph>BitmapFilterQuality.MEDIUM</codeph> wird der Filter zweimal angewendet und mit dem Wert <codeph>BitmapFilterQuality.HIGH</codeph> dreimal. Filter mit niedrigen Werten werden schneller dargestellt.
	
	<p>Bei den meisten Anwendungen genügt die Angabe der niedrigen, mittleren oder hohen Qualität für <codeph>quality</codeph>. Sie können zwar Werte bis 15 angeben, um unterschiedliche Effekte zu erzielen, höhere Werte führen jedoch auch zu einer langsameren Darstellung. Anstatt also den Wert von <codeph>quality</codeph> zu erhöhen, können Sie einen ähnlichen Effekt mit gleichzeitig schnellerer Darstellung erzielen, indem Sie einfach die Eigenschaftswerte von <codeph>blurX</codeph> und <codeph>blurY</codeph> erhöhen.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	Ein Array mit Farbverteilungsverhältnissen für die entsprechenden Farben im colors-Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>ratios</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowRatios");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var ratios:Array = filter.ratios;
		ratios.shift();
		ratios.unshift(40);
		filter.ratios = ratios;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Ein Array mit Farbverteilungsverhältnissen für die entsprechenden Farben im <codeph>colors</codeph>-Array. Die zulässigen Werte liegen zwischen 0 und 255. 
	
	<p>Die <codeph>ratios</codeph>-Eigenschaft kann nicht unmittelbar durch Bearbeitung ihrer Werte geändert werden. Sie müssen vielmehr einen Verweis auf <codeph>ratios</codeph> erstellen, dort die Änderungen vornehmen und dann <codeph>ratios</codeph> auf den Verweis setzen.</p>
	
	<p>Die Eigenschaften <codeph>colors</codeph>, <codeph>alphas</codeph> und <codeph>ratios</codeph> stehen miteinander in Zusammenhang. Das erste Element im <codeph>colors</codeph>-Array entspricht dem jeweils ersten Element im <codeph>alphas</codeph>- und im <codeph>ratios</codeph>-Array usw.</p>
	
	<p>Stellen Sie sich einen Glühen-Filter mit Farbverlauf als ein Glühen vor, das vom Zentrum eines Objekts ausgeht (sofern der Wert <codeph>distance</codeph> auf 0 (null) gesetzt wurde) und als in einander verlaufende Farbbänder angezeigt wird. Die erste Farbe des <codeph>colors</codeph>-Arrays ist die äußerste Farbe des Glühens. Die letzte Farbe stellt die innerste Farbe des Glühens dar.</p> 
	
	<p>Jeder Wert des <codeph>ratios</codeph>-Arrays legt die Position der entsprechenden Farbe im Bereich des Farbverlaufs fest. Dabei gibt 0 den äußersten Punkt und 255 den innersten Punkt des Farbverlaufs an. Die Verhältniswerte können zwischen 0 und 255 Pixel liegen und steigen dem Wert nach an, z. B. [0, 64, 128, 200, 255]. Werte zwischen 0 und 128 werden am äußeren Rand des Glühens angezeigt, während Werte zwischen 129 und 255 am inneren Rand des Glühens dargestellt werden. In Abhängigkeit von den Verhältniswerten der Farben und dem <codeph>type</codeph>-Wert des Filters werden die Filterfarben unter Umständen von dem Objekt überdeckt, auf das der Filter angewendet wird.</p>
	
	<p>Im folgenden Code und Bild wird ein Filter auf einen Movieclip mit einem schwarzen Kreis angewendet. Der Typ ist dabei auf <codeph>"full"</codeph> gesetzt. Aus Gründen der Nachvollziehbarkeit hat der erste Farbwert im <codeph>colors</codeph>-Array (Rosa) den <codeph>alpha</codeph>-Wert 1, sodass sich das Objekt gegen den weißen Hintergrund abhebt. (In einer realen Anwendung ist es eher unwahrscheinlich, dass die erste Farbe auf diese Weise angezeigt werden soll.) Die letzte Farbe des Arrays, Gelb, überdeckt den schwarzen Kreis, auf den der Filter angewendet wird:</p>
	
	<p><pre>
	var colors:Array = [0xFFCCFF, 0x0000FF, 0x9900FF, 0xFF0000, 0xFFFF00];
	var alphas:Array = [1, 1, 1, 1, 1];
	var ratios:Array = [0, 32, 64, 128, 225];
	var myGGF:GradientGlowFilter = new GradientGlowFilter(0, 0, colors, alphas, ratios, 50, 50, 1, 2, "full", false);
	</pre></p>
    <p><adobeimage alt="Ein Glühen-Filter mit Farbverlauf und einem ratios-Array von 0, 32, 64, 128, 225." href="../../images/gradientGlowDiagram.jpg"/></p>
	
	<p>Wenn Sie bei einem <codeph>type</codeph>-Wert von <codeph>"outer"</codeph> oder <codeph>"full"</codeph> einen nahtlosen Übergang vom Hintergrund des Dokuments erzielen möchten, setzen Sie die erste Farbe des Arrays auf die Farbe des Dokumenthintergrunds oder setzen Sie den Alphtransparenzwert der ersten Farbe auf 0. In beiden Fällen wird der Filter an die Hintergrundfarbe angeglichen.</p>
	
	<p>Wenn Sie an diesem Code zwei kleine Änderungen vornehmen, wird der Glühen-Effekt völlig anders dargestellt, auch wenn die <codeph>ratios</codeph>- und <codeph>colors</codeph>-Arrays unverändert belassen werden. Setzen Sie den Alphawert der ersten Farbe des Arrays auf 0 (null), damit der Filter an den weißen Dokumenthintergrund angeglichen wird, und die Eigenschaft <codeph>type</codeph> auf <codeph>"outer"</codeph> oder <codeph>"inner"</codeph>. Sehen Sie sich die Ergebnisse an. Diese sind in den folgenden Abbildungen dargestellt.</p>
        <p><adobeimage alt="äußeres Glühen" href="../../images/gradientGlowOuter.jpg"/> <adobeimage alt="inneres Glühen" href="../../images/gradientGlowInner.jpg"/></p>
	<p>Beachten Sie hierbei, dass die Farben im Farbverlauf anhand der Werte der Eigenschaften <codeph>blurX</codeph>, <codeph>blurY</codeph>, <codeph>strength</codeph> und <codeph>quality</codeph> sowie der <codeph>ratios</codeph>-Werte verteilt werden.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Die Stärke des Abdrucks oder Auftragens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowStrength");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen dem Glühen und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255. Der Wert 0 bedeutet, dass der Filter nicht angewendet wird. Der Standardwert ist 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:type:get"><apiName>type</apiName><shortdesc>
	Die Platzierung des Filtereffekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowType");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.type = "inner";
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der String ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Die Platzierung des Filtereffekts. Mögliche Werte sind die „flash.filters.BitmapFilterType“-Konstanten:
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> – Glühen-Effekt am äußeren Rand des Objekts</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – Glühen-Effekt am inneren Rand des Objekts (die Standardeinstellung)</li>
	<li><codeph>BitmapFilterType.FULL</codeph> – Glühen-Effekt über dem Objekt</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
Die DisplacementMapFilter-Klasse führt mithilfe der Pixelwerte bestimmter als „Verschiebungsmatrix“ bezeichneter BitmapData-Objekte Verschiebungen von Objekten aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Verschiebt das Originalobjekt, auf das der Filter angewendet wird.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Die DisplacementMapFilter-Klasse führt mithilfe der Pixelwerte bestimmter als <i>Verschiebungsmatrix</i> bezeichneter BitmapData-Objekte Verschiebungen von Objekten aus. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField- und Video- sowie BitmapData-Objekte.

<p>Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
<ul><li>Um Filter auf ein Anzeigeobjekt anzuwenden, verwenden Sie die <codeph>filters</codeph>-Eigenschaft des Anzeigeobjekts. Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>

<li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Beim Aufrufen von <codeph>applyFilter()</codeph> für ein BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt kombiniert.</li>
</ul>

<p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird der Wert der <codeph>cacheAsBitmap</codeph>-Eigenschaft des Anzeigeobjekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>

<p>Der Filter verwendet die folgende Formel:</p>

<codeblock>
dstPixel[x, y] = srcPixel[x + ((componentX(x, y) - 128) ~~ scaleX) / 256, y + ((componentY(x, y) - 128) ~~scaleY) / 256)
</codeblock>

<p>Dabei erhält <codeph>componentX(x, y)</codeph> den <codeph>componentX</codeph>-Farbwert der <codeph>mapBitmap</codeph>-Eigenschaft an der Position <codeph>(x - mapPoint.x ,y - mapPoint.y)</codeph>.</p>

<p>Das mit dem Filter verwendete Matrixbild wird so skaliert, dass es an die Größe der Bühne angepasst wird. Wenn das Objekt selbst skaliert wird, wird das Matrixbild nicht skaliert.</p>

<p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden jedoch nicht unterstützt. Wenn das Objekt selbst skaliert wird (also die Eigenschaften <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 1,0 sind), wird der Filtereffekt nicht skaliert. Er wird nur dann skaliert, wenn die Bühne vergrößert dargestellt wird.</p>

 </apiDesc><example conref="examples\DisplacementMapFilterExample.as"> Im folgenden Beispiel wird ein Quadrat mit einer radialen Farbverlaufsfüllung gezeichnet, ein Textfeld erstellt, ein BitmapData-Objekt erstellt und auf das DisplacementMapFilterExample-Objekt wird ein Verschiebungsmatrixfilter angewendet. Der allgemeine Workflow dieses Beispiels lautet wie folgt:
 <ol>
  <li>Die Klasse definiert Variablen für die Hintergrundfarbe, die Textfeldbezeichnung sowie die Größe und den Versatz, die in verschiedenen Funktionen verwendet werden.</li>
  <li>Die Konstruktorfunktion ruft die Methode <codeph>draw()</codeph> auf. Diese Methode verwendet Methoden der Graphics-Klasse, um ein Quadrat mit einer radialen Farbverlaufsfüllung zu zeichnen. Beachten Sie, dass es sich bei <codeph>graphics</codeph> um eine Eigenschaft des DisplacementMapFilterExample-Objekts handelt, mit dem die Klasse Sprite erweitert wird.</li>
  <li>Die Konstruktorfunktion ruft die Methode <codeph>createLabel()</codeph> auf, mit der ein Textfeld erstellt wird. In diesem Feld wird der Wert von <codeph>labelText</codeph> angezeigt und in die Anzeigeliste aufgenommen.</li>
  <li>Die Konstruktorfunktion ruft die Methode <codeph>createFilter()</codeph> auf, die Folgendes bewirkt:
      <ul>
          <li>Erstellt für das Filterobjekt eine Variable mit dem Namen <codeph>filter</codeph>.</li>
          <li>Ruft die Methode <codeph>getDisplacementMapFilter()</codeph> auf und weist den Rückgabewert der Variablen <codeph>filter</codeph> zu.</li>
          <li>Übergibt <codeph>filter</codeph> an die <codeph>filters</codeph>-Eigenschaft des DisplacementFilterExample-Objekts (die Hauptklasse).</li>
      </ul>
   </li> 
  <li>Mit der Methode <codeph>getBitmapFilter()</codeph> wird ein BitmapData-Objekt mit dem Namen <codeph>mapBitmap</codeph> erstellt, dem das Ergebnis der Methode <codeph>createBitmapData()</codeph> zugewiesen wird. Die Methode <codeph>mapBitmap</codeph> definiert zusammen mit anderen Variablen einen neuen Verschiebungsmatrixfilter.</li>
  <li>Die Methode <codeph>createBitmapData()</codeph> erstellt ein neues BitmapData-Objekt, das auf dem aktuellen Inhalt des DisplacementMapFilterExample-Objekts basiert. Auf der Basis von <codeph>bitmapData</codeph> wird eine neue Bitmap erstellt, die zur Bühne hinzugefügt wird.</li>
 </ol>
<codeblock>
package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.BitmapDataChannel;
    import flash.display.GradientType;
    import flash.display.SpreadMethod;
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.DisplacementMapFilter;
    import flash.filters.DisplacementMapFilterMode;
    import flash.geom.Matrix;
    import flash.geom.Point;
    import flash.text.TextField;
    
    public class DisplacementMapFilterExample extends Sprite {
        private var bgColor:uint     = 0xFFCC00;
        private var size:uint        = 200;
        private var offset:uint      = 90;
        private var labelText:String = "Watch the text bend with the displacement map";

        public function DisplacementMapFilterExample() {
            draw();
            createLabel();
            createFilter();
        }

        private function createFilter():void {
            var filter:BitmapFilter = getBitmapFilter();
            filters = new Array(filter);
        }

        private function getBitmapFilter():BitmapFilter {
            var mapBitmap:BitmapData = createBitmapData();
            var mapPoint:Point       = new Point(0, 0);
            var channels:uint        = BitmapDataChannel.RED;
            var componentX:uint      = channels;
            var componentY:uint      = channels;
            var scaleX:Number        = 0.5;
            var scaleY:Number        = -30;
            var mode:String          = DisplacementMapFilterMode.CLAMP;
            var color:uint           = 0;
            var alpha:Number         = 0;
            return new DisplacementMapFilter(mapBitmap,
                                             mapPoint,
                                             componentX,
                                             componentY,
                                             scaleX,
                                             scaleY,
                                             mode,
                                             color,
                                             alpha);
        }

        private function draw():void {
            var matrix:Matrix = new Matrix();
            matrix.createGradientBox(size, size);
            graphics.beginGradientFill(GradientType.RADIAL,
                                       [0xFF0000, 0x0000FF],
                                       [100, 100],
                                       [55, 200],
                                       matrix,
                                       SpreadMethod.PAD);
            graphics.drawRect(0, 0, size, size);
        }

        private function createBitmapData():BitmapData {
            var bitmapData:BitmapData = new BitmapData(size, size, true, bgColor);
            bitmapData.draw(this, new Matrix());
            var bitmap:Bitmap = new Bitmap(bitmapData);
            bitmap.x = size;
            addChild(bitmap);
            return bitmapData;
        }

        private function createLabel():void {
            var tf:TextField = new TextField();
            tf.text = labelText;
            tf.y = offset;
            tf.width = size;
            addChild(tf);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DisplacementMapFilter:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
	Initialisiert eine neue DisplacementMapFilter-Instanz mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Constructor
	 
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>mapBitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein BitmapData-Objekt mit den Daten der Verschiebungsmatrix.
	</apiDesc></apiParam><apiParam><apiItemName>mapPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Wert mit dem Offset der linken oberen Ecke des Zielanzeigeobjekts zur linken oberen Ecke des Matrixbilds.
	</apiDesc></apiParam><apiParam><apiItemName>componentX</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Gibt den Farbkanal im Matrixbild an, mit dem das <i>x</i>-Ergebnis verschoben wird. Zulässige Werte sind die BitmapDataChannel-Konstanten. 
	</apiDesc></apiParam><apiParam><apiItemName>componentY</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Gibt den Farbkanal im Matrixbild an, mit dem das <i>y</i>-Ergebnis verschoben wird. Zulässige Werte sind die BitmapDataChannel-Konstanten. 
	</apiDesc></apiParam><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Der Multiplikator, anhand dessen das auf der Matrixberechnung beruhende Ergebnis der <i>x</i>-Verschiebung skaliert wird.
	</apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Der Multiplikator, mit dem das auf der Matrixberechnung beruhende Ergebnis der <i>y</i>-Verschiebung skaliert wird.
	</apiDesc></apiParam><apiParam><apiItemName>mode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>wrap</apiData><apiDesc>Der Filtermodus. Zulässige Werte sind die DisplacementMapFilterMode-Konstanten.
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Gibt an, welche Farbe für Verschiebungen außerhalb des gültigen Bereichs verwendet werden soll. Der zulässige Bereich für Verschiebungen liegt zwischen 0,0 und 1,0. Verwenden Sie diesen Parameter, wenn <codeph>mode</codeph> auf <codeph>DisplacementMapFilterMode.COLOR</codeph> gesetzt wurde.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Gibt an, welcher Alphawert für Verschiebungen außerhalb des gültigen Bereichs verwendet werden soll. Wird als normalisierter Wert zwischen 0,0 und 1,0 angegeben. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. Verwenden Sie diesen Parameter, wenn <codeph>mode</codeph> auf <codeph>DisplacementMapFilterMode.COLOR</codeph> gesetzt wurde.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Initialisiert eine neue DisplacementMapFilter-Instanz.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Initialisiert eine neue DisplacementMapFilter-Instanz mit den angegebenen Parametern.
	
   	</apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DisplacementMapFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>DisplacementMapFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>DisplacementMapFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}		
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>mode</code> property of <code>filter_1</code>.  Modifying <code>mode</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1.mode);			// wrap
	trace(filter_2.mode);			// wrap
	trace(clonedFilter.mode);		// wrap
		
	filter_1.mode = "ignore";
	
	trace(filter_1.mode);			// ignore
	trace(filter_2.mode);			// ignore
	trace(clonedFilter.mode);		// wrap
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue DisplacementMapFilter-Instanz mit allen Eigenschaften der ursprünglichen Instanz.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DisplacementMapFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Gibt an, welcher Alphatransparenzwert für Verschiebungen außerhalb des gültigen Bereichs verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>alpha</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, welcher Alphatransparenzwert für Verschiebungen außerhalb des gültigen Bereichs verwendet werden soll. Wird als normalisierter Wert zwischen 0,0 und 1,0 angegeben. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. Der Standardwert ist 0. Verwenden Sie diese Eigenschaft, wenn die Eigenschaft <codeph>mode</codeph> auf <codeph>DisplacementMapFilterMode.COLOR</codeph> gesetzt wurde.  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:color:get"><apiName>color</apiName><shortdesc>
	Gibt an, welche Farbe für Verschiebungen außerhalb des gültigen Bereichs verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>color</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		filter.color = 0x00FF00;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, welche Farbe für Verschiebungen außerhalb des gültigen Bereichs verwendet werden soll. Der zulässige Bereich für Verschiebungen liegt zwischen 0,0 und 1,0. Die Werte liegen im hexadezimalen Format vor. Der Standardwert für <codeph>color</codeph> lautet 0. Verwenden Sie diese Eigenschaft, wenn die Eigenschaft <codeph>mode</codeph> auf <codeph>DisplacementMapFilterMode.COLOR</codeph> gesetzt wurde. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentX:get"><apiName>componentX</apiName><shortdesc>
	Gibt den Farbkanal im Matrixbild an, mit dem das x-Ergebnis verschoben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.  It changes the value from 1 to 4 which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentX = 4;
		this.filters = new Array(filter);
	}
	
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiTipTexts><apiTipText>Der zum Verschieben des x-Ergebnisses zu verwendende Farbkanal.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Gibt den Farbkanal im Matrixbild an, mit dem das <i>x</i>-Ergebnis verschoben wird. Zulässige Werte sind die BitmapDataChannel-Konstanten:
	<ul>
		<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	<li><codeph>BitmapDataChannel.BLUE</codeph></li>
	<li><codeph>BitmapDataChannel.GREEN</codeph></li>
	<li><codeph>BitmapDataChannel.RED</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentY:get"><apiName>componentY</apiName><shortdesc>
	 Gibt den Farbkanal im Matrixbild an, mit dem das y-Ergebnis verschoben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks it.  The value changes from 1 to 4, which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentY = 4;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt den Farbkanal im Matrixbild an, mit dem das <i>y</i>-Ergebnis verschoben wird. Zulässige Werte sind die BitmapDataChannel-Konstanten:
	 <ul>
	 	<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
         </ul>
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapBitmap:get"><apiName>mapBitmap</apiName><shortdesc>
	Ein BitmapData-Objekt mit den Daten der Verschiebungsmatrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapBitmap</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	var scope:Object = this;
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapBitmap = scope.createGradientBitmap(300, 80, 0xFF000000, "linear");
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	
	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier><apiException><apiDesc>Das BitmapData-Objekt ist leer (null), wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Ein BitmapData-Objekt mit den Daten der Verschiebungsmatrix.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapPoint:get"><apiName>mapPoint</apiName><shortdesc>
	Ein Wert mit dem Offset der linken oberen Ecke des Zielanzeigeobjekts zur linken oberen Ecke des Matrixbilds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapPoint</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapPoint = new Point(-30, -40);
		this.filters = new Array(filter);
		this._x = 30;
		this._y = 40;
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Das Point-Objekt ist leer (null), wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Ein Wert mit dem Offset der linken oberen Ecke des Zielanzeigeobjekts zur linken oberen Ecke des Matrixbilds.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mode:get"><apiName>mode</apiName><shortdesc>
	Der Filtermodus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example modifies <code>scaleY</code> inorder to create a displacement
	value that is out of range and then changes the <code>mode</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>ignore</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "ignore";
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	</oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der String ist leer, wenn gesetzt.
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Der String für den Filtermodus gehört nicht zu den gültigen Typen.
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Der Filtermodus. Zulässige Werte sind die DisplacementMapFilterMode-Konstanten:
	<ul>
	<li><codeph>DisplacementMapFilterMode.WRAP</codeph> – Verlegt den Verschiebungswert auf die andere Seite des Quellbilds.</li>
	<li><codeph>DisplacementMapFilterMode.CLAMP</codeph> – Setzt den Verschiebungswert auf die Kante des Quellbilds.</li>
	<li><codeph>DisplacementMapFilterMode.IGNORE</codeph> – Liegt der Verschiebungswert außerhalb des gültigen Bereichs, wird die Verschiebung ignoriert, und es werden die Quellpixel verwendet.</li>
	<li><codeph>DisplacementMapFilterMode.COLOR</codeph> – Liegt der Verschiebungswert außerhalb des Bildes, werden die Werte der Eigenschaften <codeph>color</codeph> und <codeph>alpha</codeph> ersetzt.</li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleX:get"><apiName>scaleX</apiName><shortdesc>
	Der Multiplikator, anhand dessen das auf der Matrixberechnung beruhende Ergebnis der x-Verschiebung skaliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleX = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Multiplikator, anhand dessen das auf der Matrixberechnung beruhende Ergebnis der <i>x</i>-Verschiebung skaliert wird.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleY:get"><apiName>scaleY</apiName><shortdesc>
	Der Multiplikator, anhand dessen das auf der Matrixberechnung beruhende Ergebnis der y-Verschiebung skaliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Multiplikator, mit dem das auf der Matrixberechnung beruhende Ergebnis der <i>y</i>-Verschiebung skaliert wird.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterType"><apiName>BitmapFilterType</apiName><shortdesc>
Die BitmapFilterType-Klasse enthält Werte, mit denen der Typ von BitmapFilter-Objekten festgelegt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die BitmapFilterType-Klasse enthält Werte, mit denen der Typ von BitmapFilter-Objekten festgelegt wird.

</apiDesc><example conref="examples\BitmapFilterTypeExample.as"> Im folgenden Beispiel wird ein graues Quadrat gezeichnet, auf das ein BevelFilter-Objekt angewendet wird. In diesem Beispiel erfolgt die Einstellung der Eigenschaft <codeph>type</codeph> mithilfe der Konstante <codeph>BitmapFilterType.HIGH</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterTypeExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterTypeExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterType:FULL"><apiName>FULL</apiName><shortdesc>
	Definiert die Einstellung, mit der ein Filter auf den gesamten Bereich eines Objekts angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Definiert die Einstellung, mit der ein Filter auf den gesamten Bereich eines Objekts angewendet wird.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:INNER"><apiName>INNER</apiName><shortdesc>
	Definiert die Einstellung, mit der ein Filter auf den inneren Bereich eines Objekts angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>inner</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Definiert die Einstellung, mit der ein Filter auf den inneren Bereich eines Objekts angewendet wird.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:OUTER"><apiName>OUTER</apiName><shortdesc>
	Definiert die Einstellung, mit der ein Filter auf den äußeren Bereich eines Objekts angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>outer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Definiert die Einstellung, mit der ein Filter auf den äußeren Bereich eines Objekts angewendet wird.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
Mit der DropShadowFilter-Klasse können Sie einem Anzeigeobjekt einen Schlagschatten hinzufügen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Mit der DropShadowFilter-Klasse können Sie einem Anzeigeobjekt einen Schlagschatten hinzufügen. Der Schattenalgorithmus beruht auf dem gleichen Box-Filter, der auch beim Weichzeichnen-Filter verwendet wird. Für den Stil eines Schlagschattens stehen verschiedene Optionen zur Verfügung, z. B. innere und äußere Schatten oder der Aussparungsmodus. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.

<p>Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
 <ul><li>Um Filter auf Anzeigeobjekte anzuwenden, verwenden Sie die <codeph>filters</codeph>-Eigenschaft (von DisplayObject übernommen). Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>
 
 <li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
 </ul>

<p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird der Wert der <codeph>cacheAsBitmap</codeph>-Eigenschaft des Anzeigeobjekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>
 <p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden dagegen nicht unterstützt. Wenn das Objekt selbst skaliert wird (also die Eigenschaften <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 1,0 sind), wird der Filtereffekt nicht skaliert. Er wird nur dann skaliert, wenn die Bühne vergrößert dargestellt wird.</p>
 
 <p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>

</apiDesc><example conref="examples\DropShadowFilterExample.as"> Im folgenden Beispiel wird ein gelbes Quadrat erstellt, auf das ein Schlagschatten angewendet wird. Der allgemeine Workflow dieses Beispiels lautet wie folgt:
 <ol>
  <li>Deklarieren Sie drei Eigenschaften, mit denen das Quadrat gezeichnet und auf das der Filter angewendet wird.</li>
  <li>Erstellen Sie die Konstruktorfunktion. Der Konstruktor ruft die Methode <codeph>draw()</codeph> auf. Diese Methode verwendet Methoden der Graphics-Klasse, auf die über die Eigenschaft <codeph>graphics</codeph> der Klasse Sprite zugegriffen wird, um ein orangefarbenes Quadrat zu zeichnen.</li>
  <li>Deklarieren Sie im Konstruktor die Variable <codeph>filter</codeph> als BitmapFilter-Objekt, und weisen Sie es dem Wert zu, der sich aus dem Aufruf von <codeph>getBitmapFilter()</codeph> ergibt. Mit der Methode <codeph>getBitmapFilter()</codeph> wird der verwendete Schlagschatten-Filter definiert.</li>
  <li>Erstellen Sie neues Array-Objekt <codeph>myFilters</codeph>, und fügen Sie <codeph>filter</codeph> zum Array hinzu. Weisen Sie den Array <codeph>myFilters</codeph> der Eigenschaft <codeph>filters</codeph> des DropShadowFilterExample-Objekts zu. Dadurch werden alle in <codeph>myFilters</codeph> vorgefundenen Filter angewendet; in diesem Fall nur <codeph>filter</codeph>.</li>
  </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.DropShadowFilter;

    public class DropShadowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function DropShadowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x000000;
            var angle:Number = 45;
            var alpha:Number = 0.8;
            var blurX:Number = 8;
            var blurY:Number = 8;
            var distance:Number = 15;
            var strength:Number = 0.65;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;
            return new DropShadowFilter(distance,
                                        angle,
                                        color,
                                        alpha,
                                        blurX,
                                        blurY,
                                        strength,
                                        quality,
                                        inner,
                                        knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DropShadowFilter:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
	Erstellt eine neue DropShadowFilter-Instanz mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new DropShadowFilter object
	with the default values:
	<pre>
	myFilter = new flash.filters.DropShadowFilter()
	</pre>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Versatz des Schattens in Pixel. 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Der Winkel des Schattens von 0 bis 360 Grad (Gleitkommazahl). 
	
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Farbe des Schattens im Hexadezimalformat <i>0xRRGGBB</i>. Der Standardwert lautet 0x000000.
	
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Alphatransparenzwert der Schattenfarbe. Die zulässigen Werte liegen zwischen 0.0 und 1.0. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255.0 (Gleitkomma). 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255.0 (Gleitkomma). 
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen dem Schatten und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255.0. 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Gibt an, wie oft der Filter angewendet werden soll. Verwenden Sie die BitmapFilterQuality-Konstanten:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Weitere Informationen zu diesem Parameter finden Sie in der Beschreibung der <codeph>quality</codeph>-Eigenschaft.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob es sich bei dem Schatten um einen inneren Schatten handelt. Der Wert <codeph>true</codeph> gibt einen inneren Schatten an. Der Wert <codeph>false</codeph> gibt einen äußeren Schatten an, d. h. einen Schatten um die äußeren Ränder des Objekts.
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Wendet einen Aussparungseffekt (<codeph>true</codeph>) an, der die Objektfüllung transparent macht und die Hintergrundfarbe des Dokuments zum Vorschein bringt. 
	
	</apiDesc></apiParam><apiParam><apiItemName>hideObject</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob das Objekt ausgeblendet wird oder nicht. Der Wert <codeph>true</codeph> gibt an, dass nicht das Objekt selbst sondern nur sein Schatten sichtbar ist. 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Erstellt eine neue DropShadowFilter-Instanz mit den angegebenen Parametern.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DropShadowFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three DropShadowFilter objects and compares them.  <code>filter_1</code>
	is created using the DropShadowFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue DropShadowFilter-Instanz mit allen Eigenschaften der ursprünglichen Instanz.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DropShadowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Der Alphatransparenzwert der Schattenfarbe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAlpha");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Alphatransparenzwert der Schattenfarbe. Die zulässigen Werte liegen zwischen 0.0 und 1.0. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. Der Standardwert ist 1.0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Der Winkel des Schattens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAngle");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.angle = 135;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Winkel des Schattens. Die zulässigen Werte liegen zwischen 0 und 360 Grad (Gleitkommazahl). Der Standardwert ist 45.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Der Grad der horizontalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurX");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurX = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255.0 (Gleitkomma). Der Standardwert ist 4.0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Der Grad der vertikalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurY");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurY = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255.0 (Gleitkomma). Der Standardwert ist 4.0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:color:get"><apiName>color</apiName><shortdesc>
	Die Farbe des Schattens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowColor");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.color = 0xFF0000;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Die Farbe des Schattens. Die zulässigen Werte werden im Hexadezimalformat <i>0xRRGGBB</i> angegeben. Der Standardwert lautet 0x000000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Der Versatz des Schattens in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowDistance");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.distance = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Versatz des Schattens in Pixel. Der Standardwert lautet 4,0 (Gleitkommazahl).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:hideObject:get"><apiName>hideObject</apiName><shortdesc>
	Gibt an, ob das Objekt ausgeblendet wird oder nicht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>hideObject</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowHideObject");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.hideObject = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob das Objekt ausgeblendet wird oder nicht. Der Wert <codeph>true</codeph> gibt an, dass nicht das Objekt selbst sondern nur sein Schatten sichtbar ist. Der Standardwert lautet <codeph>false</codeph> (das Objekt wird angezeigt).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	Gibt an, ob es sich bei dem Schatten um einen inneren Schatten handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowInner");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob es sich bei dem Schatten um einen inneren Schatten handelt. Der Wert <codeph>true</codeph> zeigt einen inneren Schatten an. Der Standardwert lautet <codeph>false</codeph>, gibt also einen äußeren Schatten an, d. h. einen Schatten um die äußeren Ränder des Objekts.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Wendet einen Aussparungseffekt (true) an, der die Objektfüllung transparent macht und die Hintergrundfarbe des Dokuments zum Vorschein bringt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowKnockout");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Wendet einen Aussparungseffekt (<codeph>true</codeph>) an, der die Objektfüllung transparent macht und die Hintergrundfarbe des Dokuments zum Vorschein bringt. Der Standardwert lautet <codeph>false</codeph> (keine Aussparung).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	 Gibt an, wie oft der Filter angewendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowQuality");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.quality = 0;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, wie oft der Filter angewendet werden soll. Der Standardwert lautet <codeph>BitmapFilterQuality.LOW</codeph>, was einer einmaligen Anwendung des Filters entspricht. Mit dem Wert <codeph>BitmapFilterQuality.MEDIUM</codeph> wird der Filter zweimal angewendet und mit dem Wert <codeph>BitmapFilterQuality.HIGH</codeph> dreimal. Filter mit niedrigen Werten werden schneller dargestellt.
	 
	 <p>In den meisten Fällen reicht die Angabe der niedrigen, mittleren oder hohen Qualität für „quality“ aus. Sie können zwar Werte bis 15 angeben, um unterschiedliche Effekte zu erzielen, höhere Werte führen jedoch auch zu einer langsameren Darstellung. Anstatt also den Wert von <codeph>quality</codeph> zu erhöhen, können Sie einen ähnlichen Effekt mit gleichzeitig schnellerer Darstellung erzielen, indem Sie einfach die Eigenschaftswerte von <codeph>blurX</codeph> und <codeph>blurY</codeph> erhöhen.</p>
         </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:DropShadowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Die Stärke des Abdrucks oder Auftragens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowStrength");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.strength = .6;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen dem Schatten und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255.0. Der Standardwert lautet 1.0.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterQuality"><apiName>BitmapFilterQuality</apiName><shortdesc>
Die BitmapFilterQuality-Klasse enthält Werte, mit denen die Darstellungsqualität von BitmapFilter-Objekten festgelegt werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die BitmapFilterQuality-Klasse enthält Werte, mit denen die Darstellungsqualität von BitmapFilter-Objekten festgelegt werden kann.

</apiDesc><example conref="examples\BitmapFilterQualityExample.as"> Im folgenden Beispiel wird ein graues Quadrat gezeichnet, auf das ein BevelFilter-Objekt angewendet wird. In diesem Beispiel erfolgt die Einstellung der Eigenschaft <codeph>quality</codeph> mithilfe der Konstante <codeph>BitmapFilterQuality.HIGH</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterQualityExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterQualityExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>BlurFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>DropShadowFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
	Definiert die Filtereinstellung für hohe Qualität.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Definiert die Filtereinstellung für hohe Qualität.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:LOW"><apiName>LOW</apiName><shortdesc>
	Definiert die Filtereinstellung für niedrige Qualität.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Definiert die Filtereinstellung für niedrige Qualität. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
	Definiert die Filtereinstellung für mittlere Qualität.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Definiert die Filtereinstellung für mittlere Qualität.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilterMode"><apiName>DisplacementMapFilterMode</apiName><shortdesc>
Die DisplacementMapFilterMode-Klasse stellt Werte für die „mode“-Eigenschaft der DisplacementMapFilter-Klasse bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die DisplacementMapFilterMode-Klasse stellt Werte für die <codeph>mode</codeph>-Eigenschaft der DisplacementMapFilter-Klasse bereit.

</apiDesc></apiClassifierDetail><apiValue id="flash.filters:DisplacementMapFilterMode:CLAMP"><apiName>CLAMP</apiName><shortdesc>
	Setzt den Verschiebungswert auf die Kante des Quellbilds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>clamp</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Setzt den Verschiebungswert auf die Kante des Quellbilds. Verwenden Sie diesen Wert mit der <codeph>DisplacementMapFilter.mode</codeph>-Eigenschaft.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:COLOR"><apiName>COLOR</apiName><shortdesc>
	Liegt der Verschiebungswert außerhalb des Bilds, werden die Werte der Eigenschaften „color“ und „alpha“ ersetzt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>color</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Wenn der Verschiebungswert außerhalb des Bilds liegt, werden die Werte der Eigenschaften <codeph>color</codeph> und <codeph>alpha</codeph> ersetzt. Verwenden Sie diesen Wert mit der <codeph>DisplacementMapFilter.mode</codeph>-Eigenschaft.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:IGNORE"><apiName>IGNORE</apiName><shortdesc>
	Wenn der Verschiebungswert außerhalb des gültigen Bereichs liegt, wird die Verschiebung ignoriert, und es werden die Quellpixel verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ignore</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Wenn der Verschiebungswert außerhalb des gültigen Bereichs liegt, wird die Verschiebung ignoriert, und es werden die Quellpixel verwendet. Verwenden Sie diesen Wert mit der <codeph>DisplacementMapFilter.mode</codeph>-Eigenschaft.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:WRAP"><apiName>WRAP</apiName><shortdesc>
	Verlegt den Verschiebungswert auf die andere Seite des Quellbilds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>wrap</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Verlegt den Verschiebungswert auf die andere Seite des Quellbilds. Verwenden Sie diesen Wert mit der <codeph>DisplacementMapFilter.mode</codeph>-Eigenschaft.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.filters:BevelFilter"><apiName>BevelFilter</apiName><shortdesc> 
 Mit der BevelFilter-Klasse können Sie einen Abschrägungseffekt auf Anzeigeobjekte anwenden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Fügt einen Abschrägungseffekt hinzu. 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Mit der BevelFilter-Klasse können Sie einen Abschrägungseffekt auf Anzeigeobjekte anwenden. Durch diesen Abschrägungseffekt erhalten Objekte, beispielsweise Schaltflächen, ein dreidimensionales Aussehen mit abgeflachten Kanten. Dabei haben Sie die Möglichkeit, diesen Effekt mithilfe verschiedener Glanzlicht- und Schattenfarben anzupassen. Darüber hinaus können Sie die Weichzeichnung, den Winkel und die Position der abgeflachten Kanten und des Aussparungseffekts festlegen. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.
 
 <p>Verwenden Sie zum Erstellen eines neuen Filters den Konstruktor <codeph>new BevelFilter()</codeph>. Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
 <ul><li>Um Filter auf Movieclips, Textfelder, Schaltflächen und Videosequenzen anzuwenden, verwenden Sie die Eigenschaft <codeph>filters</codeph> (von DisplayObject übernommen). Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>
 
 <li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
 </ul>
 
 <p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird der Wert der <codeph>cacheAsBitmap</codeph>-Eigenschaft des Objekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>
 
 <p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden dagegen nicht unterstützt. Wenn das Objekt selbst skaliert wird (also die Eigenschaften <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 100 % sind), wird der Filtereffekt nicht skaliert. Er wird nur dann skaliert, wenn die Bühne vergrößert dargestellt wird.</p>
 
 <p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>
 
 </apiDesc><example conref="examples\BevelFilterExample.as"> Im folgenden Beispiel wird ein dunkelgelbes Quadrat erstellt, auf das ein leuchtend gelbes (0xFFFF00) Glanzlicht und ein blauer (0x0000FF) Schatten angewendet werden. Der allgemeine Workflow dieses Beispiels lautet wie folgt:
 <ol>
  <li>Importieren Sie die erforderlichen Klassen.</li>   
  <li>Deklarieren Sie drei Eigenschaften für die <codeph>draw()</codeph>-Funktion, mit der das Objekt, auf das der Abschrägungsfilter angewendet wird, gezeichnet wird.</li>
  <li>Erstellen Sie die <codeph>BevelFilterExample()</codeph>-Konstruktorfunktion, die Folgendes bewirkt:
      <ul>
          <li>Ruft die <codeph>draw()</codeph>-Funktion auf, die später deklariert wird.</li>
          <li>Deklariert eine Variable <codeph>filter</codeph> als BitmapFilter-Objekt und weist es dem Wert zu, der sich aus dem Aufruf von <codeph>getBitmapFilter()</codeph> ergibt.</li>
          <li>Erstellt ein neues Array-Objekt <codeph>myFilters</codeph> und fügt <codeph>filter</codeph> zum Array hinzu. Anschließend wird <codeph>myFilters</codeph> der <codeph>filters</codeph>-Eigenschaft des BevelFilterExample-Objekts zugewiesen. Dadurch werden alle in <codeph>myFilters</codeph> vorgefundenen Filter angewendet; in diesem Fall nur <codeph>filter</codeph>.</li>      
      </ul>
 </li>
  <li>Erstellen Sie die <codeph>getBitmapFilter</codeph>-Funktion, mit der Eigenschaften für den Filter erstellt und festgelegt werden.</li>
  <li>Erstellen Sie die <codeph>draw()</codeph>-Funktion. Diese Funktion verwendet Methoden der Graphics-Klasse, auf die über die Eigenschaft <codeph>graphics</codeph> der Sprite-Klasse zugegriffen wird, um das Quadrat zu zeichnen.</li>
  
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BevelFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xFFFF00;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x0000FF;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BevelFilter:BevelFilter"><apiName>BevelFilter</apiName><shortdesc>
	Initialisiert eine neue BevelFilter-Instanz mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following code creates a new BevelFilter instance. The values given 
	are the default values; you could call the constructor without any values and get the same result.
	<listing> filter = new flash.filters.BevelFilter (4, 45, 0xFFFFFF, 1, 0x000000, 1, 4, 4, 1, 
	1, "inner", false) 
	</listing>
	The next example instantiates a new BevelFilter and applies it to the MovieClip <code>rect</code>.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var distance:Number = 5;
	var angleInDegrees:Number = 45;
	var highlightColor:uint = 0xFFFF00;
	var highlightAlpha:Number = .8;
	var shadowColor:uint = 0x0000FF;
	var shadowAlpha:Number = .8;
	var blurX:Number = 20;
	var blurY:Number = 20;
	var strength:Number = 1;
	var quality:int = 3;
	var type:String = "inner";
	var knockout:Boolean = false;
	
	var filter:BevelFilter = new BevelFilter(distance, angleInDegrees, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout);
	
	var rect:MovieClip = createRectangle(100, 100, 0x00CC00, "bevelFilterExample");
	rect.filters = new Array(filter);
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Versatz der Abschrägung in Pixeln (Gleitkommazahl). 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Der Winkel der Abschrägung von 0 bis 360 Grad. 
	</apiDesc></apiParam><apiParam><apiItemName>highlightColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFF</apiData><apiDesc>Die Glanzlichtfarbe der Abschrägung im Format <i>0xRRGGBB</i>. 
	</apiDesc></apiParam><apiParam><apiItemName>highlightAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Alphatransparenzwert der Glanzlichtfarbe. Die zulässigen Werte liegen zwischen 0,0 und 1,0. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. 
	</apiDesc></apiParam><apiParam><apiItemName>shadowColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0x000000</apiData><apiDesc>Die Schattenfarbe der Abschrägung im Format <i>0xRRGGBB</i>. 
	</apiDesc></apiParam><apiParam><apiItemName>shadowAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Alphatransparenzwert der Schattenfarbe. Die zulässigen Werte liegen zwischen 0,0 und 1,0. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. 
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der horizontalen Weichzeichnung in Pixel. Die zulässigen Werte liegen zwischen 0 und 255., (Gleitkomma). 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der vertikalen Weichzeichnung in Pixel. Die zulässigen Werte liegen zwischen 0 und 255, (Gleitkomma).
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen der Abschrägung und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255,0 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Die Qualität der Abschrägung. Die zulässigen Werte liegen zwischen 0 und 15. In den meisten Anwendungen können Sie jedoch die <codeph>BitmapFilterQuality</codeph>-Konstanten verwenden:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Filter mit niedrigen Werten werden schneller dargestellt. Sie können die anderen verfügbaren Zahlenwerte verwenden, um andere Effekte zu erzielen.</p>

	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Der Typ der Abschrägung. Bei den zulässigen Werten handelt es sich um die <codeph>BitmapFilterType</codeph>-Konstanten: <codeph>BitmapFilterType.INNER</codeph>, <codeph>BitmapFilterType.OUTER</codeph> oder <codeph>BitmapFilterType.FULL</codeph>. 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Wendet einen Aussparungseffekt (<codeph>true</codeph>) an, der die Objektfüllung transparent macht und die Hintergrundfarbe des Dokuments zum Vorschein bringt.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialisiert eine neue BevelFilter-Instanz mit den angegebenen Parametern.
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#BitmapFilterType"><linktext>BitmapFilterType</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:BevelFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BevelFilter objects and compares them.  <code>filter_1</code>
	is created using the BevelFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
	 	// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
		// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue BevelFilter-Instanz mit allen Eigenschaften der ursprünglichen BevelFilter-Instanz.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Der Winkel der Abschrägung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.angle = 225;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Winkel der Abschrägung. Die zulässigen Werte liegen zwischen 0 und 360 Grad. Der Standardwert ist 45°.
	
	<p>Dieser Wert stellt den Winkel einer imaginären, das Objekt beleuchtenden Lichtquelle dar und gibt die Position des Effekts relativ zu diesem Objekt an. Wenn die <codeph>distance</codeph>-Eigenschaft auf 0 (null) gesetzt wird, ist der Versatz des Effekts gleich null und die <codeph>angle</codeph>-Eigenschaft hat keine Auswirkungen.</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Der Grad der horizontalen Weichzeichnung in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurX");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurX = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der horizontalen Weichzeichnung in Pixel. Die zulässigen Werte liegen zwischen 0 und 255,0 (Gleitkommazahl). Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Der Grad der vertikalen Weichzeichnung in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurY");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurY = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der vertikalen Weichzeichnung in Pixel. Die zulässigen Werte liegen zwischen 0 und 255,0 (Gleitkommazahl). Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Der Versatz der Abschrägung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.distance = 3;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Versatz der Abschrägung. Die zulässigen Werte sind in Pixeln angegeben (Gleitkommazahl). Der Standardwert ist 4.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightAlpha:get"><apiName>highlightAlpha</apiName><shortdesc>
	Der Alphatransparenzwert der Glanzlichtfarbe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Alphatransparenzwert der Glanzlichtfarbe. Wird als normalisierter Wert von 0 bis 1 angegeben. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. Der Standardwert ist 1.
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightColor:get"><apiName>highlightColor</apiName><shortdesc>
	Die Glanzlichtfarbe der Abschrägung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightColor = 0x0000FF;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Die Glanzlichtfarbe der Abschrägung. Die zulässigen Werte werden im Hexadezimalformat <i>0xRRGGBB</i> angegeben. Der Standardwert lautet 0xFFFFFF.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
    Wendet einen Aussparungseffekt (true) an, der die Objektfüllung transparent macht und die Hintergrundfarbe des Dokuments zum Vorschein bringt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelKnockout");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    Wendet einen Aussparungseffekt (<codeph>true</codeph>) an, der die Objektfüllung transparent macht und die Hintergrundfarbe des Dokuments zum Vorschein bringt. Der Standardwert lautet <codeph>false</codeph> (keine Aussparung).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Gibt an, wie oft der Filter angewendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelQuality");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, wie oft der Filter angewendet werden soll. Der Standardwert lautet <codeph>BitmapFilterQuality.LOW</codeph>, was einer einmaligen Anwendung des Filters entspricht. Mit dem Wert <codeph>BitmapFilterQuality.MEDIUM</codeph> wird der Filter zweimal angewendet und mit dem Wert <codeph>BitmapFilterQuality.HIGH</codeph> dreimal. Filter mit niedrigen Werten werden schneller dargestellt.
	
	<p>Bei den meisten Anwendungen genügt die Angabe der niedrigen, mittleren oder hohen Qualität für <codeph>quality</codeph>. Sie können zwar Werte bis 15 angeben, um unterschiedliche Effekte zu erzielen, höhere Werte führen jedoch auch zu einer langsameren Darstellung. Anstatt also den Wert von <codeph>quality</codeph> zu erhöhen, können Sie einen ähnlichen Effekt mit gleichzeitig schnellerer Darstellung erzielen, indem Sie einfach die Eigenschaftswerte von <codeph>blurX</codeph> und <codeph>blurY</codeph> erhöhen.</p>
	
	<p>Mithilfe der folgenden <codeph>BitmapFilterQuality</codeph>-Konstanten können Sie die Werte der <codeph>quality</codeph>-Eigenschaft einstellen:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowAlpha:get"><apiName>shadowAlpha</apiName><shortdesc>
	Der Alphatransparenzwert der Schattenfarbe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Alphatransparenzwert der Schattenfarbe. Wird als normalisierter Wert von 0 bis 1 angegeben. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. Der Standardwert ist 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowColor:get"><apiName>shadowColor</apiName><shortdesc>
	Die Schattenfarbe der Abschrägung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowColor = 0xFFFF00;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Die Schattenfarbe der Abschrägung. Die zulässigen Werte werden im Hexadezimalformat <i>0xRRGGBB</i> angegeben. Der Standardwert lautet 0x000000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Die Stärke des Abdrucks oder Auftragens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelStrength");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.strength = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Die Stärke des Abdrucks oder Auftragens. Die zulässigen Werte liegen zwischen 0 und 255. Je höher der Wert, desto mehr Farbe wird aufgedruckt und desto stärker ist der Kontrast zwischen der Abschrägung und dem Hintergrund. Der Standardwert ist 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:type:get"><apiName>type</apiName><shortdesc>
	Die Platzierung der Abschrägung auf dem Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelType");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.type = "outer";
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der String ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Die Platzierung der Abschrägung auf dem Objekt. Innere und äußere Abschrägungen werden an der Innen- bzw. Außenkante platziert. Eine vollständige Abschrägung wird auf das gesamte Objekt platziert. Bei den zulässigen Werten handelt es sich um die <codeph>BitmapFilterType</codeph>-Konstanten:
	
	<ul>
	<li><codeph>BitmapFilterType.INNER</codeph></li>
	<li><codeph>BitmapFilterType.OUTER</codeph></li>
	<li><codeph>BitmapFilterType.FULL</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilter"><apiName>BitmapFilter</apiName><shortdesc>
 Die BitmapFilter-Klasse ist die Basisklasse für alle Bildfiltereffekte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Basisklasse für alle Bildfiltereffekte.
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die BitmapFilter-Klasse ist die Basisklasse für alle Bildfiltereffekte. 
 
 <p>Die Klassen BevelFilter, BlurFilter, ColorMatrixFilter, ConvolutionFilter, DisplacementMapFilter, DropShadowFilter, GlowFilter, GradientBevelFilter und GradientGlowFilter erweitern die BitmapFilter-Klasse. Diese Filter können auf alle Anzeigeobjekte angewendet werden.</p>
 
 <p>Sie können BitmapFilter-Objekte weder direkt instanziieren noch direkt erweitern.</p>
 
 </apiDesc><example conref="examples\BitmapFilterExample.as"> Im folgenden Beispiel wird gezeigt, wie mehrere Filter auf ein DisplayObject-Objekt angewendet und mit der Eigenschaft <codeph>filters</codeph> verfolgt werden können.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.*;

    public class BitmapFilterExample extends Sprite {
        public function BitmapFilterExample() {
            trace(this.filters.length);             // 0

            var tmpFilters:Array = this.filters;
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.BEVEL_FILTER));
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.GLOW_FILTER));
            this.filters = tmpFilters;

            trace(this.filters.length);             // 2
            trace(this.filters[0] is BitmapFilter); // true
            trace(this.filters[0] is BevelFilter);  // true
            trace(this.filters[1] is BitmapFilter); // true
            trace(this.filters[1] is GlowFilter);   // true
        }
    }
}

import flash.filters.*;
class FilterFactory {
    public static var BEVEL_FILTER:String = "BevelFilter";
    public static var BevelFilterConstructor:Class = BevelFilter;

    public static var BLUR_FILTER:String = "BlurFilter";
    public static var BlurFilterConstructor:Class = BlurFilter;

    public static var COLOR_MATRIX_FILTER:String = "ColorMatrixFilter";
    public static var ColorMatrixFilterConstructor:Class = ColorMatrixFilter;

    public static var CONVOLUTION_FILTER:String = "ConvolutionFilter";
    public static var ConvolutionFilterConstructor:Class = ConvolutionFilter;

    public static var DISPLACEMENT_MAP_FILTER:String = "DisplacementMapFilter";
    public static var DisplacementMapFilterConstructor:Class = DisplacementMapFilter;

    public static var DROP_SHADOW_FILTER:String = "DropShadowFilter";
    public static var DropShadowFilterConstructor:Class = DropShadowFilter;

    public static var GLOW_FILTER:String = "GlowFilter";
    public static var GlowFilterConstructor:Class = GlowFilter;

    public static var GRADIENT_BEVEL_FILTER:String = "GradientBevelFilter";
    public static var GradientBevelFilterConstructor:Class = GradientBevelFilter;

    public static var GRADIENT_GLOW_FILTER:String = "GradientGlowFilter";
    public static var GradientGlowFilterConstructor:Class = GradientGlowFilter;

    public static function createFilter(type:String):BitmapFilter {
        return new FilterFactory[type + "Constructor"]();   
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.filters:BitmapFilter:clone"><apiName>clone</apiName><shortdesc>
	 Gibt ein BitmapFilter-Objekt zurück, das eine exakte Kopie des ursprünglichen BitmapFilter-Objekts ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein BitmapFilter-Objekt.
	 
	 </apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Eine Kopie des BitmapFilter-Objekts.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt ein BitmapFilter-Objekt zurück, das eine exakte Kopie des ursprünglichen BitmapFilter-Objekts ist.
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.filters:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
 Mit der BlurFilter-Klasse können Sie einen Weichzeichnungseffekt auf Anzeigeobjekte anwenden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Ein Weichzeichnungseffekt.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der BlurFilter-Klasse können Sie einen Weichzeichnungseffekt auf Anzeigeobjekte anwenden. Die Weichzeichnung verwischt die Einzelheiten eines Bilds. Dabei können Sie Weichzeichnungen erstellen, die von einer geringfügig unscharfen Anzeige bis zu einer Gauss-Weichzeichnung reichen, einer verschwommenen Sicht, etwa wie durch eine Milchglasscheibe. Wird die <codeph>quality</codeph>-Eigenschaft dieses Filter dabei auf „Niedrig“ gesetzt, führt dies zu einem geringfügig unscharfen Erscheinungsbild generiert. Wird die <codeph>quality</codeph>-Eigenschaft dagegen auf „Hoch“ eingestellt, ergibt dies in etwa ein Gauss-Verwischen. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.
 
 <p>Verwenden Sie zum Erstellen eines neuen Filters den <codeph>newBlurFilter()</codeph>-Konstruktor. Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
 <ul><li>Um Filter auf Movieclips, Textfelder, Schaltflächen und Videosequenzen anzuwenden, verwenden Sie die Eigenschaft <codeph>filters</codeph> (von DisplayObject übernommen). Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>
 
 <li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
 </ul>
 
 <p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird die <codeph>cacheAsBitmap</codeph>-Eigenschaft des Anzeigeobjekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>
 
 <p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden dagegen nicht unterstützt. Wenn das Objekt selbst skaliert wird (also die Eigenschaften <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 100 % sind), wird der Filtereffekt nicht skaliert. Er wird nur dann skaliert, wenn die Bühne vergrößert dargestellt wird.</p>
 
 <p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>
 
 </apiDesc><example conref="examples\BlurFilterExample.as"> Im folgenden Beispiel wird ein dunkelgelbes Quadrat erstellt, auf das ein Gauss-Weichzeichnungsfilter angewendet wird. Der allgemeine Workflow dieses Beispiels lautet wie folgt:
 <ol>
  <li>Importieren Sie die erforderlichen Klassen.</li>   
  <li>Deklarieren Sie drei Eigenschaften für die <codeph>draw()</codeph>-Funktion, mit der das Objekt, auf das der Weichzeichnungsfilter angewendet wird, gezeichnet wird. </li>
  <li>Erstellen Sie die <codeph>BlurFilterExample()</codeph>-Konstruktorfunktion, die Folgendes bewirkt:
      <ul>
          <li>Ruft die <codeph>draw()</codeph>-Funktion auf, die später deklariert wird.</li>
          <li>Deklariert eine Variable <codeph>filter</codeph> als BitmapFilter-Objekt und weist es dem Wert zu, der sich aus dem Aufruf von <codeph>getBitmapFilter()</codeph> ergibt.</li>
          <li>Erstellt ein neues Array-Objekt <codeph>myFilters</codeph> und fügt <codeph>filter</codeph> zum Array hinzu. Anschließend wird <codeph>myFilters</codeph> der <codeph>filters</codeph>-Eigenschaft des BlurFilterExample-Objekts zugewiesen. Dadurch werden alle in <codeph>myFilters</codeph> vorgefundenen Filter angewendet; in diesem Fall nur <codeph>filter</codeph>.</li>
      </ul>
  </li>
  <li>Erstellen Sie die <codeph>getBitmapFilter()</codeph>-Funktion, mit der Eigenschaften für den Filter erstellt und festgelegt werden.</li>
  <li>Erstellen Sie die <codeph>draw()</codeph>-Funktion. Diese Funktion verwendet Methoden der Graphics-Klasse, auf die über die Eigenschaft <codeph>graphics</codeph> der Sprite-Klasse zugegriffen wird, um das Quadrat zu zeichnen.</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BlurFilter;

    public class BlurFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BlurFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var blurX:Number = 30;
            var blurY:Number = 30;
            return new BlurFilter(blurX, blurY, BitmapFilterQuality.HIGH);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BlurFilter:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
	Initialisiert den Filter mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Instantiate a new <code>BlurFilter</code> and apply it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "BlurFilterExample");
	
	var blurX:Number = 30;
	var blurY:Number = 30;
	var quality:Number = 3;
	
	var filter:BlurFilter = new BlurFilter(blurX, blurY, quality);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255,0 (Gleitkommazahl). 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255,0 (Gleitkommazahl). 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Gibt an, wie oft der Filter angewendet werden soll. Sie können die Qualität mithilfe der folgenden „BitmapFilterQuality“-Konstanten festlegen:
	<ul>
	<li><codeph>flash.filters.BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Hohe Qualität entspricht etwa einer Gauss-Weichzeichnung. Für die meisten Anwendungen sind diese drei Werte ausreichend. Sie können zwar weitere Zahlenwerte bis 15 angeben, um unterschiedliche Effekte zu erzielen, beachten Sie jedoch, dass höhere Werte auch zu einer langsameren Wiedergabe führen.</p>
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Initialisiert den Filter.
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Initialisiert den Filter mit den angegebenen Parametern. Mit den Standardwerten wird ein weiches unscharfes Bild erstellt.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:BlurFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BlurFilter objects and compares them.  <code>filter_1</code>
	is created using the BlurFilter constructor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>quality</code> property of <code>filter_1</code>.  Modifying <code>quality</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1.quality);			// 2
	trace(filter_2.quality);			// 2
	trace(clonedFilter.quality);		// 2
	
	filter_1.quality = 1;
	
	trace(filter_1.quality);			// 1
	trace(filter_2.quality);			// 1
	trace(clonedFilter.quality);		// 2
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue „BlurFilter“-Instanz mit allen Eigenschaften der ursprünglichen „BlurFilter“-Instanz.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BlurFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Der Grad der horizontalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurX");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurX = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255,0 (Gleitkommazahl). Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Der Grad der vertikalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurY");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurY = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255,0 (Gleitkommazahl). Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Gibt an, wie oft die Weichzeichnung durchgeführt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterQuality");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, wie oft die Weichzeichnung durchgeführt werden soll. Der Standardwert lautet <codeph>BitmapFilterQuality.LOW</codeph>, was einer einmaligen Anwendung des Filters entspricht. Mit dem Wert <codeph>BitmapFilterQuality.MEDIUM</codeph> wird der Filter zweimal angewendet und mit dem Wert <codeph>BitmapFilterQuality.HIGH</codeph> dreimal. Bei Letzterem entspricht der Effekt einer Gauss-Weichzeichnung. Filter mit niedrigen Werten werden schneller dargestellt.
	
	<p>Bei den meisten Anwendungen genügt die Angabe der niedrigen, mittleren oder hohen Qualität für <codeph>quality</codeph>. Sie können zwar Zahlenwerte bis 15 angeben, um die Anzahl der Filteranwendung zu erhöhen, höhere Werte führen jedoch auch zu einer langsameren Wiedergabe. Anstatt also den Wert von <codeph>quality</codeph> zu erhöhen, können Sie einen ähnlichen Effekt mit gleichzeitig schnellerer Darstellung erzielen, indem Sie einfach die Eigenschaftswerte von <codeph>blurX</codeph> und <codeph>blurY</codeph> erhöhen.</p>
	
	<p>Mithilfe der folgenden BitmapFilterQuality-Konstanten können Sie die Werte für die <codeph>quality</codeph>-Eigenschaft festlegen:</p>
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
Die ConvolutionFilter-Klasse wendet einen Matrix-Convolution-Filtereffekt an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Do we allow anything other than 3x3 matrix convolution? Are default x y values correct?

</internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Wendet einen Matrix-Convolution-Filter an.

</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Die ConvolutionFilter-Klasse wendet einen Matrix-Convolution-Filtereffekt an. Bei einem Convolution-Filter wird durch Kombination der Pixel im Eingabebild mit den benachbarten Pixel ein neues Bild erstellt. Mithilfe von Convolution-Filtern können zahlreiche Bildeffekte erzielt werden, darunter Weich- oder Scharfzeichnung, Kantenerkennung, Prägung und Schliff. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.

<p>Verwenden Sie zum Erstellen eines Convolution-Filters die Syntax <codeph>new ConvolutionFilter()</codeph>. Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
<ul><li>Um Filter auf Movieclips, Textfelder, Schaltflächen und Videosequenzen anzuwenden, verwenden Sie die Eigenschaft <codeph>filters</codeph> (von DisplayObject übernommen). Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>

<li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
</ul>

<p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird der Wert der <codeph>cacheAsBitmap</codeph>-Eigenschaft des Objekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>

<p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>

</apiDesc><example conref="examples\ConvolutionFilterExample.as"> Im folgenden Beispiel werden verschiedene Convolution-Filter auf eine Bilddatei angewendet. Der Filterkonstruktor ruft <codeph>buildChild()</codeph> viermal auf, um vier Instanzen des Bildes zu laden und anzuzeigen. Bei jedem Aufruf von <codeph>buildChild()</codeph> wird eine Funktion als Argument angenommen, mit der auf die erste Instanz kein Filter und auf jede folgende Instanz ein anderer Convolution-Filter angewendet wird.
 <p>Mit der Funktion <codeph>buildChild()</codeph> wird ein neues Loader-Objekt namens <codeph>loader</codeph> erstellt. Bei jedem Aufruf von <codeph>buildChild()</codeph> wird ein Ereignis-Listener an das Loader-Objekt angehängt. Auf diese Weise werden <codeph>complete</codeph>-Ereignisse erfasst, die von der an <codeph>buildChild()</codeph> übergebenen Funktion bearbeitet werden.</p>
 
 <p>Die Funktionen <codeph>applyBrightness()</codeph>, <codeph>applySharpness()</codeph> und <codeph>applyOutline()</codeph> verwenden verschiedene Werte für das <codeph>matrix</codeph>-Array, um unterschiedliche ConvolutionFilter-Effekte zu erzielen.</p>
 <p><b>Hinweis</b>: Die besten Ergebnisse erzielen Sie mit einem Bild mit ca. 80 Pixel Breite. Der Name und Speicherort der Bilddatei sollten dem an die <codeph>url</codeph>-Eigenschaft übergebenen Wert entsprechen. Beispielsweise verweist der im Beispiel an <codeph>url</codeph> übergebene Wert auf eine Datei mit dem Namen „Image.jpg“, die sich im selben Ordner wie die SWF-Datei befindet.
 </p>
 
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.filters.BitmapFilter;
    import flash.filters.ConvolutionFilter;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class ConvolutionFilterExample extends Sprite {
        private var size:uint = 140;
        private var url:String = "Image.jpg";

        public function ConvolutionFilterExample() {
            buildChild(applyNothing);
            buildChild(applyBrightness);
            buildChild(applySharpness);
            buildChild(applyOutline);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if(loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyNothing(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            applyLabel(child, "no filter");
        }

        private function applyBrightness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [5, 5, 5,
                                5, 0, 5,
                                5, 5, 5];
            applyFilter(child, matrix);
            applyLabel(child, "brightness");
        }

        private function applySharpness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [0, -1, 0,
                               -1, 20, -1,
                                0, -1, 0];
            applyFilter(child, matrix);
            applyLabel(child, "sharpness");
        }

        private function applyOutline(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [-30, 30, 0,
                                -30, 30, 0,
                                -30, 30, 0];
            applyFilter(child, matrix);
            applyLabel(child, "outline");
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var matrixX:Number = 3;
            var matrixY:Number = 3;
            var divisor:Number = 9;
            var filter:BitmapFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }

        private function applyLabel(child:DisplayObject, label:String):void {
            var tf:TextField = new TextField();
            tf.x = child.x;
            tf.y = child.height;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.text = label;
            addChild(tf);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.filters.xml#ConvolutionFilter/matrix"><linktext>matrix</linktext></link></related-links><apiConstructor id="flash.filters:ConvolutionFilter:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
	Initialisiert eine neue ConvolutionFilter-Instanz mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a ConvolutionFilter
	object with the four required parameters <code>matrixX</code>, <code>matrixY</code>, 
	<code>matrix</code>, and <code>divisor</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var matrixX:Number = 3;
	var matrixY:Number = 3;
	var matrix:Array = [1, 1, 1, 1, 1, 1, 1, 1, 1];
	var divisor:Number = 9;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
	
   	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
   	
  	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
  	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
   	myBitmapData.noise(128);
   		
   	mc.onPress = function() {
   		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
   	}
	</listing>
	
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrixX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die <i>x</i>-Dimension der Matrix (die Anzahl der Spalten in der Matrix). Der Standardwert ist 0.
	</apiDesc></apiParam><apiParam><apiItemName>matrixY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die <i>y</i>-Dimension der Matrix (die Anzahl der Zeilen in der Matrix). Der Standardwert ist 0.
	</apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Array von für die Matrixtransformation verwendeten Werten. Die Anzahl der Elemente in diesem Array muss <codeph>matrixX ~~ matrixY</codeph> entsprechen.
	</apiDesc></apiParam><apiParam><apiItemName>divisor</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der während der Matrixtransformation verwendete Nenner. Der Standardwert ist 1. Ein Nenner in der Höhe der Summe aller Matrixwerte gleicht die allgemeine Farbintensität des Ergebnisses aus. Der Wert 0 wird ignoriert, stattdessen wird der Standardwert verwendet. 
	</apiDesc></apiParam><apiParam><apiItemName>bias</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Der Ausgleichswert, der dem Ergebnis der Matrixtransformation hinzugefügt wird. Der Standardwert ist 0.
	</apiDesc></apiParam><apiParam><apiItemName>preserveAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Der Wert <codeph>false</codeph> gibt an, dass der Alphawert nicht übernommen wird, sondern dass der Convolution-Filter auf alle Kanäle, einschließlich des Alphakanals, angewendet wird. Bei <codeph>true</codeph> gilt die Convolution nur für die Farbkanäle. Der Standardwert ist <codeph>true</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>clamp</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Für Pixel außerhalb des Quellbilds gibt <codeph>true</codeph> an, dass das Eingabebild durch Duplizierung der Farbwerte an einem bestimmten Rand soweit wie nötig über seine Begrenzungen hinaus erweitert wird. Der Wert <codeph>false</codeph> gibt dagegen an, dass entsprechend den Eigenschaften <codeph>color</codeph> und <codeph>alpha</codeph> eine andere Farbe verwendet werden soll. Der Standardwert lautet <codeph>true</codeph>. 
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Hexadezimalwert der Farbe, durch die die Pixel außerhalb des Quellbilds ersetzt werden.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Der Alphawert der Ersatzfarbe.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialisiert eine neue ConvolutionFilter-Instanz mit den angegebenen Parametern.
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ConvolutionFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>ConvolutionFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>ConvolutionFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}		
	</listing>
	
	<p>To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>bias</code> property of <code>filter_1</code>.  Modifying <code>bias</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.</p>
	
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	trace(filter_1.bias);			// 0
	trace(filter_2.bias);			// 0
	trace(clonedFilter.bias);		// 0
	
	filter_1.bias = 20;
	
	trace(filter_1.bias);			// 20
	trace(filter_2.bias);			// 20
	trace(clonedFilter.bias);		// 0
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>BitmapFilter, eine neue ConvolutionFilter-Instanz mit allen Eigenschaften der ursprünglichen ConvolutionMatrixFilter-Instanz.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ConvolutionFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Der Alphatransparenzwert der Ersatzfarbe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property of <code>filter</code>
	from its default value of <code>1</code> to <code>.35</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var alpha:Number = .35;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, 0x0000FF, alpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	 
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, 98, 78), new Point(2, 2), filter);
  	}
	</listing>	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Alphatransparenzwert der Ersatzfarbe. Die zulässigen Werte liegen zwischen 0 und 1.0. Der Standardwert lautet 0. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt.	  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:bias:get"><apiName>bias</apiName><shortdesc>
	Der Ausgleichswert, der dem Ergebnis der Matrixtransformation hinzugefügt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>bias</code> property of <code>filter</code>
	from its default value of 0 to 50.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var bias:Number = 50;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, bias);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
 	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Ausgleichswert, der dem Ergebnis der Matrixtransformation hinzugefügt wird. Der Ausgleichswert erhöht den Farbwert jedes Kanals, sodass dunkle Farben heller erscheinen. Der Standardwert ist 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:clamp:get"><apiName>clamp</apiName><shortdesc>
	Gibt an, ob das Bild an einer bestimmten Position festgesetzt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob das Bild an einer bestimmten Position festgesetzt werden soll. Für Pixel außerhalb des Quellbilds gibt <codeph>true</codeph> an, dass das Eingabebild durch Duplizierung der Farbwerte an jedem seiner Ränder Rand soweit wie nötig über seine Begrenzungen hinaus erweitert wird. Der Wert <codeph>false</codeph> gibt dagegen an, dass entsprechend den Eigenschaften <codeph>color</codeph> und <codeph>alpha</codeph> eine andere Farbe verwendet werden soll. Der Standardwert lautet <codeph>true</codeph>.
	
	</apiDesc><example conref="ConvolutionClampExample.as"> Im folgenden Beispiel werden mithilfe der <codeph>BitmapData</codeph>-Klasse zwei Rahmen erstellt, von denen einer halb so groß ist wie der andere. Beim ersten Laden des Beispiels wird der größere Rahmen mithilfe von <codeph>attachBitmap()</codeph> innerhalb von <codeph>mc</codeph> gezeichnet. Wird <codeph>mc</codeph> angeklickt und die <codeph>applyFilter()</codeph>-Methode aufgerufen, so wird die <codeph>largeBox</codeph>-Instanz von <codeph>BitmapData</codeph> mit <codeph>smallBox</codeph> als Quellbitmap neu gezeichnet. Da <codeph>applyFilter()</codeph><codeph>smallBox </codeph> über ein <codeph>Rectangle</codeph> zeichnet, dessen Breite und Höhe der Breite und Höhe von <codeph>largeBox</codeph> entsprechen, ist die Quellbitmap kleiner als der Zeichnungsbereich. Die <codeph>clamp</codeph>-Eigenschaft von <codeph>ConvolutionFilter</codeph> ist in diesem Fall auf <codeph>false</codeph> gesetzt und der Bereich, der von der Quellbitmap nicht abgedeckt wird, nämlich <codeph>smallBox</codeph>, ist einfarbig rot, wie in den Variablen <codeph>clampColor</codeph> und <codeph>clampAlpha</codeph> festgelegt.
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.filters.ConvolutionFilter;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.geom.Point;

    public class ConvolutionClampExample extends Sprite {
        // Variables that affect clamping:
        var clamp:Boolean = false;
        var clampColor:Number = 0xFF0000;
        var clampAlpha:Number = 1;
        
        // For illustration, keep other ConvolutionFilter variables neutral:
        var bias:Number = 0;
        var preserveAlpha:Boolean = false;
        // Also, construct a neutral matrix
        var matrixCols:Number = 3;
        var matrixRows:Number = 3;
        var matrix:Array = [ 1,1,1,
                             1,1,1,
                             1,1,1 ];
        
        var filter:ConvolutionFilter = new ConvolutionFilter(matrixCols, matrixRows, matrix, matrix.length, bias, preserveAlpha, clamp, clampColor, clampAlpha);
        
        var largeBoxWidth:Number = 100;
        var largeBoxHeight:Number = 100;
        var largeBox:BitmapData = new BitmapData(largeBoxWidth, largeBoxWidth, true, 0xCC00FF00);
        var smallBoxWidth:Number = largeBoxWidth / 2;
        var smallBoxHeight:Number = largeBoxHeight / 2;
        var smallBox:BitmapData = new BitmapData(smallBoxWidth, smallBoxWidth, true, 0xCC0000FF);
            
        var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
        mc.attachBitmap(largeBox, this.getNextHighestDepth());
        
        mc.onPress = function() {
            largeBox.applyFilter(smallBox,
                                 new Rectangle(0,0, largeBoxWidth, largeBoxHeight),
                                 new Point(0,0),
                                 filter);
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:color:get"><apiName>color</apiName><shortdesc>
	Der Hexadezimalwert der Farbe, durch die die Pixel außerhalb des Quellbilds ersetzt werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property of <code>filter</code>
	from its default value of <code>0</code> to <code>0xFF0000</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var color:Number = 0x0000FF;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, color, 1);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	  	
  	var height:Number = 100;
  	var width:Number = 80;
  	mc.onPress = function() {
  		height -= 2;
  		width -= 2;
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, height, width), new Point(2, 2), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Der Hexadezimalwert der Farbe, durch die die Pixel außerhalb des Quellbilds ersetzt werden. Hierbei handelt es sich um einen RGB-Wert ohne Alphakomponente. Der Standardwert ist 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:divisor:get"><apiName>divisor</apiName><shortdesc>
	Der während der Matrixtransformation verwendete Nenner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>divisor</code> property of <code>filter</code>
	to 6.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  	
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	 	
  	mc.onPress = function() {
  		var newDivisor:Number = 6;
  		filter.divisor = newDivisor;
  	 	myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der während der Matrixtransformation verwendete Nenner. Der Standardwert ist 1. Ein Nenner in der Höhe der Summe aller Matrixwerte gleicht die allgemeine Farbintensität des Ergebnisses aus. Der Wert 0 wird ignoriert, stattdessen wird der Standardwert verwendet. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	Ein Array von für die Matrixtransformation verwendeten Werten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>matrix</code> property of <code>filter</code>
	from one that blurs a bitmap to one that sharpens it.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  		
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	  	
  	mc.onPress = function() {
  		var newMatrix:Array = [0, -1, 0, -1, 8, -1, 0, -1, 0];
  		filter.matrix = newMatrix;
  		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Ein Array von für die Matrixtransformation verwendeten Werten. Die Anzahl der Elemente in diesem Array muss <codeph>matrixX ~~ matrixY</codeph> entsprechen.
	<p> Dabei basiert eine Matrix-Convolution auf einer <i>n</i>-mal-<i>m</i>-Matrix, die beschreibt, wie ein bestimmter Pixelwert im Eingabebild mit den Werten der benachbarten Pixel kombiniert wird, um den Ergebniswert zu erzielen. Jedes Ergebnispixel wird durch Anwenden der Matrix auf den entsprechenden Wert des Quellpixels und der benachbarten Pixel festgelegt.</p>
	
	<p> Bei einem 3 x 3-Matrix-Convolution-Filter wird für jeden einzelnen Farbkanal die folgende Formel angewendet:
	<pre><codeph>
	dst (x, y) = ((src (x-1, y-1) ~~ a0 + src(x, y-1) ~~ a1....
	                  src(x, y+1) ~~ a7 + src (x+1,y+1) ~~ a8) / divisor) + bias
	</codeph></pre>
	</p>
	
	<p>Bestimmte Filterfunktionen werden schneller ausgeführt, wenn sie auf einem System mit einem SSE-fähigen Prozessor (Streaming SIMD Extensions) ausgeführt werden. Es folgen Kriterien für schnellere Convolution-Vorgänge:</p>
	<ul>
	<li>Beim Filter muss es sich um einen 3x3-Filter handeln.</li>
	<li>Alle Filterterme müssen Ganzzahlen zwischen -127 und +127 sein.</li>
	<li>Die Summe aller Filterterme darf insgesamt nicht mehr als den absoluten Wert 127 ergeben.</li> 
	<li>Wenn ein Filterterm negativ ist, muss der Nenner zwischen 2,00001 und 256 liegen.</li>
	<li>Wenn alle Filterterme positiv sind, muss der Nenner zwischen 1,1 und 256 liegen.</li>
	<li>Bei dem Wert des Parameters „bias“ muss es sich um eine Ganzzahl handeln.</li>
	</ul>
    <p><b>Hinweis:</b> Wenn Sie den Konstruktor ohne Parameter zum Erstellen einer ConvolutionFilter-Instanz verwenden, hat die Reihenfolge, in der Sie den Matrixeigenschaften Werte zuweisen, Einfluss auf das Verhalten des Filters. Im folgenden Fall wird das Matrix-Array zugewiesen, während die Eigenschaften <codeph>matrixX</codeph> und <codeph>matrixY</codeph> noch auf <codeph>0</codeph> gesetzt sind (Standardwert):</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    </codeblock>
    <p>Im folgenden Fall wird das Matrix-Array zugewiesen, während die Eigenschaften <codeph>matrixX</codeph> und <codeph>matrixY</codeph> auf <codeph>3</codeph> gesetzt sind:</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    </codeblock>
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixX:get"><apiName>matrixX</apiName><shortdesc>
	Die x-Dimension der Matrix (die Anzahl der Spalten in der Matrix).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixX</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
 	
 	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixX);	// 2
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Die <i>x</i>-Dimension der Matrix (die Anzahl der Spalten in der Matrix). Der Standardwert ist 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixY:get"><apiName>matrixY</apiName><shortdesc>
	Die y-Dimension der Matrix (die Anzahl der Zeilen in der Matrix).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixY</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixY);	// 3
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Die <i>y</i>-Dimension der Matrix (die Anzahl der Zeilen in der Matrix). Der Standardwert ist 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:preserveAlpha:get"><apiName>preserveAlpha</apiName><shortdesc>
	Gibt an, ob der Alphakanal ohne Anwendung des Filtereffekts beibehalten wird oder ob der Convolution-Filter neben den Farbkanälen auch auf den Alphakanal angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>preserveAlpha</code> property of <code>filter</code>
	from its default value of <code>true</code> to <code>false</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var preserveAlpha:Boolean = false;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, preserveAlpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
	
	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob der Alphakanal ohne Anwendung des Filtereffekts beibehalten wird oder ob der Convolution-Filter neben den Farbkanälen auch auf den Alphakanal angewendet wird. Der Wert <codeph>false</codeph> gibt an, dass die Convolution auf alle Kanäle angewendet werden soll, auch auf den Alphakanal. Bei <codeph>true</codeph> gilt die Convolution nur für die Farbkanäle. Der Standardwert ist <codeph>true</codeph>.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
Mit der GradientBevelFilter-Klasse können Sie einen Farbverlaufseffekt und eine Abschrägung auf Anzeigeobjekte anwenden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Ermöglicht das Anwenden eines Farbverlaufseffekt und einer Abschrägung.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Mit der GradientBevelFilter-Klasse können Sie einen Farbverlaufseffekt und eine Abschrägung auf Anzeigeobjekte anwenden. Bei einem Farbverlauf mit Abschrägung handelt es sich um eine abgeflachte Kante, bei der die Außen-, Innen- oder Oberseite eines Objekts einen Farbverlauf erhielten. Abgeflachte Kanten lassen ein Objekt dreidimensional erscheinen. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.

 <p>Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
 <ul><li>Um Filter auf Anzeigeobjekte anzuwenden, verwenden Sie die <codeph>filters</codeph>-Eigenschaft. Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>
 
 <li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
 </ul>

<p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird die <codeph>cacheAsBitmap</codeph>-Eigenschaft des Anzeigeobjekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p> 

<p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden dagegen nicht unterstützt. Wenn das Objekt selbst skaliert wird (also <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 1,0 sind), wird der Filtereffekt nicht skaliert. Er wird nur dann skaliert, wenn die Bühne vergrößert dargestellt wird.</p>

<p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>

 </apiDesc><example conref="examples\GradientBevelFilterExample.as"> Im folgenden Beispiel wird ein Quadrat gezeichnet, auf das ein Filter für Farbverlauf mit Abschrägung angewendet wird. Der allgemeine Workflow dieses Beispiels lautet wie folgt:
 <ol>
  <li>Importieren Sie die erforderlichen Klassen.</li>
  <li>Deklarieren Sie die globalen Variablen, mit denen das Quadrat und der Filter definiert werden.</li>
  <li>Erstellen Sie die Konstruktorfunktionen, die Folgendes bewirkt:
      <ul>
          <li>Ruft die <codeph>draw()</codeph>-Methode auf. Diese Methode verwendet Methoden der Graphics-Klasse, auf die über die Eigenschaft <codeph>graphics</codeph> der Klasse Sprite zugegriffen wird, um ein graues Quadrat zu zeichnen.</li>
          <li>Erstellt ein BitmapFilter-Objekt mit dem Namen <codeph>filter</codeph> und weist ihm den Wert zu, der sich aus dem Aufruf von <codeph>getBitmapFilter()</codeph> ergibt, mit dem der Filter erstellt wird.</li>
          <li>Erstellt ein neues Array mit dem Namen <codeph>myFilters</codeph> und fügt <codeph>filter</codeph> hinzu.</li>
          <li>Weist <codeph>myFilters</codeph> der <codeph>filters</codeph>-Eigenschaft des GradientBevelFilterExample-Objekts zu. Dadurch werden alle in <codeph>myFilters</codeph> vorgefundenen Filter angewendet; in diesem Fall nur <codeph>filter</codeph>.</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientBevelFilter;

    public class GradientBevelFilterExample extends Sprite {
        private var bgColor:uint     = 0xCCCCCC;
        private var size:uint        = 80;
        private var offset:uint      = 50;
        private var distance:Number  = 5;
        private var angleInDegrees:Number = 225; // opposite 45 degrees
        private var colors:Array     = [0xFFFFFF, 0xCCCCCC, 0x000000];
        private var alphas:Array     = [1, 0, 1];
        private var ratios:Array     = [0, 128, 255];
        private var blurX:Number     = 8;
        private var blurY:Number     = 8;
        private var strength:Number  = 2;
        private var quality:Number   = BitmapFilterQuality.HIGH
        private var type:String      = BitmapFilterType.INNER;
        private var knockout:Boolean = true;

        public function GradientBevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientBevelFilter(distance,
                                           angleInDegrees,
                                           colors,
                                           alphas,
                                           ratios,
                                           blurX,
                                           blurY,
                                           strength,
                                           quality,
                                           type,
                                           knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:GradientBevelFilter:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
	Initialisiert den Filter mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Constructor
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Offset-Abstand. Die zulässigen Werte liegen zwischen 0 und 8. 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Der Winkel in Grad. Die zulässigen Werte liegen zwischen 0 und 360. 
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit den im Farbverlauf zu verwendenden RGB-Hexadezimalfarbwerten. Rot beispielsweise hat den Wert 0xFF0000, Blau den Wert 0x0000FF usw.
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit Alphatransparenzwerten für die entsprechenden Farben im <codeph>colors</codeph>-Array. Die zulässigen Werte der einzelnen Elemente des Arrays liegen zwischen 0 und 1. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt.
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit Farbverteilungsverhältnissen. Die zulässigen Werte liegen zwischen 0 und 255.
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen der Abschrägung und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255. Der Wert 0 bedeutet, dass der Filter nicht angewendet wird. 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Die Qualität des Filters. Verwenden Sie die BitmapFilterQuality-Konstanten:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Weitere Informationen finden Sie in der Beschreibung der <codeph>quality</codeph>-Eigenschaft.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Die Platzierung des Abschrägungsffekts. Zulässige Werte sind die BitmapFilterType-Konstanten:
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> – Abschrägung an der Außenkante des Objekts</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – Abschrägung an der Innenkante des Objekts</li>
	<li><codeph>BitmapFilterType.FULL</codeph> – Abschrägungt auf der Oberseite des Objekts</li>
	</ul>
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob ein Aussparungseffekt angewendet wird. Mit <codeph>true</codeph> wird eine transparente Füllung des Objekts definiert, die Hintergrundfarbe des Dokuments wird sichtbar. 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialisiert den Filter mit den angegebenen Parametern.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/quality"><linktext>GradientBevelFilter.quality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GradientBevelFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two rectangle shapes. The first, 
	<code>sourceClip</code> has a bevel effect. The second, 
	<code>resultClip</code> has no effect until it is clicked.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var sourceClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneSourceClip");
	var resultClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneResultClip");
	
	resultClip.source = sourceClip;
	
	var sourceFilter:GradientBevelFilter = getNewFilter();
	sourceClip.filters = new Array(sourceFilter);
	
	resultClip._x = 180;
	resultClip.onRelease = function() {
		this.filters = new Array(this.source.filters[0].clone());
	}
	
	function setUpFlatRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		return mc;
	}
	
	function getNewFilter():GradientBevelFilter {
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		return new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	}
	
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue GradientBevelFilter-Instanz mit allen Eigenschaften der ursprünglichen GradientBevelFilter-Instanz.
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientBevelFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	Ein Array mit Alphatransparenzwerten für die entsprechenden Farben im colors-Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>alphas</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("alphasExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [.2, 0, .2];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [1, 0, 1];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ein Array von Alphawerten.
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Ein Array mit Alphatransparenzwerten für die entsprechenden Farben im <codeph>colors</codeph>-Array. Die zulässigen Werte der einzelnen Elemente des Arrays liegen zwischen 0 und 1. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt.
	
	<p>Die <codeph>alphas</codeph>-Eigenschaft kann nicht unmittelbar durch Änderung ihrer Werte geändert werden. Sie müssen vielmehr einen Verweis auf <codeph>alphas</codeph> erstellen, dort die Änderungen vornehmen und dann <codeph>alphas</codeph> auf den Verweis setzen.</p>
	
	<p>Die Eigenschaften <codeph>colors</codeph>, <codeph>alphas</codeph> und <codeph>ratios</codeph> stehen miteinander in Zusammenhang. Das erste Element im <codeph>colors</codeph>-Array entspricht dem jeweils ersten Element im <codeph>alphas</codeph>- und im <codeph>ratios</codeph>-Array usw.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Der Winkel in Grad.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>angle</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("angleExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].angle = 45;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Winkel in Grad. Die zulässigen Werte liegen zwischen 0 und 360. Der Standardwert ist 45.
	
	<p>Dieser Wert stellt den Winkel einer imaginären, das Objekt beleuchtenden Lichtquelle dar. Der Wert des Winkels bestimmt den Winkel, in dem die Farben des Farbverlaufs auf das Objekt angewendet werden: An welcher Stelle die Glanzlicht-Effekte und Schatten dargestellt bzw. die erste Farbe im Array angezeigt wird. Die Farben werden dann in der Reihenfolge ihrer Anordnung im Array angewendet.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Der Grad der horizontalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurX</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurXExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurX = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Der Grad der vertikalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurY</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurYExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurY = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255. Eine Weichzeichnung mit einer Stärke von 1 oder weniger bedeutet, dass das Originalbild kopiert wird. Der Standardwert ist 4. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:colors:get"><apiName>colors</apiName><shortdesc>
	Ein Array mit den im Farbverlauf zu verwendenden RGB-Hexadezimalfarbwerten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>colors</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("colorsExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0x000000, 0xCCCCCC, 0xFFFFFF];
		arr[0].colors = colors;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		arr[0].colors = colors;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ein Array von hexadezimalen RGB-Farbwerten.
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Ein Array mit den im Farbverlauf zu verwendenden RGB-Hexadezimalfarbwerten. Rot beispielsweise hat den Wert 0xFF0000, Blau den Wert 0x0000FF usw.
	
	<p>Die <codeph>colors</codeph>-Eigenschaft kann nicht direkt durch Bearbeiten der entsprechenden Werte geändert werden. Sie müssen vielmehr einen Verweis auf <codeph>colors</codeph> erstellen, dort die Änderungen vornehmen und dann <codeph>colors</codeph> auf den Verweis setzen.</p>
	
	<p>Die Eigenschaften <codeph>colors</codeph>, <codeph>alphas</codeph> und <codeph>ratios</codeph> stehen miteinander in Zusammenhang. Das erste Element im <codeph>colors</codeph>-Array entspricht dem jeweils ersten Element im <codeph>alphas</codeph>- und im <codeph>ratios</codeph>-Array usw.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Der Offset-Abstand.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>distance</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("distanceExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].distance = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Offset-Abstand. Die zulässigen Werte liegen zwischen 0 und 8. Der Standardwert ist 4.0.
	
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>knockout</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("knockoutExample");
	mc.onRelease = function() {
	var arr:Array = this.filters;
		arr[0].knockout = true;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde. Mit einem Aussparungseffekt wird eine transparente Füllung des Objekts definiert, die Hintergrundfarbe des Dokuments wird sichtbar. Der Wert <codeph>true</codeph> gibt an, dass ein Aussparungseffekt angewendet werden soll. Der Standardwert lautet <codeph>false</codeph> (kein Aussparungseffekt).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Gibt an, wie oft der Filter angewendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>quality</code> property on an existing
	object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("qualityExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].quality = 1; // low quality
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, wie oft der Filter angewendet werden soll. Der Standardwert lautet <codeph>BitmapFilterQuality.LOW</codeph>, was einer einmaligen Anwendung des Filters entspricht. Mit dem Wert <codeph>BitmapFilterQuality.MEDIUM</codeph> wird der Filter zweimal angewendet und mit dem Wert <codeph>BitmapFilterQuality.HIGH</codeph> dreimal. Filter mit niedrigen Werten werden schneller dargestellt.
	
	<p>Bei den meisten Anwendungen genügt die Angabe der niedrigen, mittleren oder hohen Qualität für <codeph>quality</codeph>. Sie können zwar Werte bis 15 angeben, um unterschiedliche Effekte zu erzielen, höhere Werte führen jedoch auch zu einer langsameren Darstellung. Anstatt also den Wert von <codeph>quality</codeph> zu erhöhen, können Sie einen ähnlichen Effekt mit gleichzeitig schnellerer Darstellung erzielen, indem Sie einfach die Eigenschaftswerte von <codeph>blurX</codeph> und <codeph>blurY</codeph> erhöhen.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	Ein Array mit Farbverteilungsverhältnissen für die entsprechenden Farben im colors-Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>ratios</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("ratiosExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [127, 128, 129];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [0, 128, 255];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Das Array ist leer, wenn gesetzt.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Ein Array mit Farbverteilungsverhältnissen für die entsprechenden Farben im <codeph>colors</codeph>-Array. Die zulässigen Werte der einzelnen Elemente des Arrays liegen zwischen 0 und 255.
	
	<p>Die <codeph>ratios</codeph>-Eigenschaft kann nicht unmittelbar durch Bearbeitung ihrer Werte geändert werden. Sie müssen vielmehr einen Verweis auf <codeph>ratios</codeph> erstellen, dort die Änderungen vornehmen und dann <codeph>ratios</codeph> auf den Verweis setzen.</p>
	
	<p> Die Eigenschaften <codeph>colors</codeph>, <codeph>alphas</codeph> und <codeph>ratios</codeph> stehen miteinander in Zusammenhang. Das erste Element im <codeph>colors</codeph>-Array entspricht dem jeweils ersten Element im <codeph>alphas</codeph>- und im <codeph>ratios</codeph>-Array usw.</p>
	
	<p> Um zu verstehen, wie die Farben in einem Abschrägungsfilter mit Farbverlauf verteilt werden, wählen Sie zunächst die Farben aus, die Sie für den Effekt verwenden möchten. Beachten Sie, dass eine einfacher Abschrägungsfilter eine Glanzlicht- und eine Schattenfarbe definiert, während bei einem Abschrägungsfilter mit Farbverlauf für die Glanzlichtfarbe und den Schatten je ein Farbverlauf festgelegt werden. Es wird davon ausgegangen, dass das Glanzlicht in der oberen linken Ecke und der Schatten in der rechten unteren Ecke angezeigt wird. Daraus ergibt sich eine mögliche Verwendung des Filters mit je vier Farben im Glanzlicht- und im Schattenbereich. Zusätzlich zum Glanzlicht und dem Schatten wird bei diesem Filter eine Basisfüllung verwendet, die an den Kanten zwischen Glanzlicht und Schatten angezeigt wird. Aus diesem Grund handelt es sich um insgesamt neun Farben und damit auch um neun Elemente im ratios-Array.</p>
	
	<p> Wenn man nun einen solchen Farbverlauf als Abfolge von Bändern unterschiedlicher in einander verlaufender Farben ansieht, gibt jeder „ratio“-Wert die Position der entsprechenden Farbe als Radius des Farbverlaufs an, wobei 0 den äußersten Punkt und 255 den innersten Punkt des Farbverlaufs bezeichnet. Im Normalfall liegt der Mittelwert bei 128. Dies entspricht dem Wert der Basisfüllung. Um im Bild unten den Abschrägungseffekt zu erzielen, weisen Sie anhand des Beispiels mit den neun Farben folgende „ratio“-Werte zu:</p>
	
	<ul> 
	<li> Die ersten vier Farben liegen in einem Bereich zwischen 0 und 127. Der entsprechende Wert steigt jeweils an, sodass jeder Wert größer oder gleich dem vorherigen Wert ist. Dies ist die Kante der Abschrägung in Glanzlichtfarbe.</li>
	<li> Die fünfte (mittlere) Farbe ist die Basisfüllung und hat den Wert 128. Der Pixelwert 128 legt die Basisfüllung fest, die außerhalb der Form angezeigt wird (und die abgeflachten Kanten umgibt), wenn als Typ „outer“ festgelegt wurde. Wurde als Typ dagegen „inner“ angegeben, befindet sich die Basisfüllung innerhalb der Form und deckt praktisch die objekteigene Füllung ab.</li>
	<li> Die letzten vier Farben liegen im Bereich zwischen 129 und 255. Der entsprechende Wert steigt jeweils an, sodass jeder Wert größer oder gleich dem vorherigen Wert ist. Dies ist die Kante der Abschrägung in Schattenfarbe.</li>
	</ul>
	
	<p> Wenn Sie an jeder Kante eine gleichmäßige Verteilung der Farbe erzielen möchten, müssen Sie eine ungerade Anzahl Farben angeben. Dabei definiert die mittlere Farbe die Basisfüllung. Verteilen Sie die Werte zwischen 0 und 127 oder zwischen 129 und 255 gleichmäßig auf die Farben, und ändern Sie dann die Werte, um die Breite der einzelnen Farbbänder im Farbverlauf anzupassen. Bei einem Farbverlauf mit neun Farben lautet ein Array möglicherweise [16, 32, 64, 96, 128, 160, 192, 224, 235]. Im folgenden Bild sind der Farbverlauf und die Abschrägung wie beschrieben dargestellt:</p>
	
	<p><adobeimage alt="Abschrägung mit einem 9-farbigen Verlauf" href="../../images/gradientBevelRainbow.jpg"/></p>
	
	<p>Beachten Sie hierbei, dass die Farben im Farbverlauf anhand der Werte der Eigenschaften <codeph>blurX</codeph>, <codeph>blurY</codeph>, <codeph>strength</codeph> und <codeph>quality</codeph> sowie der <codeph>ratios</codeph>-Werte verteilt werden.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Die Stärke des Abdrucks oder Auftragens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>strength</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("strengthExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].strength = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen der Abschrägung und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255. Der Wert 0 bedeutet, dass der Filter nicht angewendet wird. Der Standardwert ist 1.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:type:get"><apiName>type</apiName><shortdesc>
	Die Platzierung des Abschrägungsffekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>type</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("typeExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].type = "outer";
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Die Platzierung des Abschrägungsffekts. Zulässige Werte sind die BitmapFilterType-Konstanten:
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> – Abschrägung an der Außenkante des Objekts</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – Abschrägung an der Innenkante des Objekts</li>
	<li><codeph>BitmapFilterType.FULL</codeph> – Abschrägungt auf der Oberseite des Objekts</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
 Mit der GlowFilter-Klasse können Sie einen Glühen-Effekt auf Anzeigeobjekte anwenden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Ermöglicht das Hinzufügen eines Glühen-Effekts.
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der GlowFilter-Klasse können Sie einen Glühen-Effekt auf Anzeigeobjekte anwenden. Sie haben verschiedene Möglichkeiten für den beim Glühen verwendeten Stil, z. B. inneres oder äußeres Glühen oder den Aussparungsmodus. Der Glühen-Filter ähnelt einem Schlagschatten-Filter, dessen Eigenschaften <codeph>distance</codeph> und <codeph>angle</codeph> auf 0 (null) gesetzt sind. Sie können den Filter auf jedes Anzeigeobjekt anwenden (d. h. Objekte, die von der DisplayObject-Klasse erben), z. B. auf MovieClip-, SimpleButton-, TextField-, Video- sowie BitmapData-Objekte.
 
 <p>Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
 <ul><li>Um Filter auf Anzeigeobjekte anzuwenden, verwenden Sie die <codeph>filters</codeph>-Eigenschaft (von DisplayObject übernommen). Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen. </li>
 
 <li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
 </ul>
 
 
 <p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird die <codeph>cacheAsBitmap</codeph>-Eigenschaft des Anzeigeobjekts auf <codeph>true</codeph> gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>

 <p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden dagegen nicht unterstützt. Wenn das Objekt selbst skaliert wird (also die Eigenschaften <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 1,0 sind), wird der Filtereffekt nicht skaliert. Er wird nur dann skaliert, wenn die Bühne vergrößert dargestellt wird.</p>
 
 <p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>
 
 </apiDesc><example conref="examples\GlowFilterExample.as"> Im folgenden Beispiel wird ein Quadrat gezeichnet, auf das ein Weichzeichnen-Filter angewendet wird. Der allgemeine Workflow dieses Beispiels lautet wie folgt:
 <ol>
  <li>Importieren Sie die erforderlichen Klassen.</li>
  <li>Deklarieren Sie drei Eigenschaften für die <codeph>draw()</codeph>-Methode. Diese Methode verwendet Methoden der Graphics-Klasse, auf die über die Eigenschaft <codeph>graphics</codeph> der Sprite-Klasse zugegriffen wird, um ein orangefarbenes Quadrat zu zeichnen.</li>
  <li>Erstellen Sie die Konstruktorfunktion, die Folgendes bewirkt:
      <ul>
          <li>Ruft die <codeph>draw</codeph>-Methode auf.</li> 
          <li>Erstellt ein neues BitmapFilter-Objekt mit dem Namen <codeph>filter</codeph> und weist ihm den Wert zu, der sich aus dem Aufruf von <codeph>getBitmapFilter()</codeph> ergibt, mit dem der Filter definiert wird.</li>
          <li>Erstellt ein neues Array mit dem Namen <codeph>myFilters</codeph> und fügt <codeph>filter</codeph> hinzu. </li>
          <li>Weist <codeph>myFilters</codeph> der <codeph>filters</codeph>-Eigenschaft des BevelFilterExample-Objekts zu. Dadurch werden alle in <codeph>myFilters</codeph> vorgefundenen Filter angewendet; in diesem Fall nur <codeph>filter</codeph>.</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.GlowFilter;

    public class GlowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function GlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x33CCFF;
            var alpha:Number = 0.8;
            var blurX:Number = 35;
            var blurY:Number = 35;
            var strength:Number = 2;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;

            return new GlowFilter(color,
                                  alpha,
                                  blurX,
                                  blurY,
                                  strength,
                                  quality,
                                  inner,
                                  knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/scaleX"><linktext>flash.display.DisplayObject.scaleX</linktext></link><link href="flash.display.xml#DisplayObject/scaleY"><linktext>flash.display.DisplayObject.scaleY</linktext></link><link href="flash.filters.xml#DropShadowFilter/distance"><linktext>flash.filters.DropShadowFilter.distance</linktext></link><link href="flash.filters.xml#DropShadowFilter/angle"><linktext>flash.filters.DropShadowFilter.angle</linktext></link></related-links><apiConstructor id="flash.filters:GlowFilter:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
	Initialisiert eine neue GlowFilter-Instanz mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example instantiates a new GlowFilter instance and applies
	it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	
	var color:Number = 0x33CCFF;
	var alpha:Number = .8;
	var blurX:Number = 35;
	var blurY:Number = 35;
	var strength:Number = 2;
	var quality:Number = 3;
	var inner:Boolean = false;
	var knockout:Boolean = false;
	
	var filter:GlowFilter = new GlowFilter(color, 
										 alpha, 
										 blurX, 
										 blurY, 
										 strength, 
										 quality, 
										 inner, 
										 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFF0000</apiData><apiDesc>Die Farbe des Glühen-Effekts im hexadezimalen Format 0x<i>RRGGBB</i>. Der Standardwert lautet 0xFF0000.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Alphatransparenzwert der Farbe. Die zulässigen Werte liegen zwischen 0 und 1. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt.
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255 (Gleitkomma). Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255 (Gleitkomma). Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>2</apiData><apiDesc>Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen dem Glühen und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255. 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Gibt an, wie oft der Filter angewendet werden soll. Verwenden Sie die BitmapFilterQuality-Konstanten:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Weitere Informationen finden Sie in der Beschreibung der <codeph>quality</codeph>-Eigenschaft.</p>
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob es sich um ein inneres Glühen handelt. Der Wert <codeph>true</codeph> gibt ein inneres Glühen an. Der Wert <codeph>false</codeph> gibt ein äußeres Glühen an, d. h. ein Glühen um die äußeren Ränder des Objekts. 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde. Mit <codeph>true</codeph> wird eine transparente Füllung des Objekts definiert, die Hintergrundfarbe des Dokuments wird sichtbar. 
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialisiert eine neue GlowFilter-Instanz mit den angegebenen Parametern.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GlowFilter/quality"><linktext>GlowFilter.quality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GlowFilter:clone"><apiName>clone</apiName><shortdesc>
	Gibt eine Kopie dieses Filterobjekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GlowFilter objects and compares them: <code>filter_1</code>
	is created by using the GlowFilter constructor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> strength: 2
		// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> strength: 2
	// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Eine neue GlowFilter-Instanz mit allen Eigenschaften der ursprünglichen GlowFilter-Instanz.
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Gibt eine Kopie dieses Filterobjekts zurück.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GlowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Der Alphatransparenzwert der Farbe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterAlpha");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Alphatransparenzwert der Farbe. Die zulässigen Werte liegen zwischen 0 und 1. Mit dem Wert 0,25 wird beispielsweise ein Transparenzwert von 25 % festgelegt. Der Standardwert ist 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Der Grad der horizontalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurX");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurX = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der horizontalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255 (Gleitkomma). Der Standardwert ist 6. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Der Grad der vertikalen Weichzeichnung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurY");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurY = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Der Grad der vertikalen Weichzeichnung. Die zulässigen Werte liegen zwischen 0 und 255 (Gleitkomma). Der Standardwert ist 6. Zweierpotenzen (z. B. 2, 4, 8, 16 und 32) sind optimiert und ergeben eine schnellere Anzeige als andere Werte.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:color:get"><apiName>color</apiName><shortdesc>
	Die Farbe des Glühen-Effekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterColor");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.color = 0x00FF33;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Die Farbe des Glühen-Effekts. Die zulässigen Werte werden im Hexadezimalformat 0x<i>RRGGBB</i> angegeben. Der Standardwert lautet 0xFF0000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	Gibt an, ob es sich um ein inneres Glühen handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterInner");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob es sich um ein inneres Glühen handelt. Der Wert <codeph>true</codeph> gibt ein inneres Glühen an. Der Standardwert lautet <codeph>false</codeph>, gibt also ein äußeres Glühen an, d. h. ein Glühen um die äußeren Ränder des Objekts. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterKnockout");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, ob für das Objekt ein Aussparungseffekt definiert wurde. Mit <codeph>true</codeph> wird eine transparente Füllung des Objekts definiert, die Hintergrundfarbe des Dokuments wird sichtbar. Der Standardwert lautet <codeph>false</codeph> (keine Aussparung).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Gibt an, wie oft der Filter angewendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterQuality");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Gibt an, wie oft der Filter angewendet werden soll. Der Standardwert lautet <codeph>BitmapFilterQuality.LOW</codeph>, was einer einmaligen Anwendung des Filters entspricht. Mit dem Wert <codeph>BitmapFilterQuality.MEDIUM</codeph> wird der Filter zweimal angewendet und mit dem Wert <codeph>BitmapFilterQuality.HIGH</codeph> dreimal. Filter mit niedrigen Werten werden schneller dargestellt.
	
	<p>Bei den meisten Anwendungen genügt die Angabe der niedrigen, mittleren oder hohen Qualität für <codeph>quality</codeph>. Sie können zwar Werte bis 15 angeben, um unterschiedliche Effekte zu erzielen, höhere Werte führen jedoch auch zu einer langsameren Darstellung. Anstatt also den Wert von <codeph>quality</codeph> zu erhöhen, können Sie einen ähnlichen Effekt mit gleichzeitig schnellerer Darstellung erzielen, indem Sie einfach die Eigenschaftswerte von <codeph>blurX</codeph> und <codeph>blurY</codeph> erhöhen.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Die Stärke des Abdrucks oder Auftragens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterStrength");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.strength = .8;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Die Stärke des Abdrucks oder Auftragens. Je höher der Wert, desto mehr Farbe wird aufgetragen und desto stärker ist der Kontrast zwischen dem Glühen und dem Hintergrund. Die zulässigen Werte liegen zwischen 0 und 255. Der Standardwert ist 2.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
	 Die ShaderFilter-Klasse wendet einen Filter an, indem Sie einen Shader auf ein gefiltertes Objekt ausführt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die ShaderFilter-Klasse wendet einen Filter an, indem Sie einen Shader auf ein gefiltertes Objekt ausführt. Das gefilterte Objekt wird als Eingabe für den Shader verwendet und die Shaderausgabe wird zum Filterergebnis.
	 
	 <p>Verwenden Sie zum Erstellen eines neuen Filters den <codeph>newShaderFilter()</codeph>-Konstruktor. Die Verwendung von Filtern hängt davon ab, auf welches Objekt sie jeweils angewendet werden:</p>
	 
	 <ul>
	   <li>Um Filter auf Movieclips, Textfelder, Schaltflächen und Videosequenzen anzuwenden, verwenden Sie die Eigenschaft <codeph>filters</codeph> (von DisplayObject übernommen). Durch die Einstellung der <codeph>filters</codeph>-Eigenschaft wird das betroffene Objekt selbst nicht verändert, und Sie können den Filter wieder entfernen, indem Sie die <codeph>filters</codeph>-Eigenschaft löschen.</li>
	   <li>Um Filter auf BitmapData-Objekte anzuwenden, verwenden Sie die <codeph>BitmapData.applyFilter()</codeph>-Methode. Durch den Aufruf von <codeph>applyFilter()</codeph> bei einem BitmapData-Objekt wird das gefilterte Bild aus dem BitmapData-Quellobjekt und dem Filterobjekt generiert.</li>
	 </ul>
	 
	 <p>Wenn Sie einen Filter auf ein Anzeigeobjekt anwenden, wird der Wert der <codeph>cacheAsBitmap</codeph>-Eigenschaft des Objekts auf true gesetzt. Wenn Sie alle Filter entfernen, wird der ursprüngliche Wert von <codeph>cacheAsBitmap</codeph> wiederhergestellt.</p>
	 
	 <p>Dieser Filter unterstützt Bühnenskalierung. Allgemeine Skalierung, Drehung und Neigung werden dagegen nicht unterstützt. Wenn das Objekt selbst skaliert wird (also die Eigenschaften <codeph>scaleX</codeph> und <codeph>scaleY</codeph> ungleich 100 % sind), wird der Filter nicht skaliert. Er wird nur skaliert, wenn die Bühne vergrößert dargestellt wird.</p>
	 
	 <p>Ein Filter wird nicht angewendet, wenn das Ergebnisbild die maximalen Abmessungen überschreitet. In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite 8.191 Pixel; die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein Bild also 8.191 Pixel breit ist, darf es nur 2.048 Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880 Pixel Höhe und Breite. Wenn Sie beispielsweise einen großen Movieclip mit aktiviertem Filter vergrößert darstellen, wird der Filter deaktiviert, sobald das Ergebnisbild die maximalen Abmessungen überschreitet.</p>
	 
	 <p>Um die Shader-Instanz festzulegen, die mit dem Filter verwendet werden soll, übergeben Sie die Shader-Instanz als Argument an den <codeph>ShaderFilter()</codeph>-Konstruktor oder setzen Sie sie als Wert der <codeph>shader</codeph>-Eigenschaft.</p>
	 
	 <p>Damit sich die Shaderausgabe über die Grenzen des gefilterten Objekts erstrecken kann, verwenden Sie die Eigenschaften <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> und <codeph>bottomExtension</codeph>.</p>
	 
	 </apiDesc><example conref="examples\ShaderFilterExample.1.as"> Im folgenden Beispiel wird ein Shader geladen und als <codeph>shader</codeph>-Eigenschaft eines ShaderFilters verwendet. Der Code zeichnet einen Kreis in einer Sprite-Instanz und fügt sie der Bühne hinzu. Beim Laden des Shaders wird der Shaderfilter auf das Sprite angewendet.
 
 <p>Beachten Sie, dass im Beispiel davon ausgegangen wird, dass im selben Ordner wie dem Ausgabeordner der Anwendung eine Shaderbytecodedatei namens „gradient.pbj“ vorhanden ist.</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel RedGradientFilter
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "Applies a gradient across the red channel of the input image.";
>
{
    input image4 src;
    output pixel4 dst;
    
    parameter float width
    &lt;
        description: "The width of the image to which the shader is applied.";
        minValue: 0.0;
    >;

    void evaluatePixel()
    {
        pixel4 temp = sampleNearest(src, outCoord());
        temp.r = 1.0 - (outCoord().x * (1.0 / width));
        dst = temp;
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.filters.ShaderFilter;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderFilterExample extends Sprite {
        
        private var loader:URLLoader;
        private var s:Sprite;
        
        public function ShaderFilterExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("gradient.pbj"));
            
            s = new Sprite();
            s.graphics.beginFill(0x009900);
            s.graphics.drawCircle(100, 100, 100);
            addChild(s);
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader(loader.data);
            shader.data.width.value = [s.width];
            
            var gradientFilter:ShaderFilter = new ShaderFilter(shader);
            s.filters = [gradientFilter];
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links><apiConstructor id="flash.filters:ShaderFilter:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
		 Erstellt einen neuen Shaderfilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Der für diesen Filter zu verwendende Shader. Weitere Informationen und Einschränkungen zum Shader finden Sie in der Beschreibung der <codeph>shader</codeph>-Eigenschaft.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Erstellt einen neuen Shaderfilter.
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#ShaderFilter/shader"><linktext>shader</linktext></link></related-links></apiConstructor><apiValue id="flash.filters:ShaderFilter:bottomExtension:get"><apiName>bottomExtension</apiName><shortdesc>
		 Die Erweiterung an der unteren Seite des Zielobjekts in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Die Erweiterung an der unteren Seite des Zielobjekts in Pixel.
		 
		 <p>Die Erweiterung ist der Bereich außerhalb der Grenzen des Zielobjekts, das während der Ausführung an den Shader übergeben wird. Bei der Ausführung berechnet Flash Player oder AIR die normalen Grenzen eines Movieclips und erweitert sie auf Basis der Werte <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> und <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:leftExtension:get"><apiName>leftExtension</apiName><shortdesc>
		 Die Erweiterung an der linken Seite des Zielobjekts in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Die Erweiterung an der linken Seite des Zielobjekts in Pixel.
		 
		 <p>Die Erweiterung ist der Bereich außerhalb der Grenzen des Zielobjekts, das während der Ausführung an den Shader übergeben wird. Bei der Ausführung berechnet Flash Player oder AIR die normalen Grenzen eines Movieclips und erweitert sie auf Basis der Werte <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> und <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:rightExtension:get"><apiName>rightExtension</apiName><shortdesc>
		 Die Erweiterung an der rechten Seite des Zielobjekts in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Die Erweiterung an der rechten Seite des Zielobjekts in Pixel.
		 
		 <p>Die Erweiterung ist der Bereich außerhalb der Grenzen des Zielobjekts, das während der Ausführung an den Shader übergeben wird. Bei der Ausführung berechnet Flash Player oder AIR die normalen Grenzen eines Movieclips und erweitert sie auf Basis der Werte <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> und <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:shader:get"><apiName>shader</apiName><shortdesc>
		 Der für diesen Filter zu verwendende Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 Der für diesen Filter zu verwendende Shader.
		 
		 <p>Der Shader, der der <codeph>shader</codeph>-Eigenschaft zugewiesen ist, muss mindestens zwei <codeph>image4</codeph>-Eingaben festlegen. Die Eingabe muss <b>nicht</b> im Code über die <codeph>input</codeph>-Eigenschaft des verknüpften ShaderInput-Objekts festgelegt werden. Stattdessen wird das Objekt, auf das der Filter angewendet wird, automatisch als erste Eingabe verwendet (die Eingabe mit <codeph>index</codeph> = 0). Ein als Filter verwendeter Shader kann mehr als eine Eingabe festlegen. Diese zusätzlichen Eingaben werden durch das Setzen der <codeph>input</codeph>-Eigenschaft der ShaderInput-Instanz festgelegt.</p>
		 
		 <p>Wenn Sie dieser Eigenschaft eine Shader-Instanz zuweisen, wird der Shader intern kopiert und der Zeichenfüllvorgang verwendet anstatt eines Verweises auf den ursprünglichen Shader die interne Kopie. Änderungen am Shader, beispielsweise die Änderung eines Parameterwerts, einer Eingabe oder des Bytecodes, werden nicht auf die Shaderkopie angewendet, die für den Filter verwendet wird. Damit die Änderungen des Shaders bei der Filterausgabe berücksichtigt werden, müssen Sie der <codeph>shader</codeph>-Eigenschaft die Shader-Instanz erneut zuweisen. Wie bei allen Filtern müssen Sie der <codeph>filters</codeph>-Eigenschaft des Anzeigeobjekts auch die ShaderFilter-Instanz erneut zuweisen, damit die Filteränderungen angewendet werden.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:topExtension:get"><apiName>topExtension</apiName><shortdesc>
		 Die Erweiterung an der oberen Seite des Zielobjekts in Pixeln.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Die Erweiterung an der oberen Seite des Zielobjekts in Pixeln.
		 
		 <p>Die Erweiterung ist der Bereich außerhalb der Grenzen des Zielobjekts, das während der Ausführung an den Shader übergeben wird. Bei der Ausführung berechnet Flash Player oder AIR die normalen Grenzen eines Movieclips und erweitert sie auf Basis der Werte <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> und <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>