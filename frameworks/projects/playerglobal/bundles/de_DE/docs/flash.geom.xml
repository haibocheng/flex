<?xml version="1.0"?>
<apiPackage id="flash.geom"><apiName>flash.geom</apiName><apiDetail/><apiClassifier id="flash.geom:Utils3D"><apiName>Utils3D</apiName><shortdesc> 
 Die Utils3D-Klasse enthält statische Methoden, die die Implementierung bestimmter dreidimensionaler Matrixvorgänge vereinfachen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Eine Dienstklasse mit statischen Methoden, die die Implementierung bestimmter dreidimensionaler Matrixvorgänge vereinfachen. 
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Die Utils3D-Klasse enthält statische Methoden, die die Implementierung bestimmter dreidimensionaler Matrixvorgänge vereinfachen.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiOperation id="flash.geom:Utils3D:pointTowards"><apiName>pointTowards</apiName><shortdesc>
    Interpoliert die Ausrichtung eines Objekts gegenüber einer Position.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine geänderte Version des Matrix3D-Objekts, wie im zweiten Parameter angegeben. Um ein Anzeigeobjekt mithilfe der <codeph>pointTowards()</codeph>-Methode zu transformieren, setzen Sie die Matrix3D-Eigenschaft des Anzeigeobjekts auf das zurückgegebene Matrix3D-Objekt.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl zwischen 0 und 1, die das Objekt inkrementell in Richtung Ziel dreht.
    
    </apiDesc></apiParam><apiParam><apiItemName>mat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Die Matrix3D-Eigenschaft des Objekts, das transformiert wird. 
    
    </apiDesc></apiParam><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Die auf die Welt bezogene Position des Zielobjekts. „Auf die Welt bezogen“·bezeichnet die Transformation des Objekts relativ zum Raum der Welt und den Koordinaten, die angeben wo die Objekte dort platziert sind.  
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Der objektbezogene Vektor, der festlegt, in welche Richtung das Anzeigeobjekt weist. „Objektbezogen“ bezeichnet die Transformation des Objekts relativ zum Objektraum, dem eigenen Bezugsrahmen des Objekts mit seinem eigenen Koordinatensystem. Der Standardwert ist (0,0,-1).
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Der objektbezogene Vektor, der die Aufwärtsrichtung des Anzeigeobjekts definiert. Wenn das Objekt so gezeichnet ist, dass es von oben nach unten zeigt, dann ist die <i>+z</i>-Achse der nach oben zeigende Vektor. „Objektbezogen“ bezeichnet die Transformation des Objekts relativ zum Objektraum, dem eigenen Bezugsrahmen des Objekts mit seinem eigenen Koordinatensystem. Der Standardwert ist (0,-1,0).
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Interpoliert die Ausrichtung eines Objekts gegenüber einer Position. Die <codeph>pointTowards()</codeph>-Methode kombiniert die Funktionen der <codeph>Matrix3D.pointAt()</codeph>- und der <codeph>Matrix3D.interpolateTo()</codeph>-Methode.  
    
    <p>Die <codeph>pointTowards()</codeph>-Methode ermöglicht die direkte Änderung der Ausrichtung. Sie zerlegt die Matrix3D des Anzeigeobjekts und ersetzt die Drehungselemente durch Elemente, die eine prozentweise Drehung in Richtung der Zielposition bewirken. Das Objekt kann sich inkrementell in Richtung Ziel drehen, während es sich weiterhin in seine eigene Richtung bewegt. Aufeinanderfolgende Aufrufe der <codeph>pointTowards()</codeph>-Methode gefolgt von einer Versetzungsmethode ermöglichen eine Animation, bei der ein Objekt einem sich bewegenden Ziel folgt. Versetzen Sie das Objekt zuerst einen Prozentpunkt in Richtung Ziel und bewegen Sie es dann inkrementell entlang der Achse.</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/pointAt()"><linktext>flash.geom.Matrix3D.pointAt()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>flash.geom.Matrix3D.interpolateTo()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>flash.geom.Matrix3D.interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVector"><apiName>projectVector</apiName><shortdesc>
    Mithilfe eines Matrix3D-Projektionsobjekts wird ein Vector3D-Objekt von einer Raumkoordinate auf eine andere projiziert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Ein neues Vector3D-Objekt mit einer transformierten Raumkoordinate.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Ein Matrix3D-Projektionsobjekt, das die Projektionstransformation implementiert. Wenn ein Anzeigeobjekt über ein PerspectiveProjection-Objekt verfügt, können Sie die <codeph>perspectiveProjection.toMatrix()</codeph>-Methode verwenden, um ein Matrix3D-Projektionsobjekt zu erstellen, das auf die untergeordneten Objekte des Anzeigeobjekts angewendet wird. Für komplexere Projektionen verwenden Sie die <codeph>matrix3D.rawData</codeph>-Eigenschaft zur Erstellung einer benutzerdefinierten Projektionsmatrix. Es gibt keine integrierte Matrix3D-Methode zur Erstellung eines Matrix3D-Projektionsobjekts.
    
    </apiDesc></apiParam><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das Vector3D-Objekt, das auf eine neue Raumkoordinate projiziert wird.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Mithilfe eines Matrix3D-Projektionsobjekts wird ein Vector3D-Objekt von einer Raumkoordinate an eine andere projiziert. Die <codeph>projectVector()</codeph>-Methode funktioniert wie die <codeph>Matrix3D.transformVector()</codeph>-Methode, mit dem Unterschied, dass die <codeph>projectVector()</codeph>-Methode das <i>x</i>-, <i>y</i>- und <i>z</i>-Element des ursprünglichen Vector3D-Objekts durch den Projektionstiefenwert dividiert. Der Tiefenwert ist die Entfernung zwischen Auge und Vector3D-Objekt im Anzeige- oder Sichtraum. Der Standardwert dieser Entfernung ist der Wert des <i>z</i>-Elements.
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>flash.geom.Matrix3D.transformVector()</linktext></link><link href="flash.geom.xml#Utils3D/projectVectors()"><linktext>projectVectors()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVectors"><apiName>projectVectors</apiName><shortdesc>
    Mithilfe eines Matrix3D-Objekts wird ein Vektor dreidimensionaler Raumkoordinaten („verts“) auf einen Vektor zweidimensionaler Raumkoordinaten („projectedVerts“) projiziert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Ein Matrix3D-Projektionsobjekt, das die Projektionstransformation implementiert. Sie können ein Matrix3D-Projektionsobjekt mithilfe der <codeph>Matrix3D.rawData</codeph>-Eigenschaft erstellen.
    </apiDesc></apiParam><apiParam><apiItemName>verts</apiItemName><apiType value="Vector$Number"/><apiDesc>Ein Zahlenvektor, bei dem jeweils 3 Zahlen die <i>x</i>-, <i>y</i>- und <i>z</i>-Koordinaten eines dreidimensionalen Raums darstellen, beispielsweise <codeph>Vector3D(x,y,z)</codeph>. 
    
    </apiDesc></apiParam><apiParam><apiItemName>projectedVerts</apiItemName><apiType value="Vector$Number"/><apiDesc>Ein Zahlenvektor, bei dem jeweils zwei Zahlen eine projizierte zweidimensionale Koordinate darstellen, beispielsweise <codeph>Point(x,y)</codeph>. Sie sollten den Vektor vorab zuweisen. Die <codeph>projectVectors()</codeph>-Methode füllt die Werte für jeden projizierten Punkt aus.
    
    </apiDesc></apiParam><apiParam><apiItemName>uvts</apiItemName><apiType value="Vector$Number"/><apiDesc>Ein Zahlenvektor, bei dem jeweils drei Zahlen die <i>u</i>-, <i>v</i>- und <i>t</i>-Elemente der <codeph>uvt</codeph>-Daten darstellen. Die Elemente <i>u</i>- und <i>v</i> stellen die Texturkoordinate für jeden projizierten Punkt dar. Der <i>t</i>-Wert ist der Projektionstiefenwert, die Entfernung zwischen Auge und Vector3D-Objekt im Anzeige- oder Sichtraum. Sie sollten den Vektor vorab zuweisen und den <i>u</i>- und <i>v</i>-Wert festlegen. Die <codeph>projectVectors()</codeph>-Methode füllt den <i>t</i>-Wert für jeden projizierten Punkt aus.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Projiziert einen Vektor dreidimensionaler Raumkoordinaten auf einen Vektor zweidimensionaler Raumkoordinaten.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Mithilfe eines Matrix3D-Objekts wird ein Vektor dreidimensionaler Raumkoordinaten (<i>verts</i>) auf einen Vektor zweidimensionaler Raumkoordinaten (<codeph>projectedVerts</codeph>) projiziert. Das projizierte Vector-Objekt sollte zugewiesen werden, bevor es als Parameter verwendet wird. 
    
    <p>Die <codeph>projectVectors()</codeph>-Methode setzt auch den <i>t</i>-Wert der <i>uvt</i>-Daten. Sie sollten vorab einen Vektor zuweisen, der die <i>uvts</i>-Daten für jeden Koordinatensatz des projizierten Vektors enthält. Legen Sie auch den <i>u</i>- und <i>v</i>-Wert der <i>uvt</i>-Daten fest. Die <i>uvt</i>-Daten sind ein Vektor normalisierter Koordinaten, die für Texturmapping verwendet werden. Die UV-Koordinaten (0,0) entsprechen dem linken oberen Bereich der Bitmap, während (1,1) dem rechten unteren Bereich entspricht.</p>
    
    <p>Diese Methode kann gemeinsam mit der <codeph>Graphics.drawTriangles()</codeph>-Methode und der <codeph>GraphicsTrianglePath</codeph>-Klasse verwendet werden.</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D/projectVector()"><linktext>projectVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.geom:Vector3D"><apiName>Vector3D</apiName><shortdesc> 
 Die Vector3D-Klasse stellt einen Punkt oder eine Position im dreidimensionalen Raum unter Verwendung der kartesischen Koordinaten x, y und z dar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Die Vector3D-Klasse stellt einen Punkt oder eine Position im dreidimensionalen Raum unter Verwendung der kartesischen Koordinaten x, y und z dar. Wie in einem zweidimensionalen Raum stellt die <codeph>x</codeph>-Eigenschaft die horizontale und die <codeph>y</codeph>-Eigenschaft die vertikale Achse dar. Die <codeph>z</codeph>-Eigenschaft stellt im dreidimensionalen Raum die Tiefe dar. Der Wert der <codeph>x</codeph>-Eigenschaft erhöht sich, wenn sich das Objekt nach rechts bewegt. Der Wert der <codeph>y</codeph>-Eigenschaft erhöht sich, wenn sich das Objekt nach unten bewegt. Der Wert der <codeph>z</codeph>-Eigenschaft erhöht sich, wenn sich das Objekt vom Blickpunkt wegbewegt. Durch perspektivische Projektion und Skalierung erscheint das Objekt größer, wenn es näher, und kleiner, wenn es weiter vom Bildschirm entfernt ist. Wie bei einem rechtsseitigen dreidimensionalen Koordinatensystem zeigt die positive z-Achse vom Betrachter weg und der Wert der <codeph>z</codeph>-Eigenschaft erhöht sich, wenn sich das Objekt vom Auge des Betrachters wegbewegt. Der Ursprungspunkt (0,0,0) des globalen Raums ist die linke obere Ecke der Bühne. 
   
 <p><adobeimage alt="X, Y, Z-Achsen" href="../../images/xyzAxes.jpg"/></p>
 
 <p>Die Vector3D-Klasse kann auch eine Richtung darstellen, einen Pfeil, der vom Ursprung der Koordinaten, z. B. (0,0,0) zu einem Endpunkt zeigt, oder eine Gleitkommakomponente eines RGB (Rot, Grün, Blau)-Farbmodells.</p> 
 
 <p>Die Quaternionschreibweise führt ein viertes Element ein, die <codeph>w</codeph>-Eigenschaft, die zusätzliche Ausrichtungsinformationen bereitstellt. Die <codeph>w</codeph>-Eigenschaft kann beispielsweise einen Drehwinkel eines Vector3D-Objekts bestimmen. Die Kombination aus Drehwinkel und den Koordinaten x, y, und z bestimmt die Ausrichtung des Anzeigeobjekts. Hier sehen Sie eine Darstellung eines Vector3D-Elements in Matrixschreibweise:</p>
 
 <p><adobeimage alt="Vector3D-Elemente" href="../../images/Vector3Delements.jpg"/></p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiConstructor id="flash.geom:Vector3D:Vector3D"><apiName>Vector3D</apiName><shortdesc>
     Erstellt eine Instanz eines Vector3D-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Das erste Element, beispielsweise die x-Koordinate. 
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Das zweite Element, beispielsweise die y-Koordinate. 
     </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Das dritte Element, beispielsweise die z-Koordinate. 
     </apiDesc></apiParam><apiParam><apiItemName>w</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Ein optionales Element für zusätzliche Daten wie etwa den Drehwinkel. 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine Instanz eines Vector3D-Objekts. Wenn Sie keinen Parameter für den Konstruktor festlegen, wird ein Vector3D-Objekt mit den Elementen (0,0,0,0) erstellt.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Vector3D:add"><apiName>add</apiName><shortdesc>
    Addiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts zum Wert des x-, y- und z-Elements eines anderen Vector3D-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Vector3D-Objekt, das das Ergebnis der Addition des aktuellen Vector3D-Objekts zu einem anderen Vector3D-Objekt ist.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das Vector3D-Objekt, das zum aktuellen Vector3D-Objekt addiert wird.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Addiert das aktuelle Vector3D-Objekt zu einem anderen, sodass ein neues Vector3D-Objekt entsteht. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Addiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts zum Wert des x-, y- und z-Elements eines anderen Vector3D-Objekts. Die <codeph>add()</codeph>-Methode verändert das aktuelle Vector3D-Objekt nicht. Stattdessen gibt es ein neues Vector3D-Objekt mit den neuen Werten zurück.
    
    <p>Werden zwei Vektoren addiert, so ist das Ergebnis ein Ergebnisvektor. Die Visualisierung des Ergebnisses kann erfolgen, indem ein Vektor vom Ausgangs- oder Startpunkt des ersten Vektors zur Spitze bzw. zum Endpunkt des zweiten Vektors gezeichnet wird. Der Ergebnisvektor ist die Entfernung zwischen dem Ausgangspunkt des ersten und dem Endpunkt des zweiten Vektors.</p>   
    
    <p><adobeimage alt="Vector3D-Ergebnisvektor" href="../../images/resultantVector3D.jpg"/></p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/incrementBy()"><linktext>incrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:angleBetween"><apiName>angleBetween</apiName><shortdesc>
    Gibt den Wert im Bogenmaß (in Radiant) zwischen zwei Vektoren zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der Winkel zwischen zwei Vector3D-Objekten.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das erste Vector3D-Objekt.
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das zweite Vector3D-Objekt.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Gibt den Wert im Bogenmaß (in Radiant) zwischen zwei Vektoren zurück. Der zurückgegebene Winkel ist das kleinste Bogenmaß (in Radiant), um den das erste Vector3D-Objekt gedreht wird, bis es mit dem zweiten Vector3D-Objekt zusammenfällt. 
    
    <p>Die <codeph>angleBetween()</codeph>-Methode ist eine statische Methode. Sie können sie direkt als Methode der Vector3D-Klasse verwenden.</p>
    
    <p>Für die Umrechnung zwischen Grad und Radiant verwenden Sie die folgende Formel:</p> 
    
    <p><codeph>Radiant = Math.PI/180 ~~ Grad</codeph></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:clone"><apiName>clone</apiName><shortdesc>
    Gibt ein neues Vector3D-Objekt zurück, das eine genaue Kopie des aktuellen Vector3D-Objekts ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein neues Vector3D-Objekt, das eine Kopie des aktuellen Vector3D-Objekts ist.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Gibt ein neues Vector3D-Objekt zurück, das eine genaue Kopie des aktuellen Vector3D-Objekts ist.
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:crossProduct"><apiName>crossProduct</apiName><shortdesc>
    Gibt ein neues Vector3D-Objekt zurück, das senkrecht (im rechten Winkel) zum aktuellen und einem weiteren Vector3D-Objekt steht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein neues Vector3D-Objekt, das senkrecht (im rechten Winkel) zum aktuellen und dem als Parameter angegebenen Vector3D-Objekt steht.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Ein zweites Vector3D-Objekt. 
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Gibt ein neues Vector3D-Objekt zurück, das senkrecht (im rechten Winkel) zum aktuellen und einem weiteren Vector3D-Objekt steht. Wenn die Koordinaten des zurückgegebenen Vector3D-Objekts (0,0,0) sind, stehen die beiden Vector3D-Objekte im rechten Winkel zueinander.
    
    <p><adobeimage alt="Kreuzprodukt" href="../../images/crossproduct.jpg"/></p>
    
    <p>Sie können das normalisierte Kreuzprodukt zweier Scheitelpunkte einer Polygonoberfläche mit dem normalisierten Vektor des Kamera- oder Betrachterblickpunkts verwenden, um ein Punktprodukt zu erhalten. Der Wert des Punktprodukts gibt an, ob eine Oberfläche eines dreidimensionalen Objekts vom Blickpunkt aus verborgen ist.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/dotProduct()"><linktext>dotProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:decrementBy"><apiName>decrementBy</apiName><shortdesc>
    Dekrementiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts um den Wert des x-, y- und z-Elements des angegebenen Vector3D-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das Vector3D-Objekt, das die Werte enthält, die vom aktuellen Vector3D-Objekt subtrahiert werden.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Dekrementiert das aktuelle Vector3D-Objekt um ein anderes Vector3D-Objekt.  
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Dekrementiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts um den Wert des x-, y- und z-Elements des angegebenen Vector3D-Objekts. Anders als die <codeph>Vector3D.subtract()</codeph>-Methode ändert die <codeph>decrementBy()</codeph>-Methode das aktuelle Vector3D-Objekt und gibt kein neues Vector3D-Objekt zurück.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/subtract()"><linktext>subtract()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:distance"><apiName>distance</apiName><shortdesc>
    Gibt die Entfernung zwischen zwei Vector3D-Objekten zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Die Entfernung zwischen zwei Vector3D-Objekten.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Ein Vector3D-Objekt als erster dreidimensionaler Punkt. 
    </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Ein Vector3D-Objekt als zweiter dreidimensionaler Punkt.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Gibt die Entfernung zwischen zwei Vector3D-Objekten zurück. Die <codeph>distance()</codeph>-Methode ist eine statische Methode. Sie können sie direkt als Methode der Vector3D-Klasse verwenden, um den euklidischen Abstand zwischen zwei dreidimensionalen Punkten zu erhalten.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:dotProduct"><apiName>dotProduct</apiName><shortdesc>
    Wenn es sich beim aktuellen und bei dem als Parameter angegebenen Vector3D-Objekt um Einheitsscheitelpunkte handelt, gibt diese Methode den Kosinus des Winkels zwischen den beiden Scheitelpunkten zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Skalar, der das Punktprodukt des aktuellen Vector3D-Objekts und des angegebenen Vector3D-Objekts ist.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das zweite Vector3D-Objekt. 
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt das Punktprodukt des aktuellen Vector3D-Objekts und eines anderen Vector3D-Objekts zurück.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Wenn es sich beim aktuellen Vector3D-Objekt und bei dem als Parameter angegebenen um Einheitsscheitelpunkte handelt, gibt diese Methode den Kosinus des Winkels zwischen den beiden Scheitelpunkten zurück. Einheitsscheitelpunkte sind Scheitelpunkte, die in dieselbe Richtung zeigen, deren Länge jedoch eins ist. Sie entfernen die Länge des Vektors als Faktor im Ergebnis. Mit der <codeph>normalize()</codeph>-Methode können Sie einen Vektor in einen Einheitsvektor konvertieren. 
    
    <p>Die <codeph>dotProduct()</codeph>-Methode sucht den Winkel zwischen zwei Scheitelpunkten. Sie wird auch beim Backface Culling oder bei Beleuchtungsberechnungen verwendet. Backface Culling (Verdeckungsberechnung) ist ein Verfahren zur Bestimmung, welche Oberflächen vom Blickpunkt aus verborgen sind. Sie können die normalisierten Scheitelpunkte vom Blickpunkt (Kamera oder Auge) und das Kreuzprodukt der Scheitelpunkte einer Polygonoberfläche verwenden, um das Punktprodukt zu berechnen. Wenn das Punktprodukt kleiner als null ist, zeigt die Oberfläche zur Kamera bzw. zum Betrachter. Wenn die beiden Einheitsscheitelpunkte im rechten Winkel zueinander stehen, sind sie orthogonal und das Punktprodukt ist null. Wenn die beiden Scheitelpunkte parallel zueinander liegen, ist das Punktprodukt eins.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/crossProduct()"><linktext>crossProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:equals"><apiName>equals</apiName><shortdesc>
    Ermittelt, ob zwei Vector3D-Objekte gleich sind, indem das x-, y- und z-Element des aktuellen Vector3D-Objekts mit einem angegebenen Vector3D-Objekt verglichen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert lautet <codeph>true</codeph>, wenn das angegebene Vector3D-Objekt dem aktuellen entspricht; andernfalls ist er <codeph>false</codeph>.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das Vector3D-Objekt, das mit dem aktuellen Vector3D-Objekt verglichen wird.
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein optionaler Parameter, der festlegt, ob die <codeph>w</codeph>-Eigenschaft des Vector3D-Objekts im Vergleich verwendet wird.  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ermittelt, ob zwei Vector3D-Objekte gleich sind, indem das x-, y- und z-Element des aktuellen Vector3D-Objekts mit einem angegebenen Vector3D-Objekt verglichen werden. Wenn die Werte dieser Elemente gleich sind, sind die beiden Vector3D-Objekte gleich. Wenn der zweite optionale Parameter auf <codeph>true</codeph> eingestellt ist, werden alle vier Elemente des Vector3D-Objekts einschließlich der <codeph>w</codeph>-Eigenschaft verglichen. 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/nearEquals()"><linktext>nearEquals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:incrementBy"><apiName>incrementBy</apiName><shortdesc>
    Inkrementiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts um den Wert des x-, y- und z-Elements des angegebenen Vector3D-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das Vector3D-Objekt, das dem aktuellen Vector3D-Objekt hinzugefügt wird.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Inkrementiert das aktuelle Vector3D-Objekt um ein anderes. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Inkrementiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts um den Wert des x-, y- und z-Elements des angegebenen Vector3D-Objekts. Anders als bei der <codeph>Vector3D.add()</codeph>-Methode ändert die <codeph>incrementBy()</codeph>-Methode das aktuelle Vector3D-Objekt und gibt kein neues Vector3D-Objekt zurück.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/add()"><linktext>add()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:nearEquals"><apiName>nearEquals</apiName><shortdesc>
    Vergleicht die Elemente des aktuellen Vector3D-Objekts mit den Elementen eines angegebenen Vector3D-Objekts, um festzustellen, ob sie annähernd gleich sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert lautet <codeph>true</codeph>, wenn das angegebene Vector3D-Objekt dem aktuellen annähernd entspricht; andernfalls ist er <codeph>false</codeph>.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das Vector3D-Objekt, das mit dem aktuellen Vector3D-Objekt verglichen wird. 
    </apiDesc></apiParam><apiParam><apiItemName>tolerance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die den Toleranzfaktor festlegt. Wenn die Differenz zwischen den Werten des Vector3D-Elements, das im <codeph>toCompare-Parameter</codeph> angegeben ist, und dem aktuellen Vector3D-Element kleiner als die Toleranzzahl ist, werden die beiden Werte als annähernd gleich betrachtet.  
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein optionaler Parameter, der festlegt, ob die <codeph>w</codeph>-Eigenschaft des Vector3D-Objekts im Vergleich verwendet wird.  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Vergleicht die Elemente des aktuellen Vector3D-Objekts mit den Elementen eines angegebenen Vector3D-Objekts, um festzustellen, ob sie annähernd gleich sind. Die beiden Vector3D-Objekte sind annähernd gleich, wenn die Werte aller Elemente der beiden Scheitelpunkte gleich sind oder wenn das Ergebnis des Vergleichs innerhalb des Toleranzbereichs liegt. Die Differenz zwischen zwei Elementen muss kleiner als die im <codeph>tolerance</codeph>-Parameter angegebene Zahl sein. Wenn der dritte optionale Parameter auf <codeph>true</codeph> eingestellt ist, werden alle vier Elemente des Vector3D-Objekts einschließlich der <codeph>w</codeph>-Eigenschaft verglichen. Andernfalls werden nur die x-, y- und z-Elemente in den Vergleich einbezogen.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/equals()"><linktext>equals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:negate"><apiName>negate</apiName><shortdesc>
    Stellt das aktuelle Vector3D-Objekt auf den inversen Wert ein.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Stellt das aktuelle Vector3D-Objekt auf den inversen Wert ein. Das invertierte Objekt wird auch als Spiegelung des ursprünglichen Objekts betrachtet. Der Wert der <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Eigenschaft des aktuellen Vector3D-Objekts wird zu <codeph>-x</codeph>, <codeph>-y</codeph> und <codeph>-z</codeph> geändert. 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:normalize"><apiName>normalize</apiName><shortdesc>
    Konvertiert ein Vector3D-Objekt in einen Einheitsvektor, indem die ersten drei Elemente (x, y, z) durch die Länge des Vektors dividiert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die Länge des aktuellen Vector3D-Objekts.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Konvertiert ein Vector3D-Objekt in einen Einheitsvektor, indem die ersten drei Elemente (x, y, z) durch die Länge des Vektors dividiert werden. Einheitsscheitelpunkte sind Scheitelpunkte, die eine Richtung aufweisen, deren Länge jedoch eins ist. Sie vereinfachen Vektorberechnungen, indem die Länge als Faktor entfernt wird.
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:project"><apiName>project</apiName><shortdesc>
     Dividiert den Wert der x-, y- und z-Eigenschaft des aktuellen Vector3D-Objekts durch den Wert der w-Eigenschaft.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Dividiert den Wert der <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Eigenschaft des aktuellen Vector3D-Objekts durch den Wert der<codeph>w</codeph>-Eigenschaft. 
     
     <p>Wenn das aktuelle Vector3D-Objekt das Ergebnis der Multiplikation eines Vector3D-Objekts mit einem Matrix3D-Projektionsobjekt ist, kann die <codeph>w</codeph>-Eigenschaft den Transformationswert enthalten. Die <codeph>project()</codeph>-Methode kann die Projektion dann abschließen, indem die Elemente durch die <codeph>w</codeph>-Eigenschaft dividiert werden. Verwenden Sie die<codeph>Matrix3D.rawData</codeph>-Eigenschaft, um ein Matrix3D-Projektionsobjekt zu erstellen.</p>
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:scaleBy"><apiName>scaleBy</apiName><shortdesc>
    Skaliert das aktuelle Vector3D-Objekt um einen Skalar, eine Größe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikationswert (Skalar), mit dem ein Vector3D-Objekt skaliert wird.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Skaliert das aktuelle Vector3D-Objekt um einen Skalar, eine Größe. Das x-, y- und z-Element des Vector3D-Objekts wird mit der im Parameter angegebenen Skalarzahl multipliziert. Wenn der Vektor zum Beispiel um zehn skaliert wird, ist das Ergebnis ein zehnmal so langer Vektor. Der Skalar kann auch die Richtung des Vektors ändern. Durch das Multiplizieren des Vektors mit einer negativen Zahl wird die Richtung des Vektors umgekehrt.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:subtract"><apiName>subtract</apiName><shortdesc>
    Subtrahiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts vom x-, y- und z-Element eines anderen Vector3D-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein neues Vector3D-Objekt, das der Differenz zwischen dem aktuellen Vector3D-Objekt und dem angegebenen Vector3D-Objekt entspricht.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Das Vector3D-Objekt, das vom aktuellen Vector3D-Objekt subtrahiert wird.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Subtrahiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts vom Wert des x-, y- und z-Elements eines anderen, sodass ein neues Vector3D-Objekt erstellt wird. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Subtrahiert den Wert des x-, y- und z-Elements des aktuellen Vector3D-Objekts vom x-, y- und z-Element eines anderen Vector3D-Objekts. Die <codeph>subtract()</codeph>-Methode ändert das aktuelle Vector3D-Objekt nicht. Stattdessen gibt diese Methode ein neues Vector3D-Objekt mit neuen Werten zurück.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/decrementBy()"><linktext>decrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:toString"><apiName>toString</apiName><shortdesc>
     Gibt das aktuelle Vector3D-Objekt als String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, der den Wert der <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Eigenschaft enthält.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Gibt das aktuelle Vector3D-Objekt als String zurück. Der String enthält den Wert der <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Eigenschaft.
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Vector3D:X_AXIS"><apiName>X_AXIS</apiName><shortdesc>
    Die x-Achse, definiert als Vector3D-Objekt mit Koordinaten (1,0,0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Die x-Achse, definiert als Vector3D-Objekt mit Koordinaten (1,0,0).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Y_AXIS"><apiName>Y_AXIS</apiName><shortdesc>
    Die y-Achse, definiert als Vector3D-Objekt mit Koordinaten (0,1,0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Die y-Achse, definiert als Vector3D-Objekt mit Koordinaten (0,1,0).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Z_AXIS"><apiName>Z_AXIS</apiName><shortdesc>
    Die z-Achse, definiert als Vector3D-Objekt mit Koordinaten (0,0,1).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Die z-Achse, definiert als Vector3D-Objekt mit Koordinaten (0,0,1).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:w"><apiName>w</apiName><shortdesc>
     Das vierte Element eines Vector3D-Objekts (zusätzlich zu den x-, y- und z-Eigenschaften) kann Daten wie zum Beispiel den Drehwinkel enthalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Das vierte Element eines Vector3D-Objekts (zusätzlich zu den <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Eigenschaften) kann Daten wie zum Beispiel den Drehwinkel enthalten. Der Standardwert ist 0.
     
     <p>Die Quaternionschreibweise verwendet einen Winkel als viertes Element bei der Berechnung der dreidimensionalen Drehung. Mit der <codeph>w</codeph>-Eigenschaft kann der Drehwinkel um das Vector3D-Objekt definiert werden. Die Kombination des Drehwinkels und der Koordinaten (x,y,z) bestimmt die Ausrichtung des Anzeigeobjekts. </p>
     <p>Zusätzlich kann die <codeph>w</codeph>-Eigenschaft als perspektivischer Verzerrungsfaktor für eine projizierte dreidimensionale Position oder als ein Projektionstransformationswert bei der Darstellung einer dreidimensionalen Koordinate, die in den zweidimensionalen Raum projiziert wird, verwendet werden. Sie können zum Beispiel eine Projektionsmatrix mit der <codeph>Matrix3D.rawData</codeph>-Eigenschaft erstellen, die bei Anwendung auf ein Vector3D-Objekt einen Transformationswert im vierten Element des Vector3D-Objekts (der <codeph>w</codeph>-Eigenschaft) erzeugt. Das Dividieren der anderen Elemente des Vector3D-Objekts durch den Transformationswert erzeugt dann ein projiziertes Vector3D-Objekt. Mit der <codeph>Vector3D.project()</codeph>-Methode können Sie die ersten drei Elemente eines Vector3D-Objekts durch sein viertes Element dividieren.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/project()"><linktext>project()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:x"><apiName>x</apiName><shortdesc>
     Das erste Element eines Vector3D-Objekts, beispielsweise die x-Koordinate eines Punkts im dreidimensionalen Raum.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Das erste Element eines Vector3D-Objekts, beispielsweise die x-Koordinate eines Punkts im dreidimensionalen Raum. Der Standardwert ist 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:y"><apiName>y</apiName><shortdesc>
     Das zweite Element eines Vector3D-Objekts, beispielsweise die y-Koordinate eines Punkts im dreidimensionalen Raum.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Das zweite Element eines Vector3D-Objekts, beispielsweise die y-Koordinate eines Punkts im dreidimensionalen Raum. Der Standardwert ist 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:z"><apiName>z</apiName><shortdesc>
     Das dritte Element eines Vector3D-Objekts, beispielsweise die z-Koordinate eines Punkts im dreidimensionalen Raum.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Das dritte Element eines Vector3D-Objekts, beispielsweise die z-Koordinate eines Punkts im dreidimensionalen Raum. Der Standardwert ist 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:length:get"><apiName>length</apiName><shortdesc>
    Die Länge, Ausdehnung des aktuellen Vector3D-Objekts vom Ursprung (0,0,0) zur x-, y-, und z-Koordinate des Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Länge des aktuellen Vector3D-Objekts. 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Die Länge, Ausdehnung des aktuellen Vector3D-Objekts vom Ursprung (0,0,0) zur x-, y-, und z-Koordinate des Objekts. Die <codeph>w</codeph>-Eigenschaft wird nicht berücksichtigt. Ein Einheitsvektor hat eine Länge bzw. Ausdehnung von eins.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/lengthSquared"><linktext>lengthSquared</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:lengthSquared:get"><apiName>lengthSquared</apiName><shortdesc>
    Das Quadrat der Länge des aktuellen Vector3D-Objekts, berechnet mithilfe der x-, y- und z-Eigenschaften.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Das Quadrat der Länge des aktuellen Vector3D-Objekts. 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Das Quadrat der Länge des aktuellen Vector3D-Objekts, berechnet mithilfe der <codeph>x</codeph>-, <codeph>y</codeph>- und <codeph>z</codeph>-Eigenschaften. Die <codeph>w</codeph>-Eigenschaft wird nicht berücksichtigt. Verwenden Sie nach Möglichkeit die <codeph>lengthSquared()</codeph>-Methode anstelle des langsameren <codeph>Math.sqrt()</codeph>-Methodenaufrufs der <codeph>Vector3D.length()</codeph>-Methode.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/length"><linktext>length</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
 Die Matrix3D-Klasse stellt eine Transformationsmatrix dar, die die Position und Ausrichtung eines dreidimensionalen (3D-)Anzeigeobjekts bestimmt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><internal>Removed the following since it was very unclear. It could be used for a future example however:
 <p>To support a camera viewpoint and motion, create a camera class that keeps a Matrix3D object for 
 handling the movement of the display objects relative to the camera. In the camera space, the display objects 
 move in the opposite direction of the camera movement. For example, when the camera moves closer, the objects 
 become bigger. In other words, if the camera moves down the world z axis, the objects moves up 
 the z axis. One way to produce this effect is by setting the Matrix3D object of the camera class 
 to the inverse of the display objects' transformation. If the display objects are children of the <code>root</code> 
 display object, the Matrix3D object of the camera class can be set to the inverse of the <code>root</code> 
 display object. Another option is to have the display objects as children of a camera object.</p>
 
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Matrix3D-Klasse stellt eine Transformationsmatrix dar, die die Position und Ausrichtung eines dreidimensionalen (3D-)Anzeigeobjekts bestimmt. Die Matrix kann Transformationsfunktionen, einschließlich Versetzungen (Neupositionierung entlang der x-, y- oder z-Achse), Drehungen und Skalierungen (Größenänderungen) ausführen. Mithilfe der Matrix3D-Klasse können auch perspektivische Projektionen durchgeführt werden, d. h. Punkte aus dem dreidimensionalen Koordinatenraum werden einer zweidimensionalen (2D-)Ansicht zugeordnet. 
 
 <p>In einer Matrix können mehrere Transformationen kombiniert und in einem Vorgang auf ein 3D-Anzeigeobjekt angewendet werden. Eine Matrix kann zum Beispiel auf dreidimensionale Koordinaten angewendet werden, um eine Drehung gefolgt von einer Versetzung auszuführen. </p> 
 
 <p>Wenn Sie die <codeph>z</codeph>-Eigenschaft oder eine der Drehungs- oder Skalierungseigenschaften eines Anzeigeobjekts explizit einstellen, wird automatisch ein entsprechendes Matrix3D-Objekt erstellt.</p>
 
 <p>Der Zugriff auf das Matrix3D-Objekt eines 3D-Anzeigeobjekts erfolgt über die <codeph>transform.matrix3d</codeph>-Eigenschaft. 2D-Objekte weisen kein Matrix3D-Objekt auf. </p>
 
 <p>Der Wert der <codeph>z</codeph>-Eigenschaft eines 2D-Objekts ist null und der Wert seiner <codeph>matrix3D</codeph>-Eigenschaft ist <codeph>null</codeph>.</p> 
 
 <p><b>Hinweis:</b> Wenn ein Matrix3D-Objekt zwei verschiedenen Anzeigeobjekten zugewiesen wird, wird ein Laufzeitfehler ausgegeben.</p>
 
 <p>Die Matrix3D-Klasse verwendet eine quadratische 4x4-Matrix: eine Tabelle mit vier Zeilen und vier Spalten von Zahlen, die die Daten für die Transformation enthalten. Die ersten drei Zeilen der Matrix enthalten die Daten für die dreidimensionalen Achsen (x,y,z). Die Versetzungsinformationen befinden sich in der letzten Spalte. Die Daten für Ausrichtung und Skalierung befinden sich in den ersten drei Spalten. Die Skalierungsfaktoren sind die diagonalen Zahlen in den ersten drei Spalten. Dies ist eine Darstellung von Matrix3D-Elementen:</p>  
 
 <p><adobeimage alt="Matrix3D-Elemente" href="../../images/Matrix3Delements.jpg"/></p>
 
 <p>Sie brauchen keine Matrizenrechnung zu beherrschen, um mit der Matrix3D-Klasse zu arbeiten. Sie bietet spezifische Methoden, die Transformationen und Projektionen vereinfachen, zum Beispiel die <codeph>appendTranslation()</codeph>-, <codeph>appendRotation()</codeph>- und <codeph>interpolateTo()</codeph>-Methode. Außerdem können Sie mithilfe der <codeph>decompose()</codeph>- und <codeph>recompose()</codeph>-Methode oder der <codeph>rawData</codeph>-Eigenschaft auf die zugrunde liegenden Matrizenelemente zugreifen.</p>
 
 <p>Die Eigenschafen für die Achsendrehung von Anzeigeobjekten können zwischengespeichert werden. Das ermöglicht das separate Drehen der Achsen sowie die Verwaltung der verschiedenen Drehungskombinationen. Wird eine Methode eines Matrix3D-Objekts aufgerufen, um ein Anzeigeobjekt zu transformieren, so wird der Drehungszwischenspeicher des Objekts ungültig.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links><apiConstructor id="flash.geom:Matrix3D:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
    Erstellt ein Matrix3D-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>v</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Ein Vektor von 16 Zahlen, wobei jeweils vier Elemente eine Zeile oder eine Spalte einer 4x4-Matrix darstellen.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Erstellt ein Matrix3D-Objekt. Matrix3D-Objekte können mit einem Vektor von 16 Zahlen initialisiert werden, wobei jeweils vier Elemente eine Zeile oder eine Spalte darstellen. Nachdem das Matrix3D-Objekt erstellt wurde, können Sie mit der <codeph>rawData</codeph>-Eigenschaft auf seine Matrixelemente zugreifen. 
    
    <p>Wenn kein Parameter definiert ist, erstellt der Konstruktor ein Identitäts- oder Einheits-Matrix3D-Objekt. In der Matrixschreibweise hat eine Identitätsmatrix einen Wert von eins für alle Elemente in der diagonalen Hauptposition und einen Wert von null für alle anderen Elemente. Der Wert der <codeph>rawData</codeph>-Eigenschaft einer Identitätsmatrix lautet <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph>. Der Positions- oder Versetzungswert der Identitätsmatrix lautet <codeph>Vector3D(0,0,0)</codeph>, die Rotationseinstellung ist <codeph>Vector3D(0,0,0)</codeph> und der Skalenwert ist <codeph>Vector3D(1,1,1)</codeph>.</p> 
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix3D/identity()"><linktext>identity()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Matrix3D:append"><apiName>append</apiName><shortdesc>
    Hängt die Matrix an, indem ein anderes Matrix3D-Objekt mit dem aktuellen Matrix3D-Objekt multipliziert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Die linke Matrix, die mit dem aktuellen Matrix3D-Objekt multipliziert wird.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Hängt die Matrix an, indem ein anderes Matrix3D-Objekt mit dem aktuellen Matrix3D-Objekt multipliziert wird. Das Ergebnis kombiniert beide Matrixtransformationen. Sie können ein Matrix3D-Objekt mit vielen Matrizen multiplizieren. Das endgültige Matrix3D-Objekt enthält das Ergebnis aller Transformationen.
    
    <p>Die Matrixmultiplikation unterscheidet sich von der Matrixaddition. Die Matrixmultiplikation ist nicht kommutativ. Anders ausgedrückt, A mal B ist nicht gleich B mal A. Mit der <codeph>append()</codeph>-Methode wird die Multiplikation von links ausgeführt, das heißt, das <codeph>lhs</codeph>-Matrix3D-Objekt befindet sich links vom Multiplikationsoperator.</p>
    
    <codeph>thisMatrix = lhs ~~ thisMatrix;</codeph>
      
    <p>Wenn die <codeph>append()</codeph>-Methode zum ersten Mal aufgerufen wird, nimmt sie eine Änderung relativ zum übergeordneten Raum vor. Nachfolgende Aufrufe sind relativ zum Referenzrahmen des angehängten Matrix3D-Objekts.</p>
    
    <p>Die <codeph>append()</codeph>-Methode ersetzt die aktuelle Matrix durch die angehängte Matrix. Wenn Sie zwei Matrizen anhängen möchten, ohne die aktuelle Matrix zu ändern, kopieren Sie die aktuelle Matrix mithilfe der <codeph>clone()</codeph>-Methode und wenden dann die <codeph>append()</codeph>-Methode auf die Kopie an.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prepend()"><linktext>flash.geom.Matrix3D.prepend()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendRotation"><apiName>appendRotation</apiName><shortdesc>
    Hängt eine inkrementelle Drehung an ein Matrix3D-Objekt an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Drehungsgrad.
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Die Drehachse oder -richtung. Die üblichen Achsen sind <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) und <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Punkt, der den Mittelpunkt der Drehung eines Objekts bestimmt. Der Standarddrehpunkt eines Objekts ist sein Registrierungspunkt.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Hängt eine inkrementelle Drehung an ein Matrix3D-Objekt an. Wenn das Matrix3D-Objekt auf ein Anzeigeobjekt angewendet wird, führt die Matrix die Drehung nach den anderen Transformationen im Matrix3D-Objekt aus. 
    
    <p>Die Drehung eines Anzeigeobjekts wird durch eine Achse, einen inkrementellen Drehwinkel um die Achse und einen optionalen Drehpunkt als Mittelpunkt der Drehung des Objekts bestimmt. Die Achse kann in jede Richtung zeigen. Die üblichen Achsen sind <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) und <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). In der Luftfahrtterminologie wird die Drehung um die y-Achse als Gieren bezeichnet. Die Drehung um die x-Achse heißt Nicken. Die Drehung um die z-Achse wird als Rollen bezeichnet.</p> 
    
    <p>Die Transformationsreihenfolge ist von Bedeutung. Eine Drehung gefolgt von einer Versetzungstransformation erzeugt einen anderen Effekt als eine Versetzung gefolgt von einer Drehungstransformation.</p>
    
    <p>Der Drehungseffekt ist nicht absolut. Er ist relativ zur aktuellen Position und Ausrichtung. Um absolute Änderungen der Transformationsmatrix vorzunehmen, verwenden Sie die <codeph>recompose()</codeph>-Methode. Die <codeph>appendRotation()</codeph>-Methode unterscheidet sich auch von der Achsendrehungseigenschaft des Anzeigeobjekts, zum Beispiel von der <codeph>rotationX</codeph>-Eigenschaft. Die Drehungseigenschaft wird immer vor einer Versetzung angewendet, während die <codeph>appendRotation()</codeph>-Methode relativ zu dem bereits in der Matrix Vorhandenen ausgeführt wird. Um sicherzustellen, dass Sie einen ähnlichen Effekt erzielen wie mit der Achsendrehungseigenschaft des Anzeigeobjekts, verwenden Sie die <codeph>prependRotation</codeph>-Methode, die die Drehung vor allen anderen Transformationen in der Matrix ausführt.</p>
    
    <p>Wenn die Transformation der·￼￼<codeph>appendRotation()</codeph>-Methode auf ein Matrix3D-Objekt eines Anzeigeobjekts angewendet wird, werden die zwischengespeicherten Werte der Drehungseigenschaft des Anzeigeobjekts ungültig.</p> 
    
    <p>Eine Möglichkeit, ein Anzeigeobjekt um einen bestimmten Punkt relativ zu seiner Position zu drehen, besteht darin, die Versetzung des Objekts auf den angegebenen Punkt festzulegen, das Objekt mithilfe der <codeph>appendRotation</codeph>-Methode zu drehen und das Objekt dann an die ursprüngliche Position zurückzuversetzen. Im folgenden Beispiel führt das <codeph>myObject</codeph>-3D-Anzeigeobjekt eine Drehung um die y-Achse um die Koordinate (10,10,0) aus.</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.appendTranslation(10,10,0);
    myObject.transform.matrix3D.appendRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.appendTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependRotation()"><linktext>prependRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendScale"><apiName>appendScale</apiName><shortdesc>
    Hängt ein Matrix3D-Objekt durch inkrementelles Skalieren entlang der x-, y- und z-Achse an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der x-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der y-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der z-Achse.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Hängt ein Matrix3D-Objekt durch inkrementelles Skalieren entlang der x-, y- und z-Achse an. Wenn das Matrix3D-Objekt auf ein Anzeigeobjekt angewendet wird, führt die Matrix die Skalierungsänderungen nach den anderen Transformationen im Matrix3D-Objekt aus. Der Standardskalierungsfaktor ist (1.0, 1.0, 1.0).
    
    <p>Die Skalierung ist als Satz dreier inkrementeller Änderungen entlang der drei Achsen (x, y, z) definiert. Jede Achse kann mit einer anderen Zahl multipliziert werden. Wenn Skalierungsänderungen auf ein Anzeigeobjekt angewendet werden, erhöht oder verringert sich dessen Größe. Beispiel: Wird die x-, y- und z-Achse auf „2“ gesetzt, so wird die Größe verdoppelt. Dagegen wird sie halbiert wird, wenn die Achsen auf <codeph>0.5</codeph> gesetzt werden. Um sicherzustellen, dass sich die Skalierungstransformation nur auf eine bestimmte Achse auswirkt, setzen Sie die anderen Parameter auf eins. Der Parameter „1“ bedeutet, dass keine Skalierung an der betroffenen Achse stattfindet.</p>
    
    <p>Die <codeph>appendScale()</codeph>-Methode kann sowohl zum Ändern der Größe als auch zum Verwalten von Verzerrungen, zum Beispiel Strecken oder Stauchen eines Anzeigeobjekts, oder zum Zoomen verwendet werden. Skalierungstransformationen werden während der Drehung und Versetzung eines Anzeigeobjekts automatisch durchgeführt.</p>
    
    <p>Die Transformationsreihenfolge ist von Bedeutung. Eine Größenänderung gefolgt von einer Versetzungstransformation erzeugt einen anderen Effekt als eine Versetzung gefolgt von einer Größentransformation.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependScale()"><linktext>prependScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendTranslation"><apiName>appendTranslation</apiName><shortdesc>
    Hängt eine inkrementelle Versetzung, eine Neupositionierung entlang der x-, y- und z-Achsen, an ein Matrix3D-Objekt an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine inkrementelle Versetzung entlang der x-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine inkrementelle Versetzung entlang der y-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine inkrementelle Versetzung entlang der z-Achse.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Hängt eine inkrementelle Versetzung, eine Neupositionierung entlang der x-, y- und z-Achsen, an ein Matrix3D-Objekt an. Wenn das Matrix3D-Objekt auf ein Anzeigeobjekt angewendet wird, führt die Matrix die Versetzungsänderungen nach den anderen Transformationen im Matrix3D-Objekt aus.
    
    <p>Die Versetzung ist als ein Satz von drei inkrementellen Änderung entlang der drei Achsen (x,y,z) definiert. Wenn die Transformation auf ein Anzeigeobjekt angewendet wird, bewegt sich das Anzeigeobjekt von seiner aktuellen Position entlang der x-, y- und z-Achse, wie in den Parametern angegeben. Damit die Versetzung nur eine bestimmte Achse betrifft, setzen Sie die anderen Parameter auf null. Der Parameter „0“ bedeutet, dass keine Veränderung an der betroffenen Achse stattfindet.</p> 
    
    <p>Die Änderungen durch Versetzung sind nicht absolut. Sie sind relativ zur aktuellen Position und Ausrichtung der Matrix. Um absolute Änderungen der Transformationsmatrix vorzunehmen, verwenden Sie die <codeph>recompose()</codeph>-Methode. Die Transformationsreihenfolge ist ebenfalls von Bedeutung. Eine Versetzung gefolgt von einer Drehungstransformation erzeugt einen anderen Effekt als eine Drehung gefolgt von einer Versetzung.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependTranslation()"><linktext>prependTranslation()</linktext></link><link href="flash.geom.xml#Matrix3D/position"><linktext>position</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:clone"><apiName>clone</apiName><shortdesc>
    Gibt ein neues Matrix3D-Objekt zurück, das eine genaue Kopie des aktuellen Matrix3D-Objekts ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein neues Matrix3D-Objekt, das eine genaue Kopie des aktuellen Matrix3D-Objekts ist.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Gibt ein neues Matrix3D-Objekt zurück, das eine genaue Kopie des aktuellen Matrix3D-Objekts ist.      
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:decompose"><apiName>decompose</apiName><shortdesc>
    Gibt die Versetzungs-, Drehungs- und Skalierungseinstellungen der Transformationsmatrix als Vektor dreier Vector3D-Objekte zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Vektor aus drei Vector3D-Objekten, die jeweils die Einstellungen für die Versetzung, Drehung und Skalierung enthalten. 
    
    </apiDesc><apiType value="Vector$flash.geom:Vector3D"/></apiReturn><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>Ein optionaler Parameter, der den Ausrichtungsstil für die Matrixtransformation bestimmt. Die drei Ausrichtungsstile sind <codeph>eulerAngles</codeph> (Konstante <codeph>EULER_ANGLES</codeph>), <codeph>axisAngle</codeph> (Konstante <codeph>AXIS_ANGLE</codeph>) und <codeph>quaternion</codeph> (Konstante <codeph>QUATERNION</codeph>). Weitere Informationen zu den verschiedenen Ausrichtungsstilen finden Sie im Abschnitt über die <codeph>geom.Orientation3D</codeph>-Klasse.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Gibt die Versetzungs-, Drehungs- und Skalierungseinstellungen der Transformationsmatrix als Vektor dreier Vector3D-Objekte zurück. Das erste Vector3D-Objekt enthält die Versetzungselemente. Das zweite Vector3D-Objekt enthält die Drehungselemente. Das dritte Vector3D-Objekt enthält die Skalierungselemente. 
    
    <p>Einige Matrix3D-Methoden, beispielsweise die <codeph>interpolateTo()</codeph>-Methode, führen die Transformation aus, indem sie die Matrix automatisch zerlegen und wieder zusammensetzen.</p> 
       
    <p>Um die Transformation der Matrix mithilfe eines absoluten übergeordneten Referenzrahmens zu ändern, rufen Sie die Einstellungen mithilfe der <codeph>decompose()</codeph>-Methode ab und nehmen die entsprechenden Änderungen vor. Sie können das Matrix3D-Objekt auf die geänderte Transformation setzen, indem Sie die <codeph>recompose()</codeph>-Methode verwenden.</p>
    
    <p>Der Parameter der <codeph>decompose()</codeph>-Methode legt den Ausrichtungsstil für die Transformation fest. Die Standardausrichtung ist <codeph>eulerAngles</codeph>. Dabei wird die Ausrichtung durch einen separaten Drehwinkel pro Achse festgelegt. Die Drehungen folgen aufeinander und ändern die Achsen der jeweils anderen Drehungen nicht. Die Achsendrehungseigenschaften des Anzeigeobjekts bewirken eine Transformation des Ausrichtungsstils gemäß Eulerschen Winkeln. Weitere Optionen für den Ausrichtungsstil sind <codeph>axisAngle</codeph> und <codeph>quaternion</codeph>. Die Achsenwinkelausrichtung verwendet zur Bestimmung der Ausrichtung eine Kombination von Achse und Winkel. Die Achse, um die sich das Objekt dreht, ist ein Einheitsvektor, der die Richtung darstellt. Der Winkel stellt die Stärke der Drehung um den Vektor dar. Die Richtung bestimmt auch, wohin das Anzeigeobjekt zeigt und der Winkel bestimmt, wo oben liegt. Die <codeph>appendRotation()</codeph>- und <codeph>prependRotation()</codeph>-Methode verwendet die Achsenwinkelausrichtung. Die Quaternionausrichtung verwendet komplexe Zahlen und das vierte Element eines Vektors. Die drei Drehsachsen (x, y, z) und der Drehwinkel (w) stellen die Ausrichtung dar. Die <codeph>interpolate()</codeph>-Methode verwendet Quaternionen.</p> 
    
    </apiDesc><example conref="examples\Matrix3DdecomposeExample.as"> In diesem Beispiel werden die <codeph>decompose()</codeph>- und <codeph>recompose()</codeph>-Methode verwendet, damit sich die Ellipse horizontal ausdehnt, während sie sich auf den Fluchtpunkt zubewegt. Das erste von der <codeph>decompose()</codeph>-Methode zurückgegebene Vector3D-Objekt enthält die Koordinaten für die Versetzung. Das dritte Vector3D-Objekt enthält die Skalierungseinstellungen. Die <codeph>incrementBy()</codeph>-Methode des Vector3D-Objekts inkrementiert die absoluten Versetzungs- und Skalierungseinstellungen der Matrix.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.Event;
    
    public class Matrix3DdecomposeExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DdecomposeExample():void {
            
            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight - 40);
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 50, 40);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function enterFrameHandler(e:Event):void {  

            var v3:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(3);
            v3 = ellipse.transform.matrix3D.decompose();
            v3[0].incrementBy(new Vector3D(0,0,1));
            v3[2].incrementBy(new Vector3D(0.01,0,0));
            ellipse.transform.matrix3D.recompose(v3);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>recompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:deltaTransformVector"><apiName>deltaTransformVector</apiName><shortdesc>
    Verwendet die Transformationsmatrix ohne deren Versetzungselemente, um ein Vector3D-Objekt von einer Raumkoordinate zu einer anderen zu transformieren.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Vector3D-Objekt mit den transformierten Koordinaten.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Ein Vector3D-Objekt, das die zu transformierenden Koordinaten enthält.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Verwendet die Transformationsmatrix ohne deren Versetzungselemente, um ein Vector3D-Objekt von einer Raumkoordinate zu einer anderen zu transformieren. Das zurückgegebene Vector3D-Objekt enthält die neuen Koordinaten nach Anwendung der Drehungs- und Skalierungsinformationen. Wendet die <codeph>deltaTransformVector()</codeph>-Methode eine Matrix an, die nur eine Versetzungstransformation enthält, so ist das zurückgegebene Vector3D-Objekt mit dem ursprünglichen Vector3D-Objekt identisch.
    
    <p>Sie können die <codeph>deltaTransformVector()</codeph>-Methode verwenden, um zu bewirken, dass ein Anzeigeobjekt in einem Koordinatenraum auf die Drehungstransformation eines zweiten Anzeigeobjekts reagiert. Das Objekt kopiert die Drehung nicht; es ändert nur seine Position, um die Änderungen der Drehung wiederzuspiegeln. Um zum Beispiel mit der <codeph>display.Graphics</codeph>-API ein sich drehendes dreidimensionales Objekt zu zeichnen, müssen Sie die sich drehenden Koordinaten des Objekts einem zweidimensionalen Punkt zuordnen. Rufen Sie zunächst mit der <codeph>deltaTransformVector()</codeph>-Methode die dreidimensionalen Koordinaten des Objekts nach jeder Drehung ab. Wenden Sie als Nächstes die <codeph>local3DToGlobal()</codeph>-Methode des Anzeigeobjekts an, um die dreidimensionalen Koordinaten in zweidimensionale Punkte zu übersetzen. Mithilfe der zweidimensionalen Punkte können Sie dann das sich drehende dreidimensionale Objekt zeichnen.</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:identity"><apiName>identity</apiName><shortdesc>
    Konvertiert die aktuelle Matrix in eine Identitäts- oder Einheitsmatrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Konvertiert die aktuelle Matrix in eine Identitäts- oder Einheitsmatrix. Eine Identitätsmatrix hat einen Wert von 1 für alle Elemente in der Hauptdiagonale und einen Wert von 0 für alle anderen Elemente. Das Ergebnis ist eine Matrix mit den folgenden Einstellungen: Der <codeph>rawData</codeph>-Wert ist <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph>, die Drehungseinstellung ist auf <codeph>Vector3D(0,0,0)</codeph> gesetzt, die Positions- oder Versetzungseinstellungen sind auf <codeph>Vector3D(0,0,0)</codeph> gesetzt und die Skalierung auf <codeph>Vector3D(1,1,1)</codeph>. Hier sehen Sie eine Darstellung einer Identitätsmatrix.
    
    <p><adobeimage alt="Identitätsmatrix" href="../../images/identityMatrix.jpg"/></p>
    
    <p>Ein Objekt, das durch Anwenden einer Identitätsmatrix transformiert wird, führt keine Transformation aus. Anders ausgedrückt, wenn eine Matrix mit einer Identitätsmatrix multipliziert wird, ist das Ergebnis eine Matrix, die mit der ursprünglichen Matrix identisch ist.</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolate"><apiName>interpolate</apiName><shortdesc>
    Vereinfacht die Interpolation von einem Referenzrahmen zu einem anderen, indem ein Anzeigeobjekt einen Prozentpunkt näher an ein Zielanzeigeobjekt interpoliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Ein Matrix3D-Objekt mit Elementen, die die Werte der Matrix zwischen der Original- und der Zielmatrix anordnen. Wird die zurückgegebene Matrix auf das <codeph>this</codeph>-Anzeigeobjekt angewendet, so bewegt sich das Objekt um die angegebene Prozentzahl näher zum Zielobjekt.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>thisMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Das Matrix3D-Objekt, das interpoliert wird.
    </apiDesc></apiParam><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Das Matrix3D-Zielobjekt.
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Wert zwischen <codeph>0</codeph> und <codeph>1</codeph>, der den Prozentwert angibt, um den das <codeph>thisMat</codeph>-Matrix3D-Objekt in Richtung des Matrix3D-Zielobjekts interpoliert wird.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Interpoliert ein Anzeigeobjekt um einen Prozentpunkt näher an das Zielanzeigeobjekt.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Vereinfacht die Interpolation von einem Referenzrahmen zu einem anderen, indem ein Anzeigeobjekt einen Prozentpunkt näher an ein Zielanzeigeobjekt interpoliert wird. Das Ergebnis ist ein neues Matrix3D-Objekt, bei dem alle Elemente für die Versetzung, Drehung und Skalierung auf Werte interpoliert werden, die zwischen dem aktuellen Anzeigeobjekt und dem Zielanzeigeobjekt liegen.
    
    <p>Die <codeph>interpolate()</codeph>-Methode vermeidet einige der unerwünschten Ergebnisse, die auftreten können, wenn Methoden wie zum Beispiel die Eigenschaften für die Achsendrehung des Anzeigeobjekts verwendet werden. Die <codeph>interpolate()</codeph>-Methode macht den zwischengespeicherten Wert der Drehungseigenschaft des Anzeigeobjekts ungültig und rechnet die Ausrichtungselemente der Matrix des Anzeigeobjekts vor der Interpolation in Quaternionen um. Diese Methode gewährleistet den kürzesten, effizientesten Drehungspfad. Sie erzeugt auch eine ruckfreie Drehung und vermeidet eine Blockade der kardanischen Aufhängung (Gimbal Lock). Ein Gimbal Lock kann bei Eulerschen Winkeln auftreten, da die Achsen unabhängig voneinander behandelt werden. Bei der Drehung um zwei oder mehr Achsen können die Achsen zusammenfallen, was zu unerwarteten Ergebnissen führt. Das Gimbal Lock wird durch die Drehung mittels Quaternionen vermieden.</p> 
    
    <p>Aufeinanderfolgende Aufrufe der <codeph>interpolate()</codeph>-Methode können einen Effekt erzeugen, bei dem ein Anzeigeobjekt schnell startet und sich dann langsam einem anderen Anzeigeobjekt nähert. Wenn Sie zum Beispiel den <codeph>thisMat</codeph>-Parameter auf das zurückgegebene Matrix3D-Objekt setzen, den <codeph>toMat</codeph>-Parameter auf das mit dem Zielanzeigeobjekt verknüpfte Matrix3D-Objekt und den <codeph>percent</codeph>-Parameter auf <codeph>0.1</codeph>, so bewegt sich das Anzeigeobjekt um zehn Prozent in Richtung des Zielobjekts. Durch aufeinanderfolgende Aufrufe oder in aufeinanderfolgenden Bildern bewegt sich das Objekt um zehn Prozent der verbleibenden 90 Prozent, dann um zehn Prozent der verbleibenden 80 Prozent, bis das Ziel erreicht ist.</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>interpolateTo()</linktext></link><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolateTo"><apiName>interpolateTo</apiName><shortdesc>
    Interpoliert die Matrix des Anzeigeobjekts um ein Prozent näher an die Matrix des Zielobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Das Matrix3D-Zielobjekt.  
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Wert zwischen <codeph>0</codeph> und <codeph>1</codeph>, der die Position des Anzeigeobjekts in Bezug auf sein Ziel bestimmt. Je näher der Wert an <codeph>1.0</codeph> liegt, desto näher ist das Anzeigeobjekt seiner aktuellen Position. Je näher der Wert an <codeph>0</codeph> liegt, desto näher ist das Anzeigeobjekt dem Ziel.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Interpoliert die Matrix des Anzeigeobjekts um ein Prozent näher an die Matrix des Zielobjekts. Alle Elemente des Anzeigeobjekts für Versetzung, Drehung und Skalierung werden auf Werte zwischen der aktuellen Position und der Zielposition der Matrix des Anzeigeobjekts interpoliert. 
    
    <p>Die <codeph>interpolateTo()</codeph>-Methode vermeidet die unerwünschten Ergebnisse, die auftreten können, wenn Methoden wie zum Beispiel die Eigenschaften für die Achsendrehung des Anzeigeobjekts verwendet werden. Die <codeph>interpolateTo()</codeph>-Methode macht den zwischengespeicherten Wert der Drehungseigenschaft des Anzeigeobjekts ungültig und rechnet die Ausrichtungselemente der Matrix des Anzeigeobjekts vor der Interpolation in Quaternionen um. Diese Methode gewährleistet den kürzesten, effizientesten Drehungspfad. Sie erzeugt auch eine ruckfreie Drehung und vermeidet eine Blockade der kardanischen Aufhängung (Gimbal Lock). Ein Gimbal Lock kann bei Eulerschen Winkeln auftreten, da die Achsen unabhängig voneinander behandelt werden. Bei der Drehung um zwei oder mehr Achsen können die Achsen zusammenfallen, was zu unerwarteten Ergebnissen führt. Das Gimbal Lock wird durch die Drehung mittels Quaternionen vermieden.</p> 
    
    <p>Aufeinanderfolgende Aufrufe der <codeph>interpolateTo()</codeph>-Methode können einen Effekt erzeugen, bei dem ein Anzeigeobjekt schnell startet und sich dann langsam einem anderen Anzeigeobjekt nähert. Wenn der percent-Parameter beispielsweise auf <codeph>0.1</codeph> gesetzt ist, bewegt sich das Anzeigeobjekt um zehn Prozent in Richtung des im <codeph>toMat</codeph>-Parameter angegebenen Zielobjekts. Durch aufeinanderfolgende Aufrufe oder in aufeinanderfolgenden Bildern bewegt sich das Objekt um zehn Prozent der verbleibenden 90 Prozent, dann um zehn Prozent der verbleibenden 80 Prozent, bis das Ziel erreicht ist.</p>  
    
    </apiDesc><example conref="examples\InterpolateToExample.as"> In diesem Beispiel bewegt sich das dreidimensionale Anzeigeobjekt <codeph>ellipse2</codeph> in Richtung eines anderen dreidimensionalen Anzeigeobjekts <codeph>ellipse1</codeph>. <codeph>ellipse2</codeph> folgt <codeph>ellipse1</codeph> wie bei einer Verfolgungsjagd. Wenn <codeph>ellipse1</codeph> nicht um seine y-Achse rotiert, erreicht <codeph>ellipse2</codeph> das <codeph>ellipse1</codeph>-Objekt und „landet“ auf ihm. Die beiden Ellipsen werden auf die gleiche Weise gezeichnet, aber an unterschiedlichen dreidimensionalen Positionen des globalen Raums platziert. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class InterpolateToExample extends MovieClip {
        private var ellipse1:Shape = new Shape();
        private var ellipse2:Shape = new Shape();

        public function InterpolateToExample():void {

            ellipse1 = myEllipses(250, 100, 500, 0xFF0000);
            addChild(ellipse1);
            
            ellipse2 = myEllipses(-30, 120, 1, 0x00FF00);
            addChild(ellipse2);

            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function myEllipses(x:Number, y:Number, z:Number, c:Number):Shape {
            var s:Shape = new Shape();                            
            s.x = x;
            s.y = y;
            s.z = z;
            s.graphics.beginFill(c);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(100, 50, 100, 80);
            s.graphics.endFill();
            return s;
        }

        private function enterFrameHandler(e:Event) {
            ellipse1.rotationY += 1;

            ellipse2.transform.matrix3D.interpolateTo(ellipse1.transform.matrix3D, 0.1);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:invert"><apiName>invert</apiName><shortdesc>
    Invertiert die aktuelle Matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Gibt <codeph>true </codeph> zurück, wenn die Matrix erfolgreich invertiert wurde. 
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Invertiert die aktuelle Matrix. Eine invertierte Matrix hat dieselbe Größe wie das Original, führt jedoch die der Originalmatrix entgegengesetzte Transformation aus. Wenn die Originalmatrix zum Beispiel ein Objekt in eine Richtung um die x-Achse dreht, dreht die invertierte Matrix das Objekt in die entgegengesetzte Richtung um diese Achse. Durch das Anwenden einer invertierten Matrix auf ein Objekt wird die von der Originalmatrix durchgeführte Transformation rückgängig gemacht. Wenn eine Matrix mit ihrer invertierten Matrix multipliziert wird, ist das Ergebnis eine Identitätsmatrix. 
    
    <p>Mit einer invertierten Matrix kann eine Matrix durch eine andere dividiert werden. Um Matrix A durch Matrix B zu dividieren, wird Matrix A mit der invertierten Matrix B multipliziert. Die invertierte Matrix kann auch bei einem Kameraraum verwendet werden. Wenn sich die Kamera im Raum der Welt bewegt, muss sich das Objekt in dieser Welt in die entgegengesetzte Richtung bewegen, damit die Transformation von der Weltsicht in den Kameraraum bzw. Sichtraum erfolgt. Wenn die Kamera zum Beispiel näher kommt, werden die Objekte größer. Anders ausgedrückt, wenn sich die Kamera entlang der z-Achse der Welt nach unten (nach hinten) bewegt, bewegen sich die Objekte entlang der z-Achse der Welt nach oben (nach vorn).</p> 
    
    <p>Die <codeph>invert()</codeph>-Methode ersetzt die aktuelle Matrix durch die invertierte Matrix. Wenn Sie eine Matrix invertieren möchten, ohne die aktuelle Matrix zu ändern, kopieren Sie zunächst die aktuelle Matrix mithilfe der <codeph>clone()</codeph>-Methode und wenden dann die <codeph>invert()</codeph>-Methode auf die Kopie an.</p>
    
    <p>Das Matrix3D-Objekt muss invertierbar sein.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/determinant"><linktext>determinant</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:pointAt"><apiName>pointAt</apiName><shortdesc>
    Dreht das Anzeigeobjekt, sodass es auf eine bestimmte Position zeigt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Die auf die Welt bezogene Position des Zielobjekts. „Auf die Welt bezogen“·bezeichnet die Transformation des Objekts relativ zum Raum der Welt und den Koordinaten, die angeben wo die Objekte dort platziert sind.
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Der objektbezogene Vektor, der festlegt, in welche Richtung das Anzeigeobjekt weist. „Objektbezogen“ bezeichnet die Transformation des Objekts relativ zum Objektraum, dem eigenen Bezugsrahmen des Objekts mit seinem eigenen Koordinatensystem. Der Standardwert ist die <i>-z</i>-Achse (0,0,-1).
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Der objektbezogene Vektor, der die Aufwärtsrichtung des Anzeigeobjekts definiert. Wenn das Objekt so gezeichnet ist, dass es von oben nach unten zeigt, dann ist die <i>+z</i>-Achse der Aufwärtsvektor. „Objektbezogen“ bezeichnet die Transformation des Objekts relativ zum Objektraum, dem eigenen Bezugsrahmen des Objekts mit seinem eigenen Koordinatensystem. Der Standardwert ist die <i>-y</i>-Achse (0,-1,0).
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Dreht das Anzeigeobjekt, sodass es auf eine bestimmte Position zeigt. Diese Methode ermöglicht die direkte Änderung der Ausrichtung. Der vorwärts zeigende Vektor des Anzeigeobjekts (das <codeph>at</codeph>-Vector3D-Objekt) zeigt auf die angegebene auf die Welt bezogene Position. Die Aufwärtsrichtung des Anzeigeobjekts wird mit dem <codeph>up</codeph>-Vector3D-Objekt festgelegt. 
    
    <p>Die <codeph>pointAt()</codeph>-Methode macht den zwischengespeicherten Wert der Drehungseigenschaft des Anzeigeobjekts ungültig. Die Methode zerlegt die Matrix des Anzeigeobjekts und ändert die Drehungselemente, damit sich das Objekt in die angegebene Position dreht. Danach wird die Matrix des Anzeigeobjekts wieder zusammengesetzt (aktualisiert), wodurch die Transformation ausgeführt wird. Wenn das Objekt auf ein sich bewegendes Ziel zeigt, zum Beispiel die Position eines sich bewegenden Objekts, wird das Objekt bei jedem folgenden Aufruf der Methode in Richtung des sich bewegenden Ziels gedreht.</p>
    
    </apiDesc><example conref="examples\PointAtExample.as"> In diesem Beispiel zeigt ein Dreieck auf den Bewegungspfad einer Ellipse und folgt dieser. Die Ellipse und das Dreieck sind auf verschiedene Positionen eingestellt. Die Ellipse bewegt sich dann nach oben zur Ecke der Bühne. Das Dreieck folgt den Versetzungsänderungen der Ellipse. Sie können die Form des Dreiecks und die „at“- und „up“-Parameter von <codeph>pointAt()</codeph> ändern, um die Auswirkungen auf die Bewegung des Dreiecks zu sehen.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class PointAtExample extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var triangle:Shape = new Shape();

        public function PointAtExample():void {
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(30, 40, 50, 40);
            ellipse.graphics.endFill();
            ellipse.x = 100;
            ellipse.y = 150;
            ellipse.z = 1;

            triangle.graphics.beginFill(0x0000FF);
            triangle.graphics.moveTo(0, 0);
            triangle.graphics.lineTo(40, 40);
            triangle.graphics.lineTo(80, 0);
            triangle.graphics.lineTo(0, 0);
            triangle.graphics.endFill();
            triangle.x = 200;
            triangle.y = 50;
            triangle.z = 1;

            addChild(ellipse);
            addChild(triangle);

            ellipse.addEventListener(Event.ENTER_FRAME, ellipseEnterFrameHandler);
            triangle.addEventListener(Event.ENTER_FRAME, triangleEnterFrameHandler);
        }

        private function ellipseEnterFrameHandler(e:Event) {
            if(e.target.y > 0) {
                e.target.y -= 1;
                e.target.x -= 1;
            }
        }
        
        private function triangleEnterFrameHandler(e:Event) {
            e.target.transform.matrix3D.pointAt(ellipse.transform.matrix3D.position,
                                                Vector3D.X_AXIS, Vector3D.Y_AXIS);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prepend"><apiName>prepend</apiName><shortdesc>
    Stellt eine Matrix voran, indem das aktuelle Matrix3D-Objekt mit einem anderen Matrix3D-Objekt multipliziert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Rechte Seite der Matrix, mit der das aktuelle Matrix3D-Objekt multipliziert wird.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Stellt eine Matrix voran, indem das aktuelle Matrix3D-Objekt mit einem anderen Matrix3D-Objekt multipliziert wird. Das Ergebnis kombiniert beide Matrixtransformationen. 
    
    <p>Die Matrixmultiplikation unterscheidet sich von der Matrixaddition. Die Matrixmultiplikation ist nicht kommutativ. Anders ausgedrückt, A mal B ist nicht gleich B mal A. Mit der <codeph>prepend()</codeph>-Methode wird die Multiplikation von rechts ausgeführt, das heißt, das <codeph>rhs</codeph>-Matrix3D-Objekt befindet sich rechts vom Multiplikationsoperator.</p>
    
    <codeph>thisMatrix = thisMatrix ~~ rhs</codeph>
      
    <p>Die durch die <codeph>prepend()</codeph>-Methode ausgeführten Änderungen sind relativ zum Objektraum. Anders ausgedrückt beziehen Sie sich immer auf den ursprünglichen Referenzrahmen des Objekts.</p>
    
    <p>Die <codeph>prepend()</codeph>-Methode ersetzt die aktuelle Matrix durch die vorangestellte Matrix. Wenn Sie zwei Matrizen voranstellen möchten, ohne die aktuelle Matrix zu ändern, kopieren Sie zuerst die aktuelle Matrix mithilfe der <codeph>clone()</codeph>-Methode und wenden dann die <codeph>prepend()</codeph>-Methode auf die Kopie an.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/append()"><linktext>append()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependRotation"><apiName>prependRotation</apiName><shortdesc>
    Stellt einem Matrix3D-Objekt eine inkrementelle Drehung voran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Drehungsgrad.
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Die Drehachse oder -richtung. Die üblichen Achsen sind <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) und <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Punkt, der die Mitte der Drehung bestimmt. Der Standarddrehpunkt eines Objekts ist sein Registrierungspunkt.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Stellt einem Matrix3D-Objekt eine inkrementelle Drehung voran. Wenn das Matrix3D-Objekt auf ein Anzeigeobjekt angewendet wird, führt die Matrix die Drehung vor den anderen Transformationen im Matrix3D-Objekt aus. 
    
    <p>Die Drehung eines Anzeigeobjekts wird durch eine Achse, einen inkrementellen Drehwinkel um die Achse und einen optionalen Drehpunkt als Mittelpunkt der Drehung des Objekts bestimmt. Die Achse kann in jede Richtung zeigen. Die üblichen Achsen sind <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) und <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). In der Luftfahrtterminologie wird die Drehung um die y-Achse als Gieren bezeichnet. Die Drehung um die x-Achse heißt Nicken. Die Drehung um die z-Achse wird als Rollen bezeichnet.</p> 
    
    <p>Die Transformationsreihenfolge ist von Bedeutung. Eine Drehung gefolgt von einer Versetzungstransformation hat andere Auswirkungen als eine Versetzung gefolgt von einer Drehung.</p>
    
    <p>Der Drehungseffekt ist nicht absolut. Die Auswirkung ist objektbezogen, relativ zum Bezugsrahmen der ursprünglichen Position und Ausrichtung. Um absolute Änderungen der Transformation vorzunehmen, verwenden Sie die <codeph>recompose()</codeph>-Methode.</p>
    
    <p>Wenn die Transformation der ￼￼<codeph>prependRotation()</codeph>-Methode auf ein Matrix3D-Objekt eines Anzeigeobjekts angewendet wird, werden die zwischengespeicherten Werte der Drehungseigenschaft des Anzeigeobjekts ungültig.</p> 
    
    <p>Eine Möglichkeit, ein Anzeigeobjekt um einen bestimmten Punkt relativ zu seiner Position zu drehen, besteht darin, die Versetzung des Objekts auf den angegebenen Punkt festzulegen, das Objekt mithilfe der <codeph>prependRotation</codeph>-Methode zu drehen und das Objekt dann an die ursprüngliche Position zurückzuversetzen. Im folgenden Beispiel führt das <codeph>myObject</codeph>-3D-Anzeigeobjekt eine Drehung um die y-Achse um die Koordinate (10,10,0) aus.</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.prependTranslation(10,10,0);
    myObject.transform.matrix3D.prependRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.prependTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc><example conref="examples\Matrix3DprependRotationExample.as"> In diesem Beispiel kann der Benutzer eine Maus verwenden, um eine Ellipse um ihre <i>x</i>- und <i>y</i>-Achsen zu drehen. Die Ellipse wird mit ihrem Registrierungspunkt in ihrer Mitte gezeichnet. Die Ellipse dreht sich um ihre <i>y</i>-Achse, indem sie die <i>x</i>-Koordinate der Maus verwendet. Sie dreht sich um ihre <i>x</i>-Achse, indem sie die <i>y</i>-Koordinate der Maus verwendet.
 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.MouseEvent;
    
    public class Matrix3DprependRotationExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DprependRotationExample():void {

            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(-50, -40, 100, 80);
            ellipse.graphics.endFill();

            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight / 2);
            ellipse.z = 1;
            
            addChild(ellipse);

            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function mouseMoveHandler(e:MouseEvent):void {
            var y:int;
            var x:int;
            
            if(e.localX > ellipse.x) {
                y = (Math.round(e.localX) / 100);   
            } else {
                y = -(Math.round(e.localX) / 10);   
            }
            
            if(e.localY > ellipse.y) {
                x = (Math.round(e.localY) / 100);
            } else {
                x = -(Math.round(e.localY) / 100);
            }
            
            ellipse.transform.matrix3D.prependRotation(y, Vector3D.Y_AXIS);
            ellipse.transform.matrix3D.prependRotation(x, Vector3D.X_AXIS);
        }
        
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendRotation()"><linktext>appendRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependScale"><apiName>prependScale</apiName><shortdesc>
    Stellt einem Matrix3D-Objekt eine inkrementelle Skalierungsänderung der x-, y- und z-Achse voran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der x-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der y-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der z-Achse.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Stellt einem Matrix3D-Objekt eine inkrementelle Skalierungsänderung der x-, y- und z-Achse voran. Wenn das Matrix3D-Objekt auf ein Anzeigeobjekt angewendet wird, führt die Matrix die Skalierungsänderungen vor den anderen Transformationen im Matrix3D-Objekt aus. Die Änderungen sind objektbezogen, relativ zum Bezugsrahmen der ursprünglichen Position und Ausrichtung. Der Standardskalierungsfaktor ist (1.0, 1.0, 1.0).
    
    <p>Die Skalierung ist als Satz dreier inkrementeller Änderungen entlang der drei Achsen (x, y, z) definiert. Jede Achse kann mit einer anderen Zahl multipliziert werden. Wenn Skalierungsänderungen auf ein Anzeigeobjekt angewendet werden, erhöht oder verringert sich dessen Größe. Beispiel: Wird die x-, y- und z-Achse auf „2“ gesetzt, so wird die Größe verdoppelt. Dagegen wird sie halbiert wird, wenn die Achsen auf <codeph>0.5</codeph> gesetzt werden. Um sicherzustellen, dass sich die Skalierungstransformation nur auf eine bestimmte Achse auswirkt, setzen Sie die anderen Parameter auf eins. Der Parameter „1“ bedeutet, dass keine Skalierung an der betroffenen Achse stattfindet.</p>
    
    <p>Die <codeph>prependScale()</codeph>-Methode kann sowohl zum Ändern der Größe als auch zum Verwalten von Verzerrungen, zum Beispiel Strecken oder Stauchen eines Anzeigeobjekts, verwendet werden. Sie kann auch für das Ein- und Auszoomen auf eine Position verwendet werden. Skalierungstransformationen werden während der Drehung und Versetzung eines Anzeigeobjekts automatisch durchgeführt.</p>
    
    <p>Die Transformationsreihenfolge ist von Bedeutung. Eine Größenänderung gefolgt von einer Versetzungstransformation erzeugt einen anderen Effekt als eine Versetzung gefolgt von einer Größentransformation.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendScale()"><linktext>appendScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependTranslation"><apiName>prependTranslation</apiName><shortdesc>
    Stellt einem Matrix3D-Objekt eine inkrementelle Versetzung, eine Neupositionierung entlang der x-, y- und z-Achse voran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine inkrementelle Versetzung entlang der x-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine inkrementelle Versetzung entlang der y-Achse.
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine inkrementelle Versetzung entlang der z-Achse.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Stellt einem Matrix3D-Objekt eine inkrementelle Versetzung, eine Neupositionierung entlang der x-, y- und z-Achse voran. Wenn das Matrix3D-Objekt auf ein Anzeigeobjekt angewendet wird, führt die Matrix die Versetzungsänderungen vor den anderen Transformationen im Matrix3D-Objekt aus. 
       
    <p>Die Versetzung gibt die Entfernung an, um die sich das Anzeigeobjekt von seiner aktuellen Position weg entlang der x-, y- und z-Achse entfernt. Die <codeph>prependTranslation()</codeph>-Methode definiert die Versetzung als einen Satz dreier inkrementeller Änderungen entlang der drei Achsen (x,y,z). Damit die Versetzung nur eine bestimmte Achse betrifft, setzen Sie die anderen Parameter auf null. Der Parameter „0“ bedeutet, dass keine Veränderung an der betroffenen Achse stattfindet.</p>
    
    <p>Die Änderungen durch Versetzung sind nicht absolut. Die Auswirkung ist objektbezogen, relativ zum Bezugsrahmen der ursprünglichen Position und Ausrichtung. Um absolute Änderungen der Transformationsmatrix vorzunehmen, verwenden Sie die <codeph>recompose()</codeph>-Methode. Die Transformationsreihenfolge ist ebenfalls von Bedeutung. Eine Versetzung gefolgt von einer Drehungstransformation erzeugt einen anderen Effekt als eine Drehung gefolgt von einer Versetzungstransformation. Wenn Sie <codeph>prependTranslation()</codeph> verwenden, bewegt sich das Anzeigeobjekt weiterhin in die Richtung, in die es zeigt, unabhängig von den anderen Transformationen. Beispiel: Wenn ein Anzeigeobjekt in Richtung einer positiven x-Achse zeigte, so bewegt es sich weiterhin in die Richtung, die von der <codeph>prependTranslation()</codeph>-Methode festgelegt wird, unabhängig von der Drehung des Objekts. Um Versetzungsänderungen nach anderen Transformationen auszuführen, verwenden Sie die <codeph>appendTranslation()</codeph>-Methode.</p> 
    
    
    </apiDesc><example conref="examples\Matrix3DprependTranslationExample.as"> In diesem Beispiel kann der Benutzer die Ellipse mithilfe einer Maus an der <i>y</i>-Achse der Bühne nach oben schieben. Bewegt der Benutzer die Maus über die Ellipse, so springt diese zehn Koordinaten an der <i>y</i>-Achse nach oben. Verlässt die Maus die Ellipse, bevor diese die obere Grenze erreicht, so springt die Ellipse an der <i>y</i>-Achse wieder um zehn Koordinaten nach oben. Sobald die Ellipse die obere Grenze erreicht hat, wird sie wieder zurück an das untere Ende der Bühne bewegt.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.geom.*;
    import flash.events.MouseEvent;

    public class Matrix3DprependTranslationExample extends MovieClip {
        private var ellipse:Sprite = new Sprite();

        public function Matrix3DprependTranslationExample():void {
            ellipse.x = this.stage.stageWidth / 2;
            ellipse.y = this.stage.stageHeight - 100;
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 60, 50);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
            ellipse.addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        }

        private function mouseOverHandler(e:MouseEvent):void {
            if(ellipse.y > 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } 
        }
        
        private function mouseOutHandler(e:MouseEvent):void {
            if(ellipse.y > 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } else {
                ellipse.transform.matrix3D.prependTranslation(0, 
                                     (this.stage.stageHeight - 100), 0);
            }   
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendTranslation()"><linktext>appendTranslation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:recompose"><apiName>recompose</apiName><shortdesc>
    Legt die Einstellungen der Transformationsmatrix für die Versetzung, Drehung und Skalierung fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Gibt den Wert <codeph>false</codeph> zurück, wenn eines der Skalierungselemente „0“ ist.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>components</apiItemName><apiType value="Vector$flash.geom:Vector3D"/><apiDesc>Ein Vektor aus drei Vector3D-Objekten, die die Versetzungs-, Drehungs- und Skalierungselemente des Matrix3D-Objekts ersetzen. 
    
    </apiDesc></apiParam><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>Ein optionaler Parameter, der den Ausrichtungsstil für die Matrixtransformation bestimmt. Die drei Ausrichtungsstile sind <codeph>eulerAngles</codeph> (Konstante <codeph>EULER_ANGLES</codeph>), <codeph>axisAngle</codeph> (Konstante <codeph>AXIS_ANGLE</codeph>) und <codeph>quaternion</codeph> (Konstante <codeph>QUATERNION</codeph>). Weitere Informationen zu den verschiedenen Ausrichtungsstilen finden Sie im Abschnitt über die <codeph>geom.Orientation3D</codeph>-Klasse.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Legt die Einstellungen der Transformationsmatrix für die Versetzung, Drehung und Skalierung fest. Die Änderungen aufgrund der <codeph>recompose()</codeph>-Methode sind absolut, anders als die inkrementellen Änderungen aufgrund der Drehungseigenschaften des Anzeigeobjekts oder der Drehungsmethoden des Matrix3D-Objekts. Die <codeph>recompose()</codeph>-Methode überschreibt die Transformation der Matrix.
    
    <p>Um die Transformation der Matrix mithilfe eines absoluten übergeordneten Referenzrahmens zu ändern, rufen Sie die Einstellungen mithilfe der <codeph>decompose()</codeph>-Methode ab und nehmen die entsprechenden Änderungen vor. Sie können das Matrix3D-Objekt auf die geänderte Transformation setzen, indem Sie die <codeph>recompose()</codeph>-Methode verwenden.</p>
    
    <p>Der Parameter der <codeph>recompose()</codeph>-Methode gibt den Ausrichtungsstil an, der für die Transformation verwendet wurde. Die Standardausrichtung ist <codeph>eulerAngles</codeph>. Dabei wird die Ausrichtung durch einen separaten Drehwinkel pro Achse festgelegt. Die Drehungen folgen aufeinander und ändern die Achsen der jeweils anderen Drehungen nicht. Die Achsendrehungseigenschaften des Anzeigeobjekts bewirken eine Transformation des Ausrichtungsstils gemäß Eulerschen Winkeln. Weitere Optionen für den Ausrichtungsstil sind <codeph>axisAngle</codeph> und <codeph>quaternion</codeph>. Die Achsenwinkelausrichtung verwendet zur Bestimmung der Ausrichtung eine Kombination von Achse und Winkel. Die Achse, um die sich das Objekt dreht, ist ein Einheitsvektor, der die Richtung darstellt. Der Winkel stellt die Stärke der Drehung um den Vektor dar. Die Richtung bestimmt auch, wohin das Anzeigeobjekt zeigt und der Winkel bestimmt, wo oben liegt. Die <codeph>appendRotation()</codeph>- und <codeph>prependRotation()</codeph>-Methode verwendet die Achsenwinkelausrichtung. Die Quaternionausrichtung verwendet komplexe Zahlen und das vierte Element eines Vektors. Die Ausrichtung wird durch die drei Drehachsen (x, y, z) und den Drehwinkel (w) dargestellt. Die <codeph>interpolate()</codeph>-Methode verwendet Quaternionen.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>decompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVector"><apiName>transformVector</apiName><shortdesc>
    Verwendet die Transformationsmatrix zum Transformieren eines Vector3D-Objekts von einer Raumkoordinate zu einer anderen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Vector3D-Objekt mit den transformierten Koordinaten.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Ein Vector3D-Objekt, das die zu transformierenden Koordinaten enthält.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Verwendet die Transformationsmatrix zum Transformieren eines Vector3D-Objekts von einer Raumkoordinate zu einer anderen. Das zurückgegebene Vector3D-Objekt enthält die neuen Koordinaten nach der Transformation. Alle Matrixtransformationen einschließlich Versetzung werden auf das Vector3D-Objekt angewendet.
    
    <p>Wurde das Ergebnis der <codeph>transformVector()</codeph>-Methode auf die Position eines Anzeigeobjekts angewendet, so ändert sich nur seine Position. Die Drehungs- und Skalierungselemente des Anzeigeobjekts bleiben unverändert.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVectors"><apiName>transformVectors</apiName><shortdesc>
    Verwendet die Transformationsmatrix zum Transformieren eines Zahlenvektors von einem Koordinatenraum in einen anderen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vin</apiItemName><apiType value="Vector$Number"/><apiDesc>Ein Vektor von Zahlen, wobei jeweils drei Zahlen eine dreidimensionale Koordinate (x,y,z) bilden, die transformiert wird.
    </apiDesc></apiParam><apiParam><apiItemName>vout</apiItemName><apiType value="Vector$Number"/><apiDesc>Ein Vektor von Zahlen, wobei jeweils drei Zahlen eine transformierte dreidimensionale Koordinate (x,y,z) bilden.
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Verwendet die Transformationsmatrix zum Transformieren eines Zahlenvektors von einem Koordinatenraum in einen anderen. Die <codeph>transformVectors()</codeph>-Methode liest jeweils drei Zahlen im Vector-Objekt <codeph>vin</codeph> als eine dreidimensionale Koordinate (x,y,z) und platziert eine transformierte dreidimensionale Koordinate in das Vector-Objekt <codeph>vout</codeph>. Alle Matrixtransformationen, einschließlich der Versetzung, werden auf das Vector-Objekt <codeph>vin</codeph> angewendet. Mit der <codeph>transformVectors()</codeph>-Methode können Sie ein dreidimensionales Objekt als Gitter darstellen und transformieren. Ein Gitter ist eine Sammlung von Scheitelpunkten, die die Form des Objekts definieren.
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transpose"><apiName>transpose</apiName><shortdesc>
    Konvertiert das aktuelle Matrix3D-Objekt in eine Matrix, deren Zeilen und Spalten vertauscht sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Konvertiert das aktuelle Matrix3D-Objekt in eine Matrix, deren Zeilen und Spalten vertauscht sind. Wenn beispielsweise <codeph>rawData</codeph> des aktuellen Matrix3D-Objekts die folgenden 16 Zahlen enthält, <codeph>1,2,3,4,11,12,13,14,21,22,23,24,31,32,33,34</codeph>, so liest die <codeph>transpose()</codeph>-Methode jeweils vier Elemente als Zeilen und wandelt sie in Spalten um. Das Ergebnis ist eine Matrix mit folgenden <codeph>rawData</codeph>: <codeph>1,11,21,31,2,12,22,32,3,13,23,33,4,14,24,34</codeph>. 
    
    <p>Die <codeph>transpose()</codeph>-Methode ersetzt die aktuelle Matrix mit einer transponierten Matrix. Wenn Sie eine Matrix transponieren möchten, ohne die aktuelle Matrix zu ändern, kopieren Sie zunächst die aktuelle Matrix mithilfe der <codeph>clone()</codeph>-Methode und wenden dann die <codeph>transpose()</codeph>-Methode auf die Kopie an.</p>
    
    <p>Eine orthogonale Matrix ist eine quadratische Matrix, deren transponierte gleich ihrer invertierten Matrix ist.</p> 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix3D:determinant:get"><apiName>determinant</apiName><shortdesc>
    Eine Zahl, die festlegt, ob eine Matrix invertierbar ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
    Eine Zahl, die festlegt, ob eine Matrix invertierbar ist. 
    
    <p>Ein Matrix3D-Objekt muss invertierbar sein. Mit der <codeph>determinant</codeph>-Eigenschaft können Sie sicherstellen, dass ein Matrix3D-Objekt invertierbar ist. Wenn die Determinante null ist, ist keine invertierte Matrix vorhanden. Wenn zum Beispiel eine ganze Zeile oder Spalte einer Matrix null ist oder zwei Zeilen oder Spalten gleich sind, ist die Determinante null. Die Determinante wird auch verwendet, um eine Reihe von Gleichungen zu lösen.</p> 
    
    <p>Nur eine quadratische Matrix, wie die Matrix3D-Klasse, hat eine Determinante.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/invert()"><linktext>invert()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:position:set"><apiName>position</apiName><shortdesc>
    Ein Vector3D-Objekt, das die Position, die 3D-Koordinate (x, y, z) eines Anzeigeobjekts innerhalb des Bezugsrahmens der Transformation, enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Ein Vector3D-Objekt, das die Position, die 3D-Koordinate (x, y, z) eines Anzeigeobjekts innerhalb des Bezugsrahmens der Transformation, enthält. Die <codeph>position</codeph>-Eigenschaft gewährt unmittelbaren Zugriff auf den Versetzungsvektor der Matrix des Anzeigeobjekts, ohne dass die Matrix zerlegt und wieder zusammengesetzt werden muss. 
    
    <p>Mit der <codeph>position</codeph>-Eigenschaft können Sie auf die Versetzungselemente der Transformationsmatrix zugreifen und diese festlegen.</p>
    
    
    </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.geom.xml#position/appendTranslation()"><linktext>appendTranslation()</linktext></link><link href="" invalidHref="flash.geom.xml#position/prependTranslation()"><linktext>prependTranslation()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:rawData:get"><apiName>rawData</apiName><shortdesc>
    Ein Vektor aus 16 Zahlen, wobei jeweils vier Elemente eine Reihe oder Spalte einer 4x4-Matrix bilden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
    Ein Vektor aus 16 Zahlen, wobei jeweils vier Elemente eine Reihe oder Spalte einer 4x4-Matrix bilden. 
    
    <p>Wird die <codeph>rawData</codeph>-Eigenschaft auf eine nicht invertierbare Matrix gesetzt, so wird eine Ausnahme ausgegeben. Das Matrix3D-Objekt muss invertierbar sein. Wenn Sie eine nicht-invertierbare Matrix benötigen, erstellen Sie eine Unterklasse des Matrix3D-Objekts.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Transform"><apiName>Transform</apiName><shortdesc>
 Die Transform-Klasse erlaubt den Zugriff auf Farbanpassungseigenschaften und zwei- oder dreidimensionale Transformationsobjekte, die auf ein Anzeigeobjekt angewendet werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Erlaubt den Zugriff auf die Farbe und zwei- oder dreidimensionale Transformationsobjekte und Matrizem, die auf ein Anzeigeobjekt angewendet werden können.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Transform-Klasse erlaubt den Zugriff auf Farbanpassungseigenschaften und zwei- oder dreidimensionale Transformationsobjekte, die auf ein Anzeigeobjekt angewendet werden können. Während der Transformation wird die Farbe oder die Ausrichtung und Position eines Anzeigeobjekts von den aktuellen Werten oder Koordinaten auf neue Werte oder Koordinaten geändert (versetzt). Die Transform-Klasse sammelt auch Daten über Farb- und zweidimensionale Matrixtransformationen, die auf das Anzeigeobjekt und alle seine übergeordneten Elemente angewendet werden. Auf diese kombinierten Transformationen können Sie über die Eigenschaften <codeph>concatenatedColorTransform</codeph> und <codeph>concatenatedMatrix</codeph> zugreifen.
 
 <p>So wenden Sie Farbtransformationen an: Erstellen Sie ein ColorTransform-Objekt, stellen Sie die Farbanpassungen mit den Methoden und Eigenschaften des Objekts ein und weisen Sie dann die <codeph>colorTransformation</codeph>-Eigenschaft der <codeph>transform</codeph>-Eigenschaft des Anzeigeobjekts dem neuen ColorTransformation-Objekt zu.</p>
 
 <p>So wenden Sie zweidimensionale Transformationen an: Erstellen Sie ein Matrixobjekt, legen Sie die zweidimensionale Transformation fest und weisen Sie dann die <codeph>transform.matrix</codeph>-Eigenschaft des Anzeigeobjekts dem neuen Matrixobjekt zu.</p>
 
 <p>So wenden Sie dreidimensionale Transformationen an: Beginnen Sie mit einem dreidimensionalen Anzeigeobjekt. Die <codeph>z</codeph>-Eigenschaft eines dreidimensionalen Anzeigeobjekts weist einen von null verschiedenen Wert auf. Sie brauchen das Matrix3D-Objekt nicht zu erstellen. Für alle dreidimensionalen Objekte wird automatisch ein Matrix3D-Objekt erstellt, wenn Sie einem Anzeigeobjekt einen <codeph>z</codeph>-Wert zuweisen. Sie können über die <codeph>transform</codeph>-Eigenschaft des Anzeigeobjekts auf das Matrix3D-Objekt des Anzeigeobjekts zugreifen. Mit den Methoden der Matrix3D-Klasse können Sie Transformationseinstellungen hinzufügen oder die vorhandenen ändern. Sie können auch ein benutzerdefiniertes Matrix3D-Objekt erstellen, die Transformationselemente des benutzerdefinierten Matrix3D-Objekts einstellen und das neue Matrix3D-Objekt dann mit der <codeph>transform.matrix</codeph>-Eigenschaft dem Anzeigeobjekt zuweisen.</p>
 
 <p>So ändern Sie eine Perspektivenprojektion der Bühne oder des Stammobjekts: Verwenden Sie die <codeph>transform.matrix</codeph>-Eigenschaft des Stammanzeigeobjekts, um Zugriff auf das PerspectiveProjection-Objekt zu erlangen. Oder wenden Sie andere Perspektivenprojektionseigenschaften auf ein Anzeigeobjekt an, indem Sie die Perspektivenprojektionseigenschaften des übergeordneten Objekts des Anzeigeobjekts einstellen. Das untergeordnete Anzeigeobjekt übernimmt die neuen Eigenschaften. Erstellen Sie ein PerspectiveProjection-Objekt und stellen Sie seine Eigenschaften ein; weisen Sie das PerspectiveProjection-Objekt dann der <codeph>perspectiveProjection</codeph>-Eigenschaft der <codeph>transform</codeph>-Eigenschaft des übergeordneten Anzeigeobjekts zu. Die angegebene Projektionstransformation wird dann auf alle untergeordneten dreidimensionalen Objekte des Anzeigeobjekts angewendet.</p>
 
 <p>Da sowohl PerspectiveProjection- als auch Matrix3D-Objekte Perspektiventransformationen ausführen, sollten Sie nicht beide gleichzeitig einem Anzeigeobjekt zuweisen. Verwenden Sie das PerspectiveProjection-Objekt für Änderungen der Brennweite und der Projektionsmitte. Um die Perspektiventransformation besser steuern zu können, erstellen Sie ein Perspektivenprojektions-Matrix3D-Objekt.</p>
 
 
 </apiDesc><example conref="examples\TransformExample.as"> Im folgenden Beispiel wird mithilfe der TransformExample-Klasse die untere Seite eines quadratischen Sprites mit Farbverlaufsfüllung geneigt. Jedes Mal, wenn der Benutzer auf das Quadrat klickt, transformiert die Anwendung das Sprite, indem es dieses mithilfe der folgenden Schritte neigt:
 
 <ol>
  <li>Der <codeph>TransformExample()</codeph>-Konstruktor erstellt ein neues Sprite-Objekt mit dem Namen <codeph>target</codeph>.</li>
 
  <li>Der <codeph>TransformExample()</codeph>-Konstruktor ruft die Methode <codeph>draw()</codeph> auf, die ein Quadrat mit Farbverlaufsfüllung im Sprite zeichnet.</li>
 
  <li>Der <codeph>TransformExample()</codeph>-Konstruktor fügt dem Sprite einen click-Ereignis-Listener hinzu, der von der<codeph>clickHandler()</codeph>-Methode verarbeitet wird. </li>
 
     <li>Mithilfe der <codeph>clickHandler()</codeph>-Methode wird ein neues Matrix-Objekt erstellt (<codeph>skewMatrix</codeph>), durch das ein Neigungseffekt angewendet wird. Eine weitere Matrix (<codeph>tempMatrix</codeph>) wird der aktuellen Transformationsmatrix des Sprites zugewiesen und dann mithilfe der <codeph>concat()</codeph>-Methode mit <codeph>skewMatrix</codeph> kombiniert. Diese Matrix wird der <codeph>transform.matrix</codeph>-Eigenschaft des quadratischen Sprites zugewiesen. Jedes Mal, wenn der Benutzer auf das Quadrat klickt, wird <codeph>clickHandler()</codeph> aufgerufen, wodurch die Form des Quadrats geneigt wird.  </li>
  <li>Darüber hinaus erstellt die <codeph>clickHandler()</codeph>-Methode ein neues ColorTransform-Objekt. Die <codeph>redOffset</codeph>-Eigenschaft des neuen ColorTransform-Objekts wird auf den um 25 erhöhten aktuellen Wert von „redOffset“ gesetzt. Entsprechend wird der Wert der <codeph>blueOffset</codeph>-Eigenschaft um 25 verringert. Bei jedem Klicken ändern sich die Farben des Sprites. </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.Matrix;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class TransformExample extends Sprite {
        public function TransformExample() { 
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var skewMatrix:Matrix = new Matrix();
            skewMatrix.c = 0.25;
            var tempMatrix:Matrix = this.transform.matrix;
            tempMatrix.concat(skewMatrix);
            this.transform.matrix = tempMatrix;
            
            var rOffset:Number = this.transform.colorTransform.redOffset + 25;
            var bOffset:Number = this.transform.colorTransform.blueOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiOperation id="flash.geom:Transform:getRelativeMatrix3D"><apiName>getRelativeMatrix3D</apiName><shortdesc>
     Gibt ein Matrix3D-Objekt zurück, das den Raum eines angegebenen Anzeigeobjekts relativ zu seinem derzeitigen Raum transformiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Matrix3D-Objekt, das den Raum des <codeph>relativeTo</codeph>-Anzeigeobjekts in den Raum des aktuellen Anzeigeobjekts transformiert.
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>relativeTo</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Das Anzeigeobjekt, auf das sich die Transformation bezieht. Um ein auf die Bühne bezogenes Matrix3D-Objekt zu erhalten, setzen Sie den Parameter auf das <codeph>root</codeph>- oder <codeph>stage</codeph>-Objekt. Um ein auf die Welt bezogenes Matrix3D-Objekt zu erhalten, stellen Sie den Parameter auf ein mit einer perspektivischen Transformation verändertes Anzeigeobjekt ein.
         
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt ein Matrix3D-Objekt zurück, das den Raum eines angegebenen Anzeigeobjekts relativ zu seinem derzeitigen Raum transformiert. Mit der <codeph>getRelativeMatrix3D()</codeph>-Methode bewegen Sie ein dreidimensionales Anzeigeobjekt relativ zu einem anderen dreidimensionalen Anzeigeobjekt. 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:Transform:colorTransform:get"><apiName>colorTransform</apiName><shortdesc>
     Ein ColorTransform-Objekt mit Werten, die sämtliche Farben im Anzeigeobjekt ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the ColorTransform object <code>blueColorTransform</code> to 
    the Transform object <code>trans</code>.  This ColorTransform converts the color of the MovieClip 
    <code>rect</code> from red to blue.
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    
    var trans:Transform = new Transform(rect);
    trace(trans.colorTransform);          
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    trace(trans.colorTransform);          
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier><apiException><apiDesc>Der Wert von colorTransform lautet beim Einstellen „null“.
     
    </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Ein ColorTransform-Objekt mit Werten, die sämtliche Farben im Anzeigeobjekt ändern.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedColorTransform:get"><apiName>concatenatedColorTransform</apiName><shortdesc>
     Ein ColorTransform-Objekt, das die kombinierten auf das Anzeigeobjekt und alle übergeordneten Objekte angewendeten Farbtransformationen bis hin zur Stammebene angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to both a parent and child MovieClip.
    A <code>blueColorTransform</code> is then applied to the Transform object <code>parentTrans</code> which
    adjusts the color of both parent and child MovieClips towards blue.  Notice how <code>child.concatenatedColorTransform</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    
    trace(childTrans.concatenatedColorTransform);     
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    trace(childTrans.colorTransform);                 
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    trace(parentTrans.concatenatedColorTransform);    
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier></apiValueDef><apiDesc>
     Ein ColorTransform-Objekt, das die kombinierten auf das Anzeigeobjekt und alle übergeordneten Objekte angewendeten Farbtransformationen bis hin zur Stammebene angibt. Wenn verschiedene Farbtransformationen auf unterschiedlichen Ebenen angewendet wurden, werden diese bei dieser Eigenschaft in einem ColorTransform-Objekt verknüpft.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedMatrix:get"><apiName>concatenatedMatrix</apiName><shortdesc>
     Ein Matrix-Objekt, das die kombinierten Transformationsmatrizen des Anzeigeobjekts und aller übergeordneten Objekte bis hin zur Stammebene angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to a parent movie clip and to a child movie clip.
    A <code>scaleMatrix</code> is then applied to the Transform object <code>parentTrans</code> which
    scales both parent and child MovieClips.  Notice how <code>child.concatenatedMatrix</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.Matrix;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var scaleMatrix:Matrix = new Matrix();
    scaleMatrix.scale(2, 2);
    
    parentTrans.matrix = scaleMatrix;
    
    trace(childTrans.concatenatedMatrix);     // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(childTrans.matrix);                 // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(parentTrans.concatenatedMatrix);    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Ein Matrix-Objekt, das die kombinierten Transformationsmatrizen des Anzeigeobjekts und aller übergeordneten Objekte bis hin zur Stammebene angibt. Wenn verschiedene Transformationsmatrizen auf unterschiedlichen Ebenen angewendet wurden, werden sie für diese Eigenschaft in einer Matrix verknüpft. Bei größenveränderbaren, im Browser ausgeführten SWF-Inhalten berücksichtigt diese Eigenschaft auch den Unterschied zwischen Bühnenkoordinaten und Fensterkoordinaten, der durch die Änderung der Fenstergröße entsteht. Somit konvertiert diese Eigenschaft lokale Koordinaten in Fensterkoordinaten, die nicht notwendigerweise dem Koordinatenraum der Bühne entsprechen.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Transform:matrix:get"><apiName>matrix</apiName><shortdesc>
     Ein Matrix-Objekt mit Werten, die die Skalierung, Drehung und Versetzung des Anzeigeobjekts ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the Matrix object <code>scaleMatrix</code> to the Transform
     object <code>trans</code>.  This Matrix scales the MovieClip <code>rect</code> by a factor of two.
     <listing version="2.0">
     import flash.geom.Transform;
     import flash.geom.Matrix;
     
     var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
     
     var trans:Transform = new Transform(rect);
     trace(trans.matrix);         // (a=1, b=0, c=0, d=1, tx=0, ty=0)
          
     var scaleMatrix:Matrix = new Matrix();
     scaleMatrix.scale(2, 2);
     
     trans.matrix = scaleMatrix;
     trace(trans.matrix);         // (a=2, b=0, c=0, d=2, tx=0, ty=0)
     
     function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
     }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier><apiException><apiDesc>Die Matrix ist leer, wenn gesetzt.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Ein Matrix-Objekt mit Werten, die die Skalierung, Drehung und Versetzung des Anzeigeobjekts ändern.
     
     <p>Wenn die <codeph>matrix</codeph>-Eigenschaft auf einen Wert (nicht <codeph>null</codeph>) eingestellt ist, ist die <codeph>matrix3D</codeph>-Eigenschaft <codeph>null</codeph>. Und wenn die <codeph>matrix3D</codeph>-Eigenschaft auf einen Wert (nicht <codeph>null</codeph>) eingestellt ist, ist die <codeph>matrix</codeph>-Eigenschaft <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:matrix3D:get"><apiName>matrix3D</apiName><shortdesc>
     Erlaubt den Zugriff auf das Matrix3D-Objekt eines dreidimensionalen Anzeigeobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix3D</apiValueClassifier></apiValueDef><apiDesc>
     Erlaubt den Zugriff auf das Matrix3D-Objekt eines dreidimensionalen Anzeigeobjekts. Das Matrix3D-Objekt stellt eine Transformationsmatrix dar, die die Position und Ausrichtung des Anzeigeobjekts bestimmt. Ein Matrix3D-Objekt kann auch perspektivische Projektionen ausführen.
     
     <p>Wenn die <codeph>matrix</codeph>-Eigenschaft auf einen Wert (nicht <codeph>null</codeph>) eingestellt ist, ist die <codeph>matrix3D</codeph>-Eigenschaft <codeph>null</codeph>. Und wenn die <codeph>matrix3D</codeph>-Eigenschaft auf einen Wert (nicht <codeph>null</codeph>) eingestellt ist, ist die <codeph>matrix</codeph>-Eigenschaft <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:perspectiveProjection:get"><apiName>perspectiveProjection</apiName><shortdesc>
     Erlaubt den Zugriff auf das PerspectiveProjection-Objekt eines dreidimensionalen Anzeigeobjekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:PerspectiveProjection</apiValueClassifier></apiValueDef><apiDesc>
     Erlaubt den Zugriff auf das PerspectiveProjection-Objekt eines dreidimensionalen Anzeigeobjekts. Das PerspectiveProjection-Objekt kann verwendet werden, um die Perspektiventransformation der Bühne zu ändern oder um allen untergeordneten dreidimensionalen Objekten eines Anzeigeobjekts eine Perspektiventransformation zuzuweisen.
     
     <p>Basierend auf dem Sichtfeld und dem Seitenverhältnis (Abmessungen) der Bühne wird dem Stammobjekt ein PerspectiveProjection-Standardobjekt zugewiesen.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:pixelBounds:get"><apiName>pixelBounds</apiName><shortdesc>
     Ein Rectangle-Objekt, das das Begrenzungsrechteck des Anzeigeobjekts auf der Bühne definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Transform object <code>trans</code> and traces out
    its <code>pixelBounds</code>.  Notice that pixel bounds returns a bounding box with values 
    equal to MovieClip's <code>getBounds()</code> and <code>getRect()</code> methods.
    <listing version="2.0">
    import flash.geom.Transform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var trans:Transform = new Transform(rect);
    trace(trans.pixelBounds);         // (x=0, y=0, w=20, h=80)
    
    var boundsObj:Object = rect.getBounds();
    trace(boundsObj.xMin);            // 0
    trace(boundsObj.yMin);            // 0
    trace(boundsObj.xMax);            // 20
    trace(boundsObj.yMax);            // 80
    
    var rectObj:Object = rect.getRect();
    trace(rectObj.xMin);              // 0
    trace(rectObj.yMin);              // 0
    trace(rectObj.xMax);              // 20
    trace(rectObj.yMax);              // 80
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     Ein Rectangle-Objekt, das das Begrenzungsrechteck des Anzeigeobjekts auf der Bühne definiert.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix"><apiName>Matrix</apiName><shortdesc>
 Die Matrix-Klasse stellt eine Transformationsmatrix dar, die festlegt, wie Punkte eines Koordinatenraums einem anderen Koordinatenraum zugeordnet sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Eine standardmäßige zweidimensionale und homogene Matrix-Klasse.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Matrix-Klasse stellt eine Transformationsmatrix dar, die festlegt, wie Punkte eines Koordinatenraums einem anderen Koordinatenraum zugeordnet sind. Sie können verschiedene grafische Transformationen für ein Anzeigeobjekt durchführen, indem Sie die Eigenschaften eines Matrix-Objekts festlegen, dieses Matrix-Objekt auf die <codeph>matrix</codeph>-Eigenschaft eines Transform-Objekts anwenden und dieses Transform-Objekt dann als <codeph>transform</codeph>-Eigenschaft des Anzeigeobjekts anwenden. Die verfügbaren Transformationsfunktionen sind Schieben (<i>x</i>- und <i>y</i>-Neupositionierung), Drehen, Skalieren und Neigen. 
 
 <p>Diese Transformationsfunktionen werden als <i>affine Transformationen</i> bezeichnet. Bei affinen Transformationen bleiben gerade Linien erhalten, d. h., parallele Linien bleiben parallel.</p>
 
 <p>Wenn Sie eine Transformationsmatrix auf ein Anzeigeobjekt anwenden möchten, erstellen Sie ein Transform-Objekt, und legen Sie die entsprechende <codeph>matrix</codeph>-Eigenschaft für die Transformationsmatrix und dann die <codeph>transform</codeph>-Eigenschaft des Anzeigeobjekts für das Transform-Objekt fest. Matrix-Objekte werden auch als Parameter für bestimmte Methoden verwendet. Dazu zählen u. a. die folgenden Methoden:</p>
 
 <ul>
 
 <li>die <codeph>draw()</codeph>-Methode eines BitmapData-Objekts</li>
 
 <li>die Methoden <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> und <codeph>lineGradientStyle()</codeph> eines Graphics-Objekts</li>
 
 </ul>
 
 <p>Ein Transformationsmatrixobjekt ist eine 3x3-Matrix mit dem folgenden Inhalt:</p>
 
 <p><adobeimage alt="Eigenschaften der Matrix-Klasse in Matrixschweibweise" href="../../images/matrix_props1.jpg"/></p>
 
 <p>In herkömmlichen Transformationsmatrizen werden zusätzliche Funktionen über die Eigenschaften <codeph>u</codeph>, <codeph>v</codeph> und <codeph>w</codeph> bereitgestellt. Die Matrix-Klasse kann nur im zweidimensionalen Raum verwendet werden. Es wird daher vorausgesetzt, dass der Wert der Eigenschaften <codeph>u</codeph> und <codeph>v</codeph> 0,0 ist und der Wert der Eigenschaft <codeph>w</codeph> 1,0. Die effektiven Werte der Matrix sind wie folgt:</p>
 
 <p><adobeimage alt="Bei den Eigenschaften der Matrix-Klasse in Matrixschreibweise werden für u, v und w angenommene Werte angezeigt." href="../../images/matrix_props2.jpg"/></p>
 
 <p>Auch die Werte aller anderen sechs Eigenschaften eines Matrix-Objekts lassen sich abrufen und setzen: <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph>, <codeph>d</codeph>, <codeph>tx</codeph> und <codeph>ty</codeph>.</p>
 
 <p>Die Matrix-Klasse unterstützt die vier Haupttypen der Transformationsfunktionen: Schieben, Skalieren, Drehen und Neigen. Sie können drei dieser Transformationen über spezielle Methoden festlegen, die in der folgenden Tabelle beschrieben sind. </p>
 
 <adobetable class="innertable">
   
   
   
   
   
 <tgroup cols="5"><thead><row><entry>Transformation</entry><entry>Methode</entry><entry>Matrixwerte</entry><entry>Anzeigeergebnis</entry><entry>Beschreibung</entry></row></thead><tbody><row valign="top">
  <entry>Verschieben (Versetzen)</entry>
  <entry outputclass="nowrap"><codeph>translate(tx, ty)</codeph> </entry>
  <entry><adobeimage alt="Matrixschreibweise von translate-Methodenparametern" height="104" href="../../images/matrix_translate.jpg" width="150"/></entry>
  <entry><adobeimage alt="Darstellung von Auswirkungen der translate-Methode" height="91" href="../../images/matrix_translate_image.jpg" width="111"/></entry>
  <entry>Verschiebt das Bild um <codeph>tx</codeph> Pixel nach rechts und <codeph>ty</codeph> Pixel nach unten.</entry>
   </row><row valign="top">
  <entry>Skalieren</entry>
  <entry><codeph>scale(sx, sy)</codeph></entry>
  <entry><adobeimage alt="Matrixschreibweise von scale-Methodenparametern" height="105" href="../../images/matrix_scale.jpg" width="140"/></entry>
  <entry><adobeimage alt="Darstellung von Auswirkungen der scale-Methode" height="84" href="../../images/matrix_scale_image.jpg" width="111"/></entry>
  <entry>Ändert die Bildgröße, wobei die Position jedes Pixels mit <codeph>sx</codeph> auf der <i>x</i>-Achse und mit <codeph>sy</codeph> auf der <i>y</i>-Achse multipliziert wird.</entry>
   </row><row valign="top">
  <entry>Drehung</entry>
  <entry><codeph>rotate(q)</codeph></entry>
  <entry><adobeimage alt="Matrixschreibweise von rotate-Methodeneigenschaften" height="105" href="../../images/matrix_rotate.jpg" width="219"/></entry>
  <entry><adobeimage alt="Darstellung von Auswirkungen der rotate-Methode" height="91" href="../../images/matrix_rotate_image.jpg" width="111"/></entry>
  <entry>Dreht das Bild um den Winkel <codeph>q</codeph>, der im Bogenmaß angegeben wird.</entry>
   </row><row valign="top">
  <entry>Neigen oder Scheren </entry>
  <entry>Keine Methode. Die Eigenschaften <codeph>b</codeph> und <codeph>c</codeph> müssen festgelegt werden.</entry>
  <entry><adobeimage alt="Matrixschreibweise von Eigenschaften der skew-Funktion" href="../../images/matrix_skew.jpg"/></entry>
  <entry><adobeimage alt="Darstellung von Auswirkungen der skew-Funktion" height="77" href="../../images/matrix_skew_image.jpg" width="111"/></entry>
  <entry>Verschiebt das Bild stufenweise in paralleler Richtung zur <i>x</i>- oder <i>y</i>-Achse. Die <codeph>b</codeph>-Eigenschaft des Matrix-Objekts gibt die Tangente des Neigungswinkels entlang der <i>y</i>-Achse an und die <codeph>c</codeph>-Eigenschaft des Matrix-Objekts die Tangente des Neigungswinkels entlang der <i>x</i>-Achse.</entry>
   </row></tbody></tgroup></adobetable>
 <p>Bei jeder Transformation werden die aktuellen Matrixeigenschaften geändert. Daher können Sie mehrere Transformationen miteinander kombinieren. Rufen Sie dazu mehrere Transformationsfunktionen auf, bevor Sie die Matrix auf das entsprechende Anzeigeobjekt anwenden (mithilfe der <codeph>transform</codeph>-Eigenschaft des Anzeigeobjekts).</p>
 
 <p>Erstellen Sie mit dem <codeph>new Matrix()</codeph>-Konstruktor ein Matrix-Objekt, bevor Sie die Methoden des Matrix-Objekts aufrufen können.</p>
 
 </apiDesc><example conref="examples\MatrixExample.as"> Im folgenden Beispiel wird mithilfe der <codeph>MatrixExample</codeph>-Klasse demonstriert, wie ein großes Quadrat mit Farbverlaufsfüllung erstellt werden kann. Dies wird in den folgenden Schritten erreicht:
 <ol>
     <li>Die Anwendung erstellt ein neues Matrix-Objekt (<codeph>myMatrix</codeph>) und mithilfe der <codeph>trace()</codeph>-Methode werden die Standardeigenschaftswerte für das <codeph>myMatrix</codeph>-Objekt ausgegeben.</li>
     <li>Die Anwendung ruft <codeph>createGradientBox()</codeph> auf, wobei die Parameter <codeph>width</codeph> und <codeph>height</codeph> auf 200 Pixel gesetzt sind. Es wurde keine Drehung eingestellt, und der Abstand für die Verschiebung entlang der <i>x</i>- und <i>y</i>-Achse ist auf 50 Pixel gesetzt.</li>
     <li>Die Anwendung druckt das <codeph>myMatrix</codeph>-Objekt erneut, um die Änderungen durch den Aufruf von <codeph>createGradientBox()</codeph> zu verdeutlichen.</li>
     <li>Von der Anwendung werden drei Variablen eingerichtet, mit denen das Farbverlaufsfeld gesteuert wird:
     <ul>
         <li><codeph>colors</codeph>: Setzt die Farben des Farbverlaufs auf einen Bereich zwischen reinem Rot und reinem Blau.</li>
         <li><codeph>alphas</codeph>: Setzt die Deckkraft auf undurchsichtig.</li>
         <li><codeph>ratios</codeph>: Legt fest, dass beide Farben gleichmäßig verteilt sind.</li>
  </ul></li>
     <li>Die Anwendung ruft die Graphics-Methode <codeph>beginGradientFill()</codeph> auf, die sich auf das <codeph>myMatrix</codeph>-Objekt auswirkt. Außerdem ruft sie die <codeph>lineTo()</codeph>-Methode auf, und daraufhin wird das Feld mit Farbverlaufsfüllung erstellt.</li>
 </ol>
<codeblock>
package {
    import flash.geom.Matrix;
    import flash.display.Sprite;
    import flash.display.GradientType;

    public class MatrixExample extends Sprite {

        public function MatrixExample() {
            var myMatrix:Matrix = new Matrix();
            trace(myMatrix.toString());    // (a=1, b=0, c=0, d=1, tx=0, ty=0)

            myMatrix.createGradientBox(200, 200, 0, 50, 50);
            trace(myMatrix.toString());    // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)

            var colors:Array = [0xFF0000, 0x0000FF];
            var alphas:Array = [1, 1];
            var ratios:Array = [0, 0xFF];
            graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
            graphics.lineTo(0, 300);
            graphics.lineTo(300, 300);
            graphics.lineTo(300, 0);
            graphics.lineTo(0, 0);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiConstructor id="flash.geom:Matrix:Matrix"><apiName>Matrix</apiName><shortdesc>
    Erstellt ein neues Matrix-Objekt mit den angegebenen Parametern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
    
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Der Wert, der sich auf die Positionierung der Pixel entlang der <i>x</i>-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Wert, der sich auf die Positionierung der Pixel entlang der <i>y</i>-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.
    </apiDesc></apiParam><apiParam><apiItemName>c</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Wert, der sich auf die Positionierung der Pixel entlang der <i>x</i>-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.
    </apiDesc></apiParam><apiParam><apiItemName>d</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Der Wert, der sich auf die Positionierung der Pixel entlang der <i>y</i>-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.
    </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Strecke, um die jeder Punkt entlang der <i>x</i>-Achse geschoben werden soll.
    </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Abstand, um den jeder Punkt entlang der <i>y</i>-Achse verschoben werden soll.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt ein neues zweidimensionales Matrix-Objekt.
    
    </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
    Erstellt ein neues Matrix-Objekt mit den angegebenen Parametern. In der Matrixschreibweise sind die Eigenschaften wie folgt angeordnet:
    
    <p><adobeimage alt="Bei den Eigenschaften der Matrix-Klasse in Matrixschreibweise werden für u, v und w angenommene Werte angezeigt." href="../../images/matrix_props2.jpg"/></p>
    
    <p>Wenn Sie für den <codeph>new Matrix()</codeph>-Konstruktor keine Parameter angeben, wird eine <i>Identitätsmatrix</i> mit den folgenden Werten erstellt:</p>
    <adobetable class="innertable">
    
    
    
    <tgroup cols="2"><tbody><row>
      <entry><pre>a = 1</pre></entry>
      <entry><pre>b = 0</pre></entry>
    </row><row>
      <entry><pre>c = 0</pre></entry>
      <entry><pre>d = 1</pre></entry>
    </row><row>
      <entry><pre>tx = 0</pre></entry>
      <entry><pre>ty = 0</pre></entry>
    </row></tbody></tgroup></adobetable>
    <p>In der Matrixschreibweise sieht die Identitätsmatrix wie folgt aus:</p>
    
    <p><adobeimage alt="Eigenschaften der Matrix-Klasse in Matrixschweibweise" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc><example conref="examples\Matrix.1.as"> Im folgenden Beispiel wird <codeph>matrix_1</codeph> erstellt, indem keine Parameter an den <codeph>Matrix()</codeph>-Konstruktor gesendet werden, und <codeph>matrix_2</codeph>, indem Parameter gesendet werden. Beachten Sie, dass <codeph>matrix_1</codeph>, die ohne Parameter erstellt wurde, eine Identitätsmatrix mit den Werten <codeph>a</codeph>=1, <codeph>b</codeph>=0, <codeph>c</codeph>=0, <codeph>d</codeph>=1, <codeph>tx</codeph>=0, <codeph>ty</codeph>=0 ergibt.
<codeblock>
import flash.geom.Matrix;

var matrix_1:Matrix = new Matrix();
trace(matrix_1);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)

var matrix_2:Matrix = new Matrix(1, 2, 3, 4, 5, 6);
trace(matrix_2);  // (a=1, b=2, c=3, d=4, tx=5, ty=6)
</codeblock></example></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Matrix:clone"><apiName>clone</apiName><shortdesc>
    Gibt ein neues Matrix-Objekt zurück, das ein Klon dieser Matrix ist, mit einer exakten Kopie des enthaltenen Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>clonedMatrix</code> from <code>myMatrix</code>.
    Notice that the Matrix class does not have an equals method, so the following example
    uses a custom written function to test the equality of two Matricies.
    
    <listing version="2.0">
    import flash.geom.Matrix;
       
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
    var clonedMatrix:Matrix = new Matrix();
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // false
    
    clonedMatrix = myMatrix.clone(); 
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // true
    
    function equals(m1:Matrix, m2:Matrix):Boolean {
        return m1.toString() == m2.toString();
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Matrix-Objekt.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt ein neues Matrix-Objekt zurück, das eine Kopie der aktuellen Matrix ist.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Gibt ein neues Matrix-Objekt zurück, das ein Klon dieser Matrix ist, mit einer exakten Kopie des enthaltenen Objekts.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:concat"><apiName>concat</apiName><shortdesc>
    Verkettet eine Matrix mit der aktuellen Matrix und kombiniert auf diese Weise die geometrischen Effekte der beiden Matrizen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three Matricies that define transformations for
    three rectangle MovieClips.  The first two Matricies <code>rotate45Matrix</code>
    and <code>doubleScaleMatrix</code> are applied to the two rectangles 
    <code>rectangleMc_1</code> and <code>rectangleMc_2</code>.  Then, the third
    Matrix is created using the <code>concat()</code> method on <code>rotate45Matrix</code> and 
    <code>doubleScaleMatrix</code> to create <code>scaleAndRotateMatrix</code>. 
    This Matrix is then applied to <code>rectangleMc_3</code> to scale and rotate it.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var rectangleMc_0:MovieClip = createRectangle(20, 80, 0x000000);
    var rectangleMc_1:MovieClip = createRectangle(20, 80, 0xFF0000);   
    var rectangleMc_2:MovieClip = createRectangle(20, 80, 0x00FF00);   
    var rectangleMc_3:MovieClip = createRectangle(20, 80, 0x0000FF);
    
    var rectangleTrans_1:Transform = new Transform(rectangleMc_1);
    var rectangleTrans_2:Transform = new Transform(rectangleMc_2);
    var rectangleTrans_3:Transform = new Transform(rectangleMc_3);
    
    var rotate45Matrix:Matrix = new Matrix();
    rotate45Matrix.rotate(Math.PI/4);
    rectangleTrans_1.matrix = rotate45Matrix;
    rectangleMc_1._x = 100;
    trace(rotate45Matrix.toString());    // (a=0.707106781186548, b=0.707106781186547, c=-0.707106781186547, d=0.707106781186548, tx=0, ty=0)
    
    var doubleScaleMatrix:Matrix = new Matrix();
    doubleScaleMatrix.scale(2, 2);
    rectangleTrans_2.matrix = doubleScaleMatrix;
    rectangleMc_2._x = 200;
    trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    var scaleAndRotateMatrix:Matrix = doubleScaleMatrix.clone();
    scaleAndRotateMatrix.concat(rotate45Matrix);
    rectangleTrans_3.matrix = scaleAndRotateMatrix;
    rectangleMc_3._x = 300;
    trace(scaleAndRotateMatrix.toString());   // (a=1.4142135623731, b=1.41421356237309, c=-1.41421356237309, d=1.4142135623731, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
        var depth:Number = this.getNextHighestDepth();
        var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
        mc.beginFill(color);
        mc.lineTo(0, height);
        mc.lineTo(width, height);
        mc.lineTo(width, 0);
        mc.lineTo(0, 0);
        return mc;
    }
    
    </listing>
    
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiDesc>Die mit der Quellmatrix zu verkettende Matrix.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Verkettet eine Matrix mit der aktuellen Matrix und kombiniert auf diese Weise die geometrischen Effekte der beiden Matrizen. In mathematischer Hinsicht entspricht die Verkettung zweier Matrizen der Kombination der beiden Matrizen durch eine Matrixmultiplikation.
    
    <p>Wenn die Matrix <codeph>m1</codeph> beispielsweise ein Objekt um einen Faktor von vier skaliert und Matrix <codeph>m2</codeph> ein Objekt um einen Bogenmaßwert von 1,5707963267949 dreht (<codeph>Math.PI/2</codeph>), dann wandelt <codeph>m1.concat(m2)</codeph> <codeph>m1</codeph> in eine Matrix um, die ein Objekt um den Faktor vier skaliert und es um einen Bogenmaßwert von <codeph>Math.PI/2</codeph> dreht. </p>
    
    <p>Diese Methode ersetzt die Quellmatrix durch die verkettete Matrix. Wenn Sie zwei Matrizen ohne eine Änderung der beiden Quellmatrizen verketten möchten, kopieren Sie zuerst die Quellmatrix mit der Methode <codeph>clone()</codeph> (siehe dazu den Abschnitt mit Beispielen für Klassen).</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:createBox"><apiName>createBox</apiName><shortdesc>
     Enthält Parameter zur Skalierung, Drehung und Versetzung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Faktor für die horizontale Skalierung. 
     
     </apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Faktor für die vertikale Skalierung. 
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Drehungswert im Bogenmaß. 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Anzahl der entlang der <i>x</i>-Achse nach rechts umzusetzenden (zu verschiebenden) Pixel. 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Anzahl der entlang der <i>y</i>-Achse nach unten umzusetzenden (zu verschiebenden) Pixel.  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt ein Matrix-Objekt mit Skalierungs-, Drehungs- und Umsetzungswerten.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Enthält Parameter zur Skalierung, Drehung und Versetzung. Wenn diese Methode auf eine Matrix angewendet wird, legt sie die Werte der Matrix entsprechend diesen Parametern fest.
     
     <p>Mit der Methode <codeph>createBox()</codeph> können Sie die gleiche Matrix erstellen wie beim Anwenden der Methoden <codeph>identity()</codeph>, <codeph>rotate()</codeph>, <codeph>scale()</codeph> und <codeph>translate()</codeph> nacheinander. So hat beispielsweise <codeph>mat1.createBox(2,2,Math.PI/4, 100, 100)</codeph> denselben Effekt wie:</p>
     
     <codeblock platform="actionscript">
     import flash.geom.Matrix;
     
     var mat1:Matrix = new Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2,2);
     mat1.translate(10,20);
     </codeblock>
     
     <codeblock platform="javascript">
     var mat1 = new air.Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2, 2);
     mat1.translate(10, 20);
     </codeblock>
     
     </apiDesc><example conref="examples\Matrix_createBox.as"> Im folgenden Beispiel werden die x-Skalierung, y-Skalierung, Drehung, x-Position und y-Position von <codeph>myMatrix</codeph> gesetzt, indem die Methode <codeph>createBox()</codeph> aufgerufen wird.
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_createBox extends Sprite
    {
        public function Matrix_createBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createBox(1, 2, Math.PI/4, 50, 100);
             trace(myMatrix.toString());  
             // (a=0.7071067811865476, b=1.414213562373095, c=-0.7071067811865475, 
             //  d=1.4142135623730951, tx=100, ty=200)
             
             var rectangleShape:Shape = createRectangle(20, 80, 0xFF0000);   
             addChild(rectangleShape);
              
             var rectangleTrans:Transform = new Transform(rectangleShape);
             rectangleTrans.matrix = myMatrix;
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:createGradientBox"><apiName>createGradientBox</apiName><shortdesc>
     Erstellt den speziellen Matrixstil, der durch die beginGradientFill()- und lineGradientStyle()-Methoden der Graphics-Klasse vorgegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
     
     </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Breite des Farbverlaufsfelds.
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Höhe des Farbverlaufsfelds.
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Drehungswert im Bogenmaß. 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der entlang der <i>x</i>-Achse nach rechts zu verschiebende Abstand in Pixel. Dieser Wert wird um die Hälfte des <codeph>width</codeph>-Parameters versetzt. 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der entlang der <i>y</i>-Achse nach unten zu verschiebende Abstand in Pixel. Dieser Wert wird um die Hälfte des <codeph>height</codeph>-Parameters versetzt. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt den speziellen Matrixstil, der durch die beginGradientFill()-Methode der Graphics-Klasse vorgegeben wird.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Erstellt den speziellen Matrixstil, der durch die Methoden <codeph>beginGradientFill()</codeph> und <codeph>lineGradientStyle()</codeph> der Graphics-Klasse vorgegeben wird. Breite und Höhe werden auf ein <codeph>scaleX</codeph>/<codeph>scaleY</codeph>-Paar skaliert und die <codeph>tx</codeph>/<codeph>ty</codeph>-Werte werden um die halbe Breite und Höhe abgesetzt.
     
     <p>Dies wird an einem Beispiel für einen Farbverlauf mit den folgenden Merkmalen verdeutlicht:</p>
     
     <ul>
     
     <li><codeph>GradientType.LINEAR</codeph></li>
     <li>Zwei Farben, Grün und Blau, bei denen das ratios-Array auf <codeph>[0, 255]</codeph> gesetzt ist.</li>
     <li><codeph>SpreadMethod.PAD</codeph></li>
     <li><codeph>InterpolationMethod.LINEAR_RGB</codeph></li>
     
     </ul>
     
     <p>In den folgenden Abbildungen sind Farbverläufe, bei denen die Matrix mit der <codeph>createGradientBox()</codeph>-Methode definiert wurde, mit verschiedenen Parametereinstellungen dargestellt:</p>
     
     <adobetable class="innertable">
     
      
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry>Einstellungen für <codeph>createGradientBox()</codeph></entry><entry>Resultierender Farbverlauf</entry></row></thead><tbody><row>
     
      <entry><pre>width = 25;
     height = 25; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="daraus resultierender linearer Verlauf" href="../../images/createGradientBox-1.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 25; 
     height = 25; 
     rotation = 0; 
     tx = 25; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="daraus resultierender linearer Verlauf" href="../../images/createGradientBox-2.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50; 
     height = 50; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="daraus resultierender linearer Verlauf" href="../../images/createGradientBox-3.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50;
     height = 50; 
     rotation = Math.PI / 4; // 45 degrees
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="daraus resultierender linearer Verlauf" href="../../images/createGradientBox-4.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\Matrix_createGradientBox.as"> Im folgenden Beispiel werden die x-Skalierung, y-Skalierung, Drehung, x-Position und y-Position von <codeph>myMatrix</codeph> gesetzt, indem die Methode <codeph>createBox()</codeph> aufgerufen wird.
<codeblock>

package
{
    import flash.display.GradientType;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    
    public class Matrix_createGradientBox extends Sprite
    {
        public function Matrix_createGradientBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());          // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createGradientBox(200, 200, 0, 50, 50);
             trace(myMatrix.toString());          // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)
             
             var colors:Array = [0xFF0000, 0x0000FF];
             var alphas:Array = [100, 100];
             var ratios:Array = [0, 0xFF];
             
             this.graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
             this.graphics.drawRect(0, 0, 300, 200);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:deltaTransformPoint"><apiName>deltaTransformPoint</apiName><shortdesc>
    Diese Methode gibt für einen Punkt im noch nicht transformierten Koordinatenraum die entsprechenden Punktkoordinaten nach der Transformation zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>deltaTransformPoint()</code> method 
    to create <code>deltaTransformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method has no affect on the position of <code>deltaTransformedPoint</code>.
    In the example, however, <code>scale()</code> does affect the position.  It
    increases the original <code>x</code> value by a factor of three from 50 to 150.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);   // (50, 0)              
    
    var deltaTransformedPoint:Point = myMatrix.deltaTransformPoint(myPoint);
    trace(deltaTransformedPoint); // (150, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = deltaTransformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der sich aus der Matrixtransformation ergebende Punkt.
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt, für den das Ergebnis der Matrixtransformation abgerufen werden soll.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Diese Methode gibt für einen Punkt im noch nicht transformierten Koordinatenraum die entsprechenden Punktkoordinaten nach der Transformation zurück. Im Gegensatz zur Standardtransformation, die mithilfe der Methode <codeph>transformPoint()</codeph> angewendet wird, werden die Umsetzungsparameter <codeph>tx</codeph> und <codeph>ty</codeph> bei einer Transformation durch die Methode <codeph>deltaTransformPoint()</codeph> nicht berücksichtigt.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:identity"><apiName>identity</apiName><shortdesc>
    Setzt jede Matrixeigenschaft auf einen Wert, der zu einer Nulltransformation führt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
    </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Setzt jede Matrixeigenschaft auf einen Wert, der zu einer Nulltransformation führt. Ein durch Anwenden einer Identitätsmatrix transformiertes Objekt entspricht dem Original.
    
    <p>Nach Aufruf der Methode <codeph>identity()</codeph> hat die resultierende Matrix die folgenden Eigenschaften: <codeph>a</codeph> =1, <codeph>b</codeph> =0, <codeph>c</codeph> =0, <codeph>d</codeph> =1, <codeph>tx</codeph> =0, <codeph>ty</codeph> =0.</p>
    
    <p>In der Matrixschreibweise sieht die Identitätsmatrix wie folgt aus:</p>
    
    <p><adobeimage alt="Eigenschaften der Matrix-Klasse in Matrixschweibweise" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:invert"><apiName>invert</apiName><shortdesc>
     Führt die umgekehrte Transformation der ursprünglichen Matrix durch.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Führt die umgekehrte Transformation der ursprünglichen Matrix durch. Sie können eine umgekehrte Matrix auf ein Objekt anwenden, um die bei der Anwendung der ursprünglichen Matrix vorgenommene Transformation rückgängig zu machen.
     
     </apiDesc><example conref="examples\Matrix_invert.as"> Im folgenden Beispiel wird <codeph>halfScaleMatrix</codeph> erstellt, und zwar durch den Aufruf der Methode<codeph>invert()</codeph> aus <codeph>doubleScaleMatrix</codeph>. Anschließend wird demonstriert, dass die beiden Matrizen Umkehrungen voneinander sind, d. h., dass sie verwendet werden können, um Transformationen der jeweils anderen Matrix rückgängig zu machen, und zwar durch die Erstellung von <codeph>originalAndInverseMatrix</codeph>, die identisch ist mit <codeph>noScaleMatrix</codeph>.
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_invert extends Sprite
    {
        public function Matrix_invert()
        {
            var rect0:Shape = createRectangle(20, 80, 0xFF0000);   
            var rect1:Shape = createRectangle(20, 80, 0x00FF00);   
            var rect2:Shape = createRectangle(20, 80, 0x0000FF);
            var rect3:Shape = createRectangle(20, 80, 0x000000);
            
            var trans0:Transform = new Transform(rect0);
            var trans1:Transform = new Transform(rect1);
            var trans2:Transform = new Transform(rect2);
            var trans3:Transform = new Transform(rect3);
             
            var doubleScaleMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
            trans0.matrix = doubleScaleMatrix;
            trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
             
            var noScaleMatrix:Matrix = new Matrix(1, 0, 0, 1, 0, 0);
            trans1.matrix = noScaleMatrix;
            rect1.x = 50;
            trace(noScaleMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
            var halfScaleMatrix:Matrix = doubleScaleMatrix.clone();
            halfScaleMatrix.invert();
            trans2.matrix = halfScaleMatrix;
            rect2.x = 100;
            trace(halfScaleMatrix.toString());  // (a=0.5, b=0, c=0, d=0.5, tx=0, ty=0)
             
            var originalAndInverseMatrix:Matrix = doubleScaleMatrix.clone();
            originalAndInverseMatrix.concat(halfScaleMatrix);
            trans3.matrix = originalAndInverseMatrix;
            rect3.x = 150;
            trace(originalAndInverseMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)            
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:rotate"><apiName>rotate</apiName><shortdesc>
     Wendet eine Drehung auf das Matrix-Objekt an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example the <code>rotate()</code> method rotates <code>rectangleMc</code>
    30 degrees clockwise.  Notice that applying <code>myMatrix</code> to <code>rectangleMc</code>
    resets its <i>_x</i> value leaving us to reset it to 100 manually.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());           // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());           // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    The above example uses the <code>_x</code> property of the MovieClip object 
    to position <code>rectangleMc</code>.  Generally, when dealing with Matrix
    positioning, mixing positioning techniques is considered bad style.  The  
    example above written in good style would concatenate a translation Matrix to
    <code>myMatrix</code> to change the horizontal location of <code>rectangleMc</code>. 
    The following example demonstrates this. 
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());   // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var translateMatrix:Matrix = new Matrix();
    translateMatrix.translate(100, 0);
    myMatrix.concat(translateMatrix);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=100, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);        // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);        // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);        // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Drehwinkel im Bogenmaß.
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Wendet eine Drehung auf das Matrix-Objekt an. 
     
     <p>Durch die Methode <codeph>rotate()</codeph> werden die <codeph>a</codeph>-, <codeph>b</codeph>-, <codeph>c</codeph>- und <codeph>d</codeph>-Eigenschaften des Matrix-Objekts geändert. In der Matrixschreibweise entspricht dies der Verkettung der aktuellen Matrix mit der folgenden Matrix:</p>
     
     <p><adobeimage alt="Matrixschreibweise von scale-Methodenparametern" height="105" href="../../images/matrix_rotate.jpg" width="219"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:scale"><apiName>scale</apiName><shortdesc>
     Wendet eine Skalierung auf die Matrix an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>scale()</code> method to
    scale <code>myMatrix</code> by a factor of 3 horizontally and a factor of 4 
    vertically.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.scale(3, 4);
    trace(myMatrix.toString());   // (a=6, b=0, c=0, d=8, tx=300, ty=400)
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der <i>x</i>-Achse.
     </apiDesc></apiParam><apiParam><apiItemName>sy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ein Multiplikator zur Skalierung des Objekts entlang der <i>y</i>-Achse.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Wendet eine Skalierung auf die Matrix an. Die <i>x</i>-Achse wird mit <codeph>sx</codeph> und die <i>y</i>-Achse mit <codeph>sx</codeph> multipliziert.
     
     <p>Die Methode <codeph>scale()</codeph> ändert die <codeph>a</codeph>- und <codeph>d</codeph>-Eigenschaften des Matrix-Objekts. In der Matrixschreibweise entspricht dies der Verkettung der aktuellen Matrix mit der folgenden Matrix:</p>
     <p><adobeimage alt="Matrixschreibweise von scale-Methodenparametern" height="105" href="../../images/matrix_scale.jpg" width="140"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:toString"><apiName>toString</apiName><shortdesc>
     Gibt einen Textwert zurück, der eine Eigenschaftenliste des Matrix-Objekts enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>myMatrix</code> and converts its values 
     to a String in the format of (a=A, b=B, c=C, d=D, tx=TX, ty=TY).
     
     <listing version="2.0">
     import flash.geom.Matrix;
     
     var myMatrix:Matrix = new Matrix();
     trace("myMatrix: " + myMatrix.toString()); // (a=1, b=0, c=0, d=1, tx=0, ty=0)
     </listing>
      
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String mit den Werten für die folgenden Eigenschaften des Matrix-Objekts: <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph>, <codeph>d</codeph>, <codeph>tx</codeph> und <codeph>ty</codeph>.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt einen Textwert zurück, der die Eigenschaften des Matrix-Objekts enthält.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Gibt einen Textwert zurück, der eine Eigenschaftenliste des Matrix-Objekts enthält.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:transformPoint"><apiName>transformPoint</apiName><shortdesc>
     Gibt das Ergebnis der geometrischen Transformation, die durch das Matrix-Objekt dargestellt wird, für den angegebenen Punkt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>transformPoint()</code> method 
    to create <code>transformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method does have an affect on the position of <code>transformedPoint</code>.
    In the example, <code>scale()</code> increases the original <code>x</code> 
    value by a factor of three from 50 to 150, and <code>translate()</code> increases 
    <code>x</code> by 300 for a total value of 450.
    
    <listing version="2.0">
    import flash.geom.Matrix;     
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);                   // (50, 0)
          
    var transformedPoint:Point = myMatrix.transformPoint(myPoint);
    trace(transformedPoint);  // (450, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = transformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der sich aus der Matrixtransformation ergebende Punkt.
    
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt, für den das Ergebnis der Matrixtransformation abgerufen werden soll.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt das Ergebnis einer geometrischen Transformation für ein Point-Objekt zurück.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Gibt das Ergebnis der geometrischen Transformation, die durch das Matrix-Objekt dargestellt wird, für den angegebenen Punkt zurück. 
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:translate"><apiName>translate</apiName><shortdesc>
    Verschiebt die Matrix entsprechend den Angaben durch die Parameter „dx“ und „dy“ entlang der x- und y-Achse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>translate()</code> method to position 
    <code>rectangleMc</code> x:100 and y:50. Notice that <code>translate()</code> affects 
    the translate values <code>tx</code> and <code>ty</code> but not <code>a</code>, <code>b</code>,
    <code>c</code>, or <code>d</code>.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.translate(100, 50);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=200, ty=150)
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Verschiebung entlang der <i>x</i>-Achse nach rechts in Pixel.
    
    </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Verschiebung entlang der <i>y</i>-Achse nach unten in Pixel.
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Verschiebt die Matrix entlang der x- und y-Achse.
    
    <p>Die Methode <codeph>translate()</codeph> ändert die <codeph>tx</codeph>- und <codeph>ty</codeph>-Eigenschaften des Matrix-Objekts. In der Matrixschreibweise entspricht dies der Verkettung der aktuellen Matrix mit der folgenden Matrix:</p>
    
    <p><adobeimage alt="Matrixschreibweise von scale-Methodenparametern" height="105" href="../../images/matrix_translate.jpg" width="150"/></p>
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Verschiebt die Matrix entsprechend den Angaben durch die Parameter <codeph>dx</codeph> und <codeph>dy</codeph> entlang der <i>x</i>- und <i>y</i>-Achse.
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix:a"><apiName>a</apiName><shortdesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der x-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Der Wert, der sich auf die Positionierung der Pixel entlang der x-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der <i>x</i>-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.
     
     </apiDesc><example conref="examples\Matrix.a.1.as"> Im folgenden Beispiel wird das Matrix-Objekt <codeph>myMatrix</codeph> erstellt und der Wert der Eigenschaft <codeph>a</codeph> festgelegt.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.a);  // 1

myMatrix.a = 2;
trace(myMatrix.a);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:b"><apiName>b</apiName><shortdesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der y-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Der Wert, der sich auf die Positionierung der Pixel entlang der y-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der <i>y</i>-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.
     
     </apiDesc><example conref="examples\Matrix.b.1.as"> Im folgenden Beispiel wird das Matrix-Objekt <codeph>myMatrix</codeph> erstellt und der Wert der Eigenschaft <codeph>b</codeph> festgelegt.
<codeblock>
import flash.geom.Matrix;
 
var myMatrix:Matrix = new Matrix();
trace(myMatrix.b);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.b = Math.tan(radians);
trace(myMatrix.b);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:c"><apiName>c</apiName><shortdesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der x-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Der Wert, der sich auf die Positionierung der Pixel entlang der x-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der <i>x</i>-Achse auswirkt, wenn ein Bild gedreht oder geneigt wird.
     
     </apiDesc><example conref="examples\Matrix.c.1.as"> Im folgenden Beispiel wird das Matrix-Objekt <codeph>myMatrix</codeph> erstellt und der Wert der Eigenschaft <codeph>c</codeph> festgelegt.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.c);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.c = Math.tan(radians);
trace(myMatrix.c);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:d"><apiName>d</apiName><shortdesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der y-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Der Wert, der sich auf die Positionierung der Pixel entlang der y-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Der Wert, der sich auf die Positionierung der Pixel entlang der <i>y</i>-Achse auswirkt, wenn ein Bild skaliert oder gedreht wird.
     
     </apiDesc><example conref="examples\Matrix.d.1.as"> Im folgenden Beispiel wird das Matrix-Objekt <codeph>myMatrix</codeph> erstellt und der Wert der Eigenschaft <codeph>d</codeph> festgelegt.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.d);  // 1

myMatrix.d = 2;
trace(myMatrix.d);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:tx"><apiName>tx</apiName><shortdesc>
     Der Abstand, um den jeder Punkt entlang der x-Achse verschoben werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Der Abstand, um den jeder Punkt entlang der x-Achse verschoben werden soll.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Die Strecke, um die jeder Punkt entlang der <i>x</i>-Achse geschoben werden soll.
     
     </apiDesc><example conref="examples\Matrix.tx.1.as"> Im folgenden Beispiel wird das Matrix-Objekt <codeph>myMatrix</codeph> erstellt und der Wert der Eigenschaft <codeph>tx</codeph> wird festgelegt.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.tx);  // 0

myMatrix.tx = 50;  // 50
trace(myMatrix.tx);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:ty"><apiName>ty</apiName><shortdesc>
     Der Abstand, um den jeder Punkt entlang der y-Achse verschoben werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Der Abstand, um den jeder Punkt entlang der y-Achse verschoben werden soll.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Der Abstand, um den jeder Punkt entlang der <i>y</i>-Achse verschoben werden soll.
     
     </apiDesc><example conref="examples\Matrix.ty.1.as"> Im folgenden Beispiel wird das Matrix-Objekt <codeph>myMatrix</codeph> erstellt und der Wert der Eigenschaft <codeph>ty</codeph> festgelegt.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.ty);  // 0

myMatrix.ty = 50;
trace(myMatrix.ty);  // 50
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Rectangle"><apiName>Rectangle</apiName><shortdesc>
 Ein Rectangle-Objekt ist ein Bereich, der durch die Position seines linken oberen Eckpunkts (x, y) sowie durch seine Breite und Höhe definiert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Ein Rectangle-Objekt ist ein Bereich, der durch die Position seines linken oberen Eckpunkts (x, y) sowie durch seine Breite und Höhe definiert ist.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Ein Rectangle-Objekt ist ein Bereich, der durch die Position seines oberen linken Eckpunkts (<i>x</i>, <i>y</i>) sowie durch seine Breite und Höhe definiert ist. 
 
 <p>Die Eigenschaften <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> der Rectangle-Klasse sind voneinander unabhängig. Eine Wertänderung einer dieser Eigenschaften hat keinen Einfluss auf die anderen Eigenschaften. Die Eigenschaften <codeph>right</codeph> und <codeph>bottom</codeph> stehen jedoch im unmittelbaren Bezug zu diesen vier Eigenschaften. Wenn Sie beispielsweise den Wert der <codeph>right</codeph>-Eigenschaft ändern, ändert sich auch der Wert der <codeph>width</codeph>-Eigenschaft. Bei einer Änderung der <codeph>bottom</codeph>-Eigenschaft ändert sich auch der Wert der <codeph>height</codeph>-Eigenschaft. </p>
 
 <p platform="actionscript">Bei den folgenden Methoden und Eigenschaften werden Rectangle-Objekte verwendet:</p>
 
 <ul platform="actionscript">
 
 	<li>Die Methoden <codeph>applyFilter()</codeph>, <codeph>colorTransform()</codeph>, <codeph>copyChannel()</codeph>, <codeph>copyPixels()</codeph>, <codeph>draw()</codeph>, <codeph>fillRect()</codeph>, <codeph>generateFilterRect()</codeph>, <codeph>getColorBoundsRect()</codeph>, <codeph>getPixels()</codeph>, <codeph>merge()</codeph>, <codeph>paletteMap()</codeph>, <codeph>pixelDisolve()</codeph>, <codeph>setPixels()</codeph> und <codeph>threshold()</codeph> sowie die <codeph>rect</codeph>-Eigenschaft der BitmapData-Klasse</li>
 
 	<li>die Methoden <codeph>getBounds()</codeph> und <codeph>getRect()</codeph> sowie die Eigenschaften <codeph>scrollRect</codeph> und <codeph>scale9Grid</codeph> der DisplayObject-Klasse</li>
 
 	<li>die Methode <codeph>getCharBoundaries()</codeph> der TextField-Klasse</li>
 
 	<li>die Eigenschaft <codeph>pixelBounds</codeph> der Transform-Klasse</li>
 
 	<li>der Parameter <codeph>bounds</codeph> der <codeph>startDrag()</codeph>-Methode der Sprite-Klasse</li>
 
 	<li>der Parameter <codeph>printArea</codeph> der <codeph>addPage()</codeph>-Methode der PrintJob-Klasse</li>
 
 </ul>
 
 <p>Mit dem <codeph>new Rectangle()</codeph>-Konstruktor können Sie ein Rectangle-Objekt erstellen.</p>
 
 <p platform="actionscript"><b>Hinweis:</b> Mit der Rectangle-Klasse wird kein rechteckiges Shape-Anzeigeobjekt definiert. Wenn Sie ein rechteckiges Shape-Objekt zeichnen möchten, verwenden Sie die <codeph>drawRect()</codeph>-Methode der Graphics-Klasse.</p>
 
 </apiDesc><example conref="examples\RectangleExample.as"> Im folgenden Beispiel werden mithilfe der RectangleExample-Klasse drei neue Rectangle-Objekte an verschiedenen <i>x</i>,<i>y</i>-Koordinaten mit unterschiedlichen Höhen und Breiten erstellt. Anschließend wird die erfolgreiche Erstellung der Rectangle-Instanzen mithilfe der <codeph>trace()</codeph>-Methode bestätigt. Dann wird die boolesche Variable <codeph>isContained</codeph> dem Ergebnis zugeordnet, das sich aus dem Aufruf der <codeph>containsRect()</codeph>-Methode ergibt. Damit wird festgelegt, dass das dritte Rechteck nicht vollständig vom zweiten Rechteck eingeschlossen wird.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Rectangle;

    public class RectangleExample extends Sprite {

        public function RectangleExample() {
            var firstRect:Rectangle = new Rectangle();
            trace(firstRect);  // (x=0, y=0, w=0, h=0)
            var secondRect:Rectangle = new Rectangle(1, 3, 11, 13);
            trace(secondRect); // (x=1, y=3, w=11, h=13)
            var thirdRect:Rectangle = new Rectangle(5, 8, 17, 19);
            trace(thirdRect);  // (x=5, y=8, w=17, h=19)
            var isContained:Boolean = secondRect.containsRect(thirdRect);
            trace(isContained); // false
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/scrollRect"><linktext>flash.display.DisplayObject.scrollRect</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.text.xml#TextField/getCharBoundaries()"><linktext>flash.text.TextField.getCharBoundaries()</linktext></link><link href="flash.geom.xml#Transform/pixelBounds"><linktext>flash.geom.Transform.pixelBounds</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>flash.display.Sprite.startDrag()</linktext></link><link href="flash.printing.xml#PrintJob/addPage()"><linktext>flash.printing.PrintJob.addPage()</linktext></link></related-links><apiConstructor id="flash.geom:Rectangle:Rectangle"><apiName>Rectangle</apiName><shortdesc>
	Erstellt ein neues Rectangle-Objekt mit der angegebenen Breite und Höhe, dessen linke obere Ecke durch die Parameter x und y festgelegt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle with with specific parameters.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.toString()); // (x=5, y=10, w=50, h=100)
	</listing>
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die <i>x</i>-Koordinate der oberen linken Ecke des Rechtecks.
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die <i>y</i>-Koordinate der linken oberen Ecke des Rechtecks.
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Breite des Rechtecks in Pixel.
	</apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Höhe des Rechtecks in Pixel.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt ein neues Rectangle-Objekt mit der angegebenen Breite und Höhe, dessen linke obere Ecke durch die Parameter x und y festgelegt ist.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Erstellt ein neues Rectangle-Objekt, dessen linke obere Ecke durch die Parameter <codeph>x</codeph> und <codeph>y</codeph> festgelegt ist, und mit den angegebenen <codeph>width</codeph>- und <codeph>height</codeph>-Parametern. Wenn Sie diese Funktion ohne Parameter aufrufen, wird ein Rechteck erstellt, bei dem die Eigenschaften<codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> auf 0 gesetzt sind.
	
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Rectangle:clone"><apiName>clone</apiName><shortdesc>
	Gibt ein neues Rectangle-Objekt mit denselben Werten für die Eigenschaften „x“, „y“, „width“ und „height“ wie die des ursprünglichen Rectangle-Objekts zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the <code>clone</code> member.
	<listing version="2.0">
	import flash.geom.Rectangle;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var shadow:Rectangle = rect.clone();
	shadow.offset(5, 5);
	trace(rect); // (x=1, y=2, w=4, h=8)
	trace(shadow); // (x=6, y=7, w=4, h=8)
	</listing>

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein neues Rectangle-Objekt mit den gleichen Werten für die Eigenschaften <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> wie die des ursprünglichen Rectangle-Objekts.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt eine Kopie dieses Rectangle-Objekts zurück.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Gibt ein neues Rectangle-Objekt mit den gleichen Werten <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> wie die des ursprünglichen Rectangle-Objekts zurück.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:contains"><apiName>contains</apiName><shortdesc>
	Legt fest, ob der angegebene Punkt innerhalb des rechteckigen Bereichs liegt, der durch das Rectangle-Objekt definiert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the coordinates fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var doesContain_1:Boolean = rect.contains(59, 59);
	trace(doesContain_1); // true
	var doesContain_2:Boolean = rect.contains(10, 10);
	trace(doesContain_2); // true
	var doesContain_3:Boolean = rect.contains(60, 60);
	trace(doesContain_3); // false
	</listing>

	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn das Rectangle-Objekt den angegebenen Punkt enthält, andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>x</i>-Koordinate (horizontale Position) des Punkts.  
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>y</i>-Koordinate (vertikale Position) des Punkts.
	</apiDesc></apiParam><apiTipTexts><apiTipText>Ermittelt, ob der angegebene Punkt innerhalb des rechteckigen Bereichs liegt.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Legt fest, ob der angegebene Punkt innerhalb des rechteckigen Bereichs liegt, der durch das Rectangle-Objekt definiert ist.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsPoint"><apiName>containsPoint</apiName><shortdesc>
	Legt fest, ob der angegebene Punkt innerhalb des rechteckigen Bereichs liegt, der durch das Rectangle-Objekt definiert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the specified Points fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var containsPoint_1:Boolean = rect.containsPoint(new Point(10, 10));
	trace(containsPoint_1); // true
	var containsPoint_2:Boolean = rect.containsPoint(new Point(59, 59));
	trace(containsPoint_2); // true
	var containsPoint_3:Boolean = rect.containsPoint(new Point(60, 60));
	trace(containsPoint_3); // false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn das Rectangle-Objekt den angegebenen Punkt enthält, andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der Punkt, der durch die <i>x</i>- und <i>y</i>-Koordinaten angegeben wird.  
	</apiDesc></apiParam><apiTipTexts><apiTipText>Legt fest, ob der angegebene Punkt innerhalb des rechteckigen Bereichs liegt, der durch das Rectangle-Objekt definiert ist, bei dem ein Point-Objekt als Parameter verwendet wird.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Legt fest, ob der angegebene Punkt innerhalb des rechteckigen Bereichs liegt, der durch das Rectangle-Objekt definiert ist. Diese Methode entspricht der Methode <codeph>Rectangle.contains()</codeph>, das Point-Objekt wird jedoch als Parameter angenommen.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/contains()"><linktext>contains()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsRect"><apiName>containsRect</apiName><shortdesc>
	Legt fest, ob sich das von dem Parameter „rect“ angegebene Rectangle-Objekt innerhalb dieses Rectangle-Objekts befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>A Rectangle is said to contain another if that second 
	Rectangle falls entirely within the boundaries of the first.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectC:Rectangle = new Rectangle(10, 10, 51, 51);
	var rectD:Rectangle = new Rectangle(15, 15, 45, 45);
	var rectAContainsB:Boolean = rectA.containsRect(rectB); // true
	var rectAContainsC:Boolean = rectA.containsRect(rectC); // false
	var rectAContainsD:Boolean = rectA.containsRect(rectD); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn das angegebene Rectangle-Objekt in diesem Rectangle-Objekt enthalten ist, andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Das überprüfte Rectangle-Objekt.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Legt fest, ob sich das durch den Parameter rect angegebene Rectangle-Objekt innerhalb dieses Rectangle-Objekts befindet.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Legt fest, ob sich das von dem Parameter <codeph>rect</codeph> angegebene Rectangle-Objekt innerhalb dieses Rectangle-Objekts befindet. Ein Rechteck enthält ein anderes Rechteck, wenn Letzteres vollständig innerhalb der Grenzen des Ersteren liegt.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:equals"><apiName>equals</apiName><shortdesc>
	Legt fest, ob das im Parameter „toCompare“ angegebene Objekt und dieses Rectangle-Objekt gleich sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Even though the method signature only expects an abstract Object
	only other Rectangle instances will ever be treated as equal.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	var nonRect:Object = new Object();
	nonRect.x = 0;
	nonRect.y = 0;
	nonRect.width = 50;
	nonRect.height = 100;
	trace(rect_1.equals(nonRect));
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert <codeph>true</codeph> wenn das Objekt exakt die gleichen Werte für die Parameter <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> aufweist wie dieses Rectangle-Objekt; andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Das Rechteck, das mit diesem Rectangle-Objekt verglichen werden soll.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Legt fest, ob das im Parameter toCompare angegebene Objekt und dieses Rectangle-Objekt gleich sind.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Legt fest, ob das im Parameter <codeph>toCompare</codeph> angegebene Objekt und dieses Rectangle-Objekt gleich sind. Bei dieser Methode wird ein Objekt anhand der gleichen Eigenschaften <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> mit diesem Rectangle-Objekt verglichen.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflate"><apiName>inflate</apiName><shortdesc>
	Vergrößert das Rectangle-Objekt um die in Pixeln angegebenen Werte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and increase its <code>width</code> by 16 ~~ 2 (32) and it's <code>height</code> by 32 ~~ 2 (64)
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.toString()); // (x=1, y=2, w=4, h=8)
	rect.inflate(16, 32);
	trace(rect.toString()); // (x=-15, y=-30, w=36, h=72)	
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Wert, der links und rechts zum Rectangle-Objekt addiert wird. Zur Berechnung der neuen Breite und Position des Rechtecks wird die folgende Gleichung verwendet:
	
	<codeblock>
	x -= dx;
	width += 2 ~~ dx;
	</codeblock>
	
	</apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Wert, der oben und unten zum Rectangle-Objekt addiert wird. Zur Berechnung der neuen Höhe und Position des Rechtecks wird die folgende Gleichung verwendet:
	
	<codeblock>
	y -= dy;
	height += 2 ~~ dy;
	</codeblock>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vergrößert das Rectangle-Objekt um die in Pixeln angegebenen Werte. Der Mittelpunkt des Rectangle-Objekts bleibt gleich, und die Größe wird mit dem Wert <codeph>dx</codeph> nach links und rechts und mit dem Wert <codeph>dy</codeph> nach oben und unten erweitert.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflatePoint"><apiName>inflatePoint</apiName><shortdesc>
	 Ändert die Größe des Rectangle-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and inflate it by the <i>x</i> <i>horizontal</i> and <i>y</i> <i>vertical</i> amounts found in Point
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(0, 0, 2, 5);
	 var myPoint:Point = new Point(2, 2);
	 rect.inflatePoint(myPoint);
	 trace(rect.toString()); // (x=-2, y=-2, w=6, h=9)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Mit der <codeph>x</codeph>-Eigenschaft dieses Point-Objekts wird die horizontale Abmessung des Rectangle-Objekts vergrößert. Mit der <codeph>y</codeph>-Eigenschaft wird die vertikale Abmessung des Rectangle-Objekts vergrößert.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Vergrößert das Rectangle-Objekt mit einem Point-Objekt als Parameter.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Ändert die Größe des Rectangle-Objekts. Diese Methode ähnelt der Methode <codeph>Rectangle.inflate()</codeph>, als Parameter wird jedoch ein Point-Objekt verwendet.
	 
	  <p>Die folgenden beiden Codebeispiele führen zum gleichen Ergebnis:</p>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 var pt1:Point = new Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 var pt1 = new air.Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:intersection"><apiName>intersection</apiName><shortdesc>
	Wenn sich das im Parameter toIntersect angegebene Rectangle-Objekt mit diesem Rectangle-Objekt überschneidet, gibt die Methode die Schnittfläche als Rectangle-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>What area overlaps <code>rect_1</code> between <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 50);
	var rect_2:Rectangle = new Rectangle(25, 25, 100, 100);
	var intersectingArea:Rectangle = rect_1.intersection(rect_2);
	trace(intersectingArea.toString()); // (x=25, y=25, w=25, h=25)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Rectangle-Objekt, das der Schnittfläche entspricht. Wenn sich die Rechtecke nicht überschneiden, wird mit dieser Methode ein leeres Rectangle-Objekt zurückgegeben. Dabei handelt es sich um Rechteck, bei dem die Eigenschaften <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> auf 0 gesetzt sind.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Das Rectangle-Objekt, bei dem überprüft werden soll, ob es sich mit diesem Rectangle-Objekt überschneidet.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Schnittfläche zurück.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Wenn sich das im Parameter <codeph>toIntersect</codeph> angegebene Rectangle-Objekt mit diesem Rectangle-Objekt überschneidet, gibt die Methode die Schnittfläche als Rectangle-Objekt zurück. Wenn sich die Rechtecke nicht überschneiden, wird mit dieser Methode ein leeres Rectangle-Objekt zurückgegeben, dessen Eigenschaften auf 0 gesetzt sind.
	
    <p><adobeimage alt="Das sich daraus übergebende Übeschneidungs-Rechteck." href="../../images/rectangle_intersect.jpg"/></p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:intersects"><apiName>intersects</apiName><shortdesc>
	Legt fest, ob sich das im Parameter „toIntersect“ angegebene Objekt mit diesem Rectangle-Objekt überschneidet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Does <code>rect_1</code> intersect with <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(59, 59, 50, 50);
	var rectC:Rectangle = new Rectangle(60, 60, 50, 50);
	var rectAIntersectsB:Boolean = rectA.intersects(rectB);
	var rectAIntersectsC:Boolean = rectA.intersects(rectC);
	trace(rectAIntersectsB); // true
	trace(rectAIntersectsC); // false
	
	var firstPixel:Rectangle = new Rectangle(0, 0, 1, 1);
	var adjacentPixel:Rectangle = new Rectangle(1, 1, 1, 1);
	var pixelsIntersect:Boolean = firstPixel.intersects(adjacentPixel);
	trace(pixelsIntersect); // false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn sich das angegebene Objekt mit dem Rectangle-Objekt überschneidet, andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Das Rectangle-Objekt, das mit diesem Rectangle-Objekt verglichen werden soll. 
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Legt fest, ob sich das im Parameter toIntersect angegebene Objekt mit diesem Rectangle-Objekt überschneidet.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Legt fest, ob sich das im Parameter <codeph>toIntersect</codeph> angegebene Objekt mit diesem Rectangle-Objekt überschneidet. Bei dieser Methode wird anhand der Eigenschaften <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> des angegebenen Rectangle-Objekts überprüft, ob es sich mit diesem Rectangle-Objekt überschneidet.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:isEmpty"><apiName>isEmpty</apiName><shortdesc>
	Legt fest, ob dieses Rectangle-Objekt leer ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it become empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.isEmpty()); // false
	rect.width = 0;
	trace(rect.isEmpty()); // true
	rect.width = 4;
	trace(rect.isEmpty()); // false
	rect.height = 0;
	trace(rect.isEmpty()); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert <codeph>true</codeph>, wenn die Breite oder Höhe des Rectangle-Objekts kleiner oder gleich 0 ist, andernfalls <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Legt fest, ob dieses Rectangle-Objekt leer ist. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offset"><apiName>offset</apiName><shortdesc>
	 Ändert die Position des Rectangle-Objekts ausgehend von seiner oberen linken Ecke um die angegebenen Beträge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and offset it's <i>x</i> and <i>y</i> values by 5 and 10 respectively
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	 rect.offset(16, 32);
	 trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Verschiebt den Wert <i>x</i> des Rectangle-Objekts um diesen Wert.
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Verschiebt den Wert <i>y</i> des Rectangle-Objekts um diesen Wert.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Ändert die Position des Rectangle-Objekts.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Ändert die Position des Rectangle-Objekts ausgehend von seiner oberen linken Ecke um die angegebenen Beträge.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offsetPoint"><apiName>offsetPoint</apiName><shortdesc>
	 Ändert die Position des Rectangle-Objekts, wobei ein Point-Objekt als Parameter dient.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Offset a Rectangle by using the values found in a Point
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var myPoint:Point = new Point(16, 32);
	rect.offsetPoint(myPoint);
	trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Ein Point-Objekt, mit dem dieses Rectangle-Objekt versetzt werden kann.
	 
	</apiDesc></apiParam><apiTipTexts><apiTipText>Ändert die Position des Rectangle-Objekts, wobei ein Point-Objekt als Parameter dient.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Ändert die Position des Rectangle-Objekts, wobei ein Point-Objekt als Parameter dient. Diese Methode entspricht der Methode <codeph>Rectangle.offset()</codeph>, das Point-Objekt wird jedoch als Parameter angenommen.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:setEmpty"><apiName>setEmpty</apiName><shortdesc>
	Setzt alle Eigenschaften des Rectangle-Objekts auf 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.isEmpty()); // false
	rect.setEmpty();
	trace(rect.isEmpty()); // true
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Setzt alle Eigenschaften auf 0.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Setzt alle Eigenschaften des Rectangle-Objekts auf 0. Ein Rectangle-Objekt ist leer, wenn seine Breite oder Höhe kleiner oder gleich 0 ist.
	
	<p> Diese Methode setzt die Werte der Eigenschaften <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> auf 0.</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:toString"><apiName>toString</apiName><shortdesc>
	Erstellt und übergibt einen String, der die horizontalen und vertikalen Positionen sowie die Breite und Höhe des Rectangle-Objekts enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Concatenate a String representation of <code>rect_1</code> with some helpful 
	debugging text.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	trace("Rectangle 1 : " + rect_1.toString()); // Rectangle 1 : (x=0, y=0, w=50, h=100)
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, der die Werte der folgenden Eigenschaften des Rectangle-Objekts angibt: <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph>.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Erstellt und übergibt einen String, der die horizontalen und vertikalen Positionen sowie die Breite und Höhe des Rectangle-Objekts enthält.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:union"><apiName>union</apiName><shortdesc> 
	 Vereinigt zwei Rechtecke miteinander, indem der vertikale und horizontale Bereich zwischen ihnen gefüllt wird, sodass ein neues Rectangle-Objekt entsteht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle out of the Union of two others.
	<p>For example, consider a rectangle with properties <code>x=20</code>, <code>y=50</code>, <code>width=60</code>, and 
	<code>height=30</code> (20, 50, 60, 30) and a second rectangle with properties (150, 130, 50, 30). 
	The union of these two rectangles would be a larger rectangle encompassing the two rectangles 
	with the properties (20, 50, 180, 110).</p>
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(20, 50, 60, 30);
	var rect_2:Rectangle = new Rectangle(150, 130, 50, 30);
	var combined:Rectangle = rect_1.union(rect_2);
	trace(combined.toString()); // (x=20, y=50, w=180, h=110)
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein neues Rectangle-Objekt aus der Vereinigung der beiden Rechtecke.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toUnion</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Ein Rectangle-Objekt, das diesem Rectangle-Objekt hinzugefügt wird.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Fügt zwei Rechtecke zusammen und erstellt so ein neues Rectangle-Objekt.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc> 
	 Vereinigt zwei Rechtecke miteinander, indem der vertikale und horizontale Bereich zwischen ihnen gefüllt wird, sodass ein neues Rectangle-Objekt entsteht.
	 
    <p><adobeimage alt="Das sich daraus übergebende Vereinigungs-Rechteck." href="../../images/rectangle_union.jpg"/></p>
	<p><b>Hinweis:</b> Die <codeph>union()</codeph>-Methode ignoriert Rechtecke mit dem Höhen- oder Breitenwert <codeph>0</codeph>, wie beispielsweise: <codeph>var rect2:Rectangle = new Rectangle(300,300,50,0);</codeph></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Rectangle:height"><apiName>height</apiName><shortdesc>
	Die Höhe des Rechtecks in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>width</i> property 
	from 10 to 20. Notice that <code>rect.right</code> is also
	changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Höhe des Rechtecks in Pixel.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die Höhe des Rechtecks in Pixel. Änderungen des Werts <codeph>height</codeph> eines Rectangle-Objekts haben keinen Einfluss auf die Eigenschaften <codeph>x</codeph>, <codeph>y</codeph> und <codeph>width</codeph>.
	
    <p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:width"><apiName>width</apiName><shortdesc>
	Die Breite des Rechtecks in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Rectangle object and change its <code>width</code> property 
	from 10 to 20. Notice that <code>rect.right</code> also
	changes.

	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Breite des Rechtecks.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die Breite des Rechtecks in Pixel. Änderungen des Werts <codeph>width</codeph> eines Rectangle-Objekts haben keinen Einfluss auf die Eigenschaften <codeph>x</codeph>, <codeph>y</codeph> und <codeph>height</codeph>.
	
	<p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:x"><apiName>x</apiName><shortdesc>
	Die x-Koordinate der linken oberen Ecke des Rechtecks.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>x</i> property 
	to 10. Notice that <code>rect.left</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.x); // 0
	trace(rect.left); // 0
	rect.x = 10;
	trace(rect.x); // 10
	trace(rect.left); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die x-Koordinate der linken oberen Ecke des Rechtecks.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die <i>x</i>-Koordinate der oberen linken Ecke des Rechtecks. Änderungen des Werts der Eigenschaft <codeph>x</codeph> eines Rectangle-Objekts wirken sich nicht auf die Eigenschaften <codeph>y</codeph>, <codeph>width</codeph> und <codeph>height</codeph> aus. 
	
	<p>Der Wert der Eigenschaft <codeph>x</codeph> entspricht dem Wert der Eigenschaft <codeph>left</codeph>.</p>
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/left"><linktext>left</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:y"><apiName>y</apiName><shortdesc>
	Die y-Koordinate der linken oberen Ecke des Rechtecks.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>y</i> property
	to 10. Notice that <code>rect.top</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.y); // 0
	trace(rect.top); // 0
	rect.y = 10;
	trace(rect.y); // 10
	trace(rect.top); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die y-Koordinate der linken oberen Ecke.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die <i>y</i>-Koordinate der linken oberen Ecke des Rechtecks. Änderungen des Werts der Eigenschaft <codeph>y</codeph> eines Rectangle-Objekts wirken sich nicht auf die Eigenschaften <codeph>x</codeph>, <codeph>width</codeph> und <codeph>height</codeph> aus.
	
	<p>Der Wert der Eigenschaft <codeph>y</codeph> entspricht dem Wert der Eigenschaft <codeph>top</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link><link href="flash.geom.xml#Rectangle/top"><linktext>top</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottom:get"><apiName>bottom</apiName><shortdesc>
	Die Summe der Eigenschaften y und height.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>bottom</i> property 
	from 15 to 30. Notice that <code>rect.height</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.height); // 10
	trace(rect.bottom); // 15
	rect.bottom = 30;
	trace(rect.height); // 25
	trace(rect.bottom); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Summe der Eigenschaften y und height.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die Summe der Eigenschaften <codeph>y</codeph> und <codeph>height</codeph>.
	
    <p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottomRight:get"><apiName>bottomRight</apiName><shortdesc>
	Die Position der rechten unteren Ecke des Rectangle-Objekts, definiert durch die Werte der Eigenschaften right und bottom.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>bottomRight</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.bottom); // 5
	trace(rect.right); // 10
	var myBottomRight:Point = rect.bottomRight;
	trace(myBottomRight.x); // 5
	trace(myBottomRight.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>Die Position der rechten unteren Ecke des Rectangle-Objekts, die durch die Eigenschaften right und bottom angegeben wird.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die Position der rechten unteren Ecke des Rectangle-Objekts, die durch die Werte der Eigenschaften <codeph>right</codeph> und <codeph>bottom</codeph> angegeben wird.
	
    <p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:left:get"><apiName>left</apiName><shortdesc>
	Die x-Koordinate der linken oberen Ecke des Rechtecks.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>left</i> property and notice that 
	<code>rect.x</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.left); // 0
	trace(rect.x); // 0
	rect.left = 10;
	trace(rect.left); // 10
	trace(rect.x); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die x-Koordinate der linken oberen Ecke des Rechtecks.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die <i>x</i>-Koordinate der oberen linken Ecke des Rechtecks. Änderungen der Eigenschaft <codeph>left</codeph> eines Rectangle-Objekts wirken sich nicht auf die Eigenschaften <codeph>y</codeph> und <codeph>height</codeph> aus. Sie wirken sich jedoch auf die Eigenschaft <codeph>width</codeph> aus; Änderungen des Werts <codeph>x</codeph> betreffen dagegen <i>nicht</i> die Eigenschaft <codeph>width</codeph>.
	
	<p>Der Wert der Eigenschaft <codeph>left</codeph> entspricht dem Wert der Eigenschaft <codeph>x</codeph>.</p>
	
	
    <p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:right:get"><apiName>right</apiName><shortdesc>
	Die Summe der Eigenschaften x und width.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>right</i> property 
	from 15 to 30. Notice that <code>rect.width</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.right = 30;
	trace(rect.width); // 25
	trace(rect.right); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Summe der Eigenschaften x und width.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die Summe der Eigenschaften <codeph>x</codeph> und <codeph>width</codeph>.
	
    <p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:size:get"><apiName>size</apiName><shortdesc>
	Die Größe des Rectangle-Objekts, ausgedrückt als Point-Objekt, mit den Werten der Eigenschaften width und height.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Rectangle, retrieves it's <code>size</code>,
	changes the <code>size</code> and sets the new values on the Rectangle instance.
	It is critical to remember that the <code>Point</code> object used by <code>size</code>
	uses x and y values to represent the <code>width</code> and <code>height</code> properties
	of the Rectangle.
	<listing version="2.0">
	import flash.geom.Rectangle;
	import flash.geom.Point;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	
	var size:Point = rect.size;
	trace(size.x); // 4;
	trace(size.y); // 8;
	
	size.x = 16;
	size.y = 32;
	rect.size = size;
	trace(rect.x); // 1
	trace(rect.y); // 2
	trace(rect.width); // 16
	trace(rect.height); // 32
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>Die Größe des Rectangle“-Objekts, angegeben als Point-Objekt mit Werten für width und height.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die Größe des Rectangle-Objekts, ausgedrückt als Point-Objekt, mit <codeph>width</codeph>- und <codeph>height</codeph>-Werten.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:top:get"><apiName>top</apiName><shortdesc>
	Die y-Koordinate der linken oberen Ecke des Rechtecks.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>top</i> property and notice that 
	<code>rect.y</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.top); // 0
	trace(rect.y); // 0
	rect.top = 10;
	trace(rect.top); // 10
	trace(rect.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die y-Koordinate der linken oberen Ecke des Rechtecks.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die <i>y</i>-Koordinate der linken oberen Ecke des Rechtecks. Änderungen der Eigenschaft <codeph>top</codeph> eines Rectangle-Objekts wirken sich nicht auf die Eigenschaften <codeph>x</codeph> und <codeph>width</codeph> aus. Sie wirken sich jedoch auf die Eigenschaft <codeph>height</codeph> aus; Änderungen des Werts <codeph>y</codeph> betreffen dagegen <i>nicht</i> die Eigenschaft <codeph>height</codeph>.
	
	<p>Der Wert der Eigenschaft <codeph>top</codeph> entspricht dem Wert der Eigenschaft <codeph>y</codeph>.</p>
	
    <p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:topLeft:get"><apiName>topLeft</apiName><shortdesc>
	Die Position der linken oberen Ecke des Rectangle-Objekts, die durch den x- und y-Wert des Punkts angegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>topLeft</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(5, 15);
	var myTopLeft:Point = rect.topLeft;
	trace(myTopLeft.x); // 5;
	trace(myTopLeft.y); // 15;
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>Die Position der linken oberen Ecke des Rectangle-Objekts, die durch den x- und y-Wert des Punkts angegeben wird.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Die Position der linken oberen Ecke des Rectangle-Objekts, die durch die <i>x</i>- und <i>y</i>-Koordinate des Punkts angegeben wird.
	
    <p><adobeimage alt="Ein Bild eines Rechtecks, das Standort- und Abmessungseigenschaften anzeigt." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
 Mit der ColorTransform-Klasse können Sie die Farbwerte in einem Anzeigeobjekt ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der ColorTransform-Klasse können Sie die Farbwerte in einem Anzeigeobjekt ändern. Die auch als <i>Farbtransformation</i> bezeichnete Farbanpassungsfunktion kann auf alle vier Kanäle angewendet werden: Rot, Grün, Blau oder Alpha-Transparenz.
 
 <p>Wenn ein ColorTransform-Objekt auf ein Anzeigeobjekt angewendet wird, wird der neue Wert der einzelnen Farbkanäle folgendermaßen berechnet:</p>
 
 <ul>
 <li>Neuer Rotwert = (Alter Rotwert * <codeph>redMultiplier</codeph>) + <codeph>redOffset</codeph></li>
 <li>Neuer Grünwert = (Alter Grünwert * <codeph>greenMultiplier</codeph>) + <codeph>greenOffset</codeph></li>
 <li>Neuer Blauwert = (Alter Blauwert * <codeph>blueMultiplier</codeph>) + <codeph>blueOffset</codeph></li>
 <li>Neuer Alphawert = (Alter Alphawert * <codeph>alphaMultiplier</codeph>) + <codeph>alphaOffset</codeph></li>
 </ul>
 
 <p>Wenn einer der Farbkanalwerte nach der Berechnung größer als 255 ist, wird er auf 255 gesetzt. Wenn ein Wert kleiner 0 ist, wird er auf 0 gesetzt.</p>
 
 <p>Sie können ColorTransform-Objekte folgendermaßen verwenden:</p>
 
 <ul>
 
 	<li>im Parameter <codeph>colorTransform</codeph> für die <codeph>colorTransform()</codeph>-Methode der BitmapData-Klasse</li>
 
 	<li>als <codeph>colorTransform</codeph>-Eigenschaft eines Transform-Objekts (das als <codeph>transform</codeph>-Eigenschaft eines Anzeigeobjekts verwendet werden kann)</li>
 
 </ul>
 
 <p>Bevor Sie die Methoden des ColorTransform-Objekts aufrufen können, müssen Sie zuerst ein ColorTransform-Objekt mithilfe des <codeph>new ColorTransform()</codeph>-Konstruktors erstellen.</p>
 
 <p>Farbtransformationen können nicht auf die Hintergrundfarbe eines Movieclips (z. B. eines geladenen SWF-Objekts) angewendet werden. Sie gelten nur für Grafiken und Symbole, die mit dem Movieclip verknüpft sind.</p>
 
 </apiDesc><example conref="examples\ColorTransformExample.as"> Im folgenden Beispiel wird mithilfe der TransformExample-Klasse ein einfaches Sprite in Form eines Quadrats mit Farbverlaufsfüllung erstellt. Bei jedem Klicken des Benutzers auf das Quadrat werden die Farben des quadratischen Sprites transformiert, und zwar wird der Wert des Rotkanals erhöht und der Wert des Blaukanals gesenkt. Dies wird in den folgenden Schritten erreicht:
 
 <ol>
     <li>Der Konstruktor erstellt ein neues Sprite-Objekt <codeph>target</codeph>.</li>
 
     <li>Der <codeph>CustomButton()</codeph>-Konstruktor ruft die <codeph>draw()</codeph>-Methode auf, die ein Quadrat mit Farbverlaufsfüllung im Sprite zeichnet.</li>
 
     <li>Der <codeph>CustomButton()</codeph>-Konstruktor fügt einen click-Ereignis-Listener für das Sprite hinzu, der von der <codeph>clickHandler()</codeph>-Methode verarbeitet wird.  </li>
 
     <li>In der <codeph>clickHandler()</codeph>-Methode wurden zwei Eigenschaften auf die <codeph>redOffset</codeph>- und <codeph>blueOffset</codeph>-Eigenschaften der aktuellen Farbtransformation gesetzt. Bei beiden wurde der Wert um 25 geändert. Anschließend werden die neuen Offset-Werte der <codeph>transform.colorTransform</codeph>-Eigenschaft des quadratischen Sprites zugewiesen. Bei jedem Klicken des Benutzers auf das Quadrat wird die <codeph>clickHandler()</codeph>-Methode aufgerufen. Dadurch wird die Farbe des Quadrats geändert, da der Wert des Rotkanals erhöht und der Wert des Blaukanals gesenkt wird.  </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class ColorTransformExample extends Sprite {
        public function ColorTransformExample() {
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var rOffset:Number = transform.colorTransform.redOffset + 25;
            var bOffset:Number = transform.colorTransform.redOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);
        }
    }
}    
</codeblock></example></apiClassifierDetail><related-links><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.display.xml#BitmapData/colorTransform()"><linktext>flash.display.BitmapData.colorTransform()</linktext></link></related-links><apiConstructor id="flash.geom:ColorTransform:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
	 Erstellt von einem Anzeigeobjekt anhand der angegebenen Farb- und Alphakanalparameter ein ColorTransform-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new ColorTransform, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Wert des Multiplikators für den Rotkanal im Bereich zwischen 0 und 1.
	 </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Wert des Multiplikators für den Grünkanal im Bereich zwischen 0 und 1.
	 </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Wert des Multiplikators für den Blaukanal zwischen 0 und 1.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Der Wert des Multiplikators für den Alphatransparenzkanal im Bereich zwischen 0 und 1.
	 </apiDesc></apiParam><apiParam><apiItemName>redOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Offset-Wert für den Rotkanal zwischen -255 und 255.
	 </apiDesc></apiParam><apiParam><apiItemName>greenOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Offset-Wert für den Grünkanal im Bereich zwischen -255 und 255.
	 </apiDesc></apiParam><apiParam><apiItemName>blueOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Offset-Wert für den Blaukanal zwischen -255 und 255.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Offset-Wert für den Alphatransparenzkanal zwischen -255 und 255.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Erstellt ein ColorTransform-Objekt für ein Anzeigeobjekt.
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Erstellt von einem Anzeigeobjekt anhand der angegebenen Farb- und Alphakanalparameter ein ColorTransform-Objekt. 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:ColorTransform:concat"><apiName>concat</apiName><shortdesc>
	 Verkettet das durch den „second“-Parameter angegebene ColorTransform-Objekt mit dem aktuellen ColorTransform-Objekt und legt das aktuelle Objekt als Ergebnis fest. Dabei handelt es sich um eine additive Kombination der beiden Farbtransformationen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example concatenates the ColorTransform object <code>colorTrans_2</code>
	to <code>colorTrans_1</code> resulting in a full red offset combined with a .5 alpha multiplier.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans_1:ColorTransform = new ColorTransform(1, 1, 1, 1, 255, 0, 0, 0);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var colorTrans_2:ColorTransform = new ColorTransform(1, 1, 1, .5, 0, 0, 0, 0);
	trace(colorTrans_2);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	colorTrans_1.concat(colorTrans_2);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans_1;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>Das ColorTransform-Objekt, das mit dem aktuellen ColorTransform-Objekt kombiniert wird.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Verkettet das durch den Parameter <codeph>second</codeph> angegebene ColorTransform-Objekt mit dem aktuellen ColorTransform-Objekt und legt das aktuelle Objekt als Ergebnis fest. Dabei handelt es sich um eine additive Kombination der beiden Farbtransformationen. Die Anwendung des verketteten ColorTransform-Objekts hat die gleichen Auswirkungen wie die Anwendung der <codeph>second</codeph>-Farbtransformation nach der <i>original</i>-Farbtransformation.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:ColorTransform:toString"><apiName>toString</apiName><shortdesc>
	 Formatiert und gibt einen String zurück, der alle Eigenschaften des ColorTransform-Objekts beschreibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and calls its <code>toSting()</code> method.  This method results in a string with the format
	(redMultiplier=RM, greenMultiplier=GM, blueMultiplier=BM, alphaMultiplier=AM, redOffset=RO, greenOffset=GO, blueOffset=BO, alphaOffset=AO).
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform(1, 2, 3, 4, -255, -128, 128, 255);
 	trace(colorTrans.toString());		// (redMultiplier=1, greenMultiplier=2, blueMultiplier=3, alphaMultiplier=4, redOffset=-255, greenOffset=-128, blueOffset=128, alphaOffset=255)
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, der alle Eigenschaften des ColorTransform-Objekts angibt.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Formatiert und gibt einen String zurück, der alle Eigenschaften des ColorTransform-Objekts beschreibt.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:ColorTransform:alphaMultiplier"><apiName>alphaMultiplier</apiName><shortdesc>
	 Ein Dezimalwert, der mit dem Wert des Alphatransparenzkanals multipliziert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	import flash.geom.Transform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaMultiplier);		// 1
	
	colorTrans.alphaMultiplier = .5;	
	trace(colorTrans.alphaMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Dezimalwert, der mit dem Wert des Alphatransparenzkanals multipliziert wird.
	 
	 <p>Wenn Sie den Alphatransparenzwert eines Anzeigeobjekts direkt über die <codeph>alpha</codeph>-Eigenschaft der DisplayObject-Instanz festlegen, ändert sich dadurch der Wert der <codeph>alphaMultiplier</codeph>-Eigenschaft der <codeph>transform.colorTransform</codeph>-Eigenschaft des Anzeigeobjekts.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/alpha"><linktext>flash.display.DisplayObject.alpha</linktext></link></related-links></apiValue><apiValue id="flash.geom:ColorTransform:alphaOffset"><apiName>alphaOffset</apiName><shortdesc>
	 Eine Zahl zwischen -255 und 255, die zum Alphakanalwert addiert wird, nachdem dieser mit dem „alphaMultiplier“-Wert multipliziert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaOffset</code> from 0 to -128.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaOffset);			// 0
	
	colorTrans.alphaOffset = -128;
	trace(colorTrans.alphaOffset);			// -128
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine Zahl zwischen -255 und 255, die zum Alphakanalwert addiert wird, nachdem dieser mit dem „alphaMultiplier“-Wert multipliziert wurde.
   	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Eine Zahl zwischen -255 und 255, die zum Alphakanalwert addiert wird, nachdem dieser mit dem <codeph>alphaMultiplier</codeph>-Wert multipliziert wurde.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueMultiplier"><apiName>blueMultiplier</apiName><shortdesc>
	 Ein Dezimalwert, der mit dem Wert des Blaukanals multipliziert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueMultiplier);		// 1
	
	colorTrans.blueMultiplier = .5;
	trace(colorTrans.blueMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x0000FF);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Dezimalwert, der mit dem Wert des Blaukanals multipliziert wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueOffset"><apiName>blueOffset</apiName><shortdesc>
	 Eine Zahl zwischen -255 und 255, die zum Blau-Kanalwert addiert wird, nachdem dieser mit dem „blueMultiplier“-Wert multipliziert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueOffset);			// 0
	
	colorTrans.blueOffset = 255;
	trace(colorTrans.blueOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine Zahl zwischen -255 und 255, die zum Blau-Kanalwert addiert wird, nachdem dieser mit dem „blueMultiplier“-Wert multipliziert wurde.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Eine Zahl zwischen -255 und 255, die zum Blaukanalwert addiert wird, nachdem dieser mit dem <codeph>blueMultiplier</codeph>-Wert multipliziert wurde.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenMultiplier"><apiName>greenMultiplier</apiName><shortdesc>
	 Ein Dezimalwert, der mit dem Wert des Grünkanals multipliziert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenMultiplier);		// 1
	
	colorTrans.greenMultiplier = .5;
	trace(colorTrans.greenMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x00FF00);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Dezimalwert, der mit dem Wert des Grünkanals multipliziert wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenOffset"><apiName>greenOffset</apiName><shortdesc>
	 Eine Zahl zwischen -255 und 255, die zum Grün-Kanalwert addiert wird, nachdem dieser mit dem „greenMultiplier“-Wert multipliziert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.greenOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine Zahl zwischen -255 und 255, die zum Grün-Kanalwert addiert wird, nachdem dieser mit dem „greenMultiplier“-Wert multipliziert wurde.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Eine Zahl zwischen -255 und 255, die zum Grünkanalwert addiert wird, nachdem dieser mit dem <codeph>greenMultiplier</codeph>-Wert multipliziert wurde.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redMultiplier"><apiName>redMultiplier</apiName><shortdesc>
	 Ein Dezimalwert, der mit dem Wert des Rotkanals multipliziert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform();
 	trace(colorTrans.redMultiplier);		// 1
 	
 	colorTrans.redMultiplier = .5;
 	trace(colorTrans.redMultiplier);		// .5
 	
 	var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
 	var trans:Transform = new Transform(rect);
 	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Dezimalwert, der mit dem Wert des Rotkanals multipliziert wird. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redOffset"><apiName>redOffset</apiName><shortdesc>
	 Eine Zahl zwischen -255 und 255, die zum Rot-Kanalwert addiert wird, nachdem dieser mit dem „redMultiplier“-Wert multipliziert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.redOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.redOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Eine Zahl zwischen -255 und 255, die zum Rot-Kanalwert addiert wird, nachdem dieser mit dem „redMultiplier“-Wert multipliziert wurde.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Eine Zahl zwischen -255 und 255, die zum Rotkanalwert addiert wird, nachdem dieser mit <codeph>redMultiplier</codeph> multiplizert wurde.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:color:get"><apiName>color</apiName><shortdesc>
	 Der RGB-Farbwert eines ColorTransform-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>This example sets the RGB color value for the movie clip <code>my_mc</code>.<span class="flashonly"> To see this code work, place a movie clip on the Stage with the instance name <code>my_mc</code>. Then place the following code on Frame 1 in the main Timeline and select Control > Test Movie:</span>
	 <pre>
	 <code>var my_color:Color = new Color(my_mc);</code>
	 <code>my_color.setRGB(0xFF0000); // my_mc turns red</code>
	 </pre>
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Der RGB-Farbwert eines ColorTransform-Objekts.
	 
	 <p>Wenn Sie diese Eigenschaft festlegen, werden die drei Offset-Farbwerte (<codeph>redOffset</codeph>, <codeph>greenOffset</codeph> und <codeph>blueOffset</codeph>) entsprechend geändert und die drei Farbmultiplikatorwerte (<codeph>redMultiplier</codeph>, <codeph>greenMultiplier</codeph> und <codeph>blueMultiplier</codeph>) auf 0 gesetzt. Die Multiplikator- und Offset-Werte der Alphatransparenz ändern sich nicht.</p>
	 
	 <p>Verwenden Sie beim Übergeben eines Werts für diese Eigenschaft das Format 0x<i>RRGGBB</i>. <i>RR</i>, <i>GG</i> und <i>BB</i> setzen sich aus jeweils zwei Hexadezimalziffern zusammen, die den Offset für jede Farbkomponente festlegen. 0x teilt dem ActionScript-Compiler mit, dass die Zahl ein Hexadezimalwert ist.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Point"><apiName>Point</apiName><shortdesc>
 Das Point-Objekt stellt eine Position in einem 2D-Koordinatensystem dar, in dem x die horizontale Achse und y die vertikale Achse bildet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Die Point-Klasse gibt eine Position in einem zweidimensionalen Koordinatensystem an.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Das Point-Objekt gibt eine Position in einem zweidimensionalen Koordinatensystem an, in dem <i>x</i> die horizontale Achse und <i>y</i> die vertikale Achse darstellt. 
 
 <p>Mit dem folgenden Code wird ein Punkt bei (0,0) erstellt:</p>
 
 <codeblock platform="actionscript">var myPoint:Point = new Point();</codeblock>
 
 <codeblock platform="javascript">var myPoint = new Point();</codeblock>
 
 <p>Point-Objekte werden mit den Methoden und Eigenschaften der folgenden Klassen verwendet:</p>
 
 <ul>
 
 <li platform="actionscript">BitmapData</li>
 
 <li platform="actionscript">DisplayObject</li>
 
 <li platform="actionscript">DisplayObjectContainer</li>
 
 <li platform="actionscript">DisplacementMapFilter</li>
 
 <li>NativeWindow</li>
 
 <li platform="actionscript">Matrix</li>
 
 <li>Rectangle</li>
 
 </ul>
 
 <p>Mit dem <codeph>new Point()</codeph>-Konstruktor können Sie ein Point-Objekt erstellen.</p>
 
 </apiDesc><example conref="examples\PointExample.as"> Im folgenden Beispiel werden mithilfe der PointExample-Klasse mehrere neue Point-Objekte an verschiedenen <i>x,y</i>-Koordinaten erstellt. Anschließend werden die Ergebnisse der Methoden von verschiedenen Klassen mithilfe der <codeph>trace()</codeph>-Methode ausgegeben.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Point;

    public class PointExample extends Sprite {

        public function PointExample() {
        var point1:Point = new Point();
        trace(point1);  // (x=0, y=0)
        
        var point2:Point = new Point(6, 8);
        trace(point2); // (x=6, y=8)
        
        trace(Point.interpolate(point1, point2, 0.5)); // (x=3, y=4)
        
        trace(Point.distance(point1, point2)); // 10
        
        trace(point1.add(point2)); // (x=6, y=8)
        
        var point3:Point = point2.clone();
        trace(point2.equals(point3)); // true
        
        point3.normalize(2.5);
        trace(point3); // (x=1.5, y=2)
        
        trace(point2.subtract(point3)); // (x=4.5, y=6)
        
        trace(point1.offset(2, 3)); // 
        
        var angle:Number = Math.PI * 2 * (30 / 360); // 30Â°
        trace(Point.polar(4, angle)) // (x=3.464101615137755, y=1.9999999999999998)   
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links><apiConstructor id="flash.geom:Point:Point"><apiName>Point</apiName><shortdesc>
	 Erstellt einen neuen Punkt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The first example creates <code>point_1</code> with the default constructor.
	 <listing version="2.0">
	 import flash.geom.Point;
	 var point_1:Point = new Point();
	 trace(point_1.x); // 0
	 trace(point_1.y); // 0
	 </listing>
	 The second example creates <code>point_2</code> with the coordinates x = 1 and y = 2.
     <listing version="2.0">
	 import flash.geom.Point;
	 var point_2:Point = new Point(1, 2);
	 trace(point_2.x); // 1
	 trace(point_2.y); // 2
	 </listing>
	 
	  
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die horizontale Koordinate. 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die vertikale Koordinate. 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt einen neuen Punkt. Wenn Sie keine Parameter für diese Methode übergeben, wird ein Punkt bei (0,0) erstellt.
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Point:add"><apiName>add</apiName><shortdesc>
      	 Addiert die Koordinaten eines anderen Punkts zu den Koordinaten dieses Punkts, um einen neuen Punkt zu erstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>resultPoint</code> by adding <code>point_2</code> to 
	 <code>point_1</code>.
   	 
   	 <listing version="2.0">
   	 import flash.geom.Point;
   	 var point_1:Point = new Point(4, 8);
   	 var point_2:Point = new Point(1, 2);
   	 var resultPoint:Point = point_1.add(point_2);
   	 trace(resultPoint.toString()); // (x=5, y=10)
   	 </listing>
	 
   	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der neue Punkt.
   	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der zu addierende Punkt.
	 
      	 </apiDesc></apiParam></apiOperationDef><apiDesc>
      	 Addiert die Koordinaten eines anderen Punkts zu den Koordinaten dieses Punkts, um einen neuen Punkt zu erstellen.
	 
      	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:clone"><apiName>clone</apiName><shortdesc>
	 Erstellt eine Kopie des Point-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a <code>clonedPoint</code> from the values found in 
 	 <code>myPoint</code>.  The <code>clonedPoint</code> contains all the
	 the values from <code>myPoint</code> but is not the same object.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(1, 2);
	 var clonedPoint:Point = myPoint.clone();
	 trace(clonedPoint.x); // 1
	 trace(clonedPoint.y); // 2
	 trace(myPoint.equals(clonedPoint)); // true
	 trace(myPoint === clonedPoint); // false
	 </listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das neue Point-Objekt.
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Erstellt eine Kopie des Point-Objekts.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Erstellt eine Kopie des Point-Objekts.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:distance"><apiName>distance</apiName><shortdesc>
	 Gibt die Entfernung zwischen pt1 und pt2 zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der Abstand zwischen dem ersten und dem zweiten Punkt.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der erste Punkt.
	 </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der zweite Punkt.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt den Abstand zwischen <codeph>pt1</codeph> und <codeph>pt2</codeph> zurück.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:equals"><apiName>equals</apiName><shortdesc>
	 Stellt fest, ob zwei Punkte gleich sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert lautet <codeph>true</codeph>, wenn das Objekt diesem Point-Objekt entspricht; andernfalls <codeph>false</codeph>.
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der zu vergleichende Punkt.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Stellt fest, ob zwei Punkte gleich sind. Zwei Punkte sind gleich, wenn sie dieselben <i>x</i>- und <i>y</i>-Werte haben.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:interpolate"><apiName>interpolate</apiName><shortdesc>
    Legt einen Punkt zwischen zwei angegebenen Punkten fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example locates the interpolated point (<code>interpolatedPoint</code>) half way (50%) between <code>point_1</code> and <code>point_2</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(-100, -100);
   	var point_2:Point = new Point(50, 50);
   	var interpolatedPoint:Point = Point.interpolate(point_1, point_2, .5);
   	trace(interpolatedPoint.toString()); // (x=-25, y=-25)
   	</listing> 
	
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der neue interpolierte Punkt. 
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der erste Punkt.
	</apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der zweite Punkt.
	</apiDesc></apiParam><apiParam><apiItemName>f</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Grad der Interpolation zwischen den beiden Punkten. Zeigt an, wo sich der neue Punkt auf der Linie zwischen <codeph>pt1</codeph> und <codeph>pt2</codeph> befinden wird. Wenn <codeph>f</codeph> =1, wird <codeph>pt1</codeph> zurückgegeben; wenn <codeph>f</codeph> =0, wird <codeph>pt2</codeph> zurückgegeben.
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    Legt einen Punkt zwischen zwei angegebenen Punkten fest. Mit dem Parameter <codeph>f</codeph> wird die Position des neuen interpolierten Punkts relativ zu den beiden durch <codeph>pt1</codeph> und <codeph>pt2</codeph> angegebenen Endpunkten festgelegt. Je näher der Wert des Parameters <codeph>f</codeph> bei <codeph>1,0</codeph> liegt, desto näher liegt der interpolierte Punkt beim ersten Punkt (Parameter <codeph>pt1</codeph>). Je näher der Wert des Parameters <codeph>f</codeph> bei 0 liegt, desto näher liegt der interpolierte Punkt beim zweiten Punkt (Parameter <codeph>pt2</codeph>).
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:normalize"><apiName>normalize</apiName><shortdesc>
	Skaliert das Liniensegment zwischen (0,0) und dem aktuellen Punkt auf eine bestimmte Länge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example extends the length of the <code>normalizedPoint</code> object from 5 to 10.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var normalizedPoint:Point = new Point(3, 4);
   	trace(normalizedPoint.length); // 5
   	trace(normalizedPoint.toString()); // (x=3, y=4)
   	normalizedPoint.normalize(10);
   	trace(normalizedPoint.length); // 10
   	trace(normalizedPoint.toString()); // (x=6, y=8)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der normalisierte Punkt.
	
   	</apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Skalierungswert. Wenn der aktuelle Punkt beispielsweise bei (0,5) liegt und Sie eine Normalisierung auf 1 vornehmen, liegt der zurückgegebene Punkt bei (0,1).
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Skaliert das Liniensegment zwischen (0,0) und dem aktuellen Punkt auf eine bestimmte Länge. 
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:offset"><apiName>offset</apiName><shortdesc>
	 Versetzt das Point-Objekt um den angegebenen Betrag.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Wert, um den die horizontale Koordinate <i>x</i> versetzt werden soll.
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Wert, um den die vertikale Koordinate <i>y</i> versetzt werden soll.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Versetzt das Point-Objekt um den angegebenen Betrag. Der Wert von <codeph>dx</codeph> wird zum ursprünglichen Wert von <i>x</i> addiert, um den neuen <i>x</i>-Wert zu erstellen. Der Wert von <codeph>dy</codeph> wird zum ursprünglichen Wert von <i>yx</i> addiert, um den neuen <i>y</i>-Wert zu erstellen.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:polar"><apiName>polar</apiName><shortdesc>
	Konvertiert ein Polarkoordinatenpaar in eine kartesische Punktkoordinate.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>cartesianPoint</code> from the value of <code>angleInRadians</code>
	and a line length of 5.  The <code>angleInRadians</code> value equal to Math.atan(3/4)
   	is used because of the characteristics of right triangles with sides that 
   	have ratios of 3:4:5.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 5;
   	var angleInRadians:Number = Math.atan(3/4);
   	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // (x=4, y=3)
   	</listing>
	
	When computers work with transcendental numbers such as pi, some round-off
	error occurs because floating-point arithmetic has only finite precision.
	When you use <code>Math.PI</code>, consider using the <code>Math.round()</code> function, as shown 
	in the following example.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 10;
   	var angleInRadians:Number = Math.PI;
    	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // should be (x=-10, y=0), but is (x=-10, y=1.22460635382238e-15)
   	trace(Math.round(cartesianPoint.y)); // 0
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Der kartesische Punkt.
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Längenkoordinate des Polarpaars.
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Winkel des Polarpaars in Bogenmaß.
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Konvertiert ein Polarkoordinatenpaar in eine kartesische Punktkoordinate.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:subtract"><apiName>subtract</apiName><shortdesc>
	Subtrahiert von den Koordinaten dieses Punkts die Koordinaten eines anderen Punkts, um einen neuen Punkt zu erstellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>point_3</code> by subtracting <code>point_2</code> from <code>point_1</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(4, 8);
   	var point_2:Point = new Point(1, 2);
   	var resultPoint:Point = point_1.subtract(point_2);
   	trace(resultPoint.toString()); // (x=3, y=6)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der neue Punkt.
   	
     	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Der zu subtrahierende Punkt.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Subtrahiert von den Koordinaten dieses Punkts die Koordinaten eines anderen Punkts, um einen neuen Punkt zu erstellen.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:toString"><apiName>toString</apiName><shortdesc>
	 Gibt einen String zurück, der die Werte der x- und y-Koordinaten enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die Stringdarstellung der Koordinaten.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt einen String zurück, der die Werte der x- und y-Koordinaten enthält. 

	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt einen String zurück, der die Werte der <i>x</i>- und <i>y</i>-Koordinaten enthält. Der String hat das Format <codeph>"(x=<i>x</i>, y=<i>y</i>)"</codeph>, sodass beim Aufrufen der <codeph>toString()</codeph>-Methode für einen Punkt bei 23,17 <codeph>"(x=23, y=17)"</codeph> zurückgegeben wird.
   	 
   	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Point:x"><apiName>x</apiName><shortdesc>
	 Die horizontale Koordinate des Punkts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>x</i> (horizontal) coordinate of <code>myPoint</code> and gets <code>myX</code> from <code>myPoint.x</code>.
	 
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.x); // 0
	 myPoint.x = 5;
	 trace(myPoint.x); // 5
	 var myX:Number = myPoint.x;
	 trace(myX); // 5
     </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die horizontale Koordinate des Punkts. Der Standardwert ist 0.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:y"><apiName>y</apiName><shortdesc>
	 Die vertikale Koordinate des Punkts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>y</i> (vertical) coordinate of <code>myPoint</code> and gets <code>myY</code> from <code>myPoint.y</code>.
     
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.y); // 0
	 myPoint.y = 5;
	 trace(myPoint.y); // 5
	 var myY:Number = myPoint.y;
	 trace(myY); // 5
  	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die vertikale Koordinate des Punkts. Der Standardwert ist 0.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:length:get"><apiName>length</apiName><shortdesc>
	 Die Länge des Liniensegments von (0,0) bis zu diesem Punkt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Point, <code>myPoint</code>, and determines the length of a line from (0, 0) to that Point.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(3,4);
	 trace(myPoint.length); // 5
	 </listing>
	 
   	  
   	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Länge des Liniensegments von (0,0) bis zu diesem Punkt. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point/polar()"><linktext>Point.polar()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc> 
 Die PerspectiveProjection-Klasse bietet eine einfache Möglichkeit, die perspektivischen Tansformationen eines Anzeigeobjekts oder seiner untergeordneten Objekte zuzuweisen oder zu ändern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Die PerspectiveProjection-Klasse bietet eine einfache Möglichkeit, die perspektivischen Tansformationen eines Anzeigeobjekts oder seiner untergeordneten Objekte zuzuweisen oder zu ändern. Für komplexere oder benutzerdefinierte perspektivische Projektionen verwenden Sie die Matrix3D-Klasse. Während die PerspectiveProjection-Klasse grundlegende dreidimensionale Präsentationseigenschaften bereitstellt, ermöglicht die Matrix3D-Klasse eine bessere Steuerung der dreidimensionalen Darstellung eines Anzeigeobjekts.
 
 <p>Die Projektion ist eine Möglichkeit, ein dreidimensionales Objekt in einem zweidimensionalen Raum darzustellen. So lässt sich zum Beispiel ein Würfel auf einen Computerbildschirm projizieren. Die Perspektivenprojektion verwendet ein sogenanntes Sichtfrustum (ein Abschnitt einer rechteckigen Pyramide), um eine dreidimensionale Welt und deren Objekte zu modellieren und auf den Bildschirm zu projizieren. Das Sichtfrustum wird breiter, wenn es sich vom Ursprung des Blickpunkts wegbewegt. Der Ursprung des Blickpunkts kann eine Kamera oder das Auge des Betrachters sein, der auf den Bildschirm blickt. Die projizierte Perspektive erzeugt die Illusion von drei Dimensionen mit Tiefe und Entfernung, wobei Objekte näher am Bildschirm größer erscheinen als weiter vom Bildschirm entfernte Objekte.</p>
 
 <p><adobeimage alt="Frustumvolumen" href="../../images/frustum.jpg"/></p>
 
 <p>Bei einem PerspectiveProjection-Standardobjekt handelt es sich um ein für die perspektivische Transformation des Stammobjekts definiertes Rahmenobjekt. Es basiert auf dem Sichtfeld und dem Seitenverhältnis (Abmessungen) der Bühne. Die Projektionsmitte, der Fluchtpunkt, ist auf die Mitte der Bühne eingestellt, was bedeutet, dass dreidimensionale Anzeigeobjekte zur Mitte der Bühne verschoben werden, wenn sie entlang der z-Achse nach hinten bewegt werden. Der Standardblickpunkt liegt beim Punkt (0,0), mit Blickrichtung nach unten entlang der positiven z-Achse. Die y-Achse weist zum unteren Rand des Bildschirms. Sie können auf die Einstellungen für die Perspektivenprojektion des <codeph>root</codeph>-Anzeigeobjekts zugreifen und die Eigenschaften für das Sichtfeld und die Projektionsmitte der <codeph>perspectiveProjection</codeph>-Eigenschaft ändern, indem Sie die <codeph>DisplayObject.transform</codeph>-Eigenschaft des <codeph>root</codeph>-Objekts verwenden.</p> 
 
 <p>Über die Perspektivenprojektion des übergeordneten Elements können Sie auch eine andere Einstellung für die Perspektivenprojektion eines Anzeigeobjekts festlegen. Erstellen Sie zunächst ein PerspectiveProjection-Objekt und stellen Sie dessen <codeph>fieldOfView</codeph>- und <codeph>projectionCenter</codeph>-Eigenschaften ein. Als Nächstes weisen Sie das PerspectiveProjection-Objekt dem übergeordneten Anzeigeobjekt zu, indem Sie die <codeph>DisplayObject.transform</codeph>-Eigenschaft verwenden. Die angegebene Projektionsmatrix und Transformation wird dann auf alle untergeordneten dreidimensionalen Objekte des Anzeigeobjekts angewendet.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link></related-links><apiConstructor id="flash.geom:PerspectiveProjection:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc>
     Erstellt eine Instanz eines PerspectiveProjection-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
     </helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Erstellt eine Instanz eines PerspectiveProjection-Objekts. 
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:PerspectiveProjection:toMatrix3D"><apiName>toMatrix3D</apiName><shortdesc>
     Gibt das dem Anzeigeobjekt zugrundeliegende Matrix3D-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das zugrundeliegende Matrix3D-Objekt. 
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Gibt das dem Anzeigeobjekt zugrundeliegende Matrix3D-Objekt zurück.  
     
     <p>Ein Anzeigeobjekt kann, wie das Stammobjekt, ein PerspectiveProjection-Objekt haben, ohne dass eine Matrix3D-Eigenschaft für seine Transformationen definiert sein muss. Verwenden Sie entweder ein PerspectiveProjection- oder ein Matrix3D-Objekt, um die Perspektiventransformation festzulegen. Wenn bei Verwendung des PerspectiveProjection-Objekts ein Matrix3D-Objekt benötigt wurde, kann die <codeph>toMatrix3D()</codeph>-Methode das zugrundeliegende Matrix3D-Objekt des Anzeigeobjekts abrufen. Zum Beispiel kann die <codeph>toMatrix3D()</codeph>-Methode mit der <codeph>Utils3D.projectVectors()</codeph>-Methode verwendet werden.</p> 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:PerspectiveProjection:fieldOfView:set"><apiName>fieldOfView</apiName><shortdesc>
     Legt einen Winkel als Gradwert zwischen 0 und 180 für das dreidimensionale Blickfeld fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Legt einen Winkel als Gradwert zwischen 0 und 180 für das dreidimensionale Blickfeld fest.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Legt einen Winkel als Gradwert zwischen <codeph>0</codeph> und <codeph>180</codeph> für das dreidimensionale Sichtfeld fest. Dieser Wert legt fest, wie stark die perspektivische Transformation und Verzerrung auf ein dreidimensionales Anzeigeobjekt angewendet werden, dessen z-Koordinate nicht null ist.
     
     <p>Ein Wert nahe <codeph>0</codeph>, bedeutet das, dass die zweidimensionalen x- und y-Koordinaten des Bildschirms nahezu dieselben sind wie die dreidimensionalen x-, y- und z-Koordinaten und wenig oder keine Verzerrung auftritt. Anders ausgedrückt bewegt sich ein Anzeigeobjekt bei einem kleinen Winkel nur wenig entlang der z-Achse nach unten und seine Größe scheint sich kaum zu ändern. </p>
     
     <p>Ein Wert nahe <codeph>180</codeph> Grad führt zu einem Fischaugenobjektiveffekt: Positionen mit einem <codeph>z</codeph>-Wert kleiner als <codeph>0</codeph> werden vergrößert, dagegen werden Positionen mit einem <codeph>z</codeph>-Wert größer als <codeph>0</codeph> verkleinert. Bei einem großen Winkel bewegt sich das Anzeigeobjekt entlang der z-Achse weit nach unten und seine Größe ändert sich rasch. Ist das Sichtfeld auf <codeph>0</codeph> oder <codeph>180</codeph> gesetzt, ist auf dem Bildschirm nichts zu sehen.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:PerspectiveProjection:focalLength:get"><apiName>focalLength</apiName><shortdesc>
     Der Abstand zwischen dem Auge oder dem Ursprung des Blickpunkts (0,0,0) und dem auf der z-Achse liegenden Anzeigeobjekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Der Abstand zwischen dem Auge oder dem Ursprung des Blickpunkts (0,0,0) und dem auf der z-Achse liegenden Anzeigeobjekt. Während der perspektivischen Transformation wird <codeph>focalLength</codeph> dynamisch anhand des Sichtfeldwinkels und des Seitenverhältnisses der Bühne (Bühnenbreite dividiert durch Bühnenhöhe) berechnet.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection/fieldOfView"><linktext>fieldOfView</linktext></link></related-links></apiValue><apiValue id="flash.geom:PerspectiveProjection:projectionCenter:set"><apiName>projectionCenter</apiName><shortdesc>
     Ein zweidimensionaler Punkt, der den Mittelpunkt der Projektion, den Fluchtpunkt des Anzeigeobjekts darstellt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
     Ein zweidimensionaler Punkt, der den Mittelpunkt der Projektion, den Fluchtpunkt des Anzeigeobjekts darstellt. 
     
     <p>Die <codeph>projectionCenter</codeph>-Eigenschaft ist ein Versetzungspunkt zum ursprünglichen Registrierungspunkt oben links auf der Bühne (0,0). Standardmäßig ist die Mitte der Projektionstransformation auf die Mitte der Bühne eingestellt, was bedeutet, dass dreidimensionale Anzeigeobjekte zur Mitte der Bühne verschoben werden, wenn sie entlang der z-Achse nach hinten bewegt werden.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Orientation3D"><apiName>Orientation3D</apiName><shortdesc>
Die Orientation3D-Klasse ist eine Aufzählung von Konstantenwerten zur Darstellung des Ausrichtungsstils eines Matrix3D-Objekts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die Orientation3D-Klasse ist eine Aufzählung von Konstantenwerten zur Darstellung des Ausrichtungsstils eines Matrix3D-Objekts. Die drei Ausrichtungstypen sind Eulersche Winkel, Achsenwinkel und Quaternionen. Die <codeph>decompose</codeph>- und <codeph>recompose</codeph>-Methode des Matrix3D-Objekts verwendet einen der aufgezählten Typen, um die Drehungskomponenten der Matrix zu bestimmen.

</apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiValue id="flash.geom:Orientation3D:AXIS_ANGLE"><apiName>AXIS_ANGLE</apiName><shortdesc>
    Die Achsenwinkelausrichtung verwendet zur Bestimmung der Ausrichtung eine Kombination von Achse und Winkel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>axisAngle</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Die Achsenwinkelausrichtung verwendet zur Bestimmung der Ausrichtung eine Kombination von Achse und Winkel. Ein Beispiel für eine Achse ist eine Linie oder ein Vektor von der Mitte einer dreidimensionalen Kugel zu deren Oberfläche. Die Achse, um die sich das Objekt dreht, ist ein Einheitsvektor, der die Richtung im dreidimensionalen Raum darstellt. Der Winkel stellt die Stärke der Drehung um den Vektor dar. Die Richtung bestimmt, wohin ein Anzeigeobjekt zeigt, und der Rollwinkel bestimmt, wo oben ist. Sie können Vector3D- und Matrix3D-Objekte verwenden, um die verschiedenen Matrixtransformationen und wichtige dreidimensionale Programmierungswerte zu bestimmen, zum Beispiel den Abstand bis zur Überschneidung zweier Objekte, der verwendet werden kann, um einfache Kollisionen dreidimensionaler Objekten zu erkennen.
    
    <p>Die <codeph>Matrix3D.appendRotation()</codeph>- und die <codeph>Matrix3D.prependRotation()</codeph>-Methode verwendet die Achsenwinkelausrichtung.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:EULER_ANGLES"><apiName>EULER_ANGLES</apiName><shortdesc> 
    Eulersche Winkel ist die Standardausrichtung für die decompose()- und recompose()-Methode. Damit wird die Ausrichtung anhand separater Drehwinkel für jede der drei Achsen definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>eulerAngles</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Legt die Ausrichtung anhand separater Drehwinkel für jede der drei Achsen fest.
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
    Eulersche Winkel ist die Standardausrichtung für die <codeph>decompose()</codeph>- und <codeph>recompose()</codeph>-Methode. Damit wird die Ausrichtung anhand separater Drehwinkel für jede der drei Achsen definiert. Normalerweise folgt auf eine Drehung um die x-Achse eine Drehung um die y-Achse und dann eine Drehung um die z-Achse. 
    
    <p>Eulersche Winkel können unter Umständen zu Animationsfehlern führen, da Probleme wie Singularitäten beim Drehen um die x-Achse oder Gimbal Locks auftreten können. Zu einem Gimbal Lock kann es z. B. bei der Drehung um zwei oder mehr Achsen kommen, da bei Eulerschen Winkeln jede Achse unabhängig behandelt wird. Die Achsen können dabei zusammenfallen, was zu unerwarteten Ergebnissen führt.</p>
    
    <p>Die Achsendrehungseigenschaften des Anzeigeobjekts führen eine Drehung vom Typ Eulersche Winkel aus.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:QUATERNION"><apiName>QUATERNION</apiName><shortdesc>
    Die Quaternionausrichtung verwendet komplexe Zahlen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>quaternion</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Die Quaternionausrichtung verwendet die drei Drehsachsen (x, y, z) und den Drehwinkel (w).
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Die Quaternionausrichtung verwendet komplexe Zahlen. Die Ausrichtung in Quaternionen mithilfe der drei Drehachsen (x, y, z) und des Drehwinkels (w). Quaternionen gewährleisten den kürzesten, effizientesten Drehungspfad. Sie erzeugt auch eine ruckfreie Drehung und vermeidet eine Blockade der kardanischen Aufhängung (Gimbal Lock). Ein Gimbal Lock kann auftreten, wenn bei der Drehung um zwei oder mehr Achsen die Achsen zusammenfallen, was zu unerwarteten Ergebnissen führen kann. 
    
    <p>Die <codeph>Matrix3D.interpolate()</codeph>-Methode verwendet Quaternionen.</p> 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>