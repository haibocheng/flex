<?xml version="1.0"?>
<apiPackage id="flash.media"><apiName>flash.media</apiName><apiDetail/><apiClassifier id="flash.media:SoundCodec"><apiName>SoundCodec</apiName><shortdesc>
Die SoundCodec-Klasse ist eine Zusammenfassung von Konstantenwerten, die zur Einstellung der codec-Eigenschaft in der Microphone-Klasse verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die SoundCodec-Klasse ist eine Zusammenfassung von Konstantenwerten, die zur Einstellung der <codeph>codec</codeph>-Eigenschaft in der <codeph>Microphone</codeph>-Klasse verwendet werden.

</apiDesc></apiClassifierDetail><apiValue id="flash.media:SoundCodec:NELLYMOSER"><apiName>NELLYMOSER</apiName><shortdesc> 
	Gibt an, dass der Nellymoser-Codec zur Komprimierung von Audiodaten verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>NellyMoser</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Gibt an, dass der Nellymoser-Codec zur Komprimierung von Audiodaten verwendet werden soll. Diese Konstante ist der Standardwert für die <codeph>Microphone.codec</codeph>-Eigenschaft.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundCodec:SPEEX"><apiName>SPEEX</apiName><shortdesc> 
	Gibt an, dass der Speex-Codec zur Komprimierung von Audiodaten verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>Speex</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Gibt an, dass der Speex-Codec zur Komprimierung von Audiodaten verwendet werden soll.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:ID3Info"><apiName>ID3Info</apiName><shortdesc>
	 Die ID3Info-Klasse enthält Eigenschaften für die ID3-Metadaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die ID3Info-Klasse enthält Eigenschaften für die ID3-Metadaten. Durch Aufrufen der <codeph>id3</codeph>-Eigenschaft der Soundklasse (beispielsweise <codeph>mySound.id3.TIME</codeph>) können Sie weitere Metadaten für MP3-Dateien abrufen. Weitere Informationen finden Sie im Abschnitt zu <codeph>Sound.id3</codeph> und in den Definitionen zu ID3-Tags unter <xref href="http://www.id3.org">http://www.id3.org</xref>.
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links><apiValue id="flash.media:ID3Info:album"><apiName>album</apiName><shortdesc>
		 Der Name des Albums. Entspricht dem ID3 2.0-Tag „TALB“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Der Name des Albums. Entspricht dem ID3 2.0-Tag „TALB“.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:artist"><apiName>artist</apiName><shortdesc>
		 Der Name des Interpreten. Entspricht dem ID3 2.0-Tag „TPE1“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Der Name des Interpreten. Entspricht dem ID3 2.0-Tag „TPE1“.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:comment"><apiName>comment</apiName><shortdesc>
		 Eine Anmerkung zur Aufnahme. Entspricht dem ID3 2.0-Tag „COMM“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Eine Anmerkung zur Aufnahme. Entspricht dem ID3 2.0-Tag „COMM“.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:genre"><apiName>genre</apiName><shortdesc>
		 Das Genre des Songs. Entspricht dem ID3 2.0-Tag „TCON“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Das Genre des Songs. Entspricht dem ID3 2.0-Tag „TCON“.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:songName"><apiName>songName</apiName><shortdesc>
		 Der Name des Songs. Entspricht dem ID3 2.0-Tag „TIT2“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Der Name des Songs. Entspricht dem ID3 2.0-Tag „TIT2“.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:track"><apiName>track</apiName><shortdesc>
		 Die Titelnummer. Entspricht dem ID3 2.0-Tag „TRCK“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Die Titelnummer. Entspricht dem ID3 2.0-Tag „TRCK“.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:year"><apiName>year</apiName><shortdesc>
		 Das Aufnahmejahr. Entspricht dem ID3 2.0-Tag „TYER“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Das Aufnahmejahr. Entspricht dem ID3 2.0-Tag „TYER“.
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Microphone"><apiName>Microphone</apiName><shortdesc>
 Mit der Microphone-Klasse können Sie Audio von einem Mikrofon aufzeichnen, das an einen Computer angeschlossen ist, auf dem Flash Player oder Adobe AIR ausgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der Microphone-Klasse können Sie Audio von einem Mikrofon aufzeichnen, das an einen Computer angeschlossen ist, auf dem <ph platform="actionScript">Flash Player oder </ph>Adobe AIR ausgeführt wird. Verwenden Sie die Microphone-Klasse, um das Audio lokal zu überwachen. Mit der NetConnection- und der NetStream-Klasse können Sie das Audio an Flash Media Server übertragen. Flash Media Server kann das Audio an andere Server senden und an andere Clients, auf denen <ph platform="actionScript">Flash Player oder</ph> Adobe AIR ausgeführt wird, übertragen.
 
 <p>
 Informationen zum Aufzeichnen von Video finden Sie in der Beschreibung der Camera-Klasse.
 </p>
 
 <p>
 <b>Wichtig: </b>Flash Player zeigt ein Zugriffsschutz-Dialogfeld an, in dem der Benutzer den Zugriff auf das Mikrofon zulassen oder verweigern kann. Sorgen Sie dafür, dass Ihr Anwendungsfenster eine Mindestgröße von 215 x 138 Pixel hat, da ansonsten das Dialogfeld nicht angezeigt werden kann.
 </p>
 
 <p>
 Zum Erstellen oder Referenzieren eines Microphone-Objekts verwenden Sie die <codeph>Microphone.getMicrophone()</codeph>-Methode.
 </p>
 
 <p platform="actionscript"><b>Achtung: </b>Für Inhalte außerhalb der Anwendungssandbox wird ein Zugriffsschutz-Dialogfeld angezeigt, in dem der Benutzer den Zugriff auf das Mikrofon zulassen oder verweigern kann. Für dieses Dialogfeld muss das Anwendungsfenster mindestens 215 x 138 Pixel groß sein. Für Adobe AIR-Inhalt innerhalb der Anwendungssandbox ist der Zugriff zulässig und das Dialogfeld wird nicht angezeigt.</p>
 
 </apiDesc><example conref="examples\MicrophoneExample.as"> Im folgenden Beispiel wird Sound mit einem Mikrofon bei aktivierter Echounterdrückung aufgenommen, nachdem der Benutzer den Zugriff auf das Mikrofon des Computers gewährt hat. Mithilfe der Methode <codeph>Security.showSettings()</codeph> wird das Dialogfeld „Flash Player“ angezeigt, mit dem die Berechtigung für den Zugriff auf das Mikrofon des Benutzers angefordert wird. Durch das Aufrufen von <codeph>setLoopBack(true)</codeph> wird der Input an die lokalen Lautsprecher umgeleitet, sodass Sie den Sound hören können, während das Beispiel ausgeführt wird.
 
 <p>Zwei Listener reagieren auf <codeph>activity</codeph>- und <codeph>status</codeph>-Ereignisse. Das <codeph>activity</codeph>-Ereignis wird am Anfang und Ende (falls vorhanden) der Sitzung ausgelöst und von der Methode <codeph>activityHandler()</codeph> erfasst, die Ereignisverarbeitungsinformationen verfolgt. Das Ereignis <codeph>status</codeph> wird ausgelöst, wenn Statusinformationen vom verknüpften Microphone-Objekt übermittelt werden; es wird mithilfe der <codeph>statusHandler()</codeph>-Methode erfasst und verfolgt.</p>
 
 <p><b>Hinweis:</b> Dieses Beispiel kann nur dann korrekt nachvollzogen werden, wenn ein Mikrofon mit dem Computer verbunden ist.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Microphone;
    import flash.system.Security;

    public class MicrophoneExample extends Sprite {
        public function MicrophoneExample() {
            var mic:Microphone = Microphone.getMicrophone();
            Security.showSettings("2");
            mic.setLoopBack(true);
                    
            if (mic != null) {
                mic.setUseEchoSuppression(true);
                mic.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                mic.addEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }

        private function statusHandler(event:StatusEvent):void {
            trace("statusHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Wird ausgelöst, wenn der Status eines Mikrofons gemeldet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Status eines Mikrofons gemeldet wird. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Microphone.Muted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf das Mikrofon verweigert. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Microphone.Unmuted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf das Mikrofon gewährt.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>Microphone.getMicrophone()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Microphone_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Wird ausgelöst, wenn eine Mikrofonsitzung gestartet oder beendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn eine Mikrofonsitzung gestartet oder beendet wird. 
 
 <p>
 Um festzulegen, welche Soundmenge erforderlich ist, um dieses Ereignis mit einer <codeph>activating</codeph>-Eigenschaft mit dem Wert <codeph>true</codeph> auszulösen, oder welcher Zeitraum ohne Sound verstreichen muss, damit dieses Ereignis mit einer <codeph>activating</codeph>-Eigenschaft mit dem Wert <codeph>false</codeph> ausgelöst wird, verwenden Sie <codeph>Microphone.setSilenceLevel()</codeph>.
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>setSilenceLevel()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.media:Microphone:getMicrophone"><apiName>getMicrophone</apiName><shortdesc>
	 
	 Gibt einen Verweis auf ein Mikrofon-Objekt zur Aufnahme von Audiodaten zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, Microphone.getMicropone, getMicrophone
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Ein Verweis auf ein Mikrofon-Objekt zur Aufnahme von Audiodaten.
	 
 	 </apiDesc><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Der Indexwert des Mikrofons.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Gibt einen Verweis auf ein Mikrofon-Objekt zur Aufnahme von Audiodaten zurück. Um mit dem Aufzeichnen des Audios zu beginnen, müssen Sie das Microphone-Objekt mit einem NetStream-Objekt verknüpfen (siehe <codeph>NetStream.attachAudio()</codeph>).
	 
	 <p>
	 Mehrere Aufrufe von <codeph>Microphone.get()</codeph> verweisen auf dasselbe Mikrofon. Falls ein Programmcode also die Zeilen <codeph>mic1 = Microphone.get()</codeph> und <codeph>mic2 = Microphone.get()</codeph> enthält, verweist sowohl <codeph>mic1</codeph> als auch <codeph>mic2</codeph> auf dasselbe (standardmäßige) Mikrofon.</p>
	 <p>
	 Wenn Sie das Standardmikrofon abrufen möchten, müssen Sie <codeph>getMicrophone()</codeph> mit -1 aufrufen. Wenn Sie die Methode ohne Parameter aufrufen, wird das erste Mikrofon in der Liste abgerufen.
	 </p>
	 
	 <p>
	 Mit der <codeph>index</codeph>-Eigenschaft können Sie den Indexwert des aktuellen Microphone-Objekts abrufen. Sie können diesen Wert dann an andere Methoden der Microphone-Klasse übergeben.
	 </p>
	 
	 <p>
	 Im Allgemeinen sollten Sie keinen Wert für <codeph>index</codeph> übergeben. Verwenden Sie einfach die <codeph>Microphone.getMicrophone()</codeph>-Methode, um einen Verweis auf das Standardmikrofon zurückzugeben. Im Bedienfeld für die Mikrofoneinstellungen kann der Benutzer das Standardmikrofon für die Anwendung festlegen. Wenn Sie einen Wert für <codeph>index</codeph> übergeben, verweisen Sie unter Umständen auf ein anderes als das vom Benutzer gewählte Mikrofon. In seltenen Fällen können Sie <codeph>index</codeph> verwenden, beispielsweise wenn Ihre Anwendung Audiodaten von zwei Mikrofonen gleichzeitig aufnimmt.
	 </p>
	 
	 <p>
	 Wenn eine SWF-Datei versucht, auf das von <codeph>Microphone.getMicrophone()</codeph> zurückgegebene Objekt zuzugreifen (wenn Sie beispielsweise <codeph>NetStream.attachAudio()</codeph> aufrufen), wird in Flash Player ein Zugriffsschutz-Dialogfeld angezeigt, in dem der Benutzer den Zugriff auf das Mikrofon zulassen oder verweigern kann. (Achten Sie darauf, dass die Bühnengröße mindestens 215 x 138 Pixel beträgt. Dies ist die Mindestgröße, die Flash Player für die Anzeige des Dialogfelds benötigt.)
	 </p>
	 
	 <p>
     Wenn der Benutzer auf dieses Dialogfeld reagiert, wird ein <codeph>status</codeph>-Ereignis ausgelöst, das die Antwort des Benutzers anzeigt. Sie können auch die <codeph>Microphone.muted</codeph>-Eigenschaft überprüfen, um festzustellen, ob der Benutzer den Zugriff auf das Mikrofon zugelassen oder verweigert hat. 
	 </p>
	 
	 <p>
	 Wenn <codeph>Microphone.getMicrophone()</codeph> den Wert <codeph>null</codeph> zurückgibt, wird das Mikrofon entweder von einer anderen Anwendung genutzt oder im System sind keine Mikrofone installiert. Mit <codeph>Microphones.names.length</codeph> können Sie feststellen, ob Mikrofone installiert sind. Mit <codeph>Security.showSettings()</codeph> zeigen Sie das Flash Player-Bedienfeld für Mikrofoneinstellungen an, in dem der Benutzer das Mikrofon auswählen kann, auf das von <codeph>Microphone.getMicrophone()</codeph> verwiesen wird. 
	 
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/event:status"><linktext>Microphone.status</linktext></link><link href="flash.net.xml#NetStream/attachAudio()"><linktext>flash.net.NetStream.attachAudio()</linktext></link><link href="flash.system.xml#Security/showSettings()"><linktext>flash.system.Security.showSettings()</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone:getMicrophone_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Status eines Mikrofons gemeldet wird. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Microphone.Muted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf das Mikrofon verweigert. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Microphone.Unmuted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf das Mikrofon gewährt.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Status eines Mikrofons gemeldet wird.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Microphone:setLoopBack"><apiName>setLoopBack</apiName><shortdesc>
	 Leitet von einem Mikrofon aufgezeichnetes Audio an die lokalen Lautsprecher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>state</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData></apiParam></apiOperationDef><apiDesc>
	 Leitet von einem Mikrofon aufgezeichnetes Audio an die lokalen Lautsprecher.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.media:Microphone:setSilenceLevel"><apiName>setSilenceLevel</apiName><shortdesc>
	 Legt die minimale Eingangslautstärke fest, bei der Sound als solcher eingestuft wird und (optional) die Länge der lautlosen Zeit bis zum Erkennen von Stille.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setSilenceLevel, setSilenceLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>silenceLevel</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die erforderliche Soundmenge zum Aktivieren des Mikrofons und Auslösen des <codeph>activity</codeph>-Ereignisses. Die zulässigen Werte liegen zwischen 0 und 100. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Die Zeit in Millisekunden, die ohne Aktivität vergehen muss, bevor in Flash Player oder Adobe AIR kein Sound mehr festgestellt und das <codeph>dispatch</codeph>-Ereignis ausgelöst wird. Der Standardwert ist 2000 (2 Sekunden). (<b>Hinweis</b>: Der in der Syntax angezeigte Standardwert -1 ist ein interner Wert in Flash Player oder Adobe AIR zur Verwendung des Werts 2000.)
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt die minimale Eingangslautstärke fest, bei der Sound als solcher eingestuft wird und (optional) die Länge der lautlosen Zeit bis zum Erkennen von Stille.
	 <ul>
	   <li>Wenn das Mikrofon überhaupt keinen Sound feststellen soll, legen Sie für <codeph>silenceLevel</codeph> einen Wert von 100 fest. Das <codeph>activity</codeph>-Ereignis wird nicht ausgelöst. </li>
	   <li>Mithilfe von <codeph>Microphone.activityLevel</codeph> können Sie die Soundmenge ermitteln, die mit dem Mikrofon derzeit erkannt wird. </li>
	 </ul>
	 
	 <p>Aktivitätserkennung ist die Fähigkeit, anhand der Lautstärkepegel zu erkennen, dass jemand spricht. Wenn nicht gesprochen wird, kann Bandbreite gespart werden, da der zugehörige Audiostream nicht übertragen werden muss. Diese Daten können auch für visuelles Feedback verwendet werden, sodass Benutzer erkennen, dass sie (oder andere) derzeit stumm sind.</p>
	 
	 <p>Stillewerte entsprechen unmittelbar den Aktivitätswerten. Völlige Stille entspricht dem Aktivitätswert 0. Konstante, laute Geräusche (so laut wie bei der momentanen Einstellung für die Lautstärke erfasst werden kann) entspricht einem Wert von 100. Wenn die Lautstärke genau angepasst ist, ist Ihr Aktivitätswert geringer als der Stillewert, wenn Sie nicht sprechen. Wenn Sie sprechen, ist der Aktivitätswert höher als der Stillewert.</p>
	 
	 <p>Diese Methode ähnelt <codeph>Camera.setMotionLevel()</codeph>. Mit beiden Methoden wird angegeben, zu welchem Zeitpunkt das <codeph>activity</codeph>-Ereignis ausgelöst werden soll. Diese Methoden haben jedoch deutlich unterschiedliche Auswirkungen auf das Veröffentlichen von Streams:</p>
	 
	 <ul>
	   <li><codeph>Camera.setMotionLevel()</codeph> ist dazu bestimmt, Bewegung festzustellen und hat keinen Einfluss auf die Bandbreitenauslastung. Auch wenn ein Videostream keine Bewegung feststellt, werden weiterhin Videodaten gesendet.</li>
	 
	   <li><codeph>Microphone.setSilenceLevel()</codeph> dient zur Optimierung der Bandbreite. Wenn ein Audiostream als lautlos eingestuft wird, werden keine Audiodaten gesendet. Stattdessen wird eine Meldung gesendet, um den Beginn der Inaktivität (Stille) anzuzeigen. </li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>flash.media.Camera.setMotionLevel()</linktext></link><link href="flash.media.xml#Microphone/activityLevel"><linktext>flash.media.Microphone.activityLevel</linktext></link><link href="flash.media.xml#Microphone/event:activity"><linktext>flash.media.Microphone.activity</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/silenceLevel"><linktext>flash.media.Microphone.silenceLevel</linktext></link><link href="flash.media.xml#Microphone/silenceTimeout"><linktext>flash.media.Microphone.silenceTimeout</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Microphone:setUseEchoSuppression"><apiName>setUseEchoSuppression</apiName><shortdesc>
	 Gibt an, ob die Audio-Codec-Funktion zur Echounterdrückung verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setUseEchoSuppression, setUseEchoSuppression
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>useEchoSuppression</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Ein boolescher Wert, der angibt, ob die Echounterdrückung verwendet werden soll (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). 	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob die Audio-Codec-Funktion zur Echounterdrückung verwendet werden soll. Der Standardwert ist <codeph>false</codeph>, es sei denn, der Benutzer hat im Flash Player-Bedienfeld für die Mikrofoneinstellungen die Option „Echo reduzieren“ gewählt.
	 
	 <p>Durch die Echounterdrückung sollen die Auswirkungen von Rückkopplungen unterdrückt werden, die hervorgerufen werden, wenn Sound aus dem Lautsprecher am selben Computer über das Mikrofon empfangen wird. (Dies unterscheidet sich von der Echokompensation, bei der die Rückkopplungen vollständig entfernt werden.)</p>
	 
	 <p>Generell empfiehlt sich die Echounterdrückung, wenn Sound auf dem gleichen Computer über Lautsprecher und nicht über Kopfhörer wiedergegeben wird. Wenn Benutzer bei einer SWF-Datei das Soundausgabegerät angeben können, sollten Sie <codeph>Microphone.setUseEchoSuppression(true)</codeph> aufrufen, wenn angegeben wird, dass Lautsprecher und das Mikrofon verwendet werden sollen. </p>
	 
	 <p>Benutzer können diese Einstellungen auch im Flash Player-Bedienfeld für die Mikrofoneinstellungen anpassen.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link><link href="flash.media.xml#Microphone/useEchoSuppression"><linktext>flash.media.Microphone.useEchoSuppression</linktext></link></related-links></apiOperation><apiValue id="flash.media:Microphone:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 Die über das Mikrofon ermittelte Soundmenge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.activityLevel, activityLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die über das Mikrofon ermittelte Soundmenge. Die Werte liegen zwischen 0 (kein Sound) und 100 (sehr lauter Sound). Mithilfe des Werts dieser Eigenschaft können Sie einen geeigneten Wert zum Übergeben für die Methode <codeph>Microphone.setSilenceLevel()</codeph> ermitteln.
	 
	 <p>Wenn das Mikrofon verfügbar aber noch nicht im Einsatz ist, weil <codeph>Microphone.getMicrophone()</codeph> noch nicht aufgerufen wurde, wird diese Eigenschaft auf -1 gesetzt.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:codec:get"><apiName>codec</apiName><shortdesc>
	 Codec, der zur Komprimierung von Audiodaten verwendet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.getCodec, getCodec
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Codec, der zur Komprimierung von Audiodaten verwendet werden soll. Verfügbare Codecs sind Nellymoser (Standardeinstellung) und Speex. Die Enum-Klasse <codeph>SoundCodec</codeph> enthält die verschiedenen Werte, die für die <codeph>codec</codeph>-Eigenschaft gültig sind.
	 
	 <p>Wenn Sie den Nellymoser-Codec verwenden, können Sie die Samplerate über <codeph>Microphone.rate()</codeph> festlegen. Wenn Sie den Speex-Codec verwenden, ist die Samplerate auf 16 kHz eingestellt.</p>
	 
	 <p>Speex enthält eine Sprachaktivitätserkennung (VAD) und reduziert die Bandbreite automatisch, wenn keine Sprache erkannt wird. Wenn Sie den Speex-Codec verwenden, empfiehlt Adobe, die Abschaltschwelle (Silence-Level) auf 0 zu setzen. Verwenden Sie zum Einstellen der Abschaltschwelle die <codeph>Microphone.setSilenceLevel()</codeph>-Methode.</p>
	 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()s"><linktext>setSilenceLevel()s</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:encodeQuality:get"><apiName>encodeQuality</apiName><shortdesc>
	 Die kodierte Sprachqualität, wenn der Speex-Codec verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die kodierte Sprachqualität, wenn der Speex-Codec verwendet wird. Mögliche Werte sind 0 bis 10. Der Standardwert ist 6. Höhere Werte bedeuten eine höhere Qualität, erfordern aber auch mehr Bandbreite (wie in der folgenden Tabelle gezeigt). Die aufgelisteten Bitratenwerte sind Nettobitraten und enthalten keinen Paketierungsaufwand.
	 <p>
	  <adobetable class="innertable">
	 
	    
	    
	    
	    
	    
	    
	    
	    
	 
	    
	    
	  <tgroup cols="2"><thead><row><entry>Qualitätswert</entry><entry>Erforderliche Bitrate (Kilobit pro Sekunde)</entry></row></thead><tbody><row>
	      <entry>0</entry>
	      <entry> 3,95</entry>
	    </row><row>
	      <entry>1</entry>
	      <entry>5,75</entry>
	    </row><row>
	      <entry>2</entry>
	      <entry>7,75</entry>
	    </row><row>
	      <entry>3</entry>
	      <entry>9,80</entry>
	    </row><row>
	      <entry>4</entry>
	      <entry>12,8</entry>
	    </row><row>
	      <entry>5</entry>
	      <entry>16,8</entry>
	    </row><row>
	      <entry>6</entry>
	      <entry>20,6</entry>
	    </row><row>
	      <entry>7</entry>
	      <entry>23,8</entry>
	    </row><row>
	 <entry>8</entry>
	 <entry>27,8</entry>
	    </row><row>
	      <entry>9</entry>
	      <entry>34,2</entry>
	    </row><row>
	      <entry>10</entry>
	      <entry>42,2</entry>
	    </row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>Codec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:framesPerPacket:get"><apiName>framesPerPacket</apiName><shortdesc>
	 Anzahl der Speex-Sprachframes, die in einem Paket (Meldung) übertragen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Anzahl der Speex-Sprachframes, die in einem Paket (Meldung) übertragen werden . Jeder Frame hat eine Länge von 20 ms. Der Standardwert ist zwei Frames pro Paket.
	 
	 <p>Je mehr Speex-Frames in einer Meldung enthalten sind, desto niedriger ist die erforderliche Bandbreite, aber desto länger ist die Verzögerung beim Senden der Meldung. Weniger Speex-Frames erhöhen die erforderliche Bandbreite, reduzieren aber Verzögerungen.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:gain:get"><apiName>gain</apiName><shortdesc>
	 Betrag, um den das Mikrofon das Signal verstärkt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.gain, gain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Betrag, um den das Mikrofon das Signal verstärkt. Die zulässigen Werte liegen zwischen 0 und 100. Der Standardwert ist 50.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:index:get"><apiName>index</apiName><shortdesc>
	 Der Index des Mikrofons, der in dem durch „Microphone.names“ zurückgegebenen Array angegeben ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.index, index
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Der Index des Mikrofons, der in dem durch <codeph>Microphone.names</codeph> zurückgegebenen Array angegeben ist.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:muted:get"><apiName>muted</apiName><shortdesc>
	 Gibt an, ob der Benutzer den Zugriff auf das Mikrofon verweigert (true) oder gewährt hat (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.muted, muted
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob der Benutzer den Zugriff auf das Mikrofon verweigert (<codeph>true</codeph>) oder gewährt hat (<codeph>false</codeph>). Wenn sich dieser Wert ändert, wird ein <codeph>status</codeph>-Ereignis ausgelöst. Weitere Informationen finden Sie unter <codeph>Microphone.getMicrophone()</codeph>. 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/event:status"><linktext>flash.media.Microphone.status</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:name:get"><apiName>name</apiName><shortdesc>
	 Der Name des aktuellen Soundaufnahmegeräts, der von der Soundaufnahmehardware zurückgegeben wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.name, name
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Der Name des aktuellen Soundaufnahmegeräts, der von der Soundaufnahmehardware zurückgegeben wurde.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:names:get"><apiName>names</apiName><shortdesc>
	 Ein Array mit den Namen aller verfügbaren Soundaufnahmegeräte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.names, names
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Array mit den Namen aller verfügbaren Soundaufnahmegeräte. Die Namen werden zurückgegeben, ohne dass das Flash Player-Bedienfeld für die Zugriffsschutzeinstellungen für Benutzer angezeigt werden muss. Mit diesem Array wird über die <codeph>Microphone.names.length</codeph>-Eigenschaft der auf null basierende Index jedes Soundaufnahmegeräts sowie die Anzahl der Soundaufnahmegeräte im System angegeben. Weitere Informationen finden Sie im Abschnitt zur Array-Klasse.
	 
	 <p>Zum Aufrufen der <codeph>Microphone.names</codeph>-Eigenschaft ist eine genaue Überprüfung der Hardware erforderlich; daher kann das Erstellen des Arrays einige Sekunden dauern. In den meisten Fällen können Sie das Standardmikrofon verwenden.</p>
	 
	 <p><b>Hinweis:</b> Um den Namen des aktuellen Mikrofons festzustellen, verwenden Sie die <codeph>name</codeph>-Eigenschaft.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Array"><linktext>Array</linktext></link><link href="flash.media.xml#Microphone/name"><linktext>flash.media.Microphone.name</linktext></link><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:rate:get"><apiName>rate</apiName><shortdesc>
	 Die Abtastrate (in kHz), mit der das Mikrofon Sound aufnimmt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.rate, rate
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Abtastrate (in kHz), mit der das Mikrofon Sound aufnimmt. Akzeptable Werte sind 5, 8, 11, 22 und 44. Der Standardwert ist 8 kHz, sofern das Soundaufnahmegerät diesen Wert unterstützt. Andernfalls gilt als Standardwert die nächste verfügbare Aufnahmestufe über 8 kHz, die auf dem Soundaufnahmegerät unterstützt wird, gewöhnlich 11 kHz. Flash Player 10 und AIR 1.5 oder höher unterstützen eine Abtastrate von 16 kHz.
	 
	 <p><b>Hinweis:</b> Wenn Sie den Speex-Codec (<codeph>Microphone.codec = SoundCodec.SPEEX</codeph>) für Flash Player 10 und AIR 1.5 oder höher verwenden, ist die Standardabtastrate 16 kHz. Wenn Sie den Speex-Codec verwenden und dann den Codec-Wert in Nellymoser (<codeph>Microphone.codec = SoundCodec.NELLYMOSER</codeph>) ändern, bleibt die Abtastrate weiter auf 16 kHz eingestellt, bis Sie sie explizit auf einen neuen Wert einstellen. Um Audio mit Flash Player-Versionen vor Flash Player 10 und AIR-Versionen vor AIR 1.5 zu empfangen, ändern Sie beim Veröffentlichen von Audio sowohl den Codec als auch die Abtastrate.</p>
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>flash.media.Microphone.codec</linktext></link><link href="flash.media.xml#SoundCodec"><linktext>flash.media.SoundCodec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceLevel:get"><apiName>silenceLevel</apiName><shortdesc>
	 Die erforderliche Soundmenge zum Aktivieren des Mikrofons und zum Auslösen des activity-Ereignisses.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceLevel, silenceLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die erforderliche Soundmenge zum Aktivieren des Mikrofons und zum Auslösen des <codeph>activity</codeph>-Ereignisses. Der Standardwert ist 10.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceTimeout:get"><apiName>silenceTimeout</apiName><shortdesc>
	 Die Zeit in Millisekunden zwischen dem Zeitpunkt, zu dem mit dem Mikrofon kein Sound mehr erfasst wird, und dem Zeitpunkt, zu dem das activity-Ereignis ausgelöst wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceTimeout, silenceTimeout
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Zeit in Millisekunden zwischen dem Zeitpunkt, zu dem mit dem Mikrofon kein Sound mehr erfasst wird, und dem Zeitpunkt, zu dem das <codeph>activity</codeph>-Ereignis ausgelöst wird. Der Standardwert ist 2000 (2 Sekunden).
	 
	 <p>Um diesen Wert einzustellen, verwenden Sie die <codeph>Microphone.setSilenceLevel()</codeph>-Methode.</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Steuert den Sound dieses Microphone-Objekts im Loopback-Modus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Steuert den Sound dieses Microphone-Objekts im Loopback-Modus.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:useEchoSuppression:get"><apiName>useEchoSuppression</apiName><shortdesc>
	 Weist den Wert „true“ auf, wenn die Echounterdrückung aktiviert ist, andernfalls „false“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.useEchoSuppression, useEchoSuppression
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Weist den Wert <codeph>true</codeph> auf, wenn die Echounterdrückung aktiviert ist, andernfalls <codeph>false</codeph>. Der Standardwert ist <codeph>false</codeph>, es sei denn, der Benutzer hat im Flash Player-Bedienfeld für die Mikrofoneinstellungen die Option „Echo reduzieren“ gewählt.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.media:scanHardware"><apiName>scanHardware</apiName><shortdesc>
	 Erzwingt einen Neuscan der Mikrofone und Kameras auf dem System.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Erzwingt einen Neuscan der Mikrofone und Kameras auf dem System.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiClassifier id="flash.media:Camera"><apiName>Camera</apiName><shortdesc>
 Verwenden Sie die Camera-Klasse, um Video von einer Kamera aufzuzeichnen, die an einen Computer angeschlossen ist, auf dem Flash Player ausgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Verwenden Sie die Camera-Klasse, um Video von einer Kamera aufzuzeichnen, die an einen Computer angeschlossen ist, auf dem Flash Player ausgeführt wird. Mit der Videoklasse können Sie das Video lokal überwachen. Mit der NetConnection- und der NetStream-Klasse können Sie das Video an Flash Media Server übertragen. Flash Media Server kann den Videostream an andere Server senden und an andere Clients, auf denen Flash Player ausgeführt wird, übertragen.
 
 <p>
 Informationen zum Erfassen von Audio finden Sie in der Beschreibung der Microphone-Klasse.
 </p>
 
 <p>
 <b>Wichtig: </b>In Flash Player wird ein Zugriffsschutz-Dialogfeld angezeigt, in dem der Benutzer den Zugriff auf die Kamera zulassen oder verweigern kann. Achten Sie darauf, dass die Größe des Anwendungsfensters mindestens 215 x 138 Pixel beträgt. Dies ist die erforderliche Mindestgröße für die Anzeige des Dialogfelds.
 </p>
 
 <p>Zum Erstellen oder Referenzieren eines Camera-Objekts, verwenden Sie die <codeph>getCamera()</codeph>-Methode.</p>
 
 </apiDesc><example conref="examples\CameraExample.as"> Im folgenden Beispiel sehen Sie das von einer Kamera übertragene Bild, nachdem die Sicherheitswarnung bestätigt wurde. Die Bühne wurde so eingerichtet, dass es nicht skaliert werden kann und an der oberen linken Ecke des Player-Fensters ausgerichtet ist. Das Ereignis <codeph>activity</codeph> wird am Anfang und Ende (falls vorhanden) der Sitzung ausgelöst und von der Methode <codeph>activityHandler()</codeph> erfasst, woraufhin Informationen zum Ereignis ausgedruckt werden.
 
 <p><b>Hinweis:</b> Dieses Beispiel kann nur dann korrekt nachvollzogen werden, wenn eine Kamera mit dem Computer verbunden ist.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Camera;
    import flash.media.Video;

    public class CameraExample extends Sprite {
        private var video:Video;
        
        public function CameraExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            
            var camera:Camera = Camera.getCamera();
            
            if (camera != null) {
                camera.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                video = new Video(camera.width * 2, camera.height * 2);
                video.attachCamera(camera);
                addChild(video);
            } else {
                trace("You need a camera.");
            }
        }
        
        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links><adobeApiEvent id="flash.media:Camera_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Wird ausgelöst, wenn der Status einer Kamera protokolliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Status einer Kamera protokolliert wird. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Camera.Muted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf die Kamera verweigert. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Camera.Unmuted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf die Kamera gewährt.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>Camera.getCamera()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Camera_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Wird ausgelöst, wenn die Sitzung einer Kamera gestartet oder beendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn die Sitzung einer Kamera gestartet oder beendet wird. Rufen Sie <codeph>Camera.setMotionLevel()</codeph> auf, um festzulegen, wie viel Bewegung nötig ist, damit ein <codeph>activity</codeph>-Ereignis mit einem <codeph>activating</codeph>-Wert von <codeph>true</codeph> ausgelöst wird, oder um festzulegen, wie viel Zeit ohne Aktivität vergehen muss, bevor ein <codeph>activity</codeph>-Ereignis mit einem <codeph>activating</codeph>-Wert von <codeph>false</codeph> ausgelöst wird.
 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:Camera:getCamera"><apiName>getCamera</apiName><shortdesc>
	 Gibt eine Referenz auf ein Camera-Objekt zum Aufnehmen von Videos zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, constructor, Camera.getCamera, getCamera
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Wenn der <codeph>name</codeph>-Parameter nicht angegeben ist, gibt diese Methode einen Verweis auf die Standardkamera zurück, oder, wenn diese in einer anderen Kamera verwendet wird, auf die erste verfügbare Kamera. (Wenn mehrere Kameras installiert sind, kann der Benutzer im Flash Player-Bedienfeld für die Kameraeinstellungen die Standardkamera festlegen.) Wenn keine Kameras verfügbar oder installiert sind, gibt diese Methode den Wert <codeph>null</codeph> zurück. 
 	  
 	 </apiDesc><apiOperationClassifier>flash.media:Camera</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Gibt die abzurufende Kamera an, die in dem von der <codeph>names</codeph>-Eigenschaft zurückgegebenen Array festgelegt ist. In den meisten Anwendungen können Sie die Standardkamera durch Weglassen dieses Parameters abrufen. Um einen Wert für diesen Parameter festzulegen, verwenden Sie die Stringrepräsentation der auf Null basierenden Indexposition innerhalb des Camera.names-Arrays. Wenn Sie zum Beispiel die dritte Kamera im Array angeben möchten, verwenden Sie <codeph>Camera.getCamera("2")</codeph>. 
 	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt eine Referenz auf ein Camera-Objekt zum Aufnehmen von Videos zurück. Um mit der Videoaufnahme zu beginnen, muss das Camera-Objekt mit einem Videoobjekt verknüpft werden (siehe <codeph>Video.attachCamera() </codeph>). Wenn Sie Video an Flash Media Server übertragen möchten, rufen Sie <codeph>NetStream.attachCamera()</codeph> auf, um das Camera-Objekt mit einem NetStream-Objekt zu verknüpfen.
	 
	 <p>Mehrere Aufrufe der <codeph>getCamera()</codeph>-Methode verweisen auf denselben Kameratreiber. Wenn der Code Elemente wie <codeph>firstCam:Camera = getCamera()</codeph> und <codeph>secondCam:Camera = getCamera()</codeph> enthält, verweisen <codeph>firstCam</codeph> und <codeph>secondCam</codeph> somit auf dieselbe Kamera, bei der es sich um die Standardkamera des Benutzers handelt.</p>
	 
	 <p>Im Allgemeinen muss kein Wert für den <codeph>name</codeph>-Parameter übergeben werden. Verwenden Sie einfach <codeph>getCamera()</codeph>, um einen Verweis auf die Standardkamera zurückzugeben. Im Bedienfeld für die Kameraeinstellungen kann der Benutzer eine Standardkamera für Flash Player angeben (Informationen hierzu weiter unten in diesem Abschnitt). </p>
	 
  	 <p>Sie können ActionScript nicht verwenden, um die Berechtigungseinstellung „Zulassen“ oder „Verweigern“ für den Kamerazugriff festzulegen, Sie können jedoch das Adobe Flash Player Dialogfeld für die Kameraeinstellungen anzeigen, in dem der Benutzer den Kamerazugriff steuern kann. Wenn eine SWF-Datei mit der <codeph>attachCamera()</codeph>-Methode versucht, die von der <codeph>getCamera()</codeph>-Methode zurückgegebene Kamera mit einem Video- oder NetStream-Objekt zu verbinden, zeigt Flash Player ein Dialogfeld an, in dem der Benutzer den Zugriff auf die Kamera zulassen oder verweigern kann. (Achten Sie darauf, dass die Größe des Anwendungsfensters mindestens 215 x 138 Pixel beträgt. Dies ist die in Flash Player erforderliche Mindestgröße für die Anzeige des Dialogfelds.) Nachdem der Benutzer im Dialogfeld für die Kameraeinstellungen eine Option ausgewählt hat, wird in Flash Player ein Informationsobjekt im <codeph>status</codeph>-Ereignis zurückgegeben, das die Auswahl des Benutzers angibt. Mit <codeph>Camera.muted</codeph> wird angegeben, dass der Benutzer den Zugriff auf eine Kamera verweigert hat. Mit <codeph>Camera.Unmuted</codeph> wird angegeben, dass der Benutzer den Zugriff auf eine Kamera gewährt hat. Über die <codeph>muted</codeph>-Eigenschaft können Sie ohne Bearbeitung des <codeph>status</codeph>-Ereignisses feststellen, ob ein Benutzer den Zugriff auf eine Kamera verweigert oder gewährt hat.</p>
  	 
 	 <p>Der Benutzer kann permanente Zugriffsschutzeinstellungen für eine bestimmte Domäne festlegen, indem er während des Abspielens einer SWF-Datei mit der rechten Maustaste (Windows und Linux) bzw. bei gedrückter Ctrl-Taste (Mac OS) klickt, „Einstellungen“ auswählt, das Dialogfeld „Zugriffsschutz“ öffnet und „Speichern“ auswählt. Wenn ein Benutzer „Speichern“ auswählt, wird er in Flash Player nicht mehr dazu aufgefordert, den Zugriff von SWF-Dateien in der Domäne auf die Kamera zu gewähren oder zu verweigern.</p>
  	 
  	 <p><b>Hinweis:</b> Die <codeph>attachCamera()</codeph>-Methode ruft das Dialogfeld zum Zulassen oder Verweigern des Zugriffs auf die Kamera nicht auf, wenn der Benutzer den Zugriff verweigert hat, indem er in den Flash Player-Einstellungen die Einstellung „Speichern“ gewählt hat. In diesem Fall können Sie den Benutzer auffordern, die Einstellung „Zulassen“ oder „Verweigern“ zu ändern, indem Sie mit <codeph>Security.showSettings(SecurityPanel.PRIVACY)</codeph> das Bedienfeld „Zugriffsschutz“ von Flash Player für den Benutzer anzeigen.</p>
 	 
 	 <p>Wenn <codeph>getCamera()</codeph> den Wert <codeph>null</codeph> zurückgibt, wird die Kamera entweder gerade in einer anderen Anwendung verwendet oder im System sind keine Kameras installiert. Mithilfe der <codeph>names.length</codeph>-Eigenschaft können Sie feststellen, ob Kameras installiert sind. Um das Kameraeinstellungsbedienfeld von Flash Player anzuzeigen, in dem der Benutzer die Kamera wählen kann, die von <codeph>getCamera()</codeph> referenziert werden soll, verwenden Sie <codeph>Security.showSettings(SecurityPanel.CAMERA)</codeph>. </p>
 	 
	 <p>Der Suchlauf zum Überprüfen der Hardware auf installierte Kameras kann einige Zeit in Anspruch nehmen. Wenn Flash Player mindestens eine Kamera gefunden hat, wird der Suchlauf für diese Player-Instanz nicht noch einmal durchgeführt. Wenn von Flash Player jedoch keine Kameras gefunden werden, wird der Suchlauf bei jedem Aufruf von <codeph>getCamera</codeph> durchgeführt. Diese Funktion ist besonders hilfreich, wenn der Benutzer vergessen hat, die Kamera anzuschließen. Sofern Ihre SWF-Datei eine Schaltfläche „Wiederholen“ besitzt, mit der <codeph>getCamera</codeph> aufgerufen wird, kann Flash Player nach der Kamera suchen, ohne dass die SWF-Datei erneut gestartet werden muss.</p>
 	 
	 </apiDesc><example conref="examples\Camera_getCameraExample.as"> Im folgenden Beispiel wird die angeschlossene Kamera zum Erfassen von Videobildern verwendet, nachdem der Benutzer den Zugriff auf die Kamera zugelassen hat. Informationen über den Videostream, zum Beispiel Bilder (Frames) pro Sekunde, werden ebenfalls angezeigt.
 
 <p>Die <codeph>Camera.getCamera()</codeph>-Methode gibt einen Verweis auf ein Kameraobjekt zurück oder null, falls keine Kamera verfügbar oder installiert ist. Mit der if-Anweisung wird überprüft, ob die Kamera gefunden wurde und ob der Benutzer den Zugriff auf die Kamera zugelassen hat. Wenn der Benutzer den Zugriff verweigert hat, ist die <codeph>muted</codeph>-Eigenschaft mit dem Wert <codeph>true</codeph> belegt.</p> 
 
 <p>Wenn die <codeph>attachCamera()</codeph>-Methode aufgerufen wird, wird ein Dialogfeld angezeigt und fordert den Benutzer auf, den Flash Player-Zugriff auf die Kamera zuzulassen oder zu verweigern. Hat der Benutzer jedoch den Zugriff verweigert und die Option <codeph>Erinnern</codeph> gewählt, wird das Dialogfeld nicht geöffnet und es wird nichts angezeigt. Um sicherzustellen, dass der Benutzer die Möglichkeit hat, den Zugriff auf die Kamera zuzulassen, weist das Textfeld <codeph>myTextField</codeph> den Benutzer an, auf das Textfeld zu klicken, um die Flash Player-Einstellungen anzuzeigen.</p>
 
 <p>Die <codeph>clickHandler()</codeph>-Methode ruft die <codeph>Security.showSettings()</codeph>-Methode auf, die das Bedienfeld <codeph>Zugriffsschutz</codeph> des Dialogfelds „Einstellungen“ anzeigt. Wenn der Benutzer den Zugriff zulässt, wird das <codeph>StatusEvent.STATUS</codeph>-Ereignis ausgelöst und der Wert der <codeph>code</codeph>-Eigenschaft des Ereignisses wird auf <codeph>Camera.Unmuted</codeph> gesetzt. (Die <codeph>mute</codeph>-Eigenschaft des Kameraobjekts ist ebenfalls auf <codeph>false</codeph> gesetzt.)</p>
 
 <p>Die <codeph>statusHandler()</codeph>-Methode, die hinzugefügt wird, um die Statusänderung der Benutzereinstellung zu überprüfen, ruft die <codeph>connectCamera()</codeph>-Methode auf, wenn der Benutzer den Zugriff zulässt. Die <codeph>connectCamera()</codeph>-Methode instanziiert ein Videoobjekt mit der Breite und Höhe des erfassten Streams. Um das von der Kamera erfasste Video anzuzeigen, wird der Verweis auf den Videostream zum Videoobjekt hinzugefügt und das Videoobjekt wird der Anzeigeliste hinzugefügt.</p>
 
 <p>Ein Timerobjekt wird ebenfalls gestartet. Jede Sekunde wird ein Timerereignis eines Timerobjekts ausgelöst und die <codeph>timerHandler()</codeph>-Methode wird aufgerufen. Die <codeph>timerHandler()</codeph>-Methode wird angezeigt und aktualisiert mehrere Eigenschaften des Camera-Objekts. </p> 
 <p><b>Hinweis:</b> In diesem Beispiel wird nur die <codeph>currentFPS</codeph>-Eigenschaft geändert.</p>    
    
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.StatusEvent;
    import flash.events.MouseEvent;
    import flash.system.SecurityPanel;
    import flash.system.Security;

    public class Camera_getCameraExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);
        
        public function Camera_getCameraExample() {
            myTextField = new TextField();
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";
                
            } else if (cam.muted) {
                myTextField.text = "To enable the use of the camera,\n"
                                 + "please click on this text field.\n" 
                                 + "When the Flash Player Settings dialog appears,\n"
                                 + "make sure to select the Allow radio button\n" 
                                 + "to grant access to your camera.";

                myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            }else {
                myTextField.text = "Connecting";
                connectCamera(); 
            }
   
            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            Security.showSettings(SecurityPanel.PRIVACY);

            cam.addEventListener(StatusEvent.STATUS, statusHandler);

            myTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function statusHandler(event:StatusEvent):void {

            if (event.code == "Camera.Unmuted") {
                connectCamera(); 
                cam.removeEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                t.start();
        }

        private function timerHandler(event:TimerEvent):void {
            myTextField.y = cam.height + 20;
            myTextField.text = "";
            myTextField.appendText("bandwidth: " + cam.bandwidth + "\n");
            myTextField.appendText("currentFPS: " + Math.round(cam.currentFPS) + "\n");
            myTextField.appendText("fps: " + cam.fps + "\n");
            myTextField.appendText("keyFrameInterval: " + cam.keyFrameInterval + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/muted"><linktext>muted</linktext></link><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links><adobeApiEvent id="flash.media:Camera:getCamera_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Status einer Kamera protokolliert wird. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Camera.muted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf die Kamera verweigert. Wenn der Wert der <codeph>code</codeph>-Eigenschaft auf <codeph>"Camera.Unmuted"</codeph> gesetzt ist, hat der Benutzer den Zugriff der SWF-Datei auf die Kamera gewährt.
 	 </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Status einer Kamera protokolliert wird.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Camera:setKeyFrameInterval"><apiName>setKeyFrameInterval</apiName><shortdesc>
	 Gibt die Videobilder an, die vollständig übertragen (sogenannte Keyframes) und nicht mit dem Algorithmus zur Videokomprimierung interpoliert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>keyFrameInterval</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Ein Wert, mit dem die Videobilder angegeben werden, die vollständig (als Schlüsselbilder) übertragen und nicht mit dem Algorithmus zur Videokomprimierung interpoliert werden. Beim Wert 1 ist jedes Bild ein Schlüsselbild, beim Wert 3 ist jedes dritte Bild ein Schlüsselbild usw. Die zulässigen Werte liegen zwischen 1 und 48.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt die Videobilder an, die vollständig übertragen (sogenannte <i>Schlüsselbilder</i>) und nicht mit dem Algorithmus zur Videokomprimierung interpoliert werden. Diese Methode ist nur bei der Übertragung von Videos über Flash Media Server anwendbar.
	 
	 <p>Mit dem Algorithmus zur Videokomprimierung in Flash werden Videos so komprimiert, dass nur die ab dem letzten Bild eines Videos geänderten Bildbereiche übertragen werden. Diese Abschnitte werden als interpolierte Bilder bezeichnet. Bilder eines Videos können entsprechend dem Inhalt des vorherigen Bilds interpoliert werden. Bei einem Schlüsselbild handelt es sich jedoch um ein vollständiges Videobild, das nicht aus vorherigen Bildern interpoliert wurde.</p> 
	 
	 <p>Berücksichtigen Sie zum Festlegen eines Werts für den <codeph>keyFrameInterval</codeph>-Parameter die Bandbreitennutzung und den Zugriff auf die Videowiedergabe. Durch die Angabe eines höheren Werts für <codeph>keyFrameInterval</codeph> (weniger häufiges Senden von Schlüsselbildern) wird beispielsweise die Bandbreitennutzung verringert. Dadurch wird jedoch möglicherweise die erforderliche Zeit zum Positionieren des Abspielkopfes an einem bestimmten Punkt im Video erhöht. Unter Umständen muss eine höhere Anzahl Videobilder interpoliert werden, damit die Wiedergabe des Videos fortgesetzt werden kann.</p> 
	 
	 <p>Durch die Angabe eines niedrigen Werts für <codeph>keyFrameInterval</codeph> (häufiges Senden von Schlüsselbildern) wird dagegen die Bandbreitennutzung erhöht, da häufiger vollständige Videobilder übertragen werden. Gleichzeitig wird möglicherweise jedoch die erforderliche Zeit zum Suchen eines bestimmten Videobilds in einem aufgenommenen Video verringert.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/keyFrameInterval"><linktext>keyFrameInterval</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setLoopback"><apiName>setLoopback</apiName><shortdesc>
	 Gibt an, ob ein komprimierter Videostream für die lokale Wiedergabe der Kamera verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>compress</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob für die lokale Wiedergabe der Kameraaufnahmen ein komprimierter Videostream (<codeph>true</codeph>) oder ein unkomprimierter Stream (<codeph>false</codeph>) verwendet wird.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob ein komprimierter Videostream für die lokale Wiedergabe der Kamera verwendet wird. Diese Methode kann nur bei der Übertragung von Videos mit Flash Media Server angewendet werden. Durch Setzen von <codeph>compress</codeph> auf <codeph>true</codeph> kann präziser angezeigt werden, wie ein Video bei der Wiedergabe in Echtzeit wiedergegeben wird.
	 
	 <p>Obwohl ein komprimierter Stream für Testzwecke nützlich ist, beispielsweise bei der Vorschau der Einstellungen für die Videoqualität, entsteht dadurch ein erheblicher Verarbeitungsaufwand. Die lokale Wiedergabe wird nicht einfach nur komprimiert, sie wird komprimiert, wie bei einer Live-Verbindung für die Übertragung bearbeitet und dann für die lokale Wiedergabe dekomprimiert.</p>
	 
	 <p>Wenn Sie <codeph>compress</codeph> auf <codeph>true</codeph> setzen, können Sie die Stärke der Komprimierung über <codeph>Camera.setQuality()</codeph> festlegen.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMode"><apiName>setMode</apiName><shortdesc>
	 Legt als Kameraaufnahmemodus den systemeigenen Modus fest, mit dem die angegebenen Kriterien am besten erfüllt werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMode, setMode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die erforderliche Aufnahmebildbreite in Pixel. Der Standardwert ist 160.	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die angeforderte Aufnahmebildhöhe in Pixel. Der Standardwert ist 120.	 
	 </apiDesc></apiParam><apiParam><apiItemName>fps</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die erforderliche Rate in Bildern pro Sekunde, mit der die Kamera Daten erfassen soll. Der Standardwert ist 15.	 
	 </apiDesc></apiParam><apiParam><apiItemName>favorArea</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Gibt an, ob die Breite, Höhe und Bildrate geändert werden sollen, wenn die Kamera über keinen systemeigenen Modus verfügt, mit dem die angegebenen Kriterien erfüllt werden. Der Standardwert ist <codeph>true</codeph>, dabei hat die gewünschte Bildgröße Vorrang. Bei diesem Parameter wird der Modus ausgewählt, der den Werten <codeph>width</codeph> und <codeph>height</codeph> am nächsten kommt, auch wenn dadurch die Bildrate reduziert und die Leistung verschlechtert wird. Soll die Bildrate Vorrang vor den Werten für Höhe und Breite haben, übergeben Sie den Wert <codeph>false</codeph> für den Parameter<codeph>favorArea</codeph>.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt als Kameraaufnahmemodus den systemeigenen Modus fest, mit dem die angegebenen Kriterien am besten erfüllt werden. Wenn die Kamera über keinen systemeigenen Modus verfügt, der mit allen übergebenen Parametern übereinstimmt, wird in Flash Player ein Aufnahmemodus ausgewählt, der dem gewünschten Modus am ehesten entspricht. Bei diesem Vorgang werden möglicherweise Teile des Videobilds abgeschnitten sowie Bilder übersprungen. 
	 
	 <p>Standardmäßig überspringt Flash Player Bilder, sofern dies zum Beibehalten der gewünschten Bildgröße erforderlich ist. Um die Anzahl der übersprungenen Bilder zu minimieren, auch wenn dazu ggf. die Bildgröße reduziert werden muss, übergeben Sie den Wert <codeph>false</codeph> für den Parameter <codeph>favorArea</codeph>.</p>
	 
	 <p>Bei Auswahl eines systemeigenen Modus wird in Flash Player versucht, das gewünschte Bildseitenverhältnis möglichst beizubehalten. Wenn Sie beispielsweise den Befehl <codeph>myCam.setMode(400, 400, 30)</codeph> ausgeben und die maximalen Werte der Kamera für Breite und Höhe 320 und 288 betragen, werden in Flash Player sowohl die Breite als auch die Höhe auf den Wert 288 gesetzt. So wird in Flash Player das gewünschte Bildseitenverhältnis von 1:1 beibehalten.</p>
	 
	 <p>Wenn Sie überprüfen möchten, welche Werte diesen Eigenschaften zugewiesen wurden, nachdem in Flash Player der Modus ausgewählt wurde, der den gewünschten Werten am nächsten kommt, verwenden Sie die Eigenschaften <codeph>width</codeph>, <codeph>height</codeph> und <codeph>fps</codeph>.</p>
	 
	 <p>
	 Wenn Sie Flash Media Server verwenden, können Sie auch einzelne Bilder erfassen oder Zeitrafferaufnahmen erstellen. Weitere Informationen finden Sie unter <codeph>NetStream.attachCamera()</codeph>.
	 </p>
	 
	 </apiDesc><example conref="examples\Camera_setModeExample.as"> Im folgenden Beispiel wird die Größe des Videos geändert und die Aufnahmerate Bilder pro Sekunde wird auf einen neuen Wert gesetzt, wenn ein Benutzer auf die Bühne klickt.  
 
 <p>Die Bühne ist festgelegt und wird somit nicht skaliert. Die <codeph>Camera.getCamera()</codeph>-Methode gibt einen Verweis auf ein Kameraobjekt zurück oder null, falls keine Kamera verfügbar oder installiert ist. Falls eine Kamera vorhanden ist, wird die <codeph>connectCamera()</codeph>-Methode aufgerufen. Die <codeph>connectCamera()</codeph>-Methode instanziiert ein Videoobjekt. Um das von der Kamera erfasste Video anzuzeigen, wird der Verweis auf den Videostream zum Videoobjekt hinzugefügt und das Videoobjekt wird der Anzeigeliste hinzugefügt. Ein Ereignis-Listener für ein <codeph>MouseEvent.CLICK</codeph>-Ereignis wird ebenfalls eingerichtet. Nachdem der Benutzer auf die Bühne geklickt hat, wird die Methode <codeph>clickHandler()</codeph> aufgerufen. Die Methode überprüft die Breite des erfassten Videos und legt die Breite, die Höhe und die Anforderungsrate für Bilder pro Sekunde für den Aufnahmemodus der Kamera fest. Damit diese Einstellungen wirksam werden, muss das Videoobjekt entfernt und neu erstellt werden. Die Breite und die Höhe des Videos muss auf die Breite und Höhe des Kameraobjekts eingestellt werden.</p>      
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.events.MouseEvent;
    import flash.display.StageScaleMode;

    public class Camera_setModeExample extends Sprite {
        private var cam:Camera;
        private var vid:Video;

        public function Camera_setModeExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;

            cam = Camera.getCamera();
            
            if (!cam) {
                trace("No camera is installed.");
            }else {
                connectCamera();
            }
        }

        private function connectCamera():void {
            vid = new Video();
            vid.width = cam.width;
            vid.height = cam.height; 
            vid.attachCamera(cam);
            addChild(vid);    

            stage.addEventListener(MouseEvent.CLICK, clickHandler);
        }
    
        private function clickHandler(e:MouseEvent):void {

            switch (cam.width) {
                case 160:
                cam.setMode(320, 240, 10); 
                break;
                case 320:
                cam.setMode(640, 480, 5); 
                break;
                default:
                cam.setMode(160, 120, 15); 
                break;
            } 

            removeChild(vid);           
            connectCamera();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/fps"><linktext>fps</linktext></link><link href="flash.media.xml#Camera/height"><linktext>height</linktext></link><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.net.xml#NetStream/attachCamera()"><linktext>flash.net.NetStream.attachCamera()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMotionLevel"><apiName>setMotionLevel</apiName><shortdesc>
	 Gibt die erforderliche Bewegungsstärke zum Auslösen des activity-Ereignisses an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMotionLevel, setMotionLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>motionLevel</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Gibt die erforderliche Bewegungsstärke zum Auslösen des <codeph>activity</codeph>-Ereignisses an. Die zulässigen Werte liegen zwischen 0 und 100. Der Standardwert ist 50.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>2000</apiData><apiDesc>Gibt die Zeit in Millisekunden an, die ohne Aktivität vergehen muss, bevor Flash Player keine Aktivität mehr feststellt und das <codeph>activity</codeph>-Ereignis ausgelöst wird. Der Standardwert ist 2000 Millisekunden (2 Sekunden).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt die erforderliche Bewegungsstärke zum Auslösen des <codeph>activity</codeph>-Ereignisses an. Gibt optional die Zeit in Millisekunden an, die ohne Aktivität vergehen muss, bevor in Flash Player keine Bewegung mehr festgestellt und das Ereignis ausgelöst wird. 
	 <p><b>Hinweis: </b> Videos können unabhängig vom Wert des <codeph>motionLevel</codeph>-Parameters wiedergegeben werden. Dieser Parameter legt nur fest, wann und unter welchen Umständen das Ereignis ausgelöst wird, nicht jedoch, ob tatsächlich Videodaten aufgezeichnet oder wiedergegeben werden.</p>
	 <p>
	 Wenn die Kamera überhaupt keine Bewegung erkennen soll, legen Sie für den <codeph>motionLevel</codeph>-Parameter den Wert 100 fest. Das <codeph>activity</codeph>-Ereignis wird dann nie ausgelöst. (Dieser Wert wird wahrscheinlich nur für Testzwecke verwendet, beispielsweise um vorübergehend alle Prozeduren zu deaktivieren, die bei diesem Ereignis normalerweise ausgelöst werden.)
	 </p>
	 <p>
	 Über die <codeph>activityLevel</codeph>-Eigenschaft können Sie feststellen, welche Bewegungsstärke derzeit mit der Kamera erkannt wird. Die Bewegungstoleranzwerte entsprechen direkt den Aktivitätswerten. Völliges Fehlen von Bewegung entspricht dem Aktivitätswert 0. Ständige Bewegung entspricht dem Aktivitätswert 100. Bei fehlender Bewegung ist der Aktivitätswert niedriger als die Bewegungstoleranz, bei Bewegung übersteigen die Aktivitätswerte häufig die Bewegungstoleranz.
	 </p>
	 <p>
	 Diese Methode ähnelt <codeph>Microphone.setSilenceLevel()</codeph>. Mit beiden Methoden wird angegeben, zu welchem Zeitpunkt das <codeph>activity</codeph>-Ereignis ausgelöst werden soll. Diese Methoden haben jedoch deutlich unterschiedliche Auswirkungen auf das Veröffentlichen von Streams:
	 </p>
	 
	 <ul>
	   <li><codeph>Microphone.setSilenceLevel()</codeph> dient zur Optimierung der Bandbreite. Wenn ein Audiostream als lautlos eingestuft wird, werden keine Audiodaten gesendet. Stattdessen wird eine Meldung gesendet, um den Beginn der Inaktivität (Stille) anzuzeigen. </li>
	   <li><codeph>Camera.setMotionLevel()</codeph> ist dazu bestimmt, Bewegung festzustellen und hat keinen Einfluss auf die Bandbreitenauslastung. Auch wenn ein Videostream keine Bewegung feststellt, werden weiterhin Videodaten gesendet.</li>
	 </ul>
	   
	 
	 
	 </apiDesc><example conref="examples\Camera_setMotionLevelExample.as"> Im folgenden Beispiel wird die Kamera des Benutzers als Überwachungskamera eingesetzt. Die Kamera erkennt Bewegungen und ein Textfeld zeigt die Aktivitätsstufe an. (Das Beispiel kann erweitert werden, sodass ein akustischer Alarm ausgegeben oder eine Nachricht über einen Webdienst an andere Anwendungen gesendet wird.)
 
 <p>Die <codeph>Camera.getCamera()</codeph>-Methode gibt einen Verweis auf ein Kameraobjekt zurück oder null, falls keine Kamera verfügbar oder installiert ist. Die if-Anweisung überprüft, ob eine Kamera verfügbar ist und ruft die <codeph>connectCamera()</codeph>-Methode auf, wenn dies der Fall ist. Die <codeph>connectCamera()</codeph>-Methode instanziiert ein Videoobjekt mit der Breite und Höhe des erfassten Streams. Um das von der Kamera erfasste Video anzuzeigen, wird der Verweis auf den Videostream zum Videoobjekt hinzugefügt und das Videoobjekt wird der Anzeigeliste hinzugefügt. (Wenn die <codeph>attachCamera()</codeph>-Methode aufgerufen wird, wird ein Dialogfeld angezeigt und fordert den Benutzer auf, den Flash Player-Zugriff auf die Kamera zuzulassen oder zu verweigern. Hat der Benutzer jedoch den Zugriff verweigert und die Option <codeph>Erinnern</codeph> gewählt, wird das Dialogfeld nicht geöffnet und es wird nichts angezeigt. Um sicherzustellen, dass der Benutzer die Möglichkeit hat, den Zugriff auf die Kamera zuzulassen, rufen Sie mit der <codeph>system.Security.showSettings()</codeph>-Methode das Flash Player-Dialogfeld „Einstellungen“ auf.)</p>
 
 <p>Die <codeph>setMotionLevel()</codeph>-Methode legt die Aktivitätsstufe (Bewegungsstärke) auf 5 für minimale Bewegung fest, bevor das Aktivitätsereignis aufgerufen wird. Die Zeit zwischen dem Zeitpunkt, zu dem die Kamera mit dem Erkennen der Bewegung aufhört, und dem Auslösen des Aktivitätsereignisses ist auf 1 Sekunde (1000 Millisekunden) festgelegt. Wenn 1 Sekunde ohne Aktivität verstreicht oder die Aktivitätsstufe 5 erreicht wird, wird das <codeph>ActivityEvent.ACTIVITY</codeph>-Ereignis ausgelöst und die <codeph>activityHandler()</codeph>-Methode aufgerufen. Wenn das Ereignis durch die Aktivitätsstufe ausgelöst wurde, wird die <codeph>activating</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt und ein Timerobjekt gestartet. Jede Sekunde wird ein Timerereignis für das Timerobjekt ausgelöst und die <codeph>timerHandler()</codeph>-Methode wird aufgerufen, die die aktuelle Aktivitätsstufe anzeigt. (Auch wenn der Timer durch die Stufe 5 oder höher ausgelöst wird, kann die angezeigte Aktivitätsstufe darunter liegen.)</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.ActivityEvent;

    public class Camera_setMotionLevelExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);

        public function Camera_setMotionLevelExample() {
            myTextField = new TextField();
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";

            }else {
                myTextField.text = "Waiting to connect.";
                connectCamera(); 
            }

            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                cam.setMotionLevel(5, 1000);
                cam.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
        }

        private function activityHandler(e:ActivityEvent):void {
            if (e.activating == true) {
                t.start();    
            } else {
                myTextField.text = "Everything is quiet.";
                t.stop();
            }    
        }

        private function timerHandler(event:TimerEvent):void {
             myTextField.x = 10;
             myTextField.y = cam.height + 20;
             myTextField.text = "There is some activity. Level: " + cam.activityLevel;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/motionTimeout"><linktext>motionTimeout</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>Microphone.setSilenceLevel()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setQuality"><apiName>setQuality</apiName><shortdesc>
	 Legt die maximale Bandbreite pro Sekunde oder die erforderliche Bildqualität des aktuell ausgehenden Videofeeds fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera.setQuality, setQuality
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bandwidth</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Gibt die maximale Bandbreitennutzung für den aktuell ausgehenden Videofeed in Byte pro Sekunde an. Wenn für Flash Player-Videos so viel Bandbreite verwendet werden soll, wie für die gewünschte <codeph>quality</codeph> erforderlich ist, belegen Sie <codeph>bandwidth</codeph> mit dem Wert 0. Der Standardwert ist 16384.	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Eine Ganzzahl, die die erforderliche Bildqualität angibt, die sich aus dem Grad der Komprimierung aller Videobilder ergibt. Die zulässigen Werte liegen zwischen 1 (niedrigste Qualität, maximale Komprimierung) und 100 (höchste Qualität, keine Komprimierung). Soll die Bildqualität bei Bedarf geändert werden, um eine Überschreitung der Bandbreite zu verhindern, belegen Sie <codeph>quality</codeph> mit 0. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt die maximale Bandbreite pro Sekunde oder die erforderliche Bildqualität des aktuell ausgehenden Videofeeds fest. Diese Methode ist in der Regel nur bei der Übertragung von Videos über Flash Media Server anwendbar.
	 
	 <p>Mit dieser Methode können Sie festlegen, ob die Ausnutzung der Bandbreite oder die Bildqualität des ausgehenden Videofeeds für die Anwendung Vorrang haben soll.</p>
	 
	 <ul>
	   <li>Soll die Ausnutzung der Bandbreite Vorrang haben, geben Sie einen Wert für <codeph>bandwidth</codeph> an und belegen <codeph>quality</codeph> mit dem Wert 0. Flash Player überträgt Video dann innerhalb der angegebenen Bandbreite mit der bestmöglichen Qualität. Die Bildqualität wird von Flash Player gegebenenfalls verringert, um eine Überschreitung der angegebenen Bandbreite zu verhindern. Allgemein gilt, dass bei stärkerer Bewegung die Qualität abnimmt.</li>
	   <li>Soll die Qualität Vorrang haben, belegen Sie <codeph>bandwidth</codeph> mit dem Wert 0 und geben für <codeph>quality</codeph> einen numerischen Wert an. Flash Player verwendet dann so viel Bandbreite, wie zum Beibehalten der angegebenen Qualität erforderlich ist. Die Bildrate wird von Flash Player gegebenenfalls verringert, um die Bildqualität beizubehalten. Allgemein gilt, dass sich bei stärkerer Bewegung auch die Nutzung der Bandbreite erhöht.</li>
	   <li>Übergeben Sie numerische Werte für beide Parameter, um anzugeben, dass Bandbreite und Bildqualität gleichermaßen wichtig sind. Flash Player überträgt Video mit der angegebenen Qualität, ohne die angegebene Bandbreite zu überschreiten. Die Bildrate wird von Flash Player gegebenenfalls verringert, um die Bildqualität ohne Überschreiten der angegebenen Bandbreite beizubehalten.</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/quality"><linktext>quality</linktext></link></related-links></apiOperation><apiValue id="flash.media:Camera:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 Die von der Kamera erkannte Menge an Bewegung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die von der Kamera erkannte Menge an Bewegung. Die zulässigen Werte liegen zwischen 0 (keine erfasste Bewegung) und 100 (sehr starke Bewegung). Anhand des Werts dieser Eigenschaft können Sie ermitteln, ob eine Einstellung für die <codeph>setMotionLevel()</codeph>-Methode übergeben werden muss.
	 <p>Wenn die Kamera verfügbar ist, aufgrund eines nicht erfolgten <codeph>Video.attachCamera()</codeph>-Aufrufs noch nicht verwendet wird, wird diese Eigenschaft auf -1 gesetzt.</p>
	 <p>Beim Streaming ausschließlich unkomprimierter lokaler Videos wird diese Eigenschaft nur dann gesetzt, wenn der Ereignisprozedur eine Funktion zugewiesen wurde. Andernfalls ist diese Eigenschaft nicht definiert.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:bandwidth:get"><apiName>bandwidth</apiName><shortdesc>
	 Die Bandbreite (in Byte), die für den momentan ausgehenden Videofeed maximal zur Verfügung steht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.bandwidth, bandwidth
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Bandbreite (in Byte), die für den momentan ausgehenden Videofeed maximal zur Verfügung steht. Der Wert 0 bedeutet, dass der Feed die zur Beibehaltung der gewünschten Bildqualität erforderliche Bandbreite für Videos nutzen kann.
	 <p>Legen Sie diese Eigenschaft über die <codeph>setQuality()</codeph>-Methode fest.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>	
	 Die Abtastrate in Bildern pro Sekunde, mit der die Kamera Daten erfasst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.currentFPS, currentFPS
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>	
	 Die Abtastrate in Bildern pro Sekunde, mit der die Kamera Daten erfasst. Diese Eigenschaft kann nicht eingestellt werden. Mit der <codeph>setMode()</codeph>-Methode können Sie jedoch die verwandte Eigenschaft <codeph>fps</codeph> festlegen, welche die maximale Bildrate angibt, mit der die Kamera Daten erfassen soll. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:fps:get"><apiName>fps</apiName><shortdesc>
	 Die maximale Rate in Bildern pro Sekunde, mit der die Kamera Daten erfassen kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.fps, fps
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die maximal Rate in Bildern pro Sekunde, mit der die Kamera Daten erfassen kann. Die höchstmögliche Rate richtet sich nach den Möglichkeiten der Kamera; diese Bildrate wird möglicherweise nicht erzielt.
	 <ul>
	   <li>Über die <codeph>setMode()</codeph>-Methode können Sie den gewünschten Wert für diese Eigenschaft festlegen.</li>
	   <li>Verwenden Sie die <codeph>currentFPS</codeph>-Eigenschaft, um festzustellen, mit welcher Abtastrate die Kamera derzeit Daten erfasst.</li>
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/currentFPS"><linktext>currentFPS</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:height:get"><apiName>height</apiName><shortdesc>
	 Die aktuelle Aufnahmebildhöhe in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.height, height
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die aktuelle Aufnahmebildhöhe in Pixel. Über die <codeph>setMode()</codeph>-Methode können Sie einen Wert für diese Eigenschaft festlegen. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:index:get"><apiName>index</apiName><shortdesc>
	 Eine auf null basierende Ganzzahl, die den Index der Kamera anhand des von der names-Eigenschaft zurückgegebenen Arrays angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.index, index
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Eine auf null basierende Ganzzahl, die den Index der Kamera anhand des von der <codeph>names</codeph>-Eigenschaft zurückgegebenen Arrays angibt.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:keyFrameInterval:get"><apiName>keyFrameInterval</apiName><shortdesc>
	 Die Anzahl der Videobilder, die vollständig übertragen (sogenannte Keyframes) und nicht mit dem Algorithmus zur Videokomprimierung interpoliert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl der Videobilder, die vollständig übertragen (sogenannte <i>Schlüsselbilder</i>) und nicht mit dem Algorithmus zur Videokomprimierung interpoliert werden. Der Standardwert ist 15, d. h., jedes fünfzehnte Bild ist ein Schlüsselbild. Der Wert 1 bedeutet, dass jedes Bild ein Schlüsselbild ist. Zulässige Werte sind Zahlen von 1 bis 48.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setKeyFrameInterval()"><linktext>setKeyFrameInterval()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:loopback:get"><apiName>loopback</apiName><shortdesc>
	 Gibt an, ob eine lokale Wiedergabe der Kameraaufnahmen wie bei der Live-Übertragung mit Flash Media Server komprimiert und dekomprimiert (true) oder nicht komprimiert (false) wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob eine lokale Wiedergabe der Kameraaufnahmen wie bei der Live-Übertragung mit Flash Media Server komprimiert und dekomprimiert (<codeph>true</codeph>) oder nicht komprimiert (<codeph>false</codeph>) wird. Der Standardwert ist <codeph>false</codeph>. 
	 
	 <p>
	 Obwohl ein komprimierter Stream für Testzwecke nützlich ist, beispielsweise bei der Vorschau der Einstellungen für die Videoqualität, entsteht dadurch ein erheblicher Verarbeitungsaufwand. Die lokale Ansicht wird komprimiert und für die Übertragung bearbeitet wie in einer Live-Verbindung und dann für die lokale Anzeige dekomprimiert.
	 </p>
	 
	 <p>Um diesen Wert einzustellen, verwenden Sie <codeph>Camera.setLoopback()</codeph>. Wenn diese Eigenschaft auf „true“ gesetzt ist, können Sie den Komprimierungsgrad über <codeph>Camera.setQuality()</codeph> festlegen.</p>
	  
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setLoopback()"><linktext>setLoopback()</linktext></link><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionLevel:get"><apiName>motionLevel</apiName><shortdesc>
	 Die erforderliche Bewegungsstärke zum Auslösen des activity-Ereignisses.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionLevel, motionLevel
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die erforderliche Bewegungsstärke zum Auslösen des <codeph>activity</codeph>-Ereignisses. Die zulässigen Werte liegen zwischen 0 und 100. Der Standardwert ist 50.
	 <p>Videos können unabhängig vom Wert der Eigenschaft <codeph>motionLevel</codeph> wiedergegeben werden. Weitere Informationen hierzu finden Sie unter <codeph>setMotionLevel()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionTimeout:get"><apiName>motionTimeout</apiName><shortdesc>
	 Die Zeit in Millisekunden zwischen dem Zeitpunkt, zu dem die Kamera keine Bewegung mehr erfasst, und dem Zeitpunkt, zu dem das activity-Ereignis aufgerufen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionTimeout, motionTimeout
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die Zeit in Millisekunden zwischen dem Zeitpunkt, zu dem die Kamera keine Bewegung mehr erfasst, und dem Zeitpunkt, zu dem das <codeph>activity</codeph>-Ereignis aufgerufen wird. Der Standardwert ist 2000 (2 Sekunden). 
	 <p>Legen Sie diesen Wert über die <codeph>setMotionLevel()</codeph>-Methode fest. </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:muted:get"><apiName>muted</apiName><shortdesc>
	 Ein boolescher Wert, der angibt, ob der Benutzer im Flash Player-Dialogfeld „Zugriffsschutz“ den Zugriff auf die Kamera verweigert (true) oder gewährt (false) hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.muted, muted
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Ein boolescher Wert, der angibt, ob der Benutzer im Flash Player-Dialogfeld „Zugriffsschutz“ den Zugriff auf die Kamera verweigert (<codeph>true</codeph>) oder gewährt (<codeph>false</codeph>) hat. Wenn sich dieser Wert ändert, wird das <codeph>status</codeph>-Ereignis ausgelöst.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:name:get"><apiName>name</apiName><shortdesc>
	 Der Name der aktuellen Kamera, der von der Kamerahardware zurückgegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Der Name der aktuellen Kamera, der von der Kamerahardware zurückgegeben wird.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:names:get"><apiName>names</apiName><shortdesc>
	 Ein Array mit Strings, in dem die Namen aller verfügbaren Kameras enthalten sind. Das Dialogfeld „Zugriffsschutz“ von Flash Player wird nicht angezeigt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.names, names
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Array mit Strings, in dem die Namen aller verfügbaren Kameras enthalten sind. Das Dialogfeld „Zugriffsschutz“ von Flash Player wird nicht angezeigt. Dieses Array verhält sich ebenso wie alle anderen ActionScript-Arrays, gibt also implizit die auf null basierende Indexposition jeder Kamera und die Anzahl der Kameras im System zurück (mithilfe von <codeph>names.length</codeph>). Weitere Informationen finden Sie im Array-Klasseneintrag <codeph>names</codeph>.
	 
	 <p>Zum Aufrufen der <codeph>names</codeph>-Eigenschaft ist eine genaue Überprüfung der Hardware erforderlich; daher kann das Erstellen des Arrays einige Sekunden dauern. In den meisten Fällen können Sie die Standardkamera verwenden.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/name"><linktext>name</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:quality:get"><apiName>quality</apiName><shortdesc>
	 Die erforderliche Bildqualität, die sich aus dem Grad der Komprimierung jedes Videobilds ergibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.quality, quality
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die erforderliche Bildqualität, die sich aus dem Grad der Komprimierung jedes Videobilds ergibt. Die zulässigen Werte liegen zwischen 1 (niedrigste Qualität, maximale Komprimierung) und 100 (höchste Qualität, keine Komprimierung). Der Standardwert ist 0, d. h., die Bildqualität kann gegebenenfalls geändert werden, damit die Bandbreite nicht überschritten wird.
	 
	 <p>Legen Sie diese Eigenschaft über die <codeph>setQuality()</codeph>-Methode fest.</p>
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:width:get"><apiName>width</apiName><shortdesc>
	 Die aktuelle Aufnahmebildbreite in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.width, width
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Die aktuelle Aufnahmebildbreite in Pixel. Über die <codeph>setMode()</codeph>-Methode können Sie den gewünschten Wert für diese Eigenschaft festlegen.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
 Die SoundTransform-Klasse enthält Eigenschaften für die Lautstärke und Schwenkung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die SoundTransform-Klasse enthält Eigenschaften für die Lautstärke und Schwenkung. 
 
 </apiDesc><example conref="examples\SoundTransformExample.as"> Mit dem folgenden Beispiel wird eine MP3-Datei geladen und abgespielt. Bewegen Sie die Maus, während die MP3-Datei wiedergegeben wird; die Lautstärke und Schwenkung werden mit der Bewegung der Maus über die Bühne geändert. Legen Sie zur Ausführung dieses Beispiels eine Datei mit dem Namen „MySound.mp3“ in dem Verzeichnis ab, in dem sich die SWF-Datei befindet.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundTransformExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundTransformExample() {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.load(request);
            channel = soundFactory.play();
            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function setPan(pan:Number):void {
            trace("setPan: " + pan.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.pan = pan;
            channel.soundTransform = transform;
        }

        private function setVolume(volume:Number):void {
            trace("setVolume: " + volume.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.volume = volume;
            channel.soundTransform = transform;
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            var halfStage:uint = Math.floor(stage.stageWidth / 2);
            var xPos:uint = event.stageX;
            var yPos:uint = event.stageY;
            var value:Number;
            var pan:Number;

            if (xPos > halfStage) {
                value = xPos / halfStage;
                pan = value - 1;
            } else if (xPos &lt; halfStage) {
                value = (xPos - halfStage) / halfStage;
                pan = value;
            } else {
                pan = 0;
            }

            var volume:Number = 1 - (yPos / stage.stageHeight);

            setVolume(volume);
            setPan(pan);
            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#SimpleButton/soundTransform"><linktext>flash.display.SimpleButton.soundTransform</linktext></link><link href="flash.display.xml#Sprite/soundTransform"><linktext>flash.display.Sprite.soundTransform</linktext></link><link href="flash.media.xml#Microphone/soundTransform"><linktext>flash.media.Microphone.soundTransform</linktext></link><link href="flash.media.xml#SoundChannel/soundTransform"><linktext>flash.media.SoundChannel.soundTransform</linktext></link><link href="flash.media.xml#SoundMixer/soundTransform"><linktext>flash.media.SoundMixer.soundTransform</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link></related-links><apiConstructor id="flash.media:SoundTransform:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
	 Erstellt ein SoundTransform-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vol</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Die Lautstärke im Bereich von 0 (stumm) bis 1 (volle Lautstärke).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>panning</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Richtungseinstellung des Sounds von links nach rechts in einem Bereich zwischen -1 (vollständig links) und 1 (vollständig rechts). Beim Wert 0 erfolgt keine Richtungseinstellung (Mitte). 
	 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein SoundTransform-Objekt. 
	 
	 </apiDesc><example conref="examples\SoundTransform_constructorExample.as"> Im folgenden Beispiel wird Sound nur über den rechten Kanal wiedergegeben und die Lautstärke ist auf 50 Prozent eingestellt.
 
 <p>Der Sound wird im Konstruktor und einem zweiten Soundkanal (<codeph>channel</codeph>) zugewiesen. Außerdem wird ein SoundTransform-Objekt (<codeph>transform</codeph>) erstellt. Dessen erstes Argument legt die Lautstärke auf 50 Prozent fest (der Bereich liegt zwischen 0,0 und 1,0). Das zweite Argument legt die Richtungseinstellung fest. In diesem Beispiel ist die Richtung auf 1,0 eingestellt, was bedeutet, dass der Sound nur aus dem rechten Lautsprecher kommt. Damit diese Einstellungen wirksam werden, wird das SoundTransform-Objekt <codeph>transform</codeph> der Eigenschaft <codeph>soundTransform</codeph> des Soundkanals zugewiesen.</p> 
<p> <b>Hinweis:</b> Für dieses Beispiel wurde nur eine sehr eingeschränkte Fehlerverarbeitung geschrieben.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.events.IOErrorEvent;

    public class SoundTransform_constructorExample extends Sprite
    {
        public function SoundTransform_constructorExample() {
            var mySound:Sound = new Sound();
            var url:URLRequest = new URLRequest("mySound.mp3");
            var channel:SoundChannel;
            var transform:SoundTransform = new SoundTransform(0.5, 1.0);

            mySound.load(url);    
            channel = mySound.play();
            channel.soundTransform = transform;

            mySound.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundTransform:leftToLeft:set"><apiName>leftToLeft</apiName><shortdesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des linken Eingangssignals über den linken Lautsprecher wiedergegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des linken Eingangssignals über den linken Lautsprecher wiedergegeben wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:leftToRight:set"><apiName>leftToRight</apiName><shortdesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des linken Eingangssignals über den rechten Lautsprecher wiedergegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des linken Eingangssignals über den rechten Lautsprecher wiedergegeben wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:pan:set"><apiName>pan</apiName><shortdesc>
	 Die Richtungseinstellung des Sounds von links nach rechts in einem Bereich zwischen -1 (vollständig links) und 1 (vollständig rechts).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Richtungseinstellung des Sounds von links nach rechts in einem Bereich zwischen -1 (vollständig links) und 1 (vollständig rechts). Beim Wert 0 erfolgt keine Richtungseinstellung (ausgeglichene Mitte zwischen rechts und links).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToLeft:set"><apiName>rightToLeft</apiName><shortdesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des rechten Eingangssignals über den linken Lautsprecher wiedergegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des rechten Eingangssignals über den linken Lautsprecher wiedergegeben wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToRight:set"><apiName>rightToRight</apiName><shortdesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des rechten Eingangssignals über den rechten Lautsprecher wiedergegeben wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Ein Wert zwischen 0 (nicht) und 1 (vollständig), der angibt, welcher Anteil des rechten Eingangssignals über den rechten Lautsprecher wiedergegeben wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:volume:set"><apiName>volume</apiName><shortdesc>
	 Die Lautstärke im Bereich von 0 (stumm) bis 1 (volle Lautstärke).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Lautstärke im Bereich von 0 (stumm) bis 1 (volle Lautstärke).
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Sound"><apiName>Sound</apiName><shortdesc>
  Über die Soundklasse können Sie Sound in einer Anwendung bearbeiten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  Über die Soundklasse können Sie Sound in einer Anwendung bearbeiten. Mit der Soundklasse können Sie Soundobjekte erstellen, externe MP3-Dateien in diese Objekte laden und abspielen, Soundstreams schließen und auf Sounddaten wie z. B. Informationen zur Byteanzahl im Stream und zu ID3-Metadaten zugreifen. Eine umfassendere Steuerung des Sounds kann über die Soundquelle, d. h. das SoundChannel- oder Microphone-Objekt für den Sound, und über die Eigenschaften der SoundTransform-Klasse durchgeführt werden, die die Ausgabe des Sounds über die Lautsprecher des Computers steuern. 
  
  <p>In Flash Player 10 und höher und AIR 1.5 und höher können Sie diese Klasse auch verwenden, um mit Sound zu arbeiten, der dynamisch generiert wird. In diesem Fall verwendet das Soundobjekt die Funktion, die Sie einer <codeph>sampleData</codeph>-Ereignisprozedur zuweisen, um Sounddaten abzurufen. Der Sound wird abgespielt, während er von einem ByteArray-Objekt abgerufen wird, das Sie mit Sounddaten füllen. Sie können <codeph>Sound.extract()</codeph> verwenden, um Sounddaten aus einem Soundobjekt zu extrahieren. Anschließend können Sie die Daten bearbeiten, bevor Sie sie wieder zurück in den Stream zum Abspielen schreiben.</p>
  
  <p>Den in einer SWF-Datei eingebetteten Sound können Sie über die Eigenschaften in der SoundMixer-Klasse steuern.</p>
  
  <p platform="actionscript"><b>Hinweis</b>: Die Sound-API in ActionScript 3.0 unterscheidet sich von der in ActionScript 2.0. In ActionScript 3.0 können Sie Soundobjekte zum Steuern der zugehörigen Eigenschaften nicht in einer Hierarchie anordnen.</p>
  
  <p>Beachten Sie bei Verwendung dieser Klasse das folgende Sicherheitsmodell: </p>
  
  <ul>
  
      <li>Sound kann nicht geladen und wiedergegeben werden, wenn sich die aufrufende Datei in einer Netzwerk-Sandbox befindet und die zu ladende Sounddatei lokal gespeichert ist.</li>
  
      <li>In der Standardeinstellung ist ein Laden und Abspielen von Sound nicht erlaubt, wenn die aufrufende Datei lokal ist und versucht, Sound remote zu laden und abzuspielen. Ein Benutzer muss explizit Zugriffsrechte gewähren, um diese Art des Zugriffs zu erlauben.</li>
  
      <li>Für bestimmte Vorgänge mit Sound liegen Beschränkungen vor. Auf die Daten in einem geladenen Sound kann nur über eine Datei in einer anderen Domäne zugegriffen werden, wenn eine Cross-Domain-Richtliniendatei implementiert ist. Zu den soundbezogenen APIs, die unter diese Beschränkung fallen, zählen die <codeph>Sound.id3</codeph>-Eigenschaft sowie die Methoden <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph> und die <codeph>SoundTransform()</codeph>-Klasse.</li>
  
  </ul>
  
  <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
  
  <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
  
  <ul>
  
  <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
  <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
  
    <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
  
  </ul>
  
  </apiDesc><example conref="examples\SoundExample.as"> Im folgenden Beispiel werden Informationen über Soundereignisse angezeigt, die beim Öffnen und Abspielen einer MP3-Datei auftreten. Legen Sie zur Ausführung dieses Beispiels eine Datei mit dem Namen „MySound.mp3“ in dem Verzeichnis ab, in dem sich die SWF-Datei befindet.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;

    public class SoundExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var song:SoundChannel;

        public function SoundExample() {
            var request:URLRequest = new URLRequest(url);
            var soundFactory:Sound = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);
            song = soundFactory.play();
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.media.xml#Microphone"><linktext>Microphone</linktext></link><link href="flash.media.xml#SoundChannel"><linktext>SoundChannel</linktext></link><link href="flash.media.xml#SoundMixer"><linktext>SoundMixer</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:Sound_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Wird ausgelöst, wenn während eines Ladevorgangs Daten empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn während eines Ladevorgangs Daten empfangen werden.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Wird beim Start eines Ladevorgangs ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Start eines Ladevorgangs ausgelöst.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den der Ladevorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den der Ladevorgang fehlschlägt. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.ID3_id3"><apiName>id3</apiName><shortdesc>
 Wird durch ein Soundobjekt ausgelöst, wenn ID3-Daten für MP3-Sound verfügbar sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ID3</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird durch ein Soundobjekt ausgelöst, wenn ID3-Daten für MP3-Sound verfügbar sind. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Wird nach dem erfolgreichen Laden von Daten ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird nach dem erfolgreichen Laden von Daten ausgelöst. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.SAMPLE_DATA_sampleData"><apiName>sampleData</apiName><shortdesc>
  Wird ausgelöst, wenn der Player neue Audiodaten anfordert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SAMPLE_DATA</apiEventType><adobeApiEventClassifier>flash.events.SampleDataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  Wird ausgelöst, wenn der Player neue Audiodaten anfordert. 
 
 </apiDesc><example conref="examples\Sound_SampleDataExample.as"> Das folgende Beispiel spielt eine einfache Sinuswelle ab.
 
<codeblock>
var mySound:Sound = new Sound();
function sineWaveGenerator(event:SampleDataEvent):void {
    for ( var c:int=0; c&lt;8192; c++ ) {
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
    }
}

mySound.addEventListener(Event.SAMPLE_DATA,sineWaveGenerator);
mySound.play();
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/extract()"><linktext>extract()</linktext></link><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.events.xml#SampleDataEvent"><linktext>flash.events.SampleDataEvent</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.media:Sound:Sound"><apiName>Sound</apiName><shortdesc>
     Erstellt ein neues Soundobjekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc> Die URL, die auf eine externe MP3-Datei verweist.
     
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> Ein optionales SoundLoader-Kontextobjekt, das die Pufferzeit (die Mindestanzahl Millisekunden, die MP3-Daten im Puffer des Soundobjekts gehalten werden) definieren kann und festlegen kann, ob die Anwendung vor dem Laden von Sound nach einer domänenübergreifenden Richtliniendatei suchen soll.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues Soundobjekt. Wenn Sie ein gültiges URLRequest-Objekt für den Soundkonstruktor übergeben, ruft der Konstruktor automatisch die <codeph>load()</codeph>-Funktion für das Soundobjekt auf. Wenn Sie kein gültiges URLRequest-Objekt für den Soundkonstruktor übergeben, müssen Sie die <codeph>load()</codeph>-Funktion für das Soundobjekt selbst aufrufen, da der Stream andernfalls nicht geladen wird.
     
     <p>Sobald <codeph>load()</codeph> für ein Soundobjekt aufgerufen wurde, kann später keine andere Sounddatei mehr in dieses Soundobjekt geladen werden. Erstellen Sie ein neues Soundobjekt, wenn Sie eine andere Sounddatei laden möchten.</p>
     
     In Flash Player 10 und höher und AIR 1.5 und höher können Sie statt <codeph>load()</codeph> die <codeph>sampleData</codeph>-Ereignisprozedur verwenden, um Sound dynamisch in das Soundobjekt zu laden.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Sound:close"><apiName>close</apiName><shortdesc>
     Schließt den Stream. Dadurch werden eventuelle Downloads von Daten beendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der Stream konnte nicht geschlossen werden, oder der Stream war nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Schließt den Stream. Dadurch werden eventuelle Downloads von Daten beendet. Nach dem Aufrufen der <codeph>close()</codeph>-Methode können möglicherweise keine Daten aus dem Stream gelesen werden.
     
     </apiDesc><example conref="examples\Sound_closeExample.as"> Im folgenden Beispiel wird die <codeph>Sound.close()</codeph>-Methode aufgerufen, wenn der Benutzer auf die Stopp-Schaltfläche klickt, und das Streaming von Sound wird gestoppt.
 
 <p>Im Konstruktor wird ein Textfeld für die Start- und Stopp-Schaltfläche erstellt. Wenn der Benutzer auf das Textfeld klickt, wird die Methode <codeph>clickHandler()</codeph> aufgerufen. Sie verwaltet das Starten und Beenden der Sounddatei. Beachten Sie, dass abhängig von der Netzwerkgeschwindigkeit oder vom Zeitpunkt des Klicks auf die Stopp-Schaltfläche möglicherweise ein Großteil der Datei bereits geladen wurde, sodass es einen Moment dauern kann, bis die Wiedergabe beendet wird. Es wird ein <codeph>try...catch</codeph>-Block verwendet, um etwaige IO-Fehler, die beim Schließen des Streams auftreten können, abzufangen. Wenn Sound zum Beispiel aus einem lokalen Verzeichnis geladen und nicht gestreamt wird, wird Fehler 2029 (Dieses URLStream-Objekt verfügt nicht über einen geöffneten Stream) erfasst.</p> 
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;    
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;

    public class Sound_closeExample extends Sprite {
        private var snd:Sound = new Sound();
        private var button:TextField = new TextField();
        private var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
        
        public function Sound_closeExample() {
            button.x = 10;
            button.y = 10;
            button.text = "START";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.LEFT;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {

            if(button.text == "START") {

                snd.load(req);
                snd.play();        

                snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);

                button.text = "STOP";
            }
            else if(button.text == "STOP") {
                    
                try {
                    snd.close();
                    button.text = "Wait for loaded stream to finish.";
                }
                catch (error:IOError) {
                    button.text = "Couldn't close stream " + error.message;    
                }
            }
        }
        
        private function errorHandler(event:IOErrorEvent):void {
                button.text = "Couldn't load the file " + event.text;
        }
    }
}


</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:extract"><apiName>extract</apiName><shortdesc>
      Extrahiert unformatierte Sounddaten aus einem Soundobjekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die Anzahl der Samples, die im Soundobjekt verfügbar sind.
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Ein ByteArray-Objekt, in das die extrahierten Soundsamples platziert werden.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Anzahl der zu extrahierenden Soundsample. Ein Sample enthält sowohl den linken als auch den rechten Kanal, d. h. zwei 32-Bit-Gleitkommawerte.
          
     </apiDesc></apiParam><apiParam><apiItemName>startPosition</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>-1</apiData><apiDesc>Das Sample, bei dem die Extrahierung beginnt. Wenn Sie keinen Wert angeben, beginnt der erste Aufruf für <codeph>Sound.extract()</codeph> am Anfang des Sounds und anschließende Aufrufe ohne Wert für <codeph>startPosition</codeph> erfolgen sequenziell durch die Datei.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
      Extrahiert unformatierte Sounddaten aus einem Soundobjekt.
     
      <p>Diese Methode ist für Situationen gedacht, in denen Sie mit dynamisch generiertem Sound arbeiten und eine Funktion zum <codeph>sampleData</codeph>-Ereignis für ein anderes Soundobjekt zuweisen. Sie können diese Methode also verwenden, um Sounddaten aus einem Soundobjekt zu extrahieren. Anschließend können Sie die Daten in das Bytearray schreiben, das ein anderes Soundobjekt zum Streamen von dynamischem Audio verwendet.</p>
     
      <p>Die Audiodaten werden im Zielbytearray beginnend mit der aktuellen Position des Bytearrays abgelegt. Die Audiodaten werden immer als 44100 Hz Stereo wiedergegeben. Der Sampletyp ist ein 32-Bit-Gleitkommawert, der über <codeph>ByteArray.readFloat()</codeph> in eine Zahl umgewandelt werden kann. </p>
     
     </apiDesc><example conref="examples\Sound_extractExample.as"> Im folgenden Beispiel wird eine mp3-Datei geladen und die <codeph>extract()</codeph>-Methode der Soundklasse verwendet, um auf die Audiodaten zuzugreifen.
 <p>Die mp3-Daten werden in das <codeph>sourceSnd</codeph>-Soundobjekt geladen. Wenn die Anwendung die mp3-Daten lädt, ruft sie die <codeph>loaded()</codeph>-Funktion (die Ereignisprozedur für das <codeph>complete</codeph>-Ereignis des <codeph>sourceSnd</codeph>-Objekts) auf. Ein zweites Soundobjekt (<codeph>outputSound</codeph>) wird verwendet, um das modifizierte Audio abzuspielen. Das <codeph>outputSound</codeph>-Objekt hat einen <codeph>sampleData</codeph>-Ereignis-Listener. Das Objekt löst also periodische <codeph>sampleData</codeph>-Ereignisse aus, sobald Sie die <codeph>play()</codeph>-Methode des Objekts aufrufen. Die <codeph>upOctave()</codeph>-Methode gibt ein Bytearray mit auf den Quellaudiodaten basierenden modifizierten Audiodaten zurück. Sie gibt Audio zurück, das eine Oktave höher ist, indem sie jedes zweite Audiosample in den Quelldaten überspringt. Die Ereignisprozedur für das <codeph>sampleData</codeph>-Ereignis schreibt das zurückgegebene Bytearray in die <codeph>data</codeph>-Eigenschaft des <codeph>outputSound</codeph>-Objekts. Das <codeph>data</codeph>-Bytearray wird an die ausgegebenen Audiodaten für das <codeph>outputSound</codeph>-Objekt angehängt.</p>
 <p>Fügen Sie zum Testen dieses Beispiels eine text.mp3-Datei in das gleiche Verzeichnis ein, in dem sich die SWF-Datei befindet.</p>
<codeblock>

var sourceSnd:Sound = new Sound();
var outputSnd:Sound = new Sound();
var urlReq:URLRequest = new URLRequest("test.mp3");

sourceSnd.load(urlReq);
sourceSnd.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void
{
    outputSnd.addEventListener(SampleDataEvent.SAMPLE_DATA, processSound);
    outputSnd.play();
}

function processSound(event:SampleDataEvent):void
{
    var bytes:ByteArray = new ByteArray();
    sourceSnd.extract(bytes, 4096);
    event.data.writeBytes(upOctave(bytes));
}

function upOctave(bytes:ByteArray):ByteArray
{
    var returnBytes:ByteArray = new ByteArray();
    bytes.position = 0;
    while(bytes.bytesAvailable > 0)
    {
        returnBytes.writeFloat(bytes.readFloat());
        returnBytes.writeFloat(bytes.readFloat());
        if (bytes.bytesAvailable > 0)
        {
            bytes.position += 8;
        }
    }
    return returnBytes;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Sound/event:sampleData"><linktext>sampleData</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Sound:load"><apiName>load</apiName><shortdesc>
     Initiiert den Ladevorgang einer externen MP3-Datei von der angegebenen URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der Ladevorgang ist aufgrund eines Netzwerkfehlers fehlgeschlagen.
	 
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Über lokale nicht vertrauenswürdige Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können dies umgehen, indem Sie diese Datei als <ph platform="actionscript">lokal mit Netzwerkzugang oder als </ph>vertrauenswürdig klassifizieren.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Die <codeph>digest</codeph>-Eigenschaft des <codeph>stream</codeph>-Objekts ist nicht <codeph>null</codeph>. Sie sollten die <codeph>digest</codeph>-Eigenschaft eines URLRequest-Objekts nur setzen, wenn Sie beim Laden einer SWZ-Datei (einer Adobe-Plattformkomponente) die <codeph>URLLoader.load()</codeph>-Methode aufrufen.
     
      </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> Eine URL, die auf eine externe MP3-Datei verweist.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> Ein optionales SoundLoader-Kontextobjekt, das die Pufferzeit (die Mindestanzahl Millisekunden, die MP3-Daten im Puffer des Soundobjekts gehalten werden) definieren und festlegen kann, ob die Anwendung vor dem Laden von Sound nach einer domänenübergreifenden Richtliniendatei suchen soll.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Initiiert den Ladevorgang einer externen MP3-Datei von der angegebenen URL. Wenn Sie ein gültiges URLRequest-Objekt für den Soundkonstruktor übergeben, wird <codeph>Sound.load()</codeph> automatisch aufgerufen. Sie müssen <codeph>Sound.load()</codeph> nur aufrufen, wenn Sie kein gültiges URLRequest-Objekt oder den Wert <codeph>null</codeph> für den Soundkonstruktor übergeben.
     
     <p>Sobald <codeph>load()</codeph> für ein Soundobjekt aufgerufen wurde, kann später keine andere Sounddatei mehr in dieses Soundobjekt geladen werden. Erstellen Sie ein neues Soundobjekt, wenn Sie eine andere Sounddatei laden möchten.</p>
     
	 <p platform="actionscript">Beachten Sie bei Verwendung dieser Methode das folgende Sicherheitsmodell von:</p>
     
     <ul platform="actionscript">
     
     <li>Der Aufruf von <codeph>Sound.load()</codeph> ist nicht zulässig, wenn sich die aufrufende Datei in der lokalen Sandbox des Dateisystems und sich der Sound in einer Netzwerk-Sandbox befindet.</li>
     
     <li>Zum Aufrufen der lokal vertrauenswürdigen Sandbox oder der lokalen Sandbox mit Netzwerkzugang sind Zugriffsrechte von einer Website über eine URL-Richtliniendatei erforderlich.</li>
     
      <li>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>. </li>
     
     <li>Sie können eine SWF-Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der <codeph>object</codeph>- und <codeph>embed</codeph>-Tags festlegen.</li>
     
     </ul>
     
     <p platform="actionscript"> Wenn Sie in Flash Player 10 oder höher einen Multipart-Content-Type verwenden (z. B. „multipart/form-data“), der einen Upload enthält (gekennzeichnet durch einen „filename“-Parameter in einem „content-disposition“-Header innerhalb des POST-Body), so unterliegt die POST-Methode den Sicherheitsregeln für Uploads:</p>
	 <ul platform="actionscript">
	 <li>Der POST-Vorgang muss als Reaktion auf eine durch den Benutzer initiierte Aktion, z. B. Mausklick oder Tastendruck, erfolgen.</li>
	 <li>Ist die POST-Methode domänenübergreifend (das POST-Ziel befindet sich auf einem anderen Server als die SWF-Datei, die die POST-Anforderung sendet), so muss der Zielserver eine URL-Richtliniendatei bereitstellen, die den domänenübergreifenden Zugriff erlaubt.</li>
	 </ul>
     <p platform="actionscript">Für alle mehrteiligen Content-Typen muss ebenfalls die Syntax nach Standard RFC2046 gültig sein. Scheint die Syntax ungültig zu sein, so unterliegt die POST-Methode den Sicherheitsregeln für Uploads.</p>
     <p platform="actionscript">In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) jedoch nicht diesen Sicherheitseinschränkungen.</p>
     
     <p platform="actionscript">Weitere sicherheitsrelevante Informationen finden Sie in den folgenden Abschnitten:</p>
     
     <ul platform="actionscript">
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li>Der Abschnitt „Understanding AIR Security“ des Kapitels „Getting started with Adobe AIR“ im Handbuch <i>Developing AIR Applications</i>.</li>
       <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
     
     </apiDesc><example conref="examples\Sound_loadExample.as"> Im folgenden Beispiel wird der Ladeprozess einer Sounddatei dargestellt.
 
 <p>Im Konstruktor wird ein <codeph>URLRequest</codeph>-Objekt erstellt, um den Speicherort der Sounddatei, eines Podcasts von Adobe, zu bestimmen. Die Datei wird in einen <codeph>try...catch</codeph>-Block geladen, um Fehler abzufangen, die möglicherweise beim Laden der Datei auftreten. Wenn ein IO-Fehler auftritt, wird die <codeph>errorHandler()</codeph>-Methode ebenfalls aufgerufen, und die Fehlermeldung wird in das Textfeld geschrieben, das für den Fortschrittsbericht vorgesehen ist. Während des Ladevorgangs wird ein <codeph>ProgressEvent.PROGRESS</codeph>-Ereignis ausgelöst und die <codeph>progressHandler()</codeph>-Methode wird aufgerufen. Hier wird das <codeph>ProgressEvent.PROGRESS</codeph>-Ereignis als Timer für die Berechnung des Ladevorgangs verwendet.</p> 
  
 <p>Die <codeph>progressHandler()</codeph>-Methode teilt den <codeph>bytesLoaded</codeph>-Wert, der mit dem <codeph>ProgressEvent</codeph>-Objekt übergeben wird, durch den <codeph>bytesTotal</codeph>-Wert, um den Prozentwert der bereits geladenen Sounddaten zu ermitteln. Danach werden diese Werte im Textfeld angezeigt. (Beachten Sie, dass für den Fall, dass die Datei klein ist, im Cache gespeichert ist oder sich im lokalen Verzeichnis befindet, der Fortschritt möglicherweise nicht bemerkbar ist.)</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.ProgressEvent;
    import flash.events.IOErrorEvent;
    
    public class Sound_loadExample extends Sprite {
        private var snd:Sound = new Sound();
        private var statusTextField:TextField  = new TextField();

        public function Sound_loadExample(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
            snd.load(req);
            
            snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(ProgressEvent.PROGRESS, progressHandler);
                     
            this.addChild(statusTextField);
        }
    
        private function progressHandler(event:ProgressEvent):void {
            var loadTime:Number = event.bytesLoaded / event.bytesTotal;
            var LoadPercent:uint = Math.round(100 * loadTime);
              
            statusTextField.text = "Sound file's size in bytes: " + event.bytesTotal + "\n" 
                                 + "Bytes being loaded: " + event.bytesLoaded + "\n" 
                                 + "Percentage of sound file that is loaded " + LoadPercent + "%.\n";
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:play"><apiName>play</apiName><shortdesc>
     Erstellt ein neues SoundChannel-Objekt zur Wiedergabe von Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein SoundChannel-Objekt, über das der Sound gesteuert werden kann. Wenn Sie über keine Soundkarte verfügen oder keine Soundkanäle mehr vorhanden sind, gibt diese Methode <codeph>null</codeph> zurück. Die maximale Anzahl der gleichzeitig verfügbaren Soundkanäle ist 32.
     
     </apiDesc><apiOperationClassifier>flash.media:SoundChannel</apiOperationClassifier></apiReturn><apiParam><apiItemName>startTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Die ursprüngliche Position in Millisekunden, ab der die Wiedergabe gestartet werden soll.
     </apiDesc></apiParam><apiParam><apiItemName>loops</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Definiert, wie oft Sound als Schleife vom Wert <codeph>startTime</codeph> aus wiedergegeben wird, bevor die Wiedergabe im Soundkanal beendet wird. 
     </apiDesc></apiParam><apiParam><apiItemName>sndTransform</apiItemName><apiOperationClassifier>flash.media:SoundTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>Das ursprüngliche SoundTransform-Objekt, das dem Soundkanal zugewiesen wurde.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Erstellt ein neues SoundChannel-Objekt zur Wiedergabe von Sound. Diese Methode gibt ein SoundChannel-Objekt zurück, auf das Sie zum Beenden von Sound und zum Überwachen der Lautstärke zugreifen können. (Greifen Sie zum Steuern von Lautstärke, Schwenkung und Balance auf das SoundTransform-Objekt zu, das dem Soundkanal zugewiesen ist.)
     
     </apiDesc><example conref="examples\Sound_playExample1.as"> Im folgenden Beispiel kann der Benutzer nach dem Laden der Datei in einem grafischen Balken die Position (Startzeit) auswählen, ab der die Sounddatei abgespielt wird.
 
 <p>Der Konstruktor ruft die <codeph>Sound.load()</codeph>-Methode auf, mit dem Laden der Sounddaten zu beginnen. Als Nächstes wird die <codeph>Sound.play()</codeph>-Methode aufgerufen, die mit dem Abspielen von Sound beginnt, sobald genügend Daten geladen wurden. Die <codeph>Sound.play()</codeph>-Methode gibt ein SoundChannel-Objekt zurück, das zur Steuerung der Soundwiedergabe verwendet werden kann. Im Textfeld werden die Anweisungen angezeigt. Um sicherzustellen, dass der Inhalt bis zu dem Punkt, ab dem der Benutzer den Sound abspielen möchte, bereits geladen wurde, wird das Sprite-Objekt <codeph>bar</codeph> erstellt und angezeigt, nachdem die Datei geladen wurde. Wenn die Datei erfolgreich geladen wurde, wird ein <codeph>Event.COMPLETE</codeph>-Ereignis ausgelöst, welches die Methode <codeph>completeHandler()</codeph> auslöst. Die <codeph>completeHandler()</codeph>-Methode erstellt dann den Balken und fügt ihn der Anzeigeliste hinzu. (Anstelle eines Shape-Objekts wird ein Sprite-Objekt verwendet, um Interaktivität zu unterstützen.) Wenn der Benutzer auf den Balken klickt, wird die <codeph>clickHandler()</codeph>-Methode ausgelöst.</p> 
 
 <p>In der <codeph>clickHandler()</codeph>-Methode wird die Position der x-Koordinate des Benutzerklicks, <codeph>event.localX</codeph>, verwendet, um festzustellen, an welcher Stelle der Benutzer mit dem Abspielen der Datei beginnen möchte. Da der Balken 100 Pixel groß ist und bei der x-Koordinate 100 Pixel beginnt, ist es einfach, den Prozentwert der Position festzustellen. Da die Datei geladen wurde, hat der Wert der <codeph>length</codeph>-Eigenschaft der Sounddatei die Länge der gesamten Datei in Millisekunden. Anhand der Länge der Sounddatei und der Position in der Linie wird eine Startposition der Sounddatei bestimmt. Nach dem Stoppen des Sounds wird die Sounddatei an der ausgewählten Startposition neu gestartet, die als <codeph>startTime</codeph>-Parameter an die <codeph>play()</codeph>-Methode übergeben wird.</p>
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.MouseEvent;
    import flash.media.Sound;;
    import flash.net.URLRequest;
    import flash.media.SoundChannel;
    import flash.events.ProgressEvent;
    import flash.events.Event;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample1 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var infoTextField:TextField = new TextField();
    
        public function Sound_playExample1() {

            var req:URLRequest = new URLRequest("MySound.mp3");
            
            infoTextField.autoSize = TextFieldAutoSize.LEFT;
            infoTextField.text = "Please wait for the file to be loaded.\n" 
                                + "Then select from the bar to decide where the file should start.";
            
            snd.load(req);               
            channel = snd.play();

            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(Event.COMPLETE, completeHandler);


            this.addChild(infoTextField);
        }

        private function completeHandler(event:Event):void {                
            infoTextField.text = "File is ready.";

            var bar:Sprite = new Sprite();

            bar.graphics.lineStyle(5, 0xFF0000);
            bar.graphics.moveTo(100, 100);
            bar.graphics.lineTo(200, 100);

            bar.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(bar);
        }
    
        private function clickHandler(event:MouseEvent):void {
            
                var position:uint = event.localX;
                var percent:uint = Math.round(position) - 100;   
                var cue:uint = (percent / 100) * snd.length;

                channel.stop();
                channel = snd.play(cue);    
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            infoTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample2.as"> Im folgenden Beispiel wird der Sound ein oder zwei Mal abgespielt, je nachdem, ob der Benutzer auf eine Schaltfläche klickt oder doppelklickt.
 
 <p>Im Konstruktor wird der Sound geladen und es wird ein einfaches rechteckiges Sprite-Objekt, <codeph>button</codeph>, erstellt. (Anstelle eines Shape-Objekts wird ein Sprite-Objekt verwendet, um Interaktivität zu unterstützen.) (Hier wird davon ausgegangen, dass sich die Sounddatei im selben Verzeichnis wie die SWF-Datei befindet). (Für dieses Beispiel wurde keine Fehlerverarbeitung geschrieben.)</p>
 
 <p>Zwei Ereignis-Listener werden eingerichtet, um auf einfache Mausklicks und auf Doppelklicks zu warten. Wenn der Benutzer ein Mal klickt, wird die <codeph>clickHandler()</codeph>-Methode, die den Sound abspielt, aufgerufen. Wenn der Benutzer auf die Schaltfläche doppelklickt, wird die <codeph>doubleClickHandler()</codeph>-Methode, die die Sounddatei zwei Mal abspielt, aufgerufen. Das zweite Argument der <codeph>play()</codeph>-Methode wird auf <codeph>1</codeph> gesetzt, was bedeutet, dass die Wiedergabe nach dem ersten Abspielen bei der Startzeit des Sounds erneut beginnt. Die Startzeit, das erste Argument, wird auf <codeph>0</codeph> gesetzt, was bedeutet, dass die Datei ab dem Anfang abgespielt wird.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.media.Sound;
    import flash.net.URLRequest;

    public class Sound_playExample2 extends Sprite {
        private var button:Sprite = new Sprite(); 
        private var snd:Sound = new Sound();
            
        public function Sound_playExample2() {

            var req:URLRequest = new URLRequest("click.mp3");
            snd.load(req);               
     
            button.graphics.beginFill(0x00FF00);
            button.graphics.drawRect(10, 10, 50, 30);
            button.graphics.endFill();
     
            button.addEventListener(MouseEvent.CLICK, clickHandler);
            button.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClickHandler);
     
            this.addChild(button);
        }

        private function clickHandler(event:MouseEvent):void {
            snd.play();            
        }

        private function doubleClickHandler(event:MouseEvent):void {
            snd.play(0, 2);        
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample3.as"> Im folgenden Beispiel wird der Lade- und Abspielprozess einer Sounddatei dargestellt.
 
 <p>Die Datei wird im Konstruktor in einen <codeph>try...catch</codeph>-Block geladen, um Fehler abzufangen, die möglicherweise beim Laden der Datei auftreten. Dem Soundobjekt wird ein Listener hinzugefügt, der auf ein <codeph>IOErrorEvent</codeph>-Ereignis reagiert, indem die <codeph>errorHandler()</codeph>-Methode aufgerufen wird. Für die Hauptanwendung wird ein weiterer Listener hinzugefügt, der auf ein <codeph>Event.ENTER_FRAME</codeph>-Ereignis reagiert, das als Zeitgeber für die Anzeige des Abspielfortschritts verwendet wird. Schließlich wird ein dritter Listener für den Soundkanal hinzugefügt, der auf ein i<codeph>Event.SOUND_COMPLETE</codeph>-Ereignis reagiert (wenn die Sounddatei vollständig abgespielt wurde), indem er die <codeph>soundCompleteHandler()</codeph>-Methode aufruft. Die <codeph>soundCompleteHandler()</codeph>-Methode entfernt auch den Ereignis-Listener für das <codeph>Event.ENTER_FRAME</codeph>-Ereignis.</p>
 
 <p>Die <codeph>enterFrameHandler()</codeph>-Methode teilt den <codeph>bytesLoaded</codeph>-Wert, der mit dem <codeph>ProgressEvent</codeph>-Objekt übergeben wird, durch den <codeph>bytesTotal</codeph>-Wert, um den Prozentwert der Sounddaten, die geladen wurden, zu bestimmen. Der Prozentwert der Sounddaten, die abgespielt wurden, kann ermittelt werden, indem der Wert der <codeph>position</codeph>-Eigenschaft des Soundkanals durch die Länge der Sounddaten geteilt wird. Wenn die Sounddaten jedoch nicht vollständig geladen wurden, zeigt die <codeph>length</codeph>-Eigenschaft des Soundobjekts nur die Größe der zurzeit geladenen Daten an. Eine Schätzung der endgültigen Größe der Sounddatei wird berechnet, indem der Wert der <codeph>length</codeph>-Eigenschaft des aktuellen Soundobjekts durch den Wert der <codeph>bytesLoaded</codeph>-Eigenschaft geteilt durch den Wert der <codeph>bytesTotal</codeph>-Eigenschaft geteilt wird.</p>
 
 <p>Beachten Sie, dass für den Fall, dass die Datei klein ist, im Cache gespeichert ist oder sich im lokalen Verzeichnis befindet, der Ladefortschritt möglicherweise nicht bemerkbar ist. Die Verzögerung zwischen dem Beginn des Ladevorgangs der Sounddaten und dem Beginn der Wiedergabe der geladenen Daten wird bestimmt durch den Wert der <codeph>SoundLoaderContext.buffertime</codeph>-Eigenschaft, der standardmäßig 1000 Millisekunden beträgt und zurückgesetzt werden kann.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample3 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel;
        private var statusTextField:TextField  = new TextField();

        public function Sound_playExample3(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;

           var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
                snd.load(req);
            
                channel = snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
                    
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                    
            this.addChild(statusTextField);
        }
    
        private function enterFrameHandler(event:Event):void {    
            var loadTime:Number = snd.bytesLoaded / snd.bytesTotal;
            var loadPercent:uint = Math.round(100 * loadTime);
            var estimatedLength:int = Math.ceil(snd.length / (loadTime));
            var playbackPercent:uint = Math.round(100 * (channel.position / estimatedLength));
      
            statusTextField.text = "Sound file's size is " + snd.bytesTotal + " bytes.\n" 
                                   + "Bytes being loaded: " + snd.bytesLoaded + "\n" 
                                   + "Percentage of sound file that is loaded " + loadPercent + "%.\n"
                                   + "Sound playback is " + playbackPercent + "% complete.";     
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }

        private function soundCompleteHandler(event:Event):void {
            statusTextField.text = "The sound has finished playing.";
            removeEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundChannel/stop()"><linktext>SoundChannel.stop()</linktext></link><link href="flash.media.xml#SoundMixer/stopAll()"><linktext>SoundMixer.stopAll()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Sound:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
     Gibt die derzeit verfügbare Anzahl der Byte in diesem Soundobjekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die derzeit verfügbare Anzahl der Byte in diesem Soundobjekt zurück. Diese Eigenschaft ist in der Regel nur für extern geladene Dateien nützlich.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
     Gibt die Gesamtanzahl der Byte in diesem Soundobjekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Gesamtanzahl der Byte in diesem Soundobjekt zurück. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:id3:get"><apiName>id3</apiName><shortdesc>
     Bietet Zugriff auf die Metadaten, die in MP3-Dateien enthalten sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sound, Sound.id3, id3, mp3
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.media:ID3Info</apiValueClassifier></apiValueDef><apiDesc>
     Bietet Zugriff auf die Metadaten, die in MP3-Dateien enthalten sind.
     
     <p>MP3-Sounddateien können ID3-Tags mit Metadaten zur Datei enthalten. Wenn MP3-Sound, der mit der <codeph>Sound.load()</codeph>-Methode geladen wurde, ID3-Tags enthält, können Sie diese Eigenschaften abfragen. Es werden nur ID3-Tags unterstützt, die den UTF-8-Zeichensatz verwenden.</p>
     
	 <p><ph outputclass="actionscript">Flash Player 9 und höher und die AIR-Laufzeitumgebung unterstützen</ph> <ph platform="javascript">Die AIR-Laufzeitumgebung unterstützt</ph> ID3 2.0-Tags, im Speziellen 2.3 und 2.4. In der folgenden Tabelle sind die ID3 2.0-Standardtags und der Inhaltstyp der einzelnen Tags aufgeführt. Mit der <codeph>Sound.id3</codeph>-Eigenschaft kann über das Format <codeph>my_sound.id3.COMM</codeph>, <codeph>my_sound.id3.TIME</codeph> usw. auf diese Tags zugegriffen werden. Die erste Tabelle beschreibt Tags, auf die entweder über den ID3 2.0- oder den ActionScript-Eigenschaftennamen zugegriffen werden kann. Die zweite Tabelle beschreibt ID3-Tags, die unterstützt werden, aber keine vordefinierten Eigenschaften in ActionScript haben. </p>
     
     <adobetable class="innertable">
       
      
      
      
     
     
     
     
     <tgroup cols="2"><tbody><row>
         <entry><b>ID3 2.0-Tag</b></entry>
	    <entry><b>Entsprechende Soundklasseneigenschaft</b></entry>
      </row><row>
        <entry>COMM</entry>
        <entry>Sound.id3.comment</entry>
      </row><row>
        <entry>TALB</entry>
        <entry>Sound.id3.album </entry>
      </row><row>
     
       <entry>TCON</entry>
       <entry>Sound.id3.genre</entry>
      </row><row>
       <entry>TIT2</entry>
       <entry>Sound.id3.songName </entry>
     </row><row>
       <entry>TPE1</entry>
       <entry>Sound.id3.artist</entry>
     </row><row>
       <entry>TRCK</entry>
       <entry>Sound.id3.track </entry>
     </row><row>
       <entry>TYER</entry>
       <entry>Sound.id3.year </entry>
     </row></tbody></tgroup></adobetable>
     
     <p>In der folgenden Tabelle sind ID3-Tags beschrieben, die unterstützt werden, jedoch in der Soundklasse über keine vordefinierten Eigenschaften verfügen. Auf diese Tags kann durch Aufrufen von <codeph>mySound.id3.TFLT</codeph>, <codeph>mySound.id3.TIME</codeph> usw. zugegriffen werden.</p>  
      <adobetable class="innertable">
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      <tgroup cols="2"><tbody><row>
          <entry><b>Eigenschaft</b></entry>
          <entry><b>Beschreibung</b></entry>
        </row><row>
          <entry>TFLT</entry>
          <entry>Dateityp</entry>
        </row><row>
          <entry>TIME</entry>
          <entry>Zeit</entry>
        </row><row>
          <entry>TIT1</entry>
          <entry>Beschreibung der Inhaltsgruppe</entry>
        </row><row>
          <entry>TIT2</entry>
          <entry>Titel/Liedtitel/Inhaltsbeschreibung</entry>
        </row><row>
          <entry>TIT3</entry>
          <entry>Untertitel/Detaillierte Beschreibung</entry>
        </row><row>
          <entry>TKEY</entry>
          <entry>Erster Ton</entry>
        </row><row>
          <entry>TLAN</entry>
          <entry>Sprachen</entry>
        </row><row>
          <entry>TLEN</entry>
          <entry>Länge</entry>
        </row><row>
          <entry>TMED</entry>
          <entry>Medientyp</entry>
        </row><row>
          <entry>TOAL</entry>
          <entry>Originalalbum-/Film-/Präsentationstitel</entry>
        </row><row>
          <entry>TOFN</entry>
          <entry>Originaldateiname</entry>
        </row><row>
          <entry>TOLY</entry>
          <entry>Originalautor/Songwriter</entry>
        </row><row>
          <entry>TOPE</entry>
          <entry>Originalkünstler</entry>
        </row><row>
          <entry>TORY</entry>
          <entry>Jahr der Erstveröffentlichung</entry>
        </row><row>
          <entry>TOWN</entry>
          <entry>Eigentümer/Lizenznehmer</entry>
        </row><row>
          <entry>TPE1</entry>
          <entry>Hauptkünstler/Solokünstler</entry>
        </row><row>
          <entry>TPE2</entry>
          <entry>Band/Orchester/Begleitung</entry>
        </row><row>
          <entry>TPE3</entry>
          <entry>Leitung/Detaillierte Auflistung der Künstler</entry>
        </row><row>
          <entry>TPE4</entry>
          <entry>Interpretation, Remix oder sonstige Bearbeitung durch</entry>
        </row><row>
          <entry>TPOS</entry>
          <entry>Teil eines Satzes</entry>
        </row><row>
          <entry>TPUB</entry>
          <entry>Publisher</entry>
        </row><row>
          <entry>TRCK</entry>
          <entry>Titelnummer/Position in Satz</entry>
        </row><row>
          <entry>TRDA</entry>
          <entry>Aufnahmedaten</entry>
        </row><row>
          <entry>TRSN</entry>
          <entry>Name des Internet-Radiosenders</entry>
        </row><row>
          <entry>TRSO</entry>
          <entry>Eigentümer des Internet-Radiosenders</entry>
        </row><row>
          <entry>TSIZ</entry>
          <entry>Größe</entry>
        </row><row>
          <entry>TSRC</entry>
          <entry>ISRC (International Standard Recording Code)</entry>
        </row><row>
          <entry>TSSE</entry>
          <entry>Software/Hardware und Einstellungen für die Kodierung</entry>
        </row><row>
          <entry>TYER</entry>
          <entry>Jahr</entry>
        </row><row>
          <entry>WXXX</entry>
          <entry>URL-Verknüpfung</entry>
        </row></tbody></tgroup></adobetable>
     
     
     <p>Bedenken Sie bei Verwendung dieser Eigenschaft das Flash Player-Sicherheitsmodell:</p>
     
     <ul>
     
     <li>Die <codeph>id3</codeph>-Eigenschaft eines Soundobjekts ist immer für SWF-Dateien erlaubt, die in der gleichen Sicherheitssandbox wie die Sounddatei sind. Bei Dateien in anderen Sandboxen werden Sicherheitsprüfungen durchgeführt.</li>
     
     <li>Wenn Sie Sound mithilfe der <codeph>load()</codeph>-Methode der Soundklasse laden, können Sie einen <codeph>context</codeph>-Parameter angeben, bei dem es sich um ein SoundLoaderContext-Objekt handelt. Wenn Sie die <codeph>checkPolicyFile</codeph>-Eigenschaft des SoundLoaderContext-Objekts auf <codeph>true</codeph> festlegen, wird in Flash Player auf dem Server, von dem der Sound geladen wird, eine URL-Richtliniendatei gesucht. Wenn eine Richtliniendatei existiert und diese den Zugriff von der Domäne der ladenden SWF-Datei erlaubt, darf die Datei auf die <codeph>id3</codeph>-Eigenschaft des Soundobjekts zugreifen; andernfalls darf sie es nicht.</li>
     
     </ul>
     
     <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
     
     <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
     
     <ul>
     
     <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
       <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     
     </ul>
     
     

     
     </apiDesc><example conref="examples\Sound_id3Example.as"> Im folgenden Beispiel werden die ID3-Informationen aus einer Sounddatei gelesen und in einem Textfeld angezeigt.
 
 <p>Im Konstruktor wird die Sounddatei geladen, ist jedoch nicht auf das Abspielen eingestellt. Hier wird davon ausgegangen, dass sich die Datei im SWF-Verzeichnis befindet. Das System muss über die Berechtigung zum Lesen der ID3-Tags einer geladenen Sounddatei verfügen. Wenn die Datei ID3-Informationen enthält und das Programm berechtigt ist, diese zu lesen, wird ein <codeph>Event.ID3</codeph>-Ereignis ausgelöst und die Eigenschaft <codeph>id3</codeph> der Sounddatei wird gefüllt. Die <codeph>id3</codeph>-Eigenschaft enthält ein <codeph>ID3Info</codeph>-Objekt mit allen ID3-Informationen.</p>
 
 <p>In der <codeph>id3Handler()</codeph>-Methode werden die ID3-Tags der Datei in <codeph>id3</codeph>, einem ID3Info-Klassenobjekt, gespeichert. Es wird ein Textfeld instanziiert, um die Liste der ID3-Tags anzuzeigen. Die for-Schleife durchläuft alle ID3 2.0-Tags und hängt den Namen und den Wert an den Inhalt des Textfelds an. Mithilfe der ID3-Info-Eigenschaften (<codeph>ID3Info</codeph>) werden der Interpret, der Titelname und das Album ebenfalls angehängt. ActionScript 3.0 sowie Flash Player 9 und höher unterstützen ID3 2.0-Tags, speziell 2.3 und 2.4. Wenn Sie Eigenschaften durchlaufen wie in der for-Schleife, werden nur ID3 2.0-Tags angezeigt. Die Daten aus den früheren Versionen werden jedoch ebenfalls in der <codeph>id3</codeph>-Eigenschaft des Titels gespeichert und können mithilfe der Eigenschaften der ID3-Info-Klasse abgerufen werden. Die Tags für ID3 1.0 befinden sich am Ende der Datei, während die ID3 2.0-Tags am Anfang der Datei stehen. (In einigen Fällen weisen Dateien sowohl die Tags der früheren als auch die der älteren Versionen an derselben Stelle auf.) Wenn eine Datei sowohl am Anfang als auch am Ende der Datei Tags beider Versionen, 1.0 und 2.0, aufweist, wird die <codeph>id3Handler()</codeph>-Methode zwei Mal aufgerufen. Zuerst wird die 2.0-Version und dann die 1.0-Version gelesen. Wenn nur ein ID3 1.0-Tag verfügbar ist, kann über die ID3-Eigenschaften wie <codeph>id3.songname</codeph> darauf zugegriffen werden. Für ID3 2.0 ruft die <codeph>id3.TITS</codeph>-Eigenschaft den Namen des Titels mithilfe des neuen Tags (TITS) ab.</p>
 
 <p>Beachten Sie, dass für dieses Beispiel keine Fehlerverarbeitung geschrieben wurde, und wenn der ID3-Inhalt umfangreich ist, geht das Ergebnis möglicherweise über den anzeigbaren Bereich hinaus.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.net.URLRequest;
    import flash.media.ID3Info;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;

    public class Sound_id3Example extends Sprite {
        private var snd:Sound = new Sound();       
        private var myTextField:TextField = new TextField();

        public function Sound_id3Example() {
            snd.addEventListener(Event.ID3, id3Handler);
            snd.load(new URLRequest("mySound.mp3"));
        }
    
        private function id3Handler(event:Event):void {
            var id3:ID3Info = snd.id3;

            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.border = true;

            myTextField.appendText("Received ID3 Info: \n");
              
            for (var propName:String in id3) {
                myTextField.appendText(propName + " = " + id3[propName] + "\n");
            }
 
            myTextField.appendText("\n" + "Artist: " + id3.artist + "\n");
            myTextField.appendText("Song name: " + id3.songName + "\n");
            myTextField.appendText("Album: " + id3.album + "\n\n"); 
 
            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiValue><apiValue id="flash.media:Sound:isBuffering:get"><apiName>isBuffering</apiName><shortdesc>
     Gibt den Zwischenspeicherstatus externer MP3-Dateien zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt den Zwischenspeicherstatus externer MP3-Dateien zurück. Wenn der Wert auf <codeph>true</codeph> gesetzt ist, wird die Wiedergabe unterbrochen, während das Objekt auf weitere Daten wartet.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:length:get"><apiName>length</apiName><shortdesc>
     Die Länge des aktuellen Sounds in Millisekunden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Die Länge des aktuellen Sounds in Millisekunden.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:url:get"><apiName>url</apiName><shortdesc>
     Die URL, von der der Sound geladen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Die URL, von der der Sound geladen wurde. Diese Eigenschaft kann nur auf Soundobjekte angewendet werden, die mit der <codeph>Sound.load()</codeph>-Methode geladen wurden. Bei Soundobjekten, die mit einem Soundelement in der Bibliothek einer SWF-Datei verknüpft sind, ist der Wert der <codeph>url</codeph>-Eigenschaft <codeph>null</codeph>.
     
     <p>Da die endgültige URL noch nicht bekannt ist, hat die <codeph>url</codeph>-Eigenschaft beim ersten Aufrufen von <codeph>Sound.load()</codeph> anfänglich den Wert <codeph>null</codeph>. Sobald ein <codeph>open</codeph>-Ereignis über das Soundobjekt ausgelöst wurde, nimmt die <codeph>url</codeph>-Eigenschaft einen anderen Wert an.</p>
     
     <p>Die <codeph>url</codeph>-Eigenschaft enthält die endgültige, absolute URL, von der Sound geladen wurde. Der Wert von <codeph>url</codeph> entspricht in der Regel dem Wert, der an den <codeph>stream</codeph>-Parameter von <codeph>Sound.load()</codeph> übergeben wurde. Wenn Sie allerdings eine relative URL an <codeph>Sound.load()</codeph> übergeben haben, ist der Wert der <codeph>url</codeph>-Eigenschaft die absolute URL. Wird die ursprüngliche URL-Anforderung zusätzlich über einen HTTP-Server umgeleitet, entspricht der Wert der <codeph>url</codeph>-Eigenschaft der endgültigen URL, über die die Sounddatei tatsächlich heruntergeladen wurde. Diese Protokollierung einer absoluten, endgültigen URL entspricht dem Verhalten von <codeph>LoaderInfo.url</codeph>.</p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
 Über die SoundLoaderContext-Klasse werden Sicherheitsprüfungen bei Dateien durchgeführt, in denen Sounddaten geladen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Über die SoundLoaderContext-Klasse werden Sicherheitsprüfungen bei Dateien durchgeführt, in denen Sounddaten geladen werden. SoundLoaderContext-Objekte werden als Argument für den Konstruktor und die <codeph>load()</codeph>-Methode der Soundklasse übergeben.
 
 <p>Beachten Sie bei Verwendung dieser Klasse das folgende Sicherheitsmodell: </p>
 
 <ul>
 <li>Sounddaten können nicht geladen und wiedergegeben werden, wenn sich die aufrufende Datei in einer Netzwerk-Sandbox befindet und die zu ladende Sounddatei lokal gespeichert ist.</li>
 
 	<li>In der Standardeinstellung ist das Laden und die Wiedergabe von Sounddaten nicht zulässig, wenn über die aufrufende lokale Datei Sound remote geladen und wiedergegeben werden soll. Benutzer müssen für diesen Vorgang eine explizite Berechtigung erteilen.</li>
 
 	<li>Für bestimmte Vorgänge bei Sounddaten liegen Beschränkungen vor. Auf die Daten in einem geladenen Sound kann nicht von einer Datei in einer anderen Domäne zugegriffen werden, es sei denn, Sie implementieren eine URL-Richtliniendatei. Zu den soundbezogenen APIs, die unter diese Beschränkung fallen, zählen die <codeph>Sound.id3</codeph>-Eigenschaft sowie die Methoden <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph> und <codeph>SoundTransform()</codeph>.</li>
 
 </ul>
 
 <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
 
 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
 <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li>Der Abschnitt „Understanding AIR Security“ des Kapitels „Getting started with Adobe AIR“ im Handbuch <i>Developing AIR Applications</i>.</li>
 
   <li>Der Abschnitt <xref href="http://www.adobe.com/devnet/flashplayer/security.html" scope="external">Sicherheit</xref> im Flash Player Developer Center.</li>
 
 </ul>
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.media:SoundLoaderContext:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
     Erstellt ein neues SoundLoaderContext-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bufferTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1000</apiData><apiDesc>Die Anzahl der Sekunden zum Laden von Streamingsound in einen Puffer vor dem Streaming.
     
     </apiDesc></apiParam><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob beim Laden des Objekts nach dem Vorhandensein einer URL-Richtliniendatei gesucht werden soll (<codeph>true</codeph>).
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues SoundLoaderContext-Objekt.  
     
     </apiDesc><example conref="examples\SoundLoaderContextExample.as"> Im folgenden Beispiel wird der Puffer für zu ladenden Sound auf drei Sekunden eingestellt.
 
 <p>Der erste Parameter eines SoundLoaderContext-Objekts (<codeph>context</codeph>) wird verwendet, um den Standardpufferwert von einer Sekunde auf drei Sekunden zu erhöhen. (Der Wert wird in Millisekunden angegeben.) Wenn der zweite Parameter des SoundLoaderContext-Objekts auf <codeph>true</codeph> gesetzt wird, prüft Flash Player beim Laden des Objekts, ob eine Cross-Domain-Richtliniendatei vorhanden ist. Hier wurde der Standardwert <codeph>false</codeph> verwendet, sodass keine Überprüfung der Richtliniendatei stattfindet. Die <codeph>load()</codeph>-Methode des Soundobjekts stellt mithilfe der Kontexteinstellung sicher, dass der Streamingsound drei Sekunden in einen Puffer geladen wird, bevor der Sound gestreamt wird. Das <codeph>URLRequest</codeph>-Objekt bestimmt die Position der Datei, bei der es sich um ein Podcast von Adobe handelt. Falls beim Laden der Sounddatei ein <codeph>IOErrorEvent.IO_ERROR</codeph>-Fehler auftritt, wird die <codeph>errorHandler()</codeph>-Methode aufgerufen.</p> 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.events.IOErrorEvent;
    
    public class SoundLoaderContextExample extends Sprite {

        public function SoundLoaderContextExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            var context:SoundLoaderContext = new SoundLoaderContext(3000, false);

            snd.load(req, context);
            snd.play();      
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }

    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundLoaderContext:bufferTime"><apiName>bufferTime</apiName><shortdesc>
	 Die Anzahl der Millisekunden zum Vorausladen eines Streamingsounds in einen Puffer vor dem Streaming.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1000</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl der Millisekunden zum Vorausladen eines Streamingsounds in einen Puffer vor dem Streaming.
	 
	 <p>Beachten Sie, dass der Wert von <codeph>SoundLoaderContext.bufferTime</codeph> durch Festlegen der globalen <codeph>SoundMixer.bufferTime</codeph>-Eigenschaft nicht überschrieben werden kann. <ph platform="actionscript">Die <codeph>SoundMixer.bufferTime</codeph>-Eigenschaft wirkt sich auf die Zwischenspeicherzeit für eingebetteten Streamingsound in einer SWF-Datei aus und hängt nicht von dynamisch erstellten Soundobjekten (d. h. den ActionScript erstellten Soundobjekten) ab.</ph></p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundLoaderContext:checkPolicyFile"><apiName>checkPolicyFile</apiName><shortdesc>
	 Gibt an, ob die Anwendung vor dem Laden von Sound eine Cross-Domain-Richtliniendatei vom Server des geladenen Sounds herunterladen soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext, NetStream
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob die Anwendung vor dem Laden von Sound eine Cross-Domain-Richtliniendatei vom Server des geladenen Sounds herunterladen soll. Diese Eigenschaft wird über die <codeph>Sound.load()</codeph>-Methode auf Sound angewendet, der von außerhalb der Domäne der aufrufenden Datei geladen wird.
	 
	 <p platform="javascript">Diese Eigenschaft bezieht sich nur auf SWF-Inhalt, der außerhalb der Sandbox der AIR-Anwendung ausgeführt wird. </p>
	 
	 <p platform="actionscript">Setzen Sie diese Eigenschaft auf <codeph>true</codeph>, wenn Sie Sound von außerhalb der Domäne der aufrufenden Datei laden und Code in der aufrufenden Datei Zugriff auf niedriger Ebene·auf die Sounddaten benötigt. Zu den Beispielen für Sounddaten-Zugriff auf niedriger Ebene gehört der Verweis auf die <codeph>Sound.id3</codeph>-Eigenschaft zum Abrufen eines ID3Info-Objekts oder der Aufruf der <codeph>SoundMixer.computeSpectrum()</codeph>-Methode zum Abrufen von Soundbeispielen des geladenen Sounds. Wenn Sie während des Ladevorgangs auf Sounddaten zugreifen, ohne die <codeph>checkPolicyFile</codeph>-Eigenschaft auf <codeph>true</codeph> zu setzen, wird möglicherweise eine SecurityError-Ausnahme ausgelöst, da die erforderliche Richtliniendatei nicht heruntergeladen wurde.</p>
	 
	 <p platform="actionscript">Wenn kein Zugriff auf niedriger Ebene auf die zu ladenden Sounddaten erforderlich ist, setzen Sie <codeph>checkPolicyFile</codeph> nicht auf <codeph>true</codeph>. Die Suche nach einer Richtliniendatei beansprucht Netzwerkbandbreite und verzögert möglicherweise den Start des Downloads. Sie sollte daher nur durchgeführt werden, wenn dies unbedingt erforderlich ist.</p>
	 
	 <p platform="actionscript">Wenn Sie <codeph>Sound.load()</codeph> aufrufen und <codeph>SoundLoaderContext.checkPolicyFile</codeph> auf <codeph>true</codeph> gesetzt ist, muss Flash Player oder AIR entweder erfolgreich eine relevante URL-Richtliniendatei herunterladen oder feststellen, dass keine derartige Richtliniendatei existiert, bevor der angegebene Sound heruntergeladen wird. In <ph platform="actionscript">Flash Player oder </ph>AIR werden die folgenden Aktionen in der angegebenen Reihenfolge ausgeführt, um zu überprüfen, ob eine Richtliniendatei vorhanden ist.</p>
	 
	 <ul platform="actionscript">
	 
	 <li>Flash Player oder AIR überprüft Richtliniendateien, die bereits heruntergeladen wurden.</li>
	 
	 <li>Flash Player oder AIR versucht, ausstehende Richtliniendateien herunterzuladen, die in Aufrufen von <codeph>Security.loadPolicyFile()</codeph> angegeben wurden.</li>
	 
	 <li>Flash Player oder AIR versucht, eine Richtliniendatei vom Standardspeicherort herunterzuladen, der der URL des Sounds entspricht, d. h. <codeph>/crossdomain.xml</codeph> auf dem gleichen Server wie <codeph>URLRequest.url</codeph>. (Die URL des Sounds ist in der <codeph>url</codeph>-Eigenschaft des URLRequest-Objekts angegeben, das an <codeph>Sound.load()</codeph> oder die Sound()-Konstruktorfunktion übergeben wird.)</li>
	 </ul>
	 
	 <p platform="actionscript">In allen Fällen muss eine entsprechende Richtliniendatei auf dem Server des Sounds vorhanden sein, über die anhand des Speicherorts der Richtliniendatei auf die Sounddatei unter <codeph>URLRequest.url</codeph> zugegriffen werden kann und über die die Domäne der aufrufenden SWF-Datei über mindestens ein <codeph>&lt;allow-access-from></codeph>-Tag auf den Sound zugreifen kann.
	 </p>
	 
	 <p platform="actionscript">Wenn Sie <codeph>checkPolicyFile</codeph> auf <codeph>true</codeph> setzen, wird der Sound in Flash Player oder AIR erst geladen, nachdem die Richtliniendatei überprüft wurde. Führen Sie Methoden auf niedriger Ebene für die Sounddaten (z. B. Aufrufe von <codeph>Sound.id3</codeph> oder <codeph>SoundMixer.computeSpectrum()</codeph>) erst durch, nachdem die Ereignisse <codeph>progress</codeph> und <codeph>complete</codeph> über das Soundobjekt ausgelöst wurden.
	 </p>
	 
	 <p platform="actionscript">Wenn Sie <codeph>checkPolicyFile</codeph> auf <codeph>true</codeph> setzen und keine passende Richtliniendatei gefunden wird, wird erst dann ein Fehler zurückgegeben, wenn Sie eine Methode ausführen, die eine Richtliniendatei benötigt. In diesem Fall meldet Flash Player oder AIR einen <codeph>SecurityError</codeph>-Ausnahmefehler. Nach dem Empfang eines <codeph>complete</codeph>-Ereignisses können Sie testen, ob eine entsprechende Richtliniendatei gefunden wurde. Rufen Sie dazu den Wert von <codeph>Sound.id3</codeph> in einem <codeph>try</codeph>-Block ab, und überprüfen Sie, ob <codeph>SecurityError</codeph> ausgegeben wird.</p>
	 
	 
	 <p platform="actionscript">Bei Verwendung von <codeph>checkPolicyFile</codeph> beim Herunterladen eines Sounds von einer URL, bei der serverseitige HTTP-Weiterleitungen verwendet werden, ist Folgendes zu beachten: Flash Player oder AIR versucht, Richtliniendateien abzurufen, die mit der <codeph>url</codeph>-Eigenschaft des an <codeph>Sound.load()</codeph> übergebenen URLRequest-Objekts übereinstimmen. Wenn die endgültige Sounddatei aufgrund von HTTP-Weiterleitungen von einer anderen URL stammt, gelten die ursprünglich heruntergeladenen Richtliniendateien möglicherweise nicht für die endgültige URL des Sounds. Dies ist jedoch die URL, die bei Sicherheitsentscheidungen von Bedeutung ist.</p>
	 
	 <p platform="actionscript">Es folgt eine mögliche Lösung für diese Situation. Nach dem Empfang eines <codeph>progress</codeph>- oder <codeph>complete</codeph>-Ereignisses können Sie den Wert der <codeph>Sound.url</codeph>-Eigenschaft überprüfen, die die endgültige URL des Sounds enthält. Rufen Sie dann die <codeph>Security.loadPolicyFile()</codeph>-Methode mit der URL einer Richtliniendatei auf, die auf der endgültigen URL des Sounds beruht. Rufen Sie schließlich den Wert von <codeph>Sound.id3</codeph> auf, bis keine Ausnahme mehr ausgegeben wird.</p>
	 
	 <p platform="actionscript">Dies bezieht sich nicht auf Inhalt in der Sandbox der AIR-Anwendung. Inhalt in der Anwendungssandbox hat immer (unabhängig von seiner Herkunft) programmgesteuerten Zugriff auf Soundinhalt.</p>
	 
	 <p platform="actionscript">Weitere Informationen zu Richtliniendateien finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>flash.media.Sound.load()</linktext></link><link href="flash.media.xml#Sound/id3"><linktext>flash.media.Sound.id3</linktext></link><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>flash.media.SoundMixer.computeSpectrum()</linktext></link><link href="flash.media.xml#Sound/url"><linktext>flash.media.Sound.url</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundChannel"><apiName>SoundChannel</apiName><shortdesc>
 Die SoundChannel-Klasse steuert Sound in einer Anwendung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die SoundChannel-Klasse steuert Sound in einer Anwendung. Jeder Sound ist einem Soundkanal zugewiesen, und die Anwendung kann über mehrere Soundkanäle verfügen, die zusammengemischt werden. Die SoundChannel-Klasse enthält eine <codeph>stop()</codeph>-Methode, Eigenschaften zum Überwachen der Amplitude (Lautstärke) eines Kanals und eine Eigenschaft zum Zuweisen eines SoundTransform-Objekts zu einem Kanal.
 
 </apiDesc><example conref="examples\SoundChannelExample.as"> Im folgenden Beispiel wird eine MP3-Datei geladen und abgespielt und es werden Informationen über Soundereignisse angezeigt, die beim Laden und Abspielen der MP3-Datei auftreten. Ein Timerobjekt stellt alle 50 Millisekunden aktualisierte Informationen zur Position des Abspielkopfs bereit. Legen Sie zur Ausführung dieses Beispiels eine Datei mit dem Namen „MySound.mp3“ in dem Verzeichnis ab, in dem sich die SWF-Datei befindet.

<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundChannelExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundChannelExample() {
            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);

            channel = soundFactory.play();
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);

            positionTimer = new Timer(50);
            positionTimer.addEventListener(TimerEvent.TIMER, positionTimerHandler);
            positionTimer.start();
        }
        

        private function positionTimerHandler(event:TimerEvent):void {
            trace("positionTimerHandler: " + channel.position.toFixed(2));
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
            positionTimer.stop();       
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }

        private function soundCompleteHandler(event:Event):void {
            trace("soundCompleteHandler: " + event);
            positionTimer.stop();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:SoundChannel_flash.events.Event.SOUND_COMPLETE_soundComplete"><apiName>soundComplete</apiName><shortdesc>
 Wird ausgelöst, wenn die Wiedergabe eines Sounds beendet ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SOUND_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn die Wiedergabe eines Sounds beendet ist. 
 </apiDesc><example conref="examples\SoundChannel_event_soundCompleteExample.as"> Im folgenden Beispiel wählt der Benutzer Titel aus einer Wiedergabeliste aus und klickt dann auf „Play“, um die Lieder in der ausgewählten Reihenfolge abzuspielen.
 
 <p>Im Konstruktor wird ein Textfeld definiert, das die Liste der Titel sowie eine Zeile, die zum Abspielen ausgewählt wird, enthält. (Normalerweise werden Schaltflächen für die Wiedergabe und Listenfelder für Titellisten verwendet.) Ein Textformatobjekt wird definiert, das das Format der Titel nach der Auswahl zu kursiv ändert. Wenn ein Benutzer auf das Textfeld klickt, wird die Methode <codeph>clickHandler()</codeph> aufgerufen.</p> 
 
<p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getLineIndexAtPoint()</codeph>-Methode des Textfeld-Objekts den Index der Zeile, auf die der Benutzer geklickt hat, zurück. Mithilfe des Zeilenindex ruft die Methode <codeph>getLineText()</codeph> den Textinhalt ab. Mit der if-Anweisung wird überprüft, ob der Benutzer eine Auswahl für die Wiedergabe getroffen oder der Wiedergabeliste einen Titel hinzufügt hat. Wenn der Benutzer sich für das Abspielen entschieden hat und ein Titel ausgewählt wurde, wird der Ereignis-Listener für den Mausklick entfernt und die Methode <codeph>playNext()</codeph> wird aufgerufen, um mit der Wiedergabe der Titel zu beginnen. Wenn der Benutzer einen Titel ausgewählt hat, wird der Inhalt der Zeile dem Array <codeph>songList</codeph> hinzugefügt und das Format der Zeile wird auf kursiv eingestellt.</p>
 
 <p>Die <codeph>playNext()</codeph>-Methode durchläuft die Arrayliste, um die einzelnen Titel zu laden und abzuspielen. Der Titel wird auch einem Soundkanal zugewiesen. Ein Ereignis-Listener für den Soundkanal wird hinzugefügt, um zu reagieren, wenn ein Titel abgespielt wurde und das Ereignis <codeph>Event.SOUND_COMPLETE</codeph> ausgelöst wird. Die <codeph>soundCompleteHandler()</codeph>-Methode ruft dann die Methode <codeph>playNext()</codeph> auf, um den nächsten Titel abzuspielen. Dieser Prozess wird fortgesetzt, bis alle im Array aufgeführten Titel abgespielt wurden.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;

    public class SoundChannel_event_soundCompleteExample extends Sprite {
        private var channel:SoundChannel = new SoundChannel();
        private var songList:Array = new Array();
        private var listTextField:TextField = new TextField();
        private var songFormat:TextFormat = new TextFormat();
        private var arrayIndex:int = 0;
        private var songSelected:Boolean = false;
        
        public function SoundChannel_event_soundCompleteExample() {
            
            listTextField.autoSize = TextFieldAutoSize.LEFT;
            listTextField.border = true
            listTextField.background = true;
            listTextField.text = "Song1.mp3\n" + "Song2.mp3\n" 
                                + "Song3.mp3\n" + "Song4.mp3\n" + "PLAY";
        
            songFormat.italic = true;
 
            listTextField.addEventListener(MouseEvent.CLICK, clickHandler);
                        
            addChild(listTextField);
        }
        
        private function clickHandler(e:MouseEvent):void {
            var index:int = listTextField.getLineIndexAtPoint(e.localX, e.localY);
            var line:String = listTextField.getLineText(index);
            var firstIndex:uint = listTextField.getLineOffset(index);
            var playLine:uint = listTextField.numLines - 1;

                if((index == playLine) &amp;&amp; (songSelected == true)) {
                    listTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
                    playNext();       

                } else if (index != playLine) {
                     songList.push(line.substr(0, (line.length - 1)));
                     listTextField.setTextFormat(songFormat, firstIndex, 
                                (firstIndex + listTextField.getLineLength(index)));     
                    songSelected = true;
                 }
        }

        private function playNext():void {
 
             if(arrayIndex &lt; songList.length) {
                var snd:Sound = new Sound();
                snd.load(new URLRequest(songList[arrayIndex]));
                channel = snd.play();
                
                channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                arrayIndex++;
 
            } else {
                songSelected = false;
                    
                while(arrayIndex > 0) {
                    songList.pop();
                    arrayIndex--;
                }
            }
        }    

        private function soundCompleteHandler(e:Event):void {
            playNext();
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:SoundChannel:stop"><apiName>stop</apiName><shortdesc> 
	 Beendet die Wiedergabe des im Kanal wiedergegebenen Sounds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 Beendet die Wiedergabe des im Kanal wiedergegebenen Sounds.
	 
	 </apiDesc><example conref="examples\SoundChannel_stopExample.as"> Im folgenden Beispiel kann der Benutzer eine Sounddatei durch das Klicken auf eine Schaltfläche anhalten und fortsetzen.
 
 <p>Im Konstruktor wird die Sounddatei geladen. (In diesem Beispiel wird davon ausgegangen, dass sich die Datei im selben Verzeichnis wie die SWF-Datei befindet.) Als Schaltfläche, mit der der Benutzer Sound abspielen oder anhalten kann, wird ein Textfeld verwendet. Wenn der Benutzer auf das Textfeld <codeph>button</codeph> klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p>
 
 <p>In der <codeph>clickHandler()</codeph>-Methode wird Sound auf die Wiedergabe eingestellt und einem Soundkanal zugewiesen, wenn der Benutzer zum ersten Mal auf das Textfeld klickt. Wenn der Benutzer das nächste Mal auf das Textfeld klickt, wird die Soundwiedergabe angehalten. Die <codeph>position</codeph>-Eigenschaft des Soundkanals zeichnet die Position des Sounds zum Zeitpunkt des Stopps auf. Diese Eigenschaft wird verwendet, um Sound ab dieser Position weiter abzuspielen, nachdem der Benutzer auf das Textfeld geklickt hat, um die Wiedergabe fortzusetzen. Bei jedem Aufrufen der <codeph>Sound.play()</codeph>-Methode wird ein neues SoundChannel-Objekt erstellt und der Variablen <codeph>channel</codeph> zugewiesen. Das Soundobjekt muss einem SoundChannel-Objekt zugewiesen werden, um mithilfe der Methode <codeph>stop()</codeph> des Soundkanals den Sound anzuhalten.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
            
    public class SoundChannel_stopExample extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var button:TextField = new TextField();

        public function SoundChannel_stopExample() {
            var req:URLRequest = new URLRequest("MySound.mp3");
            snd.load(req);
            
            button.x = 10;
            button.y = 10;
            button.text = "PLAY";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.CENTER;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {
            var pausePosition:int = channel.position;

            if(button.text == "PLAY") {
                channel = snd.play(pausePosition);
                button.text = "PAUSE";
            } 
            else {
                channel.stop();
                button.text = "PLAY";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundChannel:leftPeak:get"><apiName>leftPeak</apiName><shortdesc> 
	 Die aktuelle Amplitude (Lautstärke) des linken Kanals von 0 (stumm) bis 1 (volle Amplitude).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Die aktuelle Amplitude (Lautstärke) des linken Kanals von 0 (stumm) bis 1 (volle Amplitude).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:position:get"><apiName>position</apiName><shortdesc>
	 Wenn Sound abgespielt wird, zeigt die Positionseigenschaft die aktuelle Stelle, die in der Sounddatei abgespielt wird, in Millisekunden an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Wenn Sound abgespielt wird, zeigt die <codeph>Positionseigenschaft</codeph> die aktuelle Stelle, die in der Sounddatei abgespielt wird, in Millisekunden an. Wenn Sound beendet oder angehalten wurde, zeigt die <codeph>Positionseigenschaft</codeph> die zuletzt abgespielte Stelle in der Sounddatei an.
	 
	 <p>Häufig wird der Wert der Eigenschaft <codeph>position</codeph> gespeichert, wenn der Sound gestoppt wird. Sie können die Wiedergabe später fortsetzen, indem Sie sie an der gespeicherten Position starten.
	 </p>
	 
	 <p>Wenn der Sound in einer Schleife wiedergegeben wird, wird <codeph>position</codeph> am Anfang jeder Schleife auf 0 zurückgesetzt.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:rightPeak:get"><apiName>rightPeak</apiName><shortdesc> 
	 Die aktuelle Amplitude (Lautstärke) des rechten Kanals von 0 (stumm) bis 1 (volle Amplitude).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Die aktuelle Amplitude (Lautstärke) des rechten Kanals von 0 (stumm) bis 1 (volle Amplitude).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 Das SoundTransform-Objekt, das dem Soundkanal zugewiesen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 Das SoundTransform-Objekt, das dem Soundkanal zugewiesen wurde. Ein SoundTransform-Objekt enthält Eigenschaften zum Festlegen von Lautstärke, Schwenkung sowie Zuordnung von linkem und rechtem Lautsprecher.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:Video"><apiName>Video</apiName><shortdesc>
 
 Die Videoklasse zeigt Livevideo oder aufgezeichnetes Video in einer Anwendung an, ohne dass das Video in die SWF-Datei eingebettet ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Die Videoklasse zeigt Livevideo oder aufgezeichnetes Video in einer Anwendung an, ohne dass das Video in die SWF-Datei eingebettet ist. Diese Klasse erzeugt ein Videoobjekt in einer Adobe Flash- oder Adobe Flex-Schnittstelle, die eine der beiden folgenden Videoarten abspielt: aufgenommene FLV-Dateien, die auf einem Server oder lokal gespeichert sind, oder Livevideo, das vom Computer eines Benutzers erfasst wird. Ein Videoobjekt ist ein Anzeigeobjekt in der Anzeigeliste der Anwendung und stellt den visuellen Raum dar, in dem das Video in einer Benutzeroberfläche abgespielt wird.
 
 <p>
 Bei der Verwendung mit Flash Media Server ermöglicht Ihnen das Videoobjekt, Livevideo vom Computer eines Benutzers an den Server zu senden und dann vom Server an andere Benutzer zu übertragen. Mithilfe dieser Funktionen können Sie Medienanwendungen wie einfache Videoplayer, Videoplayer mit Multipoint-Veröffentlichung von einem Server zum anderen oder eine Anwendung für den Videoaustausch in einer Community erstellen.
 </p>
 
 <p>
 Flash Player 9 unterstützt das Veröffentlichen und Wiedergeben von mit dem Sorenson Spark-Codec oder dem On2 VP6-Codec kodierten FLV-Dateien und zudem einen Alphakanal. Der Video-Codec On2 VP6 belegt eine geringere Bandbreite als ältere Technologien und enthält zusätzliche Deblocking- und Deringing-Filter. Weitere Informationen zur Videowiedergabe finden Sie im Abschnitt zur flash.net.NetStream-Klasse.</p>
 
 
 <p>
 Flash Player 9.0.115.0 und höher unterstützen MIP-Mapping, um die Wiedergabequalität und -leistung zur Laufzeit zu optimieren. Für die Videowiedergabe verwendet Flash Player MIP-Mapping-Optimierung, wenn Sie die Eigenschaft <codeph>smoothing</codeph> des Videoobjekts auf <codeph>true</codeph> einstellen. 
 </p> 
 
 <p>
 Wie bei anderen Anzeigeobjekten in der Anzeigeliste können Sie die verschiedenen Eigenschaften von Videoobjekten steuern. Sie können das Videoobjekt beispielsweise mithilfe seiner <codeph>x</codeph>- und <codeph>y</codeph>-Eigenschaften auf der Bühne verschieben, seine Größe mit den Eigenschaften <codeph>height</codeph> und <codeph>width</codeph> ändern usw. 
 </p>
 
 <p>
 Um einen Videostream abzuspielen, verwenden Sie <codeph>attachCamera()</codeph> oder <codeph>attachNetStream()</codeph>, um das Video an das Videoobjekt anzuhängen. Fügen Sie das Videoobjekt dann mithilfe von <codeph>addChild()</codeph> der Anzeigeliste hinzu.
 </p>
 
 <p product="flash">
 Wenn Sie die Flash-Authoring-Umgebung verwenden, können Sie das Videoobjekt auch auf der Bühne platzieren, anstatt es mit <codeph>addChild()</codeph> hinzuzufügen:
 </p>
 
 <ol product="flash">
   <li>Ist das Bibliothekbedienfeld nicht sichtbar, wählen Sie „Fenster“ > „Bibliothek“ aus.</li>
   <li>Fügen Sie der Bibliothek ein eingebettetes Videoobjekt hinzu, indem Sie auf der rechten Seite der Titelleiste im Bibliothekbedienfeld auf das Optionsmenü klicken und die Option „Neues Video“ auswählen.</li>
   <li>Benennen Sie das eingebettete Videoobjekt für die Verwendung in der Bibliothek im Dialogfeld für die Videoeigenschaften und klicken Sie auf „OK“.</li>
   <li>Ziehen Sie das Videoobjekt auf die Bühne und geben Sie ihm im Eigenschafteninspektor einen eindeutigen Namen, zum Beispiel <codeph>my_video</codeph>. (Verwenden Sie nicht den Namen „Video“.)</li>
 </ol>
 
 <p><b>Hinweis:</b> Die Videoklasse ist keine Unterklasse der InteractiveObject-Klasse, sodass keine Mausereignisse ausgelöst werden können. Sie können jedoch die <codeph>addEventListener()</codeph>-Methode für den Anzeigeobjekt-Container aufrufen, der das Videoobjekt enthält.
 </p>
 
 </apiDesc><example conref="examples\VideoExample.as"> Im folgenden Beispiel wird ein Videoobjekt mit den Klassen NetConnection und NetStream verwendet, um eine FLV-Datei zu laden und abzuspielen. Zur Ausführung dieses Beispiels benötigen Sie eine FLV-Datei, deren Name und Speicherort mit der an <codeph>videoURL</codeph> übergebenen Variablen übereinstimmt. In diesem Fall ist das eine FLV-Datei mit dem Namen „Video.flv“, die in dem Verzeichnis abgelegt ist, in dem sich die SWF-Datei befindet.
 <p>In diesem Fall wird der Code zur Erstellung des Video- und NetStream-Objekts und zum Aufrufen der Methoden <codeph>Video.attachNetStream()</codeph> und <codeph>NetStream.play()</codeph> in eine Prozedurfunktion eingefügt. Die Prozedur wird nur aufgerufen, wenn die Verbindung mit dem NetConnection-Objekt erfolgreich hergestellt werden kann, d. h. wenn das Ereignis <codeph>netStatus</codeph> ein info-Objekt mit einer <codeph>code</codeph>-Eigenschaft zurückgibt, die Erfolg angibt. Es wird empfohlen, die erfolgreiche Verbindungsherstellung abzuwarten, bevor Sie <codeph>NetStream.play()</codeph> aufrufen. </p>
 <codeblock>

 package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;

    public class VideoExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function VideoExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }

        private function connectStream():void {
            stream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }
    }
 }
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>attachCamera()</linktext></link><link href="flash.media.xml#Video/attachNetStream()"><linktext>attachNetStream()</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>flash.media.Camera.getCamera()</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#Stage/addChild()"><linktext>flash.display.Stage.addChild()</linktext></link></related-links><apiConstructor id="flash.media:Video:Video"><apiName>Video</apiName><shortdesc>
     Erstellt eine neue Video-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
     </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>320</apiData><apiDesc>Die Breite des Videos in Pixel.
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>240</apiData><apiDesc>Die Höhe des Videos in Pixel.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt eine neue Video-Instanz. Wenn für die Parameter <codeph>width</codeph> und <codeph>height</codeph> keine Werte angegeben sind, werden die Standardwerte verwendet. Mithilfe von <codeph>Video.width</codeph> und <codeph>Video.height</codeph> können Sie die width- und height-Eigenschaften des Videoobjekts auch nach der Erstellung des Objekts festlegen. Beim Erstellen eines neuen Videoobjekts ist der Wert 0 für die Höhe und Breite nicht zulässig. Wenn Sie den Wert 0 übergeben, werden die Standardwerte verwendet.
     
     <p>Rufen Sie nach dem Erstellen des Videos die Methode <codeph>DisplayObjectContainer.addChild()</codeph> oder <codeph>DisplayObjectContainer.addChildAt()</codeph> auf, um das Videoobjekt einem übergeordneten DisplayObjectContainer-Objekt hinzuzufügen.</p>
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Video:attachCamera"><apiName>attachCamera</apiName><shortdesc>
     Gibt einen Videostream von einer Kamera an, der innerhalb des Videoobjekts in der Anwendung angezeigt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.attachCamera, attachCamera()
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>camera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>Ein Camera-Objekt, das Videodaten erfasst. Wenn Sie die Verbindung mit dem Videoobjekt beenden möchten, übergeben Sie den Wert <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt einen Videostream von einer Kamera an, der innerhalb des Videoobjekts in der Anwendung angezeigt werden soll.
     
     <p>
     Verwenden Sie diese Methode, um Livevideo vom Computer eines Benutzers an das Videoobjekt anzuhängen. Sie können das Livevideo lokal auf demselben Computer, auf dem es aufgezeichnet wurde, abspielen, oder es an Flash Media Server senden und es mithilfe des Servers an andere Benutzer streamen.
     </p>
     
     </apiDesc><example>Die Verwendung dieser Methode wird im Beispiel für die <xref href="Camera.html#getCamera()">Camera.getCamera()</xref>-Methode veranschaulicht. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachNetStream()"><linktext>Video.attachNetStream()</linktext></link><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:attachNetStream"><apiName>attachNetStream</apiName><shortdesc>
     Gibt einen Videostream an, der innerhalb des Videoobjekts in der Anwendung angezeigt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, video, Video.attachNetStream, attachNetStream()
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>netStream</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier><apiDesc>Ein NetStream-Objekt. Wenn Sie die Verbindung mit dem Videoobjekt beenden möchten, übergeben Sie den Wert <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt einen Videostream an, der innerhalb des Videoobjekts in der Anwendung angezeigt werden soll. Der Videostream ist entweder eine FLV-Datei, die mit <codeph>NetStream.play()</codeph> abgespielt wird, ein Camera-Objekt oder <codeph>null</codeph>. Wenn Sie eine FLV-Datei verwenden, kann sie im lokalen Dateisystem oder auf Flash Media Server gespeichert werden. Wenn der Wert des <codeph>netStream</codeph>-Arguments auf <codeph>null</codeph> gesetzt ist, wird das Video nicht mehr im Videoobjekt wiedergegeben.
     
     <p>
     Sie müssen diese Methode nicht verwenden, wenn die FLV-Datei nur Audiodaten enthält. Die Audiodaten von FLV-Dateien werden automatisch wiedergegeben, wenn Sie die <codeph>NetStream.play()</codeph>-Methode aufrufen. Um die mit einer FLV-Datei verknüpften Audiodaten zu steuern, verwenden Sie die <codeph>soundTransform</codeph>-Eigenschaft des NetStream-Objekts, das die FLV-Datei wiedergibt.
     </p>
     
     </apiDesc><example>Am Ende des Abschnitts über diese Klasse finden Sie in Beispiel , in dem die Verwendung dieser Methode veranschaulicht wird. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>flash.net.NetStream.play()</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:clear"><apiName>clear</apiName><shortdesc>
     Löscht das Bild, das aktuell im Videoobjekt angezeigt wird (nicht im Videostream).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.clear, clear
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Löscht das Bild, das aktuell im Videoobjekt angezeigt wird (nicht im Videostream). Diese Methode ist für das Arbeiten mit dem aktuellen Bild nützlich. Sie können beispielsweise das letzte Bild löschen oder Standbyinformationen anzeigen, ohne das Videoobjekt auszublenden.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Video:deblocking:get"><apiName>deblocking</apiName><shortdesc>
     Gibt den Typ des Filters an, der bei der Nachbearbeitung auf dekodierte Videos angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.deblocking, deblocking
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Gibt den Typ des Filters an, der bei der Nachbearbeitung auf dekodierte Videos angewendet wird. Mit dem Standardwert 0 kann bei der Videokomprimierung gegebenenfalls ein Deblocking-Filter angewendet werden.
     
     <p>Die Komprimierung von Videos kann zu unerwünschten Artefakten führen. Mithilfe der <codeph>deblocking</codeph>-Eigenschaft können Sie Filter setzen, mit denen Blocking-Artefakte und (bei Videokomprimierungen mit dem On2 VP6-Codec) auch Ringing-Artefakte reduziert werden.</p>
     
     <p><i>Blocking</i> bezieht sich auf sichtbare Fehler zwischen den Begrenzungen der einzelnen Blocks, aus denen sich jedes Videobild zusammensetzt. <i>Ringing</i> bezieht sich auf verzerrte Kanten der Elemente in einem Videobild.</p>
     
     <p>Es stehen zwei Deblocking-Filter zur Verfügung: einer im Sorenson-Codec und ein weiterer im On2 VP6-Codec. Bei Verwendung des On2 VP6-Codecs ist zudem ein Deringing-Filter verfügbar. Verwenden Sie zum Festlegen eines Filters einen der folgenden Werte:</p>
     
     <ul>
       <li>0 – Der Deblocking-Filter wird bei der Videokomprimierung bei Bedarf angewendet.</li>
       <li>1 – Es wird kein Deblocking-Filter verwendet.</li>
       <li>2 – Es wird der Sorenson-Deblocking-Filter angewendet.</li>
       <li>3 – Nur bei der On2-Videokomprimierung wird der Deblocking-Filter von On2, jedoch kein Deringing-Filter verwendet.</li>
       <li>4 – Nur für On2-Video. Es wird der Deblocking-Filter und der Deringing-Filter von On2 verwendet.</li>
       <li>5 – Nur bei der On2-Videokomprimierung wird der Deblocking-Filter und ein leistungsstärkerer Deringing-Filter von On2 verwendet.</li>
     </ul>
     
     <p>Wenn bei Verwendung des Sorenson-Codecs ein Wert größer als 2 angegeben wurde, wird der Sorenson-Decoder automatisch auf 2 gesetzt.</p>
     
     <p>Die Verwendung eines Deblocking-Filters hat Auswirkungen auf die Gesamtleistung bei der Wiedergabe und ist bei Videos mit hoher Bandbreite normalerweise nicht erforderlich. Wenn das System eines Benutzers nicht leistungsfähig genug ist, treten bei einem aktivierten Deblocking-Filter bei der Wiedergabe von Videos möglicherweise Probleme auf.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:smoothing:get"><apiName>smoothing</apiName><shortdesc>
     Gibt an, ob das Video beim Skalieren geglättet (interpoliert) werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.smoothing, smoothing
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob das Video beim Skalieren geglättet (interpoliert) werden soll. Die Funktion zum Glätten funktioniert nur, wenn sich der Player im Modus für hohe Qualität befindet. Der Standardwert ist <codeph>false</codeph> (ohne Glättung).
     <p>Setzen Sie für die Videowiedergabe mit Flash Player 9.0.115.0 und höheren Versionen diese Eigenschaft auf <codeph>true</codeph>, um die Bilder durch MIP-Mapping zu optimieren.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:videoHeight:get"><apiName>videoHeight</apiName><shortdesc>
      Eine Ganzzahl, die die Höhe des Videostreams in Pixeln angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.height, height
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      Eine Ganzzahl, die die Höhe des Videostreams in Pixeln angibt. Im Falle von Live-Streams ist der Wert mit dem der Eigenschaft <codeph>Camera.height</codeph> des Kamera-Objekts identisch, das den Videostream aufzeichnet. Bei FLV-Dateien entspricht dieser Wert der Höhe der Datei, die im FLV-Format exportiert wurde.
     <p>Sie können diese Eigenschaft beispielsweise verwenden, um sicherzustellen, dass der Benutzer das Video in der Größe sieht, in der es aufgenommen wurde (unabhängig von der eigentlichen Größe des Videoobjekts auf der Bühne).</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/height"><linktext>flash.media.Camera.height</linktext></link></related-links></apiValue><apiValue id="flash.media:Video:videoWidth:get"><apiName>videoWidth</apiName><shortdesc>
      Eine Ganzzahl, die die Breite des Videostreams in Pixeln angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.width, width
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      Eine Ganzzahl, die die Breite des Videostreams in Pixeln angibt. Im Falle von Live-Streams ist der Wert mit dem der Eigenschaft <codeph>Camera.width</codeph> des Camera-Objekts identisch, das den Videostream aufzeichnet. Bei FLV-Dateien entspricht dieser Wert der Breite der Datei, die als FLV-Datei exportiert wurde.
     <p>Sie können diese Eigenschaft beispielsweise verwenden, um sicherzustellen, dass der Benutzer das Video in der Größe sieht, in der es aufgenommen wurde (unabhängig von der eigentlichen Größe des Videoobjekts auf der Bühne).</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>flash.media.Camera.width</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundMixer"><apiName>SoundMixer</apiName><shortdesc>
Die SoundMixer-Klasse enthält statische Eigenschaften und Methoden für globale Soundsteuerung innerhalb der Anwendung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die SoundMixer-Klasse enthält statische Eigenschaften und Methoden für globale Soundsteuerung innerhalb der Anwendung. Die SoundMixer-Klasse steuert eingebetteten und Streamingsound in der Anwendung. Sie steuert keine dynamisch erzeugten Sounds (also Sounds, die als Antwort auf Soundobjekte generiert wurden, die ein <codeph>sampleData</codeph>-Ereignis auslösen).

</apiDesc></apiClassifierDetail><apiOperation id="flash.media:SoundMixer:areSoundsInaccessible"><apiName>areSoundsInaccessible</apiName><shortdesc> 
     Gibt an, ob aufgrund der Sicherheitsbeschränkungen nicht auf Sound zugegriffen werden darf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Die Stringdarstellung des booleschen Werts.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc> 
     Gibt an, ob aufgrund der Sicherheitsbeschränkungen nicht auf Sound zugegriffen werden darf. Beispielsweise kann auf Sound, der von einer anderen Domäne als der des Inhalts, der diese Methode aufruft, geladen wird, nicht zugegriffen werden, wenn der Server für den Sound keine URL-Richtliniendatei hat, die Zugriff auf diese Domäne gewährt. Sound kann zwar geladen und wiedergegeben werden, Methoden auf niedriger Ebene, z. B. Abrufen von ID3-Metadaten für Sound, können jedoch nicht durchgeführt werden.
     
     <p>Bei Inhalten von AIR-Anwendungen in der Sicherheitssandbox der Anwendung wird beim Aufrufen dieser Methode immer <codeph>false</codeph> zurückgegeben. Alle Sounds, einschließlich der aus anderen Domänen geladenen, sind für Inhalte in der Sicherheitssandbox der Anwendung zugänglich.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>computeSpectrum()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:computeSpectrum"><apiName>computeSpectrum</apiName><shortdesc>
     Erstellt einen Schnappschuss der aktuellen Schallwelle und legt ihn im angegebenen ByteArray-Objekt ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should confirm if the floating point numbers are single- or double-precision.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>outputArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Ein ByteArray-Objekt mit den Werten, die mit dem Sound verknüpft sind. Wenn auf Sound aufgrund von Sicherheitsbeschränkungen nicht zugegriffen werden kann (<codeph>areSoundsInaccessible == true</codeph>), bleibt das <codeph>outputArray</codeph>-Objekt unverändert. Wenn sämtlicher Sound gestoppt wird, ist das <codeph>outputArray</codeph>-Objekt mit Nullen gefüllt.
     
     </apiDesc></apiParam><apiParam><apiItemName>FFTMode</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein boolescher Wert, der angibt, ob für die Sounddaten zunächst eine Fourier-Transformation durchgeführt wird. Wenn Sie diesen Parameter auf <codeph>true</codeph> setzen, gibt die Methode statt der unformatierten Schallwelle ein Frequenzspektrum zurück. Im Frequenzspektrum sind niedrige Frequenzen im linken Bereich und hohe Frequenzen im rechten Bereich dargestellt.
     
     </apiDesc></apiParam><apiParam><apiItemName>stretchFactor</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Auflösung der Soundsamples. Wenn Sie den <codeph>stretchFactor</codeph>-Wert auf 0 setzen, werden die Daten mit 44,1 KHz gesampelt, beim Wert 1 mit 22,05 KHz, beim Wert 2 mit 11,025 KHz usw.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Erstellt einen Schnappschuss der aktuellen Schallwelle und legt ihn im angegebenen ByteArray-Objekt ab. Die Werte werden als normalisierte Gleitkommawerte im Bereich zwischen -1,0 und 1,0 formatiert. Das für den <codeph>outputArray</codeph>-Parameter übergebene ByteArray-Objekt wird mit den neuen Werten überschrieben. Die Größe des erstellten ByteArray-Objekts ist auf 512 Gleitkommawerte festgelegt, wobei die ersten 256 Werte den linken Kanal darstellen und die restlichen 256 Werte den rechten Kanal.
     
     <p><b>Hinweis</b>: Diese Methode unterliegt den Sicherheitsbeschränkungen für lokale Dateien und den Beschränkungen für Cross-Domain-Ladevorgänge. Bei Verwendung lokaler Dateien oder von Sound, der über einen Server in einer anderen Domäne als die des aufrufenden Inhalts geladen wurde, müssen Sie die Sandbox-Beschränkungen möglicherweise durch eine Cross-Domain-Richtliniendatei umgehen. Weitere Informationen finden Sie in der Beschreibung zur Soundklasse. Darüber hinaus können mit dieser Methode keine Daten aus RTMP-Streams extrahiert werden, auch wenn die Methode über Inhalt aufgerufen wird, die sich in der gleichen Domäne wie der RTMP-Server befinden.</p>
     
     
     <p>Diese Methode wird über RTMP in Flash Player 9.0.115.0 und höher und in Adobe AIR unterstützt. Sie können den Zugriff auf Streams auf Flash Media Server in einem serverseitigen Skript steuern. Weitere Informationen finden Sie in den Abschnitten zu den Eigenschaften <codeph>Client.audioSampleAccess</codeph> und <codeph>Client.videoSampleAccess</codeph> in <xref href="http://www.adobe.com/go/documentation_de" scope="external"> <i>Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></xref>.</p>
     
     </apiDesc><example conref="examples\SoundMixer_computeSpectrumExample.as"> Im folgenden Beispiel wird mit der <codeph>computeSpectrum()</codeph>-Methode eine grafische Darstellung der Soundwellendaten erzeugt. 
 
 <p>Im Konstruktor wird eine Sounddatei geladen und für die Wiedergabe eingerichtet. (In diesem Beispiel wird keine Fehlerverarbeitung verwendet, und es wird davon ausgegangen, dass sich die Sounddatei im selben Verzeichnis befindet wie die SWF-Datei.) Im Beispiel wird auf das Ereignis <codeph>Event.ENTER_FRAME</codeph> gewartet, während der Sound abgespielt wird. Dabei wird wiederholt die Methode <codeph>onEnterFrame()</codeph> aufgerufen, um eine Kurve mit den Werten der Sounddaten zu zeichnen. Wenn die Wiedergabe beendet ist, stoppt die <codeph>onPlaybackComplete()</codeph>-Methode das Zeichnen, indem sie den Listener für das <codeph>Event.ENTER_FRAME</codeph>-Ereignis entfernt.</p>
 
 <p>In der <codeph>onEnterFrame()</codeph>-Methode speichert die <codeph>computeSpectrum()</codeph>-Methode den unformatierten Sound im Bytearray-Objekt <codeph>bytes</codeph>. Die Daten werden mit 44,1 KHz gesampelt. Der Bytearray enthält 512 Byte Daten, die jeweils einen Gleitkommawert zwischen -1 und 1 aufweisen. Die ersten 256 Werte repräsentieren den linken Kanal, die zweiten 256 den rechten Kanal. Die erste for-Schleife liest die ersten 256 Datenwerte (den linken Stereokanal) und zeichnet mithilfe der <codeph>Graphics.lineTo()</codeph>-Methode eine Linie von jedem Punkt zum nächsten. (Die Vektorgrafikanzeige der Soundwelle wird direkt in das Sprite-Objekt der Klasse geschrieben.) Die Soundbyte werden als 32-Bit-Gleitkommazahl vom Bytestream gelesen und mit der Plothöhe multipliziert, um den vertikalen Bereich der Kurve aufzunehmen. Die Breite wird auf das Doppelte der Breite der Kanallänge festgelegt. Die zweite for-Schleife liest die nächsten 256 Werte (den rechten Stereokanal) und plottet die Linien in umgekehrter Reihenfolge. Die Methoden <codeph>g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);</codeph> und <codeph>g.lineTo(0, PLOT_HEIGHT);</codeph> zeichnen die Grundlinien für die Wellen. Die resultierende Wellenform produziert einen Spiegelbildeffekt.</p>  

<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.net.URLRequest;
    import flash.utils.ByteArray;
    import flash.text.TextField;

    public class SoundMixer_computeSpectrumExample extends Sprite {

        public function SoundMixer_computeSpectrumExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("Song1.mp3");
            snd.load(req);
            
            var channel:SoundChannel;
            channel = snd.play();
            addEventListener(Event.ENTER_FRAME, onEnterFrame);
            channel.addEventListener(Event.SOUND_COMPLETE, onPlaybackComplete);
        }

        private function onEnterFrame(event:Event):void {
            var bytes:ByteArray = new ByteArray();
            const PLOT_HEIGHT:int = 200;
            const CHANNEL_LENGTH:int = 256;

            SoundMixer.computeSpectrum(bytes, false, 0);
            
            var g:Graphics = this.graphics;
            
            g.clear();
       
            g.lineStyle(0, 0x6600CC);
            g.beginFill(0x6600CC);
            g.moveTo(0, PLOT_HEIGHT);
            
            var n:Number = 0;
            
            for (var i:int = 0; i &lt; CHANNEL_LENGTH; i++) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }

            g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            g.endFill();
 
            g.lineStyle(0, 0xCC0066);
            g.beginFill(0xCC0066, 0.5);
            g.moveTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            
            for (i = CHANNEL_LENGTH; i > 0; i--) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }
  
            g.lineTo(0, PLOT_HEIGHT);
            g.endFill();
        }
        
        private function onPlaybackComplete(event:Event):void {
            removeEventListener(Event.ENTER_FRAME, onEnterFrame);
        }
    }
}

</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/areSoundsInaccessible()"><linktext>areSoundsInaccessible()</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.media.xml#Sound"><linktext>flash.media.Sound</linktext></link><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>flash.media.SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:stopAll"><apiName>stopAll</apiName><shortdesc>
     Stoppt sämtlichen derzeit wiedergegebenen Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Stoppt sämtlichen derzeit wiedergegebenen Sound. 
     
     <p product="flash">Diese Methode stoppt nicht den Abspielkopf. Wenn der Abspielkopf Bilder erreicht, in denen Streamingsound enthalten ist, wird die Wiedergabe dieses Sounds fortgesetzt.</p>
     
     <p platform="actionscript">Beachten Sie bei Verwendung dieser Eigenschaft das folgende Sicherheitsmodell von:</p>
     
     <ul platform="actionscript">
     
     <li> In der Standardeinstellung wird durch Aufrufen der <codeph>soundMixer.stopAll()</codeph>-Methode nur der Sound gestoppt, der sich in der gleichen Sicherheitssandbox wie das Objekt befindet, das die Methode aufruft. Sound, dessen Wiedergabe nicht über die gleiche Sandbox wie die des aufrufenden Objekts gestartet wurde, wird nicht gestoppt.</li>
     
     <li>Wenn Sie Sound mithilfe der <codeph>load()</codeph>-Methode der Soundklasse laden, können Sie einen <codeph>context</codeph>-Parameter angeben, bei dem es sich um ein SoundLoaderContext-Objekt handelt. Wenn Sie die <codeph>checkPolicyFile</codeph>-Eigenschaft des SoundLoaderContext-Objekts auf <codeph>true</codeph> setzen, wird in <ph platform="actionscript">Flash Player oder </ph>AIR auf dem Server eine Cross-Domain-Richtliniendatei gesucht, über die der Sound geladen wird. Wenn der Server über eine Cross-Domain-Richtliniendatei verfügt und die Datei die Domäne des aufrufenden Inhalts zulässt, kann die Datei den geladenen Sound über die <codeph>soundMixer.stopAll()</codeph>-Methode stoppen. Andernfalls ist dies nicht möglich.</li>
     
     </ul>
     
     <p platform="actionscript">In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
     
     <p platform="actionscript">Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
     
     <ul platform="actionscript">
     
     <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
     
     </apiDesc><example conref="examples\SoundMixer_stopAllExample.as"> Im folgenden Beispiel werden mit der Methode <codeph>stopAll()</codeph> zwei Sounds stummgeschaltet, die gleichzeitig abgespielt werden. 
 
 <p>Im Konstruktor werden zwei unterschiedliche Sounddateien geladen und für das Abspielen eingestellt. Der erste Sound wird lokal geladen und einem Soundkanal zugewiesen. (Es wird davon ausgegangen, dass sich die Datei im selben Verzeichnis wie die SWF-Datei befindet.) Die zweite Datei wird von der Adobe-Site geladen und gestreamt. Damit die Methode <codeph>SoundMixer.stopAll()</codeph> verwendet werden kann, müssen alle Sounds zugänglich sein. (Für Überprüfung der domänenübergreifenden Richtliniendatei kann ein SoundLoaderContext-Objekt verwendet werden.) Jeder Sound verfügt auch über einen Ereignis-Listener, der aufgerufen wird, wenn beim Laden der Sounddatei ein IO-Fehler auftritt. Des Weiteren wird ein Textfeld <codeph>muteButton</codeph> erstellt. Es wartet auf einen Mausklick, der die Methode <codeph>muteButtonClickHandler()</codeph> aufruft.</p>
 
 <p>Wenn in der <codeph>muteButtonClickHandler()</codeph>-Methode der Inhalt des Textfelds „MUTE“ ist, überprüft die <codeph>areSoundsInaccessible()</codeph>-Methode, ob der Soundmischer Zugriff auf die Dateien hat. Wenn auf die Dateien zugegriffen werden kann, stoppt die <codeph>stopAll()</codeph>-Methode die Sounds. Beim erneuten Klicken auf das Textfeld beginnt die Wiedergabe der ersten Sounddatei, und der Inhalt des Textfelds ändert sich zu „MUTE“. Dieses Mal schaltet die Methode <codeph>stopAll()</codeph> die einzige Sounddatei, die abgespielt wird, stumm. Die <codeph>stop()</codeph>-Methode des Soundkanals kann auch dazu verwendet werden, einen bestimmten Sound, der dem Kanal zugewiesen ist, zu stoppen. (Dazu muss der Sound dem Kanal jedes Mal neu zugewiesen werden, wenn die <codeph>play()</codeph>-Methode aufgerufen wird.)</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.events.IOErrorEvent;

    public class SoundMixer_stopAllExample extends Sprite  {
        private var firstSound:Sound = new Sound();
        private var secondSound:Sound = new Sound();
        private var muteButton:TextField = new TextField();
        private var channel1:SoundChannel = new SoundChannel();
        
        public function SoundMixer_stopAllExample() {
            firstSound.load(new URLRequest("mySound.mp3"));
            secondSound.load(new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3"));

            firstSound.addEventListener(IOErrorEvent.IO_ERROR, firstSoundErrorHandler);
            secondSound.addEventListener(IOErrorEvent.IO_ERROR, secondSoundErrorHandler);
            
            channel1 = firstSound.play();
            secondSound.play();
            
            muteButton.autoSize = TextFieldAutoSize.LEFT;
            muteButton.border = true;
            muteButton.background = true;
            muteButton.text = "MUTE";
        
            muteButton.addEventListener(MouseEvent.CLICK, muteButtonClickHandler);         
        
            this.addChild(muteButton);
        }

        private function muteButtonClickHandler(event:MouseEvent):void {

            if(muteButton.text == "MUTE") {        
  
                if(SoundMixer.areSoundsInaccessible() == false) {
                    SoundMixer.stopAll();
                    muteButton.text = "click to play only one of sound.";
                }
                else {
                    muteButton.text = "The sounds are not accessible.";
                }
            }
           else {
                firstSound.play();        
                muteButton.text = "MUTE";
           }
        } 

        private function firstSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }

        private function secondSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundMixer:bufferTime:get"><apiName>bufferTime</apiName><shortdesc>
     Die Anzahl der Sekunden zum Laden eines eingebetteten Streamingsounds in einen Puffer vor dem Streaming.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Die Anzahl der Sekunden zum Laden eines eingebetteten Streamingsounds in einen Puffer vor dem Streaming. Auf die Daten in einem geladenen Sound, einschließlich der Zwischenspeicherzeit, kann nicht von einer SWF-Datei, die sich in einer anderen Domäne befindet, zugegriffen werden, es sei denn, Sie implementieren eine Cross-Domain-Richtliniendatei. Weitere Informationen zu Sicherheit und Sound finden Sie in der Beschreibung zur Soundklasse. zu streamen. <ph platform="actionscript">Auf die Daten in einem geladenen Sound, einschließlich der Zwischenspeicherzeit, kann über Code in einer anderen Domäne nur zugegriffen werden, wenn eine Cross-Domain-Richtliniendatei implementiert ist. In der Anwendungssandbox einer AIR-Anwendung kann Code jedoch auf Daten in Sounddateien aus jeder Quelle zugreifen. Weitere Informationen zu Sicherheit und Sound finden Sie in der Beschreibung zur Soundklasse.</ph> 
     
     <p>Die <codeph>SoundMixer.bufferTime</codeph>-Eigenschaft wirkt sich nur auf die Zwischenspeicherzeit für eingebetteten Streamingsound in einer SWF-Datei aus und hängt nicht von dynamisch erstellten Soundobjekten (d. h. den in ActionScript erstellten Soundobjekten) ab. Durch den Wert von <codeph>SoundMixer.bufferTime</codeph> kann der Standardwert für die Zwischenspeicherzeit nicht überschrieben oder festgelegt werden, die in dem für die <codeph>Sound.load()</codeph>-Methode übergebenen SoundLoaderContext-Objekt angegeben ist.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link></related-links></apiValue><apiValue id="flash.media:SoundMixer:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
     Das SoundTransform-Objekt, über das die globalen Soundeigenschaften gesteuert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
     Das SoundTransform-Objekt, über das die globalen Soundeigenschaften gesteuert werden. Ein SoundTransform-Objekt enthält Eigenschaften zum Festlegen von Lautstärke, Schwenkung sowie Zuordnung von linkem und rechtem Lautsprecher. Das in dieser Eigenschaft verwendete SoundTransform-Objekt enthält endgültige Soundeinstellungen, die nach dem Anwenden der einzelnen Soundeinstellungen auf sämtliche Sounds angewendet werden.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier></apiPackage>