<?xml version="1.0"?>
<apiPackage id="flash.net"><apiName>flash.net</apiName><apiDetail/><apiClassifier id="flash.net:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
 
 Die XMLSocket-Klasse implementiert Client-Sockets, die der Flash Player- oder AIR-Anwendung die Kommunikation mit einem Server ermöglichen, der durch eine IP-Adresse oder einen Domänennamen identifiziert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLsocket, XMLsocket object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Die XMLSocket-Klasse implementiert Client-Sockets, die der <ph platform="actionscript">Flash Player- oder </ph>AIR-Anwendung die Kommunikation mit einem Server ermöglichen, der durch eine IP-Adresse oder einen Domänennamen identifiziert wird. Die XMLSocket-Klasse ist für Client-Server-Anwendungen nützlich, die geringe Latenzzeiten erfordern, beispielsweise Echtzeit-Chat-Systeme. Eine herkömmliche HTTP-Chat-Lösung fragt den Server in kurzen Abständen ab und lädt neue Nachrichten mithilfe einer HTTP-Anforderung. Im Gegensatz dazu unterhält eine XMLSocket-basierte Chat-Lösung eine offene Verbindung zum Server, damit dieser neu eingegangene Nachrichten sofort und ohne Anforderung vom Client senden kann. Um die XMLSocket-Klasse verwenden zu können, muss auf dem Servercomputer ein Daemon ausgeführt werden, der das von der XMLSocket-Klasse verwendete Protokoll verarbeiten kann. Das Protokoll wird in der folgenden Liste beschrieben: 
 <ul>
   <li>XML-Nachrichten werden über eine TCP/IP-Streaming-Socket-Verbindung im Vollduplexmodus gesendet.</li>
   <li>Jede XML-Nachricht ist ein vollständiges XML-Dokument, das mit einem Null-Byte (0) abgeschlossen wird.</li>
   <li>Es kann eine unbegrenzte Anzahl von XML-Nachrichten über eine einzelne XMLSocket-Verbindung gesendet und empfangen werden.</li>
 </ul>
 
 <p>Die Einrichtung eines Servers zur Kommunikation mit einem XMLSocket-Objekt ist oft recht anspruchsvoll. Wenn Ihre Anwendung keine Interaktionen in Echtzeit erfordert, verwenden Sie die URLLoader-Klasse anstelle der XMLSocket-Klasse. </p>
 
 <p>Um die Methoden der XMLSocket-Klasse zu verwenden, verwenden Sie zuerst den Konstruktor <codeph>new XMLSocket</codeph>, um ein XMlSocket-Objekt zu erstellen.</p>
 
 <p>SWF-Dateien in der lokalen Dateisystem-Sandbox dürfen keine Sockets verwenden.</p>
      
  <p> Die <i>Socket-Richtliniendateien</i> auf dem Ziel-Host legen sowohl den Host fest, von dem SWF-Dateien Socket-Verbindungen herstellen können, als auch die Ports, für welche die Verbindungen erstellt werden. Die Sicherheitsanforderungen für Socket-Richtliniendateien wurden in den letzten Versionen von Flash Player verschärft. Adobe empfiehlt für alle Versionen von Flash Player die Verwendung von Socket-Richtliniendateien. In einigen Fällen ist eine Socket-Richtliniendatei unbedingt erforderlich. Deshalb sollten Sie beim Verwenden von XML-Socket-Objekten sicherstellen, dass der Ziel-Host ggf. eine Socket-Richtliniendatei bereitstellt. </p>
 
  <p>Die folgende Liste fasst die Anforderungen für Socket-Richtliniendateien für die verschiedenen Versionen von Flash Player zusammen:</p>
 
  <ul>
  
   <li> In Flash Player 9.0.124.0 und höher sind für XMLSocket-Verbindungen Socket-Richtliniendateien erforderlich. Das heißt, dass eine Socket-Richtliniendatei für den Ziel-Host erforderlich ist, unabhängig von dem für die Verbindung ausgewählten Port. Sie ist sogar dann erforderlich, wenn Sie eine Verbindung zu einem Port auf dem gleichen Host herstellen, der die SWF-Dateien bereitstellt. </li>
 
   <li> Wenn Sie unter Flash Player Version 9.0.115.0 und früher eine Verbindung zu einer Portnummer kleiner als 1024 herstellen möchten, ist eine Socket-Richtliniendatei erforderlich. Das Gleiche gilt, wenn Sie eine Verbindung zu einem anderem Host herstellen möchten als dem, der die SWF-Dateien bereitstellt. </li>
 
  <li> Selbst wenn keine Socket-Richtliniendatei erforderlich ist, wird in Flash Player 9.0.115.0 während der Verwendung des Flash Debug Players eine Warnung angezeigt, wenn der Ziel-Host keine Socket-Richtliniendatei bereitstellt. </li>
 
  </ul>
 
 <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
 
 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
 <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
 </ul>
 
 </apiDesc><example conref="examples\XMLSocketExample.as"> Im folgenden Beispiel wird die XMLSocketExample-Klasse verwendet, um Daten über eine XMLSocket-Verbindung zu senden und bei XMLSocket-Ereignissen Informationen auszugeben. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Der XMLSocketExample-Konstruktor erstellt eine XMLSocket-Instanz mit dem Namen <codeph>socket</codeph>, übergibt <codeph>socket</codeph> an <codeph>ConfigureListeners()</codeph> (siehe unten) und ruft dann die Methode <codeph>connect()</codeph> für die XMLSocket-Verbindung auf, wobei der Hostname „localhost“ und die Portnummer <codeph>8080</codeph> verwendet werden.</li>
  <li>Daraufhin wird die Methode <codeph>configureListeners()</codeph> aufgerufen, die für jedes unterstützte XMLSocket-Ereignis Listener hinzufügt:
  <ul>
      <li><codeph>closeHandler()</codeph>: Listener für das Ereignis <codeph>close</codeph>, das nach dem Schließen der Netzwerkverbindung ausgelöst wird.</li>
      <li><codeph>connectHandler()</codeph>: Listener für das Ereignis <codeph>connect</codeph>, das nach dem Herstellen der Netzwerkverbindung ausgelöst wird.</li>
      <li><codeph>dataHandler()</codeph>: Listener für die <codeph>data</codeph>-Ereignisse, die jedes Mal ausgelöst werden, wenn über die XMLSocket-Verbindung neue Daten empfangen werden.</li>
      <li><codeph>progressHandler()</codeph>: Listener für die <codeph>progress</codeph>-Ereignisse, die beim Aufruf von <codeph>send()</codeph> und während des Sendevorgangs ausgelöst werden.</li>
      <li><codeph>securityErrorHandler()</codeph>: Listener für <codeph>securityError</codeph>-Ereignisse, die bei dem Versuch ausgelöst werden, mit der falschen Sicherheitseinstellung für die lokale Wiedergabe oder über einen Port mit einer niedrigeren Nummer als 1024 auf den XMLSocket-Server zuzugreifen.</li>  
      <li><codeph>ioErrorHandler()</codeph>: Listener für <codeph>ioError</codeph>-Ereignisse, die ausgelöst werden, wenn das Senden oder Empfangen von Daten fehlschlägt.</li>  
  </ul></li>
 </ol>
 <p><b>Hinweise:</b>
 <ul>
  <li>Sie müssen zur Kompilierung der SWF-Datei die Option „Sicherheit bei lokaler Wiedergabe“ auf „Nur auf Netzwerk zugreifen“ setzen.</li>
  <li>Damit dieses Beispiel funktioniert, benötigen Sie einen Server, der in Ihrer Domäne über Port 8080 läuft.</li>
  <li>Wenn Sie Flash Player 9.0.124.0 oder höher ausführen, müssen Sie auf Ihrem Server eine Socket-Richtliniendatei ablegen, die Socket-Verbindungen von Ihrer Domäne zu Port 8080 zulässt. Informationen zum Bereitstellen von Socket-Richtliniendateien finden Sie im Flash Player Developer Center im Abschnitt <xref href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html" scope="external"> Einrichten eines Servers für Socket-Richtliniendateien</xref>.</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.XMLSocket;

    public class XMLSocketExample extends Sprite {
        private var hostName:String = "localhost";
        private var port:uint = 8080;
        private var socket:XMLSocket;

        public function XMLSocketExample() {
            socket = new XMLSocket();
            configureListeners(socket);
            if (hostName &amp;&amp; port) {
                socket.connect(hostName, port);
            }
        }

        public function send(data:Object):void {
            socket.send(data);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CLOSE, closeHandler);
            dispatcher.addEventListener(Event.CONNECT, connectHandler);
            dispatcher.addEventListener(DataEvent.DATA, dataHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function closeHandler(event:Event):void {
            trace("closeHandler: " + event);
        }

        private function connectHandler(event:Event):void {
            trace("connectHandler: " + event);
        }

        private function dataHandler(event:DataEvent):void {
            trace("dataHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>flash.net.URLLoader.load()</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Wird ausgelöst, wenn mit einem Aufruf der Methode „XMLSocket.connect()“ versucht wird, eine Verbindung zu einem Server außerhalb der Sicherheitssandbox des Aufrufers oder zu einem Port mit einer niedrigeren Nummer als 1024 herzustellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn mit einem Aufruf der Methode <codeph>XMLSocket.connect()</codeph> versucht wird, eine Verbindung zu einem Server außerhalb der Sicherheitssandbox des Aufrufers oder zu einem Port mit einer niedrigeren Nummer als 1024 herzustellen.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>XMLSocket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Sende- oder Empfangsvorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Sende- oder Empfangsvorgang fehlschlägt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.DataEvent.DATA_data"><apiName>data</apiName><shortdesc>
 Wird nach dem Senden oder Empfangen von unformatierten Daten ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird nach dem Senden oder Empfangen von unformatierten Daten ausgelöst.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 Wird nach dem erfolgreichen Aufruf der Methode „XMLSocket.connect()“ ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird nach dem erfolgreichen Aufruf der Methode <codeph>XMLSocket.connect()</codeph> ausgelöst.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Wird ausgelöst, wenn der Server die Socketverbindung schließt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Server die Socketverbindung schließt. Das Ereignis <codeph>close</codeph> wird nur ausgelöst, wenn der Server die Verbindung schließt. Es wird nicht ausgelöst, wenn Sie die Methode <codeph>XMLSocket.close()</codeph> aufrufen.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:XMLSocket:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
    Erstellt ein neues XMLSocket-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein vollständig qualifizierter DNS-Domänenname oder eine IP-Adresse im Format <i>.222.333.444</i>. In Flash Player 9.0.115.0, AIR 1.0 und späteren Versionen können Sie IPv6-Adressen festlegen, z. B. rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]. Sie können auch <codeph>null</codeph> angeben, um eine Verbindung zum Hostserver herzustellen, auf dem die SWF-Datei gespeichert ist. Wenn die aufrufende SWF-Datei in einem Webbrowser ausgeführt wird, muss sich <codeph>host</codeph> in derselben Domäne befinden wie die SWF-Datei.
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die zur Herstellung einer Verbindung verwendete TCP-Portnummer auf dem Ziel-Host. In Flash Player 9.0.124.0 und späteren Versionen muss der Ziel-Host eine Socket-Richtliniendatei bereitstellen, die festlegt, dass Socket-Verbindungen zum festgelegten Port vom Host zugelassen sind, der die SWF-Datei bereitstellt. In älteren Versionen von Flash Player ist eine Socket-Richtliniendatei nur erforderlich, wenn Sie eine Verbindung zu einer Portnummer kleiner als 1024 herstellen möchten oder wenn Sie eine Verbindung mit einem Host herstellen möchten, der nicht der gleiche ist, der auch die SWF-Datei bereitstellt.
    
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Erstellt ein neues XMLSocket-Objekt. Wenn keine Parameter angegeben werden, wird ein Socket mit getrennter Verbindung erstellt. Wenn Parameter angegeben werden, wird versucht, eine Verbindung zu dem angegebenen Host und Port herzustellen.
    
    <p><b>Hinweis:</b> Es wird unbedingt empfohlen, das Konstruktor-Formular <b>ohne Parameter</b> zu verwenden, danach die Ereignis-Listener hinzuzufügen und danach die <codeph>connect</codeph>-Methode mit <codeph>host</codeph>- und <codeph>port</codeph>-Parametern aufzurufen. Diese Abfolge stellt sicher, dass alle Ereignis-Listener ordnungsgemäß funktionieren.</p>
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:XMLSocket:close"><apiName>close</apiName><shortdesc>
     Schließt die durch das XMLSocket-Objekt angegebene Verbindung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.close, close
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Schließt die durch das XMLSocket-Objekt angegebene Verbindung. Das Ereignis <codeph>close</codeph> wird nur ausgelöst, wenn der Server die Verbindung schließt. Es wird nicht ausgelöst, wenn Sie die Methode <codeph>close()</codeph> aufrufen.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:XMLSocket:connect"><apiName>connect</apiName><shortdesc>
     Stellt über den angegebenen TCP-Port eine Verbindung zum angegebenen Internet-Host her.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.connect, connect
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Über lokale nicht vertrauenswürdige Dateien kann keine Verbindung mit dem Internet hergestellt werden. Umgehen Sie diese Beschränkung, indem Sie die Datei neu als lokal mit Netzwerk oder als vertrauenswürdig klassifizieren.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Sie können für eine Socketverbindung keinen Port mit einer höheren Nummer als 65535 angeben.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein vollständig qualifizierter DNS-Domänenname oder eine IP-Adresse im Format <i>111.222.333.444</i>. Sie können auch <codeph>null</codeph> angeben, um eine Verbindung zum Hostserver herzustellen, auf dem die SWF-Datei gespeichert ist. Wenn die aufrufende Datei eine SWF-Datei ist, die in einem Webbrowser ausgeführt wird, muss <codeph>host</codeph> in der gleichen Domäne wie die Datei sein.
     
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die zur Herstellung einer Verbindung verwendete TCP-Portnummer auf dem Ziel-Host. In Flash Player 9.0.124.0 und späteren Versionen muss der Ziel-Host eine Socket-Richtliniendatei bereitstellen, die festlegt, dass Socket-Verbindungen zum festgelegten Port vom Host zugelassen sind, der die SWF-Datei bereitstellt. In älteren Versionen von Flash Player ist eine Socket-Richtliniendatei nur erforderlich, wenn Sie eine Verbindung zu einer Portnummer kleiner 1024 herstellen möchten oder wenn Sie eine Verbindung mit einem Host herstellen möchten, der nicht der gleiche ist, der auch die SWF-Datei bereitstellt.
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Stellt über den angegebenen TCP-Port eine Verbindung zum angegebenen Internet-Host her.
     
     <p>Wenn Sie für den Parameter <codeph>host</codeph> den Wert <codeph>null</codeph> angeben, wird der Host kontaktiert, auf dem die Datei gespeichert ist, die <codeph>XMLSocket.connect()</codeph> aufgerufen hat. Wenn die aufrufende Datei z. B. von www.adobe.com heruntergeladen wurde und für den host-Parameter <codeph>null</codeph> angegeben wurde, bedeutet das, dass Sie eine Verbindung zu www.adobe.com herstellen.</p>
     
     
     <p platform="actionscript">Sie können eine Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</p>
     
     <p>Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
	 
     <ul>
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/CONNECT"><linktext>flash.events.Event.CONNECT</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Bei einem Verbindungsvorgang wurde versucht, eine Verbindung zu einem Host außerhalb der Sicherheitssandbox des Aufrufers oder zu einem Port, der eine Socket-Richtliniendatei erfordert, herzustellen. Umgehen Sie diese Probleme, indem Sie auf dem Ziel-Host eine Socket-Richtliniendatei verwenden.
     </apiDesc></adobeApiEventDetail><shortdesc>Bei einem Verbindungsvorgang wurde versucht, eine Verbindung zu einem Host außerhalb der Sicherheitssandbox des Aufrufers oder zu einem Port, der eine Socket-Richtliniendatei erfordert, herzustellen.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_data"><apiName>data</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Empfang von unformatierten Daten ausgelöst.
     </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Empfang von unformatierten Daten ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde. 
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:XMLSocket:send"><apiName>send</apiName><shortdesc>
     Wandelt das mit dem Parameter „object“ angegebene XML-Objekt bzw. die angegebenen Daten in einen String um und übermittelt diesen gefolgt von einem Null-Byte (0) an den Server.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.send, send
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Das XMLSocket-Objekt ist nicht mit dem Server verbunden.
     
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Ein XML-Objekt oder andere Daten zur Übermittlung an den Server.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Wandelt das mit dem Parameter <codeph>object</codeph> angegebene XML-Objekt bzw. die angegebenen Daten in einen String um und übermittelt diesen gefolgt von einem Null-Byte (0) an den Server. Wenn es sich bei <codeph>object</codeph> um ein XML-Objekt handelt, enthält der String die XML-Textdarstellung des XML-Objekts. Die send-Operation ist asynchron; es erfolgt zwar sofort eine Rückgabe, die Daten werden aber möglicherweise zu einem späteren Zeitpunkt gesendet. Die Methode <codeph>XMLSocket.send()</codeph> gibt keinen Wert zurück, der angibt, ob die Daten erfolgreich übermittelt wurden.
     
     <p>Wenn Sie das XMLSocket-Objekt nicht über <codeph>XMLSocket.connect()</codeph> mit dem Server verbinden, schlägt der <codeph>XMLSocket.send()</codeph>-Vorgang fehl.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiValue id="flash.net:XMLSocket:connected:get"><apiName>connected</apiName><shortdesc>
     Gibt an, ob dieses XMLSocket-Objekt zurzeit verbunden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob dieses XMLSocket-Objekt zurzeit verbunden ist. Sie können sich auch für die Ereignisse <codeph>connect</codeph> und <codeph>ioError</codeph> registrieren, um zu überprüfen, ob die Verbindung erfolgreich hergestellt werden konnte.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#XMLSocket/event:connect"><linktext>connect</linktext></link><link href="flash.net.xml#XMLSocket/event:ioError"><linktext>ioError</linktext></link></related-links></apiValue><apiValue id="flash.net:XMLSocket:timeout:set"><apiName>timeout</apiName><shortdesc>
     Gibt die Anzahl der Millisekunden an, die auf eine Verbindung gewartet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Anzahl der Millisekunden an, die auf eine Verbindung gewartet werden soll.
     
     <p>Wenn die Verbindung nicht innerhalb der festgelegten Zeit hergestellt werden kann, schlägt der Verbindungsaufbau fehl. Der Standardwert ist 20.000 (zwanzig Sekunden).</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:ObjectEncoding"><apiName>ObjectEncoding</apiName><shortdesc>
 Mit der ObjectEncoding-Klasse werden Serialisierungseinstellungen in Klassen definiert, die zur Serialisierung von Objekten dienen (zum Beispiel FileStream, NetStream, NetConnection, SharedObject und ByteArray), um mit früheren Versionen von ActionScript arbeiten zu können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>ObjectEncoding, ObjectEncoding object, built-in class, AMF, Action Message Format
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der ObjectEncoding-Klasse werden Serialisierungseinstellungen in Klassen definiert, die zur Serialisierung von Objekten dienen (zum Beispiel FileStream, NetStream, NetConnection, SharedObject und ByteArray), um mit früheren Versionen von ActionScript arbeiten zu können. 
 
 <p>Mit der Objektkodierung wird die AMF-Version (Action Message Format) der Objekte gesteuert. Flash Player verwendet AMF, um eine effiziente Kommunikation zwischen einer Anwendung und einem Remote-Server zu ermöglichen. AMF kodiert Remote Procedure Calls in kompakte Binärdaten, die über HTTP/HTTPS oder das von Flash Media Server verwendete RTMP/RTMPS-Protokoll übertragen werden können. Objekte und Datenwerte werden in dieses Binärformat serialisiert, das in der Regel kompakter ist als andere Darstellungsformen wie XML.</p>
 
 <p>Adobe AIR und Flash Player 9 unterstützen die Serialisierung in zwei verschiedene Formate: AMF3 und AMF0. Das für ActionScript 3.0 entwickelte Standardformat AMF3 bietet im Vergleich zu dem für ActionScript 1.0 und 2.0 verwendeten Format AMF0 mehrere Vorteile. Die Datenübertragung über das Netzwerk erfolgt mit AMF3 effizienter als mit AMF0. <ph platform="actionscript">AMF3 unterstützt das Senden von <codeph>int</codeph>- und <codeph>uint</codeph>-Objekten als Ganzzahlen sowie Datentypen, die nur in ActionScript 3.0 verfügbar sind, wie z. B. ByteArray, XML und IExternalizable. Dieses Format ist nur in ActionScript 3.0 und für Server verfügbar, die die AMF3-Kodierung verwenden, wie Flex 2.</ph></p>
 
 <p>Die Klassen ByteArray, NetConnection, NetStream, <ph platform="actionscript">SharedObject, </ph>Socket und URLStream enthalten die <codeph>objectEncoding</codeph>-Eigenschaft , der mit der ObjectEncoding-Klasse eine Konstante zugewiesen wird. Das Verhalten der Eigenschaft <codeph>objectEncoding</codeph> hängt davon ab, um welches Objekt es sich handelt. In den Beschreibungen zur Eigenschaft <codeph>objectEncoding</codeph> der jeweiligen Klassen wird näher darauf eingegangen.</p>
 
 
 </apiDesc></apiClassifierDetail><apiValue id="flash.net:ObjectEncoding:AMF0"><apiName>AMF0</apiName><shortdesc>
	 Gibt an, dass Objekte mit der AMF-Version für ActionScript 1.0 und 2.0 serialisiert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass Objekte mit der AMF-Version für ActionScript 1.0 und 2.0 serialisiert werden.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:AMF3"><apiName>AMF3</apiName><shortdesc>
	 Gibt an, dass Objekte mit der AMF-Version für ActionScript 3.0 serialisiert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass Objekte mit der AMF-Version für ActionScript 3.0 serialisiert werden.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 Gibt das Standardformat (das neueste Format) für die aktuelle Laufzeit an (entweder Flash&amp;#xAE; Player oder Adobe&amp;#xAE; AIR&amp;#xAE;).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt das Standardformat (das neueste Format) für die aktuelle Laufzeit an (entweder Flash<sup>®</sup> Player oder Adobe<sup>®</sup> AIR<sup>®</sup>). Da die Steuerung der Objektkodierung nur in Flash Player 9 und neueren Versionen und in Adobe AIR verfügbar ist, können nur Formate ab der AMF-Version für ActionScript 3.0 verwendet werden.
	 
	 <p>Wenn für ein Objekt die <codeph>objectEncoding</codeph>-Eigenschaft auf <codeph>ObjectEncoding.DEFAULT</codeph> eingestellt ist, wird die AMF3-Kodierung verwendet. Wenn in Zukunft in einer neueren Version von Flash Player oder Adobe AIR eine neue AMF-Version eingeführt wird und Sie Ihre Inhalte neu veröffentlichen, wird die neue AMF-Version verwendet. Verwenden Sie diese Konstante nur, wenn Sie keinen Wert auf die Interoperabilität mit älteren Versionen legen.</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:dynamicPropertyWriter:get"><apiName>dynamicPropertyWriter</apiName><shortdesc>
	 Ermöglicht eine bessere Steuerung der Serialisierung der dynamischen Eigenschaften dynamischer Objekte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.net:IDynamicPropertyWriter</apiValueClassifier></apiValueDef><apiDesc>
	 Ermöglicht eine bessere Steuerung der Serialisierung der dynamischen Eigenschaften dynamischer Objekte. Wenn diese Eigenschaft den Wert <codeph>null</codeph> aufweist (Standardwert), werden dynamische Eigenschaften mit systemeigenem Code serialisiert, der alle dynamischen Eigenschaften schreibt, mit Ausnahme der Eigenschaften, die als Wert eine Funktion aufweisen.
     <p>Dieser Wert wird nur für Eigenschaften eines dynamischen Objekts aufgerufen (d. h. ein Objekt, das innerhalb einer dynamischen Klasse deklariert wurden) oder für Objekte die mithilfe des <codeph>new</codeph>-Operators deklariert wurden.</p>
	 
	 <p platform="actionscript">Sie können diese Eigenschaft verwenden, um Eigenschaften dynamischer Objekte aus der Serialisierung auszuschließen, um Eigenschaften dynamischer Objekte Werte zuzuweisen und um neue Eigenschaften für dynamische Objekte zu erstellen. Stellen Sie hierzu für die Eigenschaft auf ein Objekt ein, das die Schnittstelle „IDynamicPropertyWriter“ implementiert. Weitere Informationen hierzu finden Sie im Abschnitt zur Schnittstelle „IDynamicPropertyWriter“.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:Socket"><apiName>Socket</apiName><shortdesc>
 Die Socket-Klasse ermöglicht die Herstellung von Socketverbindungen mit Code sowie das Lesen und Schreiben von unformatierten Binärdaten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Socket-Klasse ermöglicht die Herstellung von Socketverbindungen mit Code sowie das Lesen und Schreiben von unformatierten Binärdaten. Sie ist vergleichbar mit „XMLSocket“, schreibt jedoch das Format der empfangenen oder übertragenen Daten nicht vor.
 
 <p>Die Socket-Klasse eignet sich gut für die Arbeit mit Servern, die Binärprotokolle verwenden.</p>
 
 <p>Um die Methoden der Socket-Klasse zu verwenden, verwenden Sie zuerst den Konstruktor <codeph>new Socket</codeph>, um ein Socket-Objekt zu erstellen.</p>
 
 <p>SWF-Dateien in der lokalen Dateisystem-Sandbox dürfen keine Sockets verwenden.</p>
      
  <p> Die <i>Socket-Richtliniendateien</i> auf dem Ziel-Host legen sowohl den Host fest, von dem SWF-Dateien Socket-Verbindungen herstellen können, als auch die Ports, für welche die Verbindungen erstellt werden. Die Sicherheitsanforderungen für Socket-Richtliniendateien wurden in den letzten Versionen von Flash Player verschärft. Adobe empfiehlt für alle Versionen von Flash Player die Verwendung von Socket-Richtliniendateien. In einigen Fällen ist eine Socket-Richtliniendatei unbedingt erforderlich. Deshalb sollten Sie beim Verwenden von XML-Socket-Objekten sicherstellen, dass der Ziel-Host ggf. eine Socket-Richtliniendatei bereitstellt. </p>
 
  <p>Die folgende Liste fasst die Anforderungen für Socket-Richtliniendateien für die verschiedenen Versionen von Flash Player zusammen:</p>
 
  <ul>
  
   <li> In Flash Player 9.0.124.0 und höher sind für Socket-Verbindungen Socket-Richtliniendateien erforderlich. Das heißt, dass eine Socket-Richtliniendatei für den Ziel-Host erforderlich ist, unabhängig von dem für die Verbindung ausgewählten Port. Sie ist sogar dann erforderlich, wenn Sie eine Verbindung zu einem Port auf dem gleichen Host herstellen, der die SWF-Dateien bereitstellt. </li>
 
   <li> Wenn Sie unter Flash Player Version 9.0.115.0 und früher eine Verbindung zu einer Portnummer kleiner als 1024 herstellen möchten, ist eine Socket-Richtliniendatei erforderlich. Das Gleiche gilt, wenn Sie eine Verbindung zu einem anderem Host herstellen möchten als dem, der die SWF-Dateien bereitstellt. </li>
 
  <li> Selbst wenn keine Socket-Richtliniendatei erforderlich ist, wird in Flash Player 9.0.115.0 während der Verwendung des Flash Debug Players eine Warnung angezeigt, wenn der Ziel-Host keine Socket-Richtliniendatei bereitstellt. </li>
 
  </ul>
 
 <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
  
 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
 <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
 </ul>
 
 </apiDesc><example conref="examples\SocketExample.as"> Im folgenden Beispiel werden Socket-Daten gelesen und geschrieben sowie die bei Socket-Ereignissen übertragenen Informationen ausgegeben. Wichtige Beispielauszüge:
 <ol>
    <li>Der Konstruktor erstellt eine <codeph>CustomSocket</codeph>-Instanz mit dem Namen <codeph>socket</codeph> und übergibt den Hostnamen <codeph>localhost</codeph> und Port 80 als Argumente. Da <codeph>CustomSocket</codeph> Socket erweitert, ruft <codeph>super()</codeph> den Konstruktor des Sockets auf.</li>
    <li>Danach wird die Methode <codeph>configureListeners()</codeph> aufgerufen, die Listener für Socket-Ereignisse hinzufügt.</li>
      <li>Zum Schluss wird die Socket-Methode <codeph>connect()</codeph> mit <codeph>localhost</codeph> als Hostname und 80 als Portnummer aufgerufen.</li>
 </ol>
 
 <p> <b>Hinweis:</b> Zur Ausführung des Beispiels muss in der Domäne, in der sich die SWF-Datei befindet (in diesem Beispiel <codeph>localhost</codeph>), ein Server ausgeführt werden, der Port 80 überwacht.</p>
<codeblock>

package {
    import flash.display.Sprite;

    public class SocketExample extends Sprite {

        public function SocketExample() {
            var socket:CustomSocket = new CustomSocket("localhost", 80);
        }
    }
}

import flash.errors.*;
import flash.events.*;
import flash.net.Socket;

class CustomSocket extends Socket {
    private var response:String;

    public function CustomSocket(host:String = null, port:uint = 0) {
        super();
        configureListeners();
        if (host &amp;&amp; port)  {
            super.connect(host, port);
        }
    }

    private function configureListeners():void {
        addEventListener(Event.CLOSE, closeHandler);
        addEventListener(Event.CONNECT, connectHandler);
        addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);
    }

    private function writeln(str:String):void {
        str += "\n";
        try {
            writeUTFBytes(str);
        }
        catch(e:IOError) {
            trace(e);
        }
    }

    private function sendRequest():void {
        trace("sendRequest");
        response = "";
        writeln("GET /");
        flush();
    }

    private function readResponse():void {
        var str:String = readUTFBytes(bytesAvailable);
        response += str;
    }

    private function closeHandler(event:Event):void {
        trace("closeHandler: " + event);
        trace(response.toString());
    }

    private function connectHandler(event:Event):void {
        trace("connectHandler: " + event);
        sendRequest();
    }

    private function ioErrorHandler(event:IOErrorEvent):void {
        trace("ioErrorHandler: " + event);
    }

    private function securityErrorHandler(event:SecurityErrorEvent):void {
        trace("securityErrorHandler: " + event);
    }

    private function socketDataHandler(event:ProgressEvent):void {
        trace("socketDataHandler: " + event);
        readResponse();
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.net:Socket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Wird ausgelöst, wenn mit einem Aufruf von Socket.connect() versucht wird, eine Verbindung zu einem Server außerhalb der Sicherheitssandbox des Aufrufers oder zu einem Port mit einer niedrigeren Nummer als 1024 herzustellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS check this info
 </internal></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn mit einem Aufruf von <codeph>Socket.connect()</codeph> versucht wird, eine Verbindung zu einem Server außerhalb der Sicherheitssandbox des Aufrufers oder zu einem Port mit einer niedrigeren Nummer als 1024 herzustellen.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>Socket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.ProgressEvent.SOCKET_DATA_socketData"><apiName>socketData</apiName><shortdesc>
 Wird ausgelöst, wenn ein Socket Daten empfangen hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.SOCKET_DATA</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Socket Daten empfangen hat. Für Ereignisse vom Typ <codeph>socketData</codeph> wird die Eigenschaft <codeph>ProgressEvent.bytesTotal</codeph> nicht verwendet. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Sende- oder Ladevorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Sende- oder Ladevorgang fehlschlägt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Wird ausgelöst, wenn der Server die Socketverbindung schließt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Server die Socketverbindung schließt. Das Ereignis <codeph>close</codeph> wird nur ausgelöst, wenn der Server die Verbindung schließt. Es wird nicht ausgelöst, wenn Sie die Methode <codeph>Socket.close()</codeph> aufrufen.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:Socket:Socket"><apiName>Socket</apiName><shortdesc>
    Erstellt ein neues Socket-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS determine if all above events are accurate, and which ones also apply
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Dieser Fehler tritt in SWF-Inhalt auf<ph platform="javascript">.</ph> <ph platform="actionscript"> aufgrund der folgenden Ursachen:</ph>
	 
     <ul platform="actionscript">
       <li>Über lokale Dateisystem-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können dies umgehen, indem Sie die entsprechende SWF-Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren. Diese Einschränkung gilt nicht für AIR-Anwendungsinhalt in der Sicherheitssandbox der Anwendung.</li>
	 
      <li>Sie können für eine Socketverbindung keinen Port mit einer höheren Nummer als 65535 angeben.</li>
    </ul>
	 
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein vollständig qualifizierter DNS-Domänenname oder eine IP-Adresse im Format <i>111.222.333.444</i>. In Flash Player 9.0.115.0 und AIR 1.0 und später können Sie IPv6-Adressen festlegen, z. B. rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]. Sie können auch <codeph>null</codeph> angeben, um eine Verbindung zum Hostserver herzustellen, auf dem die SWF-Datei gespeichert ist. Wenn die aufrufende SWF-Datei in einem Webbrowser ausgeführt wird, muss sich <codeph>host</codeph> in derselben Domäne befinden wie die SWF-Datei.
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die zur Herstellung einer Verbindung verwendete TCP-Portnummer auf dem Ziel-Host. In Flash Player 9.0.124.0 und späteren Versionen muss der Ziel-Host eine Socket-Richtliniendatei bereitstellen, die festlegt, dass Socket-Verbindungen zum festgelegten Port vom Host zugelassen sind, der die SWF-Datei bereitstellt. In älteren Versionen von Flash Player ist eine Socket-Richtliniendatei nur erforderlich, wenn Sie eine Verbindung zu einer Portnummer kleiner 1024 herstellen möchten oder wenn Sie eine Verbindung mit einem Host herstellen möchten, der nicht der gleiche ist, der auch die SWF-Datei bereitstellt.
    
    
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Erstellt ein neues Socket-Objekt. Wenn keine Parameter angegeben werden, wird ein Socket mit getrennter Verbindung erstellt. Wenn Parameter angegeben werden, wird versucht, eine Verbindung zu dem angegebenen Host und Port herzustellen.
    
    <p><b>Hinweis:</b> Es wird unbedingt empfohlen, das Konstruktor-Formular <b>ohne Parameter</b> zu verwenden, danach die Ereignis-Listener hinzuzufügen und danach die <codeph>connect</codeph>-Methode mit <codeph>host</codeph>- und <codeph>port</codeph>-Parametern aufzurufen. Diese Abfolge stellt sicher, dass alle Ereignis-Listener ordnungsgemäß funktionieren.</p>
    
    </apiDesc></apiConstructorDetail><adobeApiEvent id="flash.net:Socket:Socket_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den die Verbindung fehlschlägt.
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den die Verbindung fehlschlägt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc><ph platform="javascript">Dieser Fehler tritt in SWF-Inhalt auf.</ph> <ph platform="actionscript"> Wird ausgelöst, wenn beim Aufrufen von <codeph>Socket.connect()</codeph> versucht wird, eine Verbindung zu einem Server herzustellen, der keine Socket-Richtliniendatei bereitstellt, bzw. zu einem Server, dessen Richtliniendatei dem aufrufenden Host keinen Zugriff auf den angegebenen Port gewährt. Weitere Informationen zu Socket-Richtliniendateien finden Sie im Kapitel „Flash Player-Sicherheit“ in <i>Programmieren mit ActionScript 3.0</i>.</ph>
	 
    </apiDesc></adobeApiEventDetail><shortdesc>Dieser Fehler tritt in SWF-Inhalt auf. Wird ausgelöst, wenn ein Aufruf an Socket.connect() versucht, eine Verbindung mit einem Server herzustellen, der entweder keine Socket-Richtliniendatei bereitstellt oder dessen Richtliniendatei dem aufrufenden Host keinen Zugriff auf den festgelegten Port erlaubt.</shortdesc></adobeApiEvent></apiConstructor><apiOperation id="flash.net:Socket:close"><apiName>close</apiName><shortdesc>
     Schließt den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der Socket konnte nicht geschlossen werden, oder der Socket war nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Schließt den Socket. Nach dem Aufruf der Methode <codeph>close()</codeph> können keine Daten mehr gelesen oder geschrieben werden.
     
     <p>Das Ereignis <codeph>close</codeph> wird nur ausgelöst, wenn der Server die Verbindung schließt. Es wird nicht ausgelöst, wenn Sie die Methode <codeph>close()</codeph> aufrufen.</p>
     
     <p>Sie können das Socket-Objekt wieder verwenden, indem Sie die Methode <codeph>connect()</codeph> erneut aufrufen.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:connect"><apiName>connect</apiName><shortdesc>
     Stellt eine Socketverbindung mit dem angegebenen Host und Port her.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS compare this entire description with XMLSocket.connect() and make consistent
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es wurde kein Host angegeben, und die Verbindung konnte nicht erstellt werden.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler tritt in SWF-Inhalt auf<ph platform="javascript">.</ph> <ph platform="actionscript"> aufgrund der folgenden Ursachen:</ph>
	 
          <ul platform="actionscript">
              <li>Über lokale nicht vertrauenswürdige SWF-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können diese Beschränkung umgehen, indem Sie die Datei neu als lokal mit Netzwerk oder als vertrauenswürdig klassifizieren.</li>
               <li>Sie können für eine Socketverbindung keinen Port mit einer höheren Nummer als 65535 angeben.</li>
           <li>Auf der HTML-Seite, die das SWF-Objekt enthält, ist der <codeph>allowNetworking</codeph>-Parameter der Tags <codeph>object</codeph> und <codeph>embed</codeph> auf <codeph>"none"</codeph> gesetzt.</li>
	 
          </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name oder die IP-Adresse des Hosts, zu dem eine Verbindung hergestellt werden soll. Wenn kein Host angegeben wurde, wird der Host der aufrufenden Datei verwendet. Verwenden Sie in diesem Fall einen Ereignis-Listener, um zu ermitteln, ob die Verbindung erfolgreich hergestellt werden konnte.
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Portnummer für die herzustellende Verbindung.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Stellt eine Socketverbindung mit dem angegebenen Host und Port her. Wenn die Verbindung unmittelbar fehlschlägt, wird ein Ereignis oder ein Ausnahmefehler ausgelöst: Ein Fehlerereignis wird ausgelöst, wenn ein Host angegeben wurde, ein Ausnahmefehler wird ausgelöst, wenn kein Host angegeben wurde. Andernfalls wird der Verbindungsstatus durch ein Ereignis ausgegeben. Wenn bereits eine Socketverbindung besteht, wird die vorhandene Verbindung zunächst geschlossen.
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:Socket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde.
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn eine Netzwerkverbindung hergestellt wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Host angegeben wurde und ein I/O-Fehler auftritt, durch den die Verbindung fehlschlägt.
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Host angegeben wurde und ein I/O-Fehler auftritt, durch den die Verbindung fehlschlägt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn beim Aufrufen von <codeph>Socket.connect()</codeph> versucht wird, eine Verbindung zu einem Server herzustellen, der keine Socket-Richtliniendatei bereitstellt, bzw. zu einem Server, dessen Richtliniendatei dem aufrufenden Host keinen Zugriff auf den angegebenen Port gewährt. Weitere Informationen finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Aufruf an Socket.connect() versucht, eine Verbindung mit einem Server herzustellen, der entweder keine Socket-Richtliniendatei bereitstellt oder dessen Richtliniendatei dem aufrufenden Host keinen Zugriff auf den festgelegten Port erlaubt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:Socket:flush"><apiName>flush</apiName><shortdesc>
     Gibt alle Daten im Ausgabepuffer des Sockets aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.       
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Gibt alle Daten im Ausgabepuffer des Sockets aus. Die mit <codeph>write</codeph>-Methoden geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     Liest einen booleschen Wert aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der Wert ist <codeph>true</codeph>, wenn das Byte ungleich 0 ist, oder andernfalls <codeph>false</codeph>.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest einen booleschen Wert aus dem Socket. Nach dem Lesen eines einzelnen Byte gibt die Methode <codeph>true</codeph> zurück, wenn das Byte ungleich null ist, andernfalls <codeph>false</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readByte"><apiName>readByte</apiName><shortdesc>
     Liest ein Byte mit Vorzeichen aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Wert im Bereich von -128 bis 127.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest ein Byte mit Vorzeichen aus dem Socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBytes"><apiName>readBytes</apiName><shortdesc>
     Liest die Anzahl der im Parameter „length“ angegebenen Datenbyte aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Das ByteArray-Objekt, in das die Daten gelesen werden.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Offset im Bytearray, ab dem das Lesen der Daten beginnt.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Anzahl der zu lesenden Byte. Der Standardwert 0 bewirkt, dass alle verfügbaren Daten gelesen werden.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Liest die Anzahl der im Parameter <codeph>length</codeph> angegebenen Datenbyte aus dem Socket. Die Byte werden in das angegebene Bytearray gelesen, wobei an der mit <codeph>offset</codeph> angegebenen Position begonnen wird.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readDouble"><apiName>readDouble</apiName><shortdesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit.
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit aus dem Socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readFloat"><apiName>readFloat</apiName><shortdesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit.
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit aus dem Socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readInt"><apiName>readInt</apiName><shortdesc>
     Liest eine 32-Bit-Ganzzahl mit Vorzeichen aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Wert im Bereich von -2147483648 bis 2147483647.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 32-Bit-Ganzzahl mit Vorzeichen aus dem Socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     Liest einen Multibyte-String unter Verwendung des angegebenen Zeichensatzes aus dem Bytestream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein UTF-8-kodierter String.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Die Anzahl der aus dem Bytestream zu lesenden Byte.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, der den zum Interpretieren der Byte zu verwendenden Zeichensatz angibt. Mögliche Zeichensatz-Strings sind u. a. <codeph>"shift_jis"</codeph>, <codeph>"CN-GB"</codeph> und <codeph>"iso-8859-1"</codeph>. Eine vollständige Liste finden Sie unter <xref href="../../charset-codes.html">Unterstützte Zeichensätze</xref>.
     
     <p><b>Hinweis:</b> Wird der Wert des <codeph>charSet</codeph>-Parameters vom aktuellen System nicht erkannt, verwendet die Anwendung die Standard-Codepage des Systems als Zeichensatz. Beispielsweise kann ein Wert des Parameters <codeph>charSet</codeph> wie bei <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph>, wo <codeph>01</codeph> anstelle von <codeph>1</codeph> eingesetzt wird, auf Ihrem Entwicklungsrechner funktionieren, aber auf keinem anderen Rechner. Auf anderen Rechnern greift die Anwendung auf die Standard-Codepage des Systems zurück.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Liest einen Multibyte-String unter Verwendung des angegebenen Zeichensatzes aus dem Bytestream.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readObject"><apiName>readObject</apiName><shortdesc>
     Liest ein Objekt aus dem Socket, das im serialisierten AMF-Format kodiert ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das deserialisierte Objekt.
     
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     Liest ein Objekt aus dem Socket, das im serialisierten AMF-Format kodiert ist.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:readShort"><apiName>readShort</apiName><shortdesc>
     Liest eine 16-Bit-Ganzzahl mit Vorzeichen aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Wert im Bereich von -32768 bis 32767.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 16-Bit-Ganzzahl mit Vorzeichen aus dem Socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTF"><apiName>readUTF</apiName><shortdesc>
     Liest einen UTF-8-String aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein UTF-8-String.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest einen UTF-8-String aus dem Socket. Es wird davon ausgegangen, dass dem String eine short-Ganzzahl ohne Vorzeichen mit der Länge in Byte vorangestellt ist.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     Liest die mit dem Parameter „length“ angegebene Anzahl UTF-8-Byte aus dem Socket und gibt einen String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein UTF-8-String.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Die Anzahl der zu lesenden Byte.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Liest die mit dem Parameter <codeph>length</codeph> angegebene Anzahl UTF-8-Byte aus dem Socket und gibt einen String zurück.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     Liest ein Byte ohne Vorzeichen aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Wert im Bereich von 0 bis 255.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest ein Byte ohne Vorzeichen aus dem Socket.  
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     Liest eine 32-Bit-Ganzzahl ohne Vorzeichen aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Wert im Bereich von 0 bis 4294967295.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 32-Bit-Ganzzahl ohne Vorzeichen aus dem Socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     Liest eine 16-Bit-Ganzzahl ohne Vorzeichen aus dem Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Wert im Bereich von 0 bis 65535.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 16-Bit-Ganzzahl ohne Vorzeichen aus dem Socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
     Schreibt einen booleschen Wert in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Der Wert, der in den Socket geschrieben werden soll: 1 (<codeph>true</codeph>) oder 0 (<codeph>false</codeph>).
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt einen booleschen Wert in den Socket. Mit dieser Methode wird ein einzelnes Byte mit dem Wert 1 (<codeph>true</codeph>) oder 0 (<codeph>false</codeph>) geschrieben.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeByte"><apiName>writeByte</apiName><shortdesc>
     Schreibt ein Byte in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Wert, der in den Socket geschrieben werden soll. Die unteren 8 Bit des Werts werden verwendet, die oberen 24 Bit werden ignoriert.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt ein Byte in den Socket.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeBytes"><apiName>writeBytes</apiName><shortdesc>
     Schreibt eine Anzahl an Byte aus dem angegebenen Bytearray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Das ByteArray-Objekt, aus dem die Daten gelesen werden.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der auf null basierende Offset im ByteArray-Objekt <codeph>bytes</codeph>, ab dem der Schreibvorgang beginnt.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Anzahl der zu schreibenden Byte. Beim Standardwert 0 wird der gesamte Pufferinhalt ab dem durch den Parameter <codeph>offset</codeph> angegebenen Byte geschrieben.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt eine Anzahl an Byte aus dem angegebenen Bytearray. Der Schreibvorgang beginnt an der mit <codeph>offset</codeph> angegebenen Position.
     
     <p>Wenn Sie den Parameter <codeph>length</codeph> nicht angeben, wird der Standardwert 0 verwendet, sodass alle Daten beginnend ab der mit <codeph>offset</codeph> festgelegten Position geschrieben werden.</p>
     
     <p>Wenn Sie auch den Parameter <codeph>offset</codeph> nicht angeben, wird der gesamte Pufferinhalt geschrieben.</p> 
      
     <p>Wenn sich <codeph>offset</codeph> bzw. <codeph>length</codeph> außerhalb des gültigen Bereichs befinden, werden sie auf den Anfang bzw. auf das Ende des <codeph>byte</codeph>-Arrays gesetzt.</p>
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeDouble"><apiName>writeDouble</apiName><shortdesc>
     Schreibt eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Wert, der in den Socket geschrieben werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit in den Socket.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeFloat"><apiName>writeFloat</apiName><shortdesc>
     Schreibt eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der Wert, der in den Socket geschrieben werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit in den Socket.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeInt"><apiName>writeInt</apiName><shortdesc>
     Schreibt eine 32-Bit-Ganzzahl mit Vorzeichen in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Wert, der in den Socket geschrieben werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt eine 32-Bit-Ganzzahl mit Vorzeichen in den Socket.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
     Schreibt einen Multibyte-String unter Verwendung des angegebenen Zeichensatzes aus dem Bytestream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.writeMultiByte, writeMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Stringwert, der geschrieben werden soll.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, der den zum Interpretieren der Byte zu verwendenden Zeichensatz angibt. Mögliche Zeichensatz-Strings sind u. a. <codeph>"shift_jis"</codeph>, <codeph>"CN-GB"</codeph> und <codeph>"iso-8859-1"</codeph>. Eine vollständige Liste finden Sie unter <xref href="../../charset-codes.html">Unterstützte Zeichensätze</xref>. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt einen Multibyte-String unter Verwendung des angegebenen Zeichensatzes aus dem Bytestream.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeObject"><apiName>writeObject</apiName><shortdesc>
     Schreibt ein Objekt im serialisierten AMF-Format in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Das zu serialisierende Objekt
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt ein Objekt im serialisierten AMF-Format in den Socket.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeShort"><apiName>writeShort</apiName><shortdesc>
     Schreibt eine 16-Bit-Ganzzahl in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Wert, der in den Socket geschrieben werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt eine 16-Bit-Ganzzahl in den Socket. Die Byte werden wie folgt geschrieben:
     
     <pre><codeph>(v >> 8) &amp; 0xff v &amp; 0xff</codeph></pre>
     
     <p>Die unteren 16 Bit des Parameters werden verwendet, die oberen 16 Bit werden ignoriert.</p>
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTF"><apiName>writeUTF</apiName><shortdesc>
     Schreibt die folgenden Daten in den Socket: Eine 16-Bit-Ganzzahl ohne Vorzeichen, die die Länge des angegebenen UTF-8-Strings in Byte angibt, gefolgt von dem eigentlichen String.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die Länge überschreitet 65535.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, der in den Socket geschrieben werden soll.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt die folgenden Daten in den Socket: Eine 16-Bit-Ganzzahl ohne Vorzeichen, die die Länge des angegebenen UTF-8-Strings in Byte angibt, gefolgt von dem eigentlichen String.
     
     <p>Bevor der String geschrieben wird, berechnet die Methode die Anzahl der Byte, die zur Darstellung aller Zeichen des Strings benötigt werden.</p>
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
     Schreibt einen UTF-8-String in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, der in den Socket geschrieben werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt einen UTF-8-String in den Socket. 
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
     Schreibt eine 32-Bit-Ganzzahl ohne Vorzeichen in den Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ein I/O-Fehler ist im Socket aufgetreten, oder der Socket ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Der Wert, der in den Socket geschrieben werden soll.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt eine 32-Bit-Ganzzahl ohne Vorzeichen in den Socket.
     
     <p><b>Hinweis:</b> Die mit dieser Methode geschriebenen Daten werden nicht unmittelbar übertragen, sondern verbleiben in der Warteschlange, bis die Methode <codeph>flush()</codeph> aufgerufen wird.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiValue id="flash.net:Socket:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     Die Byteanzahl der zum Lesen verfügbaren Daten im Eingabepuffer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Die Byteanzahl der zum Lesen verfügbaren Daten im Eingabepuffer.
     
     <p>In Ihrem Code muss <codeph>bytesAvailable</codeph> aufgerufen werden, um sicherzustellen, dass genügend Daten verfügbar sind, bevor diese mit einer der <codeph>read</codeph>-Methoden gelesen werden.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:connected:get"><apiName>connected</apiName><shortdesc>
     Gibt an, ob dieses Socket-Objekt zurzeit verbunden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob dieses Socket-Objekt zurzeit verbunden ist. Beim Aufruf dieser Eigenschaft wird der Wert <codeph>true</codeph> zurückgegeben, wenn der Socket verbunden ist, oder andernfalls <codeph>false</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:endian:get"><apiName>endian</apiName><shortdesc>
     Gibt die Bytereihenfolge für die Daten an. Mögliche Werte sind Konstanten der flash.utils.Endian-Klasse, Endian.BIG_ENDIAN oder Endian.LITTLE_ENDIAN.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     Gibt die Bytereihenfolge für die Daten an. Mögliche Werte sind Konstanten der flash.utils.Endian-Klasse, <codeph>Endian.BIG_ENDIAN</codeph> oder <codeph>Endian.LITTLE_ENDIAN</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Steuert die beim Schreiben oder Lesen eines Objekts verwendete AMF-Version.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Steuert die beim Schreiben oder Lesen eines Objekts verwendete AMF-Version.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding-Klasse</linktext></link><link href="flash.net.xml#Socket/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#Socket/writeObject()"><linktext>writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:timeout:set"><apiName>timeout</apiName><shortdesc>
     Gibt die Anzahl der Millisekunden an, die auf eine Verbindung gewartet werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Gibt die Anzahl der Millisekunden an, die auf eine Verbindung gewartet werden soll.
     
     <p>Wenn die Verbindung nicht innerhalb der festgelegten Zeit hergestellt werden kann, schlägt der Verbindungsaufbau fehl. Der Standardwert ist 20.000 (zwanzig Sekunden).</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoader"><apiName>URLLoader</apiName><shortdesc>
 Die URLLoader-Klasse lädt die Daten von einer URL als Text, Binärdaten oder URL-kodierte Variablen herunter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die URLLoader-Klasse lädt die Daten von einer URL als Text, Binärdaten oder URL-kodierte Variablen herunter. Sie eignet sich gut zum Download von Textdateien, XML-Daten oder anderen Informationen, die in einer dynamischen, datengesteuerten Anwendung verwendet werden sollen.
 
 <p>Ein URLLoader-Objekt lädt erst alle Daten von einer URL herunter und macht sie dann für Code in den Anwendungen verfügbar. Das Objekt sendet Benachrichtigungen über den Fortschritt des Download-Vorgangs, den Sie mit den Eigenschaften <codeph>bytesLoaded</codeph> und <codeph>bytesTotal</codeph> und mit ausgelösten Ereignissen verfolgen können.</p>
 
 <p>Wenn sehr große Videodateien wie z. B. FLV-Dateien geladen werden, können Fehler aufgrund von unzureichendem Speicher zurückgegeben werden.
 </p>
 
 
 
 <p>Wenn Sie diese Klasse <ph platform="actionscript">in Flash Player und </ph>in AIR-Anwendungsinhalten in anderen Sicherheitssandboxen als in der Sicherheitssandbox der Anwendung verwenden, sollten Sie folgendes Sicherheitsmodell in Betracht ziehen:</p>
 
 <ul>
 <li>Eine SWF-Datei innerhalb der lokalen Dateisystem-Sandbox kann keine Daten aus einer Ressource in der Network-Sandbox laden bzw. keine Daten für diese Ressource bereitstellen. </li>
 
 <li> Standardmäßig müssen die aufrufende SWF-Datei und die von Ihnen geladene URL in genau der gleichen Domäne sein. Eine SWF-Datei unter www.adobe.com kann beispielsweise nur Daten laden, die sich ebenfalls unter www.adobe.com befinden. Legen Sie eine URL-Richtliniendatei auf dem Server ab, der die Daten hostet, um Daten aus einer anderen Domäne zu laden.</li>
 </ul>
  
 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
 <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
   <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
 
 </ul>
 
 
 </apiDesc><example conref="examples\URLLoaderExample.as"> Im folgenden Beispiel werden die in einer lokalen Textdatei gefundenen Daten geladen und angezeigt. Des Weiteren werden Ereignisverarbeitungsinformationen erfasst.
 
 <p><b>Hinweis:</b> Legen Sie zur Ausführung des Beispiels eine Datei mit dem Namen „urlLoaderExample.txt“ in dem Verzeichnis ab, in dem sich die SWF-Datei befindet. Diese Datei darf nur die folgende Textzeile enthalten: <codeph>answer=42&amp;question=unknown</codeph>
 </p>
 <p>Der Beispielcode führt folgende Schritte aus:</p>
 <ol>
    <li>Die Konstruktorfunktion erstellt eine URLLoader-Instanz mit dem Namen <codeph>loader</codeph> und eine URLRequest-Instanz mit dem Namen <codeph>request</codeph>, wobei es sich um den Standort und den Namen der zu ladenden Datei handelt.</li>
    <li>Das Objekt <codeph>loader</codeph> wird an die Methode <codeph>configureListeners()</codeph> übergeben, die für jedes unterstützte URLLoader-Ereignis Listener hinzufügt.</li>
    <li>Dann wird das Objekt <codeph>request</codeph> an die Methode <codeph>loader.load()</codeph> übergeben, die die Textdatei lädt.</li>
      <li>Nach Abschluss des Ladevorgangs wird das <codeph>Event.COMPLETE</codeph>-Ereignis ausgelöst, das wiederum die Methode <codeph>completeHandler()</codeph> auslöst. Die Methode <codeph>completeHandler()</codeph> erstellt ein URLVariables-Objekt aus dem aus der Datei geladenen Text. Das URLVariables-Objekt konvertiert URL-kodierte Name/Wert-Paare in ActionScript-Eigenschaften, um die Bearbeitung der geladenen Daten zu vereinfachen.</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderExample extends Sprite {
        public function URLLoaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("urlLoaderExample.txt");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
    
            var vars:URLVariables = new URLVariables(loader.data);
            trace("The answer is " + vars.answer);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 Wird ausgelöst, wenn ein Aufruf der load()-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Aufruf der <codeph>load()</codeph>-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Wird ausgelöst, wenn ein Aufruf von URLLoader.load() versucht, über HTTP auf Daten zuzugreifen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Aufruf von <codeph>URLLoader.load()</codeph> versucht, über HTTP auf Daten zuzugreifen. <ph platform="actionscript">Bei Inhalt, der in Flash Player ausgeführt wird, wird dieses Ereignis nur ausgelöst, wenn die aktuelle Flash Player-Umgebung den Statuscode für die Anforderung erkennen und zurückgeben kann. (Diese Informationen können in einigen Browser-Umgebungen möglicherweise nicht bereitgestellt werden.)</ph> Beachten Sie, dass das Ereignis <codeph>httpStatus</codeph> (falls vorhanden) vor (und zusätzlich zu) jedem <codeph>complete</codeph>- oder <codeph>error</codeph>-Ereignis gesendet wird.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Wird ausgelöst, wenn ein URLLoader.load()-Aufruf versucht, Daten von einem Server außerhalb der Sicherheitssandbox zu laden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein <codeph>URLLoader.load()</codeph>-Aufruf versucht, Daten von einem Server außerhalb der Sicherheitssandbox zu laden. Wird auch aufgelöst, wenn bei einem <codeph>URLLoader.load()</codeph>-Aufruf versucht wird, eine SWZ-Datei zu laden und das Zertifikat ungültig ist oder der Digest-String nicht mit der Komponente übereinstimmt.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird ausgelöst, wenn bei einem URLLoader.load()-Aufruf ein schwerwiegender Fehler auftritt und der Download abgebrochen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn bei einem <codeph>URLLoader.load()</codeph>-Aufruf ein schwerwiegender Fehler auftritt und der Download abgebrochen wird.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden.
 
 <p>Beachten Sie, dass Sie bei Verwendung eines URLLoader-Objekts erst dann auf die Daten zugreifen können, wenn der Ladevorgang abgeschlossen ist. In diesem Fall dient das progress-Ereignis lediglich zur Benachrichtigung über den Fortschritt des Download-Vorgangs. Verwenden Sie ein URLStream-Objekt, um vor Abschluss des Ladevorgangs auf die Daten zuzugreifen. </p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Wird ausgelöst, nachdem alle empfangenen Daten dekodiert und in der Eigenschaft „data“ des URLLoader-Objekts abgelegt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, nachdem alle empfangenen Daten dekodiert und in der Eigenschaft <codeph>data</codeph> des URLLoader-Objekts abgelegt wurden. Nach der Auslösung dieses Ereignisses können Sie auf die empfangenen Daten zugreifen.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Wird ausgelöst, wenn der Download-Vorgang nach dem Aufruf der Methode URLLoader.load() gestartet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Download-Vorgang nach dem Aufruf der Methode <codeph>URLLoader.load()</codeph> gestartet wird. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:URLLoader:URLLoader"><apiName>URLLoader</apiName><shortdesc>
	 Erstellt ein URLLoader-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein URLRequest-Objekt, das die herunterzuladende URL angibt. Ohne diesen Parameter kann der Ladevorgang nicht gestartet werden. Wenn dieser Parameter angegeben wird, beginnt der Ladevorgang unmittelbar (weitere Informationen finden Sie im Abschnitt zu <codeph>load</codeph>).
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein URLLoader-Objekt.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:URLLoader:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	
	Registriert ein Ereignis-Listener-Objekt bei einem EventDispatcher-Objekt, sodass der Listener über ein Ereignis benachrichtigt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Typ des Ereignisses.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Listener-Funktion, die das Ereignis verarbeitet. Diese Funktion muss, wie das nachfolgende Beispiel zeigt, ein Ereignisobjekt als einzigen Parameter akzeptieren und keinen<ph platform="actionscript"> Wert zurückgeben: </ph> <ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Der Name der Funktion ist beliebig.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Dieser Parameter gilt für Anzeigeobjekte in der ActionScript 3.0-Anzeigelistenarchitektur, die von SWF-Material verwendet wird.</ph> <ph platform="actionscript">Legt fest, ob der Listener in der Aufnahmephase oder in der Ziel- und Bubbling-Phase arbeitet. Ist <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt, so verarbeitet der Listener das Ereignis nur während der Aufnahmephase und nicht während der Ziel- oder Bubbling-Phase. Hat <codeph>useCapture</codeph> hingegen den Wert <codeph>false</codeph>, verarbeitet der Listener das Ereignis nur während der Ziel- oder Bubbing-Phase. Um auf das Ereignis in allen drei Phasen zu warten, rufen Sie <codeph>addEventListener()</codeph> zweimal auf; einmal ist <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt, und beim zweiten Mal hat <codeph>useCapture</codeph> den Wert <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Prioritätsstufe des Ereignis-Listeners. Die Priorität wird durch eine vorzeichenbehaftete 32-Bit-Ganzzahl zugewiesen. Je höher die Zahl, desto höher die Priorität. Alle Listener mit der Priorität <i>n</i> werden vor Listenern mit der Priorität <i>n</i> -1 verarbeitet. Wenn zwei oder mehr Listener die gleiche Priorität aufweisen, werden sie in der Reihenfolge verarbeitet, in der sie hinzugefügt wurden. Die Standardpriorität ist 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Legt fest, ob der Verweis auf den Listener stark oder schwach ist. Ein starker Verweis (der Standard) verhindert, dass der Listener von einem Garbage Collector entfernt wird. Ein schwacher Verweis hingegen nicht. <p>Funktionen von Mitgliedern auf Klassenebene werden nicht vom Garbagekollektor entfernt. Daher können Sie <codeph>useWeakReference</codeph> für Mitgliedsfunktionen auf Klassenebene auf <codeph>true</codeph> setzen, ohne dass sie vom Garbagekollektor entfernt werden. Wenn Sie <codeph>useWeakReference</codeph> auf <codeph>true</codeph> setzen bei einem Listener, der eine verschachtelte innere Funktion ist, wird die Funktion vom Garbagekollektor entfernt. Indem Sie Verweise auf die innere Funktion erstellen (d. h sie in einer anderen Variable speichern), umgehen Sie die Garbage Collection, sodass die Funktion permanent gespeichert bleibt.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	
	Registriert ein Ereignis-Listener-Objekt bei einem EventDispatcher-Objekt, sodass der Listener über ein Ereignis benachrichtigt wird. <ph platform="actionscript">Sie können Ereignis-Listener bei allen Knoten in der Anzeigeliste für eine bestimmte Art von Ereignis, Phase oder Priorität registrieren.</ph>
	
	<p platform="javascript">JavaScript-Code in der AIR-Laufzeitumgebung verwendet diese Methode, um Ereignis-Listener für Ereignisse, die von den AIR-APIs definiert werden, zu registrieren. Bei anderen JavaScript-Ereignissen (wie z. B. dem <codeph>onload</codeph>-Ereignis des DOM-<codeph>body</codeph>-Objekts) können Sie Standardtechniken für Ereignisprozeduren verwenden, wie bei Inhalten, die im Browser ausgeführt werden.</p>
	
	<p>Nachdem Sie einen Ereignis-Listener erfolgreich registriert haben, können Sie seine Priorität nicht durch weitere Aufrufe von <codeph>addEventListener()</codeph> ändern. Um die Priorität eines Listeners zu ändern, müssen Sie zunächst <codeph>removeListener()</codeph> aufrufen. Anschließend können Sie den Listener mit der neuen Prioritätsstufe erneut aufrufen. </p>
	
	<p>Nach der Registrierung des Listeners haben nachfolgende Aufrufe von <codeph>addEventListener()</codeph> mit einem anderen <codeph>type</codeph>- oder <codeph>useCapture</codeph>-Wert eine separate Listener-Registrierung zur Folge. <ph platform="actionscript">Wenn Sie beispielsweise zuerst einen Listener registrieren, für den <codeph>useCapture</codeph> auf <codeph>true</codeph> gesetzt ist, wird dieser nur während der Aufnahmephase aktiv sein. Wenn Sie <codeph>addEventListener()</codeph> für dasselbe Listener-Objekt erneut aufrufen, diesmal aber <codeph>useCapture</codeph> auf <codeph>false</codeph> gesetzt ist, werden zwei separate Listener angelegt: einer, der während der Aufnahmephase aktiv ist und ein zweiter, der während der Ziel- und Bubbling-Phase aktiv ist.</ph>
	</p>
	
	<p platform="actionscript">Sie können einen Ereignis-Listener nicht nur für die Ziel- oder Bubbling-Phase registrieren. Die beiden Phasen hängen während der Registrierung immer zusammen, da Bubbling nur für übergeordnete Elemente des Zielknotens gilt.</p>
	
	<p>Wenn Sie einen Ereignis-Listener nicht mehr brauchen, entfernen sie ihn, indem Sie <codeph>removeEventListener()</codeph> aufrufen. Andernfalls könnte es zu Speicherproblemen kommen. Ereignis-Listener werden nicht automatisch aus dem Speicher entfernt, da der Garbage Collector den Listener nicht entfernt, solange das auslösende Objekt vorhanden ist (sofern der <codeph>useWeakReference</codeph>-Parameter auf <codeph>true</codeph> gesetzt ist).</p>
		
	<p>Beim Kopieren einer EventDispatcher-Instanz werden zugewiesene Ereignis-Listener nicht kopiert. (Wenn ein neu angelegter Knoten einen Ereignis-Listener benötigt, müssen Sie den Listener nach dem Erstellen des Knotens zuweisen.) Wenn Sie jedoch eine EventDispatcher-Instanz verschieben, werden zugewiesene Ereignis-Listener ebenfalls verschoben.</p>
	
	
	<p platform="actionscript">Wenn der Ereignis-Listener bei einem Knoten registriert wird, während mit diesem Knoten ein Ereignis durchgeführt wird, so wird der Ereignis-Listener während der aktuellen Phase nicht ausgelöst, kann aber während einer späteren Phase im Ereignisablauf ausgelöst werden, etwa während der Bubbling-Phase.</p>
	
	<p platform="actionscript">Wird ein Ereignis-Listener von einem Knoten entfernt, während mit dem Knoten ein Ereignis durchgeführt wird, so wird er von den aktuellen Aktionen immer noch ausgelöst. Nachdem er entfernt worden ist, wird der Ereignis-Listener nicht wieder aufgerufen (es sei denn er wird für spätere Verarbeitungsvorgänge erneut aufgerufen). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:close"><apiName>close</apiName><shortdesc>
	 Schließt den laufenden Ladevorgang.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Schließt den laufenden Ladevorgang. Alle laufenden Ladevorgänge werden sofort beendet. Wenn kein URL-Stream ausgeführt wird, wird ein Fehler ausgegeben.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:load"><apiName>load</apiName><shortdesc>
	 Sendet und lädt Daten von der angegebenen URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Bestimmte nicht zulässige HTTP-Anforderungsheader sind möglicherweise in <codeph>URLRequest.requestHeader</codeph>-Objekten nicht enthalten. Weitere Informationen finden Sie in der Beschreibung der URLRequestHeader-Klasse.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann folgende Ursachen haben: 1) <ph platform="actionscript">Flash Player oder </ph>AIR kann den <codeph>URLRequest.data</codeph>-Parameter nicht von UTF8 in MBCS konvertieren. Dieser Fehler trifft zu, wenn das an <codeph>load()</codeph> übergebene URLRequest-Objekt auf die Ausführung eines <codeph>GET</codeph>-Vorgangs eingestellt ist und wenn <codeph>System.useCodePage</codeph> auf <codeph>true</codeph> gesetzt ist. 2) <ph platform="actionscript">Flash Player oder</ph> AIR kann·<codeph>POST</codeph> keinen Speicher zuweisen. Dieser Fehler trifft zu, wenn das an <codeph>load</codeph> übergebene URLRequest-Objekt auf die Ausführung eines <codeph>POST</codeph>-Vorgangs eingestellt ist.
	 
	 </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Über lokale nicht vertrauenswürdige Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können dies umgehen, indem Sie die entsprechende Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Der Wert des request-Parameters oder der Eigenschaft <codeph>URLRequest.url</codeph> des übergebenen URLRequest-Objekts ist <codeph>null</codeph>.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Ein URLRequest-Objekt, das die herunterzuladende URL angibt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sendet und lädt Daten von der angegebenen URL. Die Daten können als Text, unformatierte Binärdaten oder URL-kodierte Variablen empfangen werden, je nachdem, welchen Wert Sie für die Eigenschaft <codeph>dataFormat</codeph> festlegen. Beachten Sie, dass „Text“ der Standardwert der Eigenschaft <codeph>dataFormat</codeph> ist. Wenn Sie Daten an die angegebene URL senden möchten, können Sie die Eigenschaft <codeph>data</codeph> im URLRequest-Objekt festlegen.
	 
	 <p><b>Hinweis:</b> Enthält eine geladene Datei Nicht-ASCII-Zeichen (wie z. B. in vielen Sprachen außerhalb des englischen Sprachraums), wird empfohlen, dass Sie die Datei im Format UTF-8 oder UTF-16 und nicht in einem Unicode-fremden Format (z. B. ASCII) speichern.</p>
	 
	 <p> Eine SWF-Datei innerhalb der lokalen Dateisystem-Sandbox kann keine Daten aus einer Ressource in der Network-Sandbox laden bzw. keine Daten für diese Ressource bereitstellen.</p> 
	  
	 <p> Standardmäßig müssen die aufrufende SWF-Datei und die von Ihnen geladene URL in genau der gleichen Domäne sein. Eine SWF-Datei unter www.adobe.com kann beispielsweise nur Daten laden, die sich ebenfalls unter www.adobe.com befinden. Legen Sie eine URL-Richtliniendatei auf dem Server ab, der die Daten hostet, um Daten aus einer anderen Domäne zu laden.</p>
	 
      <p>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
     
     <p> Wenn Sie in Flash Player 10 oder höher einen Multipart-Content-Type verwenden (z. B. „multipart/form-data“), der einen Upload enthält (gekennzeichnet durch einen „filename“-Parameter in einem „content-disposition“-Header innerhalb des POST-Body), so unterliegt die POST-Methode den Sicherheitsregeln für Uploads:</p>
	 <ul>
	 <li>Der POST-Vorgang muss als Reaktion auf eine durch den Benutzer initiierte Aktion, z. B. Mausklick oder Tastendruck, erfolgen.</li>
	 <li>Ist die POST-Methode domänenübergreifend (das POST-Ziel befindet sich auf einem anderen Server als die SWF-Datei, die die POST-Anforderung sendet), so muss der Zielserver eine URL-Richtliniendatei bereitstellen, die den domänenübergreifenden Zugriff erlaubt.</li>
	 </ul>
     <p>Für alle mehrteiligen Content-Typen muss ebenfalls die Syntax nach Standard RFC2046 gültig sein. Scheint die Syntax ungültig zu sein, so unterliegt die POST-Methode den Sicherheitsregeln für Uploads.</p>
     
	 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
	 
     <ul>
     
     
	 <li>Der Abschnitt „Understanding AIR Security“ des Kapitels „Getting started with Adobe AIR“ im Handbuch <i>Developing AIR Applications</i>.</li>
	 
	 <li>Das <xref href="http://www.adobe.com/go/fp9_0_security" scope="external">Flash Player 9-Whitepaper zum Thema Sicherheit</xref></li>
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
       <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     
     </ul>
	 
	 </apiDesc><example conref="examples\URLLoader_loadExample.as"> Im folgenden Beispiel wird eine XML-Datei geladen und der Inhalt der jeweils ersten Argumente der Elemente wird in einem Textfeld angezeigt.
 
 <p>Es wird ein <codeph>URLRequest</codeph>-Objekt erstellt, um den Speicherort der XML-Datei anzugeben, die sich in diesem Beispiel im selben Verzeichnis wie die SWF-Datei befindet. Die Datei wird in einen <codeph>try...catch</codeph>-Block geladen, um Fehler abzufangen, die möglicherweise auftreten. (Hier werden <codeph>SecurityError</codeph>-Fehler abgefangen.) Wenn ein <codeph>IO_ERROR</codeph>-Ereignis eintritt, wird die <codeph>errorHandler()</codeph>-Methode aufgerufen, die eine Fehlermeldung in das Textfeld <codeph>xmlTextField</codeph> schreibt. Nachdem die Daten aus der XML-Datei empfangen wurden und in der data-Eigenschaft des URLLoader-Objekts <codeph>loader</codeph> platziert wurden, wird das <codeph>Event.COMPLETE</codeph>-Ereignis ausgelöst, und die <codeph>loaderCompleteHandler()</codeph>-Methode wird aufgerufen.</p>
 
 <p>In der <codeph>loaderCompleteHandler()</codeph>-Methode wird ein <codeph>try...catch</codeph>-Block verwendet, um ggf. Parsingfehler, die beim Konvertieren der geladenen Daten aus der Datei in ein XML-Objekt auftreten, abzufangen. Die <codeph>readNodes()</codeph>-Methode geht rekursiv durch alle Elemente in den Knoten des XML-Dokuments und hängt das Textfeld <codeph>xmlTextField</codeph> mit einer Liste der ersten Attribute aller Elemente an.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.xml.*;
    import flash.events.IOErrorEvent;
  
    public class URLLoader_loadExample extends Sprite {
        private var xmlTextField:TextField = new TextField();
        private var externalXML:XML;    
        private var loader:URLLoader;

        public function URLLoader_loadExample() {
            var request:URLRequest = new URLRequest("xmlFile.xml");

            loader = new URLLoader();
            
            try {
                loader.load(request);
            }
            catch (error:SecurityError)
            {
                trace("A SecurityError has occurred.");
            }

             loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);

            xmlTextField.x = 10;
            xmlTextField.y = 10;
            xmlTextField.background = true;
            xmlTextField.autoSize = TextFieldAutoSize.LEFT;

            addChild(xmlTextField);
        }

        private function loaderCompleteHandler(event:Event):void {

                try {
                    externalXML = new XML(loader.data);
                    readNodes(externalXML);    
                } catch (e:TypeError) {
                    trace("Could not parse the XML file.");
                }
        }

        private function readNodes(node:XML):void {

                for each (var element:XML in node.elements()) {
                    xmlTextField.appendText(element.attributes()[0] + "\n");

                    readNodes(element);
                }    
        }

        private function errorHandler(e:IOErrorEvent):void {
            xmlTextField.text = "Had problem loading the XML File.";
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequest/requestHeaders"><linktext>URLRequest.requestHeaders</linktext></link><link href="flash.net.xml#URLRequest/data"><linktext>URLRequest.data</linktext></link><link href="flash.net.xml#URLRequest/digest"><linktext>URLRequest.digest</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird nach dem erfolgreichen Laden von Daten ausgelöst.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird nach dem erfolgreichen Laden von Daten ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wenn der Zugriff über HTTP erfolgt und die aktuelle Flash Player-Umgebung den Empfang von Statuscodes unterstützt, werden diese Ereignisse möglicherweise zusätzlich zu allen <codeph>complete</codeph>- oder <codeph>error</codeph>Ereignissen empfangen.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wenn der Zugriff über HTTP erfolgt und die aktuelle Flash Player-Umgebung den Empfang von Statuscodes unterstützt, werden diese Ereignisse möglicherweise zusätzlich zu allen complete- oder error-Ereignissen empfangen.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Der Ladevorgang konnte nicht abgeschlossen werden.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Der Ladevorgang konnte nicht abgeschlossen werden.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Bei einem Ladevorgang wurde versucht, Daten von einem Server außerhalb der Sicherheitssandbox der aufrufenden Funktion abzurufen. Sie können dies umgehen, indem Sie eine Richtliniendatei auf dem Server verwenden.
	 </apiDesc></adobeApiEventDetail><shortdesc>Bei einem Ladevorgang wurde versucht, Daten von einem Server außerhalb der Sicherheitssandbox der aufrufenden Funktion abzurufen.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Ein Ladevorgang versuchte, eine SWZ-Datei (Adobe-Plattformkomponente) zu laden, aber das Zertifikat ist entweder ungültig oder der Digest stimmt nicht mit der Komponente überein.
	 </apiDesc></adobeApiEventDetail><shortdesc>Ein Ladevorgang versuchte, eine SWZ-Datei (Adobe-Plattformkomponente) zu laden, aber das Zertifikat ist entweder ungültig oder der Digest stimmt nicht mit der Komponente überein.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Start eines Ladevorgangs ausgelöst.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Start eines Ladevorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Aufruf der <codeph>load()</codeph>-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Aufruf der load()-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:URLLoader:bytesLoaded"><apiName>bytesLoaded</apiName><shortdesc>
	 Gibt die Anzahl der Byte an, die bereits geladen wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Anzahl der Byte an, die bereits geladen wurden.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:bytesTotal"><apiName>bytesTotal</apiName><shortdesc>
	 Gibt die Gesamtanzahl der Byte der heruntergeladenen Daten an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Gesamtanzahl der Byte der heruntergeladenen Daten an. Diese Eigenschaft weist während des Ladevorgangs den Wert 0 auf und wird nach Abschluss des Vorgangs mit dem entsprechenden Wert gefüllt. Ein fehlender Content-Length-Header führt dazu, dass bytesTotal unbestimmt ist.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:data"><apiName>data</apiName><shortdesc>
	 Die bei dem Ladevorgang empfangenen Daten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
	 Die bei dem Ladevorgang empfangenen Daten. Dieser Eigenschaft werden nur dann Werte zugewiesen, wenn der Ladevorgang abgeschlossen wurde. Das Format der Daten hängt von der Einstellung der Eigenschaft <codeph>dataFormat</codeph> ab:
	 
	 <p>Wenn die Eigenschaft <codeph>dataFormat</codeph> auf <codeph>URLLoaderDataFormat.TEXT</codeph> gesetzt ist, wird ein String empfangen, der den Text aus der geladenen Datei enthält.</p>
	 
	 <p>Wenn die Eigenschaft <codeph>dataFormat</codeph> auf <codeph>URLLoaderDataFormat.BINARY</codeph> gesetzt ist, werden die Daten als ByteArray-Objekt empfangen, das unformatierte Binärdaten enthält.</p>
	 
	 <p>Wenn die Eigenschaft <codeph>dataFormat</codeph> auf <codeph>URLLoaderDataFormat.VARIABLES</codeph> gesetzt ist, werden die Daten als URLVariables-Objekt empfangen, das URL-kodierte Variablen enthält.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link><link href="flash.net.xml#URLLoader/dataFormat"><linktext>URLLoader.dataFormat</linktext></link></related-links></apiValue><apiValue id="flash.net:URLLoader:dataFormat"><apiName>dataFormat</apiName><shortdesc>
	 Steuert, ob die heruntergeladenen Daten als Text (URLLoaderDataFormat.TEXT), unformatierte Binärdaten (URLLoaderDataFormat.BINARY) oder URL-kodierte Variablen (URLLoaderDataFormat.VARIABLES) empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>URLLoaderDataFormat.TEXT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Steuert, ob die heruntergeladenen Daten als Text (<codeph>URLLoaderDataFormat.TEXT</codeph>), unformatierte Binärdaten (<codeph>URLLoaderDataFormat.BINARY</codeph>) oder URL-kodierte Variablen (<codeph>URLLoaderDataFormat.VARIABLES</codeph>) empfangen werden.
	 
	 <p>Wenn die Eigenschaft <codeph>dataFormat</codeph> den Wert <codeph>URLLoaderDataFormat.TEXT</codeph> aufweist, wird ein String empfangen, der den Text aus der geladenen Datei enthält.</p>
	 
	 <p>Wenn die Eigenschaft <codeph>dataFormat</codeph> den Wert <codeph>URLLoaderDataFormat.BINARY</codeph> aufweist, werden die Daten als ByteArray-Objekt empfangen, das unformatierte Binärdaten enthält.</p>
	 
	 <p>Wenn die Eigenschaft <codeph>dataFormat</codeph> den Wert <codeph>URLLoaderDataFormat.VARIABLES</codeph> aufweist, werden die Daten als URLVariables-Objekt empfangen, das URL-kodierte Variablen enthält.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
 
 Die NetStreamPlayOptions-Klasse legt die verschiedenen Optionen fest, die an die NetStream.play2()-Methode übergeben werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Die NetStreamPlayOptions-Klasse legt die verschiedenen Optionen fest, die an die NetStream.play2()-Methode übergeben werden können. 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Die NetStreamPlayOptions-Klasse legt die verschiedenen Optionen fest, die an die <codeph>NetStream.play2()</codeph>-Methode übergeben werden können. Sie übergeben ein NetStreamPlayOptions-Objekt an <codeph>play2()</codeph> und die Eigenschaften der Klasse legen die verschiedenen Optionen fest. Der primäre Zweck dieser Klasse ist, dynamisch Übergänge zwischen Streams zu implementieren, entweder, um zu Streams mit anderen Bitraten und Größen zu wechseln oder um anderen Inhalt in einer Wiedergabeliste auszuwählen.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamPlayOptions:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
     
     Erstellt ein NetStreamPlayOptions-Objekt, um die Optionen festzulegen, die an die NetStream.play2()-Methode übergeben werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     
     Erstellt ein NetStreamPlayOptions-Objekt, um die Optionen festzulegen, die an die <codeph>NetStream.play2()</codeph>-Methode übergeben werden. 
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiConstructor><apiValue id="flash.net:NetStreamPlayOptions:len"><apiName>len</apiName><shortdesc>
    Die Wiedergabedauer in Sekunden für den Stream, der in streamName festgelegt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Wiedergabedauer in Sekunden für den Stream, der in streamName festgelegt wird.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Die Wiedergabedauer in Sekunden für den Stream, der in <codeph>streamName</codeph> festgelegt wird. Der Standardwert ist -1. Hiermit spielt Flash Player entweder einen Live-Stream ab, bis er nicht mehr verfügbar ist, oder einen aufgenommenen Stream, bis er endet. Wenn Sie für <codeph>len</codeph>0 angeben, spielt Flash Player den einen Frame ab, der sich <codeph>start</codeph>-Sekunden vom Anfang eines aufgenommenen Streams befindet (angenommen, dass <codeph>start</codeph> gleich oder größer als 0 ist).
    <p>Wenn Sie für <codeph>len</codeph> eine positive Zahl eingeben, spielt Flash Player <codeph>len</codeph>-Sekunden lang eine Live-Stream ab, nachdem er verfügbar wird, oder <codeph>len</codeph>-Sekunden lang einen aufgenommenen Stream ab. (Wenn ein Stream vor den <codeph>len</codeph>-Sekunden endet, endet die Wiedergabe, wenn der Stream endet.)</p> 
    <p>Wenn Sie für <codeph>len</codeph> eine andere negative Zahl als -1 eingeben, interpretiert Flash Player den Wert so, als wäre er -1.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/start"><linktext>start</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:oldStreamName"><apiName>oldStreamName</apiName><shortdesc>
    Der Name des alten Streams oder des Streams, von dem aus der Übergang stattfinden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Der Name des alten Streams oder des Streams, von dem aus der Übergang stattfinden soll. Wenn <codeph>NetStream.play2()</codeph> verwendet wird, um nur einen Stream abzuspielen (und keinen Übergang durchzuführen), muss der Wert dieser Eigenschaft entweder null oder undefiniert sein. Geben Sie andernfalls den Stream an, von dem der Übergang erfolgen soll.   
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/streamName"><linktext>streamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:start"><apiName>start</apiName><shortdesc>
    Die Startzeit für streamName in Sekunden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Startzeit für streamName in Sekunden.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Die Startzeit für <codeph>streamName</codeph> in Sekunden. Gültige Werte sind -2, -1 und 0.
    
    <p>Der Standardwert für <codeph>start</codeph> ist -2. Bei diesem Wert versucht Flash Player zuerst, den in <codeph>streamName</codeph> angegebenen Live-Stream abzuspielen. Wenn kein Live-Stream mit diesem Namen gefunden wird, spielt Flash Player den in <codeph>streamName</codeph> angegebenen aufgenommenen Stream ab. Wenn weder ein Live- noch ein aufgenommener Stream gefunden wird, öffnet Flash Player einen Live-Stream mit dem Namen <codeph>streamName</codeph>, obgleich niemand etwas auf diesem Stream veröffentlicht hat. Wenn jemand beginnt, auf diesem Stream zu veröffentlichen, beginnt Flash Player, diesen Stream abzuspielen.</p>
    
    <p>Wenn Sie für <codeph>start</codeph> eingeben, spielt Flash Player nur den in <codeph>streamName</codeph> angegebenen Live-Stream ab. Wenn kein Live-Stream gefunden wird, wartet Flash Player unendlich lange auf ihn, sofern <codeph>len</codeph> auf -1 gesetzt ist. Ist <codeph>len</codeph> auf einen anderen Wert gesetzt, wartet Flash Player <codeph>len</codeph>-Sekunden, bevor es beginnt, den nächsten Stream in der Wiedergabeliste abzuspielen.</p>
    
    <p> Wenn Sie für <codeph>start</codeph> eine 0 oder eine positive Zahl eingeben, spielt Flash Player nur einen aufgenommenen Stream mit dem Namen <codeph>streamName</codeph> ab und beginnt bei <codeph>start</codeph>-Sekunden vom Beginn des Streams. Wenn kein aufgenommener Stream gefunden wird, beginnt Flash Player, sofort den nächsten Stream in der Wiedergabeliste abzuspielen.</p>
    
    <p>Wenn Sie für <codeph>start</codeph> eine andere negative Zahl als -1 oder -2 eingeben, interpretiert Flash Player den Wert so, als wäre er -2.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/len"><linktext>len</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:streamName"><apiName>streamName</apiName><shortdesc>
    Der Name des neuen Streams, zu welchem der Übergang stattfinden soll oder der wiedergegeben werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Der Name des neuen Streams, zu welchem der Übergang stattfinden soll oder der wiedergegeben werden soll. Wenn <codeph>oldStreamName</codeph> 0 oder undefiniert ist, beginnt <codeph>NetStream.play2()</codeph> einfach mit der Wiedergabe von<codeph>streamName</codeph>. Wenn <codeph>oldStreamName</codeph> angegeben ist und <codeph>NetStream.play2()</codeph> aufgerufen wird, geht <codeph>oldStreamName</codeph> zu <codeph>streamName</codeph> (über den in der <codeph>transition</codeph>-Eigenschaft angegebenen Übergangsmodus) über. 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/oldStreamName"><linktext>oldStreamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:transition"><apiName>transition</apiName><shortdesc>
    Der Modus, in dem streamName wiedergegeben wird oder in welchem zu streamName übergegangen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Der Modus, in dem streamName wiedergegeben wird oder in welchem zu streamName übergegangen wird.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Der Modus, in dem streamName wiedergegeben wird oder in welchem zu <codeph>streamName</codeph> übergegangen wird. Mögliche Werte sind Konstanten von der NetStreamPlayTransitions-Klasse. Der Übergangsmodus resultiert abhängig davon, ob <codeph>Netstream.play2()</codeph> zur Wiedergabe oder zum Übergang eines Streams aufgerufen wird, in unterschiedlichen Verhaltensweisen. Weitere Informationen zu Übergangsmodi finden Sie unter „NetStreamPlayTransitions-Klasse“.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyOutput"><apiName>IDynamicPropertyOutput</apiName><shortdesc>
	 Diese Schnittstelle steuert die Serialisierung der dynamischen Eigenschaften dynamischer Objekte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Diese Schnittstelle steuert die Serialisierung der dynamischen Eigenschaften dynamischer Objekte. Sie verwenden diese Schnittstelle mit der IDynamicPropertyWriter-Schnittstelle und der <codeph>ObjectEncoding.dynamicPropertyWriter</codeph>-Eigenschaft.
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyOutput:flash.net:IDynamicPropertyOutput:writeDynamicProperty"><apiName>writeDynamicProperty</apiName><shortdesc>
		 Fügt der Binärausgabe eines serialisierten Objekts eine dynamische Eigenschaft hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Eigenschaft. Sie können diesen Parameter verwenden, um einer vorhandenen Eigenschaft des dynamischen Objekts einen Namen zuzuweisen oder um eine neue Eigenschaft zu erstellen.  
		 
		 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Der Wert, der für die angegebene Eigenschaft festgelegt werden soll.
		 
         </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Fügt der Binärausgabe eines serialisierten Objekts eine dynamische Eigenschaft hinzu. Wenn das Objekt danach gelesen wird (mit einer Methode wie <codeph>readObject</codeph>), enthält es die neue Eigenschaft. Sie können diese Methode verwenden, um Eigenschaften dynamischer Objekte aus der Serialisierung auszuschließen, um Eigenschaften dynamischer Objekte Werte zuzuweisen und um neue Eigenschaften für dynamische Objekte zu erstellen.
		 
         </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLVariables"><apiName>URLVariables</apiName><shortdesc>
 
 Mit der URLVariables-Klasse können Sie Variablen zwischen einer Anwendung und einem Server übertragen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, constructor
</keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Mit der URLVariables-Klasse können Sie Variablen zwischen einer Anwendung und einem Server übertragen. Verwenden Sie URLVariables-Objekte mit Methoden der URLLoader-Klasse, mit der <codeph>data</codeph>-Eigenschaft der URLRequest-Klasse und mit flash.net-Paketfunktionen.
 
 </apiDesc><example conref="examples\URLVariablesExample.as"> Im folgenden Beispiel wird die Remote-Anwendung unter http://www.[yourDomain].com/application.jsp in einem neuen Browserfenster geöffnet, und in einem URLVariables-Objekt erfasste Daten zu einer Benutzersitzung werden an die Anwendung übergeben. 
  
 <p>Wichtige Beispielauszüge:</p>
 <ol>
    <li>Die Konstruktorfunktion erstellt eine URLRequest-Instanz mit dem Namen <codeph>request</codeph>, wobei die URL der Remote-Anwendung als Parameter verwendet wird.</li>
    <li>Ein URLVariables-Objekt wird erstellt, und zwei seiner Eigenschaften werden Werte zugewiesen.</li>
    <li>Das URLVariables-Objekt wird der Eigenschaft <codeph>data</codeph> des URLRequest-Objekts zugewiesen.</li>
    <li>Das Beispiel ruft <codeph>navigateToURL</codeph> auf, wodurch ein neues Browserfenster mit der URL der Remote-Anwendung geöffnet wird.</li>
 </ol>
 <p> <b>Hinweis:</b> Zur Ausführung des Beispiels muss die URL der Remote-Anwendung durch eine gültige URL ersetzt werden. Darüber hinaus benötigen Sie Servercode, um die von Flash Player im URLVariables-Objekt erfassten Informationen auszuführen.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLVariables:URLVariables"><apiName>URLVariables</apiName><shortdesc>
	 Erstellt ein neues URLVariables-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein URL-kodierter String mit Name/Wert-Paaren.
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues URLVariables-Objekt. Sie übergeben URLVariables-Objekte an die <codeph>data</codeph>-Eigenschaft von URLRequest-Objekten.
	 
	 <p>Wenn Sie den URLVariables-Konstruktor mit einem String aufrufen, wird automatisch die <codeph>decode()</codeph>-Methode zur Konvertierung der Zeichenfolge in Eigenschaften des URLVariables-Objekts aufgerufen.</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:URLVariables:decode"><apiName>decode</apiName><shortdesc>
	 Wandelt den Variablenstring in Eigenschaften des angegebenen URLVariables-Objekts um.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.decode, decode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der Quellparameter muss ein URL-kodierter Abfragestring mit Name/Wert-Paaren sein.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein URL-kodierter Abfragestring mit Name/Wert-Paaren.	 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Wandelt den Variablenstring in Eigenschaften des angegebenen URLVariables-Objekts um.
	 <p>Diese Methode wird intern von den URLVariables-Ereignissen verwendet. Die meisten Benutzer müssen diese Methode nicht direkt aufrufen.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLVariables:toString"><apiName>toString</apiName><shortdesc>
	 Gibt einen String mit allen aufzählbaren Variablen im MIME-Inhaltskodierungsformat „application/x-www-form-urlencoded“ zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.toString, toString
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein URL-kodierter String mit Name/Wert-Paaren.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Gibt einen String mit allen aufzählbaren Variablen im MIME-Inhaltskodierungsformat <i>application/x-www-form-urlencoded</i> zurück.
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyWriter"><apiName>IDynamicPropertyWriter</apiName><shortdesc>
     Diese Schnittstelle wird zusammen mit der Schnittstelle „IDynamicPropertyOutput“ zur Steuerung der Serialisierung von dynamischen Eigenschaften dynamischer Objekte verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
     Diese Schnittstelle wird zusammen mit der Schnittstelle „IDynamicPropertyOutput“ zur Steuerung der Serialisierung von dynamischen Eigenschaften dynamischer Objekte verwendet. Weisen Sie zur Verwendung dieser Schnittstelle ein Objekt zu, das die Schnittstelle „IDynamicPropertyWriter“ in der Eigenschaft <codeph>ObjectEncoding.dynamicPropertyWriter</codeph> implementiert.
      
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyWriter:flash.net:IDynamicPropertyWriter:writeDynamicProperties"><apiName>writeDynamicProperties</apiName><shortdesc>
         Schreibt Name und Wert eines IDynamicPropertyOutput-Objekts in ein Objekt mit dynamischen Eigenschaften.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Das Objekt, in das geschrieben wird.
		 </apiDesc></apiParam><apiParam><apiItemName>output</apiItemName><apiOperationClassifier>flash.net:IDynamicPropertyOutput</apiOperationClassifier><apiDesc>Das IDynamicPropertyOutput-Objekt, das den Namen und den Wert enthält, die dynamisch in das Objekt geschrieben werden.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         Schreibt Name und Wert eines IDynamicPropertyOutput-Objekts in ein Objekt mit dynamischen Eigenschaften. Wenn <codeph>ObjectEncoding.dynamicPropertyWriter</codeph> eingestellt ist, wird diese Methode für jedes Objekt mit dynamischen Eigenschaften aufgerufen. 
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLRequestDefaults"><apiName>URLRequestDefaults</apiName><shortdesc>
 Die URLRequestDefaults-Klasse enthält statische Eigenschaften, die Sie festlegen können, um Standardwerte für die Eigenschaften der URLRequest-Klasse zu definieren.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die URLRequestDefaults-Klasse enthält statische Eigenschaften, die Sie festlegen können, um Standardwerte für die Eigenschaften der URLRequest-Klasse zu definieren. Sie enthält auch eine statische Methode, <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph>, mit der Sie Standardauthentifizierungsdetails für Anforderungen definieren können. Die URLRequest-Klasse definiert die Informationen, die in einer HTTP-Anforderung verwendet werden. 
 
 <p>Alle in einem URLRequest-Objekt festgelegten Eigenschaften überschreiben diese statischen Eigenschaften, die für die URLRequestDefaults-Klasse festgelegt sind.</p>
 
 <p>URLRequestDefault-Einstellungen gelten nur für Inhalt in der Anwendungsdomäne des Aufrufers, mit einer Ausnahme: Einstellungen, die durch den Aufruf von <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> vorgenommen werden, gelten für alle Anwendungsdomänen in der zurzeit ausgeführten Anwendung.</p>
 
 <p>Nur Adobe<sup>®</sup> AIR<sup>®</sup>-Inhalt, der in der Sicherheitssandbox der Anwendung ausgeführt wird, kann die URLRequestDefaults-Klasse verwenden. Andere Inhalte lösen einen SecurityError aus, wenn auf die Mitglieder oder Eigenschaften dieser Klasse zugegriffen wird.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><apiOperation id="flash.net:URLRequestDefaults:setLoginCredentialsForHost"><apiName>setLoginCredentialsForHost</apiName><shortdesc>
	Legt Benutzer- und Kennwortdaten für einen ausgewählten Host fest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>hostname</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Hostname, auf den der Benutzername und das Kennwort angewendet werden. Dies kann eine Domäne sein, zum Beispiel <codeph>"www.example.com"</codeph> oder eine Domäne und eine Portnummer, zum Beispiel <codeph>"www.example.com:80"</codeph>. Beachten Sie, dass <codeph>"example.com"</codeph>, <codeph>"www.example.com"</codeph> und <codeph>"sales.example.com"</codeph> jeweils als eindeutige Hosts angesehen werden. 
	
	</apiDesc></apiParam><apiParam><apiItemName>user</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Standardbenutzername, der bei Anforderungsauthentifizierungen für den angegebenen Host verwendet wird.
	
	</apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Das Standardkennwort, das bei Anforderungsauthentifizierungen für den angegebenen Host verwendet wird.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Legt Benutzer- und Kennwortdaten für einen ausgewählten Host fest. Diese Einstellungen beziehen sich auf URLRequest-Objekte in allen Anwendungsdomänen der Anwendung, also nicht nur auf die in der Anwendungsdomäne des Objekts, das diese Methode aufruft (die statischen Eigenschaften der URLRequest-Klasse beziehen sich im Gegensatz hierzu nur auf die Anwendungsdomäne des Aufrufers). Auf diese Weise kann Inhalt in der gesamten Anwendung (unabhängig von der Anwendungsdomäne des Inhalts) angemeldet sein, wenn ein anderer Teil der Anmeldung angemeldet wird.
	
	<p><i>Hinweis für Anwendungen, die unter Mac OS ausgeführt werden:</i> Wenn Sie diese Methode unter Mac OS aufrufen, verwendet die Anwendung diese Anmeldedaten für den angegebenen Host, bis die Anwendung geschlossen wird, selbst wenn Sie anschließend <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> für den gleichen Host aufrufen. Wenn ein Server jedoch die von dieser Methode angegebenen Anmeldedaten ablehnt, werden nachfolgende Aufrufe der <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph>-Methode (für denselben Host) erkannt.</p>
	
	<p><i>Hinweis:</i> Diese Methode gilt nicht für URLRequest-Objekte, die bei Datei-Upload- oder RTMP-Anforderungen verwendet werden.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLRequestDefaults:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	Die Standardeinstellung für die authenticate-Eigenschaft von URLRequest-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Die Standardeinstellung für die <codeph>authenticate</codeph>-Eigenschaft von URLRequest-Objekten. Durch das Festlegen der <codeph>authenticate</codeph>-Eigenschaft in einem URLRequest-Objekt überschreibt diese Standardeinstellung.
	
	<p><i>Hinweis:</i> Diese Einstellung gilt nicht für URLRequest-Objekte, die bei Datei-Upload- oder RTMP-Anforderungen verwendet werden.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/authenticate"><linktext>URLRequest.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	Die Standardeinstellung für die cacheResponse-Eigenschaft von URLRequest-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Die Standardeinstellung für die <codeph>cacheResponse</codeph>-Eigenschaft von URLRequest-Objekten. Durch das Festlegen der <codeph>cacheResponse</codeph>-Eigenschaft in einem URLRequest-Objekt überschreibt diese Standardeinstellung. Bei der Einstellung <codeph>true</codeph> verwendet die AIR-Anwendung standardmäßig den HTTP-Cache des Betriebssystems. Diese Einstellung gilt nicht für URLRequest-Objekte, die bei Datei-Upload- oder RTMP-Anforderungen verwendet werden.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/cacheResponse"><linktext>URLRequest.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	Die Standardeinstellung für die followRedirects-Eigenschaft von URLRequest-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Die Standardeinstellung für die <codeph>followRedirects</codeph>-Eigenschaft von URLRequest-Objekten. Durch das Festlegen der <codeph>followRedirects</codeph>-Eigenschaft in einem URLRequest-Objekt überschreibt diese Standardeinstellung. Diese Einstellung gilt nicht für URLRequest-Objekte, die bei Datei-Upload- oder RTMP-Anforderungen verwendet werden.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/followRedirects"><linktext>URLRequest.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	Die Standardeinstellung für die manageCookies-Eigenschaft von URLRequest-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Die Standardeinstellung für die <codeph>manageCookies</codeph>-Eigenschaft von URLRequest-Objekten. Durch das Festlegen der <codeph>manageCookies</codeph>-Eigenschaft in einem URLRequest-Objekt überschreibt diese Standardeinstellung.
	
	<p><i>Hinweis:</i> Diese Einstellung gilt nicht für URLRequest-Objekte, die bei Datei-Upload- oder RTMP-Anforderungen verwendet werden.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/manageCookies"><linktext>URLRequest.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:useCache:get"><apiName>useCache</apiName><shortdesc>
	Die Standardeinstellung für die useCache-Eigenschaft von URLRequest-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Die Standardeinstellung für die <codeph>useCache</codeph>-Eigenschaft von URLRequest-Objekten. Durch das Festlegen der <codeph>useCache</codeph>-Eigenschaft in einem URLRequest-Objekt überschreibt diese Standardeinstellung. Diese Einstellung gilt nicht für URLRequest-Objekte, die bei Datei-Upload- oder RTMP-Anforderungen verwendet werden.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/useCache"><linktext>URLRequest.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	Die Standardeinstellung für die userAgent-Eigenschaft von URLRequest-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Die Standardeinstellung für die <codeph>userAgent</codeph>-Eigenschaft von URLRequest-Objekten. Durch das Festlegen der <codeph>userAgent</codeph>-Eigenschaft in einem URLRequest-Objekt überschreibt diese Standardeinstellung.
	
	<p>Dies ist auch der Standard-Benutzer-Agent-String für alle HTMLLoader-Objekte (verwendet, wenn Sie die <codeph>load()</codeph>-Methode des HTMLLoader-Objekts aufrufen). Das Festlegen der <codeph>userAgent</codeph>-Eigenschaft des HTMLLoader-Objekts überschreibt die <codeph>URLRequestDefaults.userAgent</codeph>-Einstellung.</p>
	
	<p>Dieser Standardwert variiert je nach dem Laufzeitbetriebssystem (wie z. B. Mac OS, Linux oder Windows), der Laufzeitsprache und der Laufzeitversion (siehe folgende Beispiele):</p>
	
	<ul>
	
		<li><codeph>"Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/526.9+ (KHTML, wie Gecko) AdobeAIR/1.5"</codeph></li>
		<li><codeph>"Mozilla/5.0 (Windows; U; en) AppleWebKit/526.9+ (KHTML, wie Gecko) AdobeAIR/1.5"</codeph></li>
     <li><codeph>"Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/526.9+ (KHTML, wie Gecko) AdobeAIR/1.5"</codeph></li>
	
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/userAgent"><linktext>flash.net.URLRequest.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.net:getClassByAlias"><apiName>getClassByAlias</apiName><shortdesc>
     Sucht nach einer Klasse, für die mit dem Aufruf der Methode „registerClassAlias()“ ein Alias registriert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>includeExample examples\GetClassByAliasExample.as -noswf
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der Alias wurde nicht registriert.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die mit dem gegebenen Alias verknüpfte Klasse. Falls die Suche nach der Klasse nicht erfolgreich ist, wird eine Ausnahme ausgelöst.
     
     </apiDesc><apiOperationClassifier>Class</apiOperationClassifier></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der zu suchende Alias.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Sucht nach einer Klasse, für die mit dem Aufruf der Methode <codeph>registerClassAlias()</codeph> ein Alias registriert wurde.
     <p>Es erfolgt keine Interaktion zwischen dieser Methode und der Methode <codeph>flash.utils.getDefinitionByName()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#/registerClassAlias()"><linktext>registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:navigateToURL"><apiName>navigateToURL</apiName><shortdesc>
     Öffnet oder ersetzt ein Fenster in der Anwendung mit dem Flash Player-Container (in der Regel ein Browser).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
     are not supported by URLLoader.navigate.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die <codeph>digest</codeph>-Eigenschaft des <codeph>request</codeph>-Objekts ist nicht <codeph>null</codeph>. Sie sollten nur die <codeph>digest</codeph>-Eigenschaft eines zu verwendenden URLRequest-Objekts festlegen, das die <codeph>URLLoader.load()</codeph>-Methode beim Laden einer SWZ-Datei (einer Adobe-Plattformkomponente) aufruft.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>In Flash Player (und in anwendungsfremden Sandboxinhalt in Adobe AIR), wird dieser Fehler in den folgenden Situationen zurückgegeben:
     <ul>
       <li>Über lokale nicht vertrauenswürdige SWF-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können diese Situation vermeiden, indem Sie die entsprechende SWF-Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren.</li>
     
       <li>Mit einem Navigationsvorgang wurde versucht, die Pseudo-URL eines Skripts zu evaluieren, das zugehörige Dokument (in der Regel ein HTML-Dokument in einem Browser) befindet sich jedoch in einer Sandbox, auf die Sie keinen Zugriff haben. Sie können diese Situation vermeiden, indem Sie im zugehörigen Dokument <codeph>allowScriptAccess="always"</codeph> angeben.</li>
     
       <li>Sie können in den Fenstern <codeph>"_self"</codeph>, <codeph>"_top"</codeph> und <codeph>"_parent"</codeph> nicht navigieren, wenn Ihre SWF-Datei in einer HTML-Seite enthalten ist, für die <codeph>allowScriptAccess</codeph> auf den Wert <codeph>"none"</codeph> oder auf den Wert <codeph>"sameDomain"</codeph> gesetzt ist (wenn die Domänen der HTML-Datei und der SWF-Datei nicht übereinstimmen).</li>
     
       <li>Sie können nicht von einer SWF-Datei in einer lokalen Dateisystem-Sandbox aus in einem Fenster mit einem nicht standardmäßigen Namen navigieren.</li>
     
      <li>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>. </li>
     
     </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Die Methode wird nicht als Reaktion auf eine Benutzeraktion, z. B. ein Mausereignis oder Tastendruckereignis, aufgerufen. Diese Anforderung bezieht sich nur auf Inhalt in Flash Player und anwendungsfremden Sandboxinhalt in Adobe AIR.
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Ein URLRequest-Objekt, das die URL angibt, zu der navigiert werden soll.
     
     <p><ph platform="actionscript">Für Inhalte, die in Adobe AIR ausgeführt werden, gilt: Wenn</ph><ph platform="javascript">Wenn </ph> die <codeph>navigateToURL()</codeph>-Funktion verwendet wird, behandelt die Laufzeit ein URLRequest-Objekt, das die POST-Methode verwendet (ein Objekt, dessen <codeph>method</codeph>-Eigenschaft auf <codeph>URLRequestMethod.POST</codeph> eingestellt ist), so, als ob die GET-Methode verwendet wird.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Browserfenster oder der HTML-Frame, in dem das mit dem Parameter <codeph>request</codeph> angegebene Dokument angezeigt werden soll. Sie können den Namen eines bestimmten Fensters angeben oder einen der folgenden Werte verwenden:
     <ul>
     <li><codeph>"_self"</codeph> bezeichnet den aktuellen Frame im aktuellen Fenster.</li>
     <li><codeph>"_blank"</codeph> bezeichnet ein neues Fenster.</li>
     <li><codeph>"_parent"</codeph> bezeichnet den übergeordneten Frame des aktuellen Frames.</li>
     <li><codeph>"_top"</codeph> bezeichnet den obersten Frame im aktuellen Fenster.</li>
     </ul>
     <p>Wenn Sie für diesen Parameter keinen Wert angeben, wird ein neues leeres Fenster erstellt. Im eigenständigen Player können Sie entweder ein neues Fenster (<codeph>"_blank"</codeph>) oder ein benanntes Fenster angeben. Die anderen Werte treffen nicht zu.</p>
     
     <p platform="actionscript"><b>Hinweis:</b> Wenn eine SWF-Datei in der lokalen Dateisystem-Sandbox ausgeführt wird und mit einem Code, der sich in dieser SWF-Datei befindet, die Funktion <codeph>navigateToURL()</codeph> aufgerufen und ein benutzerdefinierter Fenstername für den Parameter <codeph>window</codeph> angegeben wird, wird der Fenstername in einen Zufallsnamen umgewandelt. Der Name hat die Form <codeph>"_flashXXXXXXXX"</codeph>, wobei jedes X eine zufällige hexadezimale Zahl darstellt. Wenn Sie innerhalb derselben Sitzung (bis zum Schließen des jeweiligen Browserfensters) die Funktion erneut aufrufen und denselben Namen für den Parameter <codeph>window</codeph> angeben, wird derselbe Zufalls-String verwendet.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     <ph platform="actionscript">Öffnet oder ersetzt ein Fenster in der Anwendung mit dem Flash Player-Container (in der Regel ein Browser). In Adobe AIR öffnet die Funktion eine URL im Standardsystem-Webbrowser</ph> <ph platform="javascript">Öffnet eine URL im Standardsystem-Webbrowser.</ph>
     
	 	<p>  <b><i>Wichtiger Sicherheitshinweis</i></b> </p>
     	<p>Entwickler übergeben URL-Werte, die von externen Quellen wie z. B. FlashVars erhalten wurden, oft an die <codeph>navigateToURL()</codeph>-Funktion. Hacker können versuchen, die externen Quellen zu ändern, um Angriffe wie z. B. Cross-Site-Scripting durchzuführen. Aus diesem Grund sollten Entwickler alle URLs überprüfen, bevor sie sie an diese Funktion übergeben. </p>
     	
     <p>Eine gute Datenprüfung für URLs kann je nach dem Verwendungszweck der URL in der gesamten Anwendung Verschiedenes bedeuten. Eine der häufigsten Datenprüfmethode besteht darin, zu prüfen, ob die URL dem jeweiligen Schema entspricht. Wenn z. B. unbeabsichtigt javascript:-URLs erlaubt werden, kann dies in Cross-Site-Scripting resultieren. Durch die Prüfung, ob die URL innerhalb Ihrer Domäne ist, kann gewährleistet werden, dass die SWF-Datei nicht als offene Umleitung durch Personen verwendet werden kann, die Phishing-Angriffe ausführen. Als zusätzliche Sicherheitsmaßnahme könnten Sie außerdem den Pfad der URL prüfen bzw. auch prüfen, ob die URL den RFC-Richtlinien entspricht.</p>
     
     <p platform="actionscript">Der folgende Code ist ein einfaches Beispiel für eine Datenprüfung, bei der jede URL, die nicht mit http:// oder https:// beginnt, geblockt wird, und außerdem überprüft wird, ob sich die URL innerhalb Ihres Domänennamens befindet. Dieses Beispiel ist nicht unbedingt für alle Webanwendungen geeignet und Sie sollten sich überlegen, ob zusätzliche Prüfungen für URLs notwendig sind. </p>
	 
     	<codeblock platform="actionscript">
     // AS3 Regular expression pattern match for URLs that start with http:// and https:// plus your domain name.
     function checkProtocol (flashVarURL:String):Boolean {
        // Get the domain name for the SWF if it is not known at compile time.
        // If the domain is known at compile time, then the following two lines can be replaced with a hard coded string.
        var my_lc:LocalConnection = new LocalConnection();
        var domainName:String = my_lc.domain;
        // Build the RegEx to test the URL.
        // This RegEx assumes that there is at least one "/" after the
        // domain. http://www.mysite.com will not match.
        var pattern:RegExp = new RegExp("^http[s]?\:\\/\\/([^\\/]+)\\/");
        var result:Object = pattern.exec(flashVarURL);
        if (result == null || result[1] != domainName || flashVarURL.length >= 4096) {
          return (false);
        }
        return (true);
     }  
     
     	</codeblock>
	 <p platform="actionscript">Für <i>local</i>-Inhalt, der in einem Browser ausgeführt wird, sind Aufrufe der <codeph>navigateToURL()</codeph>-Methode, die ein <codeph>"javascript:"</codeph>-Pseudoprotokoll (über ein <codeph>URLRequest</codeph>-Objekt, das als erster Parameter übergeben wurde) nur zulässig, wenn sich die SWF-Datei und die enthaltende Webseite (sofern es eine gibt) in der lokal vertrauenswürdigen Sicherheitssandbox befinden. Einige Browser unterstützen das Javascript-Protokoll mit der <codeph>navigateToURL()</codeph>-Methode nicht. Ziehen Sie stattdessen einen Aufruf der <codeph>call()</codeph>-Methode der <codeph>ExternalInterface</codeph>-API in Betracht, um JavaScript-Methoden innerhalb der umschließenden HTML-Seite aufzurufen.</p>
     
      <p platform="actionscript">In Flash Player und anwendungsfremden Sandboxen in Adobe AIR können Sie keine Verbindung mit normalerweise reservierten Ports herstellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
     
     <p platform="actionscript">Wenn Flash Player 10 oder eine spätere Version in einem Browser ausgeführt wird, kann diese Methode eventuell nicht programmgesteuert verwendet werden, um ein Popupfenster zu öffnen. Verschiedene Browser (und Browserkonfigurationen) blocken eventuell alle Popupfenster. Es ist daher nicht möglich, das Einblenden eines Popupfensters sicherzustellen. Den größten Erfolg verspricht diese Methode zum Öffnen eines Popupfensters in Code, der als direktes Ergebnis einer Benutzeraktion ausgeführt wird z. B. in einer Ereignisprozedur für ein Mausklick- oder Tastendruckereignis.</p>
     
     <p platform="actionscript"> Wenn Sie in Flash Player 10 oder höher einen Multipart-Content-Type verwenden (z. B. „multipart/form-data“), der einen Upload enthält (gekennzeichnet durch einen „filename“-Parameter in einem „content-disposition“-Header innerhalb des POST-Body), so unterliegt die POST-Methode den Sicherheitsregeln für Uploads:</p>
	 <ul platform="actionscript">
	 <li>Der POST-Vorgang muss als Reaktion auf eine durch den Benutzer initiierte Aktion, z. B. Mausklick oder Tastendruck, erfolgen.</li>
	 <li>Ist die POST-Methode domänenübergreifend (das POST-Ziel befindet sich auf einem anderen Server als die SWF-Datei, die die POST-Anforderung sendet), so muss der Zielserver eine URL-Richtliniendatei bereitstellen, die den domänenübergreifenden Zugriff erlaubt.</li>
	 </ul>
     <p platform="actionscript">Für alle mehrteiligen Content-Typen muss ebenfalls die Syntax nach Standard RFC2046 gültig sein. Scheint die Syntax ungültig zu sein, so unterliegt die POST-Methode den Sicherheitsregeln für Uploads.</p>
     
     <p platform="actionscript">Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
     
     <ul platform="actionscript">
     
     <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
     <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
       <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     
     </ul>
     
     </apiDesc><example conref="examples\NavigateToURLExample.as"> Im folgenden Beispiel wird die URL http://www.adobe.com in einem neuen Browserfenster geöffnet, und in einem URLVariables-Objekt erfasste Daten zu einer Benutzersitzung werden an den Webserver übergeben.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class NavigateToURLExample extends Sprite {

        public function NavigateToURLExample() {
            var url:String = "http://www.adobe.com";
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "Your Name";
            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            try {            
                navigateToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.external.xml#ExternalInterface/call()"><linktext>flash.external.ExternalInterface.call()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:registerClassAlias"><apiName>registerClassAlias</apiName><shortdesc>
     Behält die Klasse (den Typ) eines Objekts bei, wenn dieses in Action Message Format (AMF) kodiert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn einer der Parameter den Wert <codeph>null</codeph> aufweist.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der zu verwendende Alias.
     </apiDesc></apiParam><apiParam><apiItemName>classObject</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>Die mit dem gegebenen Alias verknüpfte Klasse.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Behält die Klasse (den Typ) eines Objekts bei, wenn dieses in Action Message Format (AMF) kodiert wird. Bei der Kodierung eines Objekts in AMF speichert diese Funktion einen Alias für die Klasse des Objekts, sodass Sie die Klasse wiederherstellen können, wenn Sie das Objekt dekodieren. Wenn im Kontext der Kodierung kein Alias für eine Objektklasse registriert wird, erfolgt die Kodierung des Objekts als anonymes Objekt. Wenn im Kontext der Dekodierung nicht derselbe Alias registriert ist, wird für die dekodierten Daten ein anonymes Objekt erstellt.
     
     <p>LocalConnection, ByteArray, SharedObject, NetConnection und NetStream sind Beispiele für Klassen, die Objekte in AMF kodieren.</p>
     
     <p>Für den Kodierungs- und Dekodierungskontext muss nicht dieselbe Klasse für einen Alias verwendet werden. Die Klassen können geändert werden, vorausgesetzt, dass die Zielklasse alle Mitglieder enthält, die von der Quellklasse serialisiert werden.</p>
     
     </apiDesc><example conref="examples\RegisterClassAliasExample.as"> In diesem Beispiel wird die Funktion <codeph>registerClassAlias()</codeph> zur Registrierung eines Alias (<codeph>com.example.eg</codeph>) für die ExampleClass-Klasse verwendet. Die Registrierung eines Alias für die Klasse ermöglicht die Deserialisierung des Objekts als Instanz von ExampleClass, und der Code gibt den Wert <codeph>true</codeph> aus. Bei Entfernung des Aufrufs <codeph>registerClassAlias()</codeph> würde der Code den Wert <codeph>false</codeph> ausgeben. 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.registerClassAlias;
    import flash.utils.ByteArray;

    public class RegisterClassAliasExample extends Sprite {
        public function RegisterClassAliasExample() {
            registerClassAlias("com.example.eg", ExampleClass);
            var eg1:ExampleClass = new ExampleClass();
            var ba:ByteArray = new ByteArray();
            ba.writeObject(eg1);
            ba.position = 0;
            var eg2:* = ba.readObject();
            trace(eg2 is ExampleClass); // true
        }
    }
}

class ExampleClass {}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding-Klasse</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:sendToURL"><apiName>sendToURL</apiName><shortdesc>
     Sendet eine URL-Anforderung an einen Server, Antworten werden jedoch ignoriert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
         are not supported by URLLoader.send.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Über lokale nicht vertrauenswürdige SWF-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können diese Situation vermeiden, indem Sie die entsprechende SWF-Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Ein URLRequest-Objekt, das die URL angibt, an die Daten gesendet werden sollen.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
     Sendet eine URL-Anforderung an einen Server, Antworten werden jedoch ignoriert.
     <p>Verwenden Sie die Methode<codeph>URLLoader.load()</codeph>, wenn die Serverantwort überprüft werden soll.</p>
     
      <p>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
     
     <p>Sie können eine SWF-Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</p>
	 
     <p> Wenn Sie in Flash Player 10 oder höher einen Multipart-Content-Type verwenden (z. B. „multipart/form-data“), der einen Upload enthält (gekennzeichnet durch einen „filename“-Parameter in einem „content-disposition“-Header innerhalb des POST-Body), so unterliegt die POST-Methode den Sicherheitsregeln für Uploads:</p>
	 <ul>
	 <li>Der POST-Vorgang muss als Reaktion auf eine durch den Benutzer initiierte Aktion, z. B. Mausklick oder Tastendruck, erfolgen.</li>
	 <li>Ist die POST-Methode domänenübergreifend (das POST-Ziel befindet sich auf einem anderen Server als die SWF-Datei, die die POST-Anforderung sendet), so muss der Zielserver eine URL-Richtliniendatei bereitstellen, die den domänenübergreifenden Zugriff erlaubt.</li>
	 </ul>
     <p>Für alle mehrteiligen Content-Typen muss ebenfalls die Syntax nach Standard RFC2046 gültig sein. Scheint die Syntax ungültig zu sein, so unterliegt die POST-Methode den Sicherheitsregeln für Uploads.</p>
     
     <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
     
     <ul>
     
     <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
     <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
       <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     
     </ul>
         
         </apiDesc><example conref="examples\SendToURLExample.as"> Im folgenden Beispiel werden die in einem URLVariables-Objekt erfassten Daten zu einer Benutzersitzung an die Anwendung unter http://www.yourDomain.com/application.jsp übergeben.
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.net.URLVariables;
    import flash.net.sendToURL;

    public class SendToURLExample extends Sprite {

        public function SendToURLExample() {
            var url:String = "http://www.yourDomain.com/application.jsp";
            var variables:URLVariables = new URLVariables();
            variables.sessionId = new Date().getTime();
            variables.userLabel = "Your Name";

            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            trace("sendToURL: " + request.url + "?" + request.data);
            try {
                sendToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiClassifier id="flash.net:Responder"><apiName>Responder</apiName><shortdesc>
 Die Responder-Klasse stellt ein Objekt bereit, das in „NetConnection.call()“ zur Verarbeitung der Rückgabewerte vom Server im Zusammenhang mit dem Erfolg oder Fehlschlagen von bestimmten Operationen verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Responder-Klasse stellt ein Objekt bereit, das in <codeph>NetConnection.call()</codeph> zur Verarbeitung der Rückgabewerte vom Server im Zusammenhang mit dem Erfolg oder Fehlschlagen von bestimmten Operationen verwendet wird. Beim Einsatz von <codeph>NetConnection.call()</codeph> können Sie auf einen Fehler der Netzwerkoperation treffen, der speziell mit der aktuellen Operation zusammenhängt, oder auf einen Fehler, der sich auf den aktuellen Verbindungsstatus bezieht. Für unkompliziertere Fehlerbearbeitung haben Operationsfehler das Responder- anstelle des NetConnection-Objekts zum Ziel.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links><apiConstructor id="flash.net:Responder:Responder"><apiName>Responder</apiName><shortdesc>
	 Erstellt ein neues Responder-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>result</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Die Funktion, die aufgerufen wird, wenn der Aufruf an den Server erfolgreich war und ein Ergebnis zurückgegeben wird.
	 </apiDesc></apiParam><apiParam><apiItemName>status</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiData>null</apiData><apiDesc>Die Funktion, die aufgerufen wird, wenn der Server einen Fehler zurückgibt.
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues Responder-Objekt. Sie übergeben das Responder-Objekt zur Verarbeitung der Rückgabewerte vom Server an <codeph>NetConnection.call()</codeph>. Sie können für einen oder beide Parameter <codeph>null</codeph> übergeben.
	 
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.net:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
 Ein URLRequestHeader-Objekt enthält einen einzelnen HTTP-Anforderungsheader und besteht aus einem Name/Wert-Paar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Ein URLRequestHeader-Objekt enthält einen einzelnen HTTP-Anforderungsheader und besteht aus einem Name/Wert-Paar. URLRequestHeader-Objekte werden in der Eigenschaft <codeph>requestHeaders</codeph> der URLRequest-Klasse verwendet.
 
 <p>In Adobe<sup>®</sup> AIR kann Inhalt in der Sicherheitssandbox der Anwendung (zum Beispiel Inhalt, der mit der AIR-Anwendung installiert wurde) beliebige Anforderungsheader ohne Fehler verwenden. Für Inhalt, der in Adobe AIR ausgeführt wird und sich in einer anderen Sicherheitssandbox befindet, <ph outputclass="actionscript">oder für Inhalt der in Flash<sup>®</sup> Player ausgeführt wird,</ph> führt die Verwendung der folgenden Anforderungsheader zu einem Laufzeitfehler, und bei beschränkten Begriffen wird nicht zwischen Groß- und Kleinschreibung unterschieden (zum Beispiel sind <codeph>Get</codeph>, <codeph>get</codeph> und <codeph>GET</codeph> alle nicht zulässig): </p>
 
 <p>In Flash Player und in Adobe AIR-Inhalt außerhalb der Sicherheitssandbox der Anwendung können die folgenden Anforderungsheader nicht verwendet werden und bei beschränkten Begriffen wird nicht zwischen Groß- und Kleinschreibung unterschieden (zum Beispiel sind <codeph>Get</codeph>, <codeph>get</codeph> und <codeph>GET</codeph> alle nicht zulässig). Mit Bindestrich versehene Begriffe gelten, wenn ein Unterstrichzeichen verwendet wird (so ist es nicht zulässig, sowohl <codeph>Content-Length</codeph> und <codeph>Content_Length</codeph> zu verwenden): </p>
 
 <p><codeph>Accept-Charset</codeph>, <codeph>Accept-Encoding</codeph>, <codeph>Accept-Ranges</codeph>, <codeph>Age</codeph>, <codeph>Allow</codeph>, <codeph>Allowed</codeph>, <codeph>Authorization</codeph>, <codeph>Charge-To</codeph>, <codeph>Connect</codeph>, <codeph>Connection</codeph>, <codeph>Content-Length</codeph>, <codeph>Content-Location</codeph>, <codeph>Content-Range</codeph>, <codeph>Cookie</codeph>, <codeph>Date</codeph>, <codeph>Delete</codeph>, <codeph>ETag</codeph>, <codeph>Expect</codeph>, <codeph>Get</codeph>, <codeph>Head</codeph>, <codeph>Host</codeph>, <codeph>Keep-Alive</codeph>, <codeph>Last-Modified</codeph>, <codeph>Location</codeph>, <codeph>Max-Forwards</codeph>, <codeph>Options</codeph>, <codeph>Origin</codeph>, <codeph>Post</codeph>, <codeph>Proxy-Authenticate</codeph>, <codeph>Proxy-Authorization</codeph>, <codeph>Proxy-Connection</codeph>, <codeph>Public</codeph>, <codeph>Put</codeph>, <codeph>Range</codeph>, <codeph>Referer</codeph>, <codeph>Request-Range</codeph>, <codeph>Retry-After</codeph>, <codeph>Server</codeph>, <codeph>TE</codeph>, <codeph>Trace</codeph>, <codeph>Trailer</codeph>, <codeph>Transfer-Encoding</codeph>, <codeph>Upgrade</codeph>, <codeph>URI</codeph>, <codeph>User-Agent</codeph>, <codeph>Vary</codeph>, <codeph>Via</codeph>, <codeph>Warning</codeph>, <codeph>WWW-Authenticate</codeph>, <codeph>x-flash-version</codeph>.</p>
 
 <p>Für URLRequestHeader-Objekte gelten Längenbeschränkungen. Wenn die Gesamtlänge eines URLRequestHeader-Objekts (die Länge der <codeph>name</codeph>-Eigenschaft plus die Länge der Eigenschaft <codeph>value</codeph>) oder eines Arrays von URLRequestHeader-Objekten (verwendet in der Eigenschaft <codeph>URLRequest.requestHeaders</codeph>) die zulässige Länge überschreitet, wird eine Ausnahme ausgelöst.</p>
 
 <p>Inhalt, der in Adobe AIR ausgeführt wird, stellt den <codeph>ACCEPT</codeph>-Header auf Folgendes ein, sofern Sie nicht eine Einstellung für den <codeph>ACCEPT</codeph>-Header in der <codeph>requestHeaders</codeph>-Eigenschaft der URLRequest-Klasse festlegen:</p>
 
 <codeph>text/xml, application/xml, application/xhtml+xml, text/html;q=0.9, text/plain;q=0.8, image/png, application/x-shockwave-flash, video/mp4;q=0.9, flv-application/octet-stream;q=0.8, video/x-flv;q=0.7, audio/mp4, ~~/~~;q=0.5</codeph>
 <p>Nicht alle Methoden, die URLRequest-Parameter akzeptieren, unterstützen die <codeph>requestHeaders</codeph>-Eigenschaft. Informationen zu der von Ihnen aufgerufenen Methode finden Sie in der entsprechenden Dokumentation. Beispiel: Die <codeph>FileReference.upload()</codeph>- und die <codeph>FileReference.download()</codeph>-Methode unterstützen die <codeph>URLRequest.requestHeaders</codeph>-Eigenschaft nicht.</p>
 <p>Aufgrund von Browsereinschränkungen werden benutzerdefinierte HTTP-Anforderungs-Header für <codeph>POST</codeph>-Anforderungen, aber nicht für <codeph>GET</codeph>-Anforderungen unterstützt.</p>  
 
 </apiDesc><example conref="examples\URLRequestHeaderExample.as"> Im folgenden Beispiel wird dem Array für die Eigenschaft <codeph>requestHeaders</codeph> ein einzelner HTTP-Anforderungsheader <codeph>header</codeph> hinzugefügt. Der Header gibt an, dass die Anwendung selbst dann die Anforderung an den Ursprungsserver weiterleiten sollte, wenn sie über eine zwischengespeicherte Kopie dessen verfügt, was angefordert wird.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.net.URLRequestHeader;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequestHeaderExample extends Sprite {
        public function URLRequestHeaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var header:URLRequestHeader = new URLRequestHeader("pragma", "no-cache");
            var request:URLRequest = new URLRequest("http://www.[yourdomain].com/greeting.cfm");
            request.data = new URLVariables("name=John+Doe");
            request.method = URLRequestMethod.POST;
            request.requestHeaders.push(header);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLRequestHeader:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
	 Erstellt ein neues URLRequestHeader-Objekt, das einen einzelnen HTTP-Anforderungsheader umfasst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Der Name eines HTTP-Anforderungsheaders (z. B. <codeph>Content-Type</codeph> oder <codeph>SOAPAction</codeph>).
	 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Der mit der Eigenschaft <codeph>name</codeph> verknüpfte Wert (z. B. <codeph>text/plain</codeph>).
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt ein neues URLRequestHeader-Objekt, das einen einzelnen HTTP-Anforderungsheader umfasst. URLRequestHeader-Objekte werden in der Eigenschaft <codeph>requestHeaders</codeph> der URLRequest-Klasse verwendet.
     
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:URLRequestHeader:name"><apiName>name</apiName><shortdesc>
	 Der Name eines HTTP-Anforderungsheaders (z. B. „Content-Type“ oder „SOAPAction“).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Der Name eines HTTP-Anforderungsheaders (z. B. <codeph>Content-Type</codeph> oder <codeph>SOAPAction</codeph>).
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestHeader:value"><apiName>value</apiName><shortdesc>
	 Der mit der Eigenschaft „name“ verknüpfte Wert (z. B. „text/plain“).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Der mit der Eigenschaft <codeph>name</codeph> verknüpfte Wert (z. B. <codeph>text/plain</codeph>).
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequestMethod"><apiName>URLRequestMethod</apiName><shortdesc>
 Die URLRequestMethod-Klasse stellt Werte bereit, die angeben, ob das URLRequest-Objekt beim Senden von Daten an den Server die POST- oder die GET-Methode verwenden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die URLRequestMethod-Klasse stellt Werte bereit, die angeben, ob das URLRequest-Objekt beim Senden von Daten an den Server die <codeph>POST</codeph>- oder die <codeph>GET</codeph>-Methode verwenden soll.
 
 </apiDesc><example conref="examples\URLRequestMethodExample.as"> Im folgenden Beispiel werden die in einer lokalen Textdatei gefundenen Daten geladen und angezeigt. Des Weiteren werden Ereignisverarbeitungsinformationen erfasst.
 
 <p><b>Hinweis:</b> Legen Sie zur Ausführung des Beispiels eine Datei mit dem Namen „example.txt“ in dem Verzeichnis ab, in dem sich die SWF-Datei befindet. Hierbei muss es sich um eine einfache Textdatei mit ein paar Wörtern oder Textzeilen handeln.
 </p>
 <p>Der Beispielcode führt folgende Schritte aus:</p>
 <ol>
    <li>Die Konstruktorfunktion erstellt eine URLLoader-Instanz mit dem Namen <codeph>loader</codeph>.</li>
    <li>Das Objekt <codeph>loader</codeph> wird an die Methode <codeph>configureListeners()</codeph> übergeben, die für jedes unterstützte URLLoader-Ereignis Listener hinzufügt.</li>
  <li>Es wird eine URLRequest-Instanz mit dem Namen <codeph>request</codeph> erstellt, die den Namen der zu ladenden Datei angibt.</li>
  <li>Die Eigenschaft <codeph>method</codeph> der Anforderung wird auf <codeph>URLRequestMethod.POST</codeph> gesetzt.</li>
    <li>Dann wird das Objekt <codeph>request</codeph> an die Methode <codeph>loader.load()</codeph> übergeben, die die Textdatei lädt.</li>
  <li>Nach Abschluss des Ladevorgangs wird das Ereignis <codeph>Event.COMPLETE</codeph> ausgelöst, das wiederum die Methode <codeph>completeHandler()</codeph> auslöst. Die Methode <codeph>completeHandler()</codeph> gibt die Eigenschaft <codeph>data</codeph> aus, d. h. den Inhalt der Textdatei.</li>
 </ol>
<codeblock>


package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestMethodExample extends Sprite {

        public function URLRequestMethodExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("example.txt");
            
            request.method = URLRequestMethod.POST;
            loader.load(request);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link></related-links><apiValue id="flash.net:URLRequestMethod:DELETE"><apiName>DELETE</apiName><shortdesc>
	 Gibt an, dass für das URLRequest-Objekt die DELETE-Methode verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>DELETE</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass für das URLRequest-Objekt die <codeph>DELETE</codeph>-Methode verwendet wird.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:GET"><apiName>GET</apiName><shortdesc>
	 Gibt an, dass für das URLRequest-Objekt die GET-Methode verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>GET</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass für das URLRequest-Objekt die <codeph>GET</codeph>-Methode verwendet wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:HEAD"><apiName>HEAD</apiName><shortdesc>
	 Gibt an, dass für das URLRequest-Objekt die HEAD-Methode verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>HEAD</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass für das URLRequest-Objekt die <codeph>HEAD</codeph>-Methode verwendet wird.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:OPTIONS"><apiName>OPTIONS</apiName><shortdesc>
	 Gibt an, dass für das URLRequest-Objekt die OPTIONS-Methode verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>OPTIONS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass für das URLRequest-Objekt die <codeph>OPTIONS</codeph>-Methode verwendet wird.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:POST"><apiName>POST</apiName><shortdesc>
	 Gibt an, dass für das URLRequest-Objekt die POST-Methode verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>POST</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass für das URLRequest-Objekt die <codeph>POST</codeph>-Methode verwendet wird.
	 
	 <p><i>Hinweis:</i> <ph platform="actionscript">Wenn Inhalt in Adobe AIR ausgeführt wird und </ph> <ph platform="javascript">Wenn </ph> die <codeph>navigateToURL()</codeph>-Funktion verwendet wird, behandelt die Laufzeit einen URLRequest, der die POST-Methode benutzt (bei der die <codeph>method</codeph>-Eigenschaft auf <codeph>URLRequestMethod.POST</codeph> gesetzt ist) so, als ob die GET-Methode verwendet wird.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:PUT"><apiName>PUT</apiName><shortdesc>
	 Gibt an, dass für das URLRequest-Objekt die PUT-Methode verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>PUT</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass für das URLRequest-Objekt die <codeph>PUT</codeph>-Methode verwendet wird.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 Die FileReferenceList-Klasse ermöglicht Benutzern das Auswählen einer oder mehrerer Dateien für den Upload.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReferenceList
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Ermöglicht das Hochladen einer oder mehrerer Dateien.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die FileReferenceList-Klasse ermöglicht Benutzern das Auswählen einer oder mehrerer Dateien für den Upload. Dabei ist ein FileReferenceList-Objekt eine Gruppe lokal auf dem Computer des Benutzers gespeicherter Dateien, die als Array von FileReference-Objekten dargestellt wird. Weitere Informationen und wichtige Überlegungen zum Gebrauch von FileReference-Objekten und der FileReference-Klasse finden Sie im Abschnitt zur FileReference-Klasse.
 
 <p>So arbeiten Sie mit der FileReferenceList-Klasse:</p>
 <ul>
 <li>Instanziieren der Klasse: <codeph>var myFileRef = new FileReferenceList();</codeph></li>
 <li>Rufen Sie die Methode <codeph>FileReferenceList.browse()</codeph> auf. Dadurch wird ein Dialogfeld geöffnet, in dem der Benutzer eine oder mehrere Dateien für den Upload-Vorgang auswählen kann: <codeph>myFileRef.browse();</codeph></li>
 <li>Nach dem erfolgreichen Aufruf von <codeph>browse()</codeph> wird die Eigenschaft <codeph>fileList</codeph> des FileReferenceList-Objekts mit den Daten eines Arrays von FileReference-Objekten aktualisiert.</li>
 <li>Rufen Sie danach für jedes Element des <codeph>fileList</codeph>-Arrays <codeph>FileReference.upload()</codeph> auf.</li>
 </ul>
 
 <p>Zur FileReferenceList-Klasse gehören auch eine <codeph>browse()</codeph>-Methode und eine <codeph>fileList</codeph>-Eigenschaft für das Arbeiten mit mehreren Dateien. Wenn eine <codeph>FileReferenceList.browse()</codeph>-Methode aufgerufen wird, wird die Wiedergabe von SWF-Dateien in der eigenständigen und der externen Version von Flash Player und in AIR für Linux und Mac OS X 10.1 und früheren Versionen unterbrochen.</p>
 
 </apiDesc><example conref="examples\FileReferenceListExample.as"> Im folgenden Beispiel wird gezeigt, wie Sie mit Ereignissen den Upload mehrerer Dateien verwalten können. Die CustomFileReferenceList-Klasse erweitert FileReferenceList und enthält das Ereignis <codeph>complete</codeph>, das nach den Upload-Vorgängen der einzelnen Dateien im FileReferenceList-Objekt ausgelöst wird. Das Ereignis <codeph>LIST_COMPLETE</codeph> der FileReferenceListExample-Klasse wird ausgelöst, wenn alle Dateien im FileReferenceList-Objekt hochgeladen wurden.
 
 <p>Verwenden Sie zur Ausführung dieses Beispiels ein Skript, das den Upload einer Datei unter http://www.[yourDomain].com/yourUploadHandlerScript.cfm zulässt. Abhängig vom Speicherort Ihrer SWF-Datei und dem Upload-Ziel müssen Sie außerdem ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash<sup>®</sup> Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen. Wenn das Upload-Ziel ein Remote-Server ist und Sie dieses Beispiel über Ihren Desktop-Computer ausführen, muss auf dem Server eine crossdomain.xml-Datei abgelegt sein.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.FileReferenceList;
 
    public class FileReferenceListExample extends Sprite {
        public static var LIST_COMPLETE:String = "listComplete";
        public function FileReferenceListExample() {
            initiateFileUpload();
        }

        private function initiateFileUpload():void {
            var fileRef:CustomFileReferenceList = new CustomFileReferenceList();
            fileRef.addEventListener(FileReferenceListExample.LIST_COMPLETE, listCompleteHandler);
            fileRef.browse(fileRef.getTypes());
        }

        private function listCompleteHandler(event:Event):void {
            trace("listCompleteHandler");
        }
    }
}
 
import flash.events.*;
import flash.net.FileReference;
import flash.net.FileReferenceList;
import flash.net.FileFilter;
import flash.net.URLRequest;
 
class CustomFileReferenceList extends FileReferenceList {
    private var uploadURL:URLRequest;
    private var pendingFiles:Array;

    public function CustomFileReferenceList() {
        uploadURL = new URLRequest();
        uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
        initializeListListeners();
    }

    private function initializeListListeners():void {
        addEventListener(Event.SELECT, selectHandler);
        addEventListener(Event.CANCEL, cancelHandler);
    }

    public function getTypes():Array {
        var allTypes:Array = new Array();
        allTypes.push(getImageTypeFilter());
        allTypes.push(getTextTypeFilter());
        return allTypes;
    }
 
    private function getImageTypeFilter():FileFilter {
        return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
    }
 
    private function getTextTypeFilter():FileFilter {
        return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
    }
 
    private function doOnComplete():void {
        var event:Event = new Event(FileReferenceListExample.LIST_COMPLETE);
        dispatchEvent(event);
    }
 
    private function addPendingFile(file:FileReference):void {
        trace("addPendingFile: name=" + file.name);
        pendingFiles.push(file);
        file.addEventListener(Event.OPEN, openHandler);
        file.addEventListener(Event.COMPLETE, completeHandler);
        file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
        file.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        file.upload(uploadURL);
    }
 
    private function removePendingFile(file:FileReference):void {
        for (var i:uint; i &lt; pendingFiles.length; i++) {
            if (pendingFiles[i].name == file.name) {
                pendingFiles.splice(i, 1);
                if (pendingFiles.length == 0) {
                    doOnComplete();
                }
                return;
            }
        }
    }
 
    private function selectHandler(event:Event):void {
        trace("selectHandler: " + fileList.length + " files");
        pendingFiles = new Array();
        var file:FileReference;
        for (var i:uint = 0; i &lt; fileList.length; i++) {
            file = FileReference(fileList[i]);
            addPendingFile(file);
        }
    }
 
    private function cancelHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("cancelHandler: name=" + file.name);
    }
 
    private function openHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("openHandler: name=" + file.name);
    }
 
    private function progressHandler(event:ProgressEvent):void {
        var file:FileReference = FileReference(event.target);
        trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
    }
 
    private function completeHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("completeHandler: name=" + file.name);
        removePendingFile(file);
    }
 
    private function httpErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("httpErrorHandler: name=" + file.name);
    }
 
    private function ioErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("ioErrorHandler: name=" + file.name);
    }
 
    private function securityErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("securityErrorHandler: name=" + file.name + " event=" + event.toString());
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer im Dialogfeld zum Suchen von Dateien eine oder mehrere Dateien für einen Upload-Vorgang auswählt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the usage of the <code>select</code> event.
 <listing version="2.0">
 import flash.net.FileReferenceList;
 import flash.net.FileReference;
 
 var listener:Object = new Object();
 
 listener.onSelect = function(fileRefList:FileReferenceList) {
 	trace("onSelect");
 	var list:Array = fileRefList.fileList;
 	var item:FileReference;
 	for(var i:Number = 0; i &lt; list.length; i++) {
 		item = list[i];
 		trace("name: " + item.name);
 		trace(item.addListener(this));
 		item.upload("http://www.yourdomain.com/");
 	}
 }
 
 listener.onComplete = function(file:FileReference):void {
 	trace("onComplete: " + file.name);
 }
 
 var fileRef:FileReferenceList = new FileReferenceList();
 fileRef.addListener(listener);
 fileRef.browse();
 </listing>
 </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer im Dialogfeld zum Suchen von Dateien eine oder mehrere Dateien für einen Upload-Vorgang auswählt. (Dieses Dialogfeld wird beim Aufruf der Methode <codeph>FileReferenceList.browse()</codeph>, <codeph>FileReference.browse()</codeph> oder <codeph>FileReference.download()</codeph> geöffnet.) Wenn der Benutzer eine Datei auswählt und den Vorgang bestätigt (z. B. durch Klicken auf „Speichern“), wird das <codeph>FileReferenceList</codeph>-Objekt mit den Daten der FileReference-Objekte aktualisiert, die die vom Benutzer ausgewählten Dateien darstellen.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Wird ausgelöst, wenn der Benutzer das Dialogfeld zum Suchen von Dateien abbricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Benutzer das Dialogfeld zum Suchen von Dateien abbricht. (Dieses Dialogfeld wird beim Aufruf der Methode <codeph>FileReferenceList.browse()</codeph>, <codeph>FileReference.browse()</codeph> oder <codeph>FileReference.download()</codeph> geöffnet.)
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:FileReferenceList:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 	 Erstellt ein neues FileReferenceList-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReferenceList</code> object,
	 iterates over each selected file, and outputs their names.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var arr:Array = fileRefList.fileList;
	 	for(var i:Number = 0; i &lt; arr.length; i++) {
	 		trace("name: " + arr[i].name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
  	 
  	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 	 Erstellt ein neues FileReferenceList-Objekt. Ein FileReferenceList-Objekt enthält keine Werte, bis Sie dafür die Methode <codeph>browse()</codeph> aufrufen und der Benutzer eine oder mehrere Dateien auswählt. Beim Aufruf von <codeph>browse()</codeph> für das FileReferenceList-Objekt wird die Eigenschaft <codeph>fileList</codeph> des Objekts mit einem Array von <codeph>FileReference</codeph>-Objekten aktualisiert.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReferenceList:browse"><apiName>browse</apiName><shortdesc>
	 Zeigt ein Dialogfeld zum Suchen von Dateien an, in dem der Benutzer eine oder mehrere lokal gespeicherte Dateien für einen Upload-Vorgang auswählen kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample><pre>
	 // ask the user to choose an image file for upload
	 var fileRef = new FileReference();
	 if (fileRef.browse(["Images", "jpg;gif;png", "Flash Movies", "swf"])) {
	   trace("Opened " + fileRef.name);
	 } else {
	   trace("User canceled");
	 }
	 </pre>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird aufgrund der folgenden Ursachen ausgelöst: 1) Es wird bereits eine FileReference- oder FileReferenceList-Suchsitzung ausgeführt. Es können nicht mehrere Suchsitzungen gleichzeitig ausgeführt werden. 2) Der Vorgang wird durch eine Einstellung in der Datei „mms.cfg“ des Benutzers verhindert. 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die FileFilter-Objekte im Array <codeph>typeFilter</codeph> nicht richtig formatiert sind, wird eine Ausnahme ausgelöst. Weitere Informationen über das richtige Filterformat finden Sie in der Dokumentation zu „FileFilter“.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Methode nicht als Reaktion auf eine Benutzeraktion, z. B. Mausereignis oder Tastendruckereignis, aufgerufen wird.
     
	  
	  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Gibt <codeph>true</codeph> zurück, wenn die Parameter gültig sind und das Dialogfeld für die Dateisuche geöffnet wird.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit FileFilter-Instanzen zur Filterung der im Dialogfeld angezeigten Dateien. Wenn Sie diesen Parameter weglassen, werden alle Dateien angezeigt. Weitere Informationen finden Sie im Abschnitt zur Klasse <xref href="FileFilter.html">FileFilter</xref>. 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Zeigt ein Dialogfeld zum Suchen von Dateien an, in dem der Benutzer lokale Dateien für einen Upload-Vorgang auswählen kann.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Zeigt ein Dialogfeld zum Suchen von Dateien an, in dem der Benutzer eine oder mehrere lokal gespeicherte Dateien für einen Upload-Vorgang auswählen kann. Das Dialogfeld stammt vom Betriebssystem des Benutzers.
	 
	 <p platform="actionscript">In Flash Player 10 und höher können Sie diese Methode nur erfolgreich als Antwort auf ein Benutzerereignis (z. B. in einer Ereignisprozedur für ein Mausklick- oder Tastendruckereignis) aufrufen. Andernfalls wird beim Aufrufen dieser Methode in Flash Player ein Fehler zurückgegeben.</p>
	 
	 <p>Wenn diese Methode aufgerufen wird und ein Benutzer erfolgreich Dateien ausgewählt hat, wird die Eigenschaft <codeph>fileList</codeph> dieses FileReferenceList-Objekts mit einem Array von FileReference-Objekten aktualisiert (ein Objekt pro vom Benutzer ausgewählter Datei). Bei jedem nachfolgenden Aufruf der Methode „FileReferenceList.browse()“ wird die Eigenschaft <codeph>FileReferenceList.fileList</codeph> auf die vom Benutzer im Dialogfeld ausgewählten Dateien zurückgesetzt.</p>
	 
	 <p>Mit dem Parameter <codeph>typeFilter</codeph> können Sie festlegen, welche Dateien im Dialogfeld angezeigt werden.</p>
	 
	 <p>Für ein FileReferenceList-Objekt kann immer nur jeweils eine <codeph>FileReference.browse()</codeph>-, <codeph>FileReference.download()</codeph>- oder <codeph>FileReferenceList.browse()</codeph>-Sitzung ausgeführt werden, da immer nur ein Dialogfeld geöffnet werden kann.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference"><linktext>FileReference-Klasse</linktext></link><link href="flash.net.xml#FileFilter"><linktext>FileFilter-Klasse</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Benutzer erfolgreich ein Element für den Upload-Vorgang aus dem Dialogfeld ausgewählt hat.
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Benutzer erfolgreich ein Element für den Upload-Vorgang aus dem Dialogfeld ausgewählt hat.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird aufgerufen, wenn der Benutzer das Dialogfeld abbricht oder schließt.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird aufgerufen, wenn der Benutzer das Dialogfeld abbricht oder schließt.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReferenceList:fileList:get"><apiName>fileList</apiName><shortdesc>
	 Ein Array von FileReference-Objekten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example demonstrates the <code>fileList</code> property.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 import flash.net.FileReference;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var list:Array = fileRefList.fileList;
	 	var item:FileReference;
	 	for(var i:Number = 0; i &lt; list.length; i++) {
	 		item = list[i];
	 		trace("name: " + item.name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
	 
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>Ein Array von FileReference-Objekten.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein Array von <codeph>FileReference</codeph>-Objekten.
	 
	 <p>Wenn die Methode <codeph>FileReferenceList.browse()</codeph> aufgerufen wurde und ein Benutzer mindestens eine Datei aus dem mit der Methode <codeph>browse()</codeph> geöffneten Dialogfeld ausgewählt hat, wird diese Eigenschaft mit einem Array von FileReference-Objekten aktualisiert, die die vom Benutzer ausgewählten Dateien darstellen. Sie können dieses Array verwenden, um die einzelnen Dateien mit der Methode <codeph>FileReference.upload()</codeph> hochzuladen. Sie können nicht mehrere Dateien auf einmal hochladen.</p>
	 
	 <p>Die Eigenschaft <codeph>fileList</codeph> wird bei jedem Aufruf von „browse()“ für das FileReferenceList-Objekt aktualisiert.</p>
	 
	 <p>Die Eigenschaften der <codeph>FileReference</codeph>-Objekte sind in der Dokumentation der FileReference-Klasse beschrieben.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileReference"><apiName>FileReference</apiName><shortdesc>
  Die FileReference-Klasse stellt eine Möglichkeit dar, Dateien zwischen dem Computer eines Benutzers und einem Server hoch- bzw. herunterzuladen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReference, FileReference.browse, FileReference.download, FileReference.create, browse, download, create
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  Die FileReference-Klasse stellt eine Möglichkeit dar, Dateien zwischen dem Computer eines Benutzers und einem Server hoch- bzw. herunterzuladen. Anhand eines Dialogfelds des Betriebssystems wird der Benutzer aufgefordert, eine hochzuladende Datei oder eine Position für den Download auszuwählen. Jedes FileReference-Objekt verweist auf eine Datei auf der Festplatte des Benutzercomputers und stellt Eigenschaften bereit, die die Größe der Datei, ihren Typ, den Namen, das Erstellungs- und das Änderungsdatum sowie bei Macintosh den Erstellertyp enthalten. 
  
  <p><b>Hinweis:</b> In Adobe AIR bietet die File-Klasse, die die FileReference-Klasse erweitert, mehr Fähigkeiten und hat weniger Sicherheitseinschränkungen als die FileReference-Klasse.</p>
  
  <p>FileReference-Instanzen können auf die folgenden Weisen erstellt werden:</p>
  <ul>
  <li>Mit dem Operator <codeph>new</codeph> und dem FileReference-Konstruktor: <codeph>var myFileReference = new FileReference();</codeph></li>
  
  <li>Durch Aufruf der Methode <codeph>FileReferenceList.browse()</codeph>, wodurch ein Array mit den FileReference-Objekten erstellt wird.</li>
  </ul>
  
  <p>Bei einem Upload-Vorgang werden den Eigenschaften eines FileReference-Objekts durch Aufrufe von <codeph>FileReference.browse()</codeph>oder <codeph>FileReferenceList.browse()</codeph>-Werte zugewiesen. Bei einem Download-Vorgang wird der Eigenschaft <codeph>name</codeph> ein Wert zugewiesen, wenn das Ereignis <codeph>select</codeph> ausgelöst wird. Die Werte aller anderen Eigenschaften werden bei Auslösung des Ereignisses <codeph>complete</codeph> zugewiesen.</p>
  
  <p>Mit der Methode <codeph>browse()</codeph> wird ein Dialogfeld des Betriebssystems geöffnet, in dem der Benutzer zur Auswahl einer Datei für den Upload-Vorgang aufgefordert wird. Mithilfe der <codeph>FileReference.browse()</codeph>-Methode kann ein Benutzer eine einzelne Datei auswählen. <codeph>FileReferenceList.browse()</codeph> ermöglicht die Auswahl mehrerer Dateien. Nach einem erfolgreichen Aufruf der <codeph>browse()</codeph>-Methode können Sie die <codeph>FileReference.upload()</codeph>-Methode aufrufen, um jeweils eine Datei hochzuladen. Die <codeph>FileReference.download()</codeph>-Methode fordert den Benutzer zur Eingabe eines Speicherorts für die Datei auf und startet den Download der Datei von einer anderen URL.</p>
  
  <p>Allerdings kann mit den Klassen FileReference und FileReferenceList der Standardspeicherort für das mit der Methode <codeph>browse()</codeph> oder <codeph>download()</codeph> generierte Dialogfeld nicht festgelegt werden. Der im Dialogfeld angegebene Standardspeicherort ist der zuletzt durchsuchte Ordner, sofern dieser Speicherort festgestellt werden kann, oder der Desktop. Die Klassen ermöglichen keine Lese- bzw. Schreibvorgänge bei den übertragenen Dateien. Über die SWF-Datei, mit der der Upload- bzw. Download-Vorgang eingeleitet wurde, besteht kein Zugriff auf die hoch- oder heruntergeladene Datei bzw. deren Speicherort auf der Festplatte des Benutzers.</p>
  
  <p>Darüber hinaus gibt es bei den FileReference- und FileReferenceList-Klassen keine Authentifizierungsverfahren. Sollte ein Server also eine Authentifizierung erforderlich machen, können Sie Dateien zwar mit dem Browser-Plug-In von Flash<sup>®</sup> Player herunterladen, mit dem eigenständigen oder externen Player jedoch nicht. Upload-Vorgänge sind mit keinem Player möglich. Mithilfe von FileReference-Ereignis-Listenern können Sie feststellen, ob ein Vorgang erfolgreich ausgeführt wurde, und gegebenenfalls Fehler beheben.</p>
  
  <p>Wenn <ph platform="actionscript">Inhalt in Flash Player oder</ph> außerhalb der Sicherheitssandbox der Anwendung in Adobe AIR ausgeführt wird, können Upload- und Download-Vorgänge nur auf Dateien in der eigenen Domäne und in Domänen, die in einer URL-Richtliniendatei angegeben sind, zugreifen. Wenn sich der Inhalt, mit dem die Upload- bzw. Download-Vorgänge gestartet werden, nicht in derselben Domäne befindet wie der Dateiserver, legen Sie eine entsprechende Richtliniendatei auf dem Dateiserver ab.</p>
  
  <p>Beachten Sie, dass aufgrund neuer zusätzlicher Funktionalität von Flash Player beim Veröffentlichen in Flash Player 10 immer nur einer der folgenden Vorgänge aktiv sein kann: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. Ansonsten gibt Flash Player einen Laufzeitfehler (Code 2174) aus. Stoppen Sie den laufenden Vorgang mithilfe von <codeph>FileReference.cancel()</codeph>. Diese Einschränkung betrifft lediglich Flash Player 10. Ältere Versionen von Flash Player sind von den Einschränkungen bezüglich gleichzeitig ausgeführter Vorgänge nicht betroffen.</p>
  
  <p platform="actionscript">Wenn eine <codeph>FileReference.browse()</codeph>-, <codeph>FileReferenceList.browse()</codeph>- oder <codeph>FileReference.download()</codeph>-Methode aufgerufen wird, wird die Wiedergabe von SWF-Dateien in der eigenständigen und der externen Version von Flash Player und in AIR für Linux und Mac OS X 10.1 und früheren Versionen unterbrochen.</p>
  
  <p platform="actionscript">Die folgende HTTP-<codeph>POST</codeph>-Anforderung wird von Flash Player an ein serverseitiges Skript gesendet, wenn keine Parameter angegeben wurden:
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  
  <p platform="actionscript">Flash Player sendet die folgende HTTP-<codeph>POST</codeph>-Anforderung, wenn der Benutzer die Parameter <codeph>"api_sig"</codeph>, <codeph>"api_key"</codeph> und <codeph>"auth_token"</codeph> angibt:
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_sig"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_key"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="auth_token"
  
  XXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  </apiDesc><example conref="examples\FileReferenceExample.as"> Im folgenden Beispiel werden Informationen zu Datenformat und Status einer zur Laufzeit geladenen Datei angezeigt.  
 <p> <b>Hinweis:</b> Ändern Sie zur Ausführung dieses Beispiels die Eigenschaft „uploadURL.url“ so, dass sie auf eine tatsächliche URL verweist. Die URL muss auf eine Datei mit dem Namen <codeph>yourUploadHandlerScript.cfm</codeph> im Stammverzeichnis des Webservers der angegebenen URL verweisen. Abhängig von der Konfiguration müssen Sie außerdem ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen.
 </p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileFilter;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReferenceExample extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReferenceExample() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            configureListeners(file);
            file.browse(getTypes());
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
            dispatcher.addEventListener(DataEvent.UPLOAD_COMPLETE_DATA,uploadCompleteDataHandler);
        }

        private function getTypes():Array {
            var allTypes:Array = new Array(getImageTypeFilter(), getTextTypeFilter());
            return allTypes;
        }

        private function getImageTypeFilter():FileFilter {
            return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
        }

        private function getTextTypeFilter():FileFilter {
            return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function uploadCompleteDataHandler(event:DataEvent):void {
            trace("uploadCompleteData: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReferenceList"><linktext>flash.net.FileReferenceList</linktext></link><link href="flash.filesystem.xml#File"><linktext>flash.filesystem.File</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference_flash.events.DataEvent.UPLOAD_COMPLETE_DATA_uploadCompleteData"><apiName>uploadCompleteData</apiName><shortdesc>
    Wird ausgelöst, nachdem die Daten vom Server nach einem erfolgreichen Upload empfangen wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.UPLOAD_COMPLETE_DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
    Wird ausgelöst, nachdem die Daten vom Server nach einem erfolgreichen Upload empfangen wurden. Das Ereignis wird nur ausgelöst, wenn Daten vom Server zurückgegeben werden.
    </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
	 Wird ausgelöst, wenn ein Aufruf der upload()- oder uploadUnencoded()-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Wird ausgelöst, wenn ein Aufruf der <codeph>upload()</codeph>- oder <codeph>uploadUnencoded()</codeph>-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann. 
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link><link href="flash.net.xml#FileReference/uploadUnencoded()"><linktext>uploadUnencoded()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
     Wird ausgelöst, wenn ein Upload-Vorgang fehlschlägt und HTTP-Statuscode zur Beschreibung des Fehlers verfügbar ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Wird ausgelöst, wenn ein Upload-Vorgang fehlschlägt und HTTP-Statuscode zur Beschreibung des Fehlers verfügbar ist. Das Ereignis <codeph>httpStatus</codeph> wird gefolgt von einem <codeph>ioError</codeph>-Ereignis ausgelöst.
     
     <p>Das Ereignis <codeph>httpStatus</codeph> wird nur bei Upload-Fehlern ausgelöst. Bei Inhalt, der im Flash Player ausgeführt wird, gilt dieses Ereignis nicht für fehlgeschlagene Downloads. Wenn ein Download mit einem HTTP-Fehler abbricht, wird dieser Fehler als I/O-Fehler gemeldet.</p>
     
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
	Wird ausgelöst, wenn der Benutzer im Dialogfeld zum Suchen von Dateien eine Datei für einen Upload- oder Download-Vorgang auswählt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Wird ausgelöst, wenn der Benutzer im Dialogfeld zum Suchen von Dateien eine Datei für einen Upload- oder Download-Vorgang auswählt. (Dieses Dialogfeld wird beim Aufruf der Methode <codeph>FileReferenceList.browse()</codeph>, <codeph>FileReference.browse()</codeph> oder <codeph>FileReference.download()</codeph> geöffnet.) Sobald ein Benutzer eine Datei auswählt und den Vorgang bestätigt (z. B. durch Klicken auf „OK“), werden die Eigenschaftenfelder des FileReference-Objekts mit Daten gefüllt.
    
    <p>Bei Inhalt, der <ph platform="actionscript">in Flash Player oder</ph>außerhalb der Sicherheitssandbox der Anwendung <ph platform="actionscript">in der Adobe AIR-Laufzeitumgebung</ph> ausgeführt wird, verhält sich das <codeph>select</codeph>-Ereignis je nachdem, welche Methode es aufgerufen hat, leicht unterschiedlich. Wenn das Ereignis <codeph>select</codeph> nach einem <codeph>browse()</codeph>-Aufruf ausgelöst wird, können sämtliche Eigenschaften des FileReference-Objekts von <ph platform="actionscript">Flash Player oder </ph>der AIR-Anwendung gelesen werden, da sich die vom Benutzer ausgewählte Datei im lokalen Dateisystem befindet. Wenn das Ereignis <codeph>select</codeph> nach einem <codeph>download()</codeph>-Aufruf ausgelöst wird, kann <ph platform="actionscript">Flash Player oder </ph>die AIR-Anwendung lediglich die <codeph>name</codeph>-Eigenschaft lesen, da die Datei zu dem Zeitpunkt der Auslösung des <codeph>select</codeph>-Ereignisses noch nicht in das lokale Dateisystem heruntergeladen wurde. Nachdem die Datei heruntergeladen und das <codeph>complete</codeph>-Ereignis ausgelöst wurde, können alle anderen Eigenschaften des FileReference-Objekts von <ph platform="actionscript">Flash Player oder </ph>der AIR-Anwendung gelesen werden.</p>
    
    </apiDesc><example conref="examples\FileReference_event_select.as"> Im folgenden Beispiel wird die Verwendung des Ereignisobjekts <codeph>select</codeph> gezeigt. Ändern Sie zur Ausführung dieses Beispiels die Eigenschaft von <codeph>uploadURL.url</codeph> so, dass sie auf eine tatsächliche Domäne und Datei anstatt auf die fiktive Datei[yourDomain].com/SomeFile.pdf verweist. Außerdem müssen Sie ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen. Damit Sie dieses Beispiel über Ihren Desktop ausführen können, müssen Sie auf dem Server eine crossdomain.xml-Datei ablegen. Wenn die Funktion <codeph>ioErrorHandler()</codeph> ausgelöst wird, müssen Sie die bereitgestellte <codeph>uploadURL</codeph> ggf. durch eine gültige URL ersetzen, die für den Empfang von Uploads konfiguriert ist.
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_select extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReference_event_select() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            file.addEventListener(Event.SELECT, selectHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.browse();
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
     Wird ausgelöst, wenn mit einem Aufruf der Methode „FileReference.upload()“ oder „FileReference.download()“ versucht wird, eine Datei auf einen Server zu laden oder von einem Server herunterzuladen, der sich außerhalb der Sicherheitssandbox des Aufrufers befindet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Wird ausgelöst, wenn mit einem Aufruf der Methode <codeph>FileReference.upload()</codeph> oder <codeph>FileReference.download()</codeph> versucht wird, eine Datei auf einen Server zu laden oder von einem Server herunterzuladen, der sich außerhalb der Sicherheitssandbox des Aufrufers befindet. Der Wert der Texteigenschaft zur Beschreibung des aufgetretenen Fehlers ist in der Regel <codeph>"securitySandboxError"</codeph>. Mit der aufrufenden SWF-Datei wurde unter Umständen versucht, ohne entsprechende Berechtigung auf eine SWF-Datei außerhalb ihrer Domäne zuzugreifen. Sie können versuchen, diesen Fehler zu beheben, indem Sie eine URL-Richtliniendatei verwenden.
     
     <p>In Adobe AIR gelten diese Sicherheitseinschränkungen nicht für Inhalt in der Sicherheitssandbox der Anwendung.</p>
     
	 <p>In Adobe AIR gelten diese Sicherheitseinschränkungen nicht für Inhalt in der Sicherheitssandbox der Anwendung.</p>
	 
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
	Wird regelmäßig während des Upload- bzw. Download-Vorgangs ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Wird regelmäßig während des Upload- bzw. Download-Vorgangs ausgelöst. Das Ereignis <codeph>progress</codeph> wird ausgelöst, während Flash Player Byte an einen Server sendet. Im Verlauf der Übertragung wird das Ereignis in regelmäßigen Abständen auch dann aufgerufen, wenn die Übertragung am Ende nicht erfolgreich abgeschlossen werden kann. Wenn Sie feststellen möchten, ob und zu welchem Zeitpunkt die Dateiübertragung erfolgreich abgeschlossen wird, verwenden Sie einen Listener für das <codeph>complete</codeph>-Ereignis.
    
    <p>In einigen Fällen werden keine <codeph>progress</codeph>-Ereignisse empfangen. Wenn die übertragene Datei beispielsweise sehr klein ist oder der Upload- bzw. Download-Vorgang in sehr kurzer Zeit erfolgt, wird möglicherweise kein <codeph>progress</codeph>-Ereignis ausgelöst.</p>
    
    <p>Bei Macintosh-Plattformen vor Version OS X 10.3 kann der Fortschritt von Upload-Vorgängen nicht festgestellt werden. Das <codeph>progress</codeph>-Ereignis wird zwar während des Upload-Vorgangs aufgerufen, die Eigenschaft <codeph>bytesLoaded</codeph> weist jedoch stets den Wert -1 auf, was bedeutet, dass der Fortschritt nicht festgestellt werden kann.</p>
    
    </apiDesc><example conref="examples\FileReference_event_progress.as"> Im folgenden Beispiel wird die Verwendung des Ereignisobjekts <codeph>progress</codeph> gezeigt. Ändern Sie zur Ausführung dieses Beispiels die Eigenschaft von <codeph>downloadURL.url</codeph> so, dass sie auf eine tatsächliche Domäne und Datei anstatt auf die fiktive URL http://www.[yourDomain].com/SomeFile.pdf verweist. Außerdem müssen Sie ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_progress extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_progress() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.download(downloadURL, fileName);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
        
        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/event:complete"><linktext>FileReference.complete</linktext></link><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
	Wird beim Start eines Upload- bzw. Download-Vorgangs ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>open</code> event.
    It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onOpen = function(file:FileReference):void {
      trace("onOpen: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Wird beim Start eines Upload- bzw. Download-Vorgangs ausgelöst.
    
    
    </apiDesc><example conref="examples\FileReference_download.as"> Im folgenden Beispiel wird die Verwendung des Ereignisobjekts <codeph>download</codeph> gezeigt. Ändern Sie zur Ausführung dieses Beispiels die Eigenschaft von <codeph>downloadURL.url</codeph> so, dass sie auf eine tatsächliche Domäne und Datei anstatt auf die fiktive URL http://www.[yourDomain].com/SomeFile.pdf verweist. Außerdem müssen Sie ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
	Wird ausgelöst, wenn der Upload- bzw. Download-Vorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>ioError</code> event. 
    Note that for simplicity, none of the other event types are used in this
    example.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onIOError = function(file:FileReference):void {
      trace("onIOError");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download("http://www.adobe.com/NonExistentFile.pdf", "NonExistentFile.pdf");
    
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Wird ausgelöst, wenn der Upload- bzw. Download-Vorgang fehlschlägt. Das Fehlschlagen einer Dateiübertragung kann folgende Ursachen haben:
    
    <ul>
    <li>Während des Lese-, Schreib- oder Übertragungsvorgangs der Datei ist ein I/O-Fehler aufgetreten.</li>
    <li>Die <ph platform="actionscript">SWF-Datei</ph><ph platform="javascript">AIR-Anwendung</ph> versucht, eine Datei auf einen Server hochzuladen, der eine Authentifizierung (z. B. anhand eines Benutzernamens und eines Kennworts) erfordert. Während des Uploads stellt <ph platform="actionscript">Flash Player bzw. </ph>die AIR-Anwendung keine Möglichkeit für die Eingabe von Kennwörtern durch die Benutzer bereit. Wenn eine <ph platform="actionscript">SWF-Datei</ph><ph platform="javascript">AIR-Anwendung</ph> versucht, eine Datei auf einen Server hochzuladen, der eine Authentifizierung erfordert, schlägt dieser Upload fehl.</li>
    <li>Die <ph platform="actionscript">SWF-Datei</ph><ph platform="javascript">AIR-Anwendung</ph> versucht, im eigenständigen oder externen Player eine Datei von einem Server herunterzuladen, der eine Authentifizierung erfordert. Während des Downloads stellt der eigenständige bzw. externe Player keine Möglichkeit für die Eingabe von Kennwörtern durch die Benutzer bereit. Wenn eine <ph platform="actionscript">SWF-Datei</ph><ph platform="javascript">AIR-Anwendung</ph> versucht, innerhalb dieser Player eine Datei von einem Server herunterzuladen, der eine Authentifizierung erfordert, schlägt dieser Download fehl. <ph platform="actionscript">Der Datei-Download kann nur in der ActiveX-Steuerung, in Browser-Plug-In-Playern und in der Adobe AIR-Laufzeitumgebung erfolgen.</ph></li>
    <li>Der an den Parameter <codeph>url</codeph> in der Methode <codeph>upload()</codeph> übergebene Wert enthält ein ungültiges Protokoll. Die zulässigen Protokolle sind HTTP und HTTPS.</li>
    </ul>
    
    <p platform="actionscript"><b>Wichtig:</b> Dialogfelder zur Eingabe eines Benutzernamens und Kennworts zur Benutzerauthentifizierung für anschließende Download-Vorgänge (und nichts anderes) können nur von Anwendungen, die in einem Browser ausgeführt werden (also Anwendungen, die das Browser-Zusatzmodul oder das ActiveX-Steuerelement verwenden) und von Inhalt angezeigt werden, der in Adobe AIR ausgeführt wird. Upload-Vorgänge mit der Zusatzmodul- oder ActiveX-Steuerelementversion bzw. Upload- und Download-Vorgänge mit dem eigenständigen oder externen Player schlagen fehl.</p>
    
    </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	Wird ausgelöst, wenn der Download-Vorgang abgeschlossen ist oder wenn beim Upload-Vorgang der HTTP-Statuscode 200 generiert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows usage of the <code>complete</code> event 
    listener. It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onComplete = function(file:FileReference):void {
      trace("onComplete: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Wird ausgelöst, wenn der Download-Vorgang abgeschlossen ist oder wenn beim Upload-Vorgang der HTTP-Statuscode 200 generiert wird. Bei Download-Vorgängen wird dieses Ereignis ausgelöst, wenn <ph platform="actionscript">Flash Player oder </ph>Adobe AIR den Download der gesamten Datei auf die Festplatte abgeschlossen hat. Bei Upload-Vorgängen wird dieses Ereignis ausgelöst, nachdem <ph platform="actionscript">Flash Player oder </ph>Adobe AIR vom empfangenden Server den HTTP-Statuscode 200 empfangen hat.
    
    </apiDesc><example conref="examples\FileReference_event_complete.as"> Im folgenden Beispiel wird die Verwendung des Ereignisobjekts <codeph>complete</codeph> gezeigt. Ändern Sie zur Ausführung dieses Beispiels die Eigenschaft von <codeph>downloadURL.url</codeph> so, dass sie auf eine tatsächliche Domäne und Datei anstatt auf die fiktive URL http://www.[yourDomain].com/SomeFile.pdf verweist. Außerdem müssen Sie ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_complete extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_complete() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
	Wird ausgelöst, wenn der Benutzer eine Upload- oder Download-Vorgang über das Dialogfeld zum Suchen von Dateien abbricht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example traces a message if the user dismisses the file-
    browsing dialog box. This method
    is triggered only if the user selects Cancel or presses the escape key after
    the dialog box opens.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onCancel = function(file:FileReference):void {
      trace("onCancel");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    if(!fileRef.download(url, "FlashPlatform.pdf")) {
      trace("dialog box failed to open.");
    }
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Wird ausgelöst, wenn der Benutzer eine Upload- oder Download-Vorgang über das Dialogfeld zum Suchen von Dateien abbricht. Flash Player löst dieses Ereignis nicht aus, wenn der Benutzer einen Upload bzw. Download auf andere Weise abbricht (durch Schließen des Browsers oder anhalten der aktuellen Anwendung).
    
    </apiDesc><example conref="examples\FileReference_event_cancel.as"> Im folgenden Beispiel wird die Verwendung des Ereignisobjekts <codeph>cancel</codeph> gezeigt. Ändern Sie zur Ausführung dieses Beispiels die Eigenschaft von <codeph>downloadURL.url</codeph> so, dass sie auf eine tatsächliche Domäne und Datei anstatt auf die fiktive URL http://www.[yourDomain].com/SomeFile.pdf verweist. Außerdem müssen Sie ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_cancel extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_cancel() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(Event.CANCEL, cancelHandler);
            file.download(downloadURL, fileName);
        }
        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:FileReference:FileReference"><apiName>FileReference</apiName><shortdesc>
    Erstellt ein neues FileReference-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReference</code> object and 
    initiates the download of a pdf file.
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    listener.onComplete = function(file:FileReference) {
      trace("onComplete : " + file.name);
    }
    
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    
    </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
    Erstellt ein neues FileReference-Objekt. Sobald dieses Objekt mit Daten versehen ist, wird ein FileReference-Objekt zu einer Datei auf der lokalen Festplatte eines Benutzers.
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReference:browse"><apiName>browse</apiName><shortdesc>
    Zeigt ein Dialogfeld für die Dateisuche an, in dem der Benutzer eine Datei für einen Upload-Vorgang auswählen kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>browse, FileReference.browse
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird in folgenden Situationen ausgelöst: 1) Es wird bereits eine FileReference- oder FileReferenceList-Suchsitzung ausgeführt. Es können nicht mehrere Suchsitzungen gleichzeitig ausgeführt werden. 2) Der Vorgang wird durch eine Einstellung in der Datei „mms.cfg“ des Benutzers verhindert.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn das Array <codeph>typeFilter</codeph> falsch formatierte FileFilter-Objekte enthält, wird eine Ausnahme ausgelöst. Informationen zum gültigen Format für FileFilter-Objekte finden Sie im Abschnitt zur Klasse <xref href="FileFilter.html">FileFilter</xref>.
  
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Methode nicht als Reaktion auf eine Benutzeraktion, z. B. Mausereignis oder Tastendruckereignis, aufgerufen wird.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Gibt <codeph>true</codeph> zurück, wenn die Parameter gültig sind und das Dialogfeld für die Dateisuche geöffnet wird.  
  
  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein Array mit FileFilter-Instanzen zur Filterung der im Dialogfeld angezeigten Dateien. Wenn Sie diesen Parameter weglassen, werden alle Dateien angezeigt. Weitere Informationen finden Sie im Abschnitt zur Klasse <xref href="FileFilter.html">FileFilter</xref>.
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Zeigt ein Dialogfeld für die Dateisuche an, in dem der Benutzer eine Datei für einen Upload-Vorgang auswählen kann. Das Dialogfeld stammt aus dem Betriebssystem des Benutzers. Der Benutzer kann eine Datei aus dem lokalen System oder aus anderen Systemen auswählen, z. B. über einen UNC-Pfad (Windows).
    
    <p><b>Hinweis:</b> Die in Adobe AIR verfügbare File-Klasse enthält Methoden für den Zugriff auf spezifischere Dialogfelder für die Auswahl von Systemdateien. Diese Methoden sind <codeph>File.browseForDirectory()</codeph>, <codeph>File.browseForOpen()</codeph>, <codeph>File.browseForOpenMultiple()</codeph> und <codeph>File.browseForSave()</codeph>.</p>
    
    <p>Wenn diese Methode aufgerufen wird und der Benutzer erfolgreich eine Datei auswählt, werden die Eigenschaften dieses FileReference-Objekts mit den Eigenschaftendaten der Datei aktualisiert. <codeph/> Es kann immer nur eine <codeph>browse()</codeph>- oder <codeph>download()</codeph>-Sitzung durchgeführt werden (da immer nur ein Dialogfeld aufgerufen werden kann).</p>
    
    <p>Mit dem Parameter <codeph>typeFilter</codeph> können Sie festlegen, welche Dateien im Dialogfeld angezeigt werden.</p>
    
    <p platform="actionscript">In Flash Player 10 und Flash Player 9 mit Update 5 können Sie diese Methode nur als Reaktion auf ein Benutzerereignis erfolgreich aufrufen, z. B. in einer Ereignisprozedur für ein Mausklick- oder Tastendruckereignis. Andernfalls führt das Aufrufen dieser Methode dazu, dass Flash Player einen Ausnahmefehler ausgibt.</p>
    
    <p platform="actionscript">Beachten Sie, dass aufgrund neuer zusätzlicher Funktionalität von Flash Player beim Veröffentlichen in Flash Player 10 immer nur einer der folgenden Vorgänge aktiv sein kann: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. Ansonsten gibt Flash Player einen Laufzeitfehler (Code 2174) aus. Stoppen Sie den laufenden Vorgang mithilfe von <codeph>FileReference.cancel()</codeph>. Diese Einschränkung betrifft lediglich Flash Player 10. Ältere Versionen von Flash Player sind von den Einschränkungen bezüglich gleichzeitig ausgeführter Vorgänge nicht betroffen.</p> 
    
  </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/event:select"><linktext>select-Ereignis</linktext></link><link href="flash.net.xml#FileReference/event:cancel"><linktext>cancel-Ereignis</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForDirectory().xml"><linktext>File.browseForDirectory()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpen().xml"><linktext>File.browseForOpen()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpenMultiple().xml"><linktext>File.browseForOpenMultiple()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForSave().xml"><linktext>File.browseForSave()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Benutzer erfolgreich ein Element aus der Dateiauswahl wählt.
  </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Benutzer erfolgreich ein Element aus der Dateiauswahl wählt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Benutzer das Fenster zum Suchen einer Datei für den Upload-Vorgang schließt.
  
  </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Benutzer das Fenster zum Suchen einer Datei für den Upload-Vorgang schließt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:cancel"><apiName>cancel</apiName><shortdesc>
  Bricht alle laufenden Upload- bzw. Download-Vorgänge dieses FileReference-Objekts ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>cancel, FileReference.cancel
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Bricht alle laufenden Upload- oder Download-Vorgänge ab.
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Bricht alle laufenden Upload- bzw. Download-Vorgänge dieses FileReference-Objekts ab. Durch Aufruf dieser Methode wird nicht das Ereignis <codeph>cancel</codeph> ausgelöst. Dieses Ereignis wird nur ausgelöst, wenn der Benutzer den Vorgang abbricht, indem er das Dialogfeld für den Upload- bzw. Download-Vorgang schließt.
  
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:FileReference:download"><apiName>download</apiName><shortdesc>
    Öffnet ein Dialogfeld, mit dem der Benutzer eine Datei von einem Remote-Server herunterladen kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird in folgenden Situationen ausgelöst: 1) Es wird bereits eine Suchsitzung ausgeführt. Es können nicht mehrere Suchsitzungen gleichzeitig ausgeführt werden. 2) Der an <codeph>request</codeph> übergebene Wert enthält keinen gültigen Pfad/kein gültiges Protokoll. 3) Der Name der für den Download-Vorgang ausgewählten Datei enthält unzulässige Zeichen. 4) Der Vorgang wird durch eine Einstellung in der Datei „mms.cfg“ des Benutzers verhindert.
    
    	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Über lokalen nicht vertrauenswürdigen Inhalt kann keine Verbindung mit dem Internet hergestellt werden. Sie können dieses Problem vermeiden, indem Sie die SWF-Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren. Diese Ausnahme wird mit einer Meldung ausgelöst, die den Dateinamen und die URL enthält, auf die aufgrund der Sicherheitsbeschränkungen für lokale Dateien nicht zugegriffen werden kann.
    
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
    
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn <codeph>url.data</codeph> den Typ „ByteArray“ aufweist, wird eine Ausnahme ausgelöst. Bei Verwendung mit den Methoden <codeph>FileReference.upload()</codeph> und <codeph>FileReference.download()</codeph> sind für <codeph>url.data</codeph> nur die Typen „URLVariables“ und „String“ zulässig.
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann folgende Ursachen haben: 1) Flash Player kann den Parameter <codeph>URLRequest.data</codeph> nicht von UTF8 in MBCS konvertieren. Dieser Fehler trifft zu, wenn das an die Methode <codeph>FileReference.download()</codeph> übergebene URLRequest-Objekt auf die Ausführung eines GET-Vorgangs eingestellt ist und wenn <codeph>System.useCodePage</codeph> auf <codeph>true</codeph> gesetzt ist. 2) Flash Player kann <codeph>POST</codeph>-Daten keinen Speicher zuweisen. Dieser Fehler trifft zu, wenn das an die Methode <codeph>FileReference.download()</codeph> übergebene URLRequest-Objekt auf die Ausführung eines <codeph>POST</codeph>-Vorgangs eingestellt ist.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Methode nicht als Reaktion auf eine Benutzeraktion, z. B. Mausereignis oder Tastendruckereignis, aufgerufen wird.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Das URLRequest-Objekt. Die Eigenschaft <codeph>url</codeph> des URLRequest-Objekts muss die URL der Datei enthalten, die auf den lokalen Computer heruntergeladen werden soll. Wenn dieser Parameter den Wert <codeph>null</codeph> aufweist, wird eine Ausnahme ausgelöst. Die <codeph>requestHeaders</codeph>-Eigenschaft des URLRequest-Objekts wird ignoriert. Benutzerdefinierte HTTP-Anforderungs-Header werden in Uploads und Downloads nicht unterstützt. Um <codeph>POST</codeph>- bzw. GET-Parameter an den Server zu senden, setzen Sie den Wert von <codeph>URLRequest.data</codeph> auf Ihre Parameter und <codeph>URLRequest.method</codeph> entweder auf <codeph>URLRequestMethod.POST</codeph> oder auf <codeph>URLRequestMethod.GET</codeph>.
    
    	<p platform="actionscript">Bei einigen Browsern sind URL-Strings in ihrer Länge beschränkt. So können URLs mit über 256 Zeichen unter Umständen bei einigen Browsern oder Servern fehlschlagen.</p>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Standarddateiname der herunterzuladenden Datei, der im Dialogfeld angezeigt wird. Dieser String darf keines der folgenden Zeichen enthalten: / \ : ~~ ? " &lt; > | %
    <p>Wenn Sie diesen Parameter weglassen, wird der Dateiname der Remote-URL analysiert und als Standarddateiname verwendet. </p>
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Öffnet ein Dialogfeld, mit dem der Benutzer eine Datei von einem Remote-Server herunterladen kann. <ph platform="actionscript">In Flash Player ist kein Grenzwert für die Größe der Dateien für Upload- und Download-Vorgänge festgelegt. Offiziell unterstützt der Player Dateigrößen von bis zu 100 MB.</ph>
    
    <p>Mit der Methode <codeph>download()</codeph> wird zunächst ein Dialogfeld des Betriebssystems geöffnet, in dem der Benutzer aufgefordert wird, einen Dateinamen einzugeben und einen Ordner zum Speichern der Datei auf dem lokalen Computer auszuwählen. Wenn der Benutzer den Speicherort auswählt und den Download-Vorgang bestätigt (z. B. durch Klicken auf „Speichern“), wird der Download vom Remote-Server gestartet. Listener erhalten Ereignisdaten und zeigen den Fortschritt, den Erfolg oder den Fehlschlag des Downloads an. Um den Status des Dialogfelds und des Download-Vorgangs nach dem <codeph>download</codeph>-Aufruf ermitteln zu können, muss der Code Listener für Ereignisse wie <codeph>cancel</codeph>, <codeph>open</codeph>, <codeph>progress</codeph> und <codeph>complete</codeph> enthalten.
    </p>
    
    <p>Die Funktionen <codeph>FileReference.upload()</codeph> und <codeph>FileReference.download()</codeph> sind ungeblockt. Die Funktionsrückgaben erfolgen nach dem Aufruf vor Abschluss der Dateiübertragung. Wenn bei einem FileReference-Objekt der Gültigkeitsbereich verlassen wird, werden alle zu dem Zeitpunkt noch nicht abgeschlossenen Upload- bzw. Download-Vorgänge für dieses Objekt abgebrochen. Stellen Sie sicher, dass das FileReference-Objekt während der gesamten Dauer des Upload- bzw. Download-Vorgangs den Gültigkeitsbereich nicht verlässt.</p>
    
    <p>Nach erfolgreich abgeschlossenem Download-Vorgang werden die Eigenschaften des FileReference-Objekts mit den Eigenschaften der lokalen Datei aktualisiert. Bei erfolgreichem Abschluss des Download-Vorgangs wird das Ereignis <codeph>complete</codeph> ausgelöst.</p>
    
    <p>Es kann immer nur eine <codeph>browse()</codeph>- oder <codeph>download()</codeph>-Sitzung durchgeführt werden (da immer nur ein Dialogfeld aufgerufen werden kann).</p>
    
    <p>Diese Methode unterstützt den Download jedes Dateityps mit HTTP oder HTTPS.</p>
    
     <p>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
    
    <p><b>Hinweis</b>: Wenn der Server eine Benutzerauthentifizierung erfordert, kann der Benutzer nur bei SWF-Dateien, die in einem Browser (also mit einem Browser-Plug-In oder einer ActiveX-Steuerung) ausgeführt werden, in einem Dialogfeld zur Eingabe eines Benutzernamens und eines Kennworts zur Authentifizierung aufgefordert werden. Dies gilt darüber hinaus nur für Download-Vorgänge. Upload-Vorgänge mit Plug-Ins oder ActiveX-Steuerelementen bzw. Upload- und Download-Vorgänge mit dem eigenständigen oder externen Player schlagen fehl.</p>
    
    <p>Wenn Sie diese Methode <ph platform="javascript">für Inhalt in anderen Sicherheitssandboxen als der Sicherheitssandbox der Anwendung</ph> verwenden, ziehen Sie das <ph platform="actionscript">Flash Player</ph><ph platform="javascript">AIR</ph>-Sicherheitsmodell in Betracht: </p>
    
    <ul>
    <li>Ladevorgänge sind nicht zulässig, wenn die aufrufende SWF-Datei sich in einer nicht vertrauenswürdigen lokalen Sandbox befindet.</li>
    
    <li>Standardmäßig werden Sandbox-übergreifende Zugriffe nicht zugelassen. Eine Website kann den Zugriff auf eine Ressource durch das Hinzufügen einer URL-Richtliniendatei ermöglichen.</li>
    
    <li platform="actionscript">Sie können eine SWF-Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</li>
    
    <li platform="actionscript">In Flash Player 10 und Flash Player 9 mit Update 5 können Sie diese Methode nur als Reaktion auf ein Benutzerereignis erfolgreich aufrufen, z. B. in einer Ereignisprozedur für ein Mausklick- oder Tastendruckereignis. Andernfalls führt das Aufrufen dieser Methode dazu, dass Flash Player einen Ausnahmefehler ausgibt.</li>
    
    </ul>
    
    <p><ph platform="actionscript">In Adobe AIR</ph> dagegen ist Inhalt in der <codeph>Sicherheitssandbox der Anwendung</codeph> (mit der AIR-Anwendung installierter Inhalt) nicht durch diese Sicherheitseinschränkungen beschränkt.</p>
    
    <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
    
    <ul>
           
    <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
    
    <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
    
    <li>Der Abschnitt „Understanding AIR Security“ des Kapitels „Getting started with Adobe AIR“ im Handbuch <i>Developing AIR Applications</i>.</li>
    
    <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
    
    </ul>
    
    <p>Beachten Sie, dass aufgrund neuer zusätzlicher Funktionalität von Flash Player beim Veröffentlichen in Flash Player 10 immer nur einer der folgenden Vorgänge aktiv sein kann: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. Ansonsten gibt Flash Player einen Laufzeitfehler (Code 2174) aus. Stoppen Sie den laufenden Vorgang mithilfe von <codeph>FileReference.cancel()</codeph>. Diese Einschränkung betrifft lediglich Flash Player 10. Ältere Versionen von Flash Player sind von den Einschränkungen bezüglich gleichzeitig ausgeführter Vorgänge nicht betroffen.</p> 
	
    </apiDesc><example conref="examples\FileReference_download.as"> Im folgenden Beispiel wird die Verwendung des Ereignisobjekts <codeph>download</codeph> gezeigt. Ändern Sie zur Ausführung dieses Beispiels die Eigenschaft von <codeph>downloadURL.url</codeph> so, dass sie auf eine tatsächliche Domäne und Datei anstatt auf die fiktive URL http://www.[yourDomain].com/SomeFile.pdf verweist. Außerdem müssen Sie ggf. die SWF-Datei unter Verwendung der Einstellung „Nur auf Netzwerk zugreifen“ für die Option „Sicherheit bei lokaler Wiedergabe“ kompilieren oder die Flash Player-Sicherheitseinstellungen ändern, um den Netzwerkzugriff für diese Datei zuzulassen.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:download_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Download-Vorgang gestartet wird.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Download-Vorgang gestartet wird.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird regelmäßig während des Download-Vorgangs ausgelöst.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird regelmäßig während des Download-Vorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Download einer Datei erfolgreich abgeschlossen wurde.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Download einer Datei erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Benutzer das Dialogfeld abbricht.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Benutzer das Dialogfeld abbricht.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Benutzer in einem Dialogfeld eine Datei für einen Download-Vorgang auswählt. 
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Benutzer in einem Dialogfeld eine Datei für einen Download-Vorgang auswählt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Download-Vorgang aufgrund eines Sicherheitsfehlers abgebrochen wird.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Download-Vorgang aufgrund eines Sicherheitsfehlers abgebrochen wird.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird aus einem der folgenden Gründe ausgelöst:
    <ul>
    <li>Beim Lesen oder Übertragen der Datei tritt ein I/O-Fehler auf.</li>
    	<li>SWF-Inhalt in der eigenständigen oder in externen Version von Flash Player versucht, eine Datei von einem Server herunterzuladen, für den eine Authentifizierung erforderlich ist. Während des Downloads stellt der eigenständige bzw. externe Player keine Möglichkeit für die Eingabe von Kennwörtern durch die Benutzer bereit. Wenn mit einer SWF-Datei versucht wird, innerhalb dieser Player eine Datei von einem Server herunterzuladen, der eine Authentifizierung erfordert, schlägt dieser Download fehl. Der Download von Dateien funktioniert grundsätzlich nur bei einer ActiveX-Steuerung oder bei Plug-In-Playern von Browsern.</li>
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>Wird aufgrund einer der folgenden Ursachen ausgelöst: Während des Lese- bzw. Übertragungsvorgangs der Datei ist ein I/O-Fehler aufgetreten. SWF-Inhalt in der eigenständigen oder in externen Version von Flash Player versucht, eine Datei von einem Server herunterzuladen, für den eine Authentifizierung erforderlich ist.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:load"><apiName>load</apiName><shortdesc>
    Startet das Laden einer lokalen Datei, die vom einem Benutzer ausgewählt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>load, FileReference.load
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird in folgenden Situationen ausgelöst: 1) Es wird bereits eine FileReference- oder FileReferenceList-Suchsitzung ausgeführt. Es können nicht mehrere Suchsitzungen gleichzeitig ausgeführt werden. 2) Der Vorgang wird durch eine Einstellung in der Datei „mms.cfg“ des Benutzers verhindert.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann auftreten, wenn die Anwendung keinen Speicher für die Datei zuordnen kann. Die Datei ist möglicherweise zu groß oder der verfügbare Speicherplatz reicht nicht aus.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Startet das Laden einer lokalen Datei.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Startet das Laden einer lokalen Datei, die vom einem Benutzer ausgewählt wurde. <ph platform="actionscript">In Flash Player bestehen zwar keine Beschränkungen bezüglich der Größe von Dateien, die hochgeladen, heruntergeladen, geladen oder gespeichert werden können, aber das Programm unterstützt offiziell Größen von bis zu 100 MB. Für Inhalt, der in Flash Player ausgeführt wird, müssen Sie die <codeph>FileReference.browse()</codeph>- oder die <codeph>FileReferenceList.browse()</codeph>-Methode aufrufen, bevor Sie die <codeph>load()</codeph>-Methode aufrufen. Inhalt, der in AIR in der Anwendungssandbox ausgeführt wird, kann jedoch die <codeph>load()</codeph>-Methode eines Dateiobjekts aufrufen, ohne zuerst die <codeph>browse()</codeph>-Methode aufzurufen. (Die AIR File-Klasse erweitert die FileReference-Klasse.)</ph>
    
    <p>Listener empfangen Ereignisse, um den Fortschritt, Erfolg oder Nichterfolg des Ladevorgangs anzuzeigen. Sie können zwar das FileReferenceList-Objekt verwenden, um Benutzer mehrere Dateien auswählen zu lassen, die geladen werden sollen, aber Sie müssen die Dateien einzeln laden. Um die Dateien einzeln zu laden, iterieren Sie durch das <codeph>FileReferenceList.fileList</codeph>-Array der FileReference-Objekte.</p>
    
    <p>Adobe AIR enthält auch die FileStream-Klasse, die weitere Optionen zum Lesen von Dateien bereitstellt.</p>
    
    <p>Die <codeph>FileReference.upload()</codeph>-, <codeph>FileReference.download()</codeph>-, <codeph>FileReference.load()</codeph>- und <codeph>FileReference.save()</codeph>-Funktionen sind nicht-blockierend. Die Funktionsrückgaben erfolgen nach dem Aufruf vor Abschluss der Dateiübertragung. Zusätzlich gilt: Wenn bei einem FileReference-Objekt der Gültigkeitsbereich verlassen wird, werden alle zu dem Zeitpunkt noch nicht abgeschlossenen Transaktionen für dieses Objekt abgebrochen. Stellen Sie sicher, dass das FileReference-Objekt während der gesamten Dauer des Upload-, Download-, Speicher- bzw. Ladevorgangs den Gültigkeitsbereich nicht verlässt.</p>
    
    <p>Wenn die Datei erfolgreich geladen wurde, wird ihr Inhalt als ein Bytearray in der <codeph>data</codeph>-Eigenschaft des FileReference-Objekts gespeichert.</p>
    
    <p platform="actionscript">Bezüglich der Sicherheit sind folgende Punkte zu beachten:</p>
    
    <ul platform="actionscript">
    <li>Ladevorgänge sind nicht zulässig, wenn die aufrufende SWF-Datei sich in einer nicht vertrauenswürdigen lokalen Sandbox befindet.</li>
    <li>Standardmäßig werden Sandbox-übergreifende Zugriffe nicht zugelassen. Bei einer Website kann der Zugriff auf eine Ressource durch eine Cross-Domain-Richtliniendatei ermöglicht werden.</li>
    <li>Sie können eine Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</li>
    </ul>
    
    <p platform="actionscript">Die genannten Punkte gelten nicht für AIR-Inhalt in der Anwendungssandbox.</p>
    
    <p>Hinweis: Wenn Sie eine Anwendung für Flash Player 10 oder AIR 1.5 veröffentlichen, kann jeweils nur eine der folgenden Methoden aktiv sein: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. Andernfalls gibt die Anwendung einen Laufzeitfehler zurück (Code 2174). Stoppen Sie den laufenden Vorgang mithilfe von <codeph>FileReference.cancel()</codeph>. Diese Beschränkung bezieht sich nur auf Flash Player 10 und AIR 1.5. Für frühere Version von Flash Player oder AIR gilt diese Beschränkung bezüglich mehrerer Methoden nicht.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/data"><linktext>FileReference.data</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>flash.filesystem.FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Start eines Ladevorgangs ausgelöst.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Start eines Ladevorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird regelmäßig während des Ladevorgangs der Datei ausgelöst.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird regelmäßig während des Ladevorgangs der Datei ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Ladevorgang einer Datei erfolgreich abgeschlossen wurde.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Ladevorgang einer Datei erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird aufgerufen, wenn das Laden wegen eines Input/Output-Fehlers fehlschlägt, während die Anwendung eine Datei liest oder schreibt.
    
    </apiDesc></adobeApiEventDetail><shortdesc>Wird aufgerufen, wenn das Laden wegen eines Input/Output-Fehlers fehlschlägt, während die Anwendung eine Datei liest oder schreibt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:save"><apiName>save</apiName><shortdesc>
    Öffnet ein Dialogfeld, das es dem Benutzer ermöglicht, eine Datei in ein lokales Dateisystem zu speichern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wird in folgenden Situationen ausgelöst: 1) Es wird bereits eine Suchsitzung ausgeführt. Es können nicht mehrere Suchsitzungen gleichzeitig ausgeführt werden. 2) Der Name der für den Download-Vorgang ausgewählten Datei enthält unzulässige Zeichen. 3) Der Vorgang wird durch eine Einstellung in der Datei „mms.cfg“ des Benutzers verhindert.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn <codeph>data</codeph> nicht auf den Typ „ByteArray“ gesetzt ist und keine <codeph>toString()</codeph>-Methode hat, wird ein Ausnahmefehler zurückgegeben. Wenn <codeph>data</codeph> nicht auf den Typ „XML“ gesetzt ist und keine <codeph>toXMLString()</codeph>-Methode hat, wird ein Ausnahmefehler zurückgegeben.
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Methode nicht als Antwort auf eine Benutzeraktion wie z. B. ein Maus- oder Tastendruckereignis aufgerufen wird.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann auftreten, wenn Flash Player keinen Speicher für die Datei zuordnen kann. Die Datei ist möglicherweise zu groß oder der verfügbare Speicherplatz reicht nicht aus.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>data</apiItemName><apiType value=""/><apiDesc>Die Daten, die gespeichert werden sollen. Die Daten können in einem von mehreren Formaten vorliegen und werden entsprechend behandelt:
    <ul>
    <li>Wenn der Wert <codeph>null</codeph> ist, gibt die Anwendung einen ArgumentError-Ausnahmefehler zurück.</li> 
    <li>Wenn der Wert ein String ist, wird er als UTF-8-kodierte Textdatei gespeichert.</li>
    <li platform="actionscript">Wenn der Wert „XML“ ist, wird er in eine Textdatei im XML-Format geschrieben. Sämtliche Formatierungsdaten bleiben hierbei erhalten.</li> 
    <li>Wenn der Wert ein ByteArray-Objekt ist, wird er wortwörtlich in eine Datendatei geschrieben.</li> 
    <li>Wenn der Wert keiner der oben genannten ist, ruft die <codeph>save()</codeph>-Methode die <codeph>toString()</codeph>-Methode des Objekts auf, um die Daten in einen String umzuwandeln, und speichert die Daten dann als eine Textdatei. Wenn dies fehlschlägt, gibt die Anwendung einen ArgumentError-Ausnahmefehler zurück.</li> 
    </ul>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Standarddateiname, der im Dialogfeld für die zu speichernde Datei angezeigt wird. Dieser String darf keines der folgenden Zeichen enthalten: / \ : ~~ ? " &lt; > | %
    <p><ph platform="javascript">Wenn Sie diesen Parameter in Flash Player auslassen, ist der Dateiname standardmäßig leer.</ph> Wenn ein File-Objekt diese Methode aufruft, ist der Dateiname der Name der Datei, auf den das File-Objekt verweist. (Die AIR File-Klasse erweitert die FileReference-Klasse.)</p>
    
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    Öffnet ein Dialogfeld, das es dem Benutzer ermöglicht, eine Datei in ein lokales Dateisystem zu speichern. <ph platform="actionscript">In Flash Player bestehen zwar keine Beschränkungen bezüglich der Größe von Dateien, die hochgeladen, heruntergeladen, geladen oder gespeichert werden können, aber der Player unterstützt offiziell Größen von bis zu 100 MB.</ph>
    
    <p>Die <codeph>save()</codeph>-Methode öffnet zuerst ein Betriebssystem-Dialogfeld, das den Benutzer zur Eingabe eines Dateinamens und zur Auswahl eines Ordners auf dem lokalen Computer auffordert, in dem die Datei gespeichert werden soll. Wenn der Benutzer einen Ordner auswählt und den Speichervorgang bestätigt (z. B. indem er auf „Speichern“ klickt), wird die Datei gespeichert. Listener empfangen Ereignisse, um den Fortschritt, Erfolg oder Nichterfolg des Speichervorgangs anzuzeigen. Um den Status des Dialogfelds und des Speichervorgangs nach dem Aufrufen von <codeph>save()</codeph> ermitteln zu können, muss Ihr Code Ereignisse wie <codeph>cancel</codeph>, <codeph>open</codeph>, <codeph>progress</codeph> und <codeph>complete</codeph> überwachen.
    </p>
    
    <p>Adobe AIR enthält auch die FileStream-Klasse, die weitere Optionen zum lokalen Speichern von Dateien bereitstellt.</p>
    
    <p>Die <codeph>FileReference.upload()</codeph>-, <codeph>FileReference.download()</codeph>-, <codeph>FileReference.load()</codeph>- und <codeph>FileReference.save()</codeph>-Funktionen sind nicht-blockierend. Die Funktionsrückgaben erfolgen nach dem Aufruf vor Abschluss der Dateiübertragung. Zusätzlich gilt: Wenn bei einem FileReference-Objekt der Gültigkeitsbereich verlassen wird, werden alle zu dem Zeitpunkt noch nicht abgeschlossenen Transaktionen für dieses Objekt abgebrochen. Stellen Sie sicher, dass das FileReference-Objekt während der gesamten Dauer des Upload-, Download-, Speicher- bzw. Ladevorgangs den Gültigkeitsbereich nicht verlässt.</p>
    
    <p>Wenn die Datei erfolgreich gespeichert wurde, werden die Eigenschaften des FileReference-Objekts mit den Eigenschaften der lokalen Datei gefüllt. Das <codeph>complete</codeph>-Ereignis wird ausgelöst, wenn der Speichervorgang erfolgreich war.</p>
    
    <p>Es kann jeweils nur eine <codeph>browse()</codeph>- oder <codeph>save()</codeph>-Sitzung durchgeführt werden (weil jeweils nur ein Dialogfeld aufgerufen werden kann).</p>
    
    <p platform="actionscript">In Flash Player können Sie diese Methode nur erfolgreich als Antwort auf ein Benutzerereignis (z. B. in einer Ereignisprozedur für ein Mausklick- oder Tastendruckereignis) aufrufen. Andernfalls führt das Aufrufen dieser Methode dazu, dass Flash Player einen Ausnahmefehler ausgibt. Diese Beschränkung gilt nicht für AIR-Inhalt in der Anwendungssandbox.</p>
    
    </apiDesc><example conref="examples\FileReference_save.as"> Im folgenden Beispiel wird der in ein Textfeld eingegebene Text in einer Datei gespeichert. Das Beispiel erstellt ein bearbeitbares Textfeld (<codeph>MyTextField</codeph>) sowie ein weiteres Textfeld, das nicht bearbeitet werden kann (<codeph>MyButtonField</codeph>) und als „Schaltfläche“ für Mausklicks dient. Ein Benutzer kann das erste Textfeld bearbeiten und auf die Schaltfläche klicken, um den Inhalt des Textfelds in einer lokalen Datei zu speichern. Die Mausklick-Ereignisprozedur <codeph>clickhandler</codeph> verwendet die <codeph>FileReference.save()</codeph>-Methode (für ein FileReference-Objekt mit dem Namen <codeph>MyFileReference</codeph>), um ein Dialogfeld im aktuellen Betriebssystem des Benutzer zu öffnen, damit der Benutzer den Inhalt in einer lokalen Datei speichern kann, deren Namen er selbst eingibt.
<codeblock>
var MyTextField:TextField = new TextField();
var MyButtonField:TextField = new TextField();
var MyFile:FileReference = new FileReference();

MyTextField.border = true;
MyTextField.type = TextFieldType.INPUT;

MyButtonField.background = true;
MyButtonField.backgroundColor = 0x339933;
MyButtonField.x = 150;
MyButtonField.height = 20;
MyButtonField.text = "Click here to save";

addChild(MyTextField);
addChild(MyButtonField);
MyButtonField.addEventListener(MouseEvent.CLICK, clickhandler);

function clickhandler(e:MouseEvent): void {
    MyFile.save(MyTextField.text);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/load()"><linktext>FileReferenceList.load()</linktext></link><link href="flash.net.xml#FileReferenceList/data"><linktext>FileReferenceList.data</linktext></link><link href="flash.net.xml#FileReferenceList/upload"><linktext>FileReferenceList.upload</linktext></link><link href="flash.net.xml#FileReferenceList/download"><linktext>FileReferenceList.download</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:save_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Download-Vorgang gestartet wird.
	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Download-Vorgang gestartet wird.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird regelmäßig während des Download-Vorgangs ausgelöst.
	</apiDesc></adobeApiEventDetail><shortdesc>Wird regelmäßig während des Download-Vorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Download einer Datei erfolgreich abgeschlossen wurde.
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Download einer Datei erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Benutzer das Dialogfeld abbricht.
	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Benutzer das Dialogfeld abbricht.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Benutzer in einem Dialogfeld eine Datei für einen Download-Vorgang auswählt. 
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Benutzer in einem Dialogfeld eine Datei für einen Download-Vorgang auswählt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Input/Output-Fehler während des Lesens oder der Übertragung der Datei auftritt.
    
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Input/Output-Fehler während des Lesens oder der Übertragung der Datei auftritt.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:upload"><apiName>upload</apiName><shortdesc>
    Startet den Upload-Vorgang für eine vom Benutzer auf einem Remote-Server ausgewählte Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>upload, FileReference.upload
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Über lokale nicht vertrauenswürdige SWF-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können dieses Problem vermeiden, indem Sie die SWF-Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren. Diese Ausnahme wird mit einer Meldung ausgelöst, die den Dateinamen und die URL enthält, auf die nicht zugegriffen werden kann.
    
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wird in folgenden Situationen ausgelöst: 1) Es wird bereits eine FileReference- oder FileReferenceList-Suchsitzung ausgeführt. Es können nicht mehrere Suchsitzungen gleichzeitig ausgeführt werden. 2) Der Parameter „URL“ enthält keinen gültigen Pfad/kein gültiges Protokoll. Für Upload-Vorgänge muss HTTP und für Download-Vorgänge FTP oder HTTP verwendet werden. 3) Der Parameter <codeph>uploadDataFieldName</codeph> weist den Wert <codeph>null</codeph> auf. 4) Der Vorgang wird durch eine Einstellung in der Datei „mms.cfg“ des Benutzers verhindert.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wird in folgenden Situationen ausgelöst: 1) Der Parameter <codeph>uploadDataFieldName</codeph> ist ein leerer String. 2) <codeph>url.data</codeph> weist den Typ „ByteArray“ auf. Bei Verwendung mit den Methoden <codeph>FileReference.upload()</codeph> und <codeph>FileReference.download()</codeph> sind für <codeph>url.data</codeph> nur die Typen „URLVariables“ und „String“ zulässig. 3) In der AIR-Laufzeitumgebung (in der Sicherheitssandbox der Anwendung) ist die Methode von URLRequest nicht GET oder POST (verwenden Sie stattdessen <codeph>uploadEncoded()</codeph>).
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann folgende Ursachen haben: 1) Flash Player kann den Parameter <codeph>URLRequest.data</codeph> nicht von UTF8 in MBCS konvertieren. Dieser Fehler trifft zu, wenn das an <codeph>FileReference.upload()</codeph> übergebene URLRequest-Objekt auf die Ausführung eines GET-Vorgangs eingestellt ist und wenn <codeph>System.useCodePage</codeph> auf <codeph>true</codeph> gesetzt ist. 2) Flash Player kann <codeph>POST</codeph>-Daten keinen Speicher zuweisen. Dieser Fehler trifft zu, wenn das an <codeph>FileReference.upload()</codeph> übergebene URLRequest-Objekt auf die Ausführung eines <codeph>POST</codeph>-Vorgangs eingestellt ist.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Das URLRequest-Objekt. Die Eigenschaft <codeph>url</codeph> des URLRequest-Objekts muss die URL des Serverskripts enthalten, das für die Verarbeitung von Upload-Vorgängen über HTTP <codeph>POST</codeph>-Aufrufe konfiguriert ist. Bei einigen Browsern sind URL-Strings in ihrer Länge beschränkt. So können URLs mit über 256 Zeichen unter Umständen bei einigen Browsern oder Servern fehlschlagen. Wenn dieser Parameter den Wert <codeph>null</codeph> aufweist, wird eine Ausnahme ausgelöst. Die <codeph>requestHeaders</codeph>-Eigenschaft des URLRequest-Objekts wird ignoriert. Benutzerdefinierte HTTP-Anforderungs-Header werden in Uploads und Downloads nicht unterstützt.
     
    <p>Diese URL kann entweder eine HTTP- oder, aus Sicherheitsgründen, eine HTTPS-Adresse sein. Wenn HTTPS verwendet werden soll, setzen Sie den Parameter <codeph>url</codeph> auf eine HTTPS-Adresse. Wenn Sie im Parameter <codeph>url</codeph> keine Portnummer angeben, wird standardmäßig Port 80 für HTTP und Port 443 für HTTPS verwendet.</p>
    
    <p>Um <codeph>POST</codeph> oder <codeph>GET</codeph>-Parameter an den Server zu senden, setzen Sie den Wert der Eigenschaft <codeph>data</codeph> des URLRequest-Objekts auf Ihre Parameter und die Eigenschaft <codeph>method</codeph> entweder auf <codeph>URLRequestMethod.POST</codeph> oder auf <codeph>URLRequestMethod.GET</codeph>.</p>
    
    
    </apiDesc></apiParam><apiParam><apiItemName>uploadDataFieldName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>Filedata</apiData><apiDesc>Der Feldname, der den Dateidaten im Upload-Vorgang mit der <codeph>POST</codeph>-Methode vorangestellt ist. Der Wert für <codeph>uploadDataFieldName</codeph> darf nicht null und kein leerer String sein. Standardmäßig weist <codeph>uploadDataFieldName</codeph> den Wert <codeph>"Filedata"</codeph> auf, wie im folgenden Beispiel für eine <codeph>POST</codeph>-Anforderung gezeigt:
    <pre>
    Content-Type: multipart/form-data; boundary=AaB03x
    --AaB03x 
    Content-Disposition: form-data; name="Filedata"; filename="example.jpg" 
    Content-Type: application/octet-stream
    ... contents of example.jpg ... 
    --AaB03x-- 
    </pre>
    
    </apiDesc></apiParam><apiParam><apiItemName>testUpload</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Eine Einstellung für die Anforderung eines Test-Uploads. Wenn <codeph>testUpload</codeph> auf <codeph>true</codeph> gesetzt ist, wird bei Dateien mit einer Größe über 10 KB ein Test-Upload mit der <codeph>POST</codeph>-Methode durchgeführt, wobei der Wert für die Länge des Inhalts 0 ist (kein Inhalt). Mit dem Test-Upload wird überprüft, ob der tatsächliche Upload-Vorgang mit Serverauthentifizierung (falls erforderlich) erfolgreich abgeschlossen werden kann. Test-Upload-Vorgänge sind nur für Player unter Windows verfügbar.
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Startet den Upload einer Datei auf einen Remote-Server.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Startet den Upload-Vorgang für eine vom Benutzer auf einem Remote-Server ausgewählte Datei. <ph platform="actionscript">In Flash Player ist kein Grenzwert für die Größe der Dateien für Upload- und Download-Vorgänge festgelegt. Offiziell unterstützt der Player Dateigrößen von bis zu 100 MB.</ph> Vor dem Aufruf dieser Methode müssen Sie die Methode <codeph>FileReference.browse()</codeph> oder <codeph>FileReferenceList.browse()</codeph> aufrufen.
    
    <p>Listener erhalten Ereignisdaten und zeigen den Fortschritt, den Erfolg oder den Fehlschlag des Uploads an. Sie können Benutzern mit dem Objekt „FileReferenceList“ zwar die Auswahl mehrerer Dateien zum Upload ermöglichen, die Dateien müssen jedoch einzeln hochgeladen werden. Verwenden Sie hierzu das Array <codeph>FileReferenceList.fileList</codeph> der FileReferenceList-Objekte.</p>
    
    <p>Die Funktionen <codeph>FileReference.upload()</codeph> und <codeph>FileReference.download()</codeph> sind ungeblockt. Die Funktionsrückgaben erfolgen nach dem Aufruf vor Abschluss der Dateiübertragung. Wenn bei einem FileReference-Objekt der Gültigkeitsbereich verlassen wird, werden alle zu dem Zeitpunkt noch nicht abgeschlossenen Upload- bzw. Download-Vorgänge für dieses Objekt abgebrochen. Stellen Sie sicher, dass das FileReference-Objekt während der gesamten Dauer des Upload- bzw. Download-Vorgangs den Gültigkeitsbereich nicht verlässt.</p>
    
    <p>Die betreffenden Dateien werden zu der im Parameter <codeph>url</codeph> angegebenen jeweiligen URL hochgeladen. Bei der URL sollte es sich um ein Serverskript handeln, das für Uploads konfiguriert ist. In Flash Player werden Dateien mit der HTTP <codeph>POST</codeph>-Methode hochgeladen. Das den Upload verwaltende Serverskript sollte eine <codeph>POST</codeph>-Anforderung mit den folgenden Elementen erwarten:</p>
    <ul>
    <li><codeph>Content-Type</codeph> mit dem Wert <codeph>multipart/form-data</codeph></li>
    <li><codeph>Content-Disposition</codeph> mit einem standardmäßig auf <codeph>"Filedata"</codeph> gesetzten <codeph>name</codeph>-Attribut und einem <codeph>filename</codeph>-Attribut, das auf den Namen der ursprünglichen Datei gesetzt ist.</li>
    <li>Die Binärdaten der Datei</li></ul>
    
     <p>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
    
    <p>Ein Beispiel für eine <codeph>POST</codeph>-Anforderung finden Sie in der Beschreibung zum Parameter <codeph>uploadDataFieldName</codeph>. Sie können <codeph>POST</codeph>- oder <codeph>GET</codeph>-Parameter mit der Methode <codeph>upload()</codeph> an den Server senden. Nähere Informationen finden Sie in der Beschreibung zum Parameter <codeph>request</codeph>.</p>
    
    <p>Wenn der Parameter <codeph>testUpload</codeph> den Wert <codeph>true</codeph> aufweist und die hochzuladende Datei größer ist als etwa 10 KB, sendet Flash Player unter Windows vor dem Hochladen der tatsächlichen Datei zunächst einen Test-Upload ohne Inhalt mit der <codeph>POST</codeph>-Methode, um sicherzustellen, dass die Übertragung erfolgreich durchgeführt werden kann. Anschließend wird ein zweiter <codeph>POST</codeph>-Vorgang mit dem tatsächlichen Dateiinhalt gesendet. Bei Dateien, die kleiner sind als 10 KB, führt Flash Player nur einen <codeph>POST</codeph>-Vorgang mit dem tatsächlichen Inhalt der hochzuladenden Datei durch. Auf Macintosh-Plattformen werden keine <codeph>POST</codeph>-Vorgänge für Test-Uploads durchgeführt.</p>
    
    <p><b>Hinweis</b>: Wenn der Server eine Benutzerauthentifizierung erfordert, kann der Benutzer nur bei SWF-Dateien, die in einem Browser (also mit einem Browser-Plug-In oder einer ActiveX-Steuerung) ausgeführt werden, in einem Dialogfeld zur Eingabe eines Benutzernamens und eines Kennworts zur Authentifizierung aufgefordert werden. Dies gilt darüber hinaus nur für Download-Vorgänge. Upload-Vorgänge mit Plug-Ins oder ActiveX-Steuerelementen bzw. Upload- und Download-Vorgänge mit dem eigenständigen oder externen Player schlagen fehl.</p>
    
    <p>Wenn Sie diese Methode <ph platform="javascript">für Inhalt in anderen Sicherheitssandboxen als der Sicherheitssandbox der Anwendung</ph> verwenden, ziehen Sie das <ph platform="actionscript">Flash Player</ph><ph platform="javascript">AIR</ph>-Sicherheitsmodell in Betracht: </p>
    
    
    <ul>
    <li>Ladevorgänge sind nicht zulässig, wenn die aufrufende SWF-Datei sich in einer nicht vertrauenswürdigen lokalen Sandbox befindet.</li>
    
    <li>Standardmäßig werden Sandbox-übergreifende Zugriffe nicht zugelassen. Eine Website kann den Zugriff auf eine Ressource durch das Hinzufügen einer URL-Richtliniendatei ermöglichen.</li>
    
	<li platform="actionscript">Sie können eine SWF-Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</li>
    
    </ul>
    
    <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
    
	<p>Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
    
    <ul>
    
    <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
    
    <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
    
    <li>Der Abschnitt „Understanding AIR Security“ des Kapitels „Getting started with Adobe AIR“ im Handbuch <i>Developing AIR Applications</i>.</li>
    
    <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
    </ul>
    <p>Beachten Sie, dass aufgrund neuer zusätzlicher Funktionalität von Flash Player beim Veröffentlichen in Flash Player 10 immer nur einer der folgenden Vorgänge aktiv sein kann: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. Ansonsten gibt Flash Player einen Laufzeitfehler (Code 2174) aus. Stoppen Sie den laufenden Vorgang mithilfe von <codeph>FileReference.cancel()</codeph>. Diese Einschränkung betrifft lediglich Flash Player 10. Ältere Versionen von Flash Player sind von den Einschränkungen bezüglich gleichzeitig ausgeführter Vorgänge nicht betroffen.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:upload_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Upload-Vorgang gestartet wird.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Upload-Vorgang gestartet wird.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird regelmäßig während des Upload-Vorgangs ausgelöst.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Wird regelmäßig während des Upload-Vorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Upload einer Datei erfolgreich abgeschlossen wurde.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Upload einer Datei erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, nachdem die Daten vom Server nach einem erfolgreichen Datei-Upload empfangen wurden.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, nachdem die Daten vom Server nach einem erfolgreichen Datei-Upload empfangen wurden.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund einer Sicherheitsverletzung fehlschlägt.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund einer Sicherheitsverletzung fehlschlägt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund eines HTTP-Fehlers fehlschlägt.
	
 	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund eines HTTP-Fehlers fehlschlägt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Der Upload-Vorgang wird erfolgreich abgeschlossen und der Server gibt eine Antwort-URL und Antwort-Header zurück.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Der Upload-Vorgang wird erfolgreich abgeschlossen und der Server gibt eine Antwort-URL und Antwort-Header zurück.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird in den folgenden Situationen aufgerufen:
    <ul>
    <li>Der Upload schlägt fehl, weil ein I/O-Fehler aufgetreten ist, während <ph platform="actionscript">Flash Player oder</ph> Adobe AIR die Datei liest, schreibt oder überträgt.</li>
    <li>Der Upload schlägt fehl, weil versucht wird, eine Datei auf einen Server hochzuladen, der eine Authentifizierung (z. B. anhand eines Benutzernamens und eines Kennworts) erfordert. Während des Uploads gibt es keine Möglichkeit für den Benutzer, Kennwörter einzugeben.</li>
    <li>Der Upload schlägt fehl, da der <codeph>url</codeph>-Parameter ein ungültiges Protokoll enthält. <codeph>FileReference.upload()</codeph> muss entweder HTTP oder HTTPS verwenden.</li>
    
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>Wird in einem der folgenden Fälle aufgerufen: Der Upload schlägt fehl, weil während des Lese-, Schreib- bzw. Übertragungsvorgangs der Datei durch Flash Player oder Adobe AIR ein I/O-Fehler aufgetreten ist. Der Upload schlägt fehl, weil versucht wird, eine Datei auf einen Server hochzuladen, der eine Authentifizierung (z. B. anhand eines Benutzernamens und eines Kennworts) erfordert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:uploadUnencoded"><apiName>uploadUnencoded</apiName><shortdesc>
    Leiten Sie das Hochladen einer Datei auf eine URL ohne Kodierung ein.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Über lokale nicht vertrauenswürdige SWF-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können dieses Problem vermeiden, indem Sie die SWF-Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren. Diese Ausnahme wird mit einer Meldung ausgelöst, die den Dateinamen und die URL enthält, auf die nicht zugegriffen werden kann.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Wird in folgenden Situationen ausgelöst: 1) Es wird bereits eine FileReference- oder FileReferenceList-Suchsitzung ausgeführt. Es können nicht mehrere Suchsitzungen gleichzeitig ausgeführt werden. 2) Der Parameter „URL“ enthält keinen gültigen Pfad/kein gültiges Protokoll. Der Datei-Upload muss HTTP verwenden.
	
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Das URLRequest-Objekt. Die Eigenschaft <codeph>url</codeph> des URLRequest-Objekts muss die URL des Serverskripts enthalten, das für die Verarbeitung von Upload-Vorgängen über HTTP <codeph>POST</codeph>-Aufrufe konfiguriert ist. Bei einigen Browsern sind URL-Strings in ihrer Länge beschränkt. So können URLs mit über 256 Zeichen unter Umständen bei einigen Browsern oder Servern fehlschlagen. Wenn dieser Parameter den Wert <codeph>null</codeph> aufweist, wird eine Ausnahme ausgelöst.  
	 
	<p>Diese URL kann entweder eine HTTP- oder, aus Sicherheitsgründen, eine HTTPS-Adresse sein. Wenn HTTPS verwendet werden soll, setzen Sie den Parameter <codeph>url</codeph> auf eine HTTPS-Adresse. Wenn Sie im Parameter <codeph>url</codeph> keine Portnummer angeben, wird standardmäßig Port 80 für HTTP und Port 443 für HTTPS verwendet.</p>
	
	<p>Um <codeph>POST</codeph> oder <codeph>GET</codeph>-Parameter an den Server zu senden, setzen Sie den Wert der Eigenschaft <codeph>data</codeph> des URLRequest-Objekts auf Ihre Parameter und die Eigenschaft <codeph>method</codeph> entweder auf <codeph>URLRequestMethod.POST</codeph> oder auf <codeph>URLRequestMethod.GET</codeph>.</p>
   	
    </apiDesc></apiParam><apiTipTexts><apiTipText>Startet den Upload einer Datei auf einen Remote-Server ohne Kodierung. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Leiten Sie das Hochladen einer Datei auf eine URL ohne Kodierung ein. Während die <codeph>upload()</codeph>-Methode die Datei in einem Formulardatenumschlag kodiert, übergibt die <codeph>uploadUnencoded()</codeph>-Methode den Dateiinhalt wie er ist im HTTP-Anforderungshauptteil. Verwenden Sie die uploadUnencoded()-Methode, wenn die Daten, die Sie senden möchten, bereits in einem Format kodiert sind, dass der empfangende Server akzeptiert. Normalerweise wird die <codeph>uploadeUnencoded()</codeph>-Methode mit der <codeph>HTTP/WebDAV PUT</codeph>-Methode.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Upload-Vorgang gestartet wird.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Upload-Vorgang gestartet wird.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird regelmäßig während des Upload-Vorgangs ausgelöst.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Wird regelmäßig während des Upload-Vorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn der Upload einer Datei erfolgreich abgeschlossen wurde.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn der Upload einer Datei erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, nachdem die Daten vom Server nach einem erfolgreichen Datei-Upload empfangen wurden.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, nachdem die Daten vom Server nach einem erfolgreichen Datei-Upload empfangen wurden.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund einer Sicherheitsverletzung fehlschlägt.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund einer Sicherheitsverletzung fehlschlägt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund eines HTTP-Fehlers fehlschlägt.
	
 	</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Upload-Vorgang aufgrund eines HTTP-Fehlers fehlschlägt.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Der Upload-Vorgang wird erfolgreich abgeschlossen und der Server gibt eine Antwort-URL und Antwort-Header zurück.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Der Upload-Vorgang wird erfolgreich abgeschlossen und der Server gibt eine Antwort-URL und Antwort-Header zurück.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird in den folgenden Situationen aufgerufen:
    <ul>
	<li>Der Upload schlägt fehl, weil ein I/O-Fehler aufgetreten ist, während Adobe AIR die Datei liest, schreibt oder überträgt.</li>
	<li>Der Upload schlägt fehl, weil versucht wird, eine Datei auf einen Server hochzuladen, der eine Authentifizierung (z. B. anhand eines Benutzernamens und eines Kennworts) erfordert. Während des Uploads gibt es keine Möglichkeit für den Benutzer, Kennwörter einzugeben.</li>
	<li>Der Upload schlägt fehl, da der <codeph>url</codeph>-Parameter ein ungültiges Protokoll enthält. <codeph>FileReference.upload()</codeph> muss entweder HTTP oder HTTPS verwenden.</li>
	</ul>
	
	</apiDesc></adobeApiEventDetail><shortdesc>Wird in einem der folgenden Fälle aufgerufen: Der Upload schlägt fehl, weil während des Lese-, Schreib- bzw. Übertragungsvorgangs der Datei durch Adobe AIR ein I/O-Fehler aufgetreten ist. Der Upload schlägt fehl, weil versucht wird, eine Datei auf einen Server hochzuladen, der eine Authentifizierung (z. B. anhand eines Benutzernamens und eines Kennworts) erfordert.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReference:creationDate:get"><apiName>creationDate</apiName><shortdesc>
    Das Erstellungsdatum der Datei auf der lokalen Festplatte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creationDate, FileReference.creationDate
    
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>Wenn die Methode <codeph>FileReference.browse() </codeph>, <codeph>FileReferenceList.browse()</codeph> oder <codeph>FileReference.download()</codeph> nicht erfolgreich aufgerufen werden konnte, wird eine Ausnahme mit einer Meldung ausgelöst, die angibt, dass die Funktionen in der falschen Reihenfolge aufgerufen wurden oder ein vorhergehender Aufruf nicht erfolgreich war. In diesem Fall weist die Eigenschaft <codeph>creationDate</codeph> den Wert <codeph>null</codeph> auf.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn nicht auf die Dateidaten zugegriffen werden kann, wird eine Ausnahme mit einer Meldung ausgelöst, die einen I/O-Fehler angibt.
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ruft das Erstellungsdatum der Datei als Date-Objekt ab.
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Das Erstellungsdatum der Datei auf der lokalen Festplatte. Falls das Objekt keine Daten enthält, gibt der Aufruf dieser Eigenschaft <codeph>null</codeph> zurück.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:creator:get"><apiName>creator</apiName><shortdesc>
    Der Macintosh-Erstellertyp der Datei, der nur mit Mac OS-Versionen, die älter als Mac OS X sind, verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creator, FileReference.creator
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn die Methode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> oder <codeph>FileReference.download()</codeph> nicht erfolgreich aufgerufen werden konnte, wird eine Ausnahme mit einer Meldung ausgelöst, die angibt, dass die Funktionen in der falschen Reihenfolge aufgerufen wurden oder ein vorhergehender Aufruf nicht erfolgreich war. In diesem Fall weist die Eigenschaft <codeph>creator</codeph> den Wert <codeph>null</codeph> auf.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Der Erstellertyp (auf Macintosh-Systemen).
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Der Macintosh-Erstellertyp der Datei, der nur in Mac OS-Versionen vor Mac OS X verwendet wird. In Windows oder Linux ist diese Eigenschaft <codeph>null</codeph>. Falls das FileReference-Objekt noch keine Daten enthält, gibt der Aufruf dieser Eigenschaft <codeph>null</codeph> zurück.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:data:get"><apiName>data</apiName><shortdesc>
    Das ByteArray-Objekt, das die Daten aus der geladenen Datei nach einem erfolgreichen Aufruf der load()-Methode repräsentiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
    </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>Wenn die <codeph>load()</codeph>-Methode nicht erfolgreich aufgerufen wurde, wird ein Ausnahmefehler mit der Meldung zurückgegeben, dass Funktionen in der falschen Reihenfolge aufgerufen wurden oder dass ein früherer Aufruf nicht erfolgreich war. In diesem Fall weist die <codeph>data</codeph>-Eigenschaft den Wert <codeph>null</codeph> auf.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Datei nicht geöffnet oder gelesen werden kann oder beim Zugriff auf die Datei ein ähnlicher Fehler auftritt, wird eine Ausnahme mit einer Meldung ausgelöst, die einen I/O-Fehler angibt. In diesem Fall weist die <codeph>data</codeph>-Eigenschaft den Wert <codeph>null</codeph> auf.
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Die geladenen Daten der Datei als ByteArray.
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Das ByteArray-Objekt, das die Daten aus der geladenen Datei nach einem erfolgreichen Aufruf der <codeph>load()</codeph>-Methode repräsentiert.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:extension:get"><apiName>extension</apiName><shortdesc>
	 Die Dateinamenerweiterung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Verweis nicht initialisiert wurde.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Die Dateinamenerweiterung.
	 
	 <p>Eine Dateierweiterung ist der Teil des Namens, der hinter dem letzten Punkt („.“) steht. Der Punkt selbst gehört nicht zur Erweiterung. Wenn der Dateiname keinen Punkt enthält, ist die Erweiterung <codeph>null</codeph>.</p>
	 
	 <p><i>Hinweis:</i> Sie sollte den Dateityp mit der <codeph>extension</codeph>-Eigenschaft bestimmen; verwenden Sie nicht die Eigenschaften <codeph>creator</codeph> oder <codeph>type</codeph>. Sie können die Eigenschaften <codeph>creator</codeph> und <codeph>type</codeph> als veraltet betrachten. Sie gelten für ältere Mac OS-Versionen.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileReference:modificationDate:get"><apiName>modificationDate</apiName><shortdesc>
   Das Datum, an dem die Datei auf der lokalen Festplatte zuletzt geändert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>modificationDate, FileReference.modificationDate
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>Wenn die Methode <codeph>FileReference.browse() </codeph>, <codeph>FileReferenceList.browse()</codeph> oder <codeph>FileReference.download()</codeph> nicht erfolgreich aufgerufen werden konnte, wird eine Ausnahme mit einer Meldung ausgelöst, die angibt, dass die Funktionen in der falschen Reihenfolge aufgerufen wurden oder ein vorhergehender Aufruf nicht erfolgreich war. In diesem Fall weist die Eigenschaft <codeph>modificationDate</codeph> den Wert <codeph>null</codeph> auf.
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn nicht auf die Dateidaten zugegriffen werden kann, wird eine Ausnahme mit einer Meldung ausgelöst, die einen I/O-Fehler angibt.
   
   </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ruft das Änderungsdatum der Datei als Date-Objekt ab.
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   Das Datum, an dem die Datei auf der lokalen Festplatte zuletzt geändert wurde. Falls das FileReference-Objekt noch keine Daten enthält, gibt der Aufruf dieser Eigenschaft <codeph>null</codeph> zurück.
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:name:get"><apiName>name</apiName><shortdesc>
   Der Name der Datei auf der lokalen Festplatte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
   </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn die Methode <codeph>FileReference.browse() </codeph>, <codeph>FileReferenceList.browse()</codeph> oder <codeph>FileReference.download()</codeph> nicht erfolgreich aufgerufen werden konnte, wird eine Ausnahme mit einer Meldung ausgelöst, die angibt, dass die Funktionen in der falschen Reihenfolge aufgerufen wurden oder ein vorhergehender Aufruf nicht erfolgreich war.
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ruft den Namen der Datei als String ab.
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   Der Name der Datei auf der lokalen Festplatte. Wenn das FileReference-Objekt keine Daten enthält (aus einem Aufruf von <codeph>FileReference.download()</codeph> oder <codeph> FileReference.browse()</codeph>), löst Flash Player einen Fehler aus, wenn Sie versuchen, den Wert diese Eigenschaft abzurufen.
   <p>Den Eigenschaften eines FileReference-Objekts werden durch einen Aufruf der Methode <codeph>browse()</codeph> Werte zugewiesen. Im Unterschied zu anderen FileReference-Eigenschaften wird beim Aufruf der Methode <codeph>download()</codeph> die Eigenschaft <codeph>name</codeph> erst bei Auslösung des Ereignisses <codeph>select</codeph> mit Daten aktualisiert.</p>
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:size:get"><apiName>size</apiName><shortdesc>
  Die Größe der Datei auf der lokalen Festplatte in Byte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Wenn die Methode <codeph>FileReference.browse() </codeph>, <codeph>FileReferenceList.browse()</codeph> oder <codeph>FileReference.download()</codeph> nicht erfolgreich aufgerufen werden konnte, wird eine Ausnahme mit einer Meldung ausgelöst, die angibt, dass die Funktionen in der falschen Reihenfolge aufgerufen wurden oder ein vorhergehender Aufruf nicht erfolgreich war.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn die Datei nicht geöffnet oder gelesen werden kann oder beim Zugriff auf die Datei ein ähnlicher Fehler auftritt, wird eine Ausnahme mit einer Meldung ausgelöst, die einen I/O-Fehler angibt.
  
  </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Die Größe der Datei in Byte.
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Die Größe der Datei auf der lokalen Festplatte in Byte. <ph platform="actionscript">Wenn <codeph>size</codeph> den Wert 0 aufweist, wird eine Ausnahme ausgelöst.</ph>
  
  <p platform="actionscript"><i>Hinweis:</i> In der ersten Version von ActionScript 3.0 wurde die <codeph>size</codeph>-Eigenschaft als uint-Objekt definiert, das Dateigrößen bis zu ca. 4 GB unterstützt. Sie wird jetzt als Number-Objekt implementiert, um größere Dateien zu unterstützen. </p>
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:type:get"><apiName>type</apiName><shortdesc>
  Der Dateityp.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>type, FileReference.type
  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn die Methode <codeph>FileReference.browse() </codeph>, <codeph>FileReferenceList.browse()</codeph> oder <codeph>FileReference.download()</codeph> nicht erfolgreich aufgerufen werden konnte, wird eine Ausnahme mit einer Meldung ausgelöst, die angibt, dass die Funktionen in der falschen Reihenfolge aufgerufen wurden oder ein vorhergehender Aufruf nicht erfolgreich war. In diesem Fall weist die Eigenschaft <codeph>type</codeph> den Wert <codeph>null</codeph> auf.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Ruft den Typ bzw. die Erweiterung der Datei ab.
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Der Dateityp. 
  
  <p>In Windows oder Linux ist diese Eigenschaft die Dateierweiterung. Auf Macintosh-Systemen ist diese Eigenschaft der vierbuchstabige Dateityp, der nur in Mac OS-Versionen, die älter als Mac OS X sind, verwendet wird. Wenn das FileReference-Objekt keine Daten enthält, gibt ein Aufruf zum Abrufen des Werts diese Eigenschaft <codeph>null</codeph> zurück.</p>
    
	<p>Für Windows, Linux und Mac OS X die Dateierweiterung, also der Teil der <codeph>name</codeph>-Eigenschaft, der auf das letzte Vorkommen des Punkts (.) folgt. Zeichen - identifiziert den Dateityp.</p>
	
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObjectFlushStatus"><apiName>SharedObjectFlushStatus</apiName><shortdesc>
 Die SharedObjectFlushStatus-Klasse stellt Werte für den von einem Aufruf der SharedObject.flush()-Methode zurückgegebenen Code bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die SharedObjectFlushStatus-Klasse stellt Werte für den von einem Aufruf der <codeph>SharedObject.flush()</codeph>-Methode zurückgegebenen Code bereit.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links><apiValue id="flash.net:SharedObjectFlushStatus:FLUSHED"><apiName>FLUSHED</apiName><shortdesc>
 Gibt an, dass die Ausgabe erfolgreich abgeschlossen wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>flushed</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Gibt an, dass die Ausgabe erfolgreich abgeschlossen wurde.
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObjectFlushStatus:PENDING"><apiName>PENDING</apiName><shortdesc>
 Gibt an, dass der Benutzer aufgefordert wird, zusätzlichen Speicherplatz für das gemeinsame Objekt zur Verfügung zu stellen, damit die Ausgabe ausgeführt werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pending</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Gibt an, dass der Benutzer aufgefordert wird, zusätzlichen Speicherplatz für das gemeinsame Objekt zur Verfügung zu stellen, damit die Ausgabe ausgeführt werden kann.
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequest"><apiName>URLRequest</apiName><shortdesc>
  Die URLRequest-Klasse erfasst alle Informationen in einer HTTP-Anforderung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The above include is not a mistake, but rather code re-use.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  Die URLRequest-Klasse erfasst alle Informationen in einer HTTP-Anforderung. URLRequest-Objekte werden an die <codeph>load()</codeph>-Methoden der Loader-, URLStream- und URLLoader-Klasse und an andere Lademethoden übergeben, um URL-Downloads zu initiieren. Sie werden auch an die <codeph>upload()</codeph>- und <codeph>download()</codeph>-Methoden der FileReference-Klasse übergeben.
 
  <p platform="actionscript">Eine SWF-Datei innerhalb der lokalen Dateisystem-Sandbox kann keine Daten aus einer Ressource in der Network-Sandbox laden bzw. keine Daten für diese Ressource bereitstellen. </p>
 
  <p>Standardmäßig müssen die aufrufende <ph platform="actionscript">SWF</ph>-Datei und die URL, die Sie laden, in der gleichen Domäne sein. Eine <ph platform="actionscript">SWF</ph>-Datei auf www.adobe.com kann beispielsweise nur Daten aus Quellen laden, die sich ebenfalls auf www.adobe.com befinden. <ph platform="actionscript">Um Daten aus einer anderen Domäne zu laden, legen Sie eine URL-Richtliniendatei auf dem Server ab, der die Daten hostet.</ph></p>
 
  <p> In Adobe AIR dagegen ist Inhalt in der Sicherheitssandbox der Anwendung (mit der AIR-Anwendung installierter Inhalt) nicht durch diese Sicherheitseinschränkungen beschränkt. Wenn Inhalt in Adobe AIR ausgeführt wird, können Dateien in der Sicherheitssandbox der Anwendung auf URLs zugreifen, die eines der folgenden URL-Schemata verwenden:</p>

  <p platform="javascript"> Dateien in der Sicherheitsdomäne der Anwendung (Dateien, die mit der AIR-Anwendung installiert wurden) können auf URLs zugreifen, die eines der folgenden URL-Schemata verwenden:</p>
 
 <ul>
 
  <li><codeph>http</codeph> und <codeph>https</codeph> </li>
 
  <li><codeph>file</codeph> </li>
 
  <li><codeph>app-storage</codeph> </li>
 
  <li><codeph>app</codeph> </li>
 
 </ul>
 
  <p>Inhalt, <ph platform="actionscript">der in Adobe AIR ausgeführt wird </ph>und nicht in der Sicherheitssandbox der Anwendung ist, unterliegt den gleichen Beschränkungen wie Inhalt, der im Browser <ph platform="actionscript">(in Flash Player)</ph> ausgeführt wird, und Ladevorgänge hängen von der Domäne des Inhalts<ph platform="actionscript"> sowie von Zugriffsrechten ab, die in URL-Richtliniendateien gewährt werden</ph>.</p>
 
 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
 <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li>Der Abschnitt „Understanding AIR Security“ des Kapitels „Getting started with Adobe AIR“ im Handbuch <i>Developing AIR Applications</i>.</li>
 
  <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
 </ul>
 
 </apiDesc><example conref="examples\URLRequestExample.as"> Im folgenden Beispiel wird ein neues Loader-Objekt erstellt und an ein URLRequest-Objekt übergeben, das den Pfad zu einer XML-Datei enthält. Bei erfolgreich ausgeführtem Ladevorgang wird ein <codeph>complete</codeph>-Ereignis ausgelöst, und die Daten in der XML-Datei werden in die Ausgabe geschrieben. Andere Ereignisse einschließlich Fehlerereignisse werden von zusätzlichen Ereignisprozeduren erfasst.
 <p>Legen Sie zur Ausführung dieses Beispiels eine Datei mit dem Namen „XMLFile.xml“ in dem Verzeichnis ab, in dem sich die SWF-Datei befindet.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestExample extends Sprite {

        public function URLRequestExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("XMLFile.xml");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequestDefaults"><linktext>URLRequestDefaults</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>HTMLLoader-Klasse</linktext></link></related-links><apiConstructor id="flash.net:URLRequest:URLRequest"><apiName>URLRequest</apiName><shortdesc>
     Erstellt ein URLRequest-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Die anzufordernde URL. Sie können die URL zu einem späteren Zeitpunkt mithilfe der Eigenschaft <codeph>url</codeph> festlegen.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein URLRequest-Objekt. Wenn <codeph>System.useCodePage</codeph> auf <codeph>true</codeph> gesetzt ist, wird die Anforderung mit der Codepage des Systems kodiert. Wenn <codeph>System.useCodePage</codeph> auf <codeph>false</codeph> gesetzt ist, wird die Anforderung mit Unicode kodiert.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.system.xml#System/useCodePage"><linktext>flash.system.System.useCodePage</linktext></link></related-links></apiConstructor><apiValue id="flash.net:URLRequest:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	Gibt an, ob Authentifizierungsanforderungen für diese Anforderung verarbeitet werden sollen (true) oder nicht (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Gibt an, ob Authentifizierungsanforderungen für diese Anforderung verarbeitet werden sollen (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). Bei der Einstellung <codeph>false</codeph> geben Authentifizierungsfehlversuche einen HTTP-Fehler zurück.  
	
	<p>Die folgenden Authentifizierungsmethoden werden unterstützt:</p>
    
	<ul>
	
		<li>Windows – HTTP Basic/Digest, Windows Integrated Authentication (einschließlich NTLM und Kerberos), SSL Certificate Authentication.</li>
    
		<li>Mac – HTTP Basic/Digest, NTLM, SSL Certificate Authentication.</li>
	
	</ul>
	
	<p><b>Hinweis</b>: Die Methoden <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> und <codeph>HTMLLoader.load()</codeph> unterstützen die·<codeph>URLRequest.authenticate</codeph>-Eigenschaft nicht.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/authenticate"><linktext>flash.net.URLRequestDefaults.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	Gibt an, ob erfolgreiche Antwortdaten für diese Anforderung zwischengespeichert werden sollen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Gibt an, ob erfolgreiche Antwortdaten für diese Anforderung zwischengespeichert werden sollen. Bei der Einstellung <codeph>true</codeph> verwendet die AIR-Anwendung den HTTP-Cache des Betriebssystems.
	
	<p><b>Hinweis</b>: Die <codeph>HTMLLoader.load()</codeph>-Methode unterstützt die <codeph>URLRequest.cacheResponse</codeph>-Eigenschaft nicht.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/cacheResponse"><linktext>flash.net.URLRequestDefaults.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:contentType:get"><apiName>contentType</apiName><shortdesc>
     Der MIME-Inhaltstyp des Inhalts in der data-Eigenschaft.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Der MIME-Inhaltstyp des Inhalts in der <codeph>data</codeph>-Eigenschaft.
     
     <p>Der Standardwert ist <codeph>application/x-www-form-urlencoded</codeph>.</p>
     
     <p><b>Hinweis</b>: Die Methoden <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> und <codeph>HTMLLoader.load()</codeph> unterstützen die·<codeph>URLRequest.contentType</codeph>-Eigenschaft nicht.</p>
     
     <p>Wenn eine POST-Anforderung gesendet wird, müssen die Werte der <codeph>contentType</codeph>- und der <codeph>data</codeph>-Eigenschaft richtig übereinstimmen. Der Wert der <codeph>contentType</codeph>-Eigenschaft weist Server an, wie der Wert der <codeph>data</codeph>-Eigenschaft interpretiert werden soll. </p>
     
     <ul> 
     <li>Wenn der Wert der <codeph>data</codeph>-Eigenschaft ein URLVariables-Objekt ist, muss der Wert für <codeph>contentType</codeph> <codeph>application/x-www-form-urlencoded</codeph> sein. </li>
     
     <li> Wenn der Wert der <codeph>data</codeph>-Eigenschaft ein beliebiger anderer Typ ist, sollte der Wert für <codeph>contentType</codeph> den POST-Datentyp angeben, der gesendet wird (die binären oder String-Daten im Wert für die <codeph>data</codeph>-Eigenschaft). </li>
     
     <li>Für <codeph>FileReference.upload()</codeph> wird der Content-Type der Anforderung automatisch auf <codeph>multipart/form-data</codeph> gesetzt und der Wert für die <codeph>contentType</codeph>-Eigenschaft wird ignoriert.</li>
     </ul>
     
     <p> Wenn Sie in Flash Player 10 oder höher einen Multipart-Content-Type verwenden (z. B. „multipart/form-data“), der einen Upload enthält (gekennzeichnet durch einen „filename“-Parameter in einem „content-disposition“-Header innerhalb des POST-Body), so unterliegt die POST-Methode den Sicherheitsregeln für Uploads:</p>
	 <ul>
	 <li>Der POST-Vorgang muss als Reaktion auf eine durch den Benutzer initiierte Aktion, z. B. Mausklick oder Tastendruck, erfolgen.</li>
	 <li>Ist die POST-Methode domänenübergreifend (das POST-Ziel befindet sich auf einem anderen Server als die SWF-Datei, die die POST-Anforderung sendet), so muss der Zielserver eine URL-Richtliniendatei bereitstellen, die den domänenübergreifenden Zugriff erlaubt.</li>
	 </ul>
     <p>Für alle mehrteiligen Content-Typen muss ebenfalls die Syntax nach Standard RFC2046 gültig sein. Scheint die Syntax ungültig zu sein, so unterliegt die POST-Methode den Sicherheitsregeln für Uploads.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/data"><linktext>data</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:data:get"><apiName>data</apiName><shortdesc>
     Ein Objekt, das mit der URL-Anforderung zu übertragende Daten enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Ein Objekt, das mit der URL-Anforderung zu übertragende Daten enthält. 
     
     <p>Diese Eigenschaft wird zusammen mit der <codeph>method</codeph>-Eigenschaft verwendet. Wenn der Wert für <codeph>method</codeph> <codeph>GET</codeph> ist, wird der Wert für <codeph>data</codeph> an den Wert für <codeph>URLRequest.url</codeph> über eine HTTP-Abfragestringsyntax angehängt. Wenn der <codeph>method</codeph>-Wert <codeph>POST</codeph> (oder ein beliebiger anderer Wert als <codeph>GET</codeph> ist), wird der Wert für <codeph>data</codeph> im Rumpf der HTTP-Anforderung übertragen.</p>
     
     <p>Die API für „URLRequest“ unterstützt binäre <codeph>POST</codeph>-Daten sowie URL-kodierte Variablen und Strings. Das Datenobjekt kann ein ByteArray-, URLVariables- oder String-Objekt sein.</p>
     
     <p>Die Verwendung der Daten hängt vom Objekttyp ab:</p>
     
     <ul>
     
         <li>Wenn es sich um ein ByteArray-Objekt handelt, werden die Binärdaten des Objekts als <codeph>POST</codeph>-Daten verwendet. Der Objekttyp „ByteArray“ wird für <codeph>GET</codeph>-Daten nicht unterstützt. Dasselbe gilt für <codeph>FileReference.upload()</codeph> und <codeph>FileReference.download()</codeph>.</li>
     
         <li>Wenn es sich um ein URLVariables-Objekt handelt und die Methode <codeph>POST</codeph> verwendet wird, werden die Variablen im Format <i>x-www-form-urlencoded</i> kodiert, und der Ergebnisstring wird als <codeph>POST</codeph>-Daten verwendet. Eine Ausnahme bildet hier der Aufruf von <codeph>FileReference.upload()</codeph>, bei dem die Variablen als separate Felder in einem <codeph>multipart/form-data</codeph>-Post gesendet werden.</li>
     
      <li>Wenn es sich um ein URLVariables-Objekt handelt und die Methode <codeph>GET</codeph> verwendet wird, definiert das URLVariables-Objekt die Variablen, die mit dem URLRequest-Objekt gesendet werden.</li>
     
         <li>Andernfalls wird das Objekt in einen String konvertiert, der als <codeph>POST</codeph>- oder <codeph>GET</codeph>-Daten verwendet wird.</li>
     
     </ul>
     
     <p>Die Daten werden erst gesendet, wenn eine Methode (z. B. <codeph>navigateToURL()</codeph> oder <codeph>FileReference.upload()</codeph>) das URLRequest-Objekt verwendet.</p>
     
     <p><b>Hinweis</b>: Der Wert für <codeph>contentType</codeph> muss dem Datentyp in der <codeph>data</codeph>-Eigenschaft entsprechen. Siehe Hinweis in der Beschreibung der <codeph>contentType</codeph>-Eigenschaft.</p>
     
     </apiDesc><example conref="examples\URLVariablesExample.as"> Im folgenden Beispiel wird die Remote-Anwendung unter http://www.[yourDomain].com/application.jsp in einem neuen Browserfenster geöffnet, und in einem URLVariables-Objekt erfasste Daten zu einer Benutzersitzung werden an die Anwendung übergeben. 
  
 <p>Wichtige Beispielauszüge:</p>
 <ol>
    <li>Die Konstruktorfunktion erstellt eine URLRequest-Instanz mit dem Namen <codeph>request</codeph>, wobei die URL der Remote-Anwendung als Parameter verwendet wird.</li>
    <li>Ein URLVariables-Objekt wird erstellt, und zwei seiner Eigenschaften werden Werte zugewiesen.</li>
    <li>Das URLVariables-Objekt wird der Eigenschaft <codeph>data</codeph> des URLRequest-Objekts zugewiesen.</li>
    <li>Das Beispiel ruft <codeph>navigateToURL</codeph> auf, wodurch ein neues Browserfenster mit der URL der Remote-Anwendung geöffnet wird.</li>
 </ol>
 <p> <b>Hinweis:</b> Zur Ausführung des Beispiels muss die URL der Remote-Anwendung durch eine gültige URL ersetzt werden. Darüber hinaus benötigen Sie Servercode, um die von Flash Player im URLVariables-Objekt erfassten Informationen auszuführen.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/method"><linktext>URLRequest.method</linktext></link><link href="flash.net.xml#URLRequestMethod"><linktext>URLRequestMethod</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.net.xml#URLRequest/contentType"><linktext>contentType</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:digest:set"><apiName>digest</apiName><shortdesc>
     Ein String, der die vorzeichenbehaftete Adobe-Plattformkomponente, die im Flash Player-Cache gespeichert (bzw. daraus abgerufen werden soll), eindeutig identifiziert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der bereitgestellte Digest stimmt nicht mit dem Digest der Datei, die aus der heruntergeladenen signierten Datei extrahiert wurde, oder mit der signierten Datei, die aus dem Cache geladen wurde, überein. Die Anwendung gibt diesen Fehler auch zurück, wenn der bereitgestellte Digest die falsche Länge hat oder ungültige (nicht hexadezimale) Zeichen enthält.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Ein String, der die vorzeichenbehaftete Adobe-Plattformkomponente, die im Flash Player-Cache gespeichert (bzw. daraus abgerufen werden soll), eindeutig identifiziert. <ph platform="actionscript"> Eine Adobe-Plattformkomponente ist eine signierte Datei (eine SWZ-Datei), die SWF-Inhalt enthält, der permanent auf dem Computer eines Benutzers zwischengespeichert wird. Alle SWZ-Dateien sind von Adobe signiert. Ein Digest entspricht einer einzelnen zwischengespeicherten Datei; wenn Sie die Datei ändern, ändert sich der Digest in unvorhergesehener Weise. Mithilfe eines Digests können Sie die zwischengespeicherte Datei auf mehreren Domänen verifizieren. Zwei Dateien mit demselben Digest sind dieselbe Datei, und zwei Dateien mit zwei Digests sind nicht dieselbe Datei. Es kann keine Datei erstellt werden, um einen Digest „nachzuahmen“ und einen anderen Digest vorzutäuschen. </ph> <ph platform="javascript">Diese Eigenschaft gilt nur für SWF-Inhalt; sie gilt nicht für JavaScript-Code, der in AIR ausgeführt wird.</ph>
     
     <p platform="actionscript">Der Digest basiert auf einem SHA-256-Meldungs-Digest-Algorithmus (64 Zeichen lang, hexadezimales Format).</p>
     
     <p platform="actionscript">Das Flex SDK enthält z. B. eine SWZ-Datei für das Flex-Framework (und stellt den Digest-String für diese SWZ-Datei bereit). Sie können diese SWZ-Datei auf Ihrem Webserver ablegen und in Ihre SWF-Datei laden (über die <codeph>load()</codeph>-Methode eines URLLoader-Objekts). Wenn auf dem Computer des Endbenutzers bereits die passende SWZ-Datei zwischengespeichert ist, verwendet die Anwendung die zwischengespeicherte SWZ-Datei. (Eine SWZ-Datei „passt“, wenn ihr <codeph>Digest</codeph> dem Digest entspricht, den Sie bereitstellen.) Andernfalls lädt die Anwendung die SWZ-Datei von der von Ihnen angegebenen URL herunter. </p>
     
     <p platform="actionscript">Legen Sie den <codeph>digest</codeph>-Parameter nur in einem URLRequest-Objekt fest, das bei einem Aufruf der <codeph>URLLoader.load()</codeph>-Methode zum Laden einer SWZ-Datei verwendet wird. Wenn die <codeph>digest</codeph>-Eigenschaft eines URLRequest-Objekts festgelegt wird, das in anderen Methoden verwendet wird, gibt die Anwendung einen IOError-Ausnahmefehler zurück.</p>
     
     </apiDesc><example conref="examples\URLRequest_digest.as"> Im folgenden Beispiel wird eine Remotedatei in den Zwischenspeicher geladen. Am Ende des Ladevorgangs enthält das Bytearray die eigentliche Datei (nicht die signierte Datei). Im Beispiel wird der Ladevorgang durch den Aufruf von <codeph>loadBytes()</codeph> abgeschlossen:
<codeblock>
 
var myURLReq:URLRequest = new URLRequest();
myURLReq.url = "http://yourdomain/users/jdoe/test01/_rsc/Automated/AssetCaching_rsc/test01/rsl.swz";
myURLReq.digest = "3B0AA28C7A990385E044D80F5637FB036317BB41E044D80F5637FB036317BB41";
var myURLLoader:URLLoader = new URLLoader();
myURLLoader.dataFormat = URLLoaderDataFormat.BINARY;
myURLLoader.addEventListener("complete", onC);

myURLLoad.load(myURLReq);

function onC(e) {
    var someLoader:Loader = new Loader();
    addChild(someLoader);
    someLoader.loadBytes((ByteArray)(myURLLoad.data)); 
}

</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	Gibt an, ob Weiterleitungen verfolgt werden sollen (true) oder nicht (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Gibt an, ob Weiterleitungen verfolgt werden sollen (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). 
	
	<p><b>Hinweis</b>: Die Methoden <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> und <codeph>HTMLLoader.load()</codeph> unterstützen die·<codeph>URLRequest.followRedirects</codeph>-Eigenschaft nicht.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/followRedirects"><linktext>URLRequestDefaults.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	Gibt an, ob der HTTP-Protokoll-Stack Cookies für diese Anforderung verwalten soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true 
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Gibt an, ob der HTTP-Protokoll-Stack Cookies für diese Anforderung verwalten soll. Bei der Einstellung <codeph>true</codeph> werden der Anforderung Cookies hinzugefügt und Antwortcookies werden gespeichert. Bei der Einstellung <codeph>false</codeph> werden Cookies <i>nicht</i> zu der Anforderung hinzugefügt und Anforderungscookies werden <i>nicht</i> gespeichert, aber Benutzer können Cookies durch direkte Header-Änderungen verwalten. 
	
	<p>Unter Mac OS werden Cookies mit Safari gemeinsam genutzt. Löschen von Cookies unter Mac OS:</p>
	
	<ol>
		<li>Öffnen Sie Safari.</li>
      <li>Wählen Sie „Safari“ > „Einstellungen“ und klicken Sie auf das Bedienfeld „Sicherheit“.</li>
      <li>Klicken Sie auf „Cookies anzeigen“.</li>
		<li>Klicken Sie auf „Alle entfernen“.</li>
	</ol>
	
	<p>Löschen von Cookies unter Windows: </p>
	
	<ol>
		<li>Öffnen Sie das Dialogfeld „Eigenschaften von Internet“ und klicken Sie auf die Registerkarte „Allgemein“.</li>
		<li>Klicken Sie auf „Cookies löschen“. </li>
	</ol>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/manageCookies"><linktext>flash.net.URLRequestDefaults.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:method:get"><apiName>method</apiName><shortdesc>
     Steuert die HTTP-Formularübertragungsmethode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der Parameter <codeph>value</codeph> ist nicht <codeph>URLRequestMethod.GET</codeph> oder <codeph>URLRequestMethod.POST</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>URLRequestMethod.GET
     
     </apiDefaultValue></apiValueDef><apiDesc>
     Steuert die HTTP-Formularübertragungsmethode. 
     
     <p><ph platform="actionscript">Für SWF-Inhalt, der in Flash Player (im Browser) ausgeführt wird, ist diese Eigenschaft auf GET- bzw. POST-Methoden beschränkt und gültige Werte sind <codeph>URLRequestMethod.GET</codeph> bzw. <codeph>URLRequestMethod.POST</codeph>.</ph></p>
     
     <p><ph platform="actionscript">Für Inhalt, der in Adobe AIR ausgeführt wird, können Sie </ph> <ph platform="javascript">Sie können </ph>jeden String-Wert verwenden, wenn sich der Inhalt in der Sicherheitssandbox der Anwendung befindet. Andernfalls sind Sie <ph platform="actionscript">genau wie bei Inhalt, der in Flash Player ausgeführt wird,</ph> auf die GET- und POST-Methode beschränkt<ph platform="javascript"> und gültige Werte sind <codeph>URLRequestMethod.GET</codeph> bzw. <codeph>URLRequestMethod.POST</codeph></ph>.</p>
     
     <p><ph platform="actionscript">Für Inhalt, der in Adobe AIR ausgeführt wird, gilt: Wenn</ph><ph platform="javascript">Wenn </ph> die <codeph>navigateToURL()</codeph>-Funktion verwendet wird, behandelt die Laufzeit ein URLRequest-Objekt, das die POST-Methode verwendet (ein Objekt, dessen <codeph>method</codeph>-Eigenschaft auf <codeph>URLRequestMethod.POST</codeph> eingestellt ist), so, als ob die GET-Methode verwendet wird.</p>
     
     <p><ph platform="actionscript"><b>Hinweis:</b> Wenn Inhalt in Flash Player ausgeführt wird und die referenzierte Form keinen Rumpf hat, verwendet Flash Player automatisch eine GET-Methode, selbst wenn die Methode auf <codeph>URLRequestMethod.POST</codeph> gesetzt ist. Aus diesem Grund wird empfohlen, immer einen „Dummy“-Rumpf einzufügen, um zu gewährleisten, dass die richtige Methode verwendet wird.</ph></p>
     
     </apiDesc><example conref="examples\URLRequest_method.as"> Im folgenden Beispiel wird die Remote-Anwendung unter http://www.[yourDomain].com/application.jsp in einem neuen Browserfenster geöffnet, und in einem URLVariables-Objekt erfasste Daten zu einer Benutzersitzung werden an die Anwendung übergeben. Der Wert der Eigenschaft <codeph>URLRequest.method</codeph> wird explizit auf <codeph>URLRequestMethod.POST</codeph> gesetzt.
 <p>Wichtige Beispielauszüge:</p>
 <ol>
    <li>Die Konstruktorfunktion erstellt eine URLRequest-Instanz mit dem Namen <codeph>request</codeph>, wobei die URL der Remote-Anwendung als Parameter verwendet wird.</li>
    <li>Ein URLVariables-Objekt wird erstellt, und zwei seiner Eigenschaften werden Werte zugewiesen.</li>
    <li>Das URLVariables-Objekt wird der Eigenschaft <codeph>data</codeph> des URLRequest-Objekts zugewiesen.</li>
  <li>Der Wert der Eigenschaft <codeph>URLRequest.method</codeph> wird auf <codeph>URLRequestMethod.POST</codeph> gesetzt.</li>
    <li>Das Beispiel ruft <codeph>navigateToURL</codeph> auf, wodurch ein neues Browserfenster mit der URL der Remote-Anwendung geöffnet wird.</li>
 </ol>
 <p> <b>Hinweis:</b> Zur Ausführung des Beispiels muss die URL der Remote-Anwendung durch eine gültige URL ersetzt werden. Darüber hinaus benötigen Sie Servercode, um die von Flash Player im URLVariables-Objekt erfassten Informationen auszuführen.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequest_method extends Sprite {

        public function URLRequest_method() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            request.method = URLRequestMethod.POST;
            
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequestMethod"><linktext>URLRequestMethod-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:requestHeaders:get"><apiName>requestHeaders</apiName><shortdesc>
     Das Array der an die HTTP-Anforderung anzuhängenden HTTP-Anforderungsheader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Das Array der an die HTTP-Anforderung anzuhängenden HTTP-Anforderungsheader. Das Array besteht aus URLRequestHeader-Objekten. Jedes Objekt im Array muss ein URLRequestHeader-Objekt sein und einen Namens- und einen Wert-String enthalten: 
     <codeblock>
     var rhArray:Array = new Array(new URLRequestHeader("Content-Type", "text/html"));
     </codeblock>
     
     <p><ph platform="actionscript">Flash Player und die AIR-Laufzeitumgebung geben </ph> <ph platform="javascript">Die AIR-Laufzeitumgebung gibt</ph> bestimmte Einschränkungen für Anforderungsheader vor. Weitere Informationen finden Sie in der Beschreibung der URLRequestHeader-Klasse.</p>
     
     <p>Nicht alle Methoden, die URLRequest-Parameter akzeptieren unterstützen die <codeph>requestHeaders</codeph>-Eigenschaft. Informationen zu der von Ihnen aufgerufenen Methode finden Sie in der entsprechenden Dokumentation. Beispiel: Die <codeph>FileReference.upload()</codeph>- und die <codeph>FileReference.download()</codeph>-Methode unterstützen die <codeph>URLRequest.requestHeaders</codeph>-Eigenschaft nicht.</p>
     <p>Aufgrund von Browsereinschränkungen werden benutzerdefinierte HTTP-Anforderungs-Header für <codeph>POST</codeph>-Anforderungen, aber nicht für <codeph>GET</codeph>-Anforderungen unterstützt.</p> 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:url:get"><apiName>url</apiName><shortdesc>
     Die anzufordernde URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Die anzufordernde URL. 
     
     <p>Achten Sie darauf, alle Zeichen zu kodieren, die in der Uniform Resource Locator-Spezifikation (siehe http://www.faqs.org/rfcs/rfc1738.html) als unsicher beschrieben werden oder die im URL-Schema des URLRequest-Objekts reserviert sind (wenn sie nicht für den reservierten Zweck verwendet werden). Verwenden Sie zum Beispiel <codeph>"%25"</codeph> für das Prozentzeichen (%) und <codeph>"%23"</codeph> für das Rautenzeichen (#), wie in <codeph>"http://www.example.com/orderForm.cfm?item=%23B-3&amp;discount=50%25"</codeph>.</p>
     
      <p>Standardmäßig muss die URL in der gleichen Domäne wie die aufrufende Datei sein, es sei denn, der Inhalt wird in der Sicherheitssandbox der <ph platform="actionscript">Adobe AIR</ph>-Anwendung ausgeführt. <ph platform="actionscript">Wenn Sie Daten aus einer anderen Domäne laden müssen, legen Sie eine URL-Richtliniendatei auf dem Server ab, der die Daten hostet</ph>. Weitere Informationen finden Sie in der Beschreibung der URLRequest-Klasse.</p>
     
     <p><ph platform="actionscript">Wenn Inhalt in Adobe AIR ausgeführt wird, können Dateien</ph> <ph platform="javascript">Dateien können</ph> in der Sicherheitssandbox der Anwendung (Dateien, die mit der AIR-Anwendung installiert wurden) auf URLs zugreifen, die eines der folgenden URL-Schemata verwenden:</p>
     
     <ul>
     
      <li><codeph>http</codeph> und <codeph>https</codeph> </li>
     
      <li><codeph>file</codeph> </li>
     
      <li><codeph>app-storage</codeph> </li>
     
      <li><codeph>app</codeph> </li>
     
     </ul>
     
     <p><b>Hinweis:</b> IPv6 (Internet Protocol Version 6) wird<ph platform="actionscript"> in AIR und in Flash Player 9.0.115.0 und höher unterstützt</ph>. IPv6 ist eine Internet Protocol-Version, die 128-Bit-Adressen unterstützt (eine Verbesserung gegenüber der älteren Version IPv4, die 32-Bit-Adressen unterstützt). Möglicherweise müssen Sie IPv6 für Ihre Netzwerkschnittstellen aktivieren. Weitere Informationen finden Sie in der Hilfe des Betriebssystems, unter dem die Daten gehostet werden. Wenn IPv6 auf dem Hostsystem unterstützt wird, können Sie numerische literale IPv6-Adressen in URLs in eckigen Klammern ([])angeben<ph platform="actionscript">, wie im folgenden Beispiel zu sehen</ph>. </p>
     
     <ph platform="actionscript">
     <pre>
     rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]:1935/test
     </pre>
     </ph>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:useCache:get"><apiName>useCache</apiName><shortdesc>
	Gibt an, ob der lokale Cache überprüft werden soll, bevor diese URLRequest Daten abruft.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Gibt an, ob der lokale Cache überprüft werden soll, bevor diese URLRequest Daten abruft. 
	
	<p><b>Hinweis</b>: Die <codeph>HTMLLoader.load()</codeph>-Methode unterstützt die <codeph>URLRequest.useCache</codeph>-Eigenschaft nicht.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/useCache"><linktext>flash.net.URLRequestDefaults.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	Legt den Benutzer-Agent-String fest, der in der HTTP-Anforderung verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der Aufrufer befindet sich nicht in der Sicherheitssandbox der AIR-Anwendung.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Legt den Benutzer-Agent-String fest, der in der HTTP-Anforderung verwendet wird. 
	
	<p platform="actionscript">Der Standardwert ist der gleiche Benutzer-Agent-String, der von Flash Player verwendet wird und unter Mac, Linux und Windows unterschiedlich ist.</p>
	
	<p><i>Hinweis:</i> Diese Eigenschaft hat keinen Einfluss auf den Benutzer-Agent-String, wenn das URLRequest-Objekt mit der <codeph>load()</codeph>-Methode eines HTMLLoader-Objekts verwendet wird. Um den Benutzer-Agent-String für ein HTMLLoader-Objekt festzulegen, stellen Sie die <codeph>userAgent</codeph>-Eigenschaft des HTMLLoader-Objekts ein oder legen Sie die statische <codeph>URLRequestDefaults.userAgent</codeph>-Eigenschaft fest.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/userAgent"><linktext>flash.net.URLRequestDefaults.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileFilter"><apiName>FileFilter</apiName><shortdesc>
 Mit der FileFilter-Klasse wird angegeben, welche Dateien des Benutzersystems im Dialogfeld zum Suchen nach Dateien angezeigt werden. Dieses Dialogfeld wird beim Aufruf der FileReference.browse()-Methode oder der FileReferenceList.browse()-Methode angezeigt oder wenn eine browse-Methode eines File-, FileReference- oder FileReferenceList-Objekts aufgerufen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der FileFilter-Klasse wird angegeben, welche Dateien des Benutzersystems im Dialogfeld zum Suchen nach Dateien angezeigt werden. Dieses Dialogfeld wird beim Aufruf der <codeph>FileReference.browse()</codeph>-Methode oder der <codeph>FileReferenceList.browse()</codeph>-Methode angezeigt oder wenn eine browse-Methode eines File-, FileReference- oder FileReferenceList-Objekts aufgerufen wird. FileFilter-Instanzen werden als Wert für den optionalen <codeph>typeFilter</codeph>-Parameter an die Methode übergeben. Bei Verwendung einer FileFilter-Instanz werden nicht in der FileFilter-Instanz angegebene Erweiterungen und Dateitypen herausgefiltert, d. h., der Benutzer kann diese Dateien nicht auswählen. Wenn kein FileFilter-Objekt an die Methode übergeben wird, werden alle Dateien im Dialogfeld angezeigt.
 
 <p>Es gibt zwei Möglichkeiten zur Verwendung von FileFilter-Instanzen:</p>
 
 <ul>
 
   <li>Eine Beschreibung mit Dateierweiterungen</li>
 
   <li>Eine Beschreibung mit Dateierweiterungen und Macintosh-Dateitypen</li>
 
 </ul>
 
 <p>Die beiden Formate können in einem Aufruf der browse-Methode nicht gleichzeitig verwendet werden. Sie können immer nur ein Format verwenden.</p>
 
 <p>Sie können eine oder mehrere FileFilter-Instanzen an die browse-Methode übergeben, wie im folgenden Beispiel gezeigt:</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFileReference:FileReference = new FileReference();
 myFileReference.browse([imagesFilter, docFilter]);
 </codeblock>
 
 <p platform="actionscript">Oder in einer AIR-Anwendung:</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile:File = new File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <codeblock platform="javascript">
 var imagesFilter = new air.FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter = new air.FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile = new air.File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <p>Die Liste der Erweiterungen in der <codeph>FileFilter.extension</codeph>-Eigenschaft wird verwendet, um die Dateien zu filtern, die im Dialogfeld zum Suchen nach Dateien angezeigt werden. Die eigentliche Liste wird nicht im Dialogfeld angezeigt. Um die Dateitypen für Benutzer anzuzeigen, müssen Sie die Dateitypen im Beschreibungsstring und in der Erweiterungsliste auflisten. Der Beschreibungsstring wird im Dialogfeld in Windows und Linux angezeigt. (Auf dem Macintosh<sup>®</sup>wird er nicht verwendet.) Wenn Sie auf einem Macintosh-System eine Liste der Macintosh-Dateitypen bereitstellen, so wird dies ebenfalls zum Filtern der Dateianzeige verwendet. Andernfalls wird die Liste der Dateierweiterungen verwendet. </p> 
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:FileFilter:FileFilter"><apiName>FileFilter</apiName><shortdesc>
	 Erstellt eine neue FileFilter-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>description</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der für Benutzer beim Auswählen von Dateien zum Upload sichtbare Beschreibungsstring.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Eine Liste der Dateierweiterung, die angibt, welche Dateiformate für Benutzer sichtbar sind, wenn sie Dateien auswählen, die hochgeladen werden sollen.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>macType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine Liste der Macintosh-Dateitypen, die angibt, welche Dateitypen für Benutzer sichtbar sind, wenn sie Dateien auswählen, die hochgeladen werden sollen. Dieser Parameter wird auf <codeph>null</codeph> gesetzt, wenn kein Wert übergeben wird.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Erstellt eine neue FileFilter-Instanz.
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:FileFilter:description:get"><apiName>description</apiName><shortdesc>
	 Der Beschreibungsstring für den Filter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Der Beschreibungsstring für den Filter. Die Beschreibung ist für den Benutzer in dem Dialogfeld sichtbar, das beim Aufruf von <codeph>FileReference.browse()</codeph> oder <codeph>FileReferenceList.browse()</codeph> geöffnet wird. Der Beschreibungsstring enthält einen String (z. B. <codeph>"Images (~~.gif, ~~.jpg, ~~.png)"</codeph>) mit Informationen darüber, welche Dateitypen hoch- bzw. heruntergeladen werden können. Beachten Sie, dass die von diesem FileReference-Objekt unterstützten Dateitypen in der Eigenschaft <codeph>extension</codeph> gespeichert sind.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:extension:get"><apiName>extension</apiName><shortdesc>
	 Eine Liste mit Dateierweiterungen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Eine Liste mit Dateierweiterungen. Diese Liste enthält die Dateitypen, die im Dialogfeld zum Suchen von Dateien angezeigt werden sollen. (Diese Liste ist für den Benutzer nicht sichtbar. Der Benutzer sieht lediglich den Wert der Eigenschaft <codeph>description</codeph>.) Die <codeph>extension</codeph>-Eigenschaft enthält eine durch Semikola getrennte Liste mit Dateierweiterungen, in der vor jede Erweiterung ein Platzhalterzeichen (~~) gesetzt wurde, wie im folgenden String zu sehen: <codeph>"~~.jpg;~~.gif;~~.png"</codeph>.
	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:macType:get"><apiName>macType</apiName><shortdesc>
	 Eine Liste mit Macintosh-Dateitypen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Eine Liste mit Macintosh-Dateitypen. Diese Liste enthält die Dateitypen, die im Dialogfeld zum Suchen von Dateien angezeigt werden sollen. (Diese Liste ist für den Benutzer nicht sichtbar. Der Benutzer sieht lediglich den Wert der Eigenschaft <codeph>description</codeph>.) Die Eigenschaft <codeph>macType</codeph> enthält eine Liste mit Macintosh-Dateitypen und Semikola als Trennzeichen wie im folgenden String gezeigt: <codeph>"JPEG;jp2_;GIFF"</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStream"><apiName>NetStream</apiName><shortdesc>
 Die NetStream-Klasse öffnet eine Streaming-Verbindung in einer Richtung zwischen einer AIR- oder Flash Player-Anwendung und Flash Media Server oder zwischen einer AIR- oder Flash Player-Anwendung und dem lokalen Dateisystem.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die NetStream-Klasse öffnet eine Streaming-Verbindung in einer Richtung zwischen einer AIR- <ph platform="actionscript">oder Flash Player</ph>-Anwendung und Flash Media Server oder zwischen einer AIR- <ph platform="actionscript">oder Flash Player</ph>-Anwendung und dem lokalen Dateisystem. Ein NetStream-Objekt ist ein Kanal innerhalb eines NetConnection-Objekts. Dieser Kanal kann entweder unter Verwendung von <codeph>NetStream.publish()</codeph> einen Stream veröffentlichen, oder er kann unter Verwendung von <codeph>NetStream.play()</codeph> einen veröffentlichten Stream abonnieren und Daten empfangen. Sie können sowohl Live-Daten (Echtzeitdaten) als auch aufgezeichnete Daten veröffentlichen und wiedergeben. Sie könne auch die <codeph>NetStream.send()</codeph>-Methode aufrufen, um Textnachrichten an alle abonnierten Clients zu senden.
 
 <p platform="actionscript">Das Abspielen externer Videodateien bietet mehrere Vorteile im Vergleich zum Einbetten von Videodateien in SWF-Dokumente, so z. B. bessere Leistungs- und Speicherverwaltung und unabhängige Video- und SWF-Bildraten. </p>
 
 <p>Adobe AIR und Flash Player 9.0.115.0 _de und höhere Versionen unterstützen Dateien, die aus dem MPEG-4-Containerstandardformat abgeleitet werden, darunter F4V, MP4, M4A, MOV, MP4V, 3GP und 3G2, wenn diese Formate H.264-Video und/oder HEAAC v2-kodiertes Audio enthalten. Mit H.264 ist die Videoqualität im Vergleich zu demselben Kodierungsprofil in Sorenson oder On2 bei niedrigeren Bitraten höher. HE-AAC v2 ist eine Erweiterung des AAC-Formats (ein Standardaudioformat, das im MPEG-4-Videostandard definiert ist), das Spectral Band Replication (SBR) und Parametric Stereo (PS) verwendet, damit bei niedrigeren Bitraten effizienter kodiert werden kann. Weitere Informationen zu unterstützten Codecs und Dateiformaten finden Sie unter <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> und <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.</p>
 
 <p><b>Workflow zur Veröffentlichung und Wiedergabe von Streams:</b></p>
 
 <ol>
 <li>Erstellen Sie ein NetConnection-Objekt.</li>
 <li>Rufen Sie die <codeph>NetConnection.connect()</codeph>-Methode auf, um eine Verbindung zur Anwendungsinstanz auf dem Server herzustellen.</li>
 <li>Erstellen Sie ein NetStream-Objekt, um einen Stream innerhalb der Verbindung zu erstellen.</li>
 <li>Um Audio und Video zu erfassen, zu kodieren und zu veröffentlichen, rufen Sie die <codeph>NetStream.attachAudio()</codeph>- und die <codeph>NetStream.attachCamera()</codeph>-Methode auf.</li>
 <li>Rufen Sie die <codeph>NetStream.publish()</codeph>-Methode auf, um den Stream einen eindeutigen Namen zu geben und Daten über den Stream an den Server zu senden, damit andere ihn erhalten können. Sie können die veröffentlichten Daten auch aufzeichnen, sodass Benutzer die Möglichkeit haben, sie zu einem späteren Zeitpunkt wiederzugeben.</li>
 <li>Rufen Sie die <codeph>NetStream.play()</codeph>-Methode auf, um einen Live-Stream oder einen aufgenommenen Stream wiederzugeben. Übergeben Sie der <codeph>play()</codeph>-Methode den Namen des Strings, der an die <codeph>publish()</codeph>-Methode übergeben wurde.</li>
 </ol>
 
 <p><b>Verwenden von Daten-Keyframes mit Flash Media Server:</b> Nachdem Sie NetConnection- und NetStream-Objekte erstellt haben, können Sie mit <codeph>NetStream.send()</codeph>Metadaten zu Live-Audio oder Video hinzufügen, während Sie es auf den Server streamen. Als Metadaten werden zum Beispiel Informationen zur Höhe oder Breite eines Videos, zur Spieldauer oder zum Namen des Erstellers bezeichnet. Sie definieren die Metadaten mit dem speziellen Prozedurnamen <codeph>@setDataFrame</codeph> als erstes Argument für <codeph>NetStream.send()</codeph>.</p>
 
 <p><b>Empfangen von Daten von einem Flash Media Server-Stream, von einer progressiven F4V-Datei oder von einer progressiven FLV-Datei:</b> Flash Media Server, F4V- und FLV-Dateien können Ereignisobjekte, die Daten enthalten, an spezifischen Datenpunkten während des Streamens oder der Wiedergabe senden. Sie können Daten aus einem Stream oder einer FLV-Datei während der Wiedergabe auf zwei Weisen handhaben:</p>
 
 <ul><li>Verknüpfen Sie eine Client-Eigenschaft mit einer Ereignisprozedur, um das Datenobjekt zu empfangen. Verwenden Sie die <codeph>NetStream.client</codeph>-Eigenschaft, um ein Objekt zu verknüpfen, das spezifische Datenhandhabungsfunktionen aufrufen soll. Das mit der <codeph>NetStream.client</codeph>-Eigenschaft verknüpfte Objekt kann die folgenden Datenpunkte überwachen: <codeph>onCuePoint()</codeph>, <codeph>onImageData()</codeph>, <codeph>onMetaData()</codeph>, <codeph>onPlayStatus()</codeph>, <codeph>onTextData()</codeph> und <codeph>onXMPData()</codeph>. Schreiben Sie anschließend Prozeduren in diese Funktionen, um das vom Stream oder von der FLV-Datei während der Wiedergabe zurückgegebene Datenobjekt zu handhaben. Weitere Informationen finden Sie unter der <codeph>NetStream.client</codeph>-Eigenschaft.</li>
 <li>Verknüpfen Sie eine Client-Eigenschaft mit einer Unterklasse der NetStream-Klasse und schreiben Sie anschließend eine Ereignisprozedur, um das Datenobjekt zu empfangen. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine Unterklasse für „NetStream“ erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li></ul>
 
 <p><b>Hinweis:</b> Um Daten über eine Audiodatei wie z. B. eine MP3-Datei zu senden, verwenden Sie die Soundklasse, um die Audiodatei mit einem Soundobjekt zu verknüpfen. Verwenden Sie anschließend die <codeph>Sound.id3</codeph>-Eigenschaft, um Metadaten aus der Sounddatei zu lesen.</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> Im folgenden Beispiel wird ein Videoobjekt mit der NetConnection- und NetStream-Klasse verwendet, um eine FLV-Datei zu laden und abzuspielen. Zur Ausführung dieses Beispiels benötigen Sie eine FLV-Datei, deren Name und Speicherort mit der an <codeph>videoURL</codeph> übergebenen Variablen übereinstimmt. In diesem Fall ist das eine FLV-Datei mit dem Namen „Video.flv“, die in dem Verzeichnis abgelegt ist, in dem sich die SWF-Datei befindet.
 <p>In diesem Fall wird der Code zur Erstellung des Video- und NetStream-Objekts und zum Aufrufen der Methoden <codeph>Video.attachNetStream()</codeph> und <codeph>NetStream.play()</codeph> in eine Prozedurfunktion eingefügt. Die Prozedur wird nur aufgerufen, wenn die Verbindung mit dem NetConnection-Objekt erfolgreich hergestellt werden kann, d. h. wenn das Ereignis <codeph>netStatus</codeph> ein <codeph>info</codeph>-Objekt mit einer <codeph>code</codeph>-Eigenschaft zurückgibt, die Erfolg angibt. Es wird empfohlen, die erfolgreiche Verbindungsherstellung abzuwarten, bevor Sie <codeph>NetStream.play()</codeph> aufrufen. </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video"><linktext>flash.media.Video</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream_flash.events.DRMStatusEvent.DRM_STATUS_drmStatus"><apiName>drmStatus</apiName><shortdesc>
 Wird ausgelöst, wenn der DRM-verschlüsselte Inhalt (Digital Rights Management) abgespielt wird (wenn der Benutzer authentifiziert wurde und berechtigt ist, den Inhalt abzuspielen).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMStatusEvent.DRM_STATUS</apiEventType><adobeApiEventClassifier>flash.events.DRMStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der DRM-verschlüsselte Inhalt (Digital Rights Management) abgespielt wird (wenn der Benutzer authentifiziert wurde und berechtigt ist, den Inhalt abzuspielen).
 <p>
 Das DRMStatusEvent-Objekt enthält Informationen über den Gutschein, zum Beispiel, ob der Inhalt offline zur Verfügung gestellt werden kann oder wann der Gutschein abläuft und der Inhalt nicht mehr angezeigt werden kann.
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMStatusEvent"><linktext>flash.events.DRMStatusEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMErrorEvent.DRM_ERROR_drmError"><apiName>drmError</apiName><shortdesc>
 Wird ausgelöst, wenn ein NetStream-Objekt versucht, eine mit DRM (Digital Rights Management) verschlüsselte Datei abzuspielen und dabei ein DRM-Fehler auftritt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMErrorEvent.DRM_ERROR</apiEventType><adobeApiEventClassifier>flash.events.DRMErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein NetStream-Objekt versucht, eine mit DRM (Digital Rights Management) verschlüsselte Datei abzuspielen und dabei ein DRM-Fehler auftritt. Ein DRMErrorEvent-Objekt wird zum Beispiel ausgelöst, wenn die Benutzerautorisierung fehlschlägt. Dies kann daran liegen, dass der Benutzer die Berechtigung zum Anzeigen des Inhalts nicht erworben hat oder dass der Content Provider das Anzeigen der Anwendung nicht unterstützt.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMErrorEvent"><linktext>flash.events.DRMErrorEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE_drmAuthenticate"><apiName>drmAuthenticate</apiName><shortdesc>
 Wird ausgelöst, wenn ein NetStream-Objekt versucht, mit DRM (Digital Rights Management) verschlüsselten Inhalt abzuspielen, für den Benutzerdaten zur Authentifizierung erforderlich sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE</apiEventType><adobeApiEventClassifier>flash.events.DRMAuthenticateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein NetStream-Objekt versucht, mit DRM (Digital Rights Management) verschlüsselten Inhalt abzuspielen, für den Benutzerdaten zur Authentifizierung erforderlich sind. 
 
 <p>
 Authentifizieren Sie den Benutzer mit der <codeph> setDRMAuthenticationCredentials()</codeph>-Methode des NetStream-Objekts. Wenn die Benutzerauthentifizierung fehlschlägt, startet die Anwendung einen neuen Versuch und löst ein neues DRMAuthenticateEvent-Ereignis für das NetStream-Objekts aus.
 </p>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onDRMContentData"><apiName>onDRMContentData</apiName><shortdesc>
 Erstellt einen Listener, der reagiert, wenn AIR DRM-Inhalts-Metadaten extrahiert, die in einer Mediendatei eingebettet sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Erstellt einen Listener, der reagiert, wenn AIR DRM-Inhalts-Metadaten extrahiert, die in einer Mediendatei eingebettet sind.
 
 <p>Ein DRMContentData-Objekt enthält die notwendigen Informationen, um einen Gutschein zu erhalten, der zur Wiedergabe einer DRM-geschützten Mediendatei erforderlich ist. Verwenden Sie die DRMManager-Klasse, um den Gutschein mit diesen Informationen herunterzuladen.</p>
 
 <p><codeph>onDRMContentData</codeph> ist eigentlich eine Eigenschaft des <codeph>NetStream.client</codeph>-Objekts. Es ist kein Ereignis, ist aber im Abschnitt „Ereignisse“ aufgeführt, weil es beim Vorabladen eingebetteter Daten aus einer lokalen Mediendatei auf ein Datenereignis reagiert. Weitere Informationen finden Sie in der Beschreibung der NetStream-Klasse. Sie können die <codeph>addEventListener()</codeph>-Methode bzw. andere EventDispatcher-Methoden nicht verwenden, um <codeph>onDRMContentData</codeph> zu überwachen oder als ein Ereignis zu verarbeiten. Stattdessen müssen Sie eine einzelne Callback-Funktion definieren und direkt an eines der folgenden Objekte anhängen:</p>
 <ul>
  <li>Das Objekt, auf das die <codeph>client</codeph>-Eigenschaft einer NetStream-Instanz verweist.</li>    
  <li>Eine Instanz einer NetStream-Unterklasse. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine Unterklasse für „NetStream“ erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li>
 </ul>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.xml#NetStream/preloadEmbeddedData()"><linktext>preloadEmbeddedData()</linktext></link><link href="flash.net.drm.xml#DRMManager"><linktext>flash.net.drm.DRMManager</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onPlayStatus"><apiName>onPlayStatus</apiName><shortdesc>
 Erstellt einen Listener, der reagiert, wenn ein NetStream-Objekt einen Stream vollständig abgespielt hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Erstellt einen Listener, der reagiert, wenn ein NetStream-Objekt einen Stream vollständig abgespielt hat. Das verknüpfte Ereignisobjekt liefert zusätzliche Informationen zu dem, was vom <codeph>netStatus</codeph>-Ereignis zurückgegeben wird. Sie können diese Eigenschaft verwenden, um Aktionen in Ihrem Code auszulösen, wenn ein NetStream-Objekt von einem Stream zu einem anderen Stream in einer Wiedergabeliste gewechselt hat (wie durch das Informationsobjekt <codeph>NetStream.Play.Switch</codeph> angegeben) oder wenn ein NetStream-Objekt bis zum Ende abgespielt wurde (wie durch das Informationsobjekt <codeph>NetStream.Play.Complete</codeph> angegeben). 
 
 <p><codeph>onPlayStatus</codeph> ist eigentlich eine Eigenschaft des <codeph>NetStream.client</codeph>-Objekts. Es ist kein Ereignis, ist aber im Abschnitt „Ereignisse“ aufgeführt, weil es auf ein Datenereignis reagiert, wenn entweder mit dem Media Flash Player gestreamt oder eine FLV-Datei wiedergegeben wird. Weitere Informationen finden Sie in der Beschreibung der NetStream-Klasse. Sie können die <codeph>addEventListener()</codeph>-Methode bzw. andere EventDispatcher-Methoden nicht verwenden, um <codeph>onPlayStatus</codeph> zu überwachen oder als ein Ereignis zu verarbeiten. Stattdessen müssen Sie eine einzelne Callback-Funktion definieren und direkt an eines der folgenden Objekte anhängen:</p>
 
 <ul>
  <li>Das Objekt, auf das die <codeph>client</codeph>-Eigenschaft einer NetStream-Instanz verweist.</li>    
  <li>Eine Instanz einer NetStream-Unterklasse. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine NetStream-Unterklasse erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li>
    
 </ul>
 
 <p>Dieses Ereignis kann ein Informationsobjekt mit den folgenden Eigenschaften zurückgeben:</p>
 
 <adobetable class="innertable">
  
  
  
   
 <tgroup cols="3"><thead><row><entry>Code-Eigenschaft</entry><entry>Level-Eigenschaft</entry><entry>Bedeutung</entry></row></thead><tbody><row>
    <entry><codeph>NetStream.Play.Switch</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>Der Abonnent wechselt von einem Stream zu einem anderen Stream in der Wiedergabeliste.</entry>
  </row><row>
    <entry><codeph>NetStream.Play.Complete</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>Die Wiedergabe ist abgeschlossen.</entry>
  </row><row>
    <entry><codeph>NetStream.Play.TransitionComplete</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>Der Abonnent wechselt als Ergebnis des Stream-Bitratenwechsels zu einem neuen Stream.</entry>
  </row></tbody></tgroup></adobetable>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.events.xml#NetStatusEvent/NET_STATUS"><linktext>flash.events.NetStatusEvent.NET_STATUS</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onCuePoint"><apiName>onCuePoint</apiName><shortdesc>
 Erstellt einen Listener, der reagiert, wenn während des Abspielens einer Videodatei ein eingebetteter Cue-Point erreicht wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Erstellt einen Listener, der reagiert, wenn während des Abspielens einer Videodatei ein eingebetteter Cue-Point erreicht wird. Sie können den Listener verwenden, um Aktionen in Ihrem Code auszulösen, wenn das Video einen bestimmten Cue-Punkt erreicht, an dem Sie andere Aktionen in Ihrer Anwendung mit Videoabspielereignissen synchronisieren können. Weitere Informationen zu Videoformaten, die vom Flash Media Server unterstützt werden, finden Sie unter <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.

 
 <p><codeph>onCuePoint</codeph> ist eigentlich eine Eigenschaft des <codeph>NetStream.client</codeph>-Objekts. Es ist kein Ereignis, ist aber im Abschnitt „Ereignisse“ aufgeführt, weil es auf ein Datenereignis reagiert, wenn entweder mit dem Media Flash Player gestreamt oder eine FLV-Datei wiedergegeben wird. Weitere Informationen finden Sie in der Beschreibung der NetStream-Klasse. Sie können die <codeph>addEventListener()</codeph>-Methode bzw. andere EventDispatcher-Methoden nicht verwenden, um <codeph>onCuePoint</codeph> zu überwachen oder als ein Ereignis zu verarbeiten. Stattdessen müssen Sie eine einzelne Callback-Funktion definieren und direkt an eines der folgenden Objekte anhängen:</p>
 
 <ul>
  <li>Das Objekt, auf das die <codeph>client</codeph>-Eigenschaft einer NetStream-Instanz verweist.</li>    
  <li>Eine Instanz einer NetStream-Unterklasse. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine Unterklasse für „NetStream“ erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li>
    
 </ul>
 
 <p>Der verknüpfte Ereignis-Listener wird nach dem Aufruf der <codeph>NetStream.play()</codeph>-Methode, aber noch vor dem Vorlauf des Abspielkopfes ausgelöst.</p>
 
 <p>Folgende Typen von Cue-Points können in eine Videodatei eingebettet werden:</p>
 
 <ul>
 <li>Ein Navigations-Cue-Point gibt ein Schlüsselbild innerhalb der Videodatei an, wobei die <codeph>time</codeph>-Eigenschaft des Cue-Points exakt dem Schlüsselbild entspricht. Navigations-Cue-Points werden oft als Lesezeichen oder Eingangspunkte verwendet, anhand derer die Benutzer durch die Videodatei navigieren können.</li>
 
 <li>Ein Ereignis-Cue-Point wird nach Zeit angegeben, unabhängig davon, ob diese Zeitangabe einem bestimmten Schlüsselbild entspricht. Ein Ereignis-Cue-Point steht in der Regel für einen Zeitpunkt eines Ereignisses im Video, das zur Auslösung anderer Anwendungsereignisse verwendet werden kann.</li>
 </ul>
 
 <p>Das <codeph>onCuePoint</codeph>-Ereignisobjekt hat folgende Eigenschaften:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Eigenschaft</entry><entry>Beschreibung</entry></row></thead><tbody><row>
   <entry><codeph>name</codeph></entry>
   <entry>Der dem Cue-Point bei der Einbettung in die Videodatei zugewiesene Name.</entry></row><row>
   <entry><codeph>parameters</codeph></entry>
   <entry>Ein assoziatives Array mit Namen/Wert-Paar-Strings, die für diesen Cue-Punkt spezifiziert sind. Für Name und Wert des Parameters können beliebige Strings verwendet werden.</entry>
 </row><row>
   <entry><codeph>time</codeph></entry>
   <entry>Die Angabe des Zeitpunkts in Sekunden, zu dem der Cue-Point während der Wiedergabe im Video auftritt.</entry>
 </row><row>
   <entry><codeph>type</codeph></entry>
   <entry>Der Typ des erreichten Cue-Points (Navigation oder Ereignis).</entry>
 </row></tbody></tgroup></adobetable>
 
 <p>Sie können Cue-Points beim ersten Kodieren der Videodatei oder beim Importieren eines Videoclips in das Flash-Authoring-Tool mit dem Videoimportassistenten einfügen.</p>
 
 <p>Das Ereignis <codeph>onMetaData</codeph> ruft auch Informationen über die Cue-Points in einer Videodatei ab. Das Ereignis <codeph>onMetaData</codeph> ruft jedoch Informationen über alle Cue-Points ab, bevor die Wiedergabe des Videos gestartet wird. Das Ereignis <codeph>onCuePoint</codeph> ruft dagegen Informationen über einen einzelnen Cue-Point zu dem für diesen Cue-Point festgelegten Zeitpunkt während der Wiedergabe ab.</p>
 
 <p>Wenn Sie bei einem bestimmten Cue-Point zu dem Zeitpunkt, zu dem er in der Wiedergabe auftritt, eine Aktion im Code auslösen möchten, verwenden Sie das Ereignis <codeph>onCuePoint</codeph>.</p>
 
 <p>Mit der für das Ereignis <codeph>onMetaData</codeph> bereitgestellten Liste von Cue-Points können Sie den Benutzern ermöglichen, die Wiedergabe an vordefinierten Punkten im Videostream zu starten. Übergeben Sie den Wert der <codeph>time</codeph>-Eigenschaft des Cue-Point an die Methode <codeph>NetStream.seek()</codeph>, um die Wiedergabe des Videos ab diesem Cue-Point zu starten.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onTextData"><apiName>onTextData</apiName><shortdesc>
  Erstellt einen Listener, der reagiert, wenn Flash Player Textdaten empfängt, die in einer aktuell abgespielten Mediendatei eingebettet sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  Erstellt einen Listener, der reagiert, wenn Flash Player Textdaten empfängt, die in einer aktuell abgespielten Mediendatei eingebettet sind. Die Textdaten sind im Format UTF-8 und können Informationen über Formatierungen basierend auf der 3GP-Timed-Textspezifikation enthalten.
  <p><codeph>onTextData</codeph> ist eigentlich eine Eigenschaft des <codeph>NetStream.client</codeph>-Objekts. Es ist kein Ereignis, ist aber im Abschnitt „Ereignisse“ aufgeführt, weil es auf ein Datenereignis reagiert, wenn entweder mit dem Media Flash Player gestreamt oder eine FLV-Datei wiedergegeben wird. Weitere Informationen finden Sie in der Beschreibung der NetStream-Klasse. Sie können die <codeph>addEventListener()</codeph>-Methode bzw. andere EventDispatcher-Methoden nicht verwenden, um <codeph>onTextData</codeph> zu überwachen oder als ein Ereignis zu verarbeiten. Stattdessen müssen Sie eine einzelne Callback-Funktion definieren und direkt an eines der folgenden Objekte anhängen:</p>
 
 <ul>
  <li>Das Objekt, auf das die <codeph>client</codeph>-Eigenschaft einer NetStream-Instanz verweist.</li>    
  <li>Eine Instanz einer NetStream-Unterklasse. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine Unterklasse für „NetStream“ erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li>
    
 </ul>
 
 <p>Der verknüpfte Ereignis-Listener wird nach dem Aufruf der <codeph>NetStream.play()</codeph>-Methode, aber noch vor dem Vorlauf des Abspielkopfes ausgelöst.</p>
  
  <p>Das onTextData-Ereignisobjekt enthält eine Eigenschaft für jeden Textdatenteil.</p>
  
  </apiDesc><example conref="examples\OnTextDataExample.as"> Der Code in diesem Beispiel verwendet die <codeph>Netstream.client</codeph>-Eigenschaft, um die Callback-Funktionen für <codeph>onTextData</codeph> und <codeph>onImageData</codeph> zu verarbeiten. Die <codeph>onImageDataHandler()</codeph>-Funktion verwendet das onImageData-Ereignisobjekt <codeph>imageData</codeph>, um das Bytearray zu speichern. Zusätzlich verwendet die <codeph>onTextDataHandler()</codeph>-Funktion das onTextData-Ereignisobjekt <codeph>textData</codeph>, um Teile von Textdaten zu speichern (jeder Datenteil ist eine Eigenschaft des <codeph>textData</codeph>-Objekts).
 <p>Sie müssen den <codeph>"yourURL"</codeph>-Speicherort im Code durch einen realen Speicherort für eine Mediendatei mit Text- oder Bildmetadaten ersetzen.</p>
 <p> Sie können auch Bild- und Textdaten mithilfe einer benutzerdefinierten Klasse verarbeiten. Weitere Informationen und Beispiele finden Sie im Artikel <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Verarbeiten von Metadaten und Cue-Points in Flash Video</xref>.</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onImageData"><apiName>onImageData</apiName><shortdesc>
 Erstellt einen Listener, der reagiert, wenn Flash Player Bilddaten als Bytearray erhält, das in einer Mediendatei eingebettet ist, die aktuell abgespielt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Erstellt einen Listener, der reagiert, wenn Flash Player Bilddaten als Bytearray erhält, das in einer Mediendatei eingebettet ist, die aktuell abgespielt wird. Die Bilddaten können entweder JPEG-, PNG- oder GIF-Inhalt erzeugen. Verwenden Sie die <codeph>flash.display.Loader.loadBytes()</codeph>-Methode, um das Bytearray in ein Anzeigeobjekt zu laden.
 <p><codeph>onImageData</codeph> ist eigentlich eine Eigenschaft des <codeph>NetStream.client</codeph>-Objekts. Es ist kein Ereignis, ist aber im Abschnitt „Ereignisse“ aufgeführt, weil es auf ein Datenereignis reagiert, wenn entweder mit dem Media Flash Player gestreamt oder eine FLV-Datei wiedergegeben wird. Weitere Informationen finden Sie in der Beschreibung der NetStream-Klasse. Sie können die <codeph>addEventListener()</codeph>-Methode bzw. andere EventDispatcher-Methoden nicht verwenden, um <codeph>onImageData</codeph> zu überwachen oder als ein Ereignis zu verarbeiten. Stattdessen müssen Sie eine einzelne Callback-Funktion definieren und direkt an eines der folgenden Objekte anhängen:</p>
 
 <ul>
  <li>Das Objekt, auf das die <codeph>client</codeph>-Eigenschaft einer NetStream-Instanz verweist.</li>    
  <li>Eine Instanz einer NetStream-Unterklasse. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine Unterklasse für „NetStream“ erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li>
    
 </ul>
 
 <p>Der verknüpfte Ereignis-Listener wird nach dem Aufruf der <codeph>NetStream.play()</codeph>-Methode, aber noch vor dem Vorlauf des Abspielkopfes ausgelöst.</p>
 
 <p>Das onImageData-Ereignisobjekt enthält die Bilddaten als ein Bytearray, das über einen AMF0-Datenkanal gesendet wird.</p>
 
 </apiDesc><example conref="examples\OnTextDataExample.as"> Der Code in diesem Beispiel verwendet die <codeph>Netstream.client</codeph>-Eigenschaft, um die Callback-Funktionen für <codeph>onTextData</codeph> und <codeph>onImageData</codeph> zu verarbeiten. Die <codeph>onImageDataHandler()</codeph>-Funktion verwendet das onImageData-Ereignisobjekt <codeph>imageData</codeph>, um das Bytearray zu speichern. Zusätzlich verwendet die <codeph>onTextDataHandler()</codeph>-Funktion das onTextData-Ereignisobjekt <codeph>textData</codeph>, um Teile von Textdaten zu speichern (jeder Datenteil ist eine Eigenschaft des <codeph>textData</codeph>-Objekts).
 <p>Sie müssen den <codeph>"yourURL"</codeph>-Speicherort im Code durch einen realen Speicherort für eine Mediendatei mit Text- oder Bildmetadaten ersetzen.</p>
 <p> Sie können auch Bild- und Textdaten mithilfe einer benutzerdefinierten Klasse verarbeiten. Weitere Informationen und Beispiele finden Sie im Artikel <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Verarbeiten von Metadaten und Cue-Points in Flash Video</xref>.</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onMetaData"><apiName>onMetaData</apiName><shortdesc>
 Erstellt einen Listener, der reagiert, wenn Flash Player beschreibende Informationen erhält, die in ein Video eingebettet sind, das aktuell abgespielt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Erstellt einen Listener, der reagiert, wenn Flash Player beschreibende Informationen erhält, die in ein Video eingebettet sind, das aktuell abgespielt wird. Weitere Informationen zu Videoformaten, die vom Flash Media Server unterstützt werden, finden Sie unter <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.
 
 <p><codeph>onMetaData</codeph> ist eigentlich eine Eigenschaft des <codeph>NetStream.client</codeph>-Objekts. Es ist kein Ereignis, ist aber im Abschnitt „Ereignisse“ aufgeführt, weil es auf ein Datenereignis reagiert, wenn entweder mit dem Media Flash Player gestreamt oder eine FLV-Datei wiedergegeben wird. Weitere Informationen finden Sie in der NetStream-Klassenbeschreibung und der <codeph>NetStream.client</codeph>-Eigenschaft. Die <codeph>addEventListener()</codeph>-Methode und die übrigen EventDispatcher-Methoden können nicht verwendet werden, um auf <codeph>onMetaData</codeph> zu warten oder diese Eigenschaft als Ereignis zu verarbeiten. Stattdessen müssen Sie eine einzelne Callback-Funktion definieren und direkt an eines der folgenden Objekte anhängen:</p>
 
 <ul>
 
  <li>Das Objekt, auf das die <codeph>client</codeph>-Eigenschaft einer NetStream-Instanz verweist.</li>    
 
  <li>Eine Instanz einer NetStream-Unterklasse. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine Unterklasse für „NetStream“ erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li>
    
 </ul>
 
 <p>Das Dienstprogramm Flash Video Exporter (ab Version 1.1) bettet die Dauer, das Erstellungsdatum, die Datenrate und andere Angaben in die Videodatei selbst ein. Von anderen Videokodierern werden andere Metadaten eingebettet.</p>
 
 <p>Der verknüpfte Ereignis-Listener wird nach dem Aufruf der <codeph>NetStream.play()</codeph>-Methode, aber noch vor dem Vorlauf des Abspielkopfes ausgelöst.</p>
 
 <p>Häufig ist die in den Stream-Metadaten eingebettete Längenangabe nur ein ungefährer Wert. Das bedeutet, dass dieser Wert nicht immer mit dem Wert der Eigenschaft <codeph>NetStream.time</codeph> übereinstimmt, wenn der Abspielkopf das Ende des Videostreams erreicht hat.</p>
 <p>Das Ereignisobjekt, das an die onMetaData-Ereignisprozedur übergeben wurde, enthält eine Eigenschaft für jeden Textdatenteil.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onXMPData"><apiName>onXMPData</apiName><shortdesc>
 Erstellt einen Listener, der reagiert, wenn Flash Player Informationen empfängt, die spezifisch für die Adobe Extensible Metadata Platform (XMP) sind und die in einem Video eingebettet sind, das aktuell abgespielt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Erstellt einen Listener, der reagiert, wenn Flash Player Informationen empfängt, die spezifisch für die Adobe Extensible Metadata Platform (XMP) sind und die in einem Video eingebettet sind, das aktuell abgespielt wird. Weitere Informationen zu Videoformaten, die vom Flash Media Server unterstützt werden, finden Sie unter <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.
 
 <p><codeph>onXMPData</codeph> ist eigentlich eine Eigenschaft des <codeph>NetStream.client</codeph>-Objekts. Es ist kein Ereignis, ist aber im Abschnitt „Ereignisse“ aufgeführt, weil es auf ein Datenereignis reagiert, wenn entweder mit dem Media Flash Player gestreamt oder eine FLV-Datei wiedergegeben wird. Weitere Informationen finden Sie in der NetStream-Klassenbeschreibung und der <codeph>NetStream.client</codeph>-Eigenschaft. Die <codeph>addEventListener()</codeph>-Methode und die übrigen EventDispatcher-Methoden können nicht verwendet werden, um auf <codeph>onMetaData</codeph> zu warten oder diese Eigenschaft als Ereignis zu verarbeiten. Stattdessen müssen Sie eine einzelne Callback-Funktion definieren und direkt an eines der folgenden Objekte anhängen:</p>
 
 <ul>
  <li>Das Objekt, auf das die <codeph>client</codeph>-Eigenschaft einer NetStream-Instanz verweist.</li>    
  <li>Eine Instanz einer NetStream-Unterklasse. Bei „NetStream“ handelt es sich um eine „versiegelte“ Klasse, d. h., dass einem NetStream-Objekt zur Laufzeit keine Eigenschaften oder Methoden hinzugefügt werden können. Sie können jedoch eine Unterklasse für „NetStream“ erstellen und die Ereignisprozedur in der Unterklasse definieren oder die Unterklasse als dynamisch festlegen und die Ereignisprozedurfunktion einer Instanz der Unterklasse hinzufügen.</li>
    
 </ul>
 
 <p>Der verknüpfte Ereignis-Listener wird nach dem Aufruf der <codeph>NetStream.play()</codeph>-Methode, aber noch vor dem Vorlauf des Abspielkopfes ausgelöst.</p>
 
 <p>Das Objekt, das an die <codeph>onXMPData()</codeph>-Ereignisprozedurfunktion übergeben wurde, hat eine <codeph>data</codeph>-Eigenschaft, die ein String ist. Der String wird von einer Top-Level UUID-Box generiert. (Die 128-Bit-UUID der Top-Level-Box ist <codeph>BE7ACFCB-97A9-42E8-9C71-999491E3AFAC</codeph>.) Diese Top-Level UUID-Box enthält exakt ein XML-Dokument, das als nullterminierter UTF8-String repräsentiert ist.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Wird ausgelöst, wenn der Status oder die Fehlerbedingung eines NetStream-Objekts protokolliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Status oder die Fehlerbedingung eines NetStream-Objekts protokolliert wird. Das Ereignis <codeph>netStatus</codeph> enthält die Eigenschaft <codeph>info</codeph>. Dabei handelt es sich um ein Informationsobjekt mit spezifischen Informationen über das Ereignis, z. B., ob ein Verbindungsversuch erfolgreich war oder fehlgeschlagen ist.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Netzwerkvorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Netzwerkvorgang fehlschlägt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron, d. h. aus nativem asynchronem Code ausgelöst wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron ausgelöst wird – das heißt, aus nativem asynchronem Code. Dieses Ereignis wird ausgelöst, wenn ein Server eine Methode auf einem Client aufruft, die nicht definiert ist.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>NetStream.onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>NetStream.onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Wird ausgelöst, wenn die Anwendung versucht, mit DRM (Digital Rights Management) verschlüsselten Inhalt abzuspielen, indem die NetStream.play()-Methode aufgerufen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn die Anwendung versucht, mit DRM (Digital Rights Management) verschlüsselten Inhalt abzuspielen, indem die <codeph>NetStream.play()</codeph>-Methode aufgerufen wird. Der Wert der Statuscode-Eigenschaft ist <codeph>"DRM.encryptedFLV"</codeph>. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:NetStream:NetStream"><apiName>NetStream</apiName><shortdesc>
 	 Erstellt einen Stream, der zum Wiedergeben von Videodateien durch das angegebene NetConnection-Objekt verwendet werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Die NetConnection-Instanz ist nicht verbunden.
 	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>connection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>Ein NetConnection-Objekt.
     </apiDesc></apiParam><apiParam><apiItemName>peerID</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>connectToFMS</apiData><apiDesc>Dieser Parameter ist optional. Er ist in Flash Player 10 und höher verfügbar. Setzen Sie den Wert für eine Verbindung mit FMS auf <codeph>NetStream.CONNECT_TO_FMS</codeph>. Für ein direktes Veröffentlichen zu Peers geben Sie <codeph>NetStream.DIRECT_CONNECTIONS</codeph> an. Um direkt von einem bestimmten Peer zu veröffentlichen, geben Sie die Identität dieses Peers an (siehe <codeph>NetConnection.nearID</codeph> und <codeph>NetConnection.farID</codeph>). Der Wert der <codeph>NetConnection.protocol</codeph>-Eigenschaft muss <codeph>"rtmfp"</codeph> sein, wenn der <codeph>peerID</codeph>-Parameter auf „peer“ gesetzt ist. Der <codeph>peerID</codeph>-Parameter wird für Nicht-RTMFP-Verbindungen ignoriert. ActionScript verwendet einen Standardwert <codeph>"connectToFMS"</codeph> für den <codeph>peerID</codeph>-Parameter, der ausgelöst wird, wenn ein Null-Wert vom Programm als Parameter für die NetStream()-Methode übergeben wird.
     <p>Da der <codeph>peerID</codeph>-Parameter aber optional ist, funktioniert Folgendes weiterhin für eine progressive Wiedergabe über eine Client-Server-Verbindung:</p>
     <codeblock>
     new NetStream(nc:NetConnection);
     </codeblock>
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Erstellt einen Stream, der zum Wiedergeben von Videodateien durch das angegebene NetConnection-Objekt verwendet werden kann. 
     
     <p>
     Weitere Informationen zu unterstützten Codecs und Dateiformaten finden Sie unter <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> und <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.
     </p>
	 
 	 </apiDesc><example conref="examples\NetStreamExample_constructor.as"> Der folgende Code zeigt eine Verbindung für den Download und die progressive Anzeige eines Videos, das mit der Variablen <codeph>videoURL</codeph> verknüpft ist:
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect(null);
            var my_ns:NetStream = new NetStream(my_nc);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example><example conref="examples\NetStreamExample_constructor2.as"> Der folgende Code zeigt eine Verbindung für das Streamen und die Anzeige eines Videos (das mit der Variablen <codeph>videoURL</codeph>) auf einer remoten Flash Media Server-Instanz verknüpft ist, die im <codeph>connect()</codeph>-Befehl angegeben ist:
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect("rtmp://www.yourfmsserver.com/someappname");
            var my_ns:NetStream = new NetStream(my_nc, NetStream.CONNECT_TO_FMS);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>flash.media.Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/CONNECT_TO_FMS"><linktext>CONNECT_TO_FMS</linktext></link><link href="flash.net.xml#NetStream/DIRECT_CONNECTIONS"><linktext>DIRECT_CONNECTIONS</linktext></link><link href="flash.net.xml#NetConnection/nearID"><linktext>flash.net.NetConnection.nearID</linktext></link><link href="flash.net.xml#NetConnection/farID"><linktext>flash.net.NetConnection.farID</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetStream:attachAudio"><apiName>attachAudio</apiName><shortdesc>
	 Gibt einen über das NetStream-Objekt gesendeten Audiostream an, wobei das Microphone-Objekt als Quelle übergeben wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiDefaultValue>"null" 
	 </apiDefaultValue><apiParam><apiItemName>microphone</apiItemName><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier><apiDesc>Die Quelle des zu übertragenden Audiostreams.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen über das NetStream-Objekt gesendeten Audiostream an, wobei das Microphone-Objekt als Quelle übergeben wurde. Diese Methode ist nur für den Herausgeber des angegebenen Streams verfügbar.
	 
	 <p>Die <codeph>attachAudio</codeph>-Methode ist für die Verwendung mit Flash Media Server konzipiert. Diese Methode wird häufig von einem Benutzer aufgerufen, der Liveaudio (oder Livevideo mit Audio) von einem Client-Computer an den Server sendet.
	 </p>
	 
	 <p>Sie können diese Methode vor oder nach dem Aufruf der Methode <codeph>publish()</codeph> zum Starten der Übertragung aufrufen. Abonnenten, die die Audiodaten wiedergeben möchten, müssen die Methode <codeph>NetStream.play()</codeph> aufrufen. Stellen Sie die <codeph>rate</codeph> des Mikrofons auf die des Soundaufnahmegeräts und den Silence-Level-Schwellwert über die <codeph>setSilenceLevel()</codeph>-Methode ein. Sie können die Soundeigenschaften (Lautstärke und Schwenk) dieses Audiostreams über die <codeph>soundTransform</codeph>-Eigenschaft des microphone-Objekts steuern.</p>
     <codeblock>
     var conn:NetConnection = new NetConnection();
     conn.connect("rtmp://server.domain.com/path");
     var stream:NetStream = new NetStream(conn);
     var live_mic:Microphone = Microphone.get();
     live_mic.rate = 8;
     live_mic.setSilenceLevel(20,200);
     var soundTrans:SoundTransform = new SoundTransform();
     soundTrans.volume = 6;
     live_mic.soundTransform = soundTrans;
     stream.attachAudio(live_mic);
     stream.publish("mic_stream","live")
     </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:attachCamera"><apiName>attachCamera</apiName><shortdesc>
	 Startet die Erfassung der Videodaten von einer Kamera bzw. stoppt die Erfassung, wenn „theCamera“ auf „null“ gesetzt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>theCamera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>Die Quelle der Videoübertragung. Gültige Werte sind ein Camera-Objekt (das die Erfassung der Videodaten startet) und <codeph>null</codeph>. Wenn Sie <codeph>null</codeph> übergeben, stoppt die Anwendung die Erfassung, und alle weiteren gesendeten Parameter werden ignoriert. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>snapshotMilliseconds</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Gibt an, ob es sich um einen kontinuierlichen Videostream, ein einzelnes Bild oder eine Reihe einzelner Bilder zur Erstellung von Zeitraffer-Material handelt.
	 
	 <ul>
     <li>Wenn Sie diesen Parameter nicht angeben, erfasst die Anwendung alle Videodaten, bis Sie den Wert <codeph>null</codeph> an <codeph>attachCamera</codeph> übergeben.</li>
	 <li>Bei Übergabe von „0“ erfasst die Anwendung nur ein einzelnes Videobild. Verwenden Sie diesen Wert, um „Schnappschüsse“ innerhalb eines bereits vorhandenen Streams zu übertragen. <ph platform="actionscript">Flash Player oder </ph> AIR interpretiert ungültige, negative oder nicht numerische Argumente als 0.</li>
     <li>Wenn Sie eine positive Zahl übergeben, wird ein einzelnes Videobild erfasst und dann eine Pause angefügt, deren Dauer dem Nachspann des Schnappschusses entspricht. Verwenden Sie diesen Wert, um Zeitraffer-Effekte zu erstellen.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Startet die Erfassung der Videodaten von einer Kamera bzw. stoppt die Erfassung, wenn <codeph>theCamera</codeph> auf <codeph>null</codeph> gesetzt ist. Diese Methode ist nur für den Herausgeber des angegebenen Streams verfügbar. 
	 
     <p>Diese Methode ist für die Verwendung mit Flash Media Server konzipiert. Weitere Informationen finden Sie in der Beschreibung der Klasse.</p>
	 
	 <p> Nachdem Sie die Videoquelle angehängt haben, müssen Sie <codeph>NetStream.publish()</codeph> aufrufen, um die Übertragung zu starten. Abonnenten, die das Video anzeigen möchten, müssen die <codeph>NetStream.play()</codeph>- und die <codeph>Video.attachCamera()</codeph>-Methode aufrufen, um das Video auf der Bühne anzuzeigen.</p>
	 
	 <p>Mit <codeph>snapshotMilliseconds</codeph> können Sie einen einzelnen Schnappschuss (durch Angabe des Werts „0“) oder eine Reihe von Schnappschüssen - die zusammen ein Zeitraffer-Video ergeben - senden. Hierzu geben Sie einen positiven Wert an, der dem Videofeed einen Nachspann anhängt, dessen Dauer der angegebenen Zahl in Millisekunden entspricht. Der Nachspann verlängert die Anzeigezeit der Videonachricht. Wenn wiederholt <codeph>attachCamera()</codeph> mit einem positiven Wert für <codeph>snapshotMilliseconds</codeph> aufgerufen wird, erzeugt die Sequenz wechselnder Schnappschüsse und Nachspänne ein Zeitraffer-Video. Sie können beispielsweise ein Bild pro Tag erfassen und an eine Videodatei anhängen. Wenn ein Abonnent die Datei wiedergibt, wird jedes Bild für die Dauer der angegebenen Anzahl an Millisekunden angezeigt.</p>
	 
	 <p>Der Parameter <codeph>snapshotMilliseconds</codeph> hat nicht denselben Zweck wie der Parameter <codeph>fps</codeph>, den Sie mit <codeph>Camera.setMode()</codeph> festlegen können. Durch die Angabe von <codeph>snapshotMilliseconds</codeph> steuern Sie, wie viel Zeit zwischen den aufgezeichneten Bildern verstreicht. Durch Angabe von <codeph>fps</codeph> mit <codeph>Camera.setMode()</codeph> steuern Sie, wie viel Zeit zwischen Aufnahme und Wiedergabe verstreicht.</p>
	 
	 <p>Beispiel: Sie möchten für insgesamt 100 Schnappschüsse alle fünf Minuten einen Schnappschuss erstellen. Hierzu haben Sie zwei Möglichkeiten:</p>
     
	 <ul>
	 <li>Sie können 100-mal den Befehl <codeph>NetStream.attachCamera(myCamera, 500)</codeph> ausführen, einmal alle fünf Minuten. So dauert die Aufnahme 500 Minuten, die Wiedergabe der Datei jedoch nur 50 Sekunden (100 Bilder mit 500 Millisekunden pro Bild).</li> 
	 
	 <li>Sie können den Befehl <codeph>Camera.setMode()</codeph> mit einem <codeph>fps</codeph>-Wert von 1/300 (1 Bild alle 300 Sekunden, d. h. alle fünf Minuten) und anschließend den Befehl <codeph>NetStream.attachCamera(source)</codeph> ausführen, wobei die Kamera 500 Minuten fortlaufend aufzeichnet. Die Wiedergabe der fertigen Datei dauert 500 Minuten (dieselbe Dauer wie für die Aufnahme) und jedes Bild wird fünf Minuten lang angezeigt.</li>
	 </ul>
     
	 <p>Bei beiden Methoden werden dieselben 500 Bilder erfasst, und beide Ansätze sind nützlich. Es hängt hauptsächlich von Ihren Wiedergabeanforderungen ab, welcher Ansatz für Sie geeigneter ist. Im zweiten Fall hätten Sie beispielsweise die Möglichkeit, über den gesamten Zeitraum Audiodaten aufzuzeichnen. Darüber hinaus haben die beiden Dateien etwa dieselbe Größe.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:close"><apiName>close</apiName><shortdesc>
	 Stoppt die Wiedergabe der Daten im Stream, legt für die Eigenschaft „time“ den Wert 0 fest und macht den Stream für andere Verwendungszwecke verfügbar.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Stoppt die Wiedergabe der Daten im Stream, legt für die Eigenschaft <codeph>time</codeph> den Wert 0 fest und macht den Stream für andere Verwendungszwecke verfügbar. Durch diese Methode wird auch die lokale Kopie einer Videodatei gelöscht, die über HTTP heruntergeladen wurde. Auch wenn die Anwendung die lokale Kopie der erstellten Datei löscht, verbleibt möglicherweise eine Kopie im Cache-Verzeichnis des Wenn Sie die Cache- oder lokale Speicherung der Videodatei vollständig vermeiden möchten, verwenden Sie Flash Media Server.
     
     <p>
     Wenn Flash Media Server verwendet wird, wird diese Methode implizit aufgerufen, wenn Sie <codeph>NetStream.play()</codeph> aus einem veröffentlichenden Stream oder <codeph>NetStream.publish()</codeph> aus einem abonnierenden Stream aufrufen. Bitte beachten Sie Folgendes:
     </p>
     
     <ul>
     <li>
     Wenn <codeph>close()</codeph> von einem veröffentlichenden Stream aufgerufen wird, stoppt der Stream die Veröffentlichung, und der Herausgeber kann den Stream jetzt für andere Zwecke verwenden. Abonnenten erhalten nichts mehr, das im Stream veröffentlicht wurde, da der Stream die Veröffentlichung beendet hat. 
     </li>
     <li>
     Wenn <codeph>close()</codeph> von einem abonnierenden Stream aufgerufen wird, wird das Abspielen des Streams für den Abonnenten gestoppt, und der Abonnent kann den Stream für andere Zwecke verwenden. Andere Abonnenten sind davon nicht betroffen.
     </li>
     <li>
     Sie können das Abspielen eines abonnierenden Streams stoppen, ohne den Stream zu schließen oder den Stream-Typ zu ändern, indem Sie <codeph>flash.net.NetStream.play(false)</codeph> verwenden.
     </li>
     </ul>
     
     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/publish()"><linktext>veröffentlichen()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:onPeerConnect"><apiName>onPeerConnect</apiName><shortdesc>
	 
     Wird ausgelöst, wenn ein Peer-Publishing-Stream mit einem Peer-Subscribing-Stream übereinstimmt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscriber</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 
     Wird ausgelöst, wenn ein Peer-Publishing-Stream mit einem Peer-Subscribing-Stream übereinstimmt. Bevor der Abonnent mit dem Herausgeber verbunden wird, rufen Sie diese Methode auf, um dem ActionScript-Code eine feine Zugriffskontrolle für Peer-to-Peer-Publishing zu ermöglichen. Der folgende Code zeigt ein Beispiel, wie eine Callback-Funktion für diese Methode erstellt wird:
     <codeblock>
	 var c:Object = new Object;
	 c.onPeerConnect = function(subscriber:NetStream):Boolean {
	 if (accept)
	 	return true;
	  else
	      return false;
	  };
	  m_netStream.client = c;
     </codeblock>
     
     <p>Wenn ein Peer-Herausgeber diese Methode nicht implementiert, dürfen alle Peers veröffentlichten Inhalt wiedergeben.</p>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:pause"><apiName>pause</apiName><shortdesc>
	 Hält die Wiedergabe eines Videostreams an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.pause, pause
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Hält die Wiedergabe eines Videostreams an. Wenn die Wiedergabe bereits angehalten wurde, hat der Aufruf dieser Methode keine Auswirkung. Rufen Sie <codeph>resume()</codeph> auf, um ein angehaltenes Video weiter abzuspielen. Rufen Sie <codeph>togglePause()</codeph>, um zwischen dem Anhalten und Abspielen (erst anhalten, dann weiter abspielen) des Videos umzuschalten.
	 
	 <p>Beginnend mit Flash Player 9.0.115.0 leert der Flash Player den Puffer nicht mehr, wenn <codeph>NetStream.pause()</codeph> aufgerufen wird. In Vorgängerversionen von Flash Player 9.0.115.0 hat Flash Player gewartet, bis der Puffer voll war, bevor die Wiedergabe fortgesetzt wurde, wodurch es häufig zu Verzögerungen kam.</p>
	 
	 <p>Für eine einzelne Pause hat die <codeph>NetStream.bufferLength</codeph>-Eigenschaft ein Limit von 60 Sekunden oder das Doppelte des Werts von <codeph>NetStream.bufferTime</codeph>, je nachdem, welcher Wert höher ist. Wenn <codeph>bufferTime</codeph> zum Beispiel 20 Sekunden beträgt, puffert Flash Player, bis <codeph>NetStream.bufferLength</codeph> den höheren Wert von 20~~2 (40) oder 60 hat; in diesem Fall also bis <codeph>bufferLength</codeph> den Wert 60 hat. Wenn <codeph>bufferTime</codeph> 40 Sekunden beträgt, puffert Flash Player, bis <codeph>bufferLength</codeph> den höheren Wert von 40~~2 (80) oder 60 hat; in diesem Fall also bis <codeph>bufferLength</codeph> den Wert 80 hat.</p>
	 
	 <p>Die <codeph>bufferLength</codeph>-Eigenschaft hat auch ein absolutes Limit. Wenn ein Aufruf von <codeph>pause()</codeph> dazu führt, dass <codeph>bufferLength</codeph> auf mehr als 600 Sekunden ansteigt oder der Wert von <codeph>bufferTime</codeph> ~~ 2, je nachdem, welcher Wert höher ist, löscht Flash Player den Puffer und setzt <codeph>bufferLength</codeph> auf 0 zurück. Wenn <codeph>bufferTime</codeph> zum Beispiel 120 Sekunden beträgt, löscht Flash Player den Puffer, wenn <codeph>bufferLength</codeph> den Wert 600 Sekunden erreicht; wenn <codeph>bufferTime</codeph> 360 Sekunden beträgt, löscht Flash Player den Puffer, wenn <codeph>bufferLength</codeph> den Wert 720 Sekunden erreicht.</p>
	 
	 <p><b>Tipp</b>: Sie können im Code <codeph>NetStream.pause()</codeph> verwenden, um Daten zu puffern, während Betrachter zum Beispiel einen Werbespot sehen, und dann die Pause aufheben, wenn das Hauptvideo beginnt.</p>
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:play"><apiName>play</apiName><shortdesc>
     Spielt Mediendateien ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>"at"see flash.media.Video#attachVideo()  This method no longer exists.  Replace with new method.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Über lokale nicht vertrauenswürdige SWF-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können diese Einschränkung umgehen, indem Sie die entsprechende SWF-Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Es muss mindestens ein Parameter angegeben werden.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Das NetStream-Objekt ist ungültig. Dies kann an einer fehlgeschlagenen NetConnection liegen.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Der Pfad der Mediendatei, die als String wiedergegeben werden soll, eine <codeph>URLRequest.url</codeph>-Eigenschaft oder eine Variable, die eine der beiden referenziert. In <ph platform="actionscript">Flash Player und in</ph> AIR-Inhalt außerhalb der Sicherheitssandbox der Anwendung können Sie lokale Videodateien abspielen, die im selben Verzeichnis gespeichert sind wie die SWF-Datei oder in einem Unterverzeichnis; Sie können jedoch nicht zu einem Verzeichnis auf einer höheren Ebenen wechseln.
	 
	 <p>
	 Mit Flash Media Server verwendet <codeph>play()</codeph> die folgenden Argumente:
	 </p>
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Name</entry><entry>Erforderlich</entry><entry>Beschreibung</entry></row></thead><tbody><row>
	   <entry><codeph>name:Object</codeph></entry>
	   <entry>Erforderlich </entry>
       <entry> Der Name einer aufgenommenen Datei, eine ID für Live-Daten, die von <codeph>NetStream.publish()</codeph> veröffentlicht wurden, oder <codeph>false</codeph>. Mit dem Wert <codeph>false</codeph> wird die Wiedergabe des Streams gestoppt, und etwaige zusätzliche Parameter werden ignoriert. Weitere Informationen zur Syntax für Dateinamen finden Sie in der Dateiformattabelle, die nach dieser Tabelle folgt.</entry>
	 </row><row>
	   <entry><codeph>start:Number</codeph></entry>
	   <entry>Optional</entry>
	   <entry> Die Startzeit in Sekunden. Zulässige Werte sind -2, -1, 0 oder eine positive Zahl. Der Standardwert ist -2, womit nach einem Live-Stream gesucht wird, dann nach einem aufgezeichneten Stream. Wird keins von beiden gefunden, wird ein neuer Live-Stream geöffnet. Mit dem Wert -1 wird nur ein Live-Stream abgespielt. Mit dem Wert 0 oder einer positiven Zahl wird ein aufgezeichneter Stream abgespielt, und zwar ab der Position <codeph>start</codeph> Sekunden.
	   </entry>
	 </row><row>
	   <entry> <codeph>len:Number</codeph> </entry>
	   <entry> Optional, wenn <codeph>start</codeph> angegeben wird. </entry>
	   <entry> Die Dauer der Wiedergabe in Sekunden. Zulässige Werte sind -1, -0, oder eine positive Zahl. Der Standardwert ist -1, womit ein Live-Stream oder ein aufgezeichneter Stream bis zum Ende abgespielt wird. Mit dem Wert 0 wird ein Einzelbild abgespielt, das sich <codeph>start</codeph> Sekunden nach dem Anfang eines aufgezeichneten Streams befindet. Ist der Wert eine positive Zahl, wird ein Live-Stream oder ein aufgezeichneter Stream für <codeph>len</codeph> Sekunden abgespielt.
	   </entry>
	 </row><row>
	   <entry> <codeph>reset:Object</codeph> </entry>
	   <entry> Optional, wenn <codeph>len</codeph> angegeben wird. </entry>
	   <entry> Gibt an, ob eine Wiedergabeliste gelöscht werden soll. Der Standardwert ist 1 oder <codeph>true</codeph>, womit vorherige Aufrufe von <codeph>play</codeph> gelöscht werden und <codeph>name</codeph> sofort abgespielt wird. Mit dem Wert 0 oder <codeph>false</codeph> wird der Stream einer Wiedergabeliste hinzugefügt. Mit dem Wert 2 bleibt die Wiedergabeliste erhalten, und es werden alle Stream-Meldungen auf einmal anstatt in Intervallen zurückgegeben. Mit dem Wert 3 wird die Wiedergabeliste gelöscht, und es werden alle Stream-Meldungen auf einmal zurückgegeben.  </entry>
	 </row></tbody></tgroup></adobetable>
	 
     <p>
     Sie können die Dateiformate wiedergeben, die in der folgenden Tabelle beschrieben sind. Die Syntax ist je nach Dateiformat unterschiedlich.</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Dateiformat</entry><entry>Syntax</entry><entry>Beispiel</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>Legen Sie den Streamnamen als einen String ohne eine Dateinamenerweiterung fest.</entry>
     <entry><codeph>ns.play("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 oder ID3</entry>
     <entry>Legen Sie den Streamnamen als einen String mit dem Präfix <codeph>mp3:</codeph> oder <codeph>id3:</codeph> und ohne eine Dateinamenerweiterung fest.</entry>
     <entry><codeph>ns.play("mp3:mymp3stream");</codeph> <codeph>ns.play("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>MPEG-4-basierte Dateien (z. B. F4V und MP4)</entry>
      <entry>Legen Sie den Streamnamen als String mit dem Präfix <codeph>mp4:</codeph> mit oder ohne Dateinamenerweiterung fest. Der Präfix zeigt dem Server an, dass die Datei H.264-verschlüsselte Video- und AAC-verschlüsselte Audiodaten innerhalb des MPEG-4 Part 14-Containerformats enthält. Wenn die Datei auf dem Server eine Dateinamenerweiterung hat, geben Sie eine Dateinamenerweiterung an. Wenn in der <codeph>publish()</codeph>-Methode eine Dateinamenerweiterung angegeben wurde, geben Sie eine Dateinamenerweiterung an.</entry>
     <entry><codeph>ns.play("mp4:myvideo.f4v")</codeph> <codeph>ns.play("mp4:myvideo.mp4")</codeph> <codeph>ns.play("mp4:myvideo")</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Spielt Mediendateien ab. 
     
     <p>
     Weitere Informationen zu unterstützten Codecs und Dateiformaten finden Sie unter <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> und <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.</p>
     
	 <p>Um Videodaten anzuzeigen, erstellen Sie ein Videoobjekt und rufen Sie die <codeph>Video.attachNetStream()</codeph>-Methode auf. Um Audio von einem Mikrofon zu streamen, verwenden Sie die <codeph>NetStream.attachAudio()</codeph>-Methode. Sie können das Microphone-Objekt verwenden, um einige Aspekte des Audios zu steuern.</p>
	 
	 <p>Rufen Sie die <codeph>DisplayObjectContainer.addChild()</codeph>-Methode auf, um Audio zu einem Objekt in der Anzeigeliste zu leiten. Sie können dann ein Soundobjekt erstellen, um einige Aspekte des Audios zu steuern. Weitere Informationen hierzu finden Sie im Abschnitt zur Methode <codeph>DisplayObjectContainer.addChild()</codeph>.</p>
	 
	 <p>Wenn die Videodatei nicht gefunden werden kann, wird das <codeph>NetStatusEvent</codeph>-Objekt ausgelöst.</p>
	 
     <p>Wenn Sie diese Methode ohne Flash Media Server verwenden, gibt es Sicherheitsüberlegungen zu beachten. Eine Datei in der lokal vertrauenswürdigen Sandbox oder der lokalen Sandbox mit Netzwerkzugang kann eine Videodatei aus der remoten Sandbox wiedergeben, aber nicht ohne explizite Erlaubnis in Form einer URL-Richtliniendatei auf die Daten der remoten Datei zugreifen. <ph platform="actionscript">Sie können auch eine SWF-Datei, die im Flash Player ausgeführt wird, daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</ph></p>
	 
      <p>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
     
      <p>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
     
	 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
	 
     <ul>
     
     <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
     <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     <li>Die <codeph>NetStream.checkPolicyFile</codeph>-Eigenschaft.</li>
     </ul>
     
	 
     </apiDesc><example><b>Flash Media Server</b> Dieses Beispiel spielt eine aufgenommene F4V-Datei vom Anfang über maximal 100 Sekunden ab. Geben Sie für MPEG-4-Dateien, wenn die Datei auf dem Server eine Dateinamenerweiterung hat, eine in der <codeph>play()</codeph>-Methode an. 
	 <codeblock>
     ns.play("mp4:record1.f4v", 0, 100, true);
	 </codeblock>
	 
	 </example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>DisplayObjectContainer.addChild()</linktext></link><link href="flash.net.xml#NetStream/checkPolicyFile"><linktext>checkPolicyFile</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream:play_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn versucht wird, Inhalt abzuspielen, der mit DRM (Digital Rights Management) verschlüsselt wurde. Der Wert der <codeph>code</codeph>-Eigenschaft ist <codeph>"DRM.encryptedFLV"</codeph>.
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn versucht wird, Inhalt abzuspielen, der mit DRM (Digital Rights Management) verschlüsselt wurde.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetStream:play2"><apiName>play2</apiName><shortdesc>
     Beginnt die Wiedergabe der Mediendateien mit verschiedenen Wiedergabeoptionen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
     Beginnt die Wiedergabe der Mediendateien mit verschiedenen Wiedergabeoptionen.
     
     <p>Diese Methode ist eine verbesserte Version von <codeph>NetStream.play()</codeph>. Wie die <codeph>play()</codeph>-Methode beginnt die <codeph>play2()</codeph>-Methode mit der Wiedergabe einer Mediendatei oder setzt Mediendateien in eine Warteschlange, um eine Wiedergabeliste zu erstellen. Wenn sie mit Flash Media Server verwendet wird, kann sie auch anfordern, dass der Server zu einer anderen Mediendatei wechselt. Der Übergang in der Clientanwendung erfolgt nahtlos.</p> 
     
     <p>Verwenden Sie die <codeph>play2()</codeph>-Methode, um zu einem Stream mit dem gleichen Inhalt zu wechseln, der mit einer anderen Bitrate kodiert ist, oder um Streams aus einer Wiedergabeliste auszutauschen. Verwenden Sie die <codeph>NetStreamInfo</codeph>-Klasse, um Netzwerkbedingungen zu überwachen und Streams basierend auf den Daten zu wechseln. Sie können auch Streams für Clients mit unterschiedlicher Funktionalität wechseln. Wenn ActionScript zum Wechseln von Streams verwendet wird, wird dies als <i>dynamisches Streamen</i> bezeichnet. Weitere Informationen finden Sie Adobe Flash Media Server Developer Guide unter <xref href="http://www.adobe.com/go/learn_fms_devguide_en">www.adobe.com/go/learn_fms_devguide_en</xref> (suchen Sie nach „dynamic streaming“). Adobe hat ein benutzerdefinierte ActionScript-Klasse mit dem Namen DynamicStream entwickelt, die die NetStream-Klasse erweitert. Sie können die DynamicStream-Klasse verwenden, um dynamisches Streamen in einer Anwendung zu implementieren, statt eigenen Code zu schreiben, um Netzwerkbedingungen zu erkennen. Selbst wenn Sie sich dazu entscheiden, Ihren eigenen dynamischen Streamingcode zu schreiben, beziehen Sie sich bitte auf die DynamicStream-Klasse, um eine funktionierende Implementierung zu sehen. Laden Sie die Klasse und die Dokumentation zur Klasse von <xref href="http://www.adobe.com/go/fms_tools">www.adobe.com/go/fms_tools</xref> herunter.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:preloadEmbeddedData"><apiName>preloadEmbeddedData</apiName><shortdesc>
	 Extrahiert DRM-Metadaten aus einer lokal gespeicherten Mediendatei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier><apiDesc>NetStreamPlayOptions beschreiben die Optionen, die beim Verarbeiten der Inhaltsdatei zu verwenden sind.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Extrahiert DRM-Metadaten aus einer lokal gespeicherten Mediendatei.
	 
	 <p>Verwenden Sie zunächst <codeph>preloadEmbeddedMetaData()</codeph>, um die für die Offline-Wiedergabe benötigten DRM-Gutscheine herunterzuladen und im Zwischenspeicher abzulegen. Wenn in einer Mediendatei eingebettete DRM-Metadaten entdeckt werden, wird ein DRMContentData-Objekt an die <codeph>onDRMContentData</codeph>-Funktion des NetStream-Clients übergeben. Dieses DRMContentData-Objekt enthält die notwendigen Informationen, um den Gutschein zu erhalten, der zur Wiedergabe des Inhalts erforderlich ist. Übergeben Sie das DRMContentDataObject an die <codeph>loadVoucher()</codeph>-Methode des DRMManagers, um den Gutschein herunterzuladen.</p>
	 
	 <p>Die Schritte zum Vorabladen eines DRM-Gutscheins sind:</p>
	 <ul>
	 <li>
	 <p>Erstellen Sie ein neues NetStream-Objekt zum Vorabladen der Metadaten.</p>
	 </li>
	 <li>Verknüpfen Sie eine Callback-Funktion mit der <codeph>onDRMContentData</codeph>-Eigenschaft des NetStream-<codeph>Clients</codeph>.</li>
	 <li>Erstellen Sie ein neues NetStreamPlayOptions-Objekt und setzen Sie seine <codeph>streamName</codeph>-Eigenschaft auf den URL-String der lokalen Videodatei.</li>
	 <li>Rufen Sie <codeph>preloadEmbeddedMetadata()</codeph> auf, um das NetStreamPlayOptions-Objekt zu übergeben.</li>
	 <li>Rufen Sie als Antwort auf das <codeph>onDRMContentData</codeph>-Callback die <codeph>loadVoucher()</codeph>-Methode des DRMManagers auf, um das DRMContentData-Objekt zu übergeben. Wenn die <codeph>authenticationMethod</codeph>-Eigenschaft des DRMContentData-Objekts den Wert <codeph>userNameAndPassWord</codeph> hat, müssen Sie den Benutzer auf dem Medienrechteserver authentifizieren, bevor Sie den Gutschein laden.</li>
	 <li>Schließen Sie den NetStream, der zum Vorabladen verwendet wird.</li> 
	 </ul>
	 
	 <p><b>Hinweis:</b> Wenn Sie zum Vorabladen von Metadaten und zur Wiedergabe von Inhalt das gleiche NetStream-Objekt verwenden, müssen Sie warten, bis der <codeph>onPlayStatus</codeph>-Aufruf von der preload-Methode generiert wurde, bevor mit der Wiedergabe begonnen wird.</p>
	 
	 <p>Heruntergeladene Gutscheine werden in einem lokalen Zwischenspeicher gespeichert. Wenn Inhalt online wiedergegeben wird, werden ebenfalls Gutscheine heruntergeladen und im Zwischenspeicher abgelegt. Wenn eine DRM-geschützte Inhaltsdatei angezeigt wird, wird automatisch ein zwischengespeicherter Gutschein aus dem lokalen Speicher abgerufen. Verwenden Sie den DRMManager, um den Gutschein-Zwischenspeicher zu verwalten.</p>
	   
	 <p><b>Hinweise:</b> Das Vorabladen von DRM-Metadaten über HTTP-, HTTPS- oder RTMP-Verbindungen wird nicht unterstützt. Sie können nur Metadaten aus Dateien vorabladen, die im Dateisystem gespeichert sind.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/event:onDRMContentData"><linktext>onDRMContentData</linktext></link><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.drm.xml#DRMManager/loadVoucher()"><linktext>flash.net.drm.DRMManager.loadVoucher()</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:publish"><apiName>publish</apiName><shortdesc>
	 Sendet einen Stream mit Audiodaten, Videodaten und Textnachrichten von einem Client an Flash Media Server. Der Stream kann während der Übertragung aufgezeichnet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein String, der den Stream identifiziert. Clients, die diesen Stream abonnieren, müssen beim Aufruf von <codeph>NetStream.play()</codeph> diesen Namen übergeben. Setzen Sie keinen Schrägstrich (/) hinter den Stream-Namen. Verwenden Sie zum Beispiel nicht den Stream-Namen <codeph>"bolero/"</codeph>. 
     
     <p>
     Sie können Dateien in den Formaten veröffentlichen, die in der folgenden Tabelle beschrieben sind. Die Syntax ist je nach Dateiformat unterschiedlich.</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Dateiformat</entry><entry>Syntax</entry><entry>Beispiel</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>Legen Sie den Streamnamen als einen String ohne eine Dateinamenerweiterung fest.</entry>
     <entry><codeph>ns.publish("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 oder ID3</entry>
     <entry>Legen Sie den Streamnamen als einen String mit dem Präfix <codeph>mp3:</codeph> oder <codeph>id3:</codeph> und ohne eine Dateinamenerweiterung fest.</entry>
     <entry><codeph>ns.publish("mp3:mymp3stream");</codeph> <codeph>ns.publish("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>MPEG-4-basierte Dateien (z. B. F4V und MP4)</entry>
     <entry>Legen Sie den Streamnamen als String mit dem Präfix <codeph>mp4:</codeph> mit oder ohne Dateinamenerweiterung fest. Der Präfix zeigt dem Server an, dass die Datei H.264-verschlüsselte Video- und AAC-verschlüsselte Audiodaten innerhalb des MPEG-4 Part 14-Containerformats enthält.</entry>
     <entry><codeph>ns.publish("mp4:myvideo.f4v")</codeph> <codeph>ns.publish("mp4:myvideo.mp4");</codeph> <codeph>ns.publish("mp4:myvideo");</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>     
	 
	 </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein String, der angibt, wie der Stream veröffentlicht wird. Gültige Werte sind "<codeph>record</codeph>", "<codeph>append</codeph>" und "<codeph>live</codeph>". Der Standardwert ist "<codeph>live</codeph>".
	 <ul>
	 <li>Wenn Sie "<codeph>record</codeph>" übergeben, veröffentlicht und zeichnet Flash Media Server Live-Daten auf und speichert die aufgezeichneten Daten in einer neuen Datei mit einem Namen, der dem an den <codeph>name</codeph>-Parameter übergebenen Wert entspricht. Wenn die Datei vorhanden ist, wird sie überschrieben.</li>
	 <li>Wenn Sie "<codeph>append</codeph>" übergeben, veröffentlicht und zeichnet Flash Media Server Live-Daten auf und hängt die aufgezeichneten Daten an eine Datei mit einem Namen an, der dem an den <codeph>name</codeph>-Parameter übergebenen Wert entspricht. Wenn keine Datei gefunden wird, die dem <codeph>name</codeph>-Parameter entspricht, wird sie erstellt. </li>
	 <li>Wenn Sie diesen Parameter auslassen oder "<codeph>live</codeph>" übergeben, veröffentlicht Flash Media Server Live-Daten, ohne sie aufzuzeichnen. Wenn eine Datei mit dem Namen vorhanden ist, der dem Wert des Parameters <codeph>name</codeph> entspricht, wird sie gelöscht.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sendet einen Stream mit Audiodaten, Videodaten und Textnachrichten von einem Client an Flash Media Server. Der Stream kann während der Übertragung aufgezeichnet werden. Diese Methode ist nur für den Herausgeber des angegebenen Streams verfügbar.
	 
	 <p>Sie können Dateien im Format FLV oder MPEG-4 aufnehmen. Wenn Sie eine Datei im Format MPEG-4 aufnehmen, müssen Sie ein Reduzierungs-Tool verwenden, um die Datei in einer anderen Anwendung zu bearbeiten oder abzuspielen. Das Tool kann von <xref href="http://www.adobe.com/go/fms_tools" scope="external">www.adobe.com/go/fms_tools</xref> heruntergeladen werden.</p>
     
     <p>Verwenden Sie diese Methode nicht, um einen Stream wiederzugeben, der bereits veröffentlicht und aufgenommen wurde. Um einen Stream wiederzugeben, verwenden Sie die <codeph>NetStream.play()</codeph>-Methode.</p>
	 
	 <codeblock platform="actionscript">
	 var subscribeNS:NetStream = new NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var subscribeNS = new air.NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
     <p>Wenn Flash Media Server einen Stream aufnimmt, erstellt es eine Datei uns speichert diese in einem Unterverzeichnis im Anwendungsverzeichnis auf dem Server. Jeder Stream wird in einem Verzeichnis gespeichert, dessen Name mit dem Instanznamen der Anwendung übereinstimmt, der an <codeph>NetConnection.connect()</codeph> übergeben wird. Der Server erstellt diese Verzeichnisse automatisch. Der folgende Code stellt beispielsweise eine Verbindung zur „lectureseries“-Anwendung her und nimmt einen Stream mit dem Namen „lecture“ auf. Die Datei „lecture.flv“ wird im Verzeichnis applications/lectureseries/streams/_definst_ directory aufgenommen:
     </p>
     
     <codeblock platform="actionscript">
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <p>Das folgende Beispiel zeigt, wie eine Verbindung zu einer anderen Instanz der gleichen Anwendung hergestellt werden kann. Die Datei „lecture.flv“ wird im Verzeichnis /applications/lectureseries/streams/monday aufgenommen:</p>
     
     <codeblock>
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
   	 
	 <p>Diese Methode löst ein <codeph>NetStatusEvent</codeph>-Objekt aus. Wenn beispielsweise jemand bereits einen Stream mit dem angegebenen Namen veröffentlicht, wird das <codeph>NetStatusEvent</codeph>-Objekt mit der <codeph>code</codeph>-Eigenschaft <codeph>"NetStream.Publish.BadName"</codeph> ausgelöst. Weitere Informationen finden Sie unter dem <codeph>NetStatusEvent</codeph>-Objekt.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>NetConnection.connect()</linktext></link><link href="" invalidHref="flash.net.xml#NetStatusEvent/info"><linktext>NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:receiveAudio"><apiName>receiveAudio</apiName><shortdesc>
	 Gibt an, ob eingehende Audiodaten im Stream wiedergegeben werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Gibt an, ob eingehende Audiodaten im Stream wiedergegeben werden (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). Der Standardwert ist <codeph>true</codeph>. 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob eingehende Audiodaten im Stream wiedergegeben werden. Diese Methode ist nur für Clients verfügbar, die diesen Stream abonniert haben, nicht für den Herausgeber des Streams.
	 
     <p>Diese Methode ist für die Verwendung mit Flash Media Server konzipiert. Weitere Informationen finden Sie in der Beschreibung der Klasse.</p> 
	 
	 <p>Sie können diese Methode vor oder nach dem Aufruf der Methode <codeph>NetStream.play()</codeph> zum Starten des Empfangs aufrufen. Beispielsweise können Sie diese Methoden an eine Schaltfläche anhängen, auf die der Benutzer klickt, um den eingehenden Audiostream stummzuschalten bzw. um die Stummschaltung aufzuheben.</p>
	 
	 <p>Wenn der angegebene Stream nur Audiodaten enthält, wird durch die Übergabe des Werts <codeph>false</codeph> an diese Methode der Wert für <codeph>NetStream.time</codeph> nicht weiter erhöht.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideo"><apiName>receiveVideo</apiName><shortdesc>
	 Gibt an, ob eingehende Videodaten im Stream wiedergegeben werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Gibt an, ob eingehende Videodaten in diesem Stream wiedergegeben werden (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). Der Standardwert ist <codeph>true</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt an, ob eingehende Videodaten im Stream wiedergegeben werden. Diese Methode ist nur für Clients verfügbar, die diesen Stream abonniert haben, nicht für den Herausgeber des Streams.
	 
     <p>Diese Methode ist für die Verwendung mit Flash Media Server konzipiert. Weitere Informationen finden Sie in der Beschreibung der Klasse.</p>
	 
	 <p>Sie können diese Methode vor oder nach dem Aufruf der Methode <codeph>NetStream.play()</codeph> zum Starten des Empfangs aufrufen. Sie haben beispielsweise die Möglichkeit, diese Methoden mit einer Schaltfläche zu verknüpfen, auf die der Benutzer klicken kann, um den eingehenden Videostream ein- bzw. auszublenden.</p>
	 
	 <p>Wenn der angegebene Stream nur Videodaten enthält, wird durch die Übergabe des Werts <codeph>false</codeph> an diese Methode der Wert für <codeph>NetStream.time</codeph> nicht weiter erhöht.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideoFPS"><apiName>receiveVideoFPS</apiName><shortdesc>
	 Gibt die Bildrate für eingehendes Video an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>FPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Gibt die Bildrate pro Sekunde an, bei der das eingehende Video abgespielt wird.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt die Bildrate für eingehendes Video an. Diese Methode ist nur für Clients verfügbar, die diesen Stream abonniert haben, nicht für den Herausgeber des Streams.
	 
     <p>Diese Methode ist für die Verwendung mit Flash Media Server konzipiert. Weitere Informationen finden Sie in der Beschreibung der Klasse.</p>
	 
	 <p>Sie können diese Methode vor oder nach dem Aufruf der Methode <codeph>NetStream.play()</codeph> zum Starten des Empfangs aufrufen. Sie können diese Methoden zum Beispiel an ein Textfeld anhängen, in dem der Benutzer die Bildrate des eingehenden Videos festlegen kann.</p>
     
     <p>Um den Videoempfang zu beenden, übergeben Sie 0 für FPS (Bildrate). Mit <codeph>NetStream.currentFPS</codeph> können Sie die aktuelle Bildrate zu bestimmen.</p>
     
     <p>Wenn Sie einen Wert an den <codeph>FPS</codeph>-Parameter übergeben, um die Bildrate des Videos zu begrenzen, versucht Flash Media Server, die Bildrate zu verringern und gleichzeitig die Integrität des Videos zu erhalten. Der Server sendet die Mindestanzahl der Bilder, um die gewünschte Rate zwischen jeweils zwei Keyframes zu erzielen. Bedenken Sie aber, dass I-Frames (Intermediate Frames) aneinander angrenzend gesendet werden müssen, da das Video ansonsten beschädigt sein wird. Deshalb wird die gewünschte Anzahl Bilder sofort und angrenzend an einen Keyframe gesendet. Da die Bilder nicht gleichmäßig verteilt sind, erscheint die Bewegung in Segmenten fließend, unterbrochen von kurzen Halts.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:resetDRMVouchers"><apiName>resetDRMVouchers</apiName><shortdesc>
     Löscht alle lokal zwischengespeicherten DRM-Gutscheindaten (Digital Rights Management).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, resetDRMVouchers
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Die Gutscheindaten können nicht gelöscht werden.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Löscht alle lokal zwischengespeicherten DRM-Gutscheindaten (Digital Rights Management).
     <p>
     Die Anwendung muss alle erforderlichen Gutscheine erneut vom Medienrechteserver herunterladen, damit der Benutzer auf zugriffsgeschützten Inhalt zugreifen kann. Der Aufruf dieser Funktion hat den gleichen Effekt wie das Aufrufen der <codeph>resetDRMVouchers()</codeph>-Funktion des DRMManager-Objekts.</p>
     
     </apiDesc><example conref="examples\NetStream.resetDRMVouchers.1.as"> Das folgende Beispiel setzt alle DRM-Gutscheine zurück:
<codeblock>

NetStream.resetDRMVouchers();
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.drm.xml#DRMManager/resetDRMVouchers()"><linktext>flash.net.drm.DRMManager.resetDRMVouchers()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:resume"><apiName>resume</apiName><shortdesc>
	 Setzt die Wiedergabe eines angehaltenen Videostreams fort.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Setzt die Wiedergabe eines angehaltenen Videostreams fort. Wenn die Wiedergabe bereits läuft, hat der Aufruf dieser Methode keine Auswirkung.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:seek"><apiName>seek</apiName><shortdesc>
	 
	 Sucht das Schlüsselbild (in der Videobranche auch „I-Frame“ genannt), das der angegebenen Position am nächsten ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.seek, seek
	 
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der ungefähre Zeitpunkt in Sekunden, zu dem der Abspielkopf in einer Videodatei verschoben werden soll. Wenn bei Verwendung von Flash Media Server <codeph>&lt;EnhancedSeek></codeph> in der Konfigurationsdatei Application.xml auf den Wert <codeph>true</codeph> gesetzt wird, generiert der Server ein Schlüsselbild bei <codeph>offset</codeph>. 
	 
	 <ul>
	   <li>Geben Sie für <codeph>offset</codeph> den Wert 0 an, wenn Sie zum Anfang des Streams zurückkehren möchten.</li>
	   <li>Geben Sie die entsprechende Sekundenzahl an, wenn Sie ab dem Anfang des Streams vorwärts suchen möchten. Um den Abspielkopf zum Beispiel an eine Position 15 Sekunden nach dem Anfang (oder dem Schlüsselbild vor 15 Sekunden) zu bewegen, verwenden Sie <codeph>myStream.seek(15)</codeph>.</li>
	   <li>Sie können in Relation zur aktuellen Position suchen, indem Sie <codeph>NetStream.time + n</codeph> oder <codeph>NetStream.time - n</codeph> eingeben, um von der aktuellen Position aus <codeph> n</codeph> Sekunden vorwärts bzw. rückwärts zu suchen. Um beispielsweise 20 Sekunden von der aktuellen Position aus zurückzuspulen, verwenden Sie <codeph>NetStream.seek(NetStream.time - 20)</codeph>.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Sucht das Schlüsselbild (in der Videobranche auch „I-Frame“ genannt), das der angegebenen Position am nächsten ist. Das Schlüsselbild wird mit einem Offset (einer Verschiebung) in Sekunden ab dem Beginn des Streams platziert. 
	 
     <p>
     Videostreams werden normalerweise mit zwei Arten von Bildern kodiert: Schlüsselbildern (oder I-Frames) und P-Frames. Ein Schlüsselbild enthält ein gesamtes Bild, während ein P-Frame ein Zwischenbild ist, das zusätzliche Videoinformationen zwischen Schlüsselbildern bietet. Ein Videostream enthält normalerweise alle 10 bis 50 Bilder ein Schlüsselbild. 
     </p>
     
     <p>
     Auf Flash Media Server wird das Verhalten von <codeph>seek()</codeph> vom Wert des <codeph>EnhancedSeek</codeph>-Elements in der Konfigurationsdatei <codeph>Application.xml</codeph> gesteuert.
     </p>
     
     <p>
     Wenn <codeph>EnhancedSeek</codeph> den Wert <codeph>false</codeph> hat, verwendet der Server den normalen Suchmodus. Im normalen Suchmodus startet der Server das Streaming vom nächsten Schlüsselbild. Wenn ein Video zum Beispiel Keyframes bei 0 und 10 Sekunden hat, führt ein Vorlauf auf 4 Sekunden dazu, dass die Wiedergabe bei 4 Sekunden mit dem Keyframe bei 0 Sekunden beginnt. Das Video bleibt stehen, bis das nächste Schlüsselbild bei 10 Sekunden erreicht wird. Um bessere Suchläufe zu erzielen, müssen Sie das Schlüsselbildintervall verringern. Im normalen Suchmodus können Sie das Video nicht an einem Punkt zwischen den Schlüsselbildern starten.
     </p>
     
     <p>
     Wenn <codeph>EnhancedSeek</codeph> den Wert <codeph>true</codeph> aufweist (dies ist der Standardwert), generiert der Server ein neues Schlüsselbild bei <codeph>offset</codeph>, basierend auf dem vorherigen Schlüsselbild und ggf. dazwischenliegenden P-Frames. Dadurch wird auf dem Server jedoch eine hohe Verarbeitungslast erzeugt, und im generierten Schlüsselbild kann es zu Verzerrungen kommen. Wenn der Videocodec On2 verwendet wird, werden das Schlüsselbild vor dem Suchpunkt sowie alle P-Frames zwischen dem Schlüsselbild und dem Suchpunkt an den Client gesendet.
     </p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:send"><apiName>send</apiName><shortdesc>
	 Sendet eine Nachricht an alle Clients mit Abonnement über den veröffentlichten Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>handlerName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die zu sendende Nachricht, auch der Name der ActionScript-Prozedur für den Empfang der Nachricht. Der Prozedurname darf nur eine Ebene umfassen (d. h. die Form übergeordnet/untergeordnet ist nicht zulässig) und hängt vom Stream-Objekt ab. Verwenden Sie keine reservierten Begriffe als Prozedurnamen. Wenn Sie beispielsweise "<codeph>close</codeph>" als Prozedurnamen verwenden, schlägt die Methode fehl. Mit Flash Media Server verwenden Sie <codeph>@setDataFrame</codeph>, um einem Live-Stream ein Schlüsselbild mit Metadaten hinzuzufügen bzw. <codeph>@clearDataFrame</codeph>, um ein Schlüsselbild zu entfernen.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Optionale Argumente beliebigen Typs. Diese werden serialisiert, über die Verbindung gesendet und von der Empfangsprozedur in derselben Reihenfolge empfangen. Wenn es sich bei dem Parameter um ein zyklisches Objekt handelt (z. B. eine verknüpfte zyklische Liste), werden die Verweise bei der Serialisierung korrekt verarbeitet. Wenn bei der Verwendung mit Flash Media Server <codeph>@setDataFrame</codeph> das erste Argument ist, verwenden Sie <codeph>onMetaData</codeph> als zweites Argument; für das dritte Argument übergeben Sie eine Instanz von <codeph>Object</codeph> oder <codeph>Array</codeph>, in der die Metadaten als Eigenschaften festgelegt wurden. Im <xref href="http://www.adobe.com/go/learn_fms_devguide_en" scope="external">Flash Media Server Developer Guide</xref> finden Sie eine Liste mit vorgeschlagenen Eigenschaftsnamen. Mit <codeph>@clearDataFrame</codeph> als erstem Argument, verwenden Sie <codeph>onMetaData</codeph> als zweites Argument und kein drittes Argument.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sendet eine Nachricht an alle Clients mit Abonnement über den veröffentlichten Stream. Diese Methode steht nur dem Herausgeber des angegebenen Streams zur Verfügung und ist für die Verwendung mit Flash Media Server konzipiert. Erstellen Sie eine Prozedur für das <codeph>NetStream</codeph>-Objekt, zum Beispiel <codeph>ns.HandlerName</codeph>, um diese Meldung zu verarbeiten und darauf zu reagieren.
     
     <p>
     Methoden und ihre Daten, Objektprototypvariablen und nicht zählbare Variablen werden in <ph platform="actionscript">Flash Player oder </ph>AIR nicht serialisiert. Zur Anzeige von Objekten serialisiert <ph platform="actionscript">Flash Player oder </ph>AIR lediglich den Pfad.
	 </p>
	 
	 <p>
	 Durch einen Aufruf der <codeph>send()</codeph>-Methode können Sie einem Live-Stream, der an Flash Media Server gesendet wird, Datenschlüsselbilder hinzufügen. Ein Datenschlüsselbild ist eine Meldung, die ein Herausgeber einem Live-Stream hinzufügt. Datenschlüsselbilder werden normalerweise verwendet, um einem Live-Stream Metadaten hinzuzufügen, bevor die Daten von Kamera und Mikrofon für den Stream erfasst werden. Ein Herausgeber kann jederzeit ein Datenschlüsselbild hinzufügen, während der Live-Stream veröffentlicht wird. Das Datenschlüsselbild wird im Speicher des Servers gespeichert, solange der Herausgeber mit dem Server verbunden ist. 
	 </p>
	 <p>
	 Clients, die den Live-Stream vor dem Hinzufügen eines Datenschlüsselbilds abonniert haben, erhalten das Schlüsselbild sobald es hinzugefügt wurde. Clients, die den Live-Stream nach dem Hinzufügen eines Datenschlüsselbilds abonnieren, erhalten das Schlüsselbild sobald sie den Stream abonnieren.
	 </p>
	 <p>
	 Um einem Live-Stream, der an Flash Media Server gesendet wird, ein Schlüsselbild mit Metadaten hinzuzufügen, verwenden Sie <codeph>@setDataFrame</codeph> als Prozedurnamen, gefolgt von zwei zusätzlichen Argumenten, zum Beispiel:
	 </p>
	 
	 <codeblock platform="actionscript">
	 var ns:NetStream = new NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var ns = new air.NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <p>
	 Das Argument <codeph>@setDataFrame</codeph> verweist auf eine spezielle Prozedur, die in Flash Media Server integriert ist. Das Argument <codeph>onMetaData</codeph> ist der Name einer Callback-Funktion in Ihrer Client-Anwendung, die auf das <codeph>onMetaData</codeph>-Ereignis wartet und die Metadaten abruft. Das dritte Element, <codeph>metaData</codeph>, ist eine Instanz von <codeph>Object</codeph> oder <codeph>Array</codeph> mit Eigenschaften, die die Metadatenwerte definieren. Herausgeber sollten Eigenschaftsnamen so festlegen, dass Abonnenten diese leicht verstehen können. Im <xref href="http://www.adobe.com/go/learn_fms_devguide_en" scope="external">Flash Media Server Developer Guide</xref> finden Sie eine Liste mit vorgeschlagenen Eigenschaftsnamen.
	 </p>
	 
	 <p>Mit <codeph>@clearDataFrame</codeph> löschen Sie ein Schlüsselbild mit Metadaten, das bereits im Stream gesendet wurde:
	 </p>
	 <codeblock>
	 ns.send("@clearDataFrame", "onMetaData");
	 </codeblock>
	 
	 
	 </apiDesc><example conref="examples\NetStream.send.1.as"> Im folgenden Beispiel werden zwei <codeph>NetStream</codeph>-Objekte erstellt. Eines veröffentlicht einen Live-Stream an den Server, während das andere den Stream abonniert.
<codeblock>
package {
   import flash.display.Sprite;
   import flash.net.NetConnection;
   import flash.net.NetStream;
   import flash.events.NetStatusEvent;
   import flash.media.Video;
   import flash.utils.setTimeout;

 
   public class TestExample extends Sprite
   {
     var nc:NetConnection = new NetConnection();
     var ns1:NetStream;
     var ns2:NetStream;
     var vid:Video = new Video(300,300);
     var obj:Object = new Object();
 
     public function TestExample() {
        nc.objectEncoding = 0;
        nc.addEventListener("netStatus", onNCStatus);
        nc.connect("rtmp://localhost/FlashVideoApp");
        addChild(vid); 
     }
  
     function onNCStatus(event:NetStatusEvent):void {
       switch (event.info.code) {
           case "NetConnection.Connect.Success":
               trace("You've connected successfully");
               ns1 = new NetStream(nc);
               ns2 = new NetStream(nc);
               
               ns1.client = new CustomClient();
               ns1.publish("dummy", "live");
    
               ns2.play("dummy");
               ns2.client = new CustomClient();
               vid.attachNetStream(ns2);
               setTimeout(sendHello, 3000);
               break;
              
           case "NetStream.Publish.BadName":
               trace("Please check the name of the publishing stream" );
               break;
        }   
     }

     function sendHello():void {
         ns1.send("myFunction", "hello");
     }       
   }
 }
 
 class CustomClient {
    public function myFunction(event:String):void {
       trace(event);
    }
 }
</codeblock></example><example conref="examples\NetStream.send.2.as"> Im folgenden Beispiel werden Metadaten erstellt und einem Live-Stream hinzugefügt:
<codeblock>
private function netStatusHandler(event:NetStatusEvent):void {
     switch (event.info.code) {  
        case "NetStream.Publish.Start":
            var metaData:Object = new Object();
            metaData.title = "myStream";
            metaData.width = 400;
            metaData.height = 200;
            ns.send("&amp;#64;setDataFrame", "onMetaData", metaData);
            ns.attachCamera( Camera.getCamera() );
            ns.attachAudio( Microphone.getMicrophone() );        
    }
}
</codeblock></example><example conref="examples\NetStream.send.3.as"> Um auf ein Datenschlüsselbild, das dem Video hinzugefügt wurde, zu reagieren, muss der Client eine <codeph>onMetaData</codeph>-Ereignisprozedur definieren. Die Ereignisprozedur <codeph>onMetaData</codeph> ist nicht bei <codeph>addEventListener()</codeph> registriert; es handelt sich vielmehr um eine Callback-Funktion mit dem Namen <codeph>onMetaData</codeph>, zum Beispiel:
<codeblock>
 public function onMetaData(info:Object):void {
    trace("width: " + info.width);
    trace("height: " + info.height);
 }
</codeblock></example><example conref="examples\NetStream.send.4.as"> Im folgenden Beispiel wird eine Wiedergabeliste auf dem Server erstellt:
<codeblock>
 // Create a NetStream for playing
 var my_ns:NetStream = new NetStream(my_nc);
 my_video.attachNetStream(my_ns);
 
 // Play the stream record1
 my_ns.play("record1", 0, -1, true);
 
 // Switch to the stream live1 and play for 5 seconds.  
 // Since reset is false, live1 will start to play after record1 is done.
 my_ns.play("live1", -1 , 5, false);
</codeblock></example><example conref="examples\NetStream.send.5.as"> Wenn die aufgezeichnete Videodatei nur Datenmeldungen enthält, können Sie die Videodatei entweder mit der Geschwindigkeit, in der sie aufgezeichnet wurde, abspielen, oder Sie rufen alle Datenmeldungen auf einmal ab.
<codeblock>
 //To play at normal speed
 var my_ns:NetStream = new NetStream(my_nc);
 my_ns.play("log", 0, -1);
 
 //To get the data messages all at once
 my_ns.play("log", 0, -1, 3);
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:setDRMAuthenticationCredentials"><apiName>setDRMAuthenticationCredentials</apiName><shortdesc>
     Senden die DRM-Authentifizierungsdaten, die für die Anzeige des verschlüsselten Inhalts erforderlich sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, setDRMAuthenticationCredentials
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>userName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein gültiger Benutzername.
     </apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die Kennwortdaten, die dem angegebenen Benutzernamen zugeordnet sind.
     </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String, der angibt, welche Art von Authentifizierungsdaten angegeben werden. Gültige Werte sind <codeph>"drm"</codeph> und <codeph>"proxy"</codeph>. Der Standardwert ist <codeph>"drm"</codeph>.
     <ul>
     <li>Mit dem Authentifizierungstyp <codeph>"drm"</codeph> werden die bereitgestellten Benutzerdaten für den Flash Media Rights Management Server (FMRMS) authentifiziert.</li>
     <li>Mit dem Authentifizierungstyp <codeph>"proxy"</codeph> werden die bereitgestellten Benutzerdaten für den Proxyserver authentifiziert und müssen mit den vom Proxyserver angeforderten übereinstimmen. Die <codeph>"proxy"</codeph>-Option ermöglicht der Anwendung zum Beispiel die Authentifizierung für einen Proxyserver, wenn ein Unternehmen diesen Schritt verlangt, bevor der Benutzer Zugriff auf das Internet hat. Sofern keine anonyme Authentifizierung verwendet wird, muss sich der Benutzer nach der Proxyauthentifizierung immer noch für den FMRMS authentifizieren, um den Gutschein zu erhalten und den Inhalt abzuspielen. Sie können <codeph>setDRMAuthenticationcredentials()</codeph> ein zweites Mal verwenden, diesmal mit der <codeph>"drm"</codeph>-Option, um die Authentifizierung für den FMRMS auszuführen.</li>
     </ul>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Senden die DRM-Authentifizierungsdaten, die für die Anzeige des verschlüsselten Inhalts erforderlich sind.
     <p>
     Die <codeph>setDRMAuthenticationCredentials()</codeph>-Methode muss Benutzerdaten zur Verfügung stellen, die mit denjenigen übereinstimmen, die vom Content Provider oder dem Proxyserver erkannt und akzeptiert werden. Dies sind dieselben Benutzerdaten, die der Benutzer verwendet, um die Berechtigung zum Anzeigen des Inhalts zu bekommen.
     </p>
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:togglePause"><apiName>togglePause</apiName><shortdesc>
	 Hält die Wiedergabe eines Streams an oder setzt sie fort.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Hält die Wiedergabe eines Streams an oder setzt sie fort. Beim ersten Aufruf dieser Methode wird die Wiedergabe angehalten und beim zweiten Aufruf fortgesetzt. Mit dieser Methode können Sie Benutzern ermöglichen, die Wiedergabe über dieselbe Schaltfläche anzuhalten und fortzusetzen.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetStream:CONNECT_TO_FMS"><apiName>CONNECT_TO_FMS</apiName><shortdesc>
     Ein statisches Objekt, das als Parameter für den Konstruktor einer NetStream-Instanz verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>connectToFMS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein statisches Objekt, das als Parameter für den Konstruktor einer NetStream-Instanz verwendet wird. Der Standardwert des zweiten Parameters im NetStream-Konstruktor: er wird nicht von der Anwendung für die progressive Medienwiedergabe verwendet. Wenn dieser Parameter verwendet wird, stellt der Konstruktor eine Verbindung zur Flash Media Server-Instanz her.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:DIRECT_CONNECTIONS"><apiName>DIRECT_CONNECTIONS</apiName><shortdesc>
     Stellt eine Peer-to-Peer-Herausgeberverbindung her.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>directConnections</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Stellt eine Peer-to-Peer-Herausgeberverbindung her. Übergeben Sie diesen String für den zweiten (optionalen) Parameter an den Konstruktor für eine NetStream-Instanz. Mit diesem String kann eine Anwendung eine NetStream-Verbindung zum Veröffentlichen von Audio und Video für Clients erstellen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:bufferLength:get"><apiName>bufferLength</apiName><shortdesc>
	 Die derzeit im Puffer befindliche Datenmenge, gemessen in Sekunden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bufferLength, bufferLength
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die derzeit im Puffer befindliche Datenmenge, gemessen in Sekunden. Wenn Sie diese Eigenschaft zusammen mit <codeph>bufferTime</codeph> verwenden, können Sie einschätzen, wie weit der Zwischenspeicher belegt ist, um beispielsweise eine Rückmeldung für einen Benutzer anzuzeigen, der darauf wartet, dass Daten in den Zwischenspeicher geladen werden.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bufferTime:set"><apiName>bufferTime</apiName><shortdesc>
	 Bestimmt, wie lange Nachrichten im Zwischenspeicher bleiben, bis mit der Anzeige des Streams begonnen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.setBufferTime, setBufferTime
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Bestimmt, wie lange Nachrichten im Zwischenspeicher bleiben, bis mit der Anzeige des Streams begonnen wird. Wenn beispielsweise die ersten 15 Sekunden des Streams ohne Unterbrechung wiedergegeben werden sollen, legen Sie 15 für <codeph>bufferTime</codeph> fest. Die Anwendung beginnt mit der Wiedergabe des Streams erst dann, wenn 15 Datensekunden zwischengespeichert sind.
	 
	 <p>Der Standardwert ist 0,1 (ein Zehntel einer Sekunde). Mit der Eigenschaft <codeph>bufferLength</codeph> können Sie die derzeit im Puffer befindliche Datenmenge (in Sekunden) ermitteln.</p>
	 
     <p><b>Hinweis:</b> Um beim Streaming von aufgezeichneten Inhalten (nicht live) Verzerrungen zu vermeiden, sollten Sie den Wert von <codeph>Netstream.bufferTime</codeph> auf 0 setzen. Bei aufgezeichneten Inhalten verwendet die Anwendung standardmäßig einen Eingabepuffer, der die Mediendaten in eine Warteschlange stellt und die Medien korrekt wiedergibt. Verwenden Sie bei aufgezeichneten Inhalten die Standardeinstellung oder erhöhen Sie die Pufferzeit.</p>
     
     <p>Beginnend mit Flash Player 9.0.115.0 leert der Flash Player den Puffer nicht mehr, wenn <codeph>NetStream.pause()</codeph> aufgerufen wird. In Vorgängerversionen von Flash Player 9.0.115.0 hat Flash Player gewartet, bis der Puffer voll war, bevor die Wiedergabe fortgesetzt wurde, wodurch es häufig zu Verzögerungen kam.</p>
     	 
     	 <p>Für eine einzelne Pause hat die <codeph>NetStream.bufferLength</codeph>-Eigenschaft ein Limit von 60 Sekunden oder das Doppelte des Werts von <codeph>NetStream.bufferTime</codeph>, je nachdem, welcher Wert höher ist. Wenn <codeph>bufferTime</codeph> zum Beispiel 20 Sekunden beträgt, puffert Flash Player, bis <codeph>NetStream.bufferLength</codeph> den höheren Wert von 20~~2 (40) oder 60 hat; in diesem Fall also bis <codeph>bufferLength</codeph> den Wert 60 hat. Wenn <codeph>bufferTime</codeph> 40 Sekunden beträgt, puffert Flash Player, bis <codeph>bufferLength</codeph> den höheren Wert von 40~~2 (80) oder 60 hat; in diesem Fall also bis <codeph>bufferLength</codeph> den Wert 80 hat.</p>
     	 
     	 <p>Die <codeph>bufferLength</codeph>-Eigenschaft hat auch ein absolutes Limit. Wenn ein Aufruf von <codeph>pause()</codeph> dazu führt, dass <codeph>bufferLength</codeph> auf mehr als 600 Sekunden ansteigt oder der Wert von <codeph>bufferTime</codeph> ~~ 2, je nachdem, welcher Wert höher ist, löscht Flash Player den Puffer und setzt <codeph>bufferLength</codeph> auf 0 zurück. Wenn <codeph>bufferTime</codeph> zum Beispiel 120 Sekunden beträgt, löscht Flash Player den Puffer, wenn <codeph>bufferLength</codeph> den Wert 600 Sekunden erreicht; wenn <codeph>bufferTime</codeph> 360 Sekunden beträgt, löscht Flash Player den Puffer, wenn <codeph>bufferLength</codeph> den Wert 720 Sekunden erreicht.</p>
     	 
     	 <p><b>Tipp</b>: Sie können im Code <codeph>NetStream.pause()</codeph> verwenden, um Daten zu puffern, während Betrachter zum Beispiel einen Werbespot sehen, und dann die Pause aufheben, wenn das Hauptvideo beginnt.</p>
     	 
     	 <p>Weitere Informationen zum neuen Pausenverhalten finden Sie unter <xref href="http://www.adobe.com/go/learn_fms_smartpause_de" scope="external">http://www.adobe.com/go/learn_fms_smartpause_de</xref>.</p>
     <p>
     <b>Flash Media Server</b>. Das Pufferverhalten ist davon abhängig, ob die Pufferzeit für einen veröffentlichenden oder abonnierenden Stream festgelegt wird. Für einen veröffentlichenden Stream legt <codeph>bufferTime</codeph> fest, wie lange der ausgehende Puffer anwachsen kann, bevor die Anwendung beginnt, Bilder zu überspringen. Bei einer Highspeed-Verbindung sollte die Pufferzeit kein Problem darstellen; Daten werden fast so schnell gesendet, wie die Anwendung sie puffern kann. Bei langsameren Verbindungen kann es jedoch einen erheblichen Unterschied geben zwischen der Geschwindigkeit, mit der die Anwendung Daten puffert, und der Geschwindigkeit, mit der die Daten an den Client gesendet werden. 
     </p>
     
     <p>
     Für einen abonnierenden Stream legt <codeph>bufferTime</codeph> fest, wie lange eingehende Daten gepuffert werden, bevor der Stream angezeigt wird. Wenn beispielsweise die ersten 15 Sekunden des Streams ohne Unterbrechung wiedergegeben werden sollen, legen Sie 15 für <codeph>bufferTime</codeph> fest; Flash beginnt mit der Wiedergabe des Streams erst, wenn 15 Datensekunden zwischengespeichert sind.
     </p>
     
     <p>
     Wenn ein aufgezeichneter Stream abgespielt wird und <codeph>bufferTime</codeph> den Wert null aufweist, stellt Flash einen kleinen Wert ein (ca. 10 Millisekunden). Wenn Live-Stream später abgespielt werden (zum Beispiel von einer Wiedergabeliste) bleibt die Pufferzeit erhalten. Das bedeutet, <codeph>bufferTime</codeph> bleibt „nicht null“ für den Stream. 
     </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#bufferTime/bufferLength"><linktext>bufferLength</linktext></link><link href="" invalidHref="flash.net.xml#bufferTime/time"><linktext>time</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 Die Anzahl der in die Anwendung geladenen Datenbyte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesLoaded, bytesLoaded
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Die Anzahl der in die Anwendung geladenen Datenbyte. Wenn Sie diese Eigenschaft zusammen mit <codeph>bytesTotal</codeph> verwenden, können Sie einschätzen, wie weit der Zwischenspeicher belegt ist, um beispielsweise eine Rückmeldung für einen Benutzer anzuzeigen, der darauf wartet, dass Daten in den Zwischenspeicher geladen werden.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesTotal"><linktext>bytesTotal</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 Die Gesamtgröße (in Byte) der in die Anwendung geladenen Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesTotal, bytesTotal
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Die Gesamtgröße (in Byte) der in die Anwendung geladenen Datei.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:checkPolicyFile:get"><apiName>checkPolicyFile</apiName><shortdesc>
	 Gibt an, ob die Anwendung vor dem Laden der Videodatei versuchen soll, eine Cross-Domain-Richtliniendatei vom Server der Videodatei herunterzuladen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob die Anwendung vor dem Laden der Videodatei versuchen soll, eine Cross-Domain-Richtliniendatei vom Server der Videodatei herunterzuladen. Diese Eigenschaft wird angewendet, wenn Sie ein NetStream-Objekt für den progressiven Video-Download (eigenständige Dateien) verwenden oder Dateien laden, die sich außerhalb der Domäne der aufrufenden Datei befinden. Diese Eigenschaft wird ignoriert, wenn Sie ein NetStream-Objekt verwenden, um einen RTMP-Bestand abzurufen.
	 
     <p>Setzen Sie diese Eigenschaft auf <codeph>true</codeph>, wenn Sie eine Videodatei von außerhalb der Domäne der aufrufenden SWF-Datei laden und die <codeph>BitmapData.draw()</codeph>-Methode für einen Pixelebenenzugriff auf das Video benötigen. Wenn Sie <codeph>BitmapData.draw()</codeph> aufrufen, ohne die Eigenschaft <codeph>checkPolicyFile</codeph> zum Ladezeitpunkt auf <codeph>true</codeph> zu setzen, wird möglicherweise eine <codeph>SecurityError</codeph>-Ausnahme ausgelöst, da die erforderliche Richtliniendatei nicht heruntergeladen wurde.</p>
	 
	 <p>Wenn kein Zugriff auf Pixelebene auf das zu ladende Video erforderlich ist, setzen Sie <codeph>checkPolicyFile</codeph> nicht auf <codeph>true</codeph>. Durch die Suche nach einer Richtliniendatei wird Netzwerkbandbreite belegt und der Start des Download-Vorgangs möglicherweise verzögert.</p>
	 
	 <p>Wenn Sie die Methode <codeph>NetStream.play()</codeph> aufrufen und <codeph>checkPolicyFile</codeph> auf <codeph>true</codeph> gesetzt ist, muss in <ph platform="actionscript">Flash Player oder </ph> der AIR-Laufzeitumgebung vor dem Herunterladen des im <codeph>NetStream.play()</codeph>-Aufruf angegebenen Objekts entweder eine entsprechende Cross-Domain-Richtlinie erfolgreich heruntergeladen werden, oder es muss festgestellt werden, dass keine Richtliniendatei vorhanden ist. In <ph platform="actionscript">Flash Player oder </ph>der AIR-Laufzeitumgebung werden die folgenden Aktionen in der angegebenen Reihenfolge ausgeführt, um zu überprüfen, ob eine Richtliniendatei vorhanden ist:</p>
	 
	 <ol>
	 
     <li>Die Anwendung überprüft Richtliniendateien, die bereits heruntergeladen wurden.</li>
	 
	 <li>Die Anwendung versucht, ausstehende Richtliniendateien herunterzuladen, die in Aufrufen von <codeph>Security.loadPolicyFile()</codeph> angegeben wurden.</li>
	 
	 <li>Die Anwendung versucht, eine Richtliniendatei vom Standardspeicherort herunterzuladen, der der an <codeph>NetStream.play()</codeph> übergebenen URL entspricht, d. h. <codeph>/crossdomain.xml</codeph> auf dem gleichen Server wie die URL.</li>
	 
	 </ol>
	 
	 <p>In allen Fällen muss für <ph platform="actionscript">Flash Player oder </ph>die AIR-Laufzeitumgebung eine entsprechende Richtliniendatei auf dem Server des Videos vorhanden sein, über die anhand ihres Speicherorts auf das Objekt unter der an <codeph>play()</codeph> übergebenen URL zugegriffen werden kann und über die die Domäne der aufrufenden Datei über mindestens ein <codeph>&lt;allow-access-from></codeph>-Tag auf das Video zugreifen kann.</p>
	 
	 <p>Wenn Sie <codeph>checkPolicyFile</codeph> auf <codeph>true</codeph> setzen, wartet die Anwendung mit dem Laden des Videos, bis die Richtliniendatei überprüft wurde. Warten Sie mit dem Ausführen von Vorgängen auf Pixelebene (z. B. Aufrufen von <codeph>BitmapData.draw()</codeph>), bis Sie <codeph>onMetaData</codeph>- oder <codeph>NetStatus</codeph>-Ereignisse von Ihrem NetStream-Objekt erhalten.</p>
	 
	 <p>Wenn Sie <codeph>checkPolicyFile</codeph> auf <codeph>true</codeph> setzen, jedoch keine entsprechende Richtliniendatei gefunden wird, wird eine Fehlermeldung erst dann ausgegeben, wenn Sie einen Vorgang durchführen, der eine Richtliniendatei erfordert. Dann wird in der Anwendung eine SecurityError-Ausnahme ausgegeben.</p>
	 
	 <p>Beim Herunterladen einer Videodatei von einer URL, bei der serverseitige HTTP-Weiterleitungen verwendet werden, müssen Sie darauf achten, <codeph>checkPolicyFile</codeph> richtig zu verwenden. Die Anwendung versucht, Richtliniendateien abzurufen, die der ursprünglichen in <codeph>NetStream.play()</codeph> angegebenen URL entsprechen. Wenn die endgültige Videodatei aufgrund von HTTP-Weiterleitungen von einer anderen URL stammt, gelten die ursprünglich heruntergeladenen Richtliniendateien möglicherweise nicht für die endgültige URL der Videodatei. Dies ist jedoch die URL, die bei Sicherheitsentscheidungen von Bedeutung ist.</p>
	 
	 <p>Weitere Informationen zu Richtliniendateien finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link><link href="flash.net.xml#NetStream/event:netStatus"><linktext>netStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:client:get"><apiName>client</apiName><shortdesc>
     Legt das Objekt fest, für das Callback-Methoden aufgerufen werden, um Streaming oder FLV-Dateidaten zu verarbeiten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Die <codeph>client</codeph>-Eigenschaft muss auf ein Objekt eingestellt werden, das nicht null ist.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Legt das Objekt fest, für das Callback-Methoden aufgerufen werden, um Streaming oder FLV-Dateidaten zu verarbeiten. Standardeinstellung ist das erstellte NetStream-Objekt <codeph>this</codeph>. Wenn Sie die <codeph>client</codeph>-Eigenschaft auf ein anderes Objekt setzen, werden Callback-Methoden auf diesem anderen Objekt aufgerufen. Das <codeph>NetStream.client </codeph>-Objekt kann die folgenden Funktionen aufrufen und ein verknüpftes Datenobjekt empfangen: <codeph>onCuePoint()</codeph>, <codeph>onImageData()</codeph>, <codeph>onMetaData()</codeph>, <codeph>onPlayStatus()</codeph>, <codeph>onTextData()</codeph> und <codeph>onXMPData()</codeph>.
     <p><b>Verknüpfen der <codeph>client</codeph>-Eigenschaft mit einer Ereignisprozedur:</b></p>
     <p><ol><li>Erstellen Sie ein Objekt und verknüpfen Sie es mit der <codeph>client</codeph>-Eigenschaft des NetStream-Objekts:
     <codeblock>
     var customClient:Object = new Object();
     my_netstream.client = customClient;
     </codeblock>
     </li>
     <li>Verknüpfen Sie eine Ereignisprozedurfunktion für das gewünschte Datenereignis als Eigenschaft des Client-Objekts:
     <codeblock>
     customClient.onImageData = onImageDataHandler;           
     </codeblock>
     </li>
     <li>Schreiben Sie die Prozedurfunktion, um das Datenereignisobjekt zu empfangen, z. B.:
     <codeblock>
      public function onImageDataHandler(imageData:Object):void {
              trace("imageData length: " + imageData.data.length);
      }
     </codeblock></li>
     </ol></p>
     <p>Wenn Daten durch den Stream oder während der Wiedergabe übergeben werden, wird das Datenereignisobjekt (in diesem Fall das <codeph>imageData</codeph>-Objekt) mit den Daten gefüllt. In der Beschreibung zu <codeph>onImageData</codeph> finden Sie ein vollständiges Beispiel eines Objekts, dass mit der <codeph>client</codeph>-Eigenschaft verknüpft ist.</p>
     <p><b>Verknüpfen der <codeph>client</codeph>-Eigenschaft mit einer Unterklasse:</b></p>
     <p><ol><li>Erstellen Sie eine Unterklasse mit einer Prozedurfunktion, um das Datenereignisobjekt zu empfangen:
     <codeblock>
     class CustomClient {
        public function onMetaData(info:Object):void {
            trace("metadata: duration=" + info.duration + " framerate=" + info.framerate);
     }
     </codeblock>
     </li>
     <li>Verknüpfen Sie eine Instanz der Unterklasse mit der <codeph>client</codeph>-Eigenschaft des NetStream-Objekts:
     <codeblock>
     my_netstream.client = new CustomClient();
     </codeblock>
     </li>
     </ol></p>     
     <p>Wenn Daten durch den Stream oder während der Wiedergabe übergeben werden, wird das Datenereignisobjekt (in diesem Fall das <codeph>info</codeph>-Objekt) mit den Daten gefüllt. Im Klassenbeispiel am Ende der NetStream-Klasse können Sie sehen, wie eine Unterklasseninstanz mit der <codeph>client</codeph>-Eigenschaft verknüpft wird.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>
	 Die Zahl der pro Sekunde angezeigten Bilder.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.currentFPS, currentFPS
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Zahl der pro Sekunde angezeigten Bilder. Wenn Sie Videodateien für die Wiedergabe auf verschiedenen Systemen exportieren, können Sie mithilfe dieses Werts beim Testen bestimmen, wie stark die exportierte Datei komprimiert werden soll.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farID:get"><apiName>farID</apiName><shortdesc>
     Die ID ganz am Ende, die mit dieser NetStream-Instanz verknüpft ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Die ID ganz am Ende, die mit dieser <codeph>NetStream</codeph>-Instanz verknüpft ist. Diese Eigenschaft wird nur für RTMFP-Verbindungen definiert.
     
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     Ein Wert, der von der anderen Seite dieses Streams gewählt wird und für diese Verbindung eindeutig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert, der von der anderen Seite dieses Streams gewählt wird und für diese Verbindung eindeutig ist. Dieser Wert erscheint am anderen Ende des Streams als <codeph>nearNonce</codeph>-Wert Diese Eigenschaft wird nur für RTMFP-Verbindungen definiert.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:info:get"><apiName>info</apiName><shortdesc>
     Gibt ein NetStreamInfo-Objekt zurück, dessen Eigenschaften Statistiken über die Dienstqualität enthalten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.net:NetStreamInfo</apiValueClassifier></apiValueDef><apiDesc>
     Gibt ein NetStreamInfo-Objekt zurück, dessen Eigenschaften Statistiken über die Dienstqualität enthalten. Das Objekt ist ein Schnappschuss des aktuellen Status. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo"><linktext>NetStreamInfo</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:liveDelay:get"><apiName>liveDelay</apiName><shortdesc>
	 Die Datenmenge (in Sekunden) im Zwischenspeicher des abonnierenden Streams im Live-Modus (ohne Puffer).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Property
	 
	 </category></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Datenmenge (in Sekunden) im Zwischenspeicher des abonnierenden Streams im Live-Modus (ohne Puffer). Diese Eigenschaft gibt die aktuelle Netzwerkübertragungsverzögerung an.
	 
	 <p>Diese Eigenschaft ist für die Verwendung mit einem Server wie Flash Media Server konzipiert. Weitere Informationen finden Sie in der Beschreibung der Klasse.</p>
	 
	 <p>Mit dem Wert dieser Eigenschaft können Sie die Übertragungsqualität des Streams grob einschätzen und dem Benutzer mitteilen. </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:maxPauseBufferTime:set"><apiName>maxPauseBufferTime</apiName><shortdesc>
     Gibt an, wie lange (in Sekunden) Meldungen im Pause-Modus gepuffert werden.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, wie lange (in Sekunden) Meldungen im Pause-Modus gepuffert werden. Diese Eigenschaft kann verwendet werden, um zu beschränken, wie viel im Pause-Modus gepuffert werden soll. Sobald der Wert für <codeph>NetStream.bufferLength</codeph> dieses Limit erreicht hat, werden keine weiteren Daten mehr gepuffert. Wenn dieser Wert nicht festgelegt ist, wird das Limit auf 60 Sekunden oder auf den doppelten Wert von <codeph>NetStream.bufferTime</codeph> auf jeder Pause gesetzt, je nachdem, welcher Wert höher ist.
     </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#maxPauseBufferTime/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     Ein Wert, der von dieser Seite des Streams gewählt wird und für diese Verbindung eindeutig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert, der von dieser Seite des Streams gewählt wird und für diese Verbindung eindeutig ist. Dieser Wert erscheint am anderen Ende des Streams als <codeph>farNonce</codeph>-Wert Diese Eigenschaft wird nur für RTMFP-Verbindungen definiert.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
	 Die Objektkodierung (AMF-Version) für dieses NetStream-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Die Objektkodierung (AMF-Version) für dieses NetStream-Objekt. Der <codeph>objectEncoding</codeph>-Wert für das NetStream-Objekt wird von dem verknüpften NetConnection-Objekt übernommen. Es ist wichtig, die Funktionsweise dieser Eigenschaft zu kennen, wenn die Kommunikation der ActionScript 3.0-SWF-Datei mit Servern erforderlich ist, die eine ältere Version als Flash Player 9 aufweisen. Weitere Informationen finden Sie in der Beschreibung der Eigenschaft <codeph>objectEncoding</codeph> in der NetConnection-Klasse.
	 
	 <p>Der Wert dieser Eigenschaft hängt davon ab, ob es sich um einen lokalen oder einen Remote-Stream handelt. Lokale Streams, bei denen <codeph>null</codeph> an die Methode <codeph>NetConnection.connect()</codeph> übergeben wurde, geben den Wert <codeph>NetConnection.defaultObjectEncoding</codeph> zurück. Remote-Streams, bei denen Sie eine Verbindung zu einem Server herstellen, geben die Objektkodierung der Serververbindung zurück.</p>
	 
	 <p>Wenn Sie versuchen, diese Eigenschaft ohne Verbindung zu lesen oder diese Eigenschaft zu ändern, gibt die Anwendung eine Ausnahme aus.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:peerStreams:get"><apiName>peerStreams</apiName><shortdesc>
	 
     Ein Objekt, das alle abonnierenden NetStream-Instanzen enthält, die diese veröffentlichende NetStream-Instanz überwachen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 
     Ein Objekt, das alle abonnierenden NetStream-Instanzen enthält, die diese veröffentlichende NetStream-Instanz überwachen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Steuert den Sound in diesem NetStream-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Steuert den Sound in diesem NetStream-Objekt. Weitere Informationen hierzu finden Sie im Abschnitt zur SoundTransform-Klasse.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:time:get"><apiName>time</apiName><shortdesc>
	 Die Position des Abspielkopfs in Sekunden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.time, time
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Position des Abspielkopfs in Sekunden.
	 <p>
	 <b>Flash Media Server</b> Bei einem abonnierenden Stream die Anzahl der Sekunden, die der Stream bereits abgespielt wurde. Bei einem veröffentlichenden Stream die Anzahl der Sekunden, die der Stream veröffentlicht wurde. Die Zahl ist bis zur Tausenderdezimalstelle genau; multiplizieren Sie sie mit 1000, um die Anzahl der Millisekunden zu erhalten, die der Stream bereits abgespielt wurde.
	 </p>
	 <p>
	 Wenn der Server bei einem abonnierenden Stream aufhört, Daten zu senden, aber der Stream offen bleibt, wird der Wert der <codeph>time</codeph>-Eigenschaft nicht weiter erhöht. Wenn der Server beginnt, wieder Daten zu senden, wird der Wert von dort, wo er angehalten wurde (als der Server aufgehört hat, Daten zu senden), weiter erhöht. 
	 </p>
	 <p>
     Der Wert für <codeph>time</codeph> wird weiter erhöht, wenn der Stream von einem Wiedergabeelement zu einem anderen wechselt. Diese Eigenschaft wird auf 0 gesetzt, wenn <codeph>NetStream.play()</codeph> aufgerufen wird und dabei <codeph>reset</codeph> den Wert <codeph>1</codeph> oder <codeph>true</codeph> aufweist, oder wenn <codeph>NetStream.close()</codeph> aufgerufen wird. 
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
 Mit der LocalConnection-Klasse können Sie ein LocalConnection-Objekt erstellen, das eine Methode in einem anderen LocalConnection-Objekt aufrufen kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der LocalConnection-Klasse können Sie ein LocalConnection-Objekt erstellen, das eine Methode in einem anderen LocalConnection-Objekt aufrufen kann. Die Kommunikation erfolgt:
 
 <ul>
 		<li>innerhalb einer einzelnen SWF-Datei</li>
 		<li>zwischen mehreren SWF-Dateien</li>
 		<li>zwischen Inhalt (SWF-basiert oder HTML-basiert) in AIR-Anwendungen</li>
		<li>zwischen Inhalt (SWF-basiert oder HTML-basiert) in einer AIR-Anwendung und SWF-Inhalt, der in einem Browser ausgeführt wird</li>
 </ul>
 
 <p>Lokale Verbindungen ermöglichen diese Art von Kommunikation zwischen SWF-Dateien ohne Verwendung von <codeph>fscommand()</codeph> oder JavaScript. LocalConnection-Objekte können nur zwischen Dateien ausgetauscht werden, die auf demselben Client-Computer abgespielt werden. Sie können jedoch in verschiedenen Anwendungen ausgeführt werden. Beispielsweise kann die eine Datei in einem Browser, eine andere in Adobe AIR abgespielt werden. </p>
 
 <p platform="actionscript">In ActionScript 3.0 erstellte LocalConnection-Objekte können mit LocalConnection-Objekten kommunizieren, die in ActionScript 1.0 oder 2.0 erstellt wurden. Dasselbe gilt umgekehrt: In ActionScript 1.0 oder 2.0 erstellte LocalConnection-Objekte können mit LocalConnection-Objekten kommunizieren, die in ActionScript 3.0 erstellt wurden. Flash Player verarbeitet die Kommunikation zwischen LocalConnection-Objekten verschiedener Versionen automatisch.</p>
 
 <p>Um zu verdeutlichen, wie LocalConnection-Objekte für die Kommunikation zwischen zwei Dateien verwendet werden, ist es hilfreich, die in jeder der Dateien verwendeten Befehle zu kennen. Eine Datei wird als <i>sendende</i> Datei bezeichnet. Diese Datei enthält die aufzurufende Methode. Die sendende Datei muss ein LocalConnection-Objekt und einen Aufruf der Methode <codeph>send()</codeph> enthalten. Die andere Datei wird als <i>empfangende</i> Datei bezeichnet. Diese Datei ruft die Methode auf. Die empfangende Datei muss ein anderes LocalConnection-Objekt und einen Aufruf der Methode <codeph>connect()</codeph> enthalten.</p>
 
 <p>Die Verwendung der Methoden <codeph>send()</codeph> und <codeph>connect()</codeph> ist unterschiedlich und hängt davon ab, ob sich die Dateien in derselben Domäne, in verschiedenen Domänen mit bekannten Domänennamen oder in verschiedenen Domänen mit unbekannten oder dynamischen Domänennamen befinden. In den folgenden Abschnitten werden diese drei Situationen mit entsprechenden Codebeispielen erläutert.</p>
 
 <p><b>Gleiche Domäne</b>: Die einfachste Art der Verwendung von LocalConnection-Objekten besteht darin, die Kommunikation nur zwischen LocalConnection-Objekten zuzulassen, die sich in derselben Domäne befinden, da die Kommunikation innerhalb derselben Domäne standardmäßig unterstützt wird. Für die Kommunikation von zwei Dateien innerhalb derselben Domäne müssen Sie keine speziellen Sicherheitsmaßnahmen implementieren. Sie übergeben einfach denselben Wert für den Parameter <codeph>connectionName</codeph> an die Methode <codeph>connect()</codeph> und an die Methode <codeph>send()</codeph>:</p>
 
 <p><adobeimage alt="Laden aus derselben Domäne" href="../../images/localconnection_samedomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.connect('myConnection');

// sendingLC is in http://www.domain.com/sending.swf
// myMethod() is defined in sending.swf
sendingLC.send('myConnection', 'myMethod');
</codeblock>
 <p><b>Unterschiedliche Domänen mit bekannten Domänennamen</b>: Für die Kommunikation von zwei SWF-Dateien in unterschiedlichen Domänen müssen Sie die Kommunikation zwischen den Domänen zulassen, indem Sie die Methode <codeph>allowDomain()</codeph> aufrufen. Außerdem müssen Sie den Verbindungsnamen in der Methode <codeph>send()</codeph> mit dem Domänennamen des empfangenden LocalConnection-Objekts qualifizieren:</p>
 
 <p><adobeimage alt="Laden aus verschiedenen Domänen" href="../../images/localconnection_differentdomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('www.anotherdomain.com');
receivingLC.connect('myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('www.domain.com:myConnection', 'myMethod');
</codeblock>
 
 <p><b>Unterschiedliche Domänen mit unbekannten Domänennamen</b>: In einigen Fällen ist es erforderlich, die Portierbarkeit der Datei mit dem empfangenden LocalConnection-Objekt zwischen Domänen zu erhöhen. Um anzuweisen, dass das sendende und das empfangende LocalConnection-Objekt sich in unterschiedlichen Domänen befinden, ohne den Domänennamen in der Methode <codeph>send()</codeph> anzugeben, fügen Sie im Aufruf von <codeph>connect()</codeph> und <codeph>send()</codeph> am Anfang des Verbindungsnamens einen Unterstrich (_) hinzu. Um die Kommunikation zwischen den beiden Domänen zuzulassen, rufen Sie die Methode <codeph>allowDomain()</codeph> auf, und übergeben Sie die Domänen, von denen LocalConnection-Aufrufe zugelassen werden sollen. Sie können auch das Platzhalterargument (~~) übergeben, um Aufrufe von allen Domänen zuzulassen:</p>
 
 <p><adobeimage alt="Laden aus unbekannten Domänennamen" href="../../images/localconnection_unknowndomains.gif"/></p>
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('~~');
receivingLC.connect('_myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('_myConnection', 'myMethod');
</codeblock>
 
 <p>Sie können LocalConnection-Objekte zum Senden und Empfangen von Daten innerhalb einer Datei verwenden. Dies ist jedoch nicht gebräuchlich.</p>
 
 <p>Weitere Informationen zu den Methoden <codeph>send()</codeph> und <codeph>connect()</codeph> finden Sie in den Erläuterungen zum Parameter <codeph>connectionName</codeph> unter den Einträgen zu <codeph>LocalConnection.send()</codeph> und <codeph>LocalConnection.connect()</codeph>. Siehe auch die Einträge zu <codeph>allowDomain()</codeph> und <codeph>domain</codeph>.</p>
 
 </apiDesc><example conref="examples\LocalConnectionSenderExample.as"> Dieses Beispiel umfasst zwei ActionScript-Klassen, die in zwei separate SWF-Dateien kompiliert werden müssen.
 
 <p>In der SWF-Datei „LocalConnectionSenderExample“ wird eine LocalConnection-Instanz erstellt. Wenn der Benutzer auf die Schaltfläche klickt, wird die Methode <codeph>call()</codeph> verwendet, um die Methode <codeph>lcHandler</codeph> in der SWF-Datei aufzurufen. Der Verbindungsname ist „myConnection“ und der Inhalt der TextField-Instanz wird als Parameter übergeben.</p>
 
 <p>In der SWF-Datei „LocalConnectionReceiverExample“ wird eine LocalConnection-Instanz erstellt und die Methode <codeph>connect()</codeph> wird aufgerufen. Diese Methode kennzeichnet die SWF-Datei als Empfänger von Meldungen an die Verbindung mit dem Namen „myConnection“. Darüber hinaus umfasst diese Klasse eine öffentliche Methode mit dem Namen <codeph>lcHandler()</codeph>. Diese Methode wird in der SWF-Datei „LocalConnectionSenderExample“ aufgerufen. Beim Aufrufen dieser Methode wird der als Parameter übergebene Text an die TextField-Instanz auf der Bühne angehängt.</p>
 
 <p><b>Hinweis:</b> Zum Testen des Beispiels müssen beide SWF-Dateien gleichzeitig auf denselben Computer geladen werden.</p>
<codeblock>

// Code in LocalConnectionSenderExample.as
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.net.LocalConnection;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.StatusEvent;
    import flash.text.TextFieldAutoSize;

    public class LocalConnectionSenderExample extends Sprite {
        private var conn:LocalConnection;
        
        // UI elements
        private var messageLabel:TextField;
        private var message:TextField;
        private var sendBtn:Sprite;
        
        public function LocalConnectionSenderExample() {
            buildUI();
            sendBtn.addEventListener(MouseEvent.CLICK, sendMessage);
            conn = new LocalConnection();
            conn.addEventListener(StatusEvent.STATUS, onStatus);
        }
        
        private function sendMessage(event:MouseEvent):void {
            conn.send("myConnection", "lcHandler", message.text);
        }
        
        private function onStatus(event:StatusEvent):void {
            switch (event.level) {
                case "status":
                    trace("LocalConnection.send() succeeded");
                    break;
                case "error":
                    trace("LocalConnection.send() failed");
                    break;
            }
        }
        
        private function buildUI():void {
            const hPadding:uint = 5;
            // messageLabel
            messageLabel = new TextField();
            messageLabel.x = 10;
            messageLabel.y = 10;
            messageLabel.text = "Text to send:";
            messageLabel.autoSize = TextFieldAutoSize.LEFT;
            addChild(messageLabel);
            
            // message
            message = new TextField();
            message.x = messageLabel.x + messageLabel.width + hPadding;
            message.y = 10;
            message.width = 120;
            message.height = 20;
            message.background = true;
            message.border = true;
            message.type = TextFieldType.INPUT;
            addChild(message);
            
            // sendBtn
            sendBtn = new Sprite();
            sendBtn.x = message.x + message.width + hPadding;
            sendBtn.y = 10;
            var sendLbl:TextField = new TextField();
            sendLbl.x = 1 + hPadding;
            sendLbl.y = 1;
            sendLbl.selectable = false;
            sendLbl.autoSize = TextFieldAutoSize.LEFT;
            sendLbl.text = "Send";
            sendBtn.addChild(sendLbl);
            sendBtn.graphics.lineStyle(1);
            sendBtn.graphics.beginFill(0xcccccc);
            sendBtn.graphics.drawRoundRect(0, 0, (sendLbl.width + 2 + hPadding + hPadding), (sendLbl.height + 2), 5, 5);
            sendBtn.graphics.endFill();
            addChild(sendBtn);
        }
    }
}
</codeblock></example><example conref="examples\LocalConnectionReceiverExample.as"><codeblock>
// Code in LocalConnectionReceiverExample.as
package {
    import flash.display.Sprite;
    import flash.net.LocalConnection;
    import flash.text.TextField;

    public class LocalConnectionReceiverExample extends Sprite {
        private var conn:LocalConnection;
        private var output:TextField;
        
        public function LocalConnectionReceiverExample()     {
            buildUI();
            
            conn = new LocalConnection();
            conn.client = this;
            try {
                conn.connect("myConnection");
            } catch (error:ArgumentError) {
                trace("Can't connect...the connection name is already being used by another SWF");
            }
        }
        
        public function lcHandler(msg:String):void {
            output.appendText(msg + "\n");
        }
        
        private function buildUI():void {
            output = new TextField();
            output.background = true;
            output.border = true;
            output.wordWrap = true;
            addChild(output);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Wird ausgelöst, wenn der Status eines LocalConnection-Objekts protokolliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Status eines LocalConnection-Objekts protokolliert wird. Bei erfolgreichem Aufruf von <codeph>LocalConnection.send()</codeph> weist die Eigenschaft <codeph>level</codeph> des Ereignisobjekts <codeph>status</codeph> den Wert <codeph>"status"</codeph> auf. Wenn der Aufruf fehlschlägt, weist die Eigenschaft <codeph>level</codeph> den Wert <codeph>"error"</codeph> auf. Wenn die empfangende Datei die Verbindung ablehnt, kann der Aufruf ohne Benachrichtigung an die sendende Datei fehlschlagen. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>LocalConnection.send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Wird ausgelöst, wenn mit einem Aufruf von „LocalConnection.send()“ versucht wird, Daten an eine andere Sicherheitssandbox zu senden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn mit einem Aufruf von <codeph>LocalConnection.send()</codeph> versucht wird, Daten an eine andere Sicherheitssandbox zu senden.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron, d. h. aus nativem asynchronem Code ausgelöst wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron ausgelöst wird – das heißt, aus nativem asynchronem Code. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:LocalConnection:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
	 Erstellt ein LocalConnection-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how receiving and sending files create LocalConnnection objects. 
	 The two files can use the same name or different names for their respective LocalConnection objects. 
	 In this example they use different names.
	 
	 <listing>
	 // Code in the receiving file
	 this.createTextField("result_txt", 1, 10, 10, 100, 22);
	 result_txt.border = true;
	 var receiving_lc:LocalConnection = new LocalConnection();
	 receiving_lc.methodToExecute = function(param1:Number, param2:Number) {
	   result_txt.text = param1+param2;
	 };
	 receiving_lc.connect("lc_name");
	 </listing>
	 
	 <p>The following file sends the request to the first file.</p>
	 
	 <listing>
	 // Code in the sending file
	 var sending_lc:LocalConnection = new LocalConnection();
	 sending_lc.send("lc_name", "methodToExecute", 5, 7);
	 </listing>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Erstellt ein LocalConnection-Objekt. Mit LocalConnection-Objekten können Sie die Kommunikation zwischen verschiedenen Dateien auf demselben Client-Computer ermöglichen.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:LocalConnection:allowDomain"><apiName>allowDomain</apiName><shortdesc>
	 Gibt eine oder mehrere Domänen an, die LocalConnection-Aufrufe an diese LocalConnection-Instanz senden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Change the first example in the listing.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Alle angegebenen Parameter müssen Strings mit einem anderen Wert als null sein.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Ein oder mehrere Strings mit den Namen der Domänen, von denen Sie LocalConnection-Aufrufe zulassen möchten. Für diesen Parameter gelten zwei Sonderfälle:
	 
	 <ul>
	   <li>Sie können das Platzhalterzeichen „~~“ angeben, um Aufrufe von allen Domänen zuzulassen.</li>
	 
	   <li>Sie können den String "<codeph>localhost</codeph>" angeben, um Aufrufe dieser Datei von lokal installierten Dateien zuzulassen. <ph platform="actionscript">In Flash Player 8 wurden Sicherheitsbeschränkungen für lokale Dateien eingeführt. Standardmäßig haben in Flash Player ausgeführte SWF-Dateien, die auf das Internet zugreifen können, keinen Zugriff auf das lokale Dateisystem. Wenn Sie "<codeph>localhost</codeph>" angeben, können in Flash Player alle lokalen SWF-Dateien auf diese SWF-Datei zugreifen.</ph> </li>
	 
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt eine oder mehrere Domänen an, die LocalConnection-Aufrufe an diese LocalConnection-Instanz senden können.
	 
	 <p>Sie können diese Methode nicht verwenden, um Dateien, die mit einem sicheren Protokoll (HTTPS) gehostet werden, den Zugriff von Dateien zu erlauben, die in nicht sicheren Protokollen gehostet werden. Sie müssen stattdessen die Ereignisprozedur <codeph>allowInsecureDomain()</codeph> verwenden.</p> 
	 
	 <p>Sie sollten diese Methode verwenden, damit eine untergeordnete Datei von einer anderen Domäne LocalConnection-Aufrufe an die übergeordnete Datei vornehmen kann, ohne dass die endgültige Domäne bekannt ist, aus der die untergeordnete Datei stammt. Dies ist beispielsweise der Fall, wenn Sie Weiterleitungen mit Lastausgleich oder Server von Dritten verwenden. In diesem Fall können Sie die Eigenschaft <codeph>url</codeph> des mit der Ladung verwendeten LoaderInfo-Objekts einsetzen, um die Domäne dazu zu bewegen, die Methode <codeph>allowDomain()</codeph> anzuwenden. Wenn Sie beispielsweise mit einem Loader-Objekt eine untergeordnete Datei laden, können Sie, sobald der Ladevorgang abgeschlossen ist, die Eigenschaft <codeph>contentLoaderInfo.url</codeph> des Loader-Objekts überprüfen und die Domäne anhand der vollständigen URL parsen. Wenn Sie so verfahren, müssen Sie unbedingt warten, bis die Datei geladen wurde, denn die <codeph>contentLoaderInfo.url</codeph>-Eigenschaft verfügt erst, nachdem die Datei vollständig geladen wurde, über ihren endgültigen, korrekten Wert. </p> 
	 
	 <p>Es kann auch die entgegengesetzte Situation auftreten: Angenommen, Sie haben eine untergeordnete Datei erstellt, die LocalConnection-Aufrufe von der übergeordnete SWF-Datei annehmen möchte, der aber die Domäne der übergeordneten Datei nicht bekannt ist. In diesem Fall implementieren Sie diese Methode, indem Sie prüfen, ob das Domänenargument mit der Domäne der Eigenschaft <codeph>loaderInfo.url</codeph> in der geladenen Datei übereinstimmt. Auch diesmal müssen Sie die Domäne anhand der vollständigen URL von <codeph>loaderInfo.url</codeph> parsen. In diesem Fall müssen Sie jedoch nicht warten, bis die übergeordnete Datei geladen wurde, denn das Laden der übergeordneten Datei ist bereits abgeschlossen, wenn der Ladevorgang für die untergeordnete Datei erfolgt.</p> 
	 
	 <p platform="actionscript">Bedenken Sie beim Einsatz dieser Methode das Sicherheitsmodell von Flash Player. In der Standardeinstellung wird ein LocalConnection-Objekt mit der Sandbox der erstellenden Datei verknüpft. Domänenübergreifende Aufrufe für LocalConnection-Objekte sind nur dann zulässig, wenn Sie in der empfangenden Datei die Methode <codeph>LocalConnection.allowDomain()</codeph> aufrufen. In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
	 
	 <p platform="actionscript">Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
	 
     <ul platform="actionscript">
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
     
	 <p platform="actionscript"><b>Hinweis</b>: Die Form der Methode <codeph>allowDomain()</codeph> hat sich geändert. In den früheren Versionen (ActionScript 1.0 und 2.0) war <codeph>allowDomain</codeph> eine zu implementierende Callback-Methode. In ActionScript 3.0 ist <codeph>allowDomain()</codeph> eine in den LocalConnection-Aufruf eingebettete Methode. Aufgrund dieser Änderung ist die Methode <codeph>allowDomain()</codeph> jetzt mit <codeph>flash.system.Security.allowDomain()</codeph> vergleichbar.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowInsecureDomain()"><linktext>flash.net.LocalConnection.allowInsecureDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:allowInsecureDomain"><apiName>allowInsecureDomain</apiName><shortdesc>
	 Gibt eine oder mehrere Domänen an, die LocalConnection-Aufrufe an dieses LocalConnection-Objekt senden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Seems like a security note is in order here.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Alle angegebenen Parameter müssen Strings mit einem anderen Wert als null sein.
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Ein oder mehrere Strings mit den Namen der Domänen, von denen Sie LocalConnection-Aufrufe zulassen möchten. Für diesen Parameter gibt es zwei Sonderfälle:
	 <ul>
	   <li>Sie können das Platzhalterzeichen „~~“ angeben, um Aufrufe von allen Domänen zuzulassen. Lokale Hosts sind hierbei nicht eingeschlossen.</li>
	   <li>Sie können den String "<codeph>localhost</codeph>" angeben, um Aufrufe dieser SWF-Datei von lokal installierten SWF-Dateien zuzulassen. In Flash Player 8 wurden Sicherheitsbeschränkungen für lokale SWF-Dateien eingeführt. SWF-Dateien, die auf das Internet zugreifen können, haben keinen Zugriff auf das lokale Dateisystem. Wenn Sie "<codeph>localhost</codeph>" angeben, können alle lokalen SWF-Dateien auf diese SWF-Datei zugreifen. Beachten Sie, dass Sie die aufrufende SWF-Datei bei der Erstellung außerdem als lokale SWF-Datei mit Netzwerkzugang kennzeichnen müssen.</li>
	 </ul>
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt eine oder mehrere Domänen an, die LocalConnection-Aufrufe an dieses LocalConnection-Objekt senden können.  
	 
	 <p>Die Methode <codeph>allowInsecureDomain()</codeph> funktioniert wie die Methode <codeph>allowDomain()</codeph>, mit der Ausnahme, dass die Methode <codeph>allowInsecureDomain()</codeph> auch das Senden von LocalConnection-Aufrufen von Dateien aus HTTPS-Quellen durch SWF-Dateien aus Nicht-HTTPS-Quellen zulässt. Dieser Unterschied ist nur von Bedeutung, wenn Sie die Methode <codeph>allowInsecureDomain()</codeph> aus einer Datei aufrufen, die über HTTPS geladen wurde. Sie müssen die Methode <codeph>allowInsecureDomain()</codeph> auch bei Nicht-HTTPS-/HTTPS-Verbindungen innerhalb derselben Domäne aufrufen. Standardmäßig sind LocalConnection-Aufrufe von Dateien aus Nicht-HTTPS-Quellen an Dateien aus HTTPS-Quellen selbst innerhalb derselben Domäne nicht zulässig.</p>
	 
	 <p>Der Aufruf von <codeph>allowInsecureDomain()</codeph> wird nicht empfohlen, da hierdurch die durch HTTPS gewährleistete Sicherheit möglicherweise gefährdet wird. Wenn Sie eine Datei über HTTPS laden, können Sie relativ sicher sein, dass die Datei bei der Übermittlung über das Netzwerk nicht manipuliert wird. Wenn Sie dann LocalConnection-Aufrufe an diese Datei durch eine Datei ohne HTTPS zulassen, akzeptieren Sie Aufrufe von einer Datei, die während der Übertragung möglicherweise manipuliert wurde. In diesem Fall ist extreme Vorsicht geboten, da Sie sich nicht auf die Authentizität der LocalConnection-Aufrufe an die über HTTPS geladene Datei verlassen können.</p>
	 
	 <p>Standardmäßig können nur andere Dateien, die mit dem HTTPS-Protokoll gehostet werden, auf mit dem HTTPS-Protokoll gehostete Dateien zugreifen. Durch diese Implementierung bleibt die durch das HTTPS-Protokoll gewährleistete Integrität gewahrt.</p>
	 
	 <p>Der Einsatz dieser Methode zur Umgehung des Standardverhaltens empfiehlt sich nicht, da damit die HTTPS-Sicherheit beeinträchtigt wird. In einigen Fällen ist dies jedoch notwendig. Beispiel: Sie müssen den Zugriff auf für Flash Player 9 oder eine neuere Version veröffentlichte HTTPS-Dateien durch HTTPS-Dateien zulassen, die für Flash Player 6 oder eine ältere Version veröffentlicht wurden.</p>
	 
	 <p>Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
	 
     <ul>
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:close"><apiName>close</apiName><shortdesc>
	 Schließt das LocalConnection-Objekt (bricht die Verbindung ab).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die LocalConnection-Instanz kann nicht geschlossen werden, da sie nicht verbunden ist.
	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Schließt das LocalConnection-Objekt (bricht die Verbindung ab). Rufen Sie diesen Befehl auf, wenn das Objekt keine Befehle mehr annehmen soll, beispielsweise, wenn Sie einen <codeph>connect()</codeph>-Befehl mit demselben Parameter <codeph>connectionName</codeph> in einer anderen SWF-Datei aufrufen möchten.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:connect"><apiName>connect</apiName><shortdesc>
	 Bereitet ein LocalConnection-Objekt auf den Empfang von Befehlen eines send()-Befehls vor (das sogenannte sendende LocalConnection-Objekt).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.connect, connect
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der an den Parameter <codeph>connectionName</codeph> übergebene Wert darf nicht null sein.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann drei verschiedene Ursachen haben: 1) Der an den Parameter <codeph>connectionName</codeph> übergebene Stringwert war „null“. Übergeben Sie einen anderen Wert als „null“. 2) Der an den Parameter <codeph>connectionName</codeph> übergebene Wert enthielt einen Doppelpunkt (:). Doppelpunkte werden als Sonderzeichen zum Trennen der Superdomäne vom String <codeph>connectionName</codeph> in der Methode <codeph>send()</codeph> und nicht in der Methode <codeph>connect()</codeph> verwendet. 3) Die LocalConnection-Instanz ist bereits verbunden.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String, der mit dem Verbindungsnamen übereinstimmt, der im Befehl <codeph>send()</codeph> für die Kommunikation mit dem empfangenden LocalConnection-Objekt angegeben wurde. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bereitet ein LocalConnection-Objekt auf den Empfang von Befehlen eines <codeph>send()</codeph>-Befehls vor (das sogenannte <i>sendende LocalConnection-Objekt</i>). Das mit diesem Befehl verwendete Objekt ist das <i>empfangende LocalConnection-Objekt</i>. Das empfangende und das sendende Objekt müssen auf demselben Client-Computer ausgeführt werden.
	 
	 <p>Um eine „Race“-Bedingung zu vermeiden, definieren Sie die mit dem empfangenden LocalConnection-Objekt verknüpften Methoden, bevor Sie diese Methode aufrufen, wie im Beispiel zur Klasse „LocalConnection“ gezeigt. </p>
	 
	 <p>In der Standardeinstellung wird das <codeph>connectionName</codeph>-Argument in den Wert <codeph>"<i>superdomain</i>:connectionName"</codeph> aufgelöst, wobei <codeph><i>superdomain</i></codeph> die Superdomäne der Datei mit dem Befehl <codeph>connect()</codeph> ist. Wenn sich beispielsweise die Datei mit dem empfangenden LocalConnection-Objekt unter www.someDomain.com befindet, wird <codeph>connectionName</codeph> in <codeph>"someDomain.com:connectionName"</codeph> aufgelöst. (Wenn sich eine Datei, die in Flash Player ausgeführt wird, auf dem Client-Computer befindet, wird <codeph>superdomain</codeph> der Wert <codeph>"localhost"</codeph> zugewiesen.)</p>
	 
	 <p>Bei Inhalt, der in der Sicherheitssandbox <codeph> der Anwendung </codeph> Adobe AIR ausgeführt wird (Inhalt, der mit der AIR-Anwendung installiert wurde), verwendet die Laufzeit den String <codeph>app#</codeph> gefolgt von der Anwendungs-ID für die AIR-Anwendung (definiert in der Anwendungsdeskriptordatei) anstelle der Superdomäne. So wird zum Beispiel ein <codeph>connectionName</codeph> für eine Anwendung mit der Anwendungs-ID <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> in <codeph>"app#com.example.air.MyApp:connectionName"</codeph> aufgelöst.</p>
	 
	 <p>Ebenso lässt Flash Player das empfangende LocalConnection-Objekt nur Befehle von sendenden LocalConnection-Objekten empfangen, deren Verbindungsnamen ebenfalls in den Wert <codeph>"</codeph><codeph><i>superdomain</i></codeph><codeph>:connectionName"</codeph> aufgelöst werden. Auf diese Weise können in Flash Player zwischen Dateien derselben Domäne ganz einfach Daten ausgetauscht werden.</p>
	 
	 <p>Wenn Sie den Datenaustausch nur zwischen Dateien in derselben Domäne implementieren, geben Sie einen String für <codeph>connectionName</codeph> an, der nicht mit einem Unterstrich (_) beginnt und der keinen Domänennamen angibt (beispielsweise <codeph>"myDomain:connectionName"</codeph>). Verwenden Sie denselben String in der Methode <codeph>connect(connectionName)</codeph>.</p>
	 
	 <p>Wenn Sie eine Kommunikation zwischen Dateien in unterschiedlichen Domänen implementieren, lässt sich die Portierbarkeit der Datei mit dem empfangenden LocalConnection-Objekt erhöhen, indem Sie für <codeph>connectionName</codeph> einen String angeben, der mit einem Unterstrich (_) beginnt. Im Folgenden werden zwei mögliche Fälle erläutert:</p>
	 
	 <ul>
	 
	   <li>Wenn der String für <codeph>connectionName</codeph> nicht mit einem Unterstrich (_) beginnt, wird ein Präfix mit der Superdomäne und einen Doppelpunkt hinzugefügt (z. B. <codeph>"myDomain:connectionName"</codeph>). Dies stellt zwar sicher, dass es keinen Konflikt zwischen Ihrer Verbindung und gleichnamigen Verbindungen aus anderen Domänen gibt, allerdings müssen sendende LocalConnection-Objekte ebenfalls diese Superdomäne angeben (z. B. <codeph>"myDomain:connectionName"</codeph>). Wenn die Datei mit dem empfangenden LocalConnection-Objekt in eine andere Domäne verschoben wird, ändert der Player das Präfix entsprechend der neuen Superdomäne (z. B. <codeph>"anotherDomain:connectionName"</codeph>). Alle sendenden LocalConnection-Objekte müssen dann manuell bearbeitet werden, damit sie auf die neue Superdomäne verweisen.</li>
	 
	   <li>Wenn der String für <codeph>connectionName</codeph> mit einem Unterstrich beginnt (zum Beispiel, <codeph>"_connectionName"</codeph>), wird dem String kein Präfix hinzugefügt. Das heißt, empfangende und sendende LocalConnection-Objekte verwenden identische Strings für <codeph>connectionName</codeph>. Wenn das empfangende Objekt mit <codeph>allowDomain()</codeph> angibt, dass Verbindungen von allen Domänen zulässig sind, können Sie die Datei mit dem empfangenden LocalConnection-Objekt in eine andere Domäne verschieben, ohne die sendenden LocalConnection-Objekte zu ändern.</li>
	 </ul>
	 
	 <p>Nähere Informationen finden Sie in der Übersicht über die Klasse und in der Erörterung zu <codeph>connectionName</codeph> in <codeph>send()</codeph> sowie in den Einträgen <codeph>allowDomain()</codeph> und <codeph>domain</codeph>.</p>
	 
	 <p><b>Hinweis: </b> Doppelpunkte werden als Sonderzeichen zum Trennen der Superdomäne vom String <codeph>connectionName</codeph> verwendet. Ein String für <codeph>connectionName</codeph>, der einen Doppelpunkt enthält, ist nicht gültig.</p>
	 
	 <p>Wenn Sie diese Methode <ph platform="javascript">für Inhalt in anderen Sicherheitssandboxen als der Sicherheitssandbox der Anwendung</ph> verwenden, ziehen Sie das <ph platform="actionscript">Flash Player</ph><ph platform="javascript">AIR</ph>-Sicherheitsmodell in Betracht. In der Standardeinstellung wird ein LocalConnection-Objekt mit der Sandbox der erstellenden Datei verknüpft. Domänenübergreifende Aufrufe für LocalConnection-Objekte sind nur dann zulässig, wenn Sie in der empfangenden Datei die Methode <codeph>LocalConnection.allowDomain()</codeph> aufrufen. <ph platform="actionscript">Sie können eine Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</ph>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox der <codeph>Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
	 
	 <p>Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
	 
     <ul>
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
     
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:send"><apiName>send</apiName><shortdesc>
	 Ruft die Methode „methodName“ für eine mit der Methode „connect(connectionName)“ geöffnete Verbindung auf (das sogenannte empfangende LocalConnection-Objekt).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.send, send
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>connectionName</codeph> oder <codeph>methodName</codeph> weist den Wert „null“ auf. Übergeben Sie andere Werte als „null“ für diese Parameter.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann folgende Ursachen haben: 1) Der Wert von <codeph>connectionName</codeph> oder <codeph>methodName</codeph> ist ein leerer String. Übergeben Sie gültige Strings für diese Parameter. 2) Für die in <codeph>methodName</codeph> angegebene Methode gelten Beschränkungen. 3) Die gesendete serialisierte Meldung ist zu groß (größer als 40 KB).
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Entspricht dem Verbindungsnamen, der im Befehl <codeph>connect()</codeph> für die Kommunikation mit dem sendenden LocalConnection-Objekt angegeben wurde. 	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>methodName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der im empfangenden LocalConnection-Objekt aufzurufenden Methode. Die folgenden Methodennamen führen zu Fehlern bei der Befehlsausführung: <codeph>send</codeph>, <codeph>connect</codeph>, <codeph>close</codeph>, <codeph>allowDomain</codeph>, <codeph>allowInsecureDomain</codeph>, <codeph>client</codeph> und <codeph>domain</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>An die angegebene Methode zu übergebende zusätzliche optionale Parameter. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ruft die Methode <codeph>methodName</codeph> für eine mit der Methode <codeph>connect(</codeph><codeph>connectionName</codeph><codeph>)</codeph> geöffnete Verbindung auf (das sogenannte empfangende LocalConnection-Objekt). Das mit diesem Befehl verwendete Objekt ist das <i>sendende LocalConnection-Objekt</i>. Die SWF-Dateien, die das sendende und das empfangende Objekt enthalten, müssen auf demselben Client-Computer ausgeführt werden.
	 
	 <p>Die Menge der Daten, die diesem Befehl als Parameter übergeben werden können, ist auf 40 Kilobyte begrenzt. Wenn <codeph>send()</codeph> einen <codeph>ArgumentError</codeph>-Fehler auslöst, die verwendete Syntax hingegen korrekt ist, versuchen Sie, die <codeph>send()</codeph>-Anfragen in mehrere Befehle aufzuteilen, die jeweils weniger als 40 KB Daten enthalten.</p>
	 
	 <p>Wie unter <codeph>connect()</codeph> beschrieben, wird die aktuelle Superdomäne standardmäßig zu <codeph>connectionName</codeph> hinzugefügt. Wenn Sie den Datenaustausch zwischen verschiedenen Domänen implementieren, müssen Sie <codeph>connectionName</codeph> sowohl im sendenden als auch im empfangenden LocalConnection-Objekt so definieren, dass die aktuelle Superdomäne nicht zu <codeph>connectionName</codeph> hinzugefügt wird. Hierzu stehen Ihnen zwei Methoden zur Wahl:</p>
	 
	 <ul>
	   <li>Beginnen Sie <codeph>connectionName</codeph> sowohl für das sendende als auch für das empfangende LocalConnection-Objekt mit einem Unterstrich (_). Geben Sie in der Datei mit dem empfangenden Objekt mit <codeph>LocalConnection.allowDomain()</codeph> an, dass Verbindungen von allen Domänen akzeptiert werden. Mit dieser Implementierung können Sie sendende und empfangende Dateien in jeder Domäne speichern.</li>
	 
	   <li>Schließen Sie die Superdomäne in <codeph>connectionName</codeph> in das sendende LocalConnection-Objekt ein, z. B. <codeph>myDomain.com:myConnectionName</codeph>. Geben Sie im empfangenden Objekt mit <codeph>LocalConnection.allowDomain()</codeph> an, dass Verbindungen von der angegebenen Superdomäne akzeptiert werden (in diesem Fall myDomain.com) oder dass Verbindungen von allen Domänen akzeptiert werden.</li>
	 </ul>
	 
	 <p><b>Hinweis: </b> Sie können in <codeph>connectionName</codeph> im empfangenden LocalConnection-Objekt keine Superdomäne angeben - dies ist nur im sendenden LocalConnection-Objekt möglich.</p>
	 
	 <p>Wenn Sie diese Methode <ph platform="javascript">für Inhalt in anderen Sicherheitssandboxen als der Sicherheitssandbox der Anwendung</ph> verwenden, ziehen Sie das <ph platform="actionscript">Flash Player</ph><ph platform="javascript">AIR</ph>-Sicherheitsmodell in Betracht. In der Standardeinstellung wird ein LocalConnection-Objekt mit der Sandbox der erstellenden Datei verknüpft. Domänenübergreifende Aufrufe für LocalConnection-Objekte sind nur dann zulässig, wenn Sie in der empfangenden Datei die Methode <codeph>LocalConnection.allowDomain()</codeph> aufrufen. Für SWF-Inhalt, der im Browser ausgeführt wird, können Sie eine Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt beinhaltet, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen. In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p> 
	 
	 <p>Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
	 
     <ul>
     
     <li class="flexonly">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li class="flashonly">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
	 
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection:send_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Es wurde mit <codeph>LocalConnection.send()</codeph> versucht, mit einer SWF-Datei in einer Sicherheitssandbox zu kommunizieren, auf die der aufrufende Code keinen Zugriff hat. Sie können dieses Problem in der Implementierung des Empfängers von <codeph>LocalConnection.allowDomain()</codeph> umgehen.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Es wurde mit LocalConnection.send() versucht, mit einer SWF-Datei in einer Sicherheitssandbox zu kommunizieren, auf die der aufrufende Code keinen Zugriff hat.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection:send_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wenn der Wert der <codeph>level</codeph>-Eigenschaft <codeph>"status"</codeph> ist, war der Aufruf erfolgreich. Wenn der Wert <codeph>"error"</codeph> ist, ist der Aufruf fehlgeschlagen. Der Aufruf kann fehlschlagen, wenn die empfangende SWF-Datei die Verbindung nicht zulässt.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Wenn die level-Eigenschaft den Wert „status“ aufweist, war der Aufruf erfolgreich; der Wert „error“ gibt an, dass der Aufruf fehlgeschlagen ist.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:LocalConnection:client:get"><apiName>client</apiName><shortdesc>
	 Gibt das Objekt an, bei dem Callback-Methoden aufgerufen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Die <codeph>client</codeph>-Eigenschaft muss auf ein Objekt eingestellt werden, das nicht null ist. 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gibt das Objekt an, bei dem Callback-Methoden aufgerufen werden. Standardeinstellung ist das erstellte LocalConnection-Objekt <codeph>this</codeph>. Wenn Sie die <codeph>client</codeph>-Eigenschaft auf ein anderes Objekt einstellen, werden die Callback-Methoden bei dem eingestellten Objekt aufgerufen.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:LocalConnection:domain:get"><apiName>domain</apiName><shortdesc>
	 Ein String, der die Domäne des Pfads der aktuellen Datei angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.domain, domain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Ein String, der die Domäne des Pfads der aktuellen Datei angibt. 
	 
	 <p>Bei Inhalt, der in der Sicherheitssandbox <codeph> der Anwendung </codeph> Adobe AIR ausgeführt wird (Inhalt, der mit der AIR-Anwendung installiert wurde), verwendet die Laufzeit den String <codeph>app#</codeph> gefolgt von der Anwendungs-ID für die AIR-Anwendung (definiert in der Anwendungsdeskriptordatei) anstelle der Superdomäne. So wird zum Beispiel ein <codeph>connectionName</codeph> für eine Anwendung mit der Anwendungs-ID <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> in <codeph>"app#com.example.air.MyApp:connectionName"</codeph> aufgelöst.</p>
	 
	 <p>In für Flash Player 9 oder neuere Versionen veröffentlichten SWF-Dateien entspricht der zurückgegebene String der exakten Domäne der Datei, einschließlich Subdomänen. Wenn die Datei beispielsweise unter www.adobe.com gespeichert ist, gibt dieser Befehl <codeph>"www.adobe.com"</codeph> zurück. </p>
	 
	 <p>Wenn die aktuelle Datei eine lokale Datei auf dem Client-Computer ist, die in Flash Player ausgeführt wird, gibt dieser Befehl <codeph>"localhost"</codeph> zurück.</p>
	 
	 <p>Gewöhnlich wird bei dieser Eigenschaft der Domänenname des sendenden LocalConnection-Objekts als Parameter in die Methode einbezogen, die Sie im empfangenden LocalConnection-Objekt oder mit <codeph>LocalConnection.allowDomain()</codeph> aufrufen möchten, um Befehle von einer angegebenen Domäne zu akzeptieren. Wenn Sie den Datenaustausch nur zwischen LocalConnection-Objekten derselben Domäne aktivieren, ist diese Eigenschaft nicht erforderlich.</p>
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiValue><apiValue id="flash.net:LocalConnection:isPerUser:get"><apiName>isPerUser</apiName><shortdesc>  
     Gibt an, ob das LocalConnection-Objekt auf den aktuellen Benutzer beschränkt ist („true“) oder ob es global allen Benutzern des Computers zur Verfügung steht („false“).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
     </apiDefaultValue></apiValueDef><apiDesc>  
     Gibt an, ob das LocalConnection-Objekt auf den aktuellen Benutzer beschränkt ist (<codeph>true</codeph>) oder ob es global allen Benutzern des Computers zur Verfügung steht (<codeph>false</codeph>). Diese Eigenschaft betrifft nur Inhalt, der unter Mac OS X ausgeführt wird; andere Plattformen ignorieren diesen Parameter. Verbindungen unter Windows- und Linux-Betriebssystemen werden immer auf Benutzerbasis hergestellt. In Flash Player 10.0.22 und älteren Versionen sowie in AIR 1.5.1 und älteren Versionen haben alle LocalConnection-Objekte unter Mac OS X einen globalen Gültigkeitsbereich. Stellen Sie diese Eigenschaft immer auf <codeph>true</codeph> ein, falls Sie nicht die Kompatibilität mit älteren Versionen sicherstellen müssen. In zukünftigen Versionen wird der Standardwert dieser Eigenschaft möglicherweise zu <codeph>true</codeph> geändert.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
 
 Die NetStreamInfo-Klasse legt die verschiedenen Quality-of-Service-Statistiken (QOS) fest, die mit einem NetStream-Objekt und dem zugrunde liegenden Streamingpuffer für Audio, Video und Daten in Beziehung stehen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Die NetStreamInfo-Klasse legt die verschiedenen Quality-of-Service-Statistiken (QOS) fest, die mit einem NetStream-Objekt und dem zugrunde liegenden Streamingpuffer für Audio, Video und Daten in Beziehung stehen. Ein NetStreamInfo-Objekt wird als Antwort auf den <codeph>NetStream.info</codeph>-Aufruf zurückgegeben, der einen Schnappschuss des aktuellen QOS-Status erstellt und die QOS-Statistiken über die NetStreamInfo-Eigenschaften bereitstellt.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamInfo:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
    Nur zur internen Verwendung. Vom Gebrauch wird abgeraten.</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>curBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>byteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>maxBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>playbackBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>droppedFrames</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>srtt</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioLossRate</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef><apiDesc>
    Nur zur internen Verwendung. Vom Gebrauch wird abgeraten. Nur die Laufzeit kann NetStreamInfo-Objekte erstellen.
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:NetStreamInfo:toString"><apiName>toString</apiName><shortdesc>
     Gibt einen Textwert zurück, der eine Liste der Eigenschaften des NetStreamInfo-Objekts enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, der die Werte der Eigenschaften des NetStreamInfo-Objekts enthält
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Gibt einen Textwert zurück, der die Eigenschaft dieses NetStreamInfo-Objekts auflistet.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Gibt einen Textwert zurück, der eine Liste der Eigenschaften des NetStreamInfo-Objekts auflistet.
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:NetStreamInfo:SRTT:get"><apiName>SRTT</apiName><shortdesc>
	 Legt die Smooth Round Trip Time für die NetStream-Session fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Legt die Smooth Round Trip Time für die NetStream-Session fest. Dieser Wert gibt nur einen gültigen Wert für RTMFP-Streams zurück und gibt 0 für RTMP-Streams zurück. Weitere Informationen finden Sie in der Dokumentation zum Flash Media Server.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferByteLength:get"><apiName>audioBufferByteLength</apiName><shortdesc>
	 Stellt die NetStream-Audiopuffergröße (in Byte) bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Stellt die NetStream-Audiopuffergröße (in Byte) bereit. Sie gibt die Puffergröße für Audiodaten in Streaming-Medien (sowohl live als auch aufgenommen) an. Diese Eigenschaft ähnelt <codeph>Netstream.bytesLoaded</codeph>, die in progressiven Downloads verwendet wird. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferLength:get"><apiName>audioBufferLength</apiName><shortdesc>
	 Stellt die NetStream-Audiopuffergröße (in Sekunden) bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Stellt die NetStream-Audiopuffergröße (in Sekunden) bereit. Diese Eigenschaft erweitert die <codeph>NetStream.bufferLength</codeph>-Eigenschaft und stellt die Pufferlänge speziell für Audiodaten bereit. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioByteCount:get"><apiName>audioByteCount</apiName><shortdesc>
	 Gibt an, wie viele Byte an Audiodaten insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, wie viele Byte an Audiodaten insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden. Sie können diesen Wert verwenden, um die eingehende Audiodatenrate über eine Metrik Ihrer Wahl zu berechnen, indem Sie einen Timer erstellen und die Unterschiede zwischen den Werten in aufeinanderfolgenden Timeraufrufen berechnen. Alternativ können Sie <codeph>audioBytesPerSecond</codeph> verwenden.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/audioBytesPerSecond"><linktext>audioBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:audioBytesPerSecond:get"><apiName>audioBytesPerSecond</apiName><shortdesc>
	 Legt die Rate in Byte pro Sekunde fest, mit der der NetStream-Audiopuffer gefüllt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Legt die Rate in Byte pro Sekunde fest, mit der der NetStream-Audiopuffer gefüllt wird. Der Wert wird als glatter Durchschnitt für die in der letzten Sekunde empfangenden Audiodaten berechnet.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioLossRate:get"><apiName>audioLossRate</apiName><shortdesc>
	 Legt den Audiodatenverlust für die NetStream-Sitzung fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Legt den Audiodatenverlust für die NetStream-Sitzung fest. Dieser Wert gibt nur einen gültigen Wert für RTMFP-Streams zurück und würde 0 für RTMP-Streams zurückgeben. Die Verlustrate ist als Verhältnis verlorener Nachrichte zur Gesamtzahl der Nachrichten definiert.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:byteCount:get"><apiName>byteCount</apiName><shortdesc>
	 Gibt an, wie viele Byte insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, wie viele Byte insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden. Sie können diesen Wert verwenden, um die eingehende Datenrate über eine Metrik Ihrer Wahl zu berechnen, indem Sie einen Timer erstellen und die Unterschiede zwischen den Werten in aufeinanderfolgenden Timeraufrufen berechnen. Alternativ können Sie <codeph>currentBytesPerSecond</codeph> verwenden.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/currentBytesPerSecond"><linktext>currentBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:currentBytesPerSecond:get"><apiName>currentBytesPerSecond</apiName><shortdesc>
	 Legt die Rate in Byte pro Sekunde fest, mit welcher der NetStream-Puffer gefüllt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Legt die Rate in Byte pro Sekunde fest, mit welcher der NetStream-Puffer gefüllt wird. Der Wert wird als glatter Durchschnitt für die gesamten in der letzten Sekunde empfangenden Daten berechnet.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferByteLength:get"><apiName>dataBufferByteLength</apiName><shortdesc>
	 Stellt die NetStream-Datenpuffergröße (in Byte) bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Stellt die NetStream-Datenpuffergröße (in Byte) bereit. Sie gibt die Puffergröße für Datenmeldungen in Streaming-Medien (sowohl live als auch aufgenommen) an. Diese Eigenschaft ähnelt <codeph>Netstream.bytesLoaded</codeph>, die in progressiven Downloads verwendet wird. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferLength:get"><apiName>dataBufferLength</apiName><shortdesc>
	 Stellt die NetStream-Puffergröße (in Sekunden) bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Stellt die NetStream-Puffergröße (in Sekunden) bereit. Diese Eigenschaft erweitert die <codeph>NetStream.bufferLength</codeph>-Eigenschaft und stellt die Pufferlänge für Datenmeldungen bereit.  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataByteCount:get"><apiName>dataByteCount</apiName><shortdesc>
	 Gibt an, wie viele Byte an Datenmeldungen insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, wie viele Byte an Datenmeldungen insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden. Sie können diesen Wert verwenden, um die eingehende Datenmeldungsrate über eine Metrik Ihrer Wahl zu berechnen, indem Sie einen Timer erstellen und die Unterschiede zwischen den Werten in aufeinanderfolgenden Timeraufrufen berechnen. Alternativ können Sie <codeph>dataBytesPerSecond</codeph> verwenden. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/dataBytesPerSecond"><linktext>dataBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:dataBytesPerSecond:get"><apiName>dataBytesPerSecond</apiName><shortdesc>
	 Legt die Rate in Byte pro Sekunde fest, mit der der NetStream-Datenpuffer gefüllt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Legt die Rate in Byte pro Sekunde fest, mit der der NetStream-Datenpuffer gefüllt wird. Der Wert wird als glatter Durchschnitt für die in der letzten Sekunde empfangenden Datenmeldungen berechnet.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:droppedFrames:get"><apiName>droppedFrames</apiName><shortdesc>
	 Gibt die Anzahl der übersprungenen Videobilder der aktuellen NetStream-Wiedergabesitzung zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Anzahl der übersprungenen Videobilder der aktuellen NetStream-Wiedergabesitzung zurück. 
	 <p>Wenn das Video in einem aufgenommenen Streaming oder einem progressiven Download ein Video mit hoher Qualität, hoher Auflösung oder einer hohen Bitrate ist, kann der Dekoder hinter der erforderlichen Anzahl von Bildern pro Sekunde hinterherhinken, wenn die CPU-Ressourcen des Systems nicht ausreichen. Bei Live-Streams lässt der Puffer Videobilder aus, wenn die Latenz zu hoch ist. Diese Eigenschaft gibt die Anzahl der Bilder an, die ausgelassen und nicht normal präsentiert wurden.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:maxBytesPerSecond:get"><apiName>maxBytesPerSecond</apiName><shortdesc>
	 Legt die maximale Rate in Byte pro Sekunde fest, mit der der NetStream-Puffer gefüllt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Legt die maximale Rate in Byte pro Sekunde fest, mit der der NetStream-Puffer gefüllt wird. Dieser Wert liefert Informationen über die Kapazität des Client-Netzwerks basierend auf den letzten Meldungen, die vom <codeph>NetStream</codeph>-Objekt empfangen wurden. Je nach der in <codeph>NetStream.bufferTime</codeph> angegebenen Größe des Puffers und der auf dem Client verfügbaren Bandbreits füllt Flash Media Server den Puffer in Schüben. Diese Eigenschaft liefert die maximale Rate, mit der der Clientpuffer gefüllt wird.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:playbackBytesPerSecond:get"><apiName>playbackBytesPerSecond</apiName><shortdesc>
	 Gibt die Streamwiedergaberate in Byte pro Sekunde zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Streamwiedergaberate in Byte pro Sekunde zurück. Der Wiedergabepuffer kann Inhalt von verschiedenen Wiedergabelisten enthalten. Diese Eigenschaft liefert die Wiedergaberate, die der Bitrate des momentan wiedergegebenen Streams am ehesten entspricht.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferByteLength:get"><apiName>videoBufferByteLength</apiName><shortdesc>
	 Stellt die NetStream-Videopuffergröße (in Byte) bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Stellt die NetStream-Videopuffergröße (in Byte) bereit. Sie gibt die Puffergröße für Videodaten in Streaming-Medien (sowohl live als auch aufgenommen) an. Diese Eigenschaft ähnelt <codeph>Netstream.bytesLoaded</codeph>, die in progressiven Downloads verwendet wird. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferLength:get"><apiName>videoBufferLength</apiName><shortdesc>
	 Stellt die NetStream-Videopuffergröße (in Sekunden) bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Stellt die NetStream-Videopuffergröße (in Sekunden) bereit. Diese Eigenschaft erweitert die <codeph>NetStream.bufferLength</codeph>-Eigenschaft und liefert die Pufferlänge für Videodaten. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoByteCount:get"><apiName>videoByteCount</apiName><shortdesc>
	 Gibt an, wie viele Byte an Videodaten insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, wie viele Byte an Videodaten insgesamt in der Warteschlange eingetroffen sind, unabhängig davon, wie viele schon abgespielt oder ausgegeben wurden. Sie können diesen Wert verwenden, um die eingehende Videodatenrate über eine Metrik Ihrer Wahl zu berechnen, indem Sie einen Timer erstellen und die Unterschiede zwischen den Werten in aufeinanderfolgenden Timeraufrufen berechnen. Alternativ können Sie <codeph>videoBytesPerSecond</codeph> verwenden. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/videoBytesPerSecond"><linktext>videoBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:videoBytesPerSecond:get"><apiName>videoBytesPerSecond</apiName><shortdesc>
	 Legt die Rate in Byte pro Sekunde fest, mit der der NetStream-Videopuffer gefüllt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Legt die Rate in Byte pro Sekunde fest, mit der der NetStream-Videopuffer gefüllt wird. Der Wert wird als glatter Durchschnitt für die in der letzten Sekunde empfangenden Videodaten berechnet.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLStream"><apiName>URLStream</apiName><shortdesc>
 Die URLStream-Klasse stellt Zugriff auf niedriger Ebene auf URL-Downloads bereit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die URLStream-Klasse stellt Zugriff auf niedriger Ebene auf URL-Downloads bereit. Die Daten werden während des Downloadvorgangs dem Anwendungscode zur Verfügung gestellt, sodass Sie nicht wie bei URLLoader warten müssen, bis der Download der gesamten Datei abgeschlossen ist. Mit der URLStream-Klasse können Sie außerdem einen Stream beenden, bevor der Download abgeschlossen ist. Der Inhalt der heruntergeladenen Datei wird in Form von unformatierten Binärdaten zur Verfügung gestellt.
 
 <p>Die Lesevorgänge in „URLLoader“ sind ungeblockt. Das heißt, dass Sie die Eigenschaft <codeph>bytesAvailable</codeph> verwenden müssen, um zu ermitteln, ob genügend Daten vorhanden sind, bevor Sie den Lesevorgang starten. Wenn nicht genügend Daten vorhanden sind, wird eine <codeph>EOFError</codeph>-Ausnahme ausgelöst.</p>
 
 <p>Alle Binärdaten werden standardmäßig im Big Endian-Format kodiert, wobei das höchstwertige Byte an erster Stelle steht.</p>
 
 <p>Für URL-Downloads mit der URLStream-Klasse gelten dieselben Sicherheitsregeln wie für URLLoader-Objekte. Richtliniendateien können nach Bedarf heruntergeladen werden. Lokale Dateisicherheitsregeln werden erzwungen, und ggf. werden Sicherheitswarnungen ausgegeben.</p>

 
 </apiDesc><example conref="examples\URLStreamExample.as"> Im folgenden Beispiel wird eine SWF-Datei geladen, und der Beginn des Headers wird analysiert, um Informationen zu Komprimierung und Versionsnummer anzugeben. 
 <p>Legen Sie zur Ausführung des Beispiels eine Datei mit dem Namen „URLStreamExample.swf“ in dem Verzeichnis ab, in dem sich die SWF-Datei befindet.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.*;
    import flash.events.*;
    import flash.net.URLRequest;
    import flash.net.URLStream;

    public class URLStreamExample extends Sprite {
        private static const ZLIB_CODE:String = "CWS";
        private var stream:URLStream;

        public function URLStreamExample() {
            stream = new URLStream();
            var request:URLRequest = new URLRequest("URLStreamExample.swf");
            configureListeners(stream);
            try {
                stream.load(request);
            } catch (error:Error) {
                trace("Unable to load requested URL.");
            }
        }

        private function configureListeners(dispatcher:EventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function parseHeader():void {
            trace("parseHeader");
            trace("isCompressed: " + isCompressed());
            trace("version: " + stream.readByte());
        }

        private function isCompressed():Boolean {
            return (stream.readUTFBytes(3) == ZLIB_CODE);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
            parseHeader();
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:Event):void {
            trace("progressHandler: " + event);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><adobeApiEvent id="flash.net:URLStream_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn während des Download-Vorgangs Daten empfangen werden. Empfangene Daten können mit den Methoden der URLStream-Klasse sofort gelesen werden.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Wird beim Start eines Ladevorgangs ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Start eines Ladevorgangs ausgelöst.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den der Ladevorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den der Ladevorgang fehlschlägt. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 Wird ausgelöst, wenn ein Aufruf der URLStream.load()-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Aufruf der <codeph>URLStream.load()</codeph>-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann. 
 
 <p>Wenn ein URLStream-Objekt für ein <codeph>httpStatusEvent</codeph>-Eigenschaft registriert wird, werden Fehlerantworten zugestellt, als ob es sich um Inhalt handelt. Anstatt ein <codeph>ioError</codeph>-Ereignis auszulösen, löst der URLStream <codeph>progress</codeph>- und <codeph>complete</codeph>-Ereignisse aus, während die Fehlerdaten in den URLStream geladen werden.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Wird ausgelöst, wenn ein URLStream.load() versucht, auf Daten über HTTP zuzugreifen, und Flash Player oder Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein <codeph>URLStream.load()</codeph> versucht, auf Daten über HTTP zuzugreifen, und <ph platform="actionscript">Flash Player oder </ph>Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann. (Diese Informationen können in einigen Browser-Umgebungen möglicherweise nicht bereitgestellt werden.) Beachten Sie, dass das Ereignis <codeph>httpStatus</codeph> (falls vorhanden) vor (und zusätzlich zu) jedem <codeph>complete</codeph>- oder <codeph>error</codeph>-Ereignis gesendet wird.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Wird ausgelöst, wenn ein URLStream.load()-Aufruf versucht, Daten von einem Server außerhalb der Sicherheitssandbox zu laden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein <codeph>URLStream.load()</codeph>-Aufruf versucht, Daten von einem Server außerhalb der Sicherheitssandbox zu laden.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Wird nach dem erfolgreichen Laden von Daten ausgelöst.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird nach dem erfolgreichen Laden von Daten ausgelöst. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:URLStream:close"><apiName>close</apiName><shortdesc>
     Schließt den Stream unmittelbar und bricht den Download-Vorgang ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der Stream konnte nicht geschlossen werden, oder der Stream war nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Schließt den Stream unmittelbar und bricht den Download-Vorgang ab. Nach dem Aufrufen der <codeph>close()</codeph>-Methode können aus dem Stream keine Daten gelesen werden.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:load"><apiName>load</apiName><shortdesc>
     Startet den Download der im Parameter „request“ angegebenen URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Bestimmte nicht zulässige HTTP-Anforderungsheader sind möglicherweise in <codeph>URLRequest.requestHeader</codeph>-Objekten nicht enthalten. Weitere Informationen finden Sie in der Beschreibung der URLRequestHeader-Klasse.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Dieser Fehler kann folgende Ursachen haben:
     
     <ol>
     
     <li>Flash Player oder Adobe AIR kann den Parameter <codeph>URLRequest.data</codeph> nicht von UTF8 in MBCS konvertieren. Dieser Fehler trifft zu, wenn das an <codeph>load()</codeph> übergebene URLRequest-Objekt auf die Ausführung eines <codeph>GET</codeph>-Vorgangs eingestellt ist und wenn <codeph>System.useCodePage</codeph> auf <codeph>true</codeph> gesetzt ist.</li>
     
     <li>Flash Player oder Adobe AIR kann·<codeph>POST</codeph> keinen Speicher zuweisen. Dieser Fehler trifft zu, wenn das an „load“ übergebene URLRequest-Objekt auf die Ausführung eines <codeph>POST</codeph>-Vorgangs eingestellt ist.</li></ol>
     
     </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Über lokale nicht vertrauenswürdige SWF-Dateien kann keine Verbindung mit dem Internet hergestellt werden. Sie können dieses Problem umgehen, indem Sie diese SWF-Datei neu als lokal mit Netzwerk oder als vertrauenswürdig klassifizieren.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Ein URLRequest-Objekt, das die herunterzuladende URL angibt. Wenn der Wert dieses Parameters oder der Eigenschaft <codeph>URLRequest.url</codeph> des übergebenen URLRequest-Objekts <codeph>null</codeph> ist, gibt die Anwendung einen Nullzeiger-Fehler aus.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Startet den Download der im Parameter <codeph>request</codeph> angegebenen URL.
     
     <p><b>Hinweis</b>: Enthält eine geladene Datei Nicht-ASCII-Zeichen (wie sie z. B. in vielen Sprachen außerhalb des englischen Sprachraums vorkommen), wird empfohlen, dass Sie die Datei im Format UTF-8 oder UTF-16 und nicht in einem Unicode-fremden Format (z. B. ASCII) speichern.</p>
     
     <p>Wenn der Ladevorgang unmittelbar fehlschlägt, wird eine IOError- oder eine SecurityError-Ausnahme (mit dem lokalen Dateisicherheitsfehler) mit der Beschreibung des Fehlers ausgegeben. Andernfalls wird ein <codeph>open</codeph>-Ereignis ausgelöst, wenn der URL-Download erfolgreich gestartet wird, bzw. ein Fehlerereignis, wenn ein Fehler auftritt.</p>
     
     <p>Standardmäßig müssen die aufrufende SWF-Datei und die von Ihnen geladene URL in genau der gleichen Domäne sein. Eine SWF-Datei unter www.adobe.com kann beispielsweise nur Daten laden, die sich ebenfalls unter www.adobe.com befinden. Legen Sie eine URL-Richtliniendatei auf dem Server ab, der die Daten hostet, um Daten aus einer anderen Domäne zu laden.</p>
     
      <p platform="actionscript">In Flash Player können Sie keine Verbindung mit normalerweisen reservierten Ports herstellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
     
     <p platform="actionscript">In Flash Player können Sie eine SWF-Datei daran hindern, diese Methode zu verwenden, indem Sie den <codeph>allowNetworking</codeph>-Parameter des <codeph>object</codeph>- und <codeph>embed</codeph>-Tags auf der HTML-Seite setzen, die den SWF-Inhalt enthält.</p>
     
     <p platform="actionscript"> Wenn Sie in Flash Player 10 und höher und in AIR 1.5 und höher einen Multipart-Content-Type (z. B. „multipart/form-data“) verwenden, der ein Upload enthält (angegeben durch einen „filename“-Parameter in einem „content-disposition“-Header innerhalb des POST-Body), unterliegt die POST-Methode den auf Uploads angewendeten Sicherheitsregeln:</p>
	 <ul platform="actionscript">
	 <li>Die POST-Methode muss als Reaktion auf eine durch den Benutzer initiierte Aktion, z. B. einen Mausklick oder Tastenbetätigung, erfolgen.</li>
	 <li>Ist die POST-Methode domänenübergreifend (das POST-Ziel befindet sich auf einem anderen Server als die SWF-Datei, die die POST-Anforderung sendet), so muss der Zielserver eine URL-Richtliniendatei bereitstellen, die den domänenübergreifenden Zugriff erlaubt.</li>
	 </ul>
     <p platform="actionscript">Für alle mehrteiligen Content-Typen muss ebenfalls die Syntax nach Standard RFC2046 gültig sein. Scheint die Syntax ungültig zu sein, so unterliegt die POST-Methode den Sicherheitsregeln für Uploads.</p>
     
     <p platform="actionscript">Diese Regeln gelten auch für AIR-Inhalt in anwendungsfremden Sandboxen. In Adobe AIR dagegen ist Inhalt in der Anwendungssandbox (mit der AIR-Anwendung installierter Inhalt) nicht durch diese Sicherheitseinschränkungen beschränkt.</p>
     
     <p platform="actionscript">Weitere Informationen zur Sicherheit finden Sie in den folgenden Abschnitten:</p>
     <ul platform="actionscript">
     
     <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neusten Kommentare zu den LiveDocs.</li>
     
     <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     
     <li>Der Abschnitt „Understanding AIR Security“ des Kapitels „Getting started with Adobe AIR“ im Handbuch <i>Developing AIR Applications</i>.</li>
     
     </ul>
     
     <p>In AIR kann sich ein URLRequest-Objekt für das <codeph>httpResponse</codeph>-Statusereignis registrieren. Anders als das <codeph>httpStatus</codeph>-Ereignis wird das <codeph>httpResponseStatus</codeph>-Ereignis ausgelöst, bevor Antwortdaten vorliegen. Außerdem enthält das <codeph>httpResponseStatus</codeph>-Ereignis Werte für die Eigenschaften <codeph>responseHeaders</codeph> und <codeph>responseURL</codeph> (die für ein <codeph>httpStatus</codeph>-Ereignis nicht definiert sind). Beachten Sie, dass das Ereignis <codeph>httpResponseStatus</codeph> (falls vorhanden) vor (und zusätzlich zu) jedem <codeph>complete</codeph>- oder <codeph>error</codeph>-Ereignis gesendet wird. 
     </p>
     
     
     <p>Wenn es <i>einen</i> <codeph>httpResponseStatus</codeph> Ereignis-Listener gibt, wird der Rumpf der Antwortmeldung <i>immer</i> gesendet, und HTTP-Statuscodeantworten resultierten immer in einem <codeph>complete</codeph>-Ereignis. Dies ist unabhängig davon wahr, ob der HTTP-Antwortstatuscode einen Erfolg oder einen Fehler anzeigt.</p> 
     
     <p><ph platform="actionscript">Wenn es in AIR</ph><ph platform="javascript">Wenn es</ph> <i>keine</i> <codeph>httpResponseStatus</codeph>-Ereignis-Listener gibt, ist das Verhalten basierend auf der <ph platform="actionscript">SWF</ph><ph platform="javascript">AIR</ph>-Version unterschiedlich:</p>
     
     <ul>
     
         <li><ph platform="actionscript">Für SWF 9-Inhalt</ph><ph platform="javascript">In einer AIR-Datei, in der der Anwendungsdeskriptor AIR 1.0 oder 1.1 als Laufzeitversion angibt</ph>, wird der Rumpf der HTTP-Antwortmeldung <i>nur gesendet, wenn</i> der HTTP-Antwortstatuscode „Erfolg“ angibt. Andernfalls (wenn ein Fehler vorliegt) wird kein Rumpf gesendet und das URLRequest-Objekt löst ein IOError-Ereignis aus.</li>
     
         <li><ph platform="actionscript">Für SWF 10-Inhalt</ph><ph platform="javascript">In einer AIR-Datei, in der der Anwendungsdeskriptor AIR 1.5 als Laufzeitversion angibt</ph>, wird der Rumpf der HTTP-Antwortmeldung <i>immer</i> gesendet. Wenn ein Fehler vorliegt, löst das URLRequest-Objekt ein IOError-Ereignis aus.</li>
     
     </ul>
     
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:URLStream:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird nach dem erfolgreichen Laden von Daten ausgelöst. Wenn es einen <codeph>httpResponseStatus</codeph>-Ereignis-Listener gibt, löst das URLRequest-Objekt auch ein <codeph>complete</codeph>-Ereignis aus, unabhängig davon, ob der HTTP-Antwortstatuscode einen Erfolg <i>oder</i> einen Fehler angibt.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Wird nach dem erfolgreichen Laden von Daten ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wenn der Zugriff über HTTP <ph platform="actionscript">erfolgt und die aktuelle Umgebung den Empfang von Statuscodes</ph> unterstützt, werden diese Ereignisse möglicherweise zusätzlich zu allen <codeph>complete</codeph>- oder <codeph>error</codeph>-Ereignissen empfangen.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Wenn der Zugriff über HTTP erfolgt und die aktuelle Umgebung den Empfang von Statuscodes unterstützt, werden diese Ereignisse möglicherweise zusätzlich zu allen complete- oder error-Ereignissen empfangen.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn ein Aufruf der <codeph>load()</codeph>-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann. 
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn ein Aufruf der load()-Methode versucht, über HTTP auf Daten zuzugreifen und Adobe AIR den Statuscode für die Anforderung erkennen und zurückgeben kann.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Der Ladevorgang konnte nicht abgeschlossen werden.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Der Ladevorgang konnte nicht abgeschlossen werden.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird beim Start eines Ladevorgangs ausgelöst.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Wird beim Start eines Ladevorgangs ausgelöst.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Bei einem Ladevorgang wurde versucht, Daten von einem Server außerhalb der Sicherheitssandbox der aufrufenden Funktion abzurufen. Sie können dies umgehen, indem Sie eine Richtliniendatei auf dem Server verwenden.
     </apiDesc></adobeApiEventDetail><shortdesc>Bei einem Ladevorgang wurde versucht, Daten von einem Server außerhalb der Sicherheitssandbox der aufrufenden Funktion abzurufen.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:URLStream:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     Liest einen booleschen Wert aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>True</codeph> wird zurückgegeben, wenn der Bytewert nicht null ist, andernfalls <codeph>false</codeph>.
     
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest einen booleschen Wert aus dem Stream. Es wird ein einzelnes Byte gelesen und <codeph>true</codeph> zurückgegeben, wenn das Byte ungleich 0 ist, oder andernfalls <codeph>false</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readByte"><apiName>readByte</apiName><shortdesc>
     Liest ein Byte mit Vorzeichen aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Wert im Bereich -128...127.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest ein Byte mit Vorzeichen aus dem Stream.
     <p>Der Rückgabewert liegt im Bereich von -128 bis 127.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readBytes"><apiName>readBytes</apiName><shortdesc>
     Liest „length“-Byte Daten aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Das ByteArray-Objekt, in das die Daten gelesen werden.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Der Offset innerhalb des mit <codeph>bytes</codeph> angegebenen Bereichs, ab dem das Lesen der Daten beginnt. Standardeinstellung ist 0.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Die Anzahl der zu lesenden Byte. Der Standardwert 0 bewirkt, dass alle verfügbaren Daten gelesen werden.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Liest <codeph>length</codeph> Byte Daten aus dem Stream. Die Bytedaten werden ab der im Parameter <codeph>offset</codeph> festgelegten Position in das im Parameter <codeph>bytes</codeph> angegebene ByteArray-Objekt gelesen.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readDouble"><apiName>readDouble</apiName><shortdesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit aus dem Stream.
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit doppelter Genauigkeit aus dem Stream.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readFloat"><apiName>readFloat</apiName><shortdesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit aus dem Stream.
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine Gleitkommazahl nach IEEE 754 mit einfacher Genauigkeit aus dem Stream.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readInt"><apiName>readInt</apiName><shortdesc>
     Liest eine 32-Bit-Ganzzahl mit Vorzeichen aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Wert im Bereich -2147483648...2147483647.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 32-Bit-Ganzzahl mit Vorzeichen aus dem Stream.
     <p>Der Rückgabewert liegt im Bereich von -2147483648 bis 2147483647.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     Liest einen Multibyte-String der angegebenen Länge unter Verwendung des angegebenen Zeichensatzes vom Bytedatenstream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLStream, URLStream.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein UTF-8-kodierter String.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Die Anzahl der aus dem Bytestream zu lesenden Byte.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, der den zum Interpretieren der Byte zu verwendenden Zeichensatz angibt. Mögliche Zeichensatz-Strings sind u. a. <codeph>"shift_jis"</codeph>, <codeph>"CN-GB"</codeph> und <codeph>"iso-8859-1"</codeph>. Eine vollständige Liste finden Sie unter <xref href="../../charset-codes.html">Unterstützte Zeichensätze</xref>.    
	 
     <p><b>Hinweis:</b> Wird der Wert des <codeph>charSet</codeph>-Parameters vom aktuellen System nicht erkannt, verwendet die Anwendung die Standard-Codepage des Systems als Zeichensatz. Beispielsweise könnte ein Wert des Parameters <codeph>charSet</codeph> wie bei <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph>, wo <codeph>01</codeph> anstelle von <codeph>1</codeph> eingesetzt wird, auf Ihrem Entwicklungsrechner funktionieren, aber auf keinem anderen Rechner. Auf anderen Rechnern greift die Anwendung auf die Standard-Codepage des Systems zurück.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Liest einen Multibyte-String der angegebenen Länge unter Verwendung des angegebenen Zeichensatzes vom Bytedatenstream.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readObject"><apiName>readObject</apiName><shortdesc>
     Liest ein im Action Message Format (AMF) kodiertes Objekt vom Socketserver.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das deserialisierte Objekt.
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     Liest ein im Action Message Format (AMF) kodiertes Objekt vom Socketserver.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiOperation><apiOperation id="flash.net:URLStream:readShort"><apiName>readShort</apiName><shortdesc>
     Liest eine 16-Bit-Ganzzahl mit Vorzeichen aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Wert im Bereich -32768...32767.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 16-Bit-Ganzzahl mit Vorzeichen aus dem Stream.
     <p>Der Rückgabewert liegt im Bereich von -32768 bis 32767.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTF"><apiName>readUTF</apiName><shortdesc>
     Liest einen UTF-8-String aus dem Bytestream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein UTF-8-String.
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest einen UTF-8-String aus dem Bytestream. Es wird davon ausgegangen, dass dem String eine short-Ganzzahl ohne Vorzeichen mit der Länge in Byte vorangestellt ist.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     Liest eine Folge von length-UTF-8-Byte aus dem Bytestream und gibt einen String zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein durch die Bytedarstellung von Zeichen erstellter UTF-8-String der angegebenen Länge.
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Eine Abfolge von UTF-8-Byte.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Liest eine Folge von <codeph>length</codeph>-UTF-8-Byte aus dem Bytestream und gibt einen String zurück.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     Liest ein Byte ohne Vorzeichen aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>

     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Wert im Bereich 0...255.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest ein Byte ohne Vorzeichen aus dem Stream.
     <p>Der Rückgabewert liegt im Bereich von 0 bis 255. </p>     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     Liest eine 32-Bit-Ganzzahl ohne Vorzeichen aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Wert im Bereich 0...4294967295.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 32-Bit-Ganzzahl ohne Vorzeichen aus dem Stream.
     <p>Der Rückgabewert liegt im Bereich von 0 bis 4294967295. </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     Liest eine 16-Bit-Ganzzahl ohne Vorzeichen aus dem Stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Es sind nicht genügend zu lesende Daten vorhanden. Wenn eine lokale SWF-Datei eine Sicherheitswarnung auslöst, lässt Flash Player nicht zu, dass die URLStream-Daten für ActionScript verfügbar sind. In diesem Fall gibt die Eigenschaft <codeph>bytesAvailable</codeph> auch dann 0 zurück, wenn Daten empfangen wurden, und eine der Lesemethoden löst eine EOFError-Ausnahme aus.</ph> <ph platform="javascript">Dieser Fehler gilt für SWF-Inhalt; er tritt nicht in JavaScript-Code auf, der in AIR ausgeführt wird.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Ein I/O-Fehler ist im Stream aufgetreten, oder der Stream ist nicht geöffnet.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Wert im Bereich 0...65535.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Liest eine 16-Bit-Ganzzahl ohne Vorzeichen aus dem Stream.
     <p>Der Rückgabewert liegt im Bereich von 0 bis 65535. </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLStream:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     Gibt für die zum Lesen verfügbaren Daten im Eingabepuffer die Anzahl der Byte an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Gibt für die zum Lesen verfügbaren Daten im Eingabepuffer die Anzahl der Byte an. Ihr Code muss die Eigenschaft <codeph>bytesAvailable</codeph> aufrufen, um sicherzustellen, dass genügend Daten verfügbar sind, bevor Sie diese mit einer der <codeph>read</codeph>-Methoden lesen.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:connected:get"><apiName>connected</apiName><shortdesc>
     Gibt an, ob dieses URLStream-Objekt zurzeit verbunden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, ob dieses URLStream-Objekt zurzeit verbunden ist. Beim Aufruf dieser Eigenschaft wird der Wert <codeph>true</codeph> zurückgegeben, wenn das URLStream-Objekt verbunden ist, oder andernfalls <codeph>false</codeph>.     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:endian:get"><apiName>endian</apiName><shortdesc>
     Gibt die Byte-Reihenfolge der Daten an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     Gibt die Byte-Reihenfolge der Daten an. Mögliche Werte sind <codeph>Endian.BIG_ENDIAN</codeph> oder <codeph>Endian.LITTLE_ENDIAN</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:URLStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Steuert die beim Schreiben oder Lesen eines Objekts verwendete Version von Action Message Format (AMF).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Steuert die beim Schreiben oder Lesen eines Objekts verwendete Version von Action Message Format (AMF).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLStream/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding-Klasse</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObject"><apiName>SharedObject</apiName><shortdesc>
 Die SharedObject-Klasse dient zum Lesen und Speichern begrenzter Datenmengen auf dem Computer eines Benutzers oder auf einem Server.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, shared object, constructor
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die SharedObject-Klasse dient zum Lesen und Speichern begrenzter Datenmengen auf dem Computer eines Benutzers oder auf einem Server. Gemeinsame Objekte ermöglichen den Datenaustausch in Echtzeit zwischen mehreren Client-SWF-Dateien und Objekten auf dem lokalen Computer oder einem Remote-Server. Lokale gemeinsame Objekte sind mit Browser-Cookies und gemeinsame Remote-Objekte mit Echtzeit-Datenübertragungsgeräten vergleichbar. Um gemeinsame Remote-Objekte zu verwenden, benötigen Sie Adobe Flash Media Server.
 
 <p>Gemeinsame Objekte können Sie für Folgendes verwenden:</p>
 
 <ul>
 
 <li><b>Lokal permanente Speicherung</b>. Dies ist die einfachste Möglichkeit zur Verwendung eines gemeinsamen Objekts, für die Flash Media Server nicht erforderlich ist. Beispielsweise können Sie <codeph>SharedObject.getLocal()</codeph> aufrufen, um ein gemeinsames Objekt in einer Anwendung wie z. B. einen Rechner mit Speicher zu erstellen. Wenn der Benutzer den Rechner schließt, speichert Flash Player den letzten Wert in einem gemeinsamen Objekt auf dem Computer des Benutzers. Daraufhin wird der Rechner bei der nächsten Verwendung mit dem zuletzt verwendeten Wert geöffnet. Wenn Sie die Eigenschaften des gemeinsamen Objekts vor dem Schließen des Rechners auf <codeph>null</codeph> setzen, wird die Anwendung beim nächsten Start ohne Werte geöffnet. Ein anderes Beispiel für die lokal permanente Speicherung ist die Erfassung von Benutzereinstellungen oder anderen Daten für eine komplexe Website, z. B. ein Verzeichnis der Artikel, die ein Benutzer auf einer Nachrichten-Site liest. Durch die Verfolgung dieser Informationen können bereits gelesene Artikel in anderer Form angezeigt werden als neue, ungelesene Artikel. Durch die Speicherung dieser Angaben auf dem Computer des Benutzers kann die Serverlast reduziert werden.</li>
 
 <li><b>Speichern und Freigeben von Daten auf Flash Media Server</b>. Ein gemeinsames Objekt kann Daten auf dem Server speichern, die dann von anderen Clients abgerufen werden können. Rufen Sie zum Beispiel <codeph>SharedObject.getRemote()</codeph> auf, um ein gemeinsames Remote-Objekt zu erstellen, etwa eine Liste mit Telefonnummer, die auf dem Server permanent gespeichert wird. Wenn ein Client Änderungen am gemeinsamen Objekt vornimmt, stehen die geänderten Daten allen Clients zur Verfügung, die zurzeit mit dem Objekt verbunden sind oder die später eine Verbindung dazu herstellen. Wenn das Objekt auch lokal gespeichert wird und ein Client Änderungen vornimmt, während er nicht mit dem Server verbunden ist, werden die Daten in das gemeinsame Remote-Objekt kopiert, wenn der Client das nächste Mal eine Verbindung mit dem Objekt herstellt.</li>
 
 <li><b>Datenaustausch in Echtzeit</b>: Gemeinsame Objekte ermöglichen den Datenaustausch zwischen mehreren Clients in Echtzeit. Beispiel: Sie können ein gemeinsames Remote-Objekt öffnen, in dem eine Liste der mit einem Chatraum verbundenen Benutzer gespeichert ist. Diese Liste kann von allen Clients angezeigt werden, die mit dem Objekt verbunden sind. Wenn ein neuer Benutzer eine Verbindung herstellt oder ein Benutzer den Chatraum verlässt, wird das Objekt aktualisiert, und die aktualisierte Liste der Chatraum-Benutzer wird auf allen mit dem Objekt verbundenen Clients angezeigt.</li>
 
 </ul>
 
 <p> Um ein gemeinsames lokales Objekt zu erstellen, rufen Sie <codeph>SharedObject.getLocal()</codeph> auf. Um ein gemeinsames Remote-Objekt zu erstellen, rufen Sie <codeph>SharedObject.getRemote()</codeph> auf.</p> 
 
 <p> Wenn eine Anwendung geschlossen wird, werden gemeinsame Objekte an eine Festplatte <i>ausgegeben</i> (flush) oder geschrieben. Sie können auch die <codeph>flush()</codeph>-Methode aufrufen, um die Daten ausdrücklich auf eine Festplatte zu schreiben.</p>
 
 <p><b>Lokaler Speicherplatz.</b> Lokale gemeinsame Objekte bringen einige Beschränkungen mit sich, die beim Entwurf einer Anwendung unbedingt zu berücksichtigen sind. Es kann vorkommen, dass die SWF-Dateien nicht zum Schreiben lokaler gemeinsamer Objekte berechtigt sind oder die in lokalen gemeinsamen Objekten gespeicherten Daten ohne Ihr Wissen gelöscht werden. Flash Player-Benutzer haben die Möglichkeit, den Speicherplatz, der einzelnen oder allen Domänen zur Verfügung steht, selbst zu verwalten. Wenn die Benutzer den bereitgestellten Speicherplatz verringern, könnten einige lokale gemeinsame Objekte gelöscht werden. Außerdem stehen Flash Player-Benutzern Sicherheitseinstellungen zur Verfügung, mit denen sie verhindern können, dass Domänen von Dritten (andere Domänen als die in der aktuellen Browser-Adressleiste angezeigte) lokale gemeinsame Objekte lesen oder schreiben.</p>
 
 <p><b>Hinweis</b>: SWF-Dateien, die auf einem lokalen Computer gespeichert sind und ausgeführt werden, können gemeinsame Objekte von Dritten stets auf Festplatte schreiben. Nähere Informationen zu gemeinsamen Objekten von Dritten finden Sie in der Flash Player-Hilfe unter <xref href="http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager03.html" scope="external">Global Speichereinstellungen</xref>.</p>
 
 <p>Es wird empfohlen, Prüfungen auf Probleme im Zusammenhang mit dem Speicherplatz und den Benutzer-Sicherheitseinstellungen durchzuführen. Nehmen Sie diese Prüfungen vor, wenn Sie <codeph>getLocal()</codeph> und <codeph>flush()</codeph> aufrufen:
 
 <ul>
 <li><codeph>SharedObject.getLocal()</codeph>: Flash Player gibt eine Ausnahme aus, wenn der Aufruf dieser Methode fehlschlägt, z. B. wenn der Benutzer gemeinsame Objekte von Dritten deaktiviert hat und die Domäne Ihrer SWF-Datei nicht mit der Domäne in der Browser-Adressleiste übereinstimmt.</li>
 
 <li><codeph>SharedObject.flush()</codeph>: Flash Player gibt eine Ausnahme aus, wenn der Aufruf dieser Methode fehlschlägt. Wenn der Aufruf erfolgreich ist, wird <codeph>SharedObjectFlushStatus.FLUSHED</codeph> zurückgegeben. Wenn zusätzlicher Speicher erforderlich ist, wird <codeph>SharedObjectFlushStatus.PENDING</codeph> zurückgegeben. Flash Player fordert den Benutzer auf, zusätzlichen Speicherplatz für lokal gespeicherte Informationen zu genehmigen. Dann wird das Ereignis <codeph>netStatus</codeph> mit einem Informationsobjekt ausgelöst, das angibt, ob die Datenausgabe erfolgreich war oder fehlgeschlagen ist.</li>
 </ul></p>
 
 <p>Wenn die SWF-Datei versucht, lokale gemeinsame Objekte zu erstellen oder zu bearbeiten, muss sie mindestens 215 Pixel breit und 138 Pixel hoch sein. Dies sind die Mindestmaße für die Anzeige des Dialogfelds, mit dem der Benutzer aufgefordert wird, den maximalen Speicherplatz für lokale gemeinsame Objekte zu erhöhen. Wenn Ihre SWF-Datei kleiner ist und zusätzlicher Speicherplatz benötigt wird, schlägt <codeph>SharedObject.flush()</codeph> fehl, gibt <codeph>SharedObjectFlushedStatus.PENDING</codeph> zurück und löst das Ereignis <codeph>netStatus</codeph> aus.</p>
 
 <p>
 <b>Gemeinsame Remote-Objekte:</b> Mit Flash Media Server können Sie gemeinsame Remote-Objekte erstellen und verwenden, die in Echtzeit von allen Clients, die mit Ihrer Anwendung verbunden sind, verwendet werden können. Wenn ein Client eine Eigenschaft eines gemeinsamen Remote-Objekts ändert, wird die Eigenschaft für alle verbundenen Clients geändert. Sie können gemeinsame Remote-Objekte verwenden, um Clients zu synchronisieren, zum Beispiel in einem Spiel mit mehreren Spielern.
 </p>
 
 <p>
 Jedes gemeinsame Remote-Objekt verfügt über eine <codeph>data</codeph>-Eigenschaft, bei der es sich um ein Objekt mit Eigenschaften handelt, das Daten speichert. Rufen Sie <codeph>setProperty()</codeph> auf, um eine Eigenschaft des Data-Objekts zu ändern. Der Server aktualisiert die Eigenschaften, löst ein <codeph>sync</codeph>-Ereignis aus und sendet die Eigenschaften zurück an die verbundenen Clients. 
 </p>
 
 <p>
 Sie können gemeinsame Remote-Objekte auf dem Client, auf dem Server oder auf beiden speichern. Standardmäßig speichert Flash Player gemeinsame Remote-Objekte einer Größe von bis zu 100K lokal. Wenn Sie versuchen, ein größeres Objekt zu speichern, zeigt Flash Player das Dialogfeld für den lokalen Speicher an, in dem der Benutzer die lokale Speicherung des gemeinsamen Objekts zulassen oder ablehnen kann. Achten Sie darauf, dass die Bühnengröße mindestens 215 mal 138 Pixel beträgt. Dies ist die Mindestgröße, die Flash für die Anzeige des Dialogfelds benötigt.
 </p>
 <p>
 Wählt der Benutzer „Zulassen“, speichert der Server das gemeinsame Objekt und löst ein <codeph>netStatus</codeph>-Ereignis mit einer <codeph>code</codeph>-Eigenschaft von <codeph>SharedObject.Flush.Success</codeph> aus. Wählt der Benutzer „Verweigern“, speichert der Server das gemeinsame Objekt nicht und löst ein <codeph>netStatus</codeph>-Ereignis mit einer <codeph>code</codeph>-Eigenschaft von <codeph>SharedObject.Flush.Failed</codeph> aus.
 </p>
 
 </apiDesc><example conref="examples\SharedObjectExample.as"> Mit dem folgenden Code wird ein SharedObject-Objekt mit der ID <codeph>"application-name"</codeph> erstellt (und in anschließenden Durchläufen abgerufen). Wenn der Benutzer auf die Schaltfläche „Speichern“ klickt, versucht die Methode <codeph>saveValue()</codeph>, eine Eigenschaft mit dem Namen <codeph>savedValue</codeph> in der <codeph>data</codeph>-Eigenschaft des SharedObject-Objekts zu speichern. Wenn Flash Player eine Genehmigung zur Speicherung der Daten anfragen muss, wird bei Gewährung bzw. Ablehnung der Genehmigung die Methode <codeph>onFlushStatus()</codeph> aufgerufen. Wenn der Benutzer auf die Schaltfläche „Löschen“ klickt, wird der in <codeph>savedValue</codeph> gespeicherte Wert über die Methode <codeph>clearValue()</codeph> gelöscht. Beim nächsten Laden der SWF-Datei lautet der abgerufene Wert <codeph>undefined</codeph>.
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.events.NetStatusEvent;
    import flash.net.SharedObject;
    import flash.net.SharedObjectFlushStatus;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFieldType;
    
    public class SharedObjectExample extends Sprite {
        
        private var mySo:SharedObject;
        
        public function SharedObjectExample() {
            buildUI();
            saveBtn.addEventListener(MouseEvent.CLICK, saveValue);
            clearBtn.addEventListener(MouseEvent.CLICK, clearValue);
            
            mySo = SharedObject.getLocal("application-name");
            output.appendText("SharedObject loaded...\n");
            output.appendText("loaded value: " + mySo.data.savedValue + "\n\n");
        }

         private function saveValue(event:MouseEvent):void {
            output.appendText("saving value...\n");
            mySo.data.savedValue = input.text;
            
            var flushStatus:String = null;
            try {
                flushStatus = mySo.flush(10000);
            } catch (error:Error) {
                output.appendText("Error...Could not write SharedObject to disk\n");
            }
            if (flushStatus != null) {
                switch (flushStatus) {
                    case SharedObjectFlushStatus.PENDING:
                        output.appendText("Requesting permission to save object...\n");
                        mySo.addEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
                        break;
                    case SharedObjectFlushStatus.FLUSHED:
                        output.appendText("Value flushed to disk.\n");
                        break;
                }
            }
            output.appendText("\n");
        }
        
        private function clearValue(event:MouseEvent):void {
            output.appendText("Cleared saved value...Reload SWF and the value should be \"undefined\".\n\n");
            delete mySo.data.savedValue;
        }
        
        private function onFlushStatus(event:NetStatusEvent):void {
            output.appendText("User closed permission dialog...\n");
            switch (event.info.code) {
                case "SharedObject.Flush.Success":
                    output.appendText("User granted permission -- value saved.\n");
                    break;
                case "SharedObject.Flush.Failed":
                    output.appendText("User denied permission -- value not saved.\n");
                    break;
            }
            output.appendText("\n");

            mySo.removeEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
        }
        
        // UI elements
        private var inputLbl:TextField;
        private var input:TextField;
        private var output:TextField;
        private var saveBtn:Sprite;
        private var clearBtn:Sprite;
    
        private function buildUI():void {
            // input label
            inputLbl = new TextField();
            addChild(inputLbl);
            inputLbl.x = 10;
            inputLbl.y = 10;
            inputLbl.text = "Value to save:";
            
            // input TextField
            input = new TextField();
            addChild(input);
            input.x = 80;
            input.y = 10;
            input.width = 100;
            input.height = 20;
            input.border = true;
            input.background = true;
            input.type = TextFieldType.INPUT;
            
            // output TextField
            output = new TextField();
            addChild(output);
            output.x = 10;
            output.y = 35;
            output.width = 250;
            output.height = 250;
            output.multiline = true;
            output.wordWrap = true;
            output.border = true;
            output.background = true;
            
            // Save button
            saveBtn = new Sprite();
            addChild(saveBtn);
            saveBtn.x = 190;
            saveBtn.y = 10;
            saveBtn.useHandCursor = true;
            saveBtn.graphics.lineStyle(1);
            saveBtn.graphics.beginFill(0xcccccc);
            saveBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var saveLbl:TextField = new TextField();
            saveBtn.addChild(saveLbl);
            saveLbl.text = "Save";
            saveLbl.selectable = false;
            
            // Clear button
            clearBtn = new Sprite();
            addChild(clearBtn);
            clearBtn.x = 230;
            clearBtn.y = 10;
            clearBtn.useHandCursor = true;
            clearBtn.graphics.lineStyle(1);
            clearBtn.graphics.beginFill(0xcccccc);
            clearBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var clearLbl:TextField = new TextField();
            clearBtn.addChild(clearLbl);
            clearLbl.text = "Clear";
            clearLbl.selectable = false;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link><link href="flash.net.xml#SharedObject/event:netStatus"><linktext>netStatus</linktext></link></related-links><adobeApiEvent id="flash.net:SharedObject_flash.events.SyncEvent.SYNC_sync"><apiName>sync</apiName><shortdesc>
 Wird ausgelöst, wenn ein gemeinsames Remote-Objekt vom Server aktualisiert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SyncEvent.SYNC</apiEventType><adobeApiEventClassifier>flash.events.SyncEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein gemeinsames Remote-Objekt vom Server aktualisiert wurde.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Wird ausgelöst, wenn der Status oder die Fehlerbedingung einer SharedObject-Instanz protokolliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Status oder die Fehlerbedingung einer SharedObject-Instanz protokolliert wird. Das Ereignis <codeph>netStatus</codeph> enthält die Eigenschaft <codeph>info</codeph>. Dabei handelt es sich um ein Informationsobjekt mit spezifischen Informationen über das Ereignis, z. B. ob ein Verbindungsversuch erfolgreich war oder ob das gemeinsame Objekt erfolgreich auf die lokale Festplatte geschrieben werden konnte. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron, d. h. aus nativem asynchronem Code ausgelöst wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron ausgelöst wird – das heißt, aus nativem asynchronem Code. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:SharedObject:clear"><apiName>clear</apiName><shortdesc>
     Lokale gemeinsame Objekte: Entfernt alle Daten und löscht das gemeinsame Objekt von der Festplatte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.clear, clear
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Lokale gemeinsame Objekte: Entfernt alle Daten und löscht das gemeinsame Objekt von der Festplatte. Der Verweis auf das gemeinsame Objekt ist weiterhin aktiv, die zugehörigen Dateneigenschaften werden jedoch gelöscht.
     
     <p>
     Für gemeinsame Remote-Objekte, die mit Flash Media Server verwendet werden, trennt <codeph>clear()</codeph> die Verbindung zum Objekt und löscht alle Daten. Wenn das gemeinsame Objekt lokal gespeichert wird, wird es mit dieser Methode auch von der Festplatte gelöscht. Der Verweis auf das gemeinsame Objekt ist weiterhin aktiv, die zugehörigen Dateneigenschaften werden jedoch gelöscht.
     </p>
      
     
     </apiDesc><example conref="examples\SharedObject_clear.as"> Mit dem folgenden Code wird ein SharedObject-Objekt mit der ID <codeph>hostName</codeph> erstellt (und in anschließenden Durchläufen abgerufen). Eine Eigenschaft mit dem Namen <codeph>username</codeph> wird der Eigenschaft „data“ des SharedObject-Objekts hinzugefügt. Anschließend wird die Methode <codeph>clear()</codeph> aufgerufen, die alle Informationen löscht, die dem Datenobjekt hinzugefügt wurden (in diesem Fall die Eigenschaft <codeph>username</codeph>).
<codeblock>

package {
    import flash.net.SharedObject;

    public class SharedObject_clear {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_clear() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            if(mySo.data.username == null) {
                mySo.data.username = username;
                trace("set: " + mySo.data.username); // yourUsername
            }
            else {
                mySo.clear();
                trace("cleared: " + mySo.data.username); // undefined
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:close"><apiName>close</apiName><shortdesc>
     Schließt die Verbindung zwischen einem gemeinsamen Remote-Objekt und dem Server.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Schließt die Verbindung zwischen einem gemeinsamen Remote-Objekt und dem Server. Wenn ein gemeinsames Remote-Objekt permanent lokal gespeichert ist, kann der Benutzer nach dem Aufruf dieser Methode Änderungen an der lokalen Kopie vornehmen. Das nächste Mal, wenn der Benutzer eine Verbindung zu dem gemeinsamen Remote-Objekt herstellt, werden diese Änderungen an den Server gesendet.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:connect"><apiName>connect</apiName><shortdesc>
     Stellt über ein angegebenes NetConnection-Objekt eine Verbindung zu einem gemeinsamen Remote-Objekt her.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: On FMS, can connect to a shared object, but cannot pass a message as a second param.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Flash Player konnte keine Verbindung zu dem angegebenen gemeinsamen Remote-Objekt herstellen. Vergewissern Sie sich, dass die NetConnection-Instanz gültig und verbunden ist und dass das gemeinsame Remote-Objekt erfolgreich auf dem Server erstellt wurde.
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>myConnection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>Ein NetConnection-Objekt, das das Real-Time Messaging Protocol (RTMP) verwendet, zum Beispiel für die Kommunikation mit Flash Media Server.
     
     </apiDesc></apiParam><apiParam><apiItemName>params</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein String, der eine Meldung definiert, die an das gemeinsame Remote-Objekt auf dem Server übergeben wird. Kann nicht mit Flash Media Server verwendet werden.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Stellt über ein angegebenes NetConnection-Objekt eine Verbindung zu einem gemeinsamen Remote-Objekt her. Verwenden Sie diese Methode nach dem Aufruf von <codeph>getRemote()</codeph>. Wird die Verbindung erfolgreich hergestellt, wird das <codeph>sync</codeph>-Ereignis ausgelöst.
     
     <p>Bevor Sie beginnen, mit einem gemeinsamen Remote-Objekt zu arbeiten, prüfen Sie, ob Fehler vorliegen, indem Sie eine <codeph>try..catch..finally</codeph> Anweisung. Warten Sie dann auf das Ereignis <codeph>sync</codeph> und verarbeiten Sie es, bevor Sie Änderungen am gemeinsamen Objekt vornehmen. Alle Änderungen, die lokal vor dem Auslösen des <codeph>sync</codeph>-Ereignisses vorgenommen werden, können verloren gehen.
     </p>
     
     <p>
     Rufen Sie die <codeph>connect()</codeph>-Methode auf, um eine Verbindung zu einem gemeinsamen Remote-Objekt herzustellen, zum Beispiel:
     </p>
     
	 <codeblock platform="actionscript">
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", myNC.uri, false);
     myRemoteSO.connect(myNC);
     </codeblock>
     
	 <codeblock platform="javascript">
	 var myRemoteSO = air.SharedObject.getRemote("mo", myNC.uri, false);
	 myRemoteSO.connect(myNC);
	 </codeblock>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link><link href="flash.net.xml#SharedObject/event:sync"><linktext>sync</linktext></link><link href="../../statements.html#try..catch..finally"><linktext>try..catch..finally</linktext></link><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:flush"><apiName>flush</apiName><shortdesc>
     Schreibt ein lokal permanentes gemeinsames Objekt in eine lokale Datei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.flush, flush
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Flash Player kann das gemeinsame Objekt nicht auf Festplatte schreiben. Dieser Fehler kann auftreten, wenn der Benutzer das Speichern lokaler Daten für Objekte dieser Domäne generell nicht zugelassen hat.
      
     
     <p><b>Hinweis:</b> Über lokale Inhalte können immer gemeinsame Objekte von Dritt-Domänen (anderen Domänen als der in der Adresszeile des Browsers) auf Festplatte geschrieben werden, auch wenn das Schreiben gemeinsamer Objekte durch Dritt-Domänen nicht zulässig ist.</p>
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Einer der folgenden Werte:
     <ul>
     <li><codeph>SharedObjectFlushStatus.PENDING</codeph>: Der Benutzer hat das Speichern lokaler Daten für Objekte dieser Domäne zugelassen, der zugewiesene Platz reicht aber zum Speichern des Objekts nicht aus. Flash Player fordert den Benutzer auf, zusätzlichen Speicherplatz zuzuweisen. Wenn der Speicherplatz für das gemeinsame Objekt in Zukunft zunehmen darf, um die Rückgabe des Werts <codeph>SharedObjectFlushStatus.PENDING</codeph> zu vermeiden, belegen Sie <codeph>minDiskSpace</codeph> mit einem Wert.
     </li>
     
     <li><codeph>SharedObjectFlushStatus.FLUSHED</codeph>: Das gemeinsame Objekt wurde erfolgreich in eine Datei auf der lokalen Festplatte geschrieben.</li>
     </ul>
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>minDiskSpace</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Der minimale Speicherplatz in Byte, der für dieses Objekt zugewiesen werden muss.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Schreibt ein lokal permanentes gemeinsames Objekt in eine lokale Datei. Wenn Sie diese Methode nicht verwenden, schreibt Flash Player das gemeinsame Objekt in eine Datei, wenn die Sitzung des gemeinsamen Objekts endet, d. h., wenn die SWF-Datei geschlossen wird, wenn das gemeinsame Objekt gelöscht wird, weil keine weiteren Verweise darauf vorhanden sind, oder wenn Sie <codeph>SharedObject.clear()</codeph> oder <codeph>SharedObject.close()</codeph> aufrufen. 
     
     <p>Wenn diese Methode <codeph>SharedObjectFlushStatus.PENDING</codeph> zurückgibt, fordert Flash Player den Benutzer in einem Dialogfeld auf, mehr Speicherplatz für Objekte dieser Domäne bereitzustellen. Wenn der Speicherplatz für das gemeinsame Objekt in Zukunft zunehmen darf, um die Rückgabe des Werts <codeph>PENDING</codeph> zu vermeiden, belegen Sie <codeph>minDiskSpace</codeph> mit einem Wert. Bei dem Versuch, eine Datei zu schreiben, ermittelt Flash Player die Anzahl der an <codeph>minDiskSpace</codeph> übergebenen Byte, anstatt lediglich zu überprüfen, ob der vorhandene Platz zum Speichern des gemeinsamen Objekts in der aktuellen Größe ausreicht. </p>
     
     <p>Wenn Sie beispielsweise annehmen, dass ein gemeinsames Objekt maximal 500 Byte groß wird, übergeben Sie 500 als Wert für <codeph>minDiskSpace</codeph>, auch wenn die Datei zunächst viel kleiner ist. Flash fordert dann den Benutzer auf, für das gemeinsame Objekt 500 Byte Speicherplatz bereitzustellen. Wenn der Benutzer den gewünschten Speicherplatz zuweist, ist es in Zukunft beim Ausgeben des Objekts nicht erforderlich, mehr Speicherplatz anzufordern (sofern die Größe 500 Byte nicht übersteigt). </p>
     
     <p>Nachdem der Benutzer auf dieses Dialogfeld reagiert hat, wird diese Methode erneut aufgerufen. Ein <codeph>netStatus-Ereignis</codeph> wird mit der <codeph>code</codeph>-Eigenschaft <codeph>SharedObject.Flush.Success</codeph> oder <codeph>SharedObject.Flush.Failed</codeph> ausgelöst
     </p>
     
     </apiDesc><example conref="examples\SharedObject_flush.as"> Mit dem folgenden Code wird ein SharedObject-Objekt mit der ID <codeph>hostName</codeph> erstellt (und in anschließenden Durchläufen abgerufen). Eine Eigenschaft mit dem Namen <codeph>username</codeph> wird der Eigenschaft „data“ des SharedObject-Objekts hinzugefügt. Anschließend wird die Methode <codeph>flush()</codeph> aufgerufen, und es wird überprüft, ob der String <codeph>pending</codeph> oder der boolesche Wert <codeph>true</codeph> bzw. <codeph>false</codeph> zurückgegeben wurde. Beachten Sie, dass alle geöffneten SharedObject-Instanzen automatisch ausgegeben werden, wenn die aktuelle Flash Player-Instanz geschlossen wird.
<codeblock>
package {
    import flash.net.SharedObject;

    public class SharedObject_flush {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_flush() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            mySo.data.username = username;
            var flushResult:Object = mySo.flush();
            trace("flushResult: " + flushResult);
            trace(mySo.data.username); // yourUsername
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/clear()"><linktext>clear()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:getLocal"><apiName>getLocal</apiName><shortdesc>
  Gibt einen Verweis auf ein lokal permanentes gemeinsames Objekt zurück, das nur für den aktuellen Client verfügbar ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, constructor, SharedObject.getLocal, getLocal, get
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Flash Player kann das gemeinsame Objekt nicht erstellen. Dieser Fehler kann auftreten, wenn das Erstellen und Speichern von permanenten gemeinsamen Objekten durch Flash-Inhalte Dritter nicht erlaubt ist (gilt nicht für lokale Inhalte). Benutzer können unter <xref href="http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html" scope="external">http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html</xref> im Einstellungsmanager im Bedienfeld „Globale Speichereinstellungen“ festlegen, dass permanente gemeinsame Objekte von Dritten nicht zulässig sind.
  
  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Gibt einen Verweis auf ein lokal permanentes gemeinsames Objekt zurück, das nur für den aktuellen Client verfügbar ist. Wenn Flash Player das gemeinsame Objekt nicht erstellen oder finden kann (wenn beispielsweise das mit <codeph>localPath</codeph> angegebene Verzeichnis nicht vorhanden ist), löst diese Methode eine Ausnahme aus.
  
  </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des Objekts. Der Name darf Schrägstriche (<codeph>/</codeph>) enthalten. So ist beispielsweise <codeph>work/addresses</codeph> ein gültiger Name. Der Name eines gemeinsamen Objekts darf weder Leerzeichen noch folgende Zeichen enthalten:   
  <pre>
  ~ % &amp; \ ; : " ' , &lt; > ? # 
  </pre>
  
  </apiDesc></apiParam><apiParam><apiItemName>localPath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der vollständige oder Teilpfad zur SWF-Datei, die das gemeinsame Objekt erstellt hat und die den lokalen Speicherort des gemeinsamen Objekts festlegt. Wenn Sie diesen Parameter nicht angeben, wird der vollständige Pfad verwendet. 
   
  </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Hiermit wird festgelegt, ob der Zugriff auf dieses gemeinsame Objekt auf SWF-Dateien beschränkt wird, die über eine HTTPS-Verbindung bereitgestellt werden. Wenn die SWF-Datei über eine HTTPS-Verbindung bereitgestellt wird, hat der Wert dieses Parameters folgende Auswirkungen:
  <ul>
  <li>Falls dieser Parameter auf <codeph>true</codeph> gesetzt wird, erstellt Flash Player ein neues sicheres gemeinsam genutztes Objekt oder ruft einen Verweis auf ein vorhandenes sicheres gemeinsam genutztes Objekt ab. Dieses sichere gemeinsam genutzte Objekt kann nur durch SWF-Dateien gelesen oder geschrieben werden, die über HTTPS bereitgestellt werden und <codeph>SharedObject.getLocal()</codeph> mit der Einstellung <codeph>true</codeph> für den <codeph>secure</codeph>-Parameter aufrufen.</li>
  <li>Wenn dieser Parameter auf <codeph>false</codeph> gesetzt wird, erstellt Flash Player ein neues gemeinsames Objekt oder ruft den Verweis auf ein vorhandenes gemeinsames Objekt ab, das durch SWF-Dateien gelesen oder geschrieben werden kann, die über andere Verbindungen als HTTPS bereitgestellt werden.</li>
  </ul>
  <p>Wenn die SWF-Datei über eine andere Verbindung als HTTPS bereitgestellt wird und Sie diesen Parameter auf <codeph>true</codeph> setzen, tritt bei der Erstellung des neuen gemeinsam genutzten Objekts (bzw. beim Zugriff auf ein zuvor erstelltes sicheres gemeinsam genutztes Objekt) ein Fehler auf, und es wird <codeph>null</codeph> zurückgegeben. Unabhängig vom Wert dieses Parameters belegen die erstellten gemeinsamen Objekte einen Teil des von einer Domäne belegten Speicherplatzes.</p>
  
  <p>Aus dem folgenden Diagramm geht die Verwendung des Parameters <codeph>secure</codeph> hervor.</p>
  <p><adobeimage alt="Diagramm eines sicheren gemeinsam genutzten Objekts" href="../../images/secureParam.jpg"/></p>
  
  </apiDesc></apiParam></apiOperationDef><apiDesc>
  Gibt einen Verweis auf ein lokal permanentes gemeinsames Objekt zurück, das nur für den aktuellen Client verfügbar ist. Falls das gemeinsam genutzte Objekt nicht bereits existiert, wird es durch diese Methode erstellt. Wenn einer oder mehrere der an <codeph>getLocal()</codeph> übergebenen Werte ungültig sind oder der Aufruf fehlschlägt, gibt Flash Player eine Ausnahme aus.
  
  <p>Anhand des folgenden Codes wird gezeigt, wie Sie den zurückgegebenen Verweis auf ein gemeinsames Objekt einer Variablen zuordnen:</p>
  <p><codeph>var so:SharedObject = SharedObject.getLocal("savedData");</codeph></p>
  
  <p><b>Hinweis:</b> Wenn der Benutzer für diese Domäne generell keine lokale Speicherung zulässt, wird das Objekt auch dann nicht lokal gespeichert, wenn für <codeph>localPath</codeph> ein lokaler Pfad angegeben wurde. Es gibt eine Ausnahme zu dieser Regel: lokale Inhalte. Über lokale Inhalte können immer gemeinsam genutzte Objekte von Dritt-Domänen (anderen Domänen als der in der Adresszeile des Browsers) auf Festplatte geschrieben werden, auch wenn das Schreiben gemeinsam genutzter Objekte durch Dritt-Domänen nicht zulässig ist.
  </p>
  
  <p>Um Namenskonflikte zu vermeiden, wird in Flash auch der Speicherort der SWF-Datei einbezogen, die das gemeinsame Objekt erstellt hat. Wenn zum Beispiel eine SWF-Datei auf www.meineFirma.com/apps/stockwatcher.swf ein gemeinsames Objekt namens <codeph>portfolio</codeph> erstellt, entsteht kein Konflikt mit einem anderen, ebenfalls <codeph>portfolio</codeph> genannten Objekt, das von einer SWF-Datei auf www.IhreFirma.com/photoshoot.swf erstellt wurde, weil die beiden SWF-Dateien aus zwei verschiedenen Verzeichnissen stammen. </p>
  
  <p><codeph>localPath</codeph> ist zwar ein optionaler Parameter, dennoch sollten Sie seine Verwendung in Erwägung ziehen, insbesondere wenn andere SWF-Dateien auf das gemeinsame Objekt zugreifen müssen. Wenn die Daten im gemeinsamen Objekt speziell für eine SWF-Datei gelten, die nicht an einen anderen Speicherort verschoben wird, ist die Verwendung des Standardwertes sinnvoll. Wenn andere SWF-Dateien auf das gemeinsame Objekt zugreifen müssen oder wenn die SWF-Datei, die das gemeinsame Objekt erstellt, zu einem späteren Zeitpunkt verschoben wird, kann der Wert dieses Parameters entscheidend dafür sein, ob SWF-Dateien auf das gemeinsame Objekt zugreifen können. Wenn Sie beispielsweise ein gemeinsames Objekt erstellen und für <codeph>localPath</codeph> der Standardwert des vollständigen Pfads zur SWF-Datei eingestellt ist, kann keine andere SWF-Datei auf das gemeinsame Objekt zugreifen. Wenn Sie die Original-SWF-Datei später an einen anderen Speicherort verschieben, kann selbst diese SWF-Datei nicht mehr auf die bereits im gemeinsamen Objekt gespeicherten Daten zugreifen.</p>
  
  <p>Verwenden Sie den Parameter <codeph>localpath</codeph>, um die versehentliche Beschränkung des Zugriffs auf ein gemeinsames Objekt zu vermeiden. Wenn Sie möchten, dass das gemeinsame Objekt für alle SWF-Dateien in der Domäne verfügbar ist, setzen Sie den Parameter <codeph>localPath</codeph> auf <codeph>/</codeph> (Schrägstrich). Dadurch wird jedoch das Risiko der Namenskonflikte mit anderen gemeinsamen Objekten in der Domäne erhöht. Sie können die Möglichkeiten ein Stück weit einschränken, indem Sie den Parameter <codeph>localPath</codeph> auf Ordnernamen aus dem vollständigen Pfad der SWF-Datei setzen. Beispiel: Für das von der SWF-Datei unter www.myCompany.com/apps/stockwatcher.swf erstellte gemeinsame Objekt <codeph>portfolio</codeph> können Sie den Parameter <codeph>localPath</codeph> auf <codeph>/</codeph> , <codeph>/apps</codeph> oder <codeph>/apps/stockwatcher.swf</codeph> setzen. Welcher Ansatz für Ihre Anwendung die meiste Flexibilität bietet, ist von der jeweiligen Anwendung abhängig.</p>
  
  <p platform="actionscript">Beachten Sie bei Verwendung dieser Methode das folgende Sicherheitsmodell von:
  
  <ul>
  
    <li>Auf gemeinsam genutzte Objekte kann nicht über Sandbox-Grenzen hinweg zugegriffen werden.</li>
    <li>Benutzer können den Zugriff auf gemeinsam genutzte Objekte über das Flash Player-Dialogfeld „Einstellungen“ oder über den Einstellungsmanager einschränken. Standardmäßig kann eine Anwendung gemeinsame Objekte mit einem Datenumfang von bis zu 100 KB pro Domäne erstellen. Administratoren und Benutzer können auch Einschränkungen für Schreibberechtigungen im Dateisystem festlegen.</li>
  </ul></p>
  
  <p platform="actionscript">Beispiel: Sie veröffentlichen die Inhalte einer SWF-Datei für die Wiedergabe als lokale Dateien (entweder lokal installierte SWF-Dateien oder EXE-Dateien) und müssen von mehreren lokalen SWF-Dateien auf ein bestimmtes gemeinsames Objekt zugreifen. In dieser Situation müssen Sie darauf achten, dass für die lokalen Dateien möglicherweise zwei verschiedene Speicherorte zur Speicherung von gemeinsamen Objekten verwendet werden. Welche Domäne verwendet wird, hängt von den Sicherheitsberechtigungen der lokalen Datei ab, die das gemeinsame Objekt erstellt hat. Für lokale Dateien sind drei verschiedene Berechtigungsstufen möglich:
  
  <ol>
    <li>Nur Zugriff auf das lokale Dateisystem</li>
    <li>Nur Zugriff auf das Netzwerk</li>
    <li>Zugriff auf das Netzwerk und auf das lokale Dateisystem</li>
  </ol></p>
  
  <p platform="actionscript">Lokale Dateien mit Zugriff auf das lokale Dateisystem (Stufe 1 oder 3) speichern gemeinsame Objekte an einem Speicherort. Lokale Dateien ohne Zugriff auf das lokale Dateisystem (Stufe 2) speichern gemeinsame Objekte an einem anderen Speicherort.</p>
  
  <p platform="actionscript">Sie können eine SWF-Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</p>
  
  <p platform="actionscript">Weitere Informationen finden Sie in den folgenden Abschnitten:
  
  <ul>
    <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
    <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
    <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
  </ul></p>
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:getRemote"><apiName>getRemote</apiName><shortdesc>
     Gibt einen Verweis auf das gemeinsame Objekt auf Flash Media Server zurück, auf das mehrere Clients zugreifen können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Flash Player kann das gemeinsame Objekt weder erstellen noch öffnen. Dieser Fall kann eintreten, wenn für die Parameter <codeph>remotePath</codeph> und <codeph>persistence</codeph> nicht vorhandene Pfade angegeben wurden.
     
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein Verweis auf ein Objekt, das von mehreren Clients gemeinsam genutzt werden kann.
     
     </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name des gemeinsamen Remote-Objekts. Der Name kann Schrägstriche (/) enthalten. So ist beispielsweise „work/addresses“ ein gültiger Name. Der Name eines gemeinsamen Objekts darf weder Leerzeichen noch folgende Zeichen enthalten:
     <pre>    ~ % &amp; \ ; :  " ' , > ? ? #</pre>
     
     </apiDesc></apiParam><apiParam><apiItemName>remotePath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der URI des Servers, auf dem das gemeinsame Objekt gespeichert wird. Dieser URI muss mit dem URI des NetConnection-Objekts übereinstimmen, das an die Methode <codeph>connect()</codeph> übergeben wird. 
     
     </apiDesc></apiParam><apiParam><apiItemName>persistence</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob die Dateneigenschaft des gemeinsamen Objekts die lokal permanente Speicherung, die permanente Remote-Speicherung oder beide Attribute aufweist. Mit diesem Parameter kann auch angegeben werden, wo das gemeinsame Objekt lokal gespeichert wird. Folgende Werte sind zulässig:
     <ul><li>Der Wert <codeph>false</codeph> gibt an, dass das gemeinsame Objekt nicht permanent auf dem Client oder auf dem Server gespeichert wird.</li>
     <li>Der Wert <codeph>true</codeph> gibt an, dass das gemeinsame Objekt nur auf dem Server permanent gespeichert wird.</li>
     <li>Ein vollständig oder teilweise angegebener lokaler Pfad zum gemeinsamen Objekt gibt an, dass das gemeinsame Objekt permanent auf dem Client und auf dem Server gespeichert wird. Auf dem Client wird es unter dem angegebenen Pfad und auf dem Server in einem Unterverzeichnis des Anwendungsverzeichnisses gespeichert.</li>
     </ul>
     
     <p><b>Hinweis:</b> Wenn der Benutzer für diese Domäne generell keine lokale Speicherung zulässt, wird das Objekt auch dann nicht lokal gespeichert, wenn ein lokaler Pfad angegeben wurde. Weitere Informationen finden Sie in der Beschreibung zur Klasse.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Hiermit wird festgelegt, ob der Zugriff auf dieses gemeinsame Objekt auf SWF-Dateien beschränkt wird, die über eine HTTPS-Verbindung bereitgestellt werden. Weitere Informationen finden Sie in den Erläuterungen zum Parameter <codeph>secure</codeph> im Eintrag zur Methode <codeph>getLocal</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gibt einen Verweis auf das gemeinsame Objekt auf Flash Media Server zurück, auf das mehrere Clients zugreifen können. Falls das gemeinsame Remote-Objekt nicht bereits existiert, wird es durch diese Methode erstellt. 
     
     <p>
     Um ein gemeinsames Remote-Objekt zu erstellen, rufen Sie <codeph>getRemote()</codeph> nach dem Aufruf von <codeph>connect()</codeph> auf, um das gemeinsame Remote-Objekt mit dem Server zu verbinden wie im folgenden Beispiel:</p>
     
	 <codeblock platform="actionscript">
     var nc:NetConnection = new NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
     
	 <codeblock platform="javascript">
     var nc = new air.NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
	 
     <p>
     Mit dem Ereignis <codeph>sync</codeph> wird bestätigt, dass die lokalen und Remote-Kopien des gemeinsamen Objekts synchronisiert sind. Alle Clients, die dieses Objekt gemeinsam verwenden sollen, müssen dieselben Werte für die Parameter <codeph>name</codeph> und <codeph>remotePath</codeph> übergeben. 
     </p> 
     
     <p>Zur Erstellung eines gemeinsamen Objekts, das nur für den aktuellen Client verfügbar ist, verwenden Sie<codeph>SharedObject.getLocal()</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:send"><apiName>send</apiName><shortdesc>
     Überträgt eine Meldung an alle mit einem gemeinsamen Remote-Objekt verbundenen Clients, einschließlich des Clients, von dem die Meldung gesendet wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Needs better documentation, examples.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Ein oder mehrere Argumente: Ein String, der die Meldung identifiziert, der Name einer oder mehrerer Verarbeitungsfunktionen, die an das gemeinsame Objekt angehängt werden, und optionale Parameter beliebigen Typs. Der Prozedurname darf nur eine Ebene umfassen (d. h. die Form übergeordnet/untergeordnet ist nicht zulässig) und hängt vom gemeinsamen Objekt ab. Die Argumente werden serialisiert, über die Verbindung gesendet und von der Empfangsprozedur in derselben Reihenfolge empfangen. Wenn es sich bei dem Parameter um ein zyklisches Objekt handelt (z. B. eine verknüpfte zyklische Liste), werden die Verweise bei der Serialisierung korrekt verarbeitet.
     
     <p><b>Hinweis</b>: Verwenden Sie keine reservierten Begriffe als Funktionsnamen. Beispiel: Bei Verwendung von <codeph>myRemoteSO.send("close")</codeph> schlägt die Prozedur fehl.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Überträgt eine Meldung an alle mit einem gemeinsamen Remote-Objekt verbundenen Clients, einschließlich des Clients, von dem die Meldung gesendet wurde. Zur Verarbeitung und Beantwortung der Meldung erstellen Sie eine Callback-Funktion, die mit dem gemeinsamen Objekt verknüpft wird.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:setDirty"><apiName>setDirty</apiName><shortdesc>
     Weist den Server an, dass der Wert einer Eigenschaft im gemeinsamen Objekt geändert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The AS2 player automatically marks properties dirty as they are changed.
          The FMS server, however, requires an explicit setProperty() call to indicate when a property
          of data has changed.
     
          AS3 does not support auto-dirtying the properties, so we are introducing setDirty() to explicitly
          indicate when a property has changed, and setProperty() to match the method provided with the server.
     
          It's probably best to read the FMS Actionscript reference (search for SharedObject.setProperty at
          www.adobe.com) before writing this documentation, as the details should be similar.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der geänderten Eigenschaft.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Weist den Server an, dass der Wert einer Eigenschaft im gemeinsamen Objekt geändert wurde. Diese Methode kennzeichnet Eigenschaften als geändert (<i>dirty</i>).
     
     <p>
     Rufen Sie <codeph>SharedObject.setProperty()</codeph> auf, um Eigenschaften für ein gemeinsames Objekt zu erstellen. 
     </p>
      
     <p>
     Die <codeph>SharedObject.setProperty()</codeph>-Methode implementiert <codeph>setDirty()</codeph>. In den meisten Fällen (bei einfachen Eigenschaftswerten wie „String“ oder „Number“) können Sie <codeph>setProperty()</codeph> anstelle von <codeph>setDirty()</codeph> aufrufen. Wenn es sich bei dem Eigenschaftswert jedoch um ein Objekt mit eigenen Eigenschaften handelt, rufen Sie <codeph>setDirty()</codeph> auf, um anzugeben, wenn ein Wert innerhalb des Objekts geändert wurde.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (clientseitige Eigenschaft)</linktext></link><link href="flash.net.xml#SharedObject/setProperty()"><linktext>setProperty()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:setProperty"><apiName>setProperty</apiName><shortdesc>
     Aktualisiert den Wert einer Eigenschaft in einem gemeinsamen Objekt und informiert den Server, dass der Wert der Eigenschaft geändert wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Eigenschaft im gemeinsamen Objekt.
     </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Wert der Eigenschaft (ein ActionScript-Objekt) oder <codeph>null</codeph> zum Löschen der Eigenschaft. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Aktualisiert den Wert einer Eigenschaft in einem gemeinsamen Objekt und informiert den Server, dass der Wert der Eigenschaft geändert wurde. Die <codeph>setProperty()</codeph>-Methode markiert Eigenschaften ausdrücklich als geändert („dirty“).
     
     <p>Weitere Informationen zu gemeinsamen Remote-Objekten finden Sie in der <xref href="http://www.adobe.com/go/learn_fms_docs_en">Dokumentation zu Flash Media Server</xref>.</p>
     
     <p><b>Hinweis:</b> Die Methode <codeph>SharedObject.setProperty()</codeph> implementiert die Methode <codeph>setDirty()</codeph>. In den meisten Fällen (bei einfachen Eigenschaftswerten wie „String“ oder „Number“) verwenden Sie <codeph>setProperty()</codeph> anstelle von <codeph>setDirty()</codeph>. Wenn es sich bei dem Eigenschaftswert jedoch um ein Objekt mit eigenen Eigenschaften handelt, verwenden Sie <codeph>setDirty()</codeph>, um anzugeben, wenn ein Wert innerhalb des Objekts geändert wurde. Im Allgemeinen empfiehlt es sich, <codeph>setProperty()</codeph> anstelle von <codeph>setDirty()</codeph> aufzurufen, da <codeph>setProperty()</codeph> einen Eigenschaftswert nur aktualisiert, wenn sich dieser Wert geändert hat; im Gegensatz dazu erzwingt <codeph>setDirty()</codeph> eine Synchronisierung aller Clients mit Abonnement.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (clientseitige Eigenschaft)</linktext></link></related-links></apiOperation><apiValue id="flash.net:SharedObject:client:get"><apiName>client</apiName><shortdesc>
     Gibt das Objekt an, bei dem Callback-Methoden aufgerufen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Die <codeph>client</codeph>-Eigenschaft muss auf ein Objekt eingestellt werden, das nicht null ist.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Gibt das Objekt an, bei dem Callback-Methoden aufgerufen werden. Das Standardobjekt ist <codeph>this</codeph>. Wenn Sie die client-Eigenschaft auf ein anderes Objekt einstellen, werden die Callback-Methoden bei dem eingestellten Objekt aufgerufen.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:data:get"><apiName>data</apiName><shortdesc>
     Die Sammlung von Attributen, die der Eigenschaft „data“ des Objekts zugewiesen sind. Diese Attribute können gemeinsam genutzt und gespeichert werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.data, data
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Die Sammlung von Attributen, die der <codeph>data</codeph>-Eigenschaft des Objekts zugewiesen sind. Diese Attribute können gemeinsam genutzt und gespeichert werden. Jedes Attribut ist ein Objekt eines beliebigen ActionScript- oder JavaScript-Typs: Array, Number, Boolean, ByteArray, XML usw. Mit den folgenden Zeilen werden beispielsweise verschiedenen Aspekten eines gemeinsamen Objekts Werte zugewiesen:
     
	 <codeblock platform="actionscript">
     var items_array:Array = new Array(101, 346, 483);
     var currentUserIsAdmin:Boolean = true;
     var currentUserName:String = "Ramona";
     
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.data.itemNumbers = items_array;
     my_so.data.adminPrivileges = currentUserIsAdmin;
     my_so.data.userName = currentUserName;
     
     for (var prop in my_so.data) {
       trace(prop+": "+my_so.data[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var items_array = new Array(101, 346, 483);
	 var currentUserIsAdmin = true;
	 var currentUserName = "Ramona";
	 
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.data.itemNumbers = items_array;
	 my_so.data.adminPrivileges = currentUserIsAdmin;
	 my_so.data.userName = currentUserName;
	 
	 for (var prop in my_so.data) {
	   trace(prop+": "+my_so.data[prop]);
	 }
	 </codeblock>
     
     <p>Alle Attribute der <codeph>data</codeph>-Eigenschaft eines gemeinsamen Objekts werden gespeichert, wenn das Objekt dauerhaft ist, und das gemeinsame Objekt enthält die folgenden Informationen:</p>
     
     <codeblock>
     userName: Ramona
     adminPrivileges: true
     itemNumbers: 101,346,483
     </codeblock>
     
     <p><b>Hinweis:</b> Weisen Sie der <codeph>data</codeph>-Eigenschaft eines gemeinsamen Objekts keine Werte direkt zu, wie in <codeph>so.data = someValue</codeph>. Flash Player ignoriert diese Zuweisungen.</p>
     
     <p>Um Attribute von lokalen gemeinsamen Objekten zu löschen, verwenden Sie folgende Syntax: <codeph>delete so.data.attributeName</codeph>. Das Attribut eines lokalen gemeinsamen Objekts wird nicht gelöscht, wenn Sie es auf <codeph>null</codeph> oder <codeph>undefined</codeph> setzen.</p>
     
     <p>Um als <i>privat</i> definierte Werte für ein gemeinsames Objekt zu erstellen (d. h. Werte, die nur für die Client-Instanz verfügbar sind, wenn das Objekt verwendet wird, und die beim Schließen nicht zusammen mit dem Objekt gespeichert werden), erstellen Sie zum Speichern Eigenschaften, die nicht <codeph>data</codeph> heißen (siehe folgendes Beispiel).</p>
     
	 <codeblock platform="actionscript">
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.favoriteColor = "blue";
     my_so.favoriteNightClub = "The Bluenote Tavern";
     my_so.favoriteSong = "My World is Blue";
     
     for (var prop in my_so) {
       trace(prop+": "+my_so[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.favoriteColor = "blue";
	 my_so.favoriteNightClub = "The Bluenote Tavern";
	 my_so.favoriteSong = "My World is Blue";
	 
	 for (var prop in my_so) {
	   trace(prop+": "+my_so[prop]);
	 }
	 </codeblock>
     
     <p>Das gemeinsame Objekt enthält die folgenden Daten:</p>
     <codeblock>
     favoriteSong: My World is Blue
     favoriteNightClub: The Bluenote Tavern
     favoriteColor: blue
     data: [object Object]
     </codeblock>
     
     <p>
     Bei gemeinsamen Remote-Objekten, die mit einem Server verwendet werden, stehen alle Attribute der <codeph>data</codeph>-Eigenschaft allen mit dem Objekt verbundenen Clients zur Verfügung, und alle Attribute werden gespeichert, wenn es sich um ein permanentes Objekt handelt. Wenn ein Client den Wert eines Attributs ändert, sehen alle Clients den neuen Wert.
     </p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
     Die Standardobjektkodierung (AMF-Version) für alle in der SWF-Datei erstellten lokalen gemeinsamen Objekte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Die Standardobjektkodierung (AMF-Version) für alle in der SWF-Datei erstellten lokalen gemeinsamen Objekte. Wenn lokale gemeinsame Objekte auf Festplatte geschrieben werden, gibt die Eigenschaft <codeph>SharedObject.defaultObjectEncoding</codeph> an, welche AMF-Version verwendet werden soll: ActionScript 3.0 (AMF3) oder ActionScript 1.0 oder 2.0 (AMF0).
     
     <p>Nähere Informationen zur Objektkodierung einschließlich der Kodierungsunterschiede zwischen gemeinsamen lokalen und Remote-Objekten finden Sie in der Beschreibung der Eigenschaft <codeph>objectEncoding</codeph>.</p>
     
     <p>Standardmäßig wird <codeph>SharedObject.defaultObjectEncoding</codeph> auf die Verwendung des Formats ActionScript 3.0 (AMF3) eingestellt. Wenn Sie lokale gemeinsame Objekte benötigen, die von im Format ActionScript 2.0 oder 1.0 geschriebenen SWF-Dateien gelesen werden können, stellen Sie <codeph>SharedObject.defaultObjectEncoding</codeph> am Skriptanfang auf die Verwendung des Formats ActionScript 1.0 bzw. ActionScript 2.0 ein (<codeph>flash.net.ObjectEncoding.AMF0</codeph>), bevor Sie mit der Erstellung lokaler Objekte beginnen. Alle danach erstellten lokalen gemeinsamen Objekte verwenden die AMF0-Kodierung und unterstützen somit ältere Inhalte. Es ist nicht möglich, den <codeph>objectEncoding</codeph>-Wert bereits erstellter lokaler gemeinsamer Objekte durch die Einstellung von <codeph>SharedObject.defaultObjectEncoding</codeph> zu ändern.</p>
     
     <p>Um die Objektkodierung für die einzelnen Objekte anstatt für alle von der SWF-Datei erstellten gemeinsamen Objekte einzustellen, setzen Sie die <codeph>objectEncoding</codeph>-Eigenschaft stattdessen auf das jeweilige lokale gemeinsame Objekt.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/objectEncoding"><linktext>objectEncoding-Eigenschaft</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Die Objektkodierung (AMF-Version) für dieses gemeinsame Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Sie haben versucht, den Wert für die <codeph>objectEncoding</codeph>-Eigenschaft eines gemeinsamen Remote-Objekts einzustellen. Diese Eigenschaft ist für gemeinsame Remote-Objekte schreibgeschützt, da dieser Wert von der verknüpften NetConnection-Instanz festgelegt wird.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Die Objektkodierung (AMF-Version) für dieses gemeinsame Objekt. Wenn ein lokales gemeinsames Objekt auf Festplatte geschrieben wird, gibt die Eigenschaft <codeph>objectEncoding</codeph> an, welche AMF-Version verwendet werden soll: ActionScript 3.0 (AMF3) oder ActionScript 1.0 oder 2.0 (AMF0). 
     
     <p>Die Objektkodierung wird unterschiedlich gehandhabt, je nachdem, ob es sich um ein lokales gemeinsames Objekt oder um ein gemeinsames Remote-Objekt handelt.</p>
     <ul>
     <li><b>Lokale gemeinsame Objekte</b>: Sie können den Wert der Eigenschaft <codeph>objectEncoding</codeph> für lokale gemeinsame Objekte abrufen oder einstellen. Mit dem Wert für <codeph>objectEncoding</codeph> wird festgelegt, welche Formatierung zum <i>Schreiben</i> dieses lokalen gemeinsamen Objekts verwendet wird. Wenn das Objekt von SWF-Dateien gelesen werden muss, die mit ActionScript 2.0 oder 1.0 geschrieben wurden, setzen Sie <codeph>objectEncoding</codeph> auf <codeph>ObjectEncoding.AMF0</codeph>. Auch wenn die Objektkodierung so eingestellt ist, dass im Format AMF3 geschrieben wird, kann Flash Player lokale gemeinsame Objekte im Format AMF0 lesen. Das heißt, wenn Sie den Standardwert für diese Eigenschaft verwenden (<codeph>ObjectEncoding.AMF3</codeph>), kann Ihre SWF-Datei trotzdem gemeinsame Objekte lesen, die mit ActionScript 2.0- oder 1.0-SWF-Dateien erstellt wurden.
     </li>
     
     <li><b>Gemeinsame Remote-Objekte</b>: Bei einer Verbindung mit dem Server übernimmt ein gemeinsames Remote-Objekt seine <codeph>objectEncoding</codeph>-Einstellung von der verknüpften NetConnection-Instanz (die zum Verbinden des gemeinsamen Remote-Objekts verwendete Instanz). Ohne Serververbindung übernimmt das gemeinsame Remote-Objekt die <codeph>defaultObjectEncoding</codeph>-Einstellung von der verknüpften NetConnection-Instanz. Da bei gemeinsamen Remote-Objekten der Wert der Eigenschaft <codeph>objectEncoding</codeph> durch die NetConnection-Instanz bestimmt wird, ist diese Eigenschaft für gemeinsame Remote-Objekte schreibgeschützt.
     </li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:size:get"><apiName>size</apiName><shortdesc>
     Ruft die aktuelle Größe des gemeinsamen Objekts in Byte ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.getSize, getSize
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Ruft die aktuelle Größe des gemeinsamen Objekts in Byte ab.
     
     <p>Um die Größe eines gemeinsamen Objekts zu berechnen, analysiert Flash die einzelnen Dateneigenschaften des Objekts. Je mehr Dateneigenschaften ein Objekt aufweist, desto länger dauert es, die Größe zu ermitteln. Das Schätzen der Objektgröße kann sehr viel Verarbeitungszeit beanspruchen. Deshalb sollten Sie diese Methode vermeiden, sofern sie nicht wirklich erforderlich ist.</p>
     
     </apiDesc><example conref="examples\SharedObject.size.1.as"> Mit dem folgenden Code wird ein SharedObject-Objekt mit der ID <codeph>"thehobbit"</codeph> erstellt. Eine Eigenschaft mit dem Namen <codeph>username</codeph> wird der Eigenschaft „data“ des SharedObject-Objekts hinzugefügt. Die Eigenschaft <codeph>size</codeph> gibt dann den angegebenen Wert zurück.
<codeblock>

import flash.net.SharedObject;

// if these get copied or not
var mySo:SharedObject = SharedObject.getLocal("thehobbit");
mySo.data.username = "bilbobaggins";
trace(mySo.size); // 55
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:fps:set"><apiName>fps</apiName><shortdesc>
     Gibt an, wie oft pro Sekunde die clientseitigen Änderungen an einem gemeinsamen Objekt an den Server gesendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: The info is relevant for Flash Media Server, but not Flex.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, wie oft pro Sekunde die clientseitigen Änderungen an einem gemeinsamen Objekt an den Server gesendet werden. 
     
     <p>Verwenden Sie diese Methode, wenn Sie den Umfang des Datenverkehrs zwischen Client und Server steuern möchten. Beispiel: Wenn die Verbindungsgeschwindigkeit zwischen Client und Server ziemlich langsam ist, empfiehlt es sich, <codeph>fps</codeph> auf einen relativ niedrigen Wert zu setzen. Wenn der Client jedoch mit einer Multiuser-Anwendung verbunden ist und es auf die zeitliche Koordinierung ankommt, sollten Sie <codeph>fps</codeph> auf einen relativ hohen Wert setzen.</p>
     
     <p>Durch Festlegen von <codeph>fps</codeph> wird ein <codeph>sync</codeph>-Ereignis ausgelöst und alle Änderungen werden beim Server aktualisiert. Wenn Sie den Server ausschließlich manuell aktualisieren möchten, müssen Sie <codeph>fps</codeph> auf 0 setzen.</p>
     
     <p>Erst nach Auslösung des Ereignisses <codeph>sync</codeph>, werden die Änderungen an den Server gesendet. Das heißt, bei einer langsamen Reaktionszeit des Servers werden Aktualisierungen möglicherweise weniger häufig an den Server gesendet als in dieser Eigenschaft angegeben. </p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoaderDataFormat"><apiName>URLLoaderDataFormat</apiName><shortdesc>
 Mit der URLLoaderDataFormat-Klasse wird angegeben, wie heruntergeladene Daten empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der URLLoaderDataFormat-Klasse wird angegeben, wie heruntergeladene Daten empfangen werden.
 
 </apiDesc><example conref="examples\URLLoaderDataFormatExample.as"> Im folgenden Beispiel wird die URLLoaderDataFormatExample-Klasse verwendet, um Datenformat und Statusinformationen einer zur Laufzeit geladenen Datei anzuzeigen. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Der Klassenkonstruktor erstellt eine URLLoader-Instanz mit dem Namen <codeph>loader</codeph> und eine URLRequest-Instanz mit dem Namen <codeph>request</codeph>, wobei es sich um den Standort und den Namen der zu ladenden Datei handelt.</li>
  <li>Das Objekt <codeph>loader</codeph> wird an die Methode <codeph>configureListeners()</codeph> übergeben, die für jedes unterstützte URLLoader-Ereignis Listener hinzufügt.
  <ul>
      <li><codeph>completeHandler()</codeph>: Listener für das Ereignis <codeph>complete</codeph>, das nach dem erfolgreichen Laden der Datei „TextFile.txt“ ausgelöst wird.</li>
      <li><codeph>openHandler()</codeph>: Listener für das Ereignis <codeph>open</codeph>, das beim Start des Downloads der Datei „TextFile.txt“ (in den Player) ausgelöst wird.</li>
      <li><codeph>progressHandler()</codeph>: Listener für das Ereignis <codeph>progress</codeph>, das beim Empfang von Daten während des Download-Vorgangs ausgelöst wird.</li>
      <li><codeph>securityErrorHandler()</codeph>: Listener für <codeph>securityError</codeph>-Ereignisse, die ausgelöst werden, wenn mit der falschen Sicherheitseinstellung für die lokale Wiedergabe auf die Textdatei zugegriffen wird.</li>  
      <li><codeph>httpStatusHandler()</codeph>: Listener für <codeph>httpStatusHandler</codeph>-Ereignisse, die in diesem Fall nicht ausgelöst werden, da es sich bei „TextFile.txt“ um eine lokale Datei handelt.</li>
      <li><codeph>ioErrorHandler()</codeph>: Listener für <codeph>ioError</codeph>-Ereignisse, die nur bei schwerwiegenden Fehlern ausgelöst werden, beispielsweise wenn die Datei nicht vorhanden ist.</li>  
  </ul></li>
  <li>Dann wird das Objekt <codeph>request</codeph> an die Methode <codeph>loader.load()</codeph> übergeben, die die Textdatei mit einem <codeph>DisplayObject</codeph>-Objekt in den Speicher lädt.</li>
 </ol>
 <p> <b>Hinweise:</b>
 <ul>
  <li>Für die Kompilierung der SWF-Datei müssen Sie die Option „Sicherheit bei lokaler Wiedergabe“ auf „Nur auf lokale Dateien zugreifen“ einstellen.
  </li>
  <li>Zur Ausführung dieses Beispiels müssen Sie eine Datei mit dem Namen „TextFile.txt“ in dem Verzeichnis ablegen, in dem sich die SWF-Datei befindet. Wenn Sie möchten, dass in diesem Beispiel Binär- oder URL-kodierte Datendateien ermittelt werden, müssen Sie die Datei im entsprechenden Datenformat bereitstellen und „TextFile.txt“ in den Namen und den Speicherort der neuen Datei ändern.</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderDataFormatExample extends Sprite {
        private var source:String = "TextFile.txt";
        private var dataFormat:String = URLLoaderDataFormat.TEXT;
        
        public function URLLoaderDataFormatExample () {
            var loader:URLLoader = new URLLoader();
            loader.dataFormat = dataFormat;
            configureListeners(loader);
            var request:URLRequest = new URLRequest(source);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Error loading requested document: " + source);
            }
        }

        private function configureListeners(dispatcher:URLLoader):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            switch(loader.dataFormat) {
                case URLLoaderDataFormat.TEXT :
                    trace("completeHandler (text): " + loader.data);
                    break;
                case URLLoaderDataFormat.BINARY :
                    trace("completeHandler (binary): " + loader.data);
                    break;
                case URLLoaderDataFormat.VARIABLES :
                    trace("completeHandler (variables): " + loader.data);
                    break;
            }
        }

        private function httpStatusHandler(event:Event):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.net:URLLoaderDataFormat:BINARY"><apiName>BINARY</apiName><shortdesc>
	 Gibt an, dass heruntergeladene Daten als unformatierte Binärdaten empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass heruntergeladene Daten als unformatierte Binärdaten empfangen werden.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:TEXT"><apiName>TEXT</apiName><shortdesc>
	 Gibt an, dass heruntergeladene Daten als Text empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass heruntergeladene Daten als Text empfangen werden.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:VARIABLES"><apiName>VARIABLES</apiName><shortdesc>
	 Gibt an, dass heruntergeladene Daten als URL-kodierte Variablen empfangen werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>variables</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass heruntergeladene Daten als URL-kodierte Variablen empfangen werden.
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayTransitions"><apiName>NetStreamPlayTransitions</apiName><shortdesc>
 
 Die NetStreamPlayTransitions-Klasse legt die gültigen Strings fest, die mit der NetStreamPlayOptions.transition-Eigenschaft verwendet werden können.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Die NetStreamPlayTransitions-Klasse legt die gültigen Strings fest, die mit der NetStreamPlayOptions.transition-Eigenschaft verwendet werden können. Diese Strings steuern das Verhalten, das je nach dem verwendeten Übergangsmodus für den Übergang zu einem neuen Stream oder zur Wiedergabe eines Streams benutzt wird.
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links><apiValue id="flash.net:NetStreamPlayTransitions:APPEND"><apiName>APPEND</apiName><shortdesc>
	 
	 Fügt den Stream einer Wiedergabeliste hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>append</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Fügt den Stream einer Wiedergabeliste hinzu. Dieser Modus tut das Gleiche wie die <codeph>NetStream.play()</codeph>-Methode, wenn der <codeph>reset</codeph>-Merker auf <codeph>false</codeph> gesetzt ist.
	 
	 <p>In diesem Modus setzt Flash Media Server den in <codeph>NetStreamPlayOptions.streamName</codeph> angegebenen Stream am Ende der Wiedergabeliste nach oben in die Liste und ignoriert den <codeph>NetStreamPlayOptions.oldStreamName</codeph>-Parameter.</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:RESET"><apiName>RESET</apiName><shortdesc>
	 
	 Löscht alle vorherigen Abspielaufrufe und spielt den festgelegten Stream sofort ab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reset</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Löscht alle vorherigen Abspielaufrufe und spielt den festgelegten Stream sofort ab. Dieser Modus tut das Gleiche wie die <codeph>NetStream.play()</codeph>-Methode, wenn der <codeph>reset</codeph>-Merker auf <codeph>true</codeph> (das Standardverhalten für <codeph>NetStream.play()</codeph>) gesetzt ist.
	 
	 <p>In diesem Modus wird der momentan wiedergegebene Stream gelöscht und der in <codeph>NetStreamPlayOptions.streamName</codeph> wird wiedergegeben. Der <codeph>NetStreamPlayOptions.oldStreamName</codeph>-Parameter wird ignoriert.</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:STOP"><apiName>STOP</apiName><shortdesc>
	 
	 Stoppt das Abspielen von Streams in einer Wiedergabeliste.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>stop</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Stoppt das Abspielen von Streams in einer Wiedergabeliste. Dieser Modus hat den gleichen Effekt, als wenn <codeph>NetStream.play(false)</codeph> aufgerufen würde. Er stoppt die Wiedergabeliste und setzt sie zurück.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWAP"><apiName>SWAP</apiName><shortdesc>
	 Ersetzt einen Inhalts-Stream durch einen anderen Inhalts-Stream und behält den Rest der Wiedergabeliste bei.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>swap</apiData><apiType value=""/></apiValueDef><apiDesc>
	 Ersetzt einen Inhalts-Stream durch einen anderen Inhalts-Stream und behält den Rest der Wiedergabeliste bei.
	 
	 <p>Wie <codeph>SWITCH</codeph> ersetzt dieser Modus den in <codeph>NetStreamPlayOptions.oldStreamName</codeph> angegebenen Stream durch den in <codeph>NetStreamPlayOptions.streamName</codeph> angegebenen Stream. Der Rest der Wiedergabeliste wird beibehalten. In diesem Modus trifft Flash Media Server keine Annahmen über den Inhalt der Streams und behandelt sie wie verschiedene Inhalte. Wenn <codeph>oldStreamName</codeph> noch nicht gesendet wurde, führt der Server den Wechsel an der Stream-Grenze durch und sendet die Bits für <codeph>streamName</codeph> vom Anfang. Wenn der Server bereits damit begonnen hat, die Bits für <codeph>oldStreamName</codeph> zu senden, wechselt er nicht zu <codeph>streamName</codeph> und löst ein <codeph>NetStream.Play.Failed</codeph>-Ereignis aus.</p>
	 
	 <p>Verwenden Sie diesen Modus, wenn die Streams, die Sie wechseln möchten, nicht zueinander gehören und verschiedene Inhalte oder Längen haben. Ein Beispiel ist der Austausch einer Werbung gegen eine andere basierend auf Benutzerverfolgungs- und Anzeigestatistiken für zuvor angesehene Werbung.</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWITCH"><apiName>SWITCH</apiName><shortdesc>
	 Wechselt von der Wiedergabe eines Streams zur Wiedergabe eines anderen Streams. Dies gilt normalerweise für Streams mit gleichem Inhalt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>switch</apiData><apiType value=""/></apiValueDef><apiDesc>
	 Wechselt von der Wiedergabe eines Streams zur Wiedergabe eines anderen Streams. Dies gilt normalerweise für Streams mit gleichem Inhalt. Geben Sie die Streams, die gewechselt werden sollen, in <codeph>NetStreamPlayOptions.oldStreamName</codeph> und <codeph>NetStreamPlayOptions.streamName</codeph> an. 
	 
	 <p>Verwenden Sie diesen Modus, wenn Sie zu einem Stream wechseln möchten, der den gleichen Inhalt hat, aber mit einer anderen Bitrate oder Auflösung kodiert ist. Verwenden Sie diesen Modus beispielsweise, wenn die Anwendung Streams in die Warteschlange einer Wiedergabeliste setzt oder einen einzelnen Stream mit einer bestimmten Bitrate wiedergibt und dann berechnet, dass die Bandbreitenverfügbarkeit oder die CPU-Kapazität entweder geringer oder höher als die Stream-Anforderungen ist. Die Anwendung kann dann die Streams mit ihrer höheren oder niedrigeren Bitratenversion aktualisieren.</p>
	 
	 <p>In diesem Modus trifft Flash Media Server bestimmte Annahmen über die Beziehung zwischen dem <codeph>oldStreamName</codeph>- und dem <codeph>streamName</codeph>-Stream. Der Server nimmt an, dass die Streams den gleichen Inhalt enthalten und das gleiche Keyframeintervall, aber verschiedene Auflösungen oder Bitraten haben.</p>
	 
	 <p>Wenn Streams in die Warteschlange einer Wiedergabeliste gesetzt wurden und <codeph>oldStreamName</codeph> einer der Streams in der Wiedergabeliste ist oder gerade abgespielt wird, wird <codeph>oldStreamName</codeph>durch <codeph>streamName</codeph> ersetzt.</p>
	 
	 <p>Wenn <codeph>oldStreamName</codeph> null oder undefiniert ist oder nicht in der Wiedergabeliste gefunden wird, wechselt der Server am nächsten logischen Punkt (um einen glatten Übergang zu gewährleisten) zu <codeph>streamName</codeph>.</p>
	 
	 <p>Um von einem Stream zu einem anderen mit anderem Inhalt zu wechseln, verwenden Sie stattdessen den <codeph>RESET</codeph>-Modus.</p>
	 
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetConnection"><apiName>NetConnection</apiName><shortdesc>
 Die NetConnection-Klasse erstellt eine bidirektionale Verbindung zwischen einer Flash Player- oder einer AIR-Anwendung und einer Flash Media Server-Anwendung bzw. zwischen einer Flash Player- oder AIR-Anwendung und einem Anwendungsserver, auf dem Flash Remoting ausgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection, Video, Responder
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die NetConnection-Klasse erstellt eine bidirektionale Verbindung zwischen <ph platform="actionscript">einer Flash Player- oder AIR </ph><ph platform="javascript">einer AIR</ph>-Anwendung und einer Flash Media Server-Anwendung bzw. zwischen einer <ph platform="actionscript">Flash Player- oder AIR</ph><ph platform="javascript">einer AIR</ph>-Anwendung und einem Anwendungsserver, auf dem Flash Remoting ausgeführt wird. Ein NetConnection-Objekt kann als Verbindung zwischen dem Client und dem Server betrachtet werden. Verwenden Sie NetStream-Objekte, um Streams über diese Verbindung zu senden. 
 <p>Erstellen Sie ein Responder-Objekt und übergeben Sie es als Parameter für <codeph>NetConnection.call()</codeph>, um Rückgabewerte vom Server bezüglich Erfolg oder Fehler bei bestimmten Vorgängen zu verarbeiten.</p>  
 <p>
 Ohne Flash Media Server können Sie die NetConnection-Klasse verwenden, um Video- und MP3-Dateien aus einem lokalen Dateisystem oder von einem Webserver abzuspielen.
 </p>
 
 <p>
 Informationen zu unterstützten Codecs und Dateiformaten finden Sie unter <xref href="http://www.adobe.com/go/hardware_scaling_de" scope="external">http://www.adobe.com/go/hardware_scaling_de</xref> und in der <xref href="http://www.adobe.com/support/documentation" scope="external">Flash Media Server-Dokumentation</xref>.
 </p>
 
 <p>Beachten Sie bei Verwendung der NetConnection-Klasse das folgende Sicherheitsmodell von:</p>
 
 <ul>
 <li>Das Laden und Wiedergeben von Audio- oder Videodateien ist nicht zulässig, wenn sich die aufrufende Datei in einer Netzwerk-Sandbox befindet und die zu ladende Datei lokal gespeichert ist.</li>
 
 	<li>In der Standardeinstellung ist das Laden und Wiedergeben von Audio- oder Videodateien nicht zulässig, wenn die aufrufende Datei lokal gespeichert ist und versucht, eine Remote-Datei zu laden und wiederzugeben. Benutzer müssen für diesen Vorgang eine explizite Berechtigung erteilen.</li>
 </ul>
 
 <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
 
 <p>Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
 
 <ul>
 
 <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
 
 <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li> 
 </ul>
 
 
 <p platform="actionscript"><b>Hinweis</b>: Diese Klasse war in ActionScript 2.0 dynamisch, ist jedoch jetzt versiegelt (d. h. nicht dynamisch). Zum Schreiben von Callback-Methoden für diese Klasse können Sie entweder die Klasse erweitern und die Callback-Methoden in der Unterklasse definieren oder mit der Eigenschaft <codeph>client</codeph> auf ein Objekt verweisen und die Callback-Methoden in diesem Objekt definieren.</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> Im folgenden Beispiel wird ein Videoobjekt mit den Klassen NetConnection und NetStream verwendet, um eine FLV-Datei zu laden und abzuspielen. Zur Ausführung dieses Beispiels benötigen Sie eine FLV-Datei, deren Name und Speicherort mit der an <codeph>videoURL</codeph> übergebenen Variablen übereinstimmt. In diesem Fall ist das eine FLV-Datei mit dem Namen „Video.flv“, die in dem Verzeichnis abgelegt ist, in dem sich die SWF-Datei befindet.
 <p>In diesem Fall wird der Code zur Erstellung des Video- und NetStream-Objekts und zum Aufrufen der Methoden <codeph>Video.attachNetStream()</codeph> und <codeph>NetStream.play()</codeph> in eine Prozedurfunktion eingefügt. Die Prozedur wird nur aufgerufen, wenn die Verbindung mit dem NetConnection-Objekt erfolgreich hergestellt werden kann, d. h. wenn das Ereignis <codeph>netStatus</codeph> ein <codeph>info</codeph>-Objekt mit einer <codeph>code</codeph>-Eigenschaft zurückgibt, die Erfolg angibt. Es wird empfohlen, die erfolgreiche Verbindungsherstellung abzuwarten, bevor Sie <codeph>NetStream.play()</codeph> aufrufen. </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.net.xml#NetConnection/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Wird ausgelöst, wenn der Status oder die Fehlerbedingung eines NetConnection-Objekts protokolliert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn der Status oder die Fehlerbedingung eines NetConnection-Objekts protokolliert wird. Das Ereignis <codeph>netStatus</codeph> enthält die Eigenschaft <codeph>info</codeph>. Dabei handelt es sich um ein Informationsobjekt mit spezifischen Informationen über das Ereignis, z. B., ob ein Verbindungsversuch erfolgreich war oder fehlgeschlagen ist. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Wird ausgelöst, wenn mit einem Aufruf von „NetConnection.call()“ versucht wird, eine Verbindung mit einem Server außerhalb der Sicherheitssandbox des Aufrufers herzustellen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn mit einem Aufruf von <codeph>NetConnection.call()</codeph> versucht wird, eine Verbindung mit einem Server außerhalb der Sicherheitssandbox des Aufrufers herzustellen.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Netzwerkvorgang fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird beim Auftreten eines I/O-Fehlers ausgelöst, durch den ein Netzwerkvorgang fehlschlägt. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron, d. h. aus nativem asynchronem Code ausgelöst wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn eine Ausnahme asynchron ausgelöst wird – das heißt, aus nativem asynchronem Code. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:NetConnection:NetConnection"><apiName>NetConnection</apiName><shortdesc>
     Erstellt ein NetConnection-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>See the example for <code>connect()</code>.
     
     </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Erstellt ein NetConnection-Objekt. Rufen Sie <codeph>connect()</codeph> auf, um eine Verbindung herzustellen.
     
	 <p>Wenn die Kommunikation einer Anwendung mit älteren Serverversionen als Flash Player 9 erforderlich ist, müssen Sie u. U. die Eigenschaft <codeph>objectEncoding</codeph> des NetConnection-Objekts einstellen.</p>
     
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>flash.net.NetConnection.connect()</linktext></link><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>objectEncoding</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetConnection:addHeader"><apiName>addHeader</apiName><shortdesc>
     Fügt der Action Message Format (AMF)-Paketstruktur eine Kontextkopfzeile hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>IMD: This method can be used in the client Flash Player for Flash Remoting
     and Flex apps. It is also a server side method used by Flash Media Server apps.
     
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Identifiziert den Header und die damit verknüpften ActionScript-Objektdaten.
     
     </apiDesc></apiParam><apiParam><apiItemName>mustUnderstand</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Der Wert <codeph>true</codeph> gibt an, dass der Server diesen Header vor der Verarbeitung der darauf folgenden Header oder Meldungen erkennen und verarbeiten muss.
     </apiDesc></apiParam><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein beliebiges ActionScript-Objekt.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Fügt der Action Message Format (AMF)-Paketstruktur eine Kontextkopfzeile hinzu. Dieser Header wird mit allen weiteren AMF-Paketen gesendet. Wenn Sie die <codeph>NetConnection.addHeader()</codeph>-Methode mit demselben Namen aufrufen, wird der vorhandene Header durch den neuen Header ersetzt, der für die Dauer des NetConnection-Objekts erhalten bleibt. Sie können einen Header entfernen, indem Sie die <codeph>NetConnection.addHeader()</codeph>-Methode mit dem Namen des Headers aufrufen.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetConnection:call"><apiName>call</apiName><shortdesc>
     Ruft auf Flash Media Server oder auf einem Anwendungsserver, auf dem Flash Remoting ausgeführt wird, einen Befehl oder eine Methode auf.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Eine in der Form <codeph>[objectPath/]method</codeph> angegebene Methode. Beispiel: Der Befehl <codeph>someObject/doSomething</codeph> fordert den Remote-Server auf, die <codeph>clientObject.someObject.doSomething()</codeph>-Methode mit allen optionalen <codeph>... arguments</codeph>-Parametern aufzurufen. Wenn der Objektpfad fehlt, wird die <codeph>clientObject.doSomething()</codeph>-Methode auf dem Remote-Server aufgerufen.
     <p>
     Mit Flash Media Server ist <codeph>command</codeph> der Name einer Funktion, die im serverseitigen Skript einer Anwendung definiert ist. Sie brauchen vor <codeph>command</codeph> keinen Objektpfad zu verwenden, wenn sich das serverseitige Skript im Stammverzeichnis der Anwendung befindet.
     </p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiDesc>Ein optionales Objekt, das zur Verarbeitung der vom Server zurückgegebenen Werte verwendet wird. Für das Responder-Objekt können zwei Methoden zur Verarbeitung der zurückgegebenen Ergebnisse definiert werden: <codeph>result</codeph> und <codeph>status</codeph>. Bei Rückgabe eines Fehlers wird <codeph>status</codeph> aufgerufen, andernfalls <codeph>result</codeph>. Das Responder-Objekt verarbeitet Fehlermeldungen, die sich auf bestimmte Operationen beziehen, wohingegen das NetConnection-Objekt auf Fehlermeldungen reagiert, die sich auf den Verbindungsstatus beziehen.
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Optionale Argumente, die einen beliebigen ActionScript-Typ aufweisen können, einschließlich eines Verweises auf ein anderes ActionScript-Objekt. Diese Argumente werden an die im Parameter <codeph>command</codeph> angegebene Methode übergeben, wenn die Methode auf dem Remote-Anwendungsserver ausgeführt wird.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ruft auf Flash Media Server oder auf einem Anwendungsserver, auf dem Flash Remoting ausgeführt wird, einen Befehl oder eine Methode auf. Bevor Sie <codeph>NetConnection.call()</codeph> aufrufen, müssen Sie <codeph>NetConnection.connect()</codeph> aufrufen, um die Verbindung zum Server herzustellen. Sie müssen eine serverseitige Funktion erstellen, die an diese Methode übergeben wird. 
     
      <p>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection:call_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Mit einem Aufruf wurde versucht, mit einem Server außerhalb der Sicherheitssandbox des Aufrufers zu kommunizieren. Sie können dieses Problem umgehen, indem Sie eine Richtliniendatei auf dem entsprechenden Server verwenden.
     </apiDesc></adobeApiEventDetail><shortdesc>Mit einem Aufruf wurde versucht, mit einem Server außerhalb der Sicherheitssandbox des Aufrufers zu kommunizieren.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetConnection:close"><apiName>close</apiName><shortdesc>
     Schließt die lokal oder zum Server geöffnete Verbindung und löst ein netStatus-Ereignis mit der code-Eigenschaft „NetConnection.Connect.Closed“ aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Schließt die lokal oder zum Server geöffnete Verbindung und löst ein <codeph>netStatus</codeph>-Ereignis mit der <codeph>code</codeph>-Eigenschaft <codeph>NetConnection.Connect.Closed</codeph> aus.
     
     <p>
     Mit dieser Methode werden alle NetStream-Objekte, die über die Verbindung ausgeführt werden, getrennt. Alle Daten in der Warteschlange, die noch nicht gesendet wurden, werden verworfen. (Um lokale oder serverbasierte Streams zu beenden, ohne die Verbindung zu schließen, verwenden Sie <codeph>NetStream.close()</codeph>.) Wenn Sie die Verbindung schließen und dann eine neue erstellen möchten, müssen Sie ein neues NetConnection-Objekt erstellen und dann erneut die <codeph>connect()</codeph>-Methode aufrufen.
     </p>
     
     <p>Die <codeph>close</codeph>-Methode trennt außerdem alle gemeinsamen Remote-Objekte, die diese Verbindung verwenden. Zur erneuten Verbindungsherstellung müssen Sie das gemeinsame Objekt jedoch nicht neu erstellen. Rufen Sie stattdessen die <codeph>SharedObject.connect()</codeph>-Methode auf, um die Verbindung mit dem gemeinsamen Objekt wiederherzustellen. Nach der Wiederherstellung der Verbindung mit dem gemeinsamen Objekt werden außerdem alle Daten, die sich beim Aufruf von <codeph>NetConnection.close()</codeph> in der Warteschlange befanden, gesendet.</p>
     
     <p>
     Mit Flash Media Server ist es beim Entwickeln am besten, <codeph>close()</codeph> aufzurufen, wenn der Client die Verbindung zum Server nicht mehr benötigt. Das Aufrufen von <codeph>close()</codeph> ist die schnellste Möglichkeit, nicht verwendete Verbindungen zu schließen. Sie können die Server als Backup-Maßnahme so konfigurieren, dass nicht verwendete Verbindungen geschlossen werden. Weitere Informationen finden Sie im·<i><xref href="http://www.adobe.com/support/documentation" scope="external">Flash Media Server Configuration and Administration Guide</xref></i>. 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetConnection:connect"><apiName>connect</apiName><shortdesc>
     Erstellt eine bidirektionale Verbindung zwischen einer Flash Player oder AIR einer AIR-Anwendung und einer Flash Media Server-Anwendung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection.connect, connect
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der an den Parameter <codeph>command</codeph> übergebene URI hat ein ungültiges Format.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Die Verbindung ist fehlgeschlagen. Dieser Fall kann eintreten, wenn Sie <codeph>connect()</codeph> über eine <codeph>netStatus</codeph>-Ereignisprozedur aufrufen, was nicht zulässig ist.
     
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Über lokale SWF-Dateien im Dateisystem kann keine Verbindung mit dem Internet hergestellt werden. Sie können dieses Problem vermeiden, indem Sie die entsprechende Datei als lokal mit Netzwerkzugang oder als vertrauenswürdig klassifizieren.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Beim Versuch, eine Verbindung mit einem normalerweise reservierten Port herzustellen. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel „Sicherheit“ im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Setzen Sie diesen Parameter auf <codeph>null</codeph>, wenn Sie eine Verbindung zu einer Videodatei auf dem lokalen Computer herstellen. Wenn Sie eine Verbindung zu einem Server herstellen, setzen Sie diesen Parameter auf den URI der Anwendung auf dem Server, die die Videodatei enthält. Verwenden Sie die folgende Syntax (Elemente in eckigen Klammern sind optional):
     
     <p><codeph>protocol:[//host][:port]/appname[/instanceName]</codeph></p>
     
     <p>Um eine Verbindung mit Flash Media Server herzustellen, verwenden Sie als Protokoll <codeph>rtmp</codeph>, <codeph>rtmpe</codeph>, <codeph>rtmps</codeph>, <codeph>rtmpt</codeph>, <codeph>rtmpte</codeph> oder <codeph>rtmfp</codeph>. Wenn die Verbindung erfolgreich hergestellt wurde, wird ein <codeph>netStatus</codeph>-Ereignis mit der <codeph>code</codeph>-Eigenschaft <codeph>NetConnection.Connect.Success</codeph> zurückgegeben. Im Abschnitt über die Eigenschaft <codeph>NetStatusEvent.info</codeph> finden Sie eine Liste aller Ereigniscodes, die als Antwort auf den Aufruf von <codeph>connect()</codeph> zurückgegeben werden.
     </p>
     
     <p>Wird die Datei von demselben Host bereitgestellt, auf dem der Server installiert ist, können Sie den <codeph>host</codeph>-Parameter auslassen. Wenn Sie den <codeph>instanceName</codeph>-Parameter auslassen, stellt <ph platform="actionscript">Flash Player oder </ph>AIR eine Verbindung zur Standardinstanz der Anwendung her.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Optionale Parameter beliebigen Typs, die an die in <codeph>command</codeph> angegebene Anwendung übergeben werden. Mit Flash Media Server werden die zusätzlichen Argumente an die Ereignisprozedur <codeph>application.onConnect()</codeph> im serverseitigen Programmcode der Anwendung übergeben. Sie müssen die Argumente in <codeph>onConnect()</codeph> definieren und verarbeiten.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Erstellt eine bidirektionale Verbindung zwischen <ph platform="actionscript">einer Flash Player oder AIR</ph><ph platform="javascript">einer AIR</ph>-Anwendung und einer Flash Media Server-Anwendung. Ein NetConnection-Objekt kann als Verbindung zwischen dem Client und dem Server betrachtet werden. Verwenden Sie NetStream-Objekte, um Streams über diese Verbindung zu senden. Informationen zu den von Flash Media Server unterstützten Codecs und Dateiformaten finden Sie in der <xref href="http://www.adobe.com/support/documentation" scope="external">Flash Media Server-Dokumentation</xref>.
     
     <p>
     Ohne Flash Media Server rufen Sie <codeph>NetConnection.connect</codeph> auf, um Video- und MP3-Dateien aus einem lokalen Dateisystem oder von einem Webserver abzuspielen. Informationen zu unterstützten Codecs und Dateiformaten finden Sie unter <xref href="http://www.adobe.com/go/hardware_scaling_de" scope="external">http://www.adobe.com/go/hardware_scaling_de</xref>.
     </p>
     
     <p>
     Erstellt eine bidirektionale Verbindung zwischen <ph platform="actionscript">einer Flash Player- oder AIR-</ph> <ph platform="javascript">einer AIR-</ph>Anwendung und einem Anwendungsserver, auf dem der Flash Remoting-Dienst ausgeführt wird. Mit der NetServices-Klasse rufen Sie über ein NetConnection-Objekt Funktionen auf und Ergebnisse von Anwendungsservern auf. Weitere Informationen finden Sie in der <xref href="http://www.adobe.com/support/documentation" scope="external">Flash Remoting-Dokumentation</xref>. 
     </p>
     
	 <p>Beachten Sie bei Verwendung dieser Methode das folgende Sicherheitsmodell von:</p>
     
     <ul>
      <li>Standardmäßig lässt <ph platform="actionscript">Flash Player oder </ph>AIR Sandbox-übergreifende Zugriffe nicht zu. Eine Website kann den Zugriff auf eine Ressource gewähren, indem eine URL-Richtliniendatei verwendet wird. </li>
     
      <li>Ihre Anwendung kann den Zugriff auf eine Ressource auf dem Server verhindern. In einer Flash Media Server-Anwendung müssen Sie serverseitigen Programmcode hinzufügen, um den Zugriff zu verweigern. Weitere Informationen finden Sie in der Flash Media Server-Dokumentation. </li> 
     
      <li>Sie können <codeph>NetConnection.connect()</codeph> nicht verwenden, wenn sich die aufrufende Datei in der lokalen Sandbox des Dateisystems befindet.</li>
     
      <li>Eine Verbindung mit normalerweise reservierten Ports ist nicht möglich. Eine vollständige Liste gesperrter Ports finden Sie unter „Einschränken von Netzwerk-APIs“ im Kapitel <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">Sicherheit</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref></ph> im Handbuch <i>Programmieren mit ActionScript 3.0</i>. </li>
     
     <li>Sie können eine SWF-Datei daran hindern, diese Methode aufzurufen, indem Sie auf der HTML-Seite, die den SWF-Inhalt enthält, den Parameter <codeph>allowNetworking</codeph> der Tags <codeph>object</codeph> und <codeph>embed</codeph> festlegen.</li>
     
     </ul>
     
	 <p>In Adobe AIR unterliegt Inhalt in der Sicherheitssandbox <codeph>der Anwendung</codeph> (Inhalt, der mit der AIR-Anwendung installiert wird) nicht diesen Sicherheitseinschränkungen.</p>
	 
     <p>Weitere Informationen finden Sie in den folgenden Abschnitten:</p>
     
     <ul>
     
     <li product="flex">Das Kapitel <xref href="http://www.adobe.com/go/flex3_progAS3_security_de" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     <li product="flash">Das Kapitel <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">Sicherheit</xref> im Handbuch <i>Programmieren mit ActionScript 3.0</i> und die neuesten Kommentare in den LiveDocs.</li>
     
     <li>Der Abschnitt <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Sicherheit </xref> im Flash Player Developer Center.</li>
     </ul>
     
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetConnection:client:get"><apiName>client</apiName><shortdesc>
     Gibt das Objekt an, bei dem Callback-Methoden aufgerufen werden sollen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Die <codeph>client</codeph>-Eigenschaft muss auf ein Objekt eingestellt werden, das nicht null ist. 
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Gibt das Objekt an, bei dem Callback-Methoden aufgerufen werden sollen. Standardeinstellung ist diese NetConnection-Instanz. Wenn Sie die <codeph>client</codeph>-Eigenschaft auf ein anderes Objekt einstellen, werden die Callback-Methoden bei dem eingestellten Objekt aufgerufen.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connected:get"><apiName>connected</apiName><shortdesc>
	 Gibt an, ob die Anwendung über eine permanente RTMP-Verbindung mit einem Server verbunden ist (true) oder nicht (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob die Anwendung über eine permanente RTMP-Verbindung mit einem Server verbunden ist (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). Bei einer Verbindung mit HTTP hat diese Eigenschaft den Wert <codeph>false</codeph>, es sei denn, die Verbindung besteht zu Flash Remoting-Diensten auf einem Anwendungsserver, in welchem Fall der Wert <codeph>true</codeph> ist. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connectedProxyType:get"><apiName>connectedProxyType</apiName><shortdesc>
     Der verwendete Proxytyp, um Flash Media Server über NetConnection.connect() aufzurufen: „none“, „HTTP“, „HTTPS“ oder „CONNECT“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Es wurde versucht, ohne Verbindung der NetConnection-Instanz auf diese Eigenschaft zuzugreifen. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Der verwendete Proxytyp, um Flash Media Server über <codeph>NetConnection.connect()</codeph> aufzurufen: <codeph>„none“</codeph>, <codeph>„HTTP“</codeph>, <codeph>„HTTPS“</codeph> oder <codeph>„CONNECT“</codeph>. Der Wert ist <codeph>„none“</codeph>, wenn die Verbindung nicht über einen Tunnel erfolgt, <codeph>„HTTP“</codeph>, wenn die Verbindung über einen HTTP-Tunnel erfolgt, <codeph>„HTTPS“</codeph>, wenn die Verbindung über einen HTTPS-Tunnel erfolgt, und <codeph>„CONNECT“</codeph>, wenn die Verbindung über die HTTP CONNECT-Tunnelmethode erfolgt.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
	 Die Standard-Objektkodierung für NetConnection-Objekte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Die Standard-Objektkodierung für NetConnection-Objekte. Wenn ein Objekt in Binärdaten geschrieben oder aus Binärdaten gelesen wird, gibt die Eigenschaft <codeph>defaultObjectEncoding</codeph> an, welche Action Message Format (AMF)-Version für die Serialisierung der Daten verwendet wird: ActionScript 3.0 (<codeph>ObjectEncoding.AMF3</codeph>) oder ActionScript 1.0 und ActionScript 2.0 (<codeph>ObjectEncoding.AMF0</codeph>). 
     
     <p>Der Standardwert ist <codeph>ObjectEncoding.AMF3</codeph>. Eine Änderung der Einstellung für <codeph>NetConnection.defaultObjectEncoding</codeph> wirkt sich nicht auf bereits vorhandene NetConnection-Instanzen, sondern nur auf nach der Änderung erstellte Instanzen aus.</p>
     
     <p>Um die Objektkodierungen separat einzustellen (anstatt einer Objektkodierung für die gesamte Anwendung), verwenden Sie hingegen die Eigenschaft <codeph>objectEncoding</codeph> des NetConnection-Objekts.</p>
     
     <p>Nähere Informationen finden Sie in der Beschreibung der Eigenschaft <codeph>objectEncoding</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farID:get"><apiName>farID</apiName><shortdesc>
     Der Bezeichner der Flash Media Server-Instanz, mit dem diese Flash Player- oder Adobe AIR-Instanz verbunden ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Der Bezeichner der Flash Media Server-Instanz, mit dem diese Flash Player- oder Adobe AIR-Instanz verbunden ist. Diese Eigenschaft ist nur für RTMFP-Verbindungen von Bedeutung. Der Wert dieser Eigenschaft ist nur verfügbar, nachdem eine RTMFP-Verbindung hergestellt wurde.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/nearID"><linktext>nearID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     Ein Wert, der vom Flash Media Server ausgewählt wird und für diese Verbindung eindeutig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert, der vom Flash Media Server ausgewählt wird und für diese Verbindung eindeutig ist. Dieser Wert erscheint für den Server als <codeph>client.nearNonce</codeph>-Wert. Dieser Wert wird nur für RTMFP-, RTMPE- und RTMPTE-Verbindungen definiert.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:maxPeerConnections:get"><apiName>maxPeerConnections</apiName><shortdesc>
     Die Anzahl der eingehenden und ausgehenden Peer-Verbindungen, die diese Instanz von Flash Player oder Adobe AIR zulässt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Die Anzahl der eingehenden und ausgehenden Peer-Verbindungen, die diese Instanz von Flash Player oder Adobe AIR zulässt. Der Standardwert ist 8. 
     <p>Dieser Wert unterscheidet nicht zwischen Herausgeber- und Abonnenten-Verbindungen. Wenn dieser Wert verringert wird, während Peer-Verbindungen vorhanden sind, wirkt sich der neue Wert nur auf neu eingehende Verbindungen aus. Bestehende Verbindungen werden nicht fallen gelassen.</p>
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:nearID:get"><apiName>nearID</apiName><shortdesc>
     Die ID dieser Flash Player- oder Adobe AIR-Instanz für diese NetConnection-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Die ID dieser Flash Player- oder Adobe AIR-Instanz für diese NetConnection-Instanz. Diese Eigenschaft ist nur für RTMFP-Verbindungen von Bedeutung.
     
     <p>Jede NetConnection-Instanz hat eine eindeutige <codeph>nearID</codeph>-Eigenschaft. Keine Flash Player-, Adobe AIR- oder NetConnection-Instanz hat die gleiche ID.</p>
     
     <p>Andere Flash Player- oder Adobe AIR-Instanzen verwenden diese ID als <codeph>peerID</codeph> für neue NetStream-Verbindungen für diesen Client. Somit ist diese ID die <codeph>farID</codeph> für alle Peer-NetStreams, die eine Verbindung zu dieser Instanz herstellen.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/farID"><linktext>farID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     Ein Wert, der von dieser Flash Player- oder Adobe AIR-Instanz ausgewählt wird und für diese Verbindung eindeutig ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ein Wert, der von dieser Flash Player- oder Adobe AIR-Instanz ausgewählt wird und für diese Verbindung eindeutig ist. Dieser Wert erscheint für den Server als <codeph>client.farNonce</codeph>-Wert. Dieser Wert wird nur für RTMFP-, RTMPE- und RTMPTE-Verbindungen definiert.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Die Objektkodierung für diese NetConnection-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Es wurde versucht, bei bereits hergestellter Verbindung der NetConnection-Instanz den Wert der Eigenschaft <codeph>objectEncoding</codeph> einzustellen.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiException><apiDesc>Für diese Eigenschaft wurde ein anderer Wert als <codeph>ObjectEncoding.AMF0</codeph> oder <codeph>ObjectEncoding.AMF3</codeph> eingestellt.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Die Objektkodierung für diese NetConnection-Instanz.
     
     <p>
     Wenn ein Objekt in Binärdaten geschrieben oder aus Binärdaten gelesen wird, gibt die <codeph>defaultObjectEncoding</codeph>-Eigenschaft an, welche Action Message Format (AMF)-Version für die Serialisierung der Daten verwendet werden soll: ActionScript 3.0 (<codeph>ObjectEncoding.AMF3</codeph>) oder ActionScript 1.0 und ActionScript 2.0 (<codeph>ObjectEncoding.AMF0</codeph>). Stellen Sie die <codeph>objectEncoding</codeph>-Eigenschaft ein, um eine AMF-Version für eine NetConnection-Instanz festzulegen.
     </p>
     
	 <p>Es ist wichtig, die Funktionsweise dieser Eigenschaft zu verstehen, wenn die Kommunikation der Anwendung mit Servern erforderlich ist, die eine ältere Version als Flash Player 9 aufweisen. Die folgenden drei Szenarios sind möglich:
     </p>
     
     <ul>
	 <li>Verbindung mit einem Server, der AMF3 unterstützt (zum Beispiel Flex Data Services 2 oder Flash Media Server 3). Der Standardwert für <codeph>defaultObjectEncoding</codeph> ist <codeph>ObjectEncoding.AMF3</codeph>. Alle in dieser Datei erstellten NetConnection-Instanzen verwenden die AMF3-Serialisierung, deshalb brauchen Sie die <codeph>objectEncoding</codeph>-Eigenschaft nicht festzulegen.</li>
       
     <li>Verbindung mit einem Server, der AMF nicht unterstützt (zum Beispiel Flash Media Server 2). Setzen Sie in diesem Fall die statische Eigenschaft <codeph>NetConnection.defaultObjectEncoding</codeph> auf <codeph>ObjectEncoding.AMF0</codeph>. Für alle in dieser SWF-Datei erstellten NetConnection-Instanzen wird die AMF0-Serialisierung verwendet. Die Eigenschaft <codeph>objectEncoding</codeph> muss nicht gesetzt werden. </li>
     
     <li>Herstellung einer Verbindung zu mehreren Servern mit verschiedenen Kodierungsversionen. Anstatt <codeph>defaultObjectEncoding</codeph> zu verwenden, legen Sie die Objektkodierung pro Verbindung fest, indem Sie die Eigenschaft <codeph>objectEncoding</codeph> für jede einzelne Verbindung verwenden. Setzen Sie die Eigenschaft für die Verbindung mit Servern, die AMF0-Kodierung verwenden (z. B. Flash Media Server 2), auf <codeph>ObjectEncoding.AMF0</codeph>, und für die Verbindung mit Servern, die AMF3-Kodierung verwenden (z. B. Flex Data Services 2), auf <codeph>ObjectEncoding.AMF3</codeph>.</li>
     </ul>
     
     <p>Sobald die Verbindung für eine NetConnection-Instanz hergestellt ist, kann die Eigenschaft <codeph>objectEncoding</codeph> nicht mehr geändert werden.</p>
     
	 <p>Wenn Sie die falsche Kodierung für die Herstellung einer Serververbindung verwenden, löst das NetConnection-Objekt das <codeph>netStatus</codeph>-Ereignis. Die <codeph>NetStatusEvent.info</codeph>-Eigenschaft enthält ein Informationsobjekt mit dem <codeph>code</codeph>-Eigenschaftswert <codeph>NetConnection.Connect.Failed</codeph> und einer Beschreibung, die angibt, dass die Objektkodierung ungültig ist.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:protocol:get"><apiName>protocol</apiName><shortdesc>
     Das Protokoll, das zur Herstellung der Verbindung verwendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Es wurde versucht, ohne Verbindung der NetConnection-Instanz auf diese Eigenschaft zuzugreifen. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Das Protokoll, das zur Herstellung der Verbindung verwendet wird. Diese Eigenschaft ist relevant, wenn Flash Media Server verwendet wird. Mögliche Werte sind wie folgt:
     <ul>
     <li><codeph>"rtmp"</codeph>: Real-Time Messaging Protocol (RTMP)</li>
     <li><codeph>"rtmpe"</codeph>: Verschlüsseltes RTMP</li>
     <li><codeph>"rtmpt"</codeph>: RTMP über HTTP-Tunnel</li>
     <li><codeph>"rtmpte"</codeph>: Verschlüsseltes RTMP über HTTP-Tunnel</li>
     <li><codeph>"rtmps"</codeph>: HTTPS-basiertes RTMP</li>
     <li><codeph>"rtmfp"</codeph>: Real-Time Media Flow Protocol (RTMFP)</li>
     </ul>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:proxyType:get"><apiName>proxyType</apiName><shortdesc>
     Gibt an, welche Fallback-Methoden ausprobiert werden sollen, wenn ein anfänglicher Verbindungsversuch zum Server fehlschlägt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5. In the Breeze Add-in, the default value is <code>"best"</code>; if this value
     is not changed, native SSL sockets are used by default, and a fallback
     to other methods is used if necessary. 
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt an, welche Fallback-Methoden ausprobiert werden sollen, wenn ein anfänglicher Verbindungsversuch zum Server fehlschlägt. Sie müssen einen Wert für die <codeph>proxyType</codeph>-Eigenschaft festlegen, bevor Sie die <codeph>NetConnection.connect()</codeph>-Methode aufrufen.
     
     <p>Gültige Werte sind <codeph>„none“</codeph>, <codeph>"HTTP"</codeph>, <codeph>„CONNECT“</codeph> und <codeph>„best“</codeph>.</p>
     
	 <p>Der Standardwert für diese Eigenschaft ist <codeph>„none“</codeph>. Wenn Sie diesen Wert nicht ändern, verwendet die Anwendung HTTPS-Tunnel für RTMPS. Wenn die Eigenschaft auf <codeph>„best“</codeph> gesetzt wird, versucht der Client, die Verbindung über native SSL herzustellen. Kann die Verbindung nicht hergestellt werden, werden andere Verbindungsmethoden probiert. Wenn für die Eigenschaft der Wert <codeph>„HTTP“</codeph> eingestellt ist und eine direkte Verbindung fehlschlägt, wird HTTP-Tunneling verwendet. Wenn für die Eigenschaft der Wert <codeph>„CONNECT“</codeph> eingestellt ist und eine direkte Verbindung fehlschlägt, wird die Tunneling-Methode <codeph>CONNECT</codeph> verwendet. Wenn diese Methode ebenfalls fehlschlägt, erfolgt kein Fallback auf HTTP-Tunneling.</p>
     
     <p>Diese Eigenschaft ist nur bei Verwendung von RTMP, RTMPS oder RTMPT anwendbar. Die <codeph>CONNECT</codeph>-Methode kann nur bei Benutzern angewendet werden, die über einen Proxyserver mit dem Netzwerk verbunden sind.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:unconnectedPeerStreams:get"><apiName>unconnectedPeerStreams</apiName><shortdesc>
     
     Ein Objekt, das alle Peer-Subscriber-NetStream-Objekte enthält, die nicht mit Publishing-NetStream-Objekten verknüpft sind.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     
     Ein Objekt, das alle Peer-Subscriber-NetStream-Objekte enthält, die nicht mit veröffentlichenden NetStream-Objekten verknüpft sind. NetStream-Abonnentenobjekte, die mit veröffentlichenden NetStream-Objekten verknüpft sind, sind im <codeph>NetStream.peerStreams</codeph>-Array.
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/peerStreams"><linktext>NetStream.peerStreams</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:uri:get"><apiName>uri</apiName><shortdesc>
     Der an die NetConnection.connect()-Methode übergebene URI.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Der an die <codeph>NetConnection.connect()</codeph>-Methode übergebene URI. Wenn die <codeph>NetConnection.connect()</codeph>-Methode nicht aufgerufen oder kein URI übergeben wurde, weist diese Eigenschaft den Wert <codeph>undefined</codeph> auf.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:usingTLS:get"><apiName>usingTLS</apiName><shortdesc>
     Gibt an, ob eine sichere Verbindung über TLS (Transport Layer Security) statt HTTPS hergestellt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Es wurde versucht, ohne Verbindung der NetConnection-Instanz auf diese Eigenschaft zuzugreifen. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Gibt an, ob eine sichere Verbindung über TLS (Transport Layer Security) statt HTTPS hergestellt wurde. Diese Eigenschaft ist nur gültig, wenn eine Verbindung mit einem NetConnection-Objekt besteht.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>