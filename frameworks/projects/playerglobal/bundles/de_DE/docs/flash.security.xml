<?xml version="1.0"?>
<apiPackage id="flash.security"><apiName>flash.security</apiName><apiDetail/><apiClassifier id="flash.security:XMLSignatureValidator"><apiName>XMLSignatureValidator</apiName><shortdesc>
	 Die XMLSignatureValidator-Klasse überprüft sowohl, ob eine XML-Signaturdatei gut strukturiert und unverändert ist, als auch optional, ob sie mit einem Schlüssel signiert wurde, der mit einem vertrauenswürdigen digitalen Zertifikat verknüpft ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die XMLSignatureValidator-Klasse überprüft sowohl, ob eine XML-Signaturdatei gut strukturiert und unverändert ist, als auch optional, ob sie mit einem Schlüssel signiert wurde, der mit einem vertrauenswürdigen digitalen Zertifikat verknüpft ist.
	 
	 <p>XMLSignatureValidator implementiert einen Teilsatz der W3C-Empfehlung für XML-Signatursyntax- und -verarbeitung und sollte nicht als konforme Implementierung betrachtet werden. Der unterstützte Teilsatz der Empfehlung enthält:</p>
	 <ul>
	  <li>Die gesamte Kernsignatursyntax mit Ausnahme des KeyInfo-Elements.</li>
	  <li>Das KeyInfo-Element unterstützt nur das X509Data-Element.</li>
	  <li>Das X509Data-Element unterstützt nur das X509Certificate-Element.</li>
	  <li>Der SHA256-Digestmethodenalgorithmus.</li>
	  <li>Der PKCS1-Signieralgorithmus.</li>
	  <li>Die „Canonical XML without comments“-Kanonisierungsmethode und Transformationsalgorithmus.</li>
	  <li>Das Manifest-Element in zusätzlicher Signatursyntax.</li>
	 </ul>
	 
	 <p>Sie müssen eine IURIDereferencer-Implementierung zur Verfügung stellen, um eine XML-Signatur zu verifizieren. Diese Implementierungsklasse ist zuständig für das Auflösen der URIs, die in den SignedInfo-Elementen der Signaturdatei angegeben sind und die referenzierten Daten in einem Objekt zurückgeben, zum Beispiel ein ByteArray, das die IDataInput-Schnittstelle implementiert.</p>
	 
	 <p>Um zu überprüfen, ob das Signierzertifikat mit einem vertrauenswürdigen Zertifikat verkettet ist, muss entweder die XML-Signatur die zum Bilden der Kette in X509Certificate-Elementen erforderlichen Zertifikate enthalten oder Sie müssen die zum Bilden der Kette erforderlichen Zertifikate über die <codeph>addCertificate()</codeph>-Methode bereitstellen.</p>
	 
	 <p><b>Überprüfen einer XMLSignatur:</b></p>
	 <ol>
	 <li>Erstellen Sie eine Instanz der XMLSignatureValidator-Klasse.</li>
	 <li>Stellen Sie die <codeph>uriDereferencer</codeph>-Eigenschaft der Instanz auf eine Instanz Ihrer IURIDereferencer-Implementierungsklasse ein.</li>
	 <li>(Optional) Stellen Sie über die <codeph>addCertificate()</codeph>-Methode DER-kodierte Zertifikate zum Bilden der vertrauenswürdigen Zertifikatkette bereit.</li>
	 <li>Rufen Sie die <codeph>verify</codeph>-Methode von XMLSignatureValidator auf, wobei Sie die zu verifizierende Signatur übergeben.</li>
	 <li>Überprüfen Sie die <codeph>validityStatus</codeph>-Eigenschaft, nachdem das XMLSignatureValidator-Objekt ein complete-Ereignis auslöst.</li>  
	 </ol>
	 
	 <p><b>Informationen zum Signaturstatus:</b></p>
	 <p>XML-Signaturen können gültig oder ungültig sein oder ihre Gültigkeit ist unbekannt. Der Gesamtstatus richtet sich nach dem Verifizierungsstatus der einzelnen Komponenten der Signaturdatei:</p>
	 <ul>
	 <li><codeph>digestStatus</codeph>: Die Gültigkeit der Kryptographie der Signatur, die über das SignedInfo-Element berechnet wird. Kann <codeph>valid</codeph>, <codeph>invalid</codeph> oder <codeph>unknown</codeph> sein.</li>
	 <li><codeph>identityStatus</codeph>: Die Gültigkeit des signierenden Zertifikats. Wenn das Zertifikat abgelaufen, zurückgenommen oder geändert wurde, ist der Status <codeph>invalid</codeph>. Wenn das Zertifikat nicht mit einem vertrauenswürdigen Stammzertifikat verbunden werden kann, ist der Status <codeph>unknown</codeph>. Das Zertifikat wird nicht überprüft, wenn der Digest ungültig ist. Bei Nichtüberprüfung wird der Status als <codeph>unknown</codeph> gemeldet.</li>
	 <li><codeph>referencesStatus</codeph>: Die Gültigkeit der Daten, auf die von den Referenzen im SignedInfo-Element der Signaturdatei verwiesen wird. Kann <codeph>valid</codeph>, <codeph>invalid</codeph> oder <codeph>unknown</codeph> sein. Die Referenzen werden nicht überprüft, wenn der Digest oder das Zertifikat ungültig ist. Die Referenzprüfung kann auch basierend auf der Einstellung der <codeph>referencesValidationSetting</codeph>-Eigenschaft übersprungen werden. Bei Nichtüberprüfung wird der Status als <codeph>unknown</codeph> gemeldet.</li>
	 </ul>
	 <p>Die von der <codeph>validityStatus</codeph>-Eigenschaft gemeldete Signaturgültigkeit kann folgende Werte aufweisen:</p>
	 <ul>
	 <li><codeph>valid</codeph>, wenn <codeph>referencesStatus</codeph>, <codeph>digestStatus</codeph> und <codeph>identityStatus</codeph> alle <codeph>valid</codeph> sind.</li>
	 <li><codeph>invalid</codeph>, wenn einer der Status <codeph>invalid</codeph> ist.</li>
	 <li><codeph>unknown</codeph>: Wenn <codeph>referencesStatus</codeph>, <codeph>digestStatus</codeph> oder <codeph>identityStatus</codeph> <codeph>unknown</codeph> ist.</li>
	 </ul>
	 
	 <p><b>Kanonisierungsbeschränkungen:</b></p>
	 <p>Die XML-Engine in AIR erzeugt beim Kanonisieren eines XML-Dokuments nicht immer den erwarteten XML-String. Aus diesem Grund wird empfohlen, keine Weißräume zwischen Elemente in umhüllten oder abgetrennten Signaturdokumenten zu setzen und Namespaces in Signaturdokumenten nicht neu zu definieren. In beiden Fällen erzeugt AIR das Dokument unter Umständen nicht mit der gleichen Zeichenfolge wie das Original und die Prüfung schlägt folglich fehl.</p>
	   
	 </apiDesc><example conref="examples\XMLSignatureValidatorExample.as"> Das folgende Beispiel lädt und überprüft eine Datei, die eine XML-Signatur enthält. Um dieses Beispiel zu verwenden, müssen Sie einen IURIDereferencer implementieren, der zu den zu überprüfenden Signaturen passt (ersetzen Sie hierzu die im Beispiel verwendete SignedMessageDereferencer-Klasse). Führen Sie das Beispiel aus, indem Sie <codeph>SignatureValidatorExample.validateSignature( signatureFile )</codeph> aufrufen und die Datei, die das zu überprüfende XML-Signaturdokument enthält, übergeben.
 
<codeblock>
import flash.events.Event;
import flash.filesystem.File;
import flash.filesystem.FileStream;
import flash.security.ReferencesValidationSetting;
import flash.security.XMLSignatureValidator; 

import com.example.SignedMessageDereferencer; //A custom class implementing IURIDereferencer

public class SignatureValidatorExample{ 
    private var xmlSig:XML;
    private const signatureNS:Namespace = new Namespace( "http://www.w3.org/2000/09/xmldsig#" );
    
    public static function validateSignature( signatureFile:File ):void{
        try{
            //Set up the XMLSignatureValidator
            var verifier:XMLSignatureValidator = new XMLSignatureValidator();
            verifier.addEventListener( Event.COMPLETE, verificationComplete );
            verifier.uriDereferencer = new SignedMessageDereferencer();
            verifier.referencesValidationSetting = ReferencesValidationSetting.VALID_OR_UNKNOWN_IDENTITY;
    
            //Load the signed document
            var sigFileStream:FileStream = new FileStream();
            sigFileStream.open( signatureFile, FileMode.READ );
            var xmlDoc:XML = XML( sigFileStream.readUTFBytes(sigFileStream.bytesAvailable) );
            
            //Get the last Signature element in the document
            if( xmlDoc.name().localName != "Signature" ){
                var signatureList:XMLList = xmlDoc..signatureNS::Signature;
                xmlSig = XML( signatureList[ signatureList.length()-1 ] );
            } else{
                xmlSig = xmlDoc;
            }
    
            //Validate the signature
            verifier.verify( xmlSig );
            
        }catch (e:Error){
            statusDisplay.text = "Verification error.\n" + e;
        }
    }
    
    private static function verificationComplete(event:Event):void{
        trace( "Signature Validity: " + verifier.validityStatus );
        trace( "Digest validity: " + verifier.digestStatus );
        trace( "Certificate validity: " + verifier.identityStatus );
        trace( "Data validity: " + verifier.referencesStatus );
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.security.xml#IURIDereferencer"><linktext>IURIDereferencer</linktext></link><link href="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/"><linktext>XML-Signatursyntax und Verarbeitung</linktext></link><link href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"><linktext>Canonical XML</linktext></link><link href="http://www.ietf.org/rfc/rfc2437.txt"><linktext>PKCS #1</linktext></link></related-links><adobeApiEvent id="flash.security:XMLSignatureValidator_flash.events.ErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
	 Wird ausgelöst, wenn die Überprüfung aufgrund von Fehlern nicht abgeschlossen werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Wird ausgelöst, wenn die Überprüfung aufgrund von Fehlern nicht abgeschlossen werden kann. 
	 
	 </apiDesc><example conref="examples\XMLSignatureValidator.error.1.as"> Das folgende Beispiel überwacht Fehlerereignisse, die von einem XMLSignatureValidator-Objekt ausgelöst werden, und verfolgt die Fehlermeldung:
<codeblock>
private function verificationError(event:ErrorEvent):void{
    trace("Verification error: " + event.text);                
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.security:XMLSignatureValidator_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	 Wird ausgelöst, wenn die Überprüfung abgeschlossen ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Wird ausgelöst, wenn die Überprüfung abgeschlossen ist.
	 
	 <p>Ein <codeph>complete</codeph>-Ereignis bedeutet nicht, dass die Signatur gültig ist. Überprüfen Sie die <codeph>validityStatus</codeph>-Eigenschaft des XMLSignatureValidator-Objekts, um das Ergebnis der Signaturüberprüfung zu ermitteln.</p>
	 
	 </apiDesc><example conref="examples\XMLSignatureValidator.complete.1.as"> Das folgende Beispiel überwacht vollständige Ergebnisse, die von einem XMLSignatureValidator-Objekt ausgelöst werden, und verfolgt die Überprüfungsergebnisse:
<codeblock>
private function verificationComplete(event:Event):void{
    var validator:XMLSignatureValidator = event.target as XMLSignatureValidator;
    trace("Digest status: " + validator.digestStatus);
    trace("Identity status: " + validator.identityStatus);
    trace("Reference status: " + validator.referencesStatus);
    trace("Signature status: " + validator.validityStatus);    
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/validityStatus"><linktext>validityStatus</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.security:XMLSignatureValidator:XMLSignatureValidator"><apiName>XMLSignatureValidator</apiName><shortdesc>
		 Erstellt ein neues XMLSignatureValidator-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Erstellt ein neues XMLSignatureValidator-Objekt.
		 
		 <p>Sie müssen die <codeph>uriDereferencer</codeph>-Eigenschaft einstellen, bevor Sie die <codeph>verify()</codeph>-Methode des neuen Objekts aufrufen.</p>
		 
		 </apiDesc><example conref="examples\XMLSignatureValidator.constructor.1.as"> Das folgende Beispiel erstellt und richtet ein neues XMLSignatureValidator-Objekt ein:
<codeblock> 
import com.example.EnvelopedDereferencer; //Your custom IURIDereferencer implementation

//Create the object
var verifier:XMLSignatureValidator = new XMLSignatureValidator();

//Provide the IURIDerferencer
verifier.uriDereferencer = new EnvelopedDereferencer(xmlDoc);

//Set validation options
verifier.referencesValidationSetting = ReferencesValidationSetting.VALID_OR_UNKNOWN_IDENTITY;
verifier.revocationCheckSetting = RevocationCheckSettings.NEVER;
verifier.useSystemTrustStore = true;

//Add listeners to handle results
verifier.addEventListener(Event.COMPLETE, verificationComplete);
verifier.addEventListener(ErrorEvent.ERROR, verificationError);
</codeblock></example></apiConstructorDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/uriDereferencer"><linktext>uriDereferencer</linktext></link></related-links></apiConstructor><apiOperation id="flash.security:XMLSignatureValidator:addCertificate"><apiName>addCertificate</apiName><shortdesc>
	   Fügt ein x509-Zertifikat für die Kettenbildung hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Aufruf während der Überprüfung einer Signatur erfolgt.
	   
	   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>cert</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Ein ByteArray-Objekt, das ein digitales DER-kodiertes x509-Zertifikat enthält.
	   </apiDesc></apiParam><apiParam><apiItemName>trusted</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Setzen Sie es auf <codeph>true</codeph>, um dieses Zertifikat als Vertrauensanker festzulegen.
	   </apiDesc></apiParam></apiOperationDef><apiDesc>
	   Fügt ein x509-Zertifikat für die Kettenbildung hinzu. 
	   
	   <p>Das hinzugefügte Zertifikat muss ein DER-kodiertes x509-Zertifikat sein.</p>
	   
	   <p>Wenn der <codeph>trusted</codeph>-Parameter den Wert <codeph>true</codeph> hat, wird das Zertifikat als Vertrauensanker angesehen.</p>
	   
	   <p><b>Hinweis:</b> Eine XML-Signatur kann Zertifikate zum Bilden der Zertifikatkette des Unterzeichners enthalten. Die XMLSignatureValidator-Klasse verwendet diese Zertifikate zur Kettenbildung, aber nicht als vertrauenswürdige Stämme (standardmäßig).</p>
	   
	   </apiDesc><example conref="examples\XMLSignatureValidator.addCertificate.1.as"> Das folgende Beispiel lädt ein Zertifikat aus dem Dateisystem und fügt es als Vertrauensanker hinzu.
<codeblock>
 import flash.utils.ByteArray;
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 var certificate:ByteArray = new ByteArray();
 
 var certFile:File = new File("certificate.cer");
 var certFileStream:FileStream = new FileStream();
 certFileStream.open(certFile, FileMode.READ);
 certFileStream.readBytes(certificate, 0, certFileStream.bytesAvailable);

 verifier.addCertificate(certificate, true);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.security:XMLSignatureValidator:verify"><apiName>verify</apiName><shortdesc>
		Überprüft die angegebene Signatur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Wenn der Aufruf während der Überprüfung einer Signatur erfolgt. 
		 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Wenn andere Fehler gefunden werden, z. B. nicht wohlgeformtes XML oder nicht unterstützte Elemente in der Signaturdatei. 
		</apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>signature</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Die XML-Signatur, die überprüft werden soll.
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Überprüft die angegebene Signatur. 
		
		<p>Die Überprüfung ist asynchron. Das XMLSignatureValidator-Objekt löst ein <codeph>complete</codeph>-Ereignis aus, wenn die Überprüfung erfolgreich abgeschlossen wird bzw. ein <codeph>error</codeph>-Ereignis, wenn die Überprüfung aufgrund von Fehlern nicht abgeschlossen werden kann.</p> 
		
		<p>Der Überprüfungsprozess kann nicht abgebrochen werden. Wenn gerade ein Überprüfungsprozess ausgeführt wird, schlagen anschließende Aufrufe der <codeph>verify()</codeph>-Methode fehl. Nach der aktuellen Überprüfung können Sie die <codeph>verify()</codeph>-Methode erneut aufrufen.</p> 
		
		<p><b>Hinweis:</b> Da der XMLSignatureValidator nur einen Teilsatz der W3C-Empfehlung für die Syntax und Verarbeitung von XML-Signaturen implementiert, können nicht alle gültigen XML-Signaturen überprüft werden.</p>
		 
		 
		</apiDesc><example conref="examples\XMLSignatureValidator.verify.1.as"> Das folgende Beispiel liest eine Datei, die eine XML-Signatur enthält, und überprüft sie durch Aufrufen der <codeph>verify()</codeph>-Methode. (Bei diesem Beispiel wird angenommen, dass die IURIDereferencer-Implementierung für die Signatur geeignet ist.)
<codeblock>
import flash.filesystem.File;
import flash.filesystem.FileStream;
import com.example.SignedMessageDereferencer; //Your IURIDereferencer implementation
 
const xmlSignatureNS:Namespace = new Namespace( "http://www.w3.org/2000/09/xmldsig#" );

var verifier:XMLSignatureValidator = new XMLSignatureValidator();
verifier.uriDereferencer = new SignedMessageDereferencer();

var signatureFile:File = new File( "path/to/XMLSignatureDocument.xml" );
var sigFileStream:FileStream = new FileStream();
sigFileStream.open( signatureFile, FileMode.READ );

var xmlDoc:XML = XML( sigFileStream.readUTFBytes(sigFileStream.bytesAvailable) );
var xmlSig:XML = XML( xmlDoc..xmlSignatureNS::Signature );

verifier.verify( xmlSig );
</codeblock></example></apiOperationDetail><adobeApiEvent id="flash.security:XMLSignatureValidator:verify_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn die Überprüfung erfolgreich abgeschlossen wurde.
		</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn die Überprüfung erfolgreich abgeschlossen wurde.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.security:XMLSignatureValidator:verify_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Wird ausgelöst, wenn bei der Überprüfung von Verweisen ein Fehler aufgetreten ist. 
		</apiDesc></adobeApiEventDetail><shortdesc>Wird ausgelöst, wenn bei der Überprüfung von Verweisen ein Fehler aufgetreten ist.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.security:XMLSignatureValidator:digestStatus:get"><apiName>digestStatus</apiName><shortdesc>
	    Der Gültigkeitsstatus der kryptographischen Signatur, die über das SignedInfo-Element berechnet wird.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Überprüfung einer Signatur erfolgt.
		 
		 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	    Der Gültigkeitsstatus der kryptographischen Signatur, die über das <codeph>SignedInfo</codeph>-Element berechnet wird.
	    
	    <p>Der Status ist:</p>
	    <ul>
	    <li><codeph>valid</codeph>: Wenn die Signatur kryptographisch gültig ist.</li>
	    <li><codeph>invalid</codeph>: Wenn der Digest nach dem Signieren geändert wurde.</li>
	    <li><codeph>unknown</codeph>: Wenn die <codeph>verify()</codeph>-Methode nicht aufgerufen wurde.</li>
		</ul>
		
		 <p><b>Hinweis:</b> Wenn der <codeph>digestStatus</codeph> ungültig ist, werden der <codeph>identityStatus</codeph> und der <codeph>referencesStatus</codeph> nicht überprüft und als <codeph>unknown</codeph> gemeldet.</p>
		 
		 </apiDesc><example conref="examples\XMLSignature.digestStatus.1.as"/></apiValueDetail></apiValue><apiValue id="flash.security:XMLSignatureValidator:identityStatus:get"><apiName>identityStatus</apiName><shortdesc>
	    Der Gültigkeitsstatus des signierenden Zertifikats.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Überprüfung einer Signatur erfolgt.
 		</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	    Der Gültigkeitsstatus des signierenden Zertifikats. 
	    
	    <p>Der Status kann sein:</p>
	    <ul>
	    <li><codeph>valid</codeph>: Das Zertifikat ist nicht abgelaufen, hat die Rücknahmeüberprüfung bestanden und ist mit einem vertrauenswürdigen Stammzertifikat verbunden.</li>
	    <li><codeph>unknown</codeph>: Das Zertifikat ist nicht abgelaufen, hat die Rücknahmeüberprüfung bestanden, ist jedoch nicht mit einem vertrauenswürdigen Stammzertifikat verbunden. Der Status<codeph>unknown</codeph> wird auch gemeldet, wenn der Status nicht überprüft wurde, weil entweder die <codeph>verify()</codeph>-Methode nicht aufgerufen wurde oder weil die kryptographische Signatur des SignedInfo-Elements (<codeph>digestStatus</codeph>) ungültig ist.</li>
	    <li><codeph>invalid</codeph>: Das Zertifikat ist abgelaufen oder hat eine Rücknahmeüberprüfung nicht bestanden.</li>
	    </ul>
	    <p>Die über die <codeph>addCertificate()</codeph>-Methode hinzugefügten Zertifikate und die Einstellungen der <codeph>revocationCheckSetting</codeph>- und der <codeph>useSystemTrustStore</codeph>-Eigenschaft können ändern, ob ein Zertifikat als gültig betrachtet wird.</p>
	    
		<p><b>Hinweis:</b> Wenn der<codeph>identityStatus</codeph> ungültig ist, wird der <codeph>referencesStatus</codeph> nicht überprüft und als <codeph>unknown</codeph> gemeldet. Außerdem werden Verweise nicht überprüft, wenn der <codeph>identityStatus</codeph> unbekannt ist, es sei denn, die <codeph>referencesValidationSetting</codeph> ist <codeph>validOrUnknownIdentity</codeph>.</p>
		
 		</apiDesc><example conref="examples\XMLSignatureValidator.identityStatus.1.as"> Das folgende Beispiel ruft das Ergebnis der Überprüfung des signierenden Zertifikats ab (nachdem eine Signatur überprüft wurde):
<codeblock>
 import flash.security.XMLSignatureValidator;
 
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 //validate a signature...
  
 var identityResult:String = verifier.identityStatus;
</codeblock></example></apiValueDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/addCertificate()"><linktext>addCertificate()</linktext></link><link href="flash.security.xml#XMLSignatureValidator/revocationCheckSetting"><linktext>revocationCheckSetting</linktext></link><link href="flash.security.xml#XMLSignatureValidator/useSystemTrustStore"><linktext>useSystemTrustStore</linktext></link><link href="flash.security.xml#XMLSignatureValidator/referencesValidationSetting"><linktext>referencesValidationSetting</linktext></link></related-links></apiValue><apiValue id="flash.security:XMLSignatureValidator:referencesStatus:get"><apiName>referencesStatus</apiName><shortdesc>
	    Der Gültigkeitsstatus der Daten in den Verweisen im SignedInfo-Element.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Überprüfung einer Signatur erfolgt.
 		</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	    Der Gültigkeitsstatus der Daten in den Verweisen im <codeph>SignedInfo</codeph>-Element.
	    
	    <p>Der Status kann sein:</p>
	    <ul>
	    <li><codeph>valid</codeph>: Wenn alle Verweise gültig sind.</li>
	    <li><codeph>invalid</codeph>: Wenn einer der Verweise ungültig ist.</li>
	    <li><codeph>unknown</codeph>: Wenn keine Überprüfung stattgefunden hat. Verweise können in den folgenden Situationen unüberprüft bleiben:
	    <ul> 
	    	<li>die <codeph>verify()</codeph>-Methode wurde nicht aufgerufen</li>
	    	<li>die kryptographische Signatur des SignedInfo-Elements (<codeph>digestStatus</codeph>) ist ungültig.</li>
	    	<li>das signierende Zertifikat (<codeph>identityStatus</codeph>) ist ungültig</li>
	    	<li><codeph>referencesValidationSetting</codeph> ist <codeph>validIdentity</codeph> (die Standardeinstellung) und der <codeph>identityStatus</codeph> des signierenden Zertifikats ist unbekannt.</li>
	    	<li>die <codeph>referencesValidationSetting</codeph> ist <codeph>never</codeph>.</li>
	    </ul>
	    </li>
		</ul>
		
		 <p><b>Wichtig:</b> Externe Ressourcen werden nur überprüft, wenn sie direkt in einem SignedInfo-Element innerhalb des Signaturdokuments referenziert werden. Externe Ressourcen, auf die von einer sekundären Referenz verwiesen wird, werden nicht überprüft. Wenn z. B. eine XML-Signatur ein Manifest-Element signiert, wird nur die Integrität des Manifest-Elements selbst überprüft. Die im Manifest aufgelisteten Dateien werden nicht überprüft.</p>
		 
		</apiDesc><example conref="examples\XMLSignatureValidator.referencesStatus.1.as"> Das folgende Beispiel ruft das Ergebnis der Überprüfung der Verweise in der Signatur ab (nachdem eine Signatur überprüft wurde):
<codeblock>
 import flash.security.XMLSignatureValidator;
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 //validate a signature...
  
 var dataResult:String = verifier.referencesStatus;
</codeblock></example></apiValueDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/referencesValidationSetting"><linktext>referencesValidationSetting</linktext></link></related-links></apiValue><apiValue id="flash.security:XMLSignatureValidator:referencesValidationSetting:set"><apiName>referencesValidationSetting</apiName><shortdesc>
	    Gibt die Bedingungen an, unter denen Verweise überprüft werden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Validierung einer Signatur erfolgt.
		 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>wenn der <codeph>setting</codeph>-Parameter einen Wert enthält, der nicht in der ReferencesValidationSetting-Klasse definiert ist.
		 
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	    Gibt die Bedingungen an, unter denen Verweise überprüft werden.
		
		 <p>Verwenden Sie Konstanten, die in der ReferencesValidationSetting-Klasse definiert sind, um die Eigenschaft festzulegen. Zu diesen Einstellungen gehören:</p>
		 <ul>	
		 <li><codeph>ReferencesValidationSetting.VALID_IDENTITY</codeph>: Verweise werden nur überprüft, wenn das signierende Zertifikat gültig und mit einem vertrauenswürdigen Stamm verkettet ist. Dies ist die Standardeinstellung.</li>
		 <li><codeph>ReferencesValidationSetting.VALID_OR_UNKNOWN_IDENTITY</codeph>: Verweise werden überprüft, wenn das signierende Zertifikat gültig ist, selbst wenn es nicht mit einem vertrauenswürdigen Stamm verkettet ist.</li>
		 <li><codeph>ReferencesValidationSetting.NEVER</codeph>: Verweise werden nie überprüft.</li> 
		 </ul>
		 
		 <p>
		 Verwenden Sie die Standardeinstellung (<codeph>validIdentity</codeph>) für Signaturen, die mit einem kommerziellen Zertifikat signiert sind, oder wenn Sie Ihr eigenes Zertifikat als Vertrauensanker über die <codeph>addCertificate()</codeph>-Methode bereitstellen. Durch diese Einstellung wird verhindert, dass Verweise überprüft werden, wenn das signierte Dokument sowieso abgelehnt wird.
		 </p>
		 <p>
		 Verwenden Sie die Einstellung <codeph>validOrUnknownIdentity</codeph> für Signaturen, die mit selbst signierten Zertifikaten signiert sind. Mit dieser Einstellung können Sie überprüfen, ob die signierten Daten unverändert sind, erhalten aber keine Garantie bezüglich der Identität des Signierers. 
		 </p>
		 <p>
		 Verwenden Sie die Einstellung <codeph>never</codeph>, um zu verhindern, dass Verweise überprüft werden, wenn diese Überprüfung im Kontext Ihrer Anwendung unerheblich ist.
		 </p>
		 </apiDesc><example conref="examples\XMLSignatureValidator.referencesValidationSetting.1.as"> Das folgende Beispiel setzt das XMLSignatureValidator-Objekt nur dann auf eine Überprüfung von Verweisen, wenn das signierende Zertifikat mit einem Vertrauensanker verkettet ist:
<codeblock>
 import flash.security.ReferencesValidationSetting;
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator(); 
 verifier.referencesValidationSetting = ReferencesValidationSetting.VALID_OR_UNKNOWN_IDENTITY;
</codeblock></example></apiValueDetail><related-links><link href="flash.security.xml#ReferencesValidationSetting"><linktext>ReferencesValidationSetting</linktext></link></related-links></apiValue><apiValue id="flash.security:XMLSignatureValidator:revocationCheckSetting:set"><apiName>revocationCheckSetting</apiName><shortdesc>
	    Gibt an, wie die Zertifikatrücknahme überprüft werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Validierung einer Signatur erfolgt.
		</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	    Gibt an, wie die Zertifikatrücknahme überprüft werden soll.
		
		 <p>Legen Sie diese Eigenschaft mit Konstanten, die in der RevocationSettings-Klasse definiert sind, fest. Zu diesen Einstellungen gehören:</p>
		 <ul>	
		 <li><codeph>RevocationCheckSettings.NEVER</codeph>: Die Zertifikatrücknahme wird nicht überprüft.</li>
		 <li><codeph>RevocationCheckSettings.BEST_EFFORT</codeph>: Die Zertifikatrücknahme wird überprüft, wenn Rücknahmeinformationen zur Verfügung stehen und der Rücknahmestatus abgerufen werden kann. Wenn der Rücknahmestatus nicht ermittelt werden kann, wird das Zertifikat nicht zurückgewiesen.</li>
		 <li><codeph>RevocationCheckSettings.REQUIRED_IF_AVAILABLE</codeph>: Wenn das Zertifikat Rücknahmeinformationen enthält, muss zur Überprüfung des Zertifikats der Rücknahmestatus ermittelt werden.</li> 
		 <li><codeph>RevocationCheckSettings.ALWAYS_REQUIRED</codeph>: Der Rücknahmestatus wird immer überprüft. Zertifikate ohne Rücknahmeinformationen werden abgelehnt.</li>
		 </ul>
		 
		 </apiDesc><example conref="examples\XMLSignature.revocationCheckSetting.1.as"/></apiValueDetail><related-links><link href="flash.security.xml#RevocationCheckSettings"><linktext>RevocationCheckSettings</linktext></link></related-links></apiValue><apiValue id="flash.security:XMLSignatureValidator:signerCN:get"><apiName>signerCN</apiName><shortdesc>
	   Das Feld „Allgemeiner Name“ des signierenden Zertifikats.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	   Das Feld „Allgemeiner Name“ des signierenden Zertifikats.  
	   
	   </apiDesc><example conref="examples\XMLSignatureValidator.signerCN.1.as"> Das folgende Beispiel liest den allgemeinen Namen des signierenden Zertifikats (nachdem eine Signatur überprüft wurde):
<codeblock>
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 //validate a signature...
  
 var commonName:String = verifier.signerCN;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.security:XMLSignatureValidator:signerDN:get"><apiName>signerDN</apiName><shortdesc>
	   Das Feld „Eindeutiger Name“ des signierenden Zertifikats.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	   Das Feld „Eindeutiger Name“ des signierenden Zertifikats.  
	   
	   </apiDesc><example conref="examples\XMLSignatureValidator.signerDN.1.as"> Das folgende Beispiel liest den eindeutigen Namen des signierenden Zertifikats (nachdem eine Signatur überprüft wurde):
<codeblock>
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 //validate a signature...
  
 var distinguishedName:String = verifier.signerDN;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.security:XMLSignatureValidator:signerExtendedKeyUsages:get"><apiName>signerExtendedKeyUsages</apiName><shortdesc>
	   Ein Array, das die OIDs für die erweiterte Tastenverwendung enthält, die im signierenden Zertifikat aufgeführt sind.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Überprüfung einer Signatur erfolgt.
	   
	   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	   Ein Array, das die OIDs für die erweiterte Tastenverwendung enthält, die im signierenden Zertifikat aufgeführt sind.
	   
	   <p>Jede erweiterte Tastenverwendung wird in numerischer OID-Form gemeldet.</p>
	   
	   </apiDesc><example conref="examples\XMLSignatureValidator.signerExtendedKeyUsages.1.as"> Das folgende Beispiel liest die erweiterten Tasten-OIDs des signierenden Zertifikats (nachdem eine Signatur überprüft wurde):
<codeblock>
 import flash.security.XMLSignatureValidator;
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 //validate a signature...
  
 var extendedKeyOIDs:Array = verifier.signerExtendedKeyUsages;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.security:XMLSignatureValidator:signerTrustSettings:get"><apiName>signerTrustSettings</apiName><shortdesc>
		Ein Array, das die Vertrauenseinstellungen des signierenden Zertifikats enthält.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Überprüfung einer Signatur erfolgt.
		
		</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
		Ein Array, das die Vertrauenseinstellungen des signierenden Zertifikats enthält.
		
		<p>Die Vertrauenseinstellungen werden aus dem System und den Schlüssel-IODs, die im Zertifikat eingebettet sind, abgeleitet. Konstanten für die Strings, die die erkannten Vertrauenseinstellungen repräsentieren, sind in der SignerTrustSettings-Klasse definiert.</p>
		 
		 <p>Das <codeph>signerTrustSettings</codeph>-Array eines Zertifikats mit dem Status <codeph>unknown</codeph> oder <codeph>invalid</codeph> ist leer.</p>
		
		<p>Das Verändern des Array hat keinen Einfluss auf die Vertrauenseinstellungen des Zertifikats. </p>
		
  	    </apiDesc><example conref="examples\XMLSignatureValidator.signerTrustSettings.1.as"> Das folgende Beispiel liest die Vertrauenseinstellungen des signierenden Zertifikats (nachdem eine Signatur überprüft wurde):
<codeblock>
 import flash.security.XMLSignatureValidator;
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 //validate a signature...
  
 var certificateTrustedFor:Array = verifier.signerTrustSettings;
</codeblock></example></apiValueDetail><related-links><link href="flash.security.xml#SignerTrustSettings"><linktext>SignerTrustSettings</linktext></link></related-links></apiValue><apiValue id="flash.security:XMLSignatureValidator:uriDereferencer:set"><apiName>uriDereferencer</apiName><shortdesc>
	     Die IURIDereferencer-Implementierung.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.security:IURIDereferencer</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Validierung einer Signatur erfolgt.
		 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	     Die IURIDereferencer-Implementierung.
		 
		 <p>Eine IURIDereferencer-Implementierung muss bereitgestellt werden, bevor eine Signatur überprüft wird.</p>
		 
		 </apiDesc><example conref="examples\XMLSignatureValidator.uriDereferencer.1.as"> Das folgende Beispiel erstellt eine Instanz von SignedMessageDereferencer, die die IURIDereferencer-Schnittstelle implementiert, und setzt sie als den Dereferenzierer, der zur Überprüfung der Signatur verwendet werden soll:
<codeblock>
 import com.example.SignedMessageDereferencer; //A custom class implementing IURIDereferencer
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator(); 
 verifier.uriDereferencer = new SignedMessageDereferencer();
</codeblock></example></apiValueDetail><related-links><link href="flash.security.xml#IURIDereferencer"><linktext>IURIDereferencer</linktext></link></related-links></apiValue><apiValue id="flash.security:XMLSignatureValidator:useSystemTrustStore:set"><apiName>useSystemTrustStore</apiName><shortdesc>
	    Gibt an, dass Zertifikate im Vertrauensspeicher des Systems für die Kettenbildung verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Validierung einer Signatur erfolgt.
		 
		 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	    Gibt an, dass Zertifikate im Vertrauensspeicher des Systems für die Kettenbildung verwendet werden.
	    
	    <p>Ist der Wert <codeph>true</codeph>, werden die Vertrauensanker im Vertrauensspeicher des Systems als vertrauenswürdige Stämme verwendet. Der Vertrauensspeicher des Systems wird standardmäßig nicht verwendet.</p>
		
		</apiDesc><example conref="examples\XMLSignatureValidator.useSystemTrustStore.1.as"> Das folgende Beispiel erzeugt eine XMLSignatureValidator-Instanz und richtet diese so ein, dass beim Überprüfen einer XML-Signatur der Systemablagebereich für vertrauenswürdige Zertifikate verwendet wird:
<codeblock>
 var verifier:XMLSignatureValidator = new XMLSignatureValidator(); 
 verifier.useSystemTrustStore = true;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.security:XMLSignatureValidator:validityStatus:get"><apiName>validityStatus</apiName><shortdesc>
	    Der Gültigkeitsstatus einer überprüften XML-Signatur.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Wenn der Zugriff während der Überprüfung einer Signatur erfolgt.
		
		</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	    Der Gültigkeitsstatus einer überprüften XML-Signatur.
	    
		<p>Die XML-Signatur wird überprüft, indem die kryptographische Signatur des SignedInfo-Elements, das signierende Zertifikat und die Daten, auf die die Referenzen im SignedInfo-Element verweisen, überprüft werden. Die Gültigkeit jedes dieser Elemente wird einzeln über die <codeph>digestStatus</codeph>-, die <codeph>identityStatus()</codeph>- bzw. die <codeph>referencesStatus</codeph>-Eigenschaft gemeldet.</p>
		
	    <p>XML-Signaturen können gültig oder ungültig sein oder ihre Gültigkeit ist unbekannt. Der Gesamtstatus richtet sich nach dem Verifizierungsstatus der einzelnen Komponenten der Signaturdatei:</p>
	    <ul>
	    <li><codeph>digestStatus</codeph>: Die Gültigkeit der kryptographischen Signatur, die über das SignedInfo-Element berechnet wird.</li>
	    <li><codeph>identityStatus</codeph>: Die Gültigkeit des signierenden Zertifikats.</li>
	    <li><codeph>referencesStatus</codeph>: Die Gültigkeit des Digests der Verweise im SignedInfo-Element der Signatur.</li>
	    </ul>
	    <p>Die von der <codeph>validityStatus</codeph>-Eigenschaft gemeldete Signaturgültigkeit kann folgende Werte aufweisen:</p>
	    <ul>
	    <li><codeph>valid</codeph>, wenn <codeph>referencesStatus</codeph>, <codeph>digestStatus</codeph> und <codeph>identityStatus</codeph> alle <codeph>valid</codeph> sind.</li>
	    <li><codeph>invalid</codeph>, wenn einer der Status <codeph>invalid</codeph> ist.</li>
	    <li><codeph>unknown</codeph>: Wenn einer der Status <codeph>unknown</codeph> ist.</li>
	    </ul>
		
		</apiDesc><example conref="examples\XMLSignatureValidator.validityStatus.1.as"> Das folgende Beispiel ruft das Ergebnis der Überprüfung der XML-Signatur ab. 
<codeblock>
 import flash.security.XMLSignatureValidator;
 
 var verifier:XMLSignatureValidator = new XMLSignatureValidator();
 //validate the signature...
  
 var validationResult:String = verifier.validityStatus;
</codeblock></example></apiValueDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/digestStatus"><linktext>digestStatus</linktext></link><link href="flash.security.xml#XMLSignatureValidator/identityStatus"><linktext>identityStatus</linktext></link><link href="flash.security.xml#XMLSignatureValidator/referencesStatus"><linktext>referencesStatus</linktext></link><link href="flash.security.xml#SignatureStatus"><linktext>SignatureStatus</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.security:IURIDereferencer"><apiName>IURIDereferencer</apiName><shortdesc>
	Der IURIDereferencer definiert eine Schnittstelle für Objekte, die URIs in einer XML-Signatur auflösen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Der IURIDereferencer definiert eine Schnittstelle für Objekte, die URIs in einer XML-Signatur auflösen.
	 
	<p>Die IURIDereferencer-Implementierung ist zuständig für das Auflösen der URIs, die in den SignedInfo-Elementen einer XML-Signaturdatei angegeben sind und die referenzierten Daten in einem Objekt zurückgeben, zum Beispiel ein ByteArray, das die IDataInput-Schnittstelle implementiert. <ph platform="javascript">Um die IURIDereferencer-Schnittstelle zu verwenden, müssen Sie eine ActionScript-Klasse erstellen, die die Schnittstelle implementiert. In JavaScript können Sie ein <codeph>script</codeph>-Tag verwenden, um eine SWF-Datei zu laden, die eine ActionScript-Klasse enthält.</ph></p>
	
	<p>Die Schnittstelle verfügt über eine Methode:·<codeph>dereference()</codeph>. Eine typische Implementierung könnte auch eine Methode zur Übergabe des XML-Signaturobjekts mit den aufzulösenden URIs an den Dereferenzierer erfordern.</p> 
	 
	 <p>Die IURIDereferencer-Schnittstelle wird mit der XMLSignatureValidator-Klasse verwendet.</p>
	
	</apiDesc><example conref="examples\IURIDereferencerExample.as"/></apiClassifierDetail><related-links><link href="flash.security.xml#XMLSignatureValidator"><linktext>XMLSignatureValidator</linktext></link><link href="flash.security.xml#XMLSignatureValidator/uriDereferencer"><linktext>XMLSignatureValidator.uriDereferencer</linktext></link></related-links><apiOperation id="flash.security:IURIDereferencer:flash.security:IURIDereferencer:dereference"><apiName>dereference</apiName><shortdesc>
		Löst den angegebenen URI auf und dereferenziert ihn.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die vom URI referenzierten Daten.
		</apiDesc><apiOperationClassifier>flash.utils:IDataInput</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der URI, der dereferenziert werden soll.
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Löst den angegebenen URI auf und dereferenziert ihn.
		
		</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.security:SignerTrustSettings"><apiName>SignerTrustSettings</apiName><shortdesc>
	Die SignerTrustSettings-Klasse definiert Konstanten, die mit der SignerTrustSettings-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die SignerTrustSettings-Klasse definiert Konstanten, die mit der <codeph>SignerTrustSettings</codeph>-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/signerTrustSettings"><linktext>XMLSignatureValidator.signerTrustSettings</linktext></link></related-links><apiValue id="flash.security:SignerTrustSettings:CODE_SIGNING"><apiName>CODE_SIGNING</apiName><shortdesc> 
	   Das Zertifikat ist für Codesignaturen vertrauenswürdig.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>codeSigning</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	   Das Zertifikat ist für Codesignaturen vertrauenswürdig. Dies impliziert, dass eine Kette zu einem vertrauenswürdigen Stamm besteht, dass der Stamm für Codesignaturen vertrauenswürdig ist und dass das signierende Zertifikat in der Extended Key Usage-Erweiterung über die CodeSigning OID verfügt.
	   
	   </apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:SignerTrustSettings:PLAYLIST_SIGNING"><apiName>PLAYLIST_SIGNING</apiName><shortdesc> 
	   Das Zertifikat ist für Signaturen von Wiedergabelisten vertrauenswürdig.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>playlistSigning</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	   Das Zertifikat ist für Signaturen von Wiedergabelisten vertrauenswürdig. Dies impliziert, dass eine Kette zu einem vertrauenswürdigen Stamm besteht und dass das signierende Zertifikat in der Extended Key Usage-Erweiterung über die OID zum Signieren von Wiedergabelisten verfügt.
	   
	   </apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:SignerTrustSettings:SIGNING"><apiName>SIGNING</apiName><shortdesc> 
	  Das Zertifikat ist für Signaturen allgemein vertrauenswürdig.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>signing</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	  Das Zertifikat ist für Signaturen allgemein vertrauenswürdig. 
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.security:SignatureStatus"><apiName>SignatureStatus</apiName><shortdesc>
	Die SignatureStatus-Klasse definiert Konstanten, die von der validityStatus-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die SignatureStatus-Klasse definiert Konstanten, die von der <codeph>validityStatus</codeph>-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/validityStatus"><linktext>XMLSignatureValidator.validityStatus</linktext></link></related-links><apiValue id="flash.security:SignatureStatus:INVALID"><apiName>INVALID</apiName><shortdesc> 
	Ungültiger Status.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>invalid</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Ungültiger Status.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:SignatureStatus:UNKNOWN"><apiName>UNKNOWN</apiName><shortdesc> 
	Unbekannter Status.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>unknown</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Unbekannter Status.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:SignatureStatus:VALID"><apiName>VALID</apiName><shortdesc> 
	Gültiger Status.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>valid</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Gültiger Status.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.security:ReferencesValidationSetting"><apiName>ReferencesValidationSetting</apiName><shortdesc>
	Die ReferencesValidationSetting-Klasse definiert Konstanten, die von der referencesValidationSetting-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die ReferencesValidationSetting-Klasse definiert Konstanten, die von der <codeph>referencesValidationSetting</codeph>-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/ReferencesValidationSetting"><linktext>XMLSignatureValidator.ReferencesValidationSetting</linktext></link></related-links><apiValue id="flash.security:ReferencesValidationSetting:NEVER"><apiName>NEVER</apiName><shortdesc> 
	Verweise nie überprüfen.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Verweise nie überprüfen.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:ReferencesValidationSetting:VALID_IDENTITY"><apiName>VALID_IDENTITY</apiName><shortdesc> 
	Verweise nur dann überprüfen, wenn das signierende Zertifikat gültig und vertrauenswürdig ist.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>validIdentity</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Verweise nur dann überprüfen, wenn das signierende Zertifikat gültig und vertrauenswürdig ist.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:ReferencesValidationSetting:VALID_OR_UNKNOWN_IDENTITY"><apiName>VALID_OR_UNKNOWN_IDENTITY</apiName><shortdesc> 
	Verweise auch dann überprüfen, wenn das signierende Zertifikat nicht vertrauenswürdig ist (also nicht mit einem bekannten vertrauenswürdigen Stamm verkettet ist).</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>validOrUnknownIdentity</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Verweise auch dann überprüfen, wenn das signierende Zertifikat nicht vertrauenswürdig ist (also nicht mit einem bekannten vertrauenswürdigen Stamm verkettet ist).
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.security:RevocationCheckSettings"><apiName>RevocationCheckSettings</apiName><shortdesc>
	Die RevocationCheckSettings-Klasse definiert Konstanten, die von der revocationCheckSetting-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Die RevocationCheckSettings-Klasse definiert Konstanten, die von der <codeph>revocationCheckSetting</codeph>-Eigenschaft eines XMLSignatureValidator-Objekts verwendet werden.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.security.xml#XMLSignatureValidator/revocationCheckSetting"><linktext>XMLSignatureValidator.revocationCheckSetting</linktext></link></related-links><apiValue id="flash.security:RevocationCheckSettings:ALWAYS_REQUIRED"><apiName>ALWAYS_REQUIRED</apiName><shortdesc>
		Zertifikatrücknahme immer überprüfen.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>alwaysRequired</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Zertifikatrücknahme immer überprüfen. Zertifikate ohne Rücknahmeinformationen werden abgelehnt.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:RevocationCheckSettings:BEST_EFFORT"><apiName>BEST_EFFORT</apiName><shortdesc>
		Zertifikatrücknahme überprüfen, falls Rücknameinformationen verfügbar sind und der Rücknahmestatus ermittelt werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bestEffort</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Zertifikatrücknahme überprüfen, falls Rücknameinformationen verfügbar sind und der Rücknahmestatus ermittelt werden kann. Wenn der Rücknahmestatus nicht ermittelt werden kann, wird das Zertifikat nicht zurückgewiesen.
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:RevocationCheckSettings:NEVER"><apiName>NEVER</apiName><shortdesc>
		Zertifikatrücknahme nicht überprüfen.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Zertifikatrücknahme nicht überprüfen.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.security:RevocationCheckSettings:REQUIRED_IF_AVAILABLE"><apiName>REQUIRED_IF_AVAILABLE</apiName><shortdesc>
		Zertifikatrücknahme überprüfen, wenn das Zertifikat Rücknahmeinformationen enthält.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>requiredIfInfoAvailable</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Zertifikatrücknahme überprüfen, wenn das Zertifikat Rücknahmeinformationen enthält. Wenn die Informationen zur Verfügung stehen, aber der Rücknahmestatus nicht ermittelt werden kann, wird das Zertifikat abgelehnt.
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>