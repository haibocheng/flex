<?xml version="1.0"?>
<apiPackage id="flash.text"><apiName>flash.text</apiName><apiDetail/><apiClassifier id="flash.text:TextExtent"><apiName>TextExtent</apiName><shortdesc>
 Die TextExtent-Klasse enthält Informationen über die Ausmaße von Text innerhalb eines Textfelds.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die TextExtent-Klasse enthält Informationen über die Ausmaße von Text innerhalb eines Textfelds. Objekte dieser Klasse werden von der <codeph>TextFormat.getTextExtent</codeph>-Methode zurückgegeben.
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.text:TextExtent:TextExtent"><apiName>TextExtent</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextExtent:ascent"><apiName>ascent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:descent"><apiName>descent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:height"><apiName>height</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldHeight"><apiName>textFieldHeight</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldWidth"><apiName>textFieldWidth</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:width"><apiName>width</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
	 Die CSMSettings-Klasse enthält Eigenschaften für CSM (Continuous Stroke Modulation) bei Verwendung der Methode „TextRenderer.setAdvancedAntiAliasingTable()“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not functioning correctly. Bug report 193833
	 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die CSMSettings-Klasse enthält Eigenschaften für CSM (Continuous Stroke Modulation) bei Verwendung der Methode <codeph>TextRenderer.setAdvancedAntiAliasingTable()</codeph>. CSM ist die kontinuierliche Modulation von Strichbreite und Kantenschärfe.
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links><apiConstructor id="flash.text:CSMSettings:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
     Erstellt ein neues CSMSettings-Objekt, das Strichwerte für individuelle Anti-Aliasing-Einstellungen enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>fontSize</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Größe in Pixel, für die die Einstellungen gelten.
	 </apiDesc></apiParam><apiParam><apiItemName>insideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der obere Schwellenwert, oberhalb dessen die Dichte auf den Höchstwert (z. B. 255) gesetzt wird.
	 </apiDesc></apiParam><apiParam><apiItemName>outsideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der untere Schwellenwert, unterhalb dessen die Dichte auf 0 gesetzt wird.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Erstellt ein neues CSMSettings-Objekt, das Strichwerte für individuelle Anti-Aliasing-Einstellungen enthält. 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.text:CSMSettings:fontSize"><apiName>fontSize</apiName><shortdesc>
		 Die Größe in Pixel, für die die Einstellungen gelten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Die Größe in Pixel, für die die Einstellungen gelten.
		 
		 <p>Das an die <codeph>setAdvancedAntiAliasingTable()</codeph>-Methode übergebene Array <codeph>advancedAntiAliasingTable</codeph> kann mehrere Einträge für CSM-Einstellungen zu verschiedenen Schriftgrößen enthalten. Mit dieser Eigenschaft können Sie die Schriftgröße zusammen mit den anderen Einstellungen bestimmen.
		 </p>
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:insideCutoff"><apiName>insideCutoff</apiName><shortdesc>
		 Der obere Schwellenwert, oberhalb dessen die Dichte auf den Höchstwert (z. B. 255) gesetzt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Der obere Schwellenwert, oberhalb dessen die Dichte auf den Höchstwert (z. B. 255) gesetzt wird.
         
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:outsideCutoff"><apiName>outsideCutoff</apiName><shortdesc>
		 Der untere Schwellenwert, unterhalb dessen die Dichte auf 0 gesetzt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Der untere Schwellenwert, unterhalb dessen die Dichte auf 0 gesetzt wird.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextColorType"><apiName>TextColorType</apiName><shortdesc>
Die TextColorType-Klasse enthält Farbwerte für die flash.text.TextRenderer-Klasse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die TextColorTypeKlasse enthält Farbwerte für die flash.text.TextRenderer-Klasse.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:TextColorType:DARK_COLOR"><apiName>DARK_COLOR</apiName><shortdesc>
    Wird im Parameter „colorType“ der Methode „setAdvancedAntiAliasingTable()“ verwendet.</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dark</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Wird im Parameter <codeph>colorType</codeph> der Methode <codeph>setAdvancedAntiAliasingTable()</codeph> verwendet. Verwenden Sie die Syntax <codeph>TextColorType.DARK_COLOR</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextColorType:LIGHT_COLOR"><apiName>LIGHT_COLOR</apiName><shortdesc>
    Wird im Parameter „colorType“ der Methode „setAdvancedAntiAliasingTable()“ verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>light</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Wird im Parameter <codeph>colorType</codeph> der Methode <codeph>setAdvancedAntiAliasingTable()</codeph> verwendet. Verwenden Sie die Syntax <codeph>TextColorType.LIGHT_COLOR</codeph>.	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:GridFitType"><apiName>GridFitType</apiName><shortdesc>
Mit der GridFitType-Klasse werden Werte für die Rasteranpassung in der TextField-Klasse definiert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Mit der GridFitType-Klasse werden Werte für die Rasteranpassung in der TextField-Klasse definiert.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:GridFitType:NONE"><apiName>NONE</apiName><shortdesc> 
	Hiermit werden keine Einstellungen für die Rasteranpassung vorgenommen.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Hiermit werden keine Einstellungen für die Rasteranpassung vorgenommen. Horizontale und vertikale Linien in den Glyphen werden nicht am Pixelraster ausgerichtet. Diese Konstante wird zur Einstellung der Eigenschaft <codeph>gridFitType</codeph> in der TextField-Klasse verwendet. Diese Einstellung eignet sich oft für Animationen oder für große Schriften. Verwenden Sie die Syntax <codeph>GridFitType.NONE</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:PIXEL"><apiName>PIXEL</apiName><shortdesc>
	Passt breite horizontale und vertikale Linien an das Pixelraster an.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Passt breite horizontale und vertikale Linien an das Pixelraster an. Diese Konstante wird zur Einstellung der Eigenschaft <codeph>gridFitType</codeph> in der TextField-Klasse verwendet. Diese Einstellung funktioniert nur bei linksbündigen Textfeldern und funktioniert wie die Konstante <codeph>GridFitType.SUBPIXEL</codeph> bei statischem Text. Diese Einstellung bietet im Allgemeinen die beste Lesbarkeit für linksbündigen Text. Verwenden Sie die Syntax <codeph>GridFitType.PIXEL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:SUBPIXEL"><apiName>SUBPIXEL</apiName><shortdesc>
	Passt breite horizontale und vertikale Linien an das Subpixel-Raster von LCD-Monitoren an.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subpixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Passt breite horizontale und vertikale Linien an das Subpixel-Raster von LCD-Monitoren an. (Tatsächlich sind die Pixel auf einem LCD-Monitor Rot, Grün und Blau.) Diese Einstellung eignet sich oft gut für rechtsbündigen oder zentrierten dynamischen Text und ist manchmal eine praktische Alternative, wenn zwischen Animations- und Textqualität abzuwägen ist. Diese Konstante wird zur Einstellung der Eigenschaft <codeph>gridFitType</codeph> in der TextField-Klasse verwendet. Verwenden Sie die Syntax <codeph>GridFitType.SUBPIXEL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StaticText"><apiName>StaticText</apiName><shortdesc>
 Diese Klasse steht für StaticText-Objekte in der Anzeigeliste.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Diese Klasse steht für StaticText-Objekte in der Anzeigeliste. Sie können mit ActionScript keine StaticText-Objekte erstellen. StaticText-Objekte können nur mit dem Authoring-Tool erstellt werden. Beim Versuch, ein StaticText-Objekt zu erstellen, wird ein <codeph>ArgumentError</codeph> erzeugt.
 
 <p>Um einen Verweis auf ein bestehendes statisches Textfeld in ActionScript 3.0 zu erzeugen, können Sie die Elemente in der Anzeigeliste durchlaufen. Im folgenden Ausschnitt wird beispielsweise geprüft, ob die Anzeigeliste ein statisches Textfeld enthält, welches anschließend ggf. einer Variablen zugewiesen wird:</p>
 
 <codeblock>
 var i:uint;
 for (i = 0; i &lt; this.numChildren; i++) {
     var displayitem:DisplayObject = this.getChildAt(i);
     if (displayitem instanceof StaticText) {
         trace("a static text field is item " + i + " on the display list");
         var myFieldLabel:StaticText = StaticText(displayitem);
         trace("and contains the text: " + myFieldLabel.text);
     }
 }
 </codeblock>
 </apiDesc></apiClassifierDetail><apiValue id="flash.text:StaticText:text:get"><apiName>text</apiName><shortdesc>
     Gibt den aktuellen Text im statischen Textfeld zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gibt den aktuellen Text im statischen Textfeld zurück. Mit dem Authoring-Tool können mehrere Textfeldobjekte, die den vollständigen Text umfassen, exportiert werden. Bei vertikalem Text wird beispielsweise ein Textfeld pro Zeichen erstellt.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextField"><apiName>TextField</apiName><shortdesc>
 Die TextField-Klasse dient zum Erstellen von Anzeigeobjekten für die Texteingabe und -anzeige.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Die TextField-Klasse dient zum Erstellen von Anzeigeobjekten für die Texteingabe und -anzeige.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die TextField-Klasse dient zum Erstellen von Anzeigeobjekten für die Texteingabe und -anzeige. Alle dynamischen Textfelder und Eingabetextfelder in einer SWF-Datei sind Instanzen der TextField-Klasse. <ph outputclass="flexonly">Mit der TextField-Klasse können Sie Text-Rendering auf niedriger Ebene durchführen. In Flex verwenden Sie jedoch normalerweise die Steuerelemente „Label“, „Text“, „TextArea“ und „TextInput“ zur Textverarbeitung.</ph> <ph outputclass="flashonly">Sie können einem Textfeld im Eigenschafteninspektor einen Instanznamen zuweisen und es mit den Methoden und Eigenschaften der TextField-Klasse per ActionScript bearbeiten. TextField-Instanznamen erscheinen im Film-Explorer und im Dialogfeld „Zielpfad einfügen“ des Aktionenbedienfelds.</ph>
 
 <p>Verwenden Sie zur dynamischen Erstellung eines Textfelds den Konstruktor <codeph>TextField()</codeph>.</p>
 
 <p>Mit den Methoden der TextField-Klasse können Sie Text in dynamischen Textfeldern oder Eingabetextfeldern, die Sie beim Authoring oder zur Laufzeit erstellen, festlegen, auswählen und ändern. </p>
 
 <p>ActionScript bietet mehrere Möglichkeiten, Text zur Laufzeit zu formatieren. Mit der TextFormat-Klasse können Sie die Zeichen- und Absatzformatierung für TextField-Objekte festlegen. Sie können mit der Eigenschaft <codeph>TextField.styleSheet</codeph> und der StyleSheet-Klasse Cascading Style Sheets (CSS)-Stile auf Textfelder anwenden. Über CSS können integrierte HTML-Tags geändert, neue Formatierungstags definiert oder Stile angewendet werden. Sie können HTML-formatierten Text, der optional CSS-Stile verwendet, direkt einem Textfeld zuweisen. HTML-Text, den Sie einem Textfeld zuweisen, kann eingebettete Medien (Movieclips, SWF-, GIF-, PNG- und JPEG-Dateien) enthalten. Der Text umgibt die eingebetteten Medien. Dies ist mit der Art vergleichbar, in der Text in einem Webbrowser die in einem HTML-Dokument eingebetteten Medien umgibt. </p>
 
 <p>Flash Player unterstützt einige HTML-Tags zum Formatieren von Text. Eine Liste der unterstützten HTML-Tags finden Sie in der Beschreibung der Eigenschaft <xref href="flasht/text/TextField#htmlText">htmlText</xref>.</p>
 
 </apiDesc><example conref="examples\TextFieldExample.as"> Beim folgenden Beispiel wird die Klasse <codeph>TextFieldExample</codeph> zur Anzeige einer Textmeldung verwendet. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Es wird eine <codeph>label</codeph>-Eigenschaft vom Typ „TextField“ erstellt.</li>
  <li>Der Klassenkonstruktor ruft die Funktion <codeph>configureLabel()</codeph> auf.</li>
  <li> Mit der Methode <codeph>configureLabel()</codeph> wird zuerst ein neues TextField-Objekt erstellt, das anschließend der Eigenschaft <codeph>label</codeph> zugewiesen wird. Danach werden die Parameter wie folgt eingestellt:
  <ul>
      <li>Textfeld links ausrichten.</li>
      <li>Hintergrundfüllung aktivieren.</li>
      <li>Rahmen aktivieren.</li>
  </ul>
  </li>
  <li>Mit der Methode <codeph>configureLabel()</codeph> wird die Variable <codeph>format</codeph> erstellt und einer neuen TextFormat-Instanz mit den folgenden Parametern zugewiesen:
  <ul>
      <li>Schriftart = Verdana</li>
      <li>Schriftfarbe = reines Rot</li>
      <li>Schriftgröße = 10</li>
      <li>Unterstreichung = true</li>
  </ul>
  </li>
  <li>Die Eigenschaft <codeph>defaultTextFormat</codeph> des Textfelds <codeph>label</codeph> ist auf <codeph>format</codeph> gesetzt, und die <codeph>label</codeph>-Instanz wird der Anzeigeliste hinzugefügt. In dieser wird zuerst ein Textfeld ohne Text angezeigt.</li>
 
  <li>Der Konstruktor setzt den Text des <codeph>label</codeph>-Textfelds auf <codeph>"Hello world and welcome to the show."</codeph> fest, indem er die <codeph>setLabel()</codeph>-Methode aufruft.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFieldExample extends Sprite {
        private var label:TextField;
        private var labelText:String = "Hello world and welcome to the show.";

        public function TextFieldExample() {
            configureLabel();
            setLabel(labelText);
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 Flash Player löst das textInput-Ereignis aus, wenn ein Benutzer ein oder mehr Textzeichen eingibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Flash Player löst das Ereignis <codeph>textInput</codeph> aus, wenn ein Benutzer ein oder mehr Textzeichen eingibt. Dieses Ereignis kann durch verschiedene Texteingabemethoden ausgelöst werden, z. B. die Standardtastatur, Eingabemethodeneditoren (Input Method Editors, IMEs), Spracherkennungssysteme oder das Einfügen von Text ohne Formatierungs- oder Stilinformationen.
 </apiDesc><example conref="examples\TextField_textInput.as"> Das folgende Beispiel definiert zwei TextField-Objekte: das erste TextField-Objekt ist ein Eingabetextfeld, das zweite ein dynamisches Textfeld. Wenn Sie Textzeichen in das erste Textfeld eingeben, wird das <codeph>textInput</codeph>-Ereignis ausgelöst, die <codeph>textInputHandler()</codeph>-Prozedur aufgerufen und die Zeichen werden im zweiten Textfeld angezeigt. Wenn Sie einen Textblock in das Eingabefeld einfügen, kopiert die Ereignisprozedur den ganzen Block in das andere Feld.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextInputExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();

        public function TextInputExample()
        {
            myTextBox1.type = TextFieldType.INPUT;
            myTextBox1.width = 200;
            myTextBox1.height = 20;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(TextEvent.TEXT_INPUT,textInputHandler);
        }

        public function textInputHandler(event:TextEvent):void
        {
           myTextBox2.text=event.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.SCROLL_scroll"><apiName>scroll</apiName><shortdesc>
 Von einem TextField-Objekt ausgelöst, nachdem der Benutzer einen Bildlauf durchgeführt hat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SCROLL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Von einem TextField-Objekt ausgelöst, <i>nachdem</i> der Benutzer einen Bildlauf durchgeführt hat. 
 </apiDesc><example conref="examples\TextField_scroll.as"> Das folgende Beispiel definiert zwei TextField-Objekte: Das erste TextField-Objekt hat zwei verknüpfte Ereignisprozeduren: Wenn Sie mit der Maus in dieses erste Textfeld klicken, wird das <codeph>mouseDown</codeph>-Ereignis ausgelöst und die verknüpfte <codeph>mouseDownScroll</codeph>-Prozedur aufgerufen. Die <codeph>mouseDownScroll()</codeph>-Prozedur führt dazu, dass im Feld ein Bildlauf durchgeführt wird. Danach wird das <codeph>scroll</codeph>-Ereignis ausgelöst und die verknüpfte <codeph>scrollHandler()</codeph>-Prozedur aktualisiert das zweite Textfeld, um die aktuelle Bildlaufposition anzuzeigen.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextScrollExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();
        private var myText:String = "Hello world and welcome to the show. It's really nice to meet you. Take your coat off and stay a while. OK, show is over. Hope you had fun. You can go home now. Don't forget to tip your waiter. There are mints in the bowl by the door. Thank you. Please come again.";

        public function TextScrollExample()
        {
            myTextBox1.text = myText;
            myTextBox1.width = 200;
            myTextBox1.height = 50;
            myTextBox1.multiline = true;
            myTextBox1.wordWrap = true;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;
            myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownScroll);
            myTextBox1.addEventListener(Event.SCROLL, scrollHandler);
        }

        public function mouseDownScroll(event:MouseEvent):void
        {
            myTextBox1.scrollV++;
        }
        public function scrollHandler(event:Event):void
        {
           myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.LINK_link"><apiName>link</apiName><shortdesc>
 Wird ausgelöst, wenn ein Benutzer auf einen Hyperlink in einem HTML-fähigen Textfeld klickt und die URL-Adresse mit „event:“ beginnt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.LINK</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, wenn ein Benutzer auf einen Hyperlink in einem HTML-fähigen Textfeld klickt und die URL-Adresse mit „event:“ beginnt. Der Rest der URL nach „event:“ wird in die Texteigenschaft des LINK-Ereignisses platziert.
 <p><b>Hinweis:</b> Das Standardverhalten (dem Textfeld wird Text hinzugefügt) tritt nur dann ein, wenn Flash Player das Ereignis erstellt. Dies ist der Fall, wenn ein Benutzer versucht, Text einzugeben. Eine Texteingabe in ein Textfeld durch Senden von <codeph>textInput</codeph>-Ereignissen ist nicht möglich.</p>
 </apiDesc><example conref="examples\TextField_event_link.as"> Im folgenden Beispiel wird die Funktion <codeph>playMP3()</codeph> definiert. Es wird das TextField-Objekt <codeph>list</codeph> erstellt und mit HTML-Text gefüllt. Die Texte <codeph>"Track 1"</codeph> und <codeph>"Track 2"</codeph> sind Links innerhalb des Textfelds. Die Funktion playMP3() wird aufgerufen, wenn der Benutzer auf einen der Links klickt. Der Name der MP3-Datei nach dem String „event:“ im <codeph>href</codeph>-Attribut des HTML-Tags wird an die <codeph>linkHandler()</codeph>-Methode als <codeph>text</codeph>-Eigenschaft des <codeph>link</codeph>-Ereignisobjekts übergeben.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;
    import flash.events.TextEvent;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_event_link extends Sprite
    {
        private var myMP3:Sound;
        public function TextField_event_link() {
            myMP3 = new Sound();
            var list:TextField = new TextField();
            list.autoSize = TextFieldAutoSize.LEFT;
            list.multiline = true;
            list.htmlText = "&lt;a href=\"event:track1.mp3\">Track 1&lt;/a>&lt;br>";
            list.htmlText += "&lt;a href=\"event:track2.mp3\">Track 2&lt;/a>&lt;br>";
            addEventListener(TextEvent.LINK, linkHandler);
            addChild(list);
        }
        
        private function playMP3(mp3:String):void {
            try {    
                myMP3.load(new URLRequest(mp3));
                myMP3.play();
            }
            catch(err:Error) {
                trace(err.message);
            }
            myMP3.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }
        
        private function linkHandler(linkEvent:TextEvent):void {
            playMP3(linkEvent.text);
        }
        
        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.CHANGE_change"><apiName>change</apiName><shortdesc>
 Wird ausgelöst, nachdem ein Steuerelementwert geändert wurde (im Gegensatz zum textInput-Ereignis, das ausgelöst wird, bevor der Wert geändert wird).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Wird ausgelöst, nachdem ein Steuerelementwert geändert wurde (im Gegensatz zum <codeph>textInput</codeph>-Ereignis, das ausgelöst wird, bevor der Wert geändert wird). Im Gegensatz zur W3C DOM-Ereignismodell-Version des <codeph>change</codeph>-Ereignisses, bei der das Ereignis erst nach einem Wechsel des Fokus auf ein anderes Steuerelement ausgelöst wird, wird das Ereignis bei der ActionScript 3.0-Version des <codeph>change</codeph>-Ereignisses ausgelöst, sobald sich das Steuerelement ändert. Wenn ein Benutzer z. B. Text in ein Textfeld eingibt, wird ein <codeph>change</codeph>-Ereignis nach jedem Tastendruck ausgelöst.
 </apiDesc><example conref="examples\TextField_Event_changeExample.as"> Im folgenden Beispiel wird der Text, den der Benutzer eingibt (die Benutzereingabe), sofort in ein anderes Textfeld mit einem anderen Textformat kopiert. 
 
 <p>Es werden zwei Textfelder erstellt, eines für die Benutzereingabe und das andere (<codeph>headingTextField</codeph>) für die Kopie der Benutzereingabe. Es wird auch ein TextFormat-Objekt erstellt und das Standardtextformat wird dem Textfeld <codeph>headingTextField</codeph> zugewiesen. Wenn der Inhalt des Textfelds geändert wird, wird die <codeph>changeHandler()</codeph>-Methode aufgerufen, die den Text aus dem Textfeld <codeph>inputTextField</codeph> dem Textfeld <codeph>headingTextField</codeph> zuweist. (Wenn die Methode für das <codeph>TextEvent.TEXT_INPUT</codeph>-Ereignis und nicht für das <codeph>Event.CHANGE</codeph>-Ereignis aufgerufen wird, wird der Inhalt der Benutzereingabe erst kopiert, nachdem der Benutzer weiteren Text eingegeben hat.)</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;
    import flash.events.Event;
    
    import flash.events.TextEvent;

    public class TextField_Event_changeExample extends Sprite {
        private var inputTextField:TextField = new TextField(); 
        private var headingTextField:TextField = new TextField(); 
        private var newFormat:TextFormat = new TextFormat();
         
        public function TextField_Event_changeExample() {
            headingTextField.x = 10;
            headingTextField.y = 10;
            headingTextField.height = 30;
            headingTextField.width = 400;
            headingTextField.background = true;
            headingTextField.backgroundColor = 0xF5F5DC;
            headingTextField.selectable = false;
 
            inputTextField.x = 10;
            inputTextField.y = 70;
            inputTextField.height = 20;
            inputTextField.width = 230;
            inputTextField.background = true;
            inputTextField.border = true;
            inputTextField.maxChars = 40;
            inputTextField.wordWrap = true;
            inputTextField.type = TextFieldType.INPUT;

            inputTextField.addEventListener(Event.CHANGE, changeHandler);

            newFormat.bold = true;
            newFormat.size = 18;
            newFormat.color = 0xFF0000;
            newFormat.align = TextFormatAlign.CENTER;

            headingTextField.defaultTextFormat = newFormat;

            this.addChild(inputTextField);
            this.addChild(headingTextField);
        }

        private function changeHandler(e:Event):void {
            headingTextField.text = inputTextField.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.text:TextField:TextField"><apiName>TextField</apiName><shortdesc>
	Erstellt eine neue TextField-Instanz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Erstellt eine neue TextField-Instanz. Rufen Sie nach der Erstellung der TextField-Instanz die <codeph>addChild()</codeph>- bzw. <codeph>addChildAt()</codeph>-Methode des übergeordneten DisplayObjectContainer-Objekts auf, um die TextField-Instanz der Anzeigeliste hinzuzufügen.
     <p>Die Standardgröße für ein Textfeld beträgt 100 x 100 Pixel.</p>
	 
	 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.text:TextField:appendText"><apiName>appendText</apiName><shortdesc>
	 Hängt den vom Parameter „newText“ angegebenen String an das Ende des Texts im Textfeld an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der an den vorhandenen Text anzuhängende String.
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Hängt Text an das Ende des vorhandenen Texts im „TextField“ an.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Hängt den vom Parameter <codeph>newText</codeph> angegebenen String an das Ende des Texts im Textfeld an. Diese Methode ist effizienter als eine Additionszuweisung (<codeph>+=</codeph>) bei einer <codeph>text</codeph>-Eigenschaft (wie z. B. <codeph>someTextField.text += moreText</codeph>), insbesondere bei Textfeldern mit erheblichem Inhalt.
     
	 </apiDesc><example conref="examples\TextField_appendTextExample.as"> Im folgenden Beispiel wird die Uhrzeit angezeigt, falls nicht gerade Wochenende ist. Am Wochenende wird dagegen der Text „It's the weekend“ angezeigt. Außerdem werden bis zu einer bestimmten Position die Anzahl der Zeichen und die Anzahl der Zeilen im Textfeld gezählt.
 
 <p>Das Textfeld <codeph>outputText</codeph> wird so eingestellt, dass es sich automatisch an den Text anpasst und dass der Text links ausgerichtet ist. Dazu wird die Eigenschaft <codeph>autoSize</codeph> verwendet. Die <codeph>outputText.text</codeph>-Eigenschaft schreibt die erste Zeile des Inhalts, und die <codeph>appendText()</codeph>-Methode hängt den Rest des Inhalts an. (Es ist nicht erforderlich, mit der <codeph>text</codeph>-Eigenschaft zu beginnen. Die <codeph>appendText()</codeph>-Methode könnte auch verwendet werden, um Text von außerhalb des Rahmens anzuhängen.) Wenn die <codeph>text</codeph>-Eigenschaft ein zweites Mals gesetzt wird, wird der ursprüngliche Text überschrieben. Verwenden Sie den <codeph>+=</codeph>-Operator, um Inhalt mit der <codeph>text</codeph>-Eigenschaft anzuhängen.</p>
 
 <p>Die <codeph>if</codeph>-Anweisung überprüft, ob es sich beim Datum um Samstag (6) oder Sonntag (0) handelt. Ist dies nicht der Fall, gibt die <codeph>toLocaleTimeString()</codeph>-Methode die Ortszeit zurück, die an den Inhalt des Textfelds angehängt wird.</p> 
 
 <p>Die <codeph>length</codeph>-Eigenschaft des Textfelds wird verwendet, um die Anzahl der Zeichen bis direkt vor dem Aufrufen der Funktion zu lesen, und die p<codeph>numLines</codeph>-Eigenschaft zählt die Zeilen im Textfeld. Beachten Sie, dass die leeren Zeilen sowie die Leerräume und Zeilenumbrüche (\n) mitgezählt werden, um die Länge des Inhalts zu bestimmen.</p>   
 
<codeblock>
  package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
 
    public class TextField_appendTextExample extends Sprite {
         
        public function TextField_appendTextExample() {
            var outputText:TextField = new TextField();
            var today:Date = new Date();
                
            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
 
            outputText.text = "WHAT TIME IS IT?" + "\n\n";
 
            if((today.day == 0) || (today.day == 6)) {
                outputText.appendText("It's the weekend.");
                outputText.appendText("\n\n");
           
            } else {
                outputText.appendText("The time is: ");
                outputText.appendText(today.toLocaleTimeString() + ".\n\n");  
            }

            outputText.appendText("Number of characters including line breaks and spaces so far: ");
            outputText.appendText(outputText.length.toString() + "\n");
            outputText.appendText("Number of lines in the outputText: ");
            outputText.appendText(outputText.numLines.toString());   

            this.addChild(outputText);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getCharBoundaries"><apiName>getCharBoundaries</apiName><shortdesc>
	 Gibt ein Rechteck zurück, das die Begrenzungsbox für das Zeichen darstellt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Rechteck mit Mindest- und Höchstwerten für <codeph>x</codeph> und <codeph>y</codeph>, mit dem die Begrenzungsbox für das Zeichen definiert wird.
	 
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert für das Zeichen mit Basis null (d. h., die erste Position ist 0, die zweite Position 1 usw.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt ein Rechteck zurück, das die Begrenzungsbox für das Zeichen darstellt.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt ein Rechteck zurück, das die Begrenzungsbox für das Zeichen darstellt.
	 
	 </apiDesc><example conref="examples\TextField_getCharBoundariesExample.as"> Im folgenden Beispiel wird ein vom Benutzer ausgewähltes Zeichen mithilfe der <codeph>getCharBoundaries()</codeph>-Methode markiert (hervorgehoben).
 
 <p>Die Klasse definiert das Shape-Objekt <codeph>spotlight</codeph>, das ein Rechteck um jedes ausgewählte Zeichen zeichnet. Wenn der Benutzer auf das Textfeld <codeph>myTextField</codeph> klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p>
 
 <p>In der <codeph>clickHandler()</codeph>-Methode ruft die <codeph>getCharIndexAtPoint()</codeph>-Methode den Index des ausgewählten Zeichens basierend auf den <codeph>localX</codeph>- und <codeph>localY</codeph>-Koordinaten des Mausklicks ab, der relativ zum <codeph>Sprite</codeph>-Objekt, in dem er sich befindet, ist. Die <codeph>getCharIndexAtPoint()</codeph>-Methode gibt <codeph>-1</codeph> zurück, wenn der Punkt (der Mausklick) sich auf keinem Zeichen befindet. Da das Textfeld größer sein kann als der Text, wird die zurückgegebene Ganzzahl (<codeph>index</codeph>) überprüft, um sicherzustellen, dass der Benutzer auf ein Zeichen geklickt hat. Die Ganzzahl <codeph>index</codeph> wird auch von <codeph>getCharBoundaries()</codeph> verwendet, um ein <codeph>Rectangle</codeph>-Objekt abzurufen, das die Grenzen des Zeichens enthält. Die <codeph>clear()</codeph>-Methode löscht alle zuvor angezeigten <codeph>spotlight</codeph>-Shape-Objekte. An der Position des Zeichens (ausgehend von den Koordinaten (10, 10)) wird mithilfe der zurückgegebenen x- und y-Koordinaten des <codeph>frame</codeph>-Rechtecks ein neues Rechteck in der Größe der Breite- und Höhe-Werte des Zeichens gezeichnet. Um das Zeichen hervorzuheben, wird das Shape-Objekt <codeph>spotlight</codeph> mit Gelb gefüllt und die Deckkraft wird auf 35 Prozent gesetzt, sodass das Zeichen zu erkennen ist. Beachten Sie, dass Leerzeichen auch als Zeichen behandelt werden.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    import flash.display.Shape;

    public class TextField_getCharBoundariesExample extends Sprite
    {
        private var myTextField:TextField = new TextField();    
        private var spotlight:Shape = new Shape();
        
        public function TextField_getCharBoundariesExample() {
            
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.text = "Selected a character from this text by clicking on it."

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);    
            this.addChild(spotlight);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
 
            if (index != -1) {
                 var frame:Rectangle = myTextField.getCharBoundaries(index);

                spotlight.graphics.clear();    
                spotlight.graphics.beginFill(0xFFFF00, .35);
                spotlight.graphics.drawRect((frame.x + 10), (frame.y + 10), frame.width, frame.height);            
                spotlight.graphics.endFill();
            }
        } 
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getCharIndexAtPoint"><apiName>getCharIndexAtPoint</apiName><shortdesc>
	 Gibt den auf null basierenden Indexwert des Zeichens an dem von den Parametern x und y angegebenen Punkt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Indexwert für das Zeichen mit Basis null (d. h., die erste Position ist 0, die zweite Position 1 usw.). Wenn der Wert -1 zurückgegeben wird, befindet sich der Punkt nicht über einem Zeichen.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>x</i>-Koordinate des Zeichens.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>y</i>-Koordinate des Zeichens.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt den auf null basierenden Indexwert des Zeichens zurück.
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt den auf null basierenden Indexwert des Zeichens an dem von den Parametern <codeph>x</codeph> und <codeph>y</codeph> angegebenen Punkt zurück.
	 
	 </apiDesc><example conref="examples\TextField_getCharIndexAtPointExample.as"> Im folgenden Beispiel wird das Zeichen in ein anderes Textfeld über dem Text kopiert, wenn der Benutzer auf ein Zeichen klickt.
 
 <p>Das erste Textfeld enthält dann den Text, den der Benutzer auswählt. Um sicherzustellen, dass nur auf den Text geklickt, dieser aber nicht ausgewählt wird, wird die <codeph>selectable</codeph>-Eigenschaft auf „false“ gesetzt. Wenn der Benutzer auf das Textfeld <codeph>firstTextField</codeph> klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p>
 
 <p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getCharIndexAtPoint()</codeph>-Methode den Index des Zeichens zurück, basierend auf den <codeph>localX</codeph>- und <codeph>localY</codeph>-Koordinaten des Mausklicks. Da das Textfeld größer sein kann als der Text, wird die zurückgegebene Ganzzahl (<codeph>index</codeph>) überprüft, um sicherzustellen, dass der Benutzer auf ein Zeichen geklickt hat. Die <codeph>getCharIndexAtPoint()</codeph>-Methode gibt <codeph>-1</codeph> zurück, wenn der Punkt (der Mausklick) sich nicht auf einem Zeichen befindet. Anhand der Mauskoordinaten werden die Koordinaten des neuen Textfelds, in dem die kopierten Zeichen angezeigt werden, festgelegt. Die Farbe der Zeichen im zweiten Textfeld wird auf „rot“ gesetzt. Zum Schluss wird der Text des zweiten Feldes auf das ausgewählte Zeichen festgelegt, das mit der <codeph>charAt()</codeph>-Methode abgerufen wird. Beachten Sie, dass bei Verwendung der <codeph>text</codeph>-Eigenschaft anstelle der <codeph>appendText()</codeph>-Methode das Zeichen im zweiten Feld überschrieben wird, anstatt das Zeichen anzuhängen.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getCharIndexAtPointExample extends Sprite {
        private var firstTextField:TextField = new TextField();    
        private var secondTextField:TextField = new TextField();
        
        public function TextField_getCharIndexAtPointExample() {

            firstTextField.x = 100;
            firstTextField.y = 100; 
            firstTextField.width = 260;
            firstTextField.height = 20;
            firstTextField.border = true;
            firstTextField.background = true;
            firstTextField.selectable = false;
            
            firstTextField.text = "Selected a character from this text by clicking on it."

            firstTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(firstTextField);    
            this.addChild(secondTextField);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = firstTextField.getCharIndexAtPoint(e.localX, e.localY);

            if (index != -1) {
                secondTextField.x = mouseX;
                secondTextField.y =  70;
                secondTextField.border = true;
                secondTextField.selectable = false;
                secondTextField.background = true;
                secondTextField.textColor = 0xFF0000;
                secondTextField.autoSize = TextFieldAutoSize.LEFT;
                secondTextField.text = firstTextField.text.charAt(index);    
            }
        } 
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getFirstCharInParagraph"><apiName>getFirstCharInParagraph</apiName><shortdesc>
	 Gibt anhand eines Zeichenindex den Index des ersten Zeichens im gleichen Absatz zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der angegebene Zeichenindex befindet sich nicht im Bereich.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der auf null basierende Indexwert des ersten Zeichens im gleichen Absatz.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert für das Zeichen mit Basis null (d. h., das erste Zeichen ist 0, das zweite Zeichen 1 usw.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Der auf null basierende Indexwert des Zeichens.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt anhand eines Zeichenindex den Index des ersten Zeichens im gleichen Absatz zurück.
	 
	 </apiDesc><example conref="examples\TextField_getFirstCharInParagraphExample.as"> Im folgenden Beispiel wird eine Absatzformatierung auf den Inhalt des Textfelds angewendet. Wenn der Benutzer auf einen Absatz klickt, wird der Text des Absatzes rechts ausgerichtet; klickt der Benutzer erneut auf den Absatz, wird das ursprüngliche (Standard-)Format, Ausrichtung links, angewendet.
 
 <p>Im Konstruktor wird das Textfeld <codeph>myTextField</codeph> für den Zeilenumbruch eingerichtet. Die <codeph>getTextFormat</codeph>-Methode gibt das ursprüngliche Format des ersten Zeichens des Textfeldinhalts zurück, das in das TextFormat-Objekt <codeph>originalFormat</codeph> platziert wird. Ein neues TextFormat-Objekt (<codeph>newFormat</codeph>) wird definiert, dessen <codeph>align</codeph>-Eigenschaft auf die Ausrichtung rechts gesetzt wird. Wenn der Benutzer auf das Textfeld klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p>
 
 <p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getCharIndexAtPoint()</codeph>-Methode den Index des Zeichens zurück, basierend auf den <codeph>localX</codeph>- und <codeph>localY</codeph>-Koordinaten des Mausklicks. Die erste <codeph>if</codeph>-Anweisung überprüft, ob der Benutzer auf ein Zeichen geklickt hat. Unter Verwendung der <codeph>clickIndex</codeph>-Ganzzahl, die von der <codeph>getCharIndexAtPoint()</codeph>-Methode zurückgegeben wird, gibt die <codeph>getFirstCharInParagraph()</codeph>-Methode den Index des ersten Zeichens in dem Absatz, auf den der Benutzer geklickt hat, zurück. Der Index des letzten Zeichens im Absatz wird bestimmt, indem die Länge des Absatzes (mithilfe der <codeph>getParagraphLength()</codeph>-Methode) zum Index des ersten Zeichens im Absatz hinzugefügt wird, abzüglich des letzten Zeichens (<codeph>\n</codeph>). Die zweite <codeph>if</codeph>-Anweisung überprüft das Format des ersten Zeichens im Absatz. Wenn dessen Ausrichtung mit der des ursprünglichen Formats (Linksausrichtung) übereinstimmt, wird das neue Format auf alle Zeichen im Absatz angewendet. Andernfalls wird das Format des Absatzes auf das ursprüngliche Format zurückgesetzt. Die Ausrichtung ist genau wie Einzug, Aufzählungszeichen, Tabulator, linker und rechter Rand eine Formatierung, die für Absätze gilt. Beachten Sie, dass bei Verwendung eines Zeilenumbruchs die Formatierung nur auf die erste Zeile des Absatzes angewendet wird, wenn das Argument <codeph>endIndex</codeph> für die <codeph>setTextFormat()</codeph>-Methode nicht definiert ist.</p>
     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;

    public class TextField_getFirstCharInParagraphExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        private var originalFormat:TextFormat = new TextFormat();
        private var newFormat:TextFormat = new TextFormat(); 
        
        public function TextField_getFirstCharInParagraphExample() {
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 300; 
            myTextField.background = true;
             
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.\n\n");

            originalFormat = myTextField.getTextFormat(0);

            newFormat.align = TextFormatAlign.RIGHT;

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
  
            this.addChild(myTextField);
        }

        private function clickHandler(e:MouseEvent):void {
            var clickIndex:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
                  
            if(clickIndex != -1) {
                var paragraphFirstIndex:int = myTextField.getFirstCharInParagraph(clickIndex);
                var paragraphEndIndex:int = paragraphFirstIndex + ((myTextField.getParagraphLength(clickIndex) - 1));
            
                if (myTextField.getTextFormat(paragraphFirstIndex).align == originalFormat.align) {
                     myTextField.setTextFormat(newFormat, paragraphFirstIndex, paragraphEndIndex);
                }else {
                     myTextField.setTextFormat(originalFormat, paragraphFirstIndex, paragraphEndIndex);
                }
            } 
        }
    }
}
 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getImageReference"><apiName>getImageReference</apiName><shortdesc>
	 Gibt einen DisplayObject-Verweis für die jeweilige ID, ein Bild oder eine SWF-Datei zurück, die bzw. das einem HTML-formatierten Textfeld über ein &amp;lt;img&amp;gt;-Tag hinzugefügt wurde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Das Anzeigeobjekt, das dem Bild bzw. der SWF-Datei mit dem passenden <codeph>id</codeph>-Attribut im Tag <codeph>&lt;img></codeph> des Textfelds entspricht. Bei Medien von einer externen Quelle handelt es sich um ein Loader-Objekt. Sobald das Medienobjekt geladen ist, handelt es sich um ein untergeordnetes Objekt dieses Loader-Objekts. Für in die SWF-Datei eingebetteten Medien ist dies das geladene Objekt. Wenn kein <codeph>&lt;img></codeph>-Tag mit der übereinstimmenden <codeph>id</codeph> existiert, gibt die Methode <codeph>null</codeph> zurück.
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Die <codeph>id</codeph>, für die eine Entsprechung vorliegen muss (im Attribut <codeph>id</codeph> des Tags <codeph>&lt;img></codeph>). 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen DisplayObject-Verweis für die angegebene <codeph>id</codeph> zurück, bei einem Bild bzw. einer SWF-Datei, das/die einem HTML-formatierten Textfeld mit dem Tag <codeph>&lt;img></codeph> hinzugefügt wurde. Das Tag <codeph>&lt;img></codeph> liegt im folgenden Format vor:
	 
	 <p><pre><codeph>	&lt;img src = 'filename.jpg' id = 'instanceName' ></codeph></pre></p>
	 
	 </apiDesc><example conref="examples\TextField_getImageReferenceExample.as"> Im folgenden Beispiel wird das Bild im Feld beim Klicken auf das Textfeld auf eine Deckkraft von 25 Prozent gesetzt und um 90 Grad gedreht. Mit jedem folgenden Mausklick wird das Bild erneut um 90 Grad gedreht.
 
 <p>Das Bild (<codeph>image.jpg</codeph>) wird über HTML eingeschlossen. (Hier wird davon ausgegangen, dass sich die Bilddatei im selben Verzeichnis wie die SWF-Datei befindet). Ein <codeph>id</codeph>-Attribut muss für das <codeph>img</codeph>-Tag definiert werden, damit mit der <codeph>getImageReference()</codeph>-Methode auf das Bild zugegriffen werden kann. Die <codeph>htmlText</codeph>-Eigenschaft wird verwendet, um HTML-formatierte Stringinhalte einzuschließen. Wenn der Benutzer auf das Textfeld <codeph>myTextField</codeph> klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p> 
 
 <p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getImageReference()</codeph>-Methode einen Verweis auf das Bild als <codeph>DisplayObject</codeph> zurück. Mit diesem Verweis kann das Bild wie jedes <codeph>DisplayObject</codeph>-Objekt bearbeitet werden. Hier werden die Eigenschaften <codeph>alpha</codeph> (Transparenz) und <codeph>rotation</codeph> festgelegt. Die <codeph>transform</codeph>-Eigenschaft kann verwendet werden, um auf die Matrix, die Farbtransformation und die Pixelgrenzen des Anzeigeobjekts zuzugreifen. Beachten Sie auch, dass <codeph>flash.display.DisplayObject</codeph> importiert werden muss.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.display.DisplayObject;
    
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getImageReferenceExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        
        public function TextField_getImageReferenceExample()
        {
            var myText1:String = "&lt;p>Here is an image we want to mainpulate: &lt;img src='image.jpg' id='testimage'>&lt;/p>";

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 250;
            myTextField.height = 250;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.border = true;
            myTextField.multiline = true;

            myTextField.htmlText = myText1;
            
            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);
        }
 
        private function clickHandler(e:MouseEvent):void {
            var imageRef:DisplayObject = myTextField.getImageReference("testimage");
 
            imageRef.rotation += 90;
            imageRef.x = 125;
            imageRef.y = 125;
            imageRef.alpha = 0.25;      
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>htmlText</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineIndexAtPoint"><apiName>getLineIndexAtPoint</apiName><shortdesc>
	 Gibt den auf null basierenden Indexwert des Zeichens an dem von den Parametern x und y angegebenen Punkt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Indexwert für die Zeile mit Basis null (d. h., die erste Zeile ist 0, die zweite Zeile 1 usw.). Wenn der Wert -1 zurückgegeben wird, befindet sich der Punkt nicht über einer Zeile.
 	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>x</i>-Koordinate der Zeile.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die <i>y</i>-Koordinate der Zeile.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Der auf null basierende Indexwert der Zeile am angegebenen Punkt.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt den auf null basierenden Indexwert der Zeile an dem von den Parametern <codeph>x</codeph> und <codeph>y</codeph> angegebenen Punkt zurück.
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexAtPointExample.as"> Im folgenden Beispiel wird eine Zeile aus einem Shakespeare-Sonett in eines neues Textfeld kopiert, wenn der Benutzer auf die Zeile klickt.   
 
 <p>Im Konstruktor wird das Textfeld <codeph>poem</codeph> so festgelegt, dass kein Zeilenumbruch verwendet wird (da es sich um ein Gedicht handelt). Die <codeph>autoSize</codeph>-Eigenschaft wird verwendet, um den Text automatisch anzupassen und ggf. seine Größe als links ausgerichteter Text zu ändern. Das Textfeld <codeph>poemCopy</codeph> wird unter dem Textfeld <codeph>poem</codeph> platziert. Wenn der Benutzer auf eine Zeile des Gedichts klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p>
 
 <p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getLineIndexAtPoint()</codeph>-Methode den Zeilenindex der Zeile zurück, auf die der Benutzer geklickt hat, basierend auf den <codeph>localX</codeph>- und <codeph>localY</codeph>-Koordinaten des Mausklicks. (Da das Originalgedicht in das Textfeld passt, ist es hier nicht erforderlich, zu überprüfen, ob der Text außerhalb des Bereichs liegt (<codeph>RangeError</codeph>, von der <codeph>getCharIndexAtPoint()</codeph>-Methode ausgegeben.) Der Zeilenindex wird verwendet, um den Inhalt der Zeile mit der <codeph>getLineText()</codeph>-Methode als String abzurufen, der dann an den Inhalt des Textfelds <codeph>poemCopy</codeph> angehängt wird. Das Kopieren kann kontinuierlich fortgeführt werden, ab einem bestimmten Punkt befindet sich der Text jedoch außerhalb des sichtbaren Bereichs des Textfelds <codeph>poemCopy</codeph>.</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexAtPointExample extends Sprite {
        private var poem:TextField = new TextField();
        private var poemCopy:TextField = new TextField();
        
        public function TextField_getLineIndexAtPointExample() {
            poem.border = true;
            poem.autoSize = TextFieldAutoSize.LEFT;
            poem.x = 10;
            poem.wordWrap = false;

            poemCopy.height = 250;
            poemCopy.width = 270;
            poemCopy.y = 230;
            poemCopy.x = 10;
            poemCopy.background = true;
            poemCopy.border = true;
            poemCopy.wordWrap = false;
            
            poem.appendText("Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.");

           poem.addEventListener(MouseEvent.CLICK, clickHandler); 

           this.addChild(poem); 
           this.addChild(poemCopy);
        }
    
        private function clickHandler(e:MouseEvent):void {
                var index:int = poem.getLineIndexAtPoint(e.localX, e.localY);
                var s:String;

                s = poem.getLineText(index);
                poemCopy.appendText(s + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineIndexOfChar"><apiName>getLineIndexOfChar</apiName><shortdesc>
	 Gibt den auf null basierenden Indexwert der Zeile zurück, die das vom Parameter „charIndex“ angegebene Zeichen enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der angegebene Zeichenindex befindet sich nicht im Bereich.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der auf null basierende Indexwert der Zeile.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert für das Zeichen mit Basis null (d. h., das erste Zeichen ist 0, das zweite Zeichen 1 usw.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Der auf null basierende Indexwert der Zeile, die das vom <codeph>charIndex</codeph>-Parameter angegebene Zeichen enthält.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt den auf null basierenden Indexwert der Zeile zurück, die das vom <codeph>charIndex</codeph>-Parameter angegebene Zeichen enthält.
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexOfCharExample.as"> Im folgenden Beispiel gibt die <codeph>getLineIndexOfChar()</codeph>-Methode die Zeilennummern für das 100. und 500. Zeichen im Textfeld zurück.
 
 <p>Das Textfeld <codeph>myTextField</codeph> wurde mit Zeilenumbruch und als links ausgerichteter Text definiert. Die <codeph>getLineIndexOfChar()</codeph>-Methode gibt den Zeilenindex für die angegebenen Zeichenindizes (100 und 500) zurück. Diese Informationen werden dann an den Absatz angehängt. Beachten Sie, dass der Zeilenindex (<codeph>index</codeph>) um 1 erhöht wird, um die Zeilennummer zu erhalten, da der Zeilenindex mit 0 beginnt. Wenn die Anzeigegröße geändert wird, kann sich die Zeilennummer zwar ändern, die Informationen hier bleiben jedoch unverändert, da die Methode nur ein Mal aufgerufen wird.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexOfCharExample extends Sprite 
    {
        public function TextField_getLineIndexOfCharExample()
        {
            var myTextField:TextField = new TextField();
            
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 200;
            myTextField.background = true;  
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.autoSize = TextFieldAutoSize.LEFT;

            myTextField.appendText("The TextField class is used to create display objects for "
                + "text display and input. All dynamic and input text fields in a SWF file" 
                + "are instances of the TextField class. You can use the TextField class "
                + "to perform low-level text rendering. However, in Flex, you typically use "
                + "the Label, Text, TextArea, and TextInput controls to process text. "  
                + "You can give a text field an instance name in the Property inspector "
                + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                + "Target Path dialog box in the Actions panel.\n\n");

            var index:int = myTextField.getLineIndexOfChar(100);
            myTextField.appendText("100th character is in line: " +  (index + 1) + "\n");
            index = myTextField.getLineIndexOfChar(500);
            myTextField.appendText("500th character is in line: " + (index + 1));

            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineLength"><apiName>getLineLength</apiName><shortdesc>
	 Gibt die Zeichenanzahl in einer bestimmten Textzeile zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineLength, getLineLength
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die angegebene Zeilennummer befindet sich nicht im Bereich.
	 
 	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Die Anzahl der Zeichen in der Zeile.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Nummer der Zeile, deren Länge Sie ermitteln möchten.
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt die Zeichenanzahl in einer bestimmten Textzeile zurück.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt die Zeichenanzahl in einer bestimmten Textzeile zurück.
	 
	 </apiDesc><example conref="examples\TextField_getLineLengthExample.as"> Im folgenden Beispiel wird die Zeilenlänge (Anzahl der Zeichen) einer Zeile in einem separaten Feld angezeigt, wenn der Benutzer auf die Zeile klickt. 
 <p>Zur Veranschaulichung wird das Textfeld <codeph>myTextField</codeph>, in dem der zu zählende Text angezeigt wird, auf <codeph>INPUT</codeph> gesetzt, sodass der Benutzer die Zeilen ändern oder zwischen den Zeilen bzw. am Ende Zeilen hinzufügen kann. (Am Ende der letzten Zeile wird mithilfe eines Zeilenumbruchs (<codeph>\n</codeph>) eine leere Zeile erstellt.) Das Textfeld <codeph>countLines</codeph>, in dem das Ergebnis der Zeilenlängenermittlung angezeigt wird, wird unter dem Textfeld <codeph>myTextField</codeph> platziert, der Text in diesem Feld kann nicht ausgewählt werden. Wenn der Benutzer auf eine Zeile im Textfeld <codeph>myTextField</codeph> klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p>
 <p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getLineIndexAtPoint()</codeph>-Methode den Zeilenindex der Zeile zurück, auf die der Benutzer geklickt hat. Dazu werden die <codeph>localX</codeph>- und <codeph>localY</codeph>-Koordinaten des Mausklicks verwendet. Die <codeph>if</codeph>-Anweisung überprüft, ob der Benutzer auf ein Zeichen geklickt hat. Ist dies der Fall, gibt die <codeph>getLineLength()</codeph>-Methode unter Verwendung des Zeilenindex die Anzahl der Zeichen in der Zeile zurück. Beachten Sie, dass die leeren Zeilen zwischen den Zeilen das zweite Zeilenumbruchzeichen (<codeph>\n</codeph>) enthalten und eine Zählung von 1 Zeichen aufweisen, während die Zeile nach der letzten Zeile eine Zählung von 0 aufweist. Leerzeichen zählen ebenfalls als ein Zeichen. Der Benutzer kann eine neue Zeile schreiben oder eine Zeile ändern und die Zeichenzählung der Zeile erhalten, indem er auf die Zeile klickt. Wenn Zeilenumbrüche verwendet werden und die Bildschirmgröße geändert wird, könnte sich der Zeilenindex ändern.</p>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class TextField_getLineLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countLines:TextField = new TextField();  

        public function TextField_getLineLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 350;
            myTextField.height = 150;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.type = TextFieldType.INPUT;
            
            myTextField.appendText("Click on the lines to count its number of characters:\n\n");
            myTextField.appendText("This is a short line.\n");
            myTextField.appendText("This is a longer line than the last line.\n\n");
            myTextField.appendText("This one is even longer than the one before. It has two sentences.\n");

            this.addChild(myTextField);

            countLines.border = true;
            countLines.x = 10;
            countLines.y = 180;
            countLines.height = 30;
            countLines.width = 200;
            countLines.background = true;
            countLines.selectable = false;

           this.addChild(countLines);    

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getLineIndexAtPoint(e.localX, e.localY);
        
            if (index != -1) {
            var lenght:int = myTextField.getLineLength(index);

            countLines.text = "Number of characters in the line is: " + lenght.toString();
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineMetrics"><apiName>getLineMetrics</apiName><shortdesc>
	 Gibt metrische Informationen zu einer bestimmten Textzeile zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineMetrics, getLineMetrics
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die angegebene Zeilennummer befindet sich nicht im Bereich.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Ein TextLineMetrics-Objekt.
	 </apiDesc><apiOperationClassifier>flash.text:TextLineMetrics</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die Nummer der Zeile, für die Sie metrische Informationen ermitteln möchten.
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt metrische Informationen zu einer bestimmten Textzeile zurück.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt metrische Informationen zu einer bestimmten Textzeile zurück.
	 
	 </apiDesc><example conref="examples\TextField_getLineMetricsExample.as"> Im folgenden Beispiel werden einige metrische Zeilenwerte für zwei unterschiedlich formatierte Textzeilen angezeigt.
 
 <p>Der angehängte Text befindet sich zwei Zeilen unter dem Gedicht <i>Song of Myself</i> von Walt Whitman. Mit einem neuen TextFormat-Objekt (<codeph>newFormat</codeph>) wird das Format der zweiten Zeile festgelegt. Die erste Zeile enthält das Standardformat. Die <codeph>getLineMetrics()</codeph>-Methode gibt ein <codeph>TextLineMetrics</codeph>-Objekt für eine bestimmte Zeile zurück. (Der Zeilenindex beginnt mit 0.) Mit den TextLineMetrics-Objekten <codeph>metrics1</codeph> und <codeph>metrics2</codeph> für die erste und zweite Zeile werden jeweils die Werte für die Oberlänge (ascent), Unterlänge (descent), Höhe (height) und Strichstärke (weight) der Zeile abgerufen und angezeigt. Die resultierenden Zahlen werden in Strings konvertiert, jedoch nicht gerundet. Beachten Sie, dass dieser Wert für die Zeile und nicht für ein bestimmtes Zeichen gilt. Er spiegelt den Bereich der Zeichen für eine Zeile wieder. Wenn in einer Zeile zum Beispiel Zeichen mit unterschiedlichen Höhen vorkommen, bestimmt das Zeichen mit dem höchsten Wert für die Höhe den Wert. Dies bedeutet auch, dass sich einige metrische Werte ändern können, wenn das Format eines Zeichens geändert wird.</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.TextFormat;
 
    public class TextField_getLineMetricsExample extends Sprite {

        public function TextField_getLineMetricsExample() {
            var myTextField:TextField = new TextField();
            var newFormat:TextFormat = new TextFormat(); 

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.wordWrap = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.appendText("A child said What is the grass? fetching it to me with full hands;\n");
            myTextField.appendText("How could I answer the child? I do not know what it is any more than he.\n\n");

            newFormat.size = 14;
            newFormat.font = "Arial";
            newFormat.italic = true;
            myTextField.setTextFormat(newFormat, 67, 139);
               
            var metrics1:TextLineMetrics = myTextField.getLineMetrics(0);
             
            myTextField.appendText("Metrics ascent for the line 1 is: " + metrics1.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics1.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics1.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics1.width.toString() + "\n\n");

            var metrics2:TextLineMetrics = myTextField.getLineMetrics(1);
             
            myTextField.appendText("Metrics ascent for the line 2 is: " + metrics2.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics2.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics2.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics2.width.toString() + "\n");

            addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineOffset"><apiName>getLineOffset</apiName><shortdesc>
	 Gibt den Zeichenindex des ersten Zeichens in der vom Parameter „lineIndex“ angegebenen Zeile zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die angegebene Zeilennummer befindet sich nicht im Bereich.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der auf null basierende Indexwert des ersten Zeichens in der Zeile.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert für die Zeile mit Basis null (d. h., die erste Zeile ist 0, die zweite Zeile 1 usw.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Der auf null basierende Indexwert des ersten Zeichens in der Zeile.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt den Zeichenindex des ersten Zeichens in der vom Parameter <codeph>lineIndex</codeph> angegebenen Zeile zurück.
	 
	 </apiDesc><example conref="examples\TextField_getLineOffsetExample.as"> Im folgenden Beispiel wird das erste Zeichen in Zeile 4 überprüft, welches sich ändert, wenn die Größe des Bildschirms (und des Textfelds) geändert wird.
 
 <p>Für das Textfeld <codeph>myTextField</codeph> wird der Zeilenumbruch festgelegt. Im Textfeld <codeph>countField</codeph> wird das erste Zeichen der Zeile 4 angezeigt. Wenn der Benutzer auf das Textfeld <codeph>myTextField</codeph> klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen.</p>
 
 <p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getLineOffset()</codeph>-Methode den Index des ersten Zeichens bei Zeilenindex 3, also in der vierten Zeile des Textes, zurück. (Die erste Zeile hat den Index 0.) Die <codeph>charAt()</codeph>-Methode wird verwendet, um das Zeichen mithilfe des Index des ersten Zeichens der vierten Zeile abzurufen. Der Inhalt des Textfelds <codeph>countField</codeph> wird mit diesen Informationen aktualisiert; dazu wird die <codeph>text</codeph>-Eigenschaft des Textfelds <codeph>countField</codeph> verwendet. Die Verwendung der <codeph>countField.text</codeph>-Eigenschaft bedeutet, dass nach jedem Klick der Inhalt des Textfelds <codeph>countField</codeph> überschrieben wird. Wenn der Benutzer die Größe der Anzeige ändert, wird für den Inhalt ein Zeilenumbruch ausgeführt, und das erste Zeichen der Zeile 4 könnte sich ändern. Durch erneutes Klicken auf das Textfeld <codeph>myTextField</codeph> wird der Inhalt des Textfelds <codeph>countField</codeph> mit dem neuen ersten Zeichen der vierten Zeile aktualisiert.</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getLineOffsetExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();
        
        public function TextField_getLineOffsetExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 150;
            myTextField.height = 300;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;

            countField.height = 20;
            countField.width = 200;
            countField.x = 10;
            countField.y = 320;
            countField.selectable = false;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        
            this.addChild(myTextField);
            this.addChild(countField);
        }
    
            private function clickHandler(e:MouseEvent):void {
                var c:String;
                var index:int;
                
                index = myTextField.getLineOffset(3);
                c = myTextField.text.charAt(index);
                countField.text = "The first character of line 4 is: " + c;
            }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineText"><apiName>getLineText</apiName><shortdesc>
	 Gibt den Text der durch den Parameter „lineIndex“ angegebenen Zeile zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Die angegebene Zeilennummer befindet sich nicht im Bereich.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Der in der angegebenen Zeile enthaltene Textstring.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert für die Zeile mit Basis null (d. h., die erste Zeile ist 0, die zweite Zeile 1 usw.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Der in der angegebenen Zeile enthaltene Textstring.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt den Text der durch den Parameter <codeph>lineIndex</codeph> angegebenen Zeile zurück.
	 
	 </apiDesc><example conref="examples\TextField_getLineTextExample.as"> Im folgenden Beispiel werden die Zeilennummern aller Vorkommnisse des Wortes „love“ im Shakespeare-Sonett gesucht und angezeigt.
 
 <p>Das Textfeld <codeph>poem</codeph> wird so eingerichtet, dass es sich an den Text anpasst und links ausgerichteten Text anzeigt. Die <codeph>wordWrap</codeph>-Eigenschaft wird auf <codeph>false</codeph> gesetzt, sodass für die Zeilen des Gedichts kein Zeilenumbruch ausgeführt wird, obwohl dies normalerweise kein Problem sein sollte, wenn die <codeph>autoSize</codeph>-Eigenschaft verwendet wird. Die <codeph>for</codeph> -Schleife durchläuft die Zeilen des Sonetts mithilfe der <codeph>numLines</codeph>-Eigenschaft des Textfelds. Die <codeph>getLineText()</codeph>-Methode gibt den Inhalt der Zeile als String zurück. (Beachten Sie, dass die <codeph>numLines</codeph>-Eigenschaft die Anzahl der Zeilen ab 1 zurückgibt, während bei der <codeph>getLineText()</codeph>-Methode die Zeilennummern bei 0 anfangen.) Unter Verwendung des regulären Ausdrucks (<codeph>/love/i</codeph>) sucht die <codeph>if</codeph>-Anweisung nach Teilstrings des Worts und Groß- oder Kleinschreibung. Wenn der Ausdruck gefunden wird, gibt die <codeph>search</codeph>-Methode den Index des ersten übereinstimmenden Teilstrings zurück, andernfalls wird <codeph>-1</codeph> zurückgegeben (wenn kein Treffer gefunden wird). Die Nummer der Zeile, in der „love“ gefunden wurde (<codeph>(i + 1)</codeph>), wird dann in den String <codeph>lineResult</codeph> platziert. Die string-Methode konvertiert das number-Argument (<codeph>(i + 1)</codeph>) in einen String, sofern es ein anderes Argument gibt, das ein String ist (" "). Das Zeilenergebnis der Suche schließt Zeilen mit den Wörtern „loved“ oder „Love's“ mit ein. Wenn der String „Love was found in lines:“ (Liebe wurde in diesen Zeilen gefunden:) der <codeph>for</codeph>-Schleife vorangestellt würde, wäre das Wort „Love“ in dieser Zeile ebenfalls eingeschlossen worden.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
 
    public class TextField_getLineTextExample extends Sprite {
           
        public function TextField_getLineTextExample() {
           var poem:TextField = new TextField();
           var lineResult:String = ""; 
           var pattern:RegExp = /love/i;

            poem.x = 10;
            poem.y = 10;
            poem.background = true;
            poem.wordWrap = false;
            poem.autoSize = TextFieldAutoSize.LEFT;
            
            poem.text = "Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.\n\n";

            for (var i:int = 0; i &lt; poem.numLines; i++) {

                var s:String = poem.getLineText(i);
                        
                if(s.search(pattern) != -1) {
                    lineResult += (i + 1) + " ";
                }
            }

            poem.appendText("Love was found in lines: " + lineResult);
             
            this.addChild(poem);                      
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getParagraphLength"><apiName>getParagraphLength</apiName><shortdesc>
	 Gibt anhand eines Zeichenindex die Länge des Absatzes mit dem angegebenen Zeichen zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der angegebene Zeichenindex befindet sich nicht im Bereich.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Gibt die Anzahl der Zeichen im Absatz zurück.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert für das Zeichen mit Basis null (d. h., das erste Zeichen ist 0, das zweite Zeichen 1 usw.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Der auf null basierende Indexwert des Zeichens.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt anhand eines Zeichenindex die Länge des Absatzes mit dem angegebenen Zeichen zurück. Die Länge wird relativ zum ersten Zeichen im Absatz (wie von <codeph>getFirstCharInParagraph()</codeph> zurückgegeben) und nicht zum vorliegenden Zeichenindex angegeben.
	 
	 </apiDesc><example conref="examples\TextField_getParagraphLengthExample.as"> Im folgenden Beispiel wird die Länge des Absatzes sowie die Anzahl des Zeichens „s“ im Absatz in einem separaten Textfeld angezeigt, wenn der Benutzer eine Absatz auswählt.
 
 <p>Im Textfeld <codeph>myTextField</codeph> werden die Absätze angezeigt, die der Benutzer auswählt. Wenn der Benutzer auf das Textfeld klickt, wird das <codeph>MouseEvent.CLICK</codeph>-Ereignis ausgelöst und die <codeph>clickHandler()</codeph>-Methode wird aufgerufen. Die Länge des Absatzes und die Anzahl der „s“-Zeichen wird im Textfeld <codeph>countField</codeph> angezeigt, das unter dem Textfeld <codeph>myTextField</codeph> platziert wird.</p> 
 
 <p>In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getCharIndexAtPoint()</codeph>-Methode den Index des Zeichens zurück, basierend auf den <codeph>localX</codeph>- und <codeph>localY</codeph>-Koordinaten des Mausklicks. Die erste <codeph>if</codeph>-Anweisung überprüft, ob der Benutzer auf ein Zeichen geklickt hat. Die <codeph>getFirstCharInParagraph()</codeph>-Methode verwendet diesen Index, um den Index des ersten Zeichens im selben Absatz zurückzugeben. Die von der <codeph>getParagraphLength()</codeph>-Methode zurückgegebene Absatzlänge wird zusammen mit dem Index des ersten Zeichens im Absatz verwendet, um den Index für das Absatzende zu bestimmen. Eine <codeph>for</codeph>-Schleife durchläuft den Absatz und ermittelt die Anzahl der „s“-Zeichen.</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getParagraphLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();

        public function TextField_getParagraphLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 280;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file" 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField() constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            countField.x = 10;
            countField.y = 300;
            countField.height = 50;
            countField.width = 250;
            countField.background = true;
            countField.selectable = false;

            this.addChild(myTextField);
            this.addChild(countField);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
            
            if(index != -1) {
                var beginParag:int = myTextField.getFirstCharInParagraph(index);
                var paragLength:int = myTextField.getParagraphLength(index);
                var endParag:int = beginParag + paragLength;
                var sCount:uint = 0;

                for (var i:int = beginParag; i &lt;= endParag; i++) {
                    if ((myTextField.text.charAt(i) == "s") || (myTextField.text.charAt(i) == "S")) {
                        sCount++; 
                    }

                countField.text = "Paragraph length is: " + paragLength.toString() + "\n" 
                        + "Number of 's' characters in the paragraph: " + sCount.toString();
                }
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/getFirstCharInParagraph()"><linktext>flash.text.TextField.getFirstCharInParagraph()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getTextFormat"><apiName>getTextFormat</apiName><shortdesc>
	 Gibt ein TextFormat-Objekt mit Formatierungsinformationen für den durch die Parameter „beginIndex“ und „endIndex“ angegebenen Textbereich zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getTextFormat, getTextFormat
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Der angegebene <codeph>beginIndex</codeph> bzw. <codeph>endIndex</codeph> befindet sich nicht im Bereich.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Das TextFormat-Objekt, das die Formatierungseigenschaften des angegebenen Texts wiedergibt.
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Optional; eine Ganzzahl, die den Startpunkt eines Textbereichs innerhalb des Textfelds angibt.
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Optional; eine Ganzzahl zur Angabe der Position des ersten Zeichens nach dem gewünschten Textbereich. Wenn Sie die Werte <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> angeben, wird wie gewünscht der Text von <codeph>beginIndex</codeph> bis <codeph>endIndex-1</codeph> gelesen. 
	 
 	 </apiDesc></apiParam><apiTipTexts><apiTipText>Gibt ein TextFormat-Objekt zurück.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Gibt ein TextFormat-Objekt mit Formatierungsinformationen für den durch die Parameter <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> angegebenen Textbereich zurück. Nur Eigenschaften, die für den gesamten Text gelten, sind im resultierenden TextFormat-Objekt eingestellt. Für jede <i>gemischte</i> Eigenschaft, die an unterschiedlichen Stellen im Text unterschiedliche Werte aufweist, wird der Wert auf <codeph>null</codeph> gesetzt.
	 
	 <p>Wenn Sie keine Werte für diese Parameter angeben, wird diese Methode auf den gesamten Text im Textfeld angewendet.  </p>
	 
	 <p>In der folgenden Tabelle sind drei Verwendungsmöglichkeiten aufgeführt:</p>
	 
	 <adobetable class="innertable">
	   
	   
	 	 
	   
	 <tgroup cols="2"><thead><row><entry>Verwendung</entry><entry>Beschreibung</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.getTextFormat()</codeph></entry>
	 	   <entry>Gibt ein TextFormat-Objekt mit den Formatierungsinformationen für den gesamten Text in einem Textfeld zurück. Nur Eigenschaften, die für den gesamten Text im Textfeld gelten, sind im resultierenden TextFormat-Objekt eingestellt. Für jede <i>gemischte</i> Eigenschaft, die an unterschiedlichen Stellen im Text unterschiedliche Werte aufweist, wird der Wert auf <codeph>null</codeph> gesetzt.</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number)</codeph></entry>
	     <entry>Gibt ein TextFormat-Objekt mit einer Kopie des Textformats an der durch <codeph>beginIndex</codeph> gekennzeichneten Position zurück.</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number,endIndex:Number)</codeph></entry>
	     <entry>Gibt ein TextFormat-Objekt mit Formatierungsinformationen für den Textbereich zwischen <codeph>beginIndex</codeph> und <codeph>endIndex-1</codeph> zurück. Nur Eigenschaften, die für den gesamten Text im angegebenen Textbereich gelten, sind im resultierenden TextFormat-Objekt eingestellt. Alle „gemischten“ Eigenschaften (mixed), die an unterschiedlichen Stellen im Textbereich unterschiedliche Werte aufweisen, besitzen den Wert <codeph>null</codeph>.</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example>Bitte sehen Sie sich das Beispiel für die <xref href="TextField.html#getFirstCharInParagraph()">getFirstCharInParagraph()</xref>- oder <xref href="TextField.html#setTextFormat()">setTextFormat()</xref>-Methode an, in dem illustriert ist, wie die <codeph>getTextFormat()</codeph>-Methode verwendet wird. 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:isFontCompatible"><apiName>isFontCompatible</apiName><shortdesc>
	 Gibt „true“ zurück, wenn eine eingebettete Schriftart mit dem angegebenen fontName und fontStyle verfügbar ist, wobei Font.fontType gleich flash.text.FontType.EMBEDDED ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Der angegebene <codeph>fontStyle</codeph> ist kein Mitglied von <codeph>flash.text.FontStyle</codeph>.
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, wenn eine kompatible eingebettete Schriftart verfügbar ist, wenn nicht, dann <codeph>false</codeph>.
	 
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der zu überprüfenden eingebetteten Schriftart.
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Legt den Schriftstil fest, der geprüft werden soll. Verwenden Sie <codeph>flash.text.FontStyle</codeph>
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt „true“ zurück, wenn eine eingebettete Schriftart mit dem angegebenen <codeph>fontName</codeph> und <codeph>fontStyle</codeph> verfügbar ist, wobei <codeph>Font.fontType</codeph> gleich <codeph>flash.text.FontType.EMBEDDED</codeph> ist. Ab Flash Player 10 können zwei Arten von eingebetteten Schriftarten in einer SWF-Datei erscheinen. Normale eingebettete Schriftarten werden nur mit TextField-Objekten verwendet. CFF-Schriftarten werden nur von den flash.text.engine-Klassen verwendet. Die beiden Arten unterscheiden sich durch die <codeph>fontType</codeph>-Eigenschaft der <codeph>Font</codeph>-Klasse, die von der <codeph>enumerateFonts()</codeph>-Funktion zurückgegeben wird.
	 
	 <p>TextField kann keine Schriftarten des Typs <codeph>EMBEDDED_CFF</codeph> verwenden. Wenn <codeph>embedFonts</codeph> auf <codeph>true</codeph> gesetzt ist und die einzige Schriftart, die zur Laufzeit mit dem angegebenen Namen und Stil verfügbar ist, vom Typ <codeph>EMBEDDED_CFF</codeph> ist, kann Flash Player den Text nicht wiedergeben (so als ob keine eingebetteten Schriftarten mit dem angegebenen Namen und Stil zur Verfügung stünden).</p>
	 
	 <p>Wenn sowohl <codeph>EMBEDDED</codeph>- als auch <codeph>EMBEDDED_CFF</codeph>-Schriftarten mit dem gleichen Namen und Stil verfügbar sind, wird die <codeph>EMBEDDED</codeph>-Schriftart ausgewählt und Text wird mit der <codeph>EMBEDDED</codeph>-Schriftart wiedergegeben.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link><link href="flash.text.engine.xml#TextBlock/createTextLine"><linktext>flash.text.engine.TextBlock.createTextLine</linktext></link><link href="flash.text.xml#FontType/EMBEDDED_CFF"><linktext>flash.text.FontType.EMBEDDED_CFF</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceSelectedText"><apiName>replaceSelectedText</apiName><shortdesc>
	 Ersetzt die aktuelle Auswahl durch den Inhalt des Parameters „value“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.replaceSelectedText, replaceSelectedText
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Diese Methode kann bei einem Textfeld mit Stylesheet nicht verwendet werden.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, mit dem der aktuell ausgewählte Text ersetzt wird.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Ersetzt die aktuelle Auswahl durch den Inhalt des Parameters „value“.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Ersetzt die aktuelle Auswahl durch den Inhalt des Parameters <codeph>value</codeph>. Der Text wird an der Stelle eingefügt, an der sich die aktuelle Auswahl befindet; es werden das Standardzeichenformat und das Standardabsatzformat verwendet. Der Text wird nicht als HTML behandelt.
	 
	 <p>Mit der <codeph>replaceSelectedText()</codeph>-Methode können Sie Text einfügen und löschen, ohne die Zeichen- und Absatzformatierung des übrigen Textes zu beeinflussen.</p>
     <p><b>Hinweis:</b> Diese Methode funktioniert nicht, wenn ein Stylesheet auf das Textfeld angewendet wird.</p>
     
	 
	 </apiDesc><example conref="examples\TextField_replaceSelectedTextExample.as"> Im folgenden Beispiel löscht der Benutzer Text aus dem ersten Textfeld, indem er ihn auswählt und den ausgewählten Text im zweiten Textfeld durch den String „NEW TEXT“ ersetzt.
 
 <p>Es werden zwei verschiedene TextField-Objekte erstellt, und für die <codeph>MouseEvent.MOUSE_UP</codeph>-Ereignisse werden Ereignis-Listener hinzugefügt. „Mouse up“ tritt ein, wenn der Benutzer die Maustaste loslässt, ein Ereignis, das normalerweise nach der Auswahl eines Textabschnitts vorkommt. Beachten Sie, dass die Standardeinstellung eines Textfelds vorsieht, dass der darin befindliche Text ausgewählt werden kann.</p>
 
 <p>Mit der <codeph>mouseHandler1()</codeph>-Methode wird der Text gelöscht, indem er durch einen leeren String ersetzt wird, wenn der Benutzer die Maustaste im Textfeld <codeph>myTextField1</codeph> loslässt. Dies kann wiederholt werden, bis der gesamte Text gelöscht wurde. In der <codeph>mouseHandler2()</codeph>-Methode werden die Eigenschaften <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> überprüft, um festzustellen, ob Zeichen ausgewählt wurden, wenn ein Benutzer Text im Textfeld <codeph>myTextField2</codeph> auswählt. (Die Eigenschaften <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> haben nicht denselben Wert, wenn Text ausgewählt wurde.) Der ausgewählte Text wird dann durch den String „NEW TEXT“ ersetzt. Dies kann wiederholt werden, bis der gesamte ursprüngliche Text des zweiten Textfelds durch den String „NEW TEXT“ ersetzt wurde.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;    
    import flash.events.MouseEvent;

    public class TextField_replaceSelectedTextExample extends Sprite {
        private var myTextField1:TextField = new TextField();
        private var myTextField2:TextField = new TextField();
        
        public function TextField_replaceSelectedTextExample() {
            myTextField1.x = 10;
            myTextField1.width = 300;
            myTextField1.height = 50; 
            myTextField1.background = true; 
            myTextField1.border = true;
            myTextField1.text = "Select the text you want to remove from the line.";
            
            myTextField2.x = 10;
            myTextField2.y = 60;
            myTextField2.width = 300;
            myTextField2.height = 50;
            myTextField2.background = true;
            myTextField2.border = true;
            myTextField2.text = "Select the text you want to replace with NEW TEXT.";
            
            myTextField1.addEventListener(MouseEvent.MOUSE_UP, mouseHandler1);
            myTextField2.addEventListener(MouseEvent.MOUSE_UP, mouseHandler2);
            
            this.addChild(myTextField1);
            this.addChild(myTextField2);
        }
        
        private function mouseHandler1(e:MouseEvent):void {
            myTextField1.replaceSelectedText("");
        }

        private function mouseHandler2(e:MouseEvent):void {
            if(myTextField2.selectionBeginIndex != myTextField2.selectionEndIndex) {
                myTextField2.replaceSelectedText("NEW TEXT");    
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceText"><apiName>replaceText</apiName><shortdesc>
	 Ersetzt den Zeichenbereich, der durch die Parameter „beginIndex“ und „endIndex“ angegeben wird, durch den Inhalt des Parameters „newText“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Diese Methode kann bei einem Textfeld mit Stylesheet nicht verwendet werden.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der auf null basierende Indexwert für die Startposition des Ersetzungsbereichs.
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Die auf null basierende Indexposition des ersten Zeichens nach dem gewünschten Textabschnitt.
	 </apiDesc></apiParam><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Text, durch den der angegebene Zeichenbereich ersetzt werden soll.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Ersetzt einen Zeichenbereich.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Ersetzt den Zeichenbereich, der durch die Parameter <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> angegeben wird, durch den Inhalt des Parameters <codeph>newText.</codeph> Wie geplant wird der Text ab <codeph>beginIndex</codeph> bis <codeph>endIndex-1</codeph> ersetzt.  
     <p><b>Hinweis:</b> Diese Methode funktioniert nicht, wenn ein Stylesheet auf das Textfeld angewendet wird.</p>
     
	 </apiDesc><example conref="examples\TextField_replaceTextExample.as"> Im folgenden Beispiel wird die <codeph>replaceText()</codeph>-Methode verwendet, um Text in einem Textfeld zu löschen, zu ersetzen und einzufügen.
 
 <p>Das Textfeld <codeph>outputText</codeph> wird so eingerichtet, dass es sich an den Text anpasst und links ausgerichteten Text anzeigt. Mit dem ersten Aufruf der <codeph>replaceText()</codeph>-Methode wird die erste Zeile („This is the wrong heading“) durch „THIS IS THE HEADING FOR EVERYONE“ ersetzt. Mit dem zweiten Aufruf der Methode wird der Text „CORRECT“ zwischen „THE“ und „HEADING“ eingefügt. Mit dem dritten Aufruf der Methode werden die Worte „FOR EVERYONE“ gelöscht. Beachten Sie, dass mit jedem Aufruf der <codeph>appendText()</codeph>-Methode der Anfangs- und Endindex des Textes geändert wird. Hier wird nur der endgültige Text (nachdem alle Änderungen vorgenommen wurden) angezeigt.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_replaceTextExample extends Sprite {

        public function TextField_replaceTextExample() {
            var outputText:TextField = new TextField();

            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
            
            outputText.appendText("This is the wrong heading");
            outputText.appendText("\n\n"); 
            outputText.appendText("This is the body of the text.");

            outputText.replaceText(0, 25, "THIS IS THE HEADING FOR EVERYONE");

            outputText.replaceText(12, 12, "CORRECT ");
            
            outputText.replaceText(27, 40, "");
            
           this.addChild(outputText);
         }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:setSelection"><apiName>setSelection</apiName><shortdesc>
	 Legt den durch die Indexwerte des ersten und letzten Zeichens (Parameter „beginIndex und „endIndex“) angegebenen Text als ausgewählt fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der auf null basierende Indexwert für das erste Zeichen der Auswahl (d. h., das erste Zeichen ist 0, das zweite Zeichen 1 usw.).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der auf null basierende Indexwert des letzten Zeichens in der Auswahl.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Legt eine neue Textauswahl fest.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Legt den durch die Indexwerte des ersten und letzten Zeichens (Parameter <codeph>beginIndex</codeph> und <codeph>endIndex</codeph>) angegebenen Text als ausgewählt fest. Wenn die beiden Parameterwerte gleich sind, setzt diese Methode den Einfügepunkt (so als ob Sie die <codeph>caretIndex</codeph>-Eigenschaft setzen).
	 
	 </apiDesc><example conref="examples\TextField_setSelectionExample.as"> Wenn der Benutzer im folgenden Beispiel auf eine beliebige Stelle im Textfeld klickt, wird ein vordefinierter Textbereich ausgewählt (der die Wörter „TEXT IN ALL CAPS“ hervorhebt).
 
 <p>Zwei Ereignis-Listener für das Textfeld <codeph>myTextField</codeph> antworten auf das Betätigen bzw. auf das Loslassen der Maustaste durch den Benutzer. „Mouse up“ tritt ein, wenn der Benutzer die Maustaste loslässt, ein Ereignis, das normalerweise nach der Auswahl eines Textabschnitts vorkommt. Beachten Sie, dass die Standardeinstellung eines Textfelds vorsieht, dass der darin befindliche Text ausgewählt werden kann. Wenn auf Text geklickt wird, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen. Wenn Text ausgewählt wurde und die Maustaste losgelassen wird, wird die <codeph>mouseUpHandler()</codeph>-Methode aufgerufen.</p>
 
 <p>In beiden Methoden, <codeph>clickHandler()</codeph> und <codeph>mouseUpHandler()</codeph>, legt die <codeph>setSelection()</codeph>-Methode nur die Zeichen zwischen den Indizes 54 und 70 (TEXT IN ALL CAPS) als ausgewählt fest.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_setSelectionExample extends Sprite
    {
        private var myTextField:TextField = new TextField();

        public function TextField_setSelectionExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS is selected.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            myTextField.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);

            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

        private function mouseUpHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:setTextFormat"><apiName>setTextFormat</apiName><shortdesc>
	 Weist dem angegebenen Text in einem Textfeld die mit dem Parameter „format“ angegebene Textformatierung zu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.setTextFormat, setTextFormat
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Diese Methode kann bei einem Textfeld mit Stylesheet nicht verwendet werden.
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Der angegebene <codeph>beginIndex</codeph> bzw. <codeph>endIndex</codeph> befindet sich nicht im Bereich.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier><apiDesc>Ein TextFormat-Objekt, das sowohl Zeichen- als auch Absatzformatierungsinformationen enthält.
	 
     </apiDesc></apiParam><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Optional; eine Ganzzahl, die die auf null basierende Indexposition angibt, die ihrerseits das erste Zeichen im gewünschten Textbereich angibt.
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Optional; eine Ganzzahl zur Angabe des ersten Zeichens nach dem gewünschten Textbereich. Wenn Sie die Werte <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> angeben, wird wie gewünscht der Text von <codeph>beginIndex</codeph> bis <codeph>endIndex-1</codeph> aktualisiert.  
	 
	 <p>
	 <adobetable class="innertable">
	   
	   
	  
	   
	   
	 
	 <tgroup cols="2"><thead><row><entry>Verwendung</entry><entry>Beschreibung</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat)</codeph></entry>
	 
	     <entry>Wendet die Eigenschaften von <codeph>textFormat</codeph> auf den gesamten Text im Textfeld an.</entry>
	   </row><row>
	 
	 <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int)</codeph></entry>
	 
	     <entry>Wendet die Eigenschaften von <codeph>textFormat</codeph> auf den Text an, der an der Position <codeph>beginIndex</codeph> beginnt.</entry>
	   </row><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int, endIndex:int)</codeph></entry>
	 	   <entry>Wendet die Eigenschaften von <codeph>textFormat</codeph> auf den Textbereich zwischen <codeph>beginIndex</codeph> und <codeph>endIndex-1</codeph> an.</entry>
	   </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>Beachten Sie, dass manuell vom Benutzer eingefügter oder mit der <codeph>replaceSelectedText()</codeph>-Methode ersetzter Text nicht die für die Texteinfügemarke angegebene Formatierung, sondern die Standardformatierung für neuen Text des Textfelds erhält. Wenn Sie die Standardformatierung eines Textfelds für neuen Text definieren möchten, verwenden Sie die Eigenschaft <codeph>defaultTextFormat</codeph>.</p>
	 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Wendet Textformatierung an.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Weist dem angegebenen Text in einem Textfeld die mit dem Parameter <codeph>format</codeph> angegebene Textformatierung zu. Der Wert des Parameters <codeph>format</codeph> muss ein TextFormat-Objekt mit den gewünschten Änderungen bei der Textformatierung sein. Nur die Eigenschaften von <codeph>format</codeph>, die nicht null lauten, werden dem Textfeld zugewiesen. Eigenschaften von <codeph>format</codeph>, die auf <codeph>null</codeph> gesetzt wurden, werden nicht zugewiesen. Standardmäßig sind alle Eigenschaften eines neu erstellten TextFormat-Objekts auf <codeph>null</codeph> gesetzt.
     <p><b>Hinweis:</b> Diese Methode funktioniert nicht, wenn ein Stylesheet auf das Textfeld angewendet wird.</p>
     
	 <p>Mit der Methode <codeph>setTextFormat()</codeph> wird das Textformat geändert, das auf einen Zeichenbereich oder den gesamten Text in einem Textfeld angewendet wird. Geben Sie keine Werte für <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> an, wenn die Eigenschaften des Formats auf den kompletten Text im Textfeld angewendet werden sollen. Wenn Sie die Eigenschaften des Formats auf einen Textbereich anwenden möchten, geben Sie Werte für die Parameter <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> an. Mit der Eigenschaft <codeph>length</codeph> können Sie die Indexwerte bestimmen.</p>
	 
	 <p>Die beiden Arten von Formatierungsinformationen in einem TextFormat-Objekt sind Formatierungen auf Zeichen- und auf Absatzebene. Jedes Zeichen in einem Textfeld kann seine eigenen Zeichenformatierungseinstellungen (z. B. Schriftname, Schriftgrad, fett und kursiv) haben.</p>
	 
	 <p>Bei Absätzen wird das erste Zeichen im Absatz auf die für den gesamten Absatz geltenden Absatzformatierungseinstellungen überprüft. Es gibt unter anderem folgende Absatzformatierungseinstellungen: linker Rand, rechter Rand und Einzug.</p>
	 
	 <p>Jeder Text, der manuell vom Benutzer eingefügt oder durch die <codeph>replaceSelectedText()</codeph>-Methode ersetzt wird, erhält die Textfeld-Standardformatierung für neuen Text und nicht die Formatierung, die für den Texteinfügepunkt angegeben ist. Um die Standardformatierung für neuen Text festzulegen, verwenden Sie <codeph>defaultTextFormat</codeph>.</p>
	 
	 </apiDesc><example conref="examples\TextField_setTextFormatExample.as"> Im folgenden Beispiel wechselt beim Klicken auf den Text ein definierter Textbereich, „TEXT IN ALL CAPS“ zwischen dem Standardtextformat und dem neuen Format.
 
 <p>Es wird ein Ereignis-Listener für das Textfeld <codeph>myTextField</codeph> hinzugefügt, das auf Mausklicks reagiert, indem die <codeph>clickHandler()</codeph>-Methode aufgerufen wird. In der <codeph>clickHandler()</codeph>-Methode gibt die <codeph>getTextFormat()</codeph>-Methode das aktuelle Format eines Zeichens (Index 55) aus dem eingerückten Bereich des Texts zurück, welches dann in das TextFormat-Objekt <codeph>currentTextFormat</codeph> platziert wird. Die <codeph>if</codeph>-Anweisung überprüft das Textformat <codeph>currentTextFormat</codeph>, um festzustellen, ob die Zeichen in dem Bereich das neue Format verwenden (Schriftgröße 18 Punkt). Ist dies nicht der Fall, ändert das neue Format die Größe auf 18 Punkt, die Farbe auf Rot und wendet die Formate Unterstrichen und Kursiv auf den Bereich zwischen 54 und 70 (TEXT IN ALL CAPS) an. Wenn das Zeichen in dem Bereich das neue Format verwendet, wird das Format des Bereichs auf das Standardformat (das ursprüngliche Format) des Textfelds zurückgesetzt.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;  
    import flash.text.TextFieldAutoSize;  
    import flash.events.MouseEvent;

    public class TextField_setTextFormatExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextField_setTextFormatExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.selectable = false;
            myTextField.background = true;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS changes format.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            newFormat.color = 0xFF0000;
            newFormat.size = 18;
            newFormat.underline = true;
            newFormat.italic = true;
                
            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            var currentTextFormat:TextFormat = myTextField.getTextFormat(55);
            
            if(currentTextFormat.size != 18) {
                myTextField.setTextFormat(newFormat, 54, 70);
            }
            else {
                myTextField.setTextFormat(myTextField.defaultTextFormat);
            }    
        }    
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextField:alwaysShowSelection:get"><apiName>alwaysShowSelection</apiName><shortdesc>
	Wenn sich das Textfeld bei Einstellung „true“ nicht im Fokus befindet, markiert Flash Player die Auswahl im Textfeld in grau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
    
	</apiDefaultValue></apiValueDef><apiDesc>
	Wenn sich das Textfeld bei Einstellung <codeph>true</codeph> nicht im Fokus befindet, markiert Flash Player die Auswahl im Textfeld in grau. Wenn sich das Textfeld bei Einstellung <codeph>false</codeph> nicht im Fokus befindet, markiert Flash Player die Auswahl im Textfeld nicht.
	
    </apiDesc><example conref="examples\TextField_alwaysShowSelection.as"> Kompilieren Sie die folgende Datei, und führen Sie sie aus. Wenn Sie die Datei ausführen, ziehen Sie den Text in beide Textfelder, um ihn auszuwählen. Achten Sie auf den Unterschied bei der Markierung der Auswahl, wenn Sie Text in den beiden Textfeldern auswählen (und damit den Fokus ändern):
<codeblock>

    package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_alwaysShowSelection extends Sprite {
        public function TextField_alwaysShowSelection() {
            var label1:TextField = createCustomTextField(0, 20, 200, 20);
            label1.text = "This text is selected.";
            label1.setSelection(0, 9);
            label1.alwaysShowSelection = true;

            var label2:TextField = createCustomTextField(0, 50, 200, 20);
            label2.text = "Drag to select some of this text.";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x; result.y = y;
            result.width = width; result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:antiAliasType:get"><apiName>antiAliasType</apiName><shortdesc>
	 Der für dieses Textfeld verwendete Anti-Aliasing-Typ.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>This example creates two text fields and applies advanced anti-aliasing to the first one
	 only.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "This text uses advanced anti-aliasing.";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "This text uses normal anti-aliasing."
	 my_text2.antiAliasType = "normal";
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Der verwendete Anti-Aliasing-Typ.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Der für dieses Textfeld verwendete Anti-Aliasing-Typ. Verwenden Sie <codeph>flash.text.AntiAliasType</codeph>-Konstanten für diese Eigenschaft. Sie können diese Einstellung nur dann steuern, wenn die Schriftart eingebettet ist (die Eigenschaft <codeph>embedFonts</codeph> ist auf <codeph>true</codeph> gesetzt). Die Standardeinstellung ist <codeph>flash.text.AntiAliasType.NORMAL</codeph>.
	 
	 <p>Wenn Sie Werte für diese Eigenschaft definieren möchten, verwenden Sie die folgenden Stringwerte:</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Stringwert</entry><entry>Beschreibung</entry></row></thead><tbody><row>
	 	<entry><codeph>flash.text.AntiAliasType.NORMAL</codeph></entry>
	 	<entry>Wendet das normale Text-Anti-Aliasing an. Dieser Wert entspricht dem Anti-Aliasing-Typ, den Flash Player 7 und frühere Versionen verwendeten.</entry>
	   </row><row>
	   	<entry><codeph>flash.text.AntiAliasType.ADVANCED</codeph></entry>
	 	<entry>Wendet erweitertes Anti-Aliasing an, sodass der Text besser lesbar ist. (Diese Funktion ist seit Flash Player 8 verfügbar.) Erweitertes Anti-Aliasing ermöglicht die hochwertige Wiedergabe von kleinen Schriftarten. Es eignet sich am besten für Anwendungen mit sehr viel kleinem Text. Das erweiterte Anti-Aliasing bietet sich hingegen nicht für große Schriften (über 48 Punkte) an.</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link><link href="flash.text.xml#TextField/embedFonts"><linktext>flash.text.TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:autoSize:get"><apiName>autoSize</apiName><shortdesc>
	 Steuert die automatische Größenänderung und Ausrichtung von Textfeldern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.autoSize, autoSize
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der angegebene <codeph>autoSize</codeph>-Wert gehört nicht zu „flash.text.TextFieldAutoSize“.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Steuert die automatische Größenänderung und Ausrichtung von Textfeldern.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Steuert die automatische Größenänderung und Ausrichtung von Textfeldern. Zulässige Werte für die <codeph>TextFieldAutoSize</codeph>-Konstanten: <codeph>TextFieldAutoSize.NONE</codeph> (Standard), <codeph>TextFieldAutoSize.LEFT</codeph>, <codeph>TextFieldAutoSize.RIGHT</codeph> und <codeph>TextFieldAutoSize.CENTER</codeph>.
	 
	 <p>Wurde <codeph>autoSize</codeph> auf den Standardwert <codeph>TextFieldAutoSize.NONE</codeph> gesetzt, erfolgt keine Größenänderung.</p>
	 
	 <p>Wurde <codeph>autoSize</codeph> auf <codeph>TextFieldAutoSize.LEFT</codeph> gesetzt, wird der Text als linksbündiger Text behandelt, d. h., die linke Seite des Textfelds bleibt fixiert, und Größenänderungen eines einzeiligen Textfelds werden auf der rechten Seite vorgenommen. Wenn Text einen Zeilenumbruch enthält (z. B. <codeph>"\n"</codeph> oder <codeph>"\r"</codeph>), wird die unterste Zeile ebenfalls so geändert, dass die nächste Textzeile eingefügt werden kann. Wenn <codeph>wordWrap</codeph> ebenfalls auf <codeph>true</codeph> eingestellt ist, wird nur die Größe der untersten Zeile des Textfelds geändert, die rechte Seite bleibt dagegen unverändert.</p>
	 
	 <p>Wurde <codeph>autoSize</codeph> auf <codeph>TextFieldAutoSize.RIGHT</codeph> gesetzt, wird der Text als rechtsbündiger Text behandelt, d. h., die rechte Seite des Textfelds bleibt fixiert, und Größenänderungen eines einzeiligen Textfelds werden auf der linken Seite vorgenommen. Wenn Text einen Zeilenumbruch enthält (z. B. <codeph>"\n" oder "\r")</codeph>, wird die unterste Zeile ebenfalls so geändert, dass die nächste Textzeile eingefügt werden kann. Wenn <codeph>wordWrap</codeph> ebenfalls auf <codeph>true</codeph> eingestellt ist, wird nur die Größe der untersten Zeile des Textfelds geändert, die linke Seite bleibt dagegen unverändert.</p>
	 
	 <p>Wurde <codeph>autoSize</codeph> auf <codeph>TextFieldAutoSize.CENTER</codeph> gesetzt, wird der Text als zentriert behandelt, d. h., eine Änderung der Größe eines einzeiligen Textfelds wird gleichmäßig auf den rechten und linken Rand verteilt. Wenn Text einen Zeilenumbruch enthält (z. B. <codeph>"\n"</codeph> oder <codeph>"\r"</codeph>), wird die unterste Zeile ebenfalls so geändert, dass die nächste Textzeile eingefügt werden kann. Wenn <codeph>wordWrap</codeph> ebenfalls auf <codeph>true</codeph> eingestellt ist, wird nur die Größe der untersten Zeile des Textfelds geändert, die linke und rechte Seite bleiben dagegen unverändert.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFieldAutoSize"><linktext>flash.text.TextFieldAutoSize</linktext></link><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>flash.text.TextField.wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:background:get"><apiName>background</apiName><shortdesc>
	 Gibt an, ob das Textfeld einen gefüllten Hintergrund aufweist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.background, background
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Gibt an, ob das Textfeld einen gefüllten Hintergrund aufweist. Bei <codeph>true</codeph> weist das Textfeld einen gefüllten Hintergrund auf. Bei <codeph>false</codeph> weist das Textfeld keinen gefüllten Hintergrund auf. Mit der Eigenschaft <codeph>backgroundColor</codeph> legen Sie die Hintergrundfarbe eines Textfelds fest.
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/backgroundColor"><linktext>flash.text.TextField.backgroundColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:backgroundColor:get"><apiName>backgroundColor</apiName><shortdesc>
	 Gibt die Hintergrundfarbe des Textfelds an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.backgroundColor, backgroundColor, background Color
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Hintergrundfarbe des Textfelds an. Der Standardwert ist <codeph>0xFFFFFF</codeph> (weiß). Diese Eigenschaft kann abgerufen oder eingestellt werden, selbst wenn derzeit kein Hintergrund verwendet wird. Die Farbe ist jedoch nur dann sichtbar, wenn die Eigenschaft <codeph>background</codeph> des Textfelds <codeph>true</codeph> ist.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/background"><linktext>flash.text.TextField.background</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:border:get"><apiName>border</apiName><shortdesc>
	 Gibt an, ob das Textfeld umrahmt ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.border, border
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Gibt an, ob das Textfeld umrahmt ist. Bei <codeph>true</codeph> ist das Textfeld umrahmt. Bei <codeph>false</codeph> weist das Textfeld keinen Rahmen auf. Mit der Eigenschaft <codeph>borderColor</codeph> können Sie die Rahmenfarbe festlegen.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/borderColor"><linktext>flash.text.TextField.borderColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:borderColor:get"><apiName>borderColor</apiName><shortdesc>
	 Gibt die Farbe des Textfeldrahmens an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.borderColor, borderColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Farbe des Textfeldrahmens an. Der Standardwert ist <codeph>0x000000</codeph> (schwarz). Diese Eigenschaft kann abgerufen oder eingestellt werden, selbst wenn derzeit kein Rahmen verwendet wird. Die Farbe ist jedoch nur dann sichtbar, wenn die Eigenschaft <codeph>border</codeph> des Textfelds <codeph>true</codeph> ist.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/border"><linktext>flash.text.TextField.border</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:bottomScrollV:get"><apiName>bottomScrollV</apiName><shortdesc>
	 Eine Ganzzahl (Index mit Basis 1), die die unterste der im angegebenen Textfeld sichtbaren Zeilen angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.bottomScrollV, bottomScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Eine Ganzzahl, mit der die unterste Zeile in einem Textfeld angegeben wird.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Eine Ganzzahl (Index mit Basis 1), die die unterste der im angegebenen Textfeld sichtbaren Zeilen angibt. Das Textfeld kann als Fenster zur Anzeige eines Textblocks betrachtet werden. Die Eigenschaft <codeph>scrollV</codeph> ist der auf eins basierende Index der obersten sichtbaren Zeile im Fenster.
	 
	 <p>Der gesamte Text zwischen den durch <codeph>scrollV</codeph> und <codeph>bottomScrollV</codeph> begrenzten Zeilen ist zurzeit im Textfeld sichtbar.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:caretIndex:get"><apiName>caretIndex</apiName><shortdesc>
	 Der Index der Position der Einfügemarke.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Gibt den auf null basierenden Indexwert der blinkenden Einfügemarke zurück.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Der Index der Position der Einfügemarke. Wenn keine Einfügemarke angezeigt wird, ergibt sich der Wert aus der Position, die die Einfügemarke erhält, wenn das Feld den Fokus zurückerlangt (normalerweise die Stelle, an der sich die Einfügemarke zuvor befunden hat, oder 0, wenn das Feld bislang nicht den Fokus hatte).
	 
	 <p>Indizes für Auswahlbereiche haben die Basis null (d. h. die erste Position ist 0, die zweite Position 1 usw.).</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> In diesem Beispiel wird eine TextField-Instanz erstellt und mit Text gefüllt. Es wird ein Ereignis-Listener zugewiesen, damit die <codeph>printCursorPosition</codeph>-Methode aufgerufen wird, sobald der Benutzer auf die TextField-Instanz klickt. In diesem Fall werden die Werte der Eigenschaften <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> ausgegeben.
 
 <p>Führen Sie dieses Beispiel aus, und versuchen Sie, durch Klicken in die TextField-Instanz Text auszuwählen. Klicken Sie anschließend in das Feld, ohne Text auszuwählen. Wenn Sie in den Text klicken, ohne eine Auswahl vorzunehmen, gibt die Eigenschaft <codeph>caretIndex</codeph> an, wo sich die Einfügemarke befindet, und die Eigenschaften <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> sind identisch mit dem Wert der Eigenschaft <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:condenseWhite:get"><apiName>condenseWhite</apiName><shortdesc>
	 Ein Boolescher Wert, der angibt, ob zusätzliche Leerräume (beispielsweise Leerzeichen oder Zeilenumbrüche) aus einem Textfeld mit HTML-Text entfernt werden sollen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>textfield, text, HTML
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Ein boolescher Wert, mit dem zusätzlicher Leerraum aus einem HTML-Textfeld entfernt wird.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein Boolescher Wert, der angibt, ob zusätzliche Leerräume (beispielsweise Leerzeichen oder Zeilenumbrüche) aus einem Textfeld mit HTML-Text entfernt werden sollen. Der Standardwert ist <codeph>false</codeph>. Die Eigenschaft <codeph>condenseWhite</codeph> betrifft nur Text mit der Eigenschaft <codeph>htmlText</codeph>, nicht mit der Eigenschaft <codeph>text</codeph>. Wenn Sie Text mit der Eigenschaft <codeph>text</codeph> festlegen, wird <codeph>condenseWhite</codeph> ignoriert.
	 
	 <p>Wenn <codeph>condenseWhite</codeph> auf <codeph>true</codeph> gesetzt ist, verwenden Sie HTML-Standardbefehle wie <codeph>&lt;BR></codeph> und <codeph>&lt;P></codeph>, um in das Textfeld Zeilenumbrüche einzufügen.</p>
	 
	 <p>Legen Sie die Eigenschaft <codeph>condenseWhite</codeph> fest, bevor Sie die Eigenschaft <codeph>htmlText</codeph> festlegen.</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_condenseWhite.as"> Aus dem folgenden Beispiel geht der Unterschied zwischen der Einstellung <codeph>false</codeph> und <codeph>true</codeph> für <codeph>condenseWhite</codeph> hervor:
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_condenseWhite extends Sprite {
        public function TextField_condenseWhite() {
            var tf1:TextField = createCustomTextField(0, 0, 200, 50);
            tf1.condenseWhite = false;
            tf1.htmlText = "keep    on\n\ttruckin'";
            
            var tf2:TextField = createCustomTextField(0, 120, 200, 50);
            tf2.condenseWhite = true;
            tf2.htmlText = "keep    on\n\ttruckin'";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:defaultTextFormat:get"><apiName>defaultTextFormat</apiName><shortdesc>
	 Legt das Format fest, das auf neu eingefügten Text (z. B. von einem Benutzer eingegebener Text oder Text, der mit der replaceSelectedText()-Methode eingefügt wird) angewendet wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.defaultTextFormat, defaultTextFormat
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:TextFormat</apiValueClassifier><apiException><apiDesc>Diese Methode kann bei einem Textfeld mit Stylesheet nicht verwendet werden.
	  
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Gibt das Textformat für neu eingefügten Text an.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Legt das Format fest, das auf neu eingefügten Text (z. B. von einem Benutzer eingegebener Text oder Text, der mit der <codeph>replaceSelectedText()</codeph>-Methode eingefügt wird) angewendet wird.
	 
	 <p><b>Hinweis:</b> Wenn Zeichen ausgewählt werden, die mit <codeph>setSelection()</codeph> und <codeph>replaceSelectedText()</codeph> ersetzt werden sollen, wird das <codeph>defaultTextFormat</codeph> nur angewendet, wenn der Text bis zu und einschließlich dem letzten Zeichen ausgewählt wurde. Hier ist ein Beispiel:</p>
	 <pre>
	 var my_txt:TextField new TextField();
	 my_txt.text = "Flash Macintosh version";
	 var my_fmt:TextFormat = new TextFormat();
	 my_fmt.color = 0xFF0000;
	 my_txt.defaultTextFormat = my_fmt;
	 my_txt.setSelection(6,15); // partial text selected - defaultTextFormat not applied
	 my_txt.setSelection(6,23); // text selected to end - defaultTextFormat applied
	 my_txt.replaceSelectedText("Windows version");
	 </pre>
	 
	 <p>Bei Aufruf der Eigenschaft <codeph>defaultTextFormat</codeph> sind alle Eigenschaften des zurückgegebenen TextFormat-Objekts definiert. Keine Eigenschaft besitzt den Wert <codeph>null</codeph>.</p>
     <p><b>Hinweis:</b> Diese Eigenschaft kann nicht festgelegt werden, wenn ein Stylesheet auf das Textfeld angewendet wird.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/replaceSelectedText()"><linktext>flash.text.TextField.replaceSelectedText()</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:displayAsPassword:get"><apiName>displayAsPassword</apiName><shortdesc>
	 Gibt an, ob es sich um ein Kennworttextfeld handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.password, password
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Gibt an, ob Eingabezeichen verborgen sind.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Gibt an, ob es sich um ein Kennworttextfeld handelt. Weist die Eigenschaft den Wert <codeph>true</codeph> auf, handelt es sich um ein Kennworttextfeld, und statt der eingegebenen Zeichen werden Sternchen angezeigt. Bei <codeph>false</codeph> handelt es sich nicht um ein Kennworttextfeld. Wenn der Kennwortmodus aktiviert ist, können die Befehle „Ausschneiden“ und „Kopieren“ sowie die entsprechenden Tastaturbefehle nicht verwendet werden. Dieser Sicherheitsmechanismus verhindert, dass skrupellose Benutzer anhand des Tastaturbefehls das Kennwort eines unbeaufsichtigten Computers herausfinden.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:embedFonts:get"><apiName>embedFonts</apiName><shortdesc>
	 Gibt an, ob bei der Wiedergabe eingebettete Schriftkonturen verwendet werden sollen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.embedFonts, embedFonts
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Das Textfeld wird mit Schriftkonturen oder Geräteschriftarten wiedergegeben.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Gibt an, ob bei der Wiedergabe eingebettete Schriftkonturen verwendet werden sollen. Bei <codeph>false</codeph> wird das Textfeld mit Geräteschriftarten dargestellt.
	 
	 <p>Wenn Sie die Eigenschaft <codeph>embedFonts</codeph> für ein Textfeld auf <codeph>true</codeph> setzen, müssen Sie für diesen Text mit der Eigenschaft <codeph>font</codeph> eines auf das Textfeld angewendeten TextFormat-Objekts eine Schriftart angeben. Wenn die angegebene Schriftart nicht in der SWF-Datei eingebettet ist, wird der Text nicht angezeigt.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#Font/enumerateFonts()"><linktext>Font.enumerateFonts()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:gridFitType:get"><apiName>gridFitType</apiName><shortdesc>
	 Die für dieses Textfeld verwendete Art der Rasteranpassung.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example shows three text fields that use the
	 different <code>flash.text.GridFitType</code> settings.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 9.5, 10, 400, 100);
	 my_text1.text = "this.gridFitType = none";
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "none";
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 9.5, 40, 400, 100);
	 my_text2.text = "this.gridFitType = advanced";
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 9.5, 70, 400, 100);
	 my_text3.text = "this.gridFitType = subpixel";
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "subpixel";
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>pixel
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Die verwendete Art der Rasteranpassung.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die für dieses Textfeld verwendete Art der Rasteranpassung. Diese Eigenschaft gilt nur dann, wenn die Eigenschaft <codeph>flash.text.AntiAliasType</codeph> des Textfelds auf <codeph>flash.text.AntiAliasType.ADVANCED</codeph> gesetzt ist.
	 
	 <p>Anhand der verwendeten Art der Rasteranpassung wird bestimmt, ob Flash Player breite horizontale und vertikale Linien an ein Pixel- oder Subpixelraster anpasst.</p>
	 
	 <p>Für die Eigenschaft <codeph>flash.text.GridFitType</codeph> können Sie die folgenden Stringwerte verwenden:</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Stringwert</entry><entry>Beschreibung</entry></row></thead><tbody><row>
	     <entry><codeph>flash.text.GridFitType.NONE</codeph></entry>
	     <entry>Definiert keine Rasteranpassung. Horizontale und vertikale Linien in den Glyphen werden nicht am Pixelraster ausgerichtet. Diese Einstellung wird für Animationen und große Schriftgrade empfohlen.</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.PIXEL</codeph></entry>
	     <entry>Definiert die Anpassung breiter horizontaler und vertikaler Linien an das Pixelraster. Diese Einstellung funktioniert nur für linksbündig ausgerichtete Textfelder. Wenn Sie diese Einstellung nutzen möchten, muss die Eigenschaft <codeph>flash.display.AntiAliasType</codeph> des Textfelds auf <codeph>flash.text.AntiAliasType.ADVANCED</codeph> gesetzt sein. Diese Einstellung bietet im Allgemeinen die beste Lesbarkeit für linksbündigen Text.</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.SUBPIXEL</codeph></entry>
	     <entry>Breite horizontale und vertikale Linien werden an das Sub-Pixelraster auf LCD-Displays angepasst. Wenn Sie diese Einstellung nutzen möchten, muss die Eigenschaft <codeph>flash.text.AntiAliasType</codeph> des Textfelds auf <codeph>flash.text.AntiAliasType.ADVANCED</codeph> gesetzt sein. Die Einstellung <codeph>flash.text.GridFitType.SUBPIXEL</codeph> eignet sich oft für rechtsbündigen oder zentrierten dynamischen Text und ist manchmal eine praktische Alternative, wenn zwischen Animations- und Textqualität abzuwägen ist.</entry>
	   </row></tbody></tgroup></adobetable>
	 
     </apiDesc><example conref="examples\TextField_gridFitType.as"> Das folgende Beispiel zeigt drei Textfelder mit verschiedenen Einstellungen für die <codeph>gridFitType</codeph>-Eigenschaft. Achten Sie bei diesem Beispiel auf den Unterschied in der Lesbarkeit der ersten beiden Zeilen. Beachten Sie auch die optimale Verwendung von <codeph>GridFitType.PIXEL</codeph> für link ausgerichteten Text und <codeph>GridFitType.SUBPIXEL</codeph> für rechts ausgerichteten Text.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;

    public class gridFitTypeExample extends Sprite
    {
        public function gridFitTypeExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=12;

    var tf1:TextField = createCustomTextField(0,0,format1,"NONE",TextFieldAutoSize.LEFT,GridFitType.NONE);
    
    var tf2:TextField = createCustomTextField(0,30,format1,"PIXEL",TextFieldAutoSize.LEFT,GridFitType.PIXEL);

    var tf3:TextField = createCustomTextField(300,60,format1,"SUBPIXEL",TextFieldAutoSize.RIGHT,GridFitType.SUBPIXEL);

        }
        private function createCustomTextField(x:Number,y:Number,fm:TextFormat,tl:String,tfs:String,gft:String):TextField 
        {
            var result:TextField = new TextField();
            result.x=x;
            result.y=y;
            result.embedFonts=true;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.text="This text uses a gridFitType of " + tl;
            result.autoSize=tfs;
        result.gridFitType=gft;
            result.setTextFormat(fm);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#GridFitType"><linktext>flash.text.GridFitType</linktext></link><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:htmlText:get"><apiName>htmlText</apiName><shortdesc>
	 Enthält die HTML-Darstellung des Inhalts des Textfelds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.htmlText, htmlText
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Die HTML-Darstellung des Inhalts des Textfelds.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Enthält die HTML-Darstellung des Inhalts des Textfelds. 
	 
	 <p>Flash Player unterstützt die folgenden HTML-Tags:</p>
	 
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 Tag
	 </entry><entry>
	 Beschreibung
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 Anker-Tag
	 </entry>
	 
	 <entry>
	 Mit dem Tag <codeph>&lt;a></codeph> wird ein Hyperlink erstellt. Das Tag unterstützt die folgenden Attribute:
	 <ul>
	 
	 <li>
	 <codeph>target</codeph>: Gibt den Namen des Zielfensters an, in das die Seite geladen werden soll. Folgende Optionen stehen zur Verfügung: <codeph>_self</codeph>, <codeph>_blank</codeph>, <codeph>_parent</codeph> und <codeph>_top</codeph>. Mit der Option <codeph>_self</codeph> wird der aktuelle Frame im aktuellen Fenster angegeben, mit <codeph>_blank</codeph> ein neues Fenster, mit <codeph>_parent</codeph> der dem aktuellen Frame übergeordnete Frame und mit <codeph>_top</codeph> der Frame der obersten Stufe im aktuellen Fenster. 
	 </li>
	 
	 <li>
	 <codeph>href</codeph>: Legt eine URL oder ein ActionScript <codeph>link</codeph>-Ereignis fest. Die URL kann ein absoluter oder relativer Pfad zum Speicherort der SWF-Datei sein, von der die Seite geladen wird. Ein Beispiel für einen absoluten Verweis auf eine URL ist <codeph>http://www.adobe.com</codeph>, während <codeph>/index.html</codeph> ein relativer Verweis ist. Absolute URLs müssen mit dem Präfix http:// versehen sein, da Flash Player bzw. AIR sie ansonsten als relative URLs behandelt. Sie können mit dem Ereignis <codeph>link</codeph> festlegen, dass der Link eine ActionScript-Funktion in einer SWF-Datei ausführt, anstatt eine URL zu öffnen. Um ein <codeph>link</codeph>-Ereignis anzugeben, verwenden Sie das Ereignisschema anstelle des http-Schemas im <codeph>href</codeph>-Attribut. Ein Beispiel ist <codeph>href="event:myText"</codeph> anstelle von <codeph>href="http://myURL"</codeph>; wenn der Benutzer auf einen Hypertext-Link klickt, der das Ereignisschema enthält, löst das Textfeld ein <codeph>link</codeph> TextEvent aus, dessen <codeph>text</codeph>-Eigenschaft den Wert "<codeph>myText</codeph>" aufweist. Sie können dann eine ActionScript-Funktion erstellen, die ausgeführt wird, wann immer das link-TextEvent ausgelöst wird. Sie können auch mit Stylesheets die Stile <codeph>a:link</codeph>, <codeph>a:hover</codeph> und <codeph>a:active</codeph> für Anker-Tags definieren.
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Fettdruck-Tag
	 </entry>
	 
	 <entry>
	 Mit dem Tag <codeph>&lt;b></codeph> wird Text fett dargestellt. Für die verwendete Schriftart muss ein fettes Schriftbild vorhanden sein.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Zeilenumbruch-Tag
	 </entry>
	 <entry>
	 Das Tag <codeph>&lt;br></codeph> fügt einen Zeilenumbruch in das Textfeld ein. Definieren Sie das Textfeld als mehrzeiliges Textfeld, um dieses Tag zu verwenden.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Schriftart-Tag
	 </entry>
	 
	 <entry>
	 Mit dem Tag <codeph>&lt;font></codeph> legen Sie fest, welche Schriftarten für die Textanzeige verwendet werden. Die folgenden Attribute werden vom font-Tag unterstützt::
	 <ul>
	 
	 <li>
	 <codeph>color</codeph>: Es werden nur hexadezimale Farbwerte (<codeph>#FFFFFF</codeph>) unterstützt. 
	 </li>
	 
	 <li>
	 <codeph>face</codeph>: Gibt den Namen der zu verwendenden Schriftart an. Sie können wie im folgenden Beispiel dargestellt eine durch Kommas getrennte Liste von Schriftartnamen angeben. In diesem Fall wählt Flash Player die erste verfügbare Schriftart. Wenn die angegebene Schriftart nicht auf dem lokalen Computersystem installiert oder nicht in der SWF-Datei eingebettet ist, wählt Flash Player eine Ersatzschriftart aus. 
	 </li>
	 
	 <li>
	 <codeph>size</codeph>: Gibt die Größe der Schriftart an. Sie können absolute Pixelgrößen wie 16 oder 18 oder relative Punktgrößen wie +2 und -4 verwenden. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Bild-Tag
	 </entry>
	 
	 <entry>
	 Mit dem Tag <codeph>&lt;img></codeph> können Sie externe Bilddateien (JPEG, GIF, PNG), SWF-Dateien und Movieclips in Textfelder einbetten. Text fließt automatisch um in Textfelder eingebettete Bilder herum. Sie müssen das Textfeld als mehrzeilig definieren, um Text um ein Bild fließen zu lassen. 
	 
	  <p>Die folgenden Attribute werden vom <codeph>&lt;img></codeph>-Tag unterstützt: </p>
	 
	 <ul>
	 
	 <li>
	 <codeph>src</codeph>: Definiert die URL zu einer Bild- oder SWF-Datei bzw. den Verknüpfungsbezeichner eines Movieclip-Symbols in der Bibliothek. Dieses Attribut ist erforderlich. Alle anderen sind optional. Externe Dateien (JPEG, GIF, PNG und SWF) werden erst dann angezeigt, wenn sie komplett heruntergeladen worden sind. 
	 </li>
	 
	 <li>
	 <codeph>width</codeph>: Die Breite des einzufügenden Bilds, der SWF-Datei oder des Movieclips in Pixel. 
	 </li>
	 
	 <li>
	 <codeph>height</codeph>: Die Höhe des einzufügenden Bilds, der SWF-Datei oder des Movieclips in Pixel. 
	 </li>
	 
	 <li>
	 <codeph>align</codeph>: Legt die horizontale Ausrichtung des eingebetteten Bilds im Textfeld fest. Gültige Werte sind <codeph>left</codeph> und <codeph>right</codeph>. Der Standardwert ist <codeph>left</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>hspace</codeph>: Legt die Größe des horizontalen Bereichs um das Bild fest, in dem kein Text zu sehen ist. Der Standardwert ist 8. 
	 </li>
	 
	 <li>
	 <codeph>vspace</codeph>: Legt die Größe des vertikalen Bereichs um das Bild fest, in dem kein Text zu sehen ist. Der Standardwert ist 8.  
	 </li>
	 
	 <li>
	 <codeph>id</codeph>: Definiert den Namen der Movieclip-Instanz (von Flash Player erstellt), die die eingebettete Bild- oder SWF-Datei bzw. den Movieclip enthält. Diese Methode wird verwendet, um den eingebetteten Inhalt mit ActionScript zu steuern. 
	 </li>
	 
	 <li>
	 <codeph>checkPolicyFile</codeph>: Gibt an, dass Flash Player nach einer URL-Richtliniendatei auf dem Server suchen soll, der mit der Bilddomäne verknüpft ist. Wenn eine Richtliniendatei existiert, können SWF-Dateien in den Domänen, die in der Datei aufgelistet sind, auf die Daten des geladenen Bildes zugreifen, indem sie beispielsweise die <codeph>BitmapData.draw()</codeph>-Methode mit diesem Bild als <codeph>source</codeph>-Parameter aufrufen. Weitere Informationen finden Sie im Kapitel „Sicherheitsaspekte im Flash Player“ des Handbuchs <i>Programmieren mit ActionScript 3.0</i>.
	 </li>
	 
	 </ul>
	  <p>Medieninhalte, die in Textfelder eingebettet sind, werden in voller Größe angezeigt. Um die Abmessung der Medien anzugeben, die Sie einbetten, verwenden Sie das <codeph>&lt;img></codeph>-Tag und das <codeph>height</codeph>- und <codeph>width</codeph>-Attribut. </p>
	 
	  <p>Im Allgemeinen wird ein in ein Textfeld eingebettetes Bild in der Zeile nach dem Tag <codeph>&lt;img></codeph> angezeigt. Ist jedoch das <codeph>&lt;img></codeph>-Tag das erste Zeichen im Textfeld, erscheint das Bild dort in der ersten Zeile. </p>
	 
	 <p>Wenn sich in der Sicherheitssandbox der Anwendung AIR-Inhalt befindet, ignoriert AIR <codeph>img</codeph>-Tags im HTML-Inhalt in ActionScript TextField-Objekten. Hierdurch werden eventuelle Phishing-Angriffe verhindert.</p>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Kursiv-Tag
	 </entry>
	 
	 <entry>
	 Mit dem <codeph>&lt;i></codeph>-Tag markierter Text wird kursiv angezeigt. Für die verwendete Schriftart muss ein kursives Schriftbild vorhanden sein.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Listenelement-Tag
	 </entry>
	 
	 <entry>
	 Das Tag <codeph>&lt;li></codeph> sorgt dafür, dass vor dem Text, der vom Tag umschlossen ist, ein Aufzählungszeichen platziert wird. <b>Hinweis:</b> Dae Flash Player und AIR sortierte und unsortierte Listen-Tags (<codeph>&lt;ol></codeph> und <codeph>&lt;ul></codeph> nicht erkennen, ändern sie nicht, wie Ihre Liste wiedergegeben wird. Alle Listen werden unsortiert und mit Aufzählungszeichen vor jedem einzelnen Element angezeigt.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Absatz-Tag
	 </entry>
	 
	 <entry>
	 Mit dem Tag <codeph>&lt;p></codeph> wird ein neuer Absatz erstellt. Das Textfeld muss als mehrzeiliges Textfeld definiert werden, um dieses Tag zu verwenden. Die folgenden Attribute werden vom <codeph>&lt;p></codeph>-Tag unterstützt:
	 <ul>
	 
	 <li>
	 align: Gibt die Ausrichtung des Texts innerhalb des Absatzes an. Gültige Werte sind <codeph>left</codeph>, <codeph>right</codeph>, <codeph>justify</codeph> und <codeph>center</codeph>. 
	 </li>
	 
	 <li>
	 class: Legt eine von einem flash.text.StyleSheet-Objekt definierte CSS-Stilklasse fest. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Bereichs-Tag
	 </entry>
	 
	 <entry>
	 
	 Das Tag <codeph>&lt;span></codeph> ist nur im Einsatz mit CSS-Textstilen verfügbar. Das folgende Attribut wird dabei unterstützt:
	 
	 <ul>
	 
	 <li>
	 class: Legt eine von einem flash.text.StyleSheet-Objekt definierte CSS-Stilklasse fest. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Textformat-Tag
	 </entry>
	 
	 <entry>
	  <p>Mit dem Tag <codeph>&lt;textformat></codeph> können Sie einige Eigenschaften der TextFormat-Klasse zur Absatzformatierung in Textfeldern nutzen. Dazu zählen Zeilenabstand, Einzug, Ränder und Tabstopps. Sie können das Tag <codeph>&lt;textformat></codeph> mit den integrierten HTML-Tags kombinieren. </p>
	 
	  <p>Die folgenden Attribute werden vom Tag <codeph>&lt;textformat></codeph> unterstützt: </p>
	 <ul>
	 
	 <li>
	 <codeph>blockindent</codeph>: Legt den Blockeinzug in Punkten fest; entspricht <codeph>TextFormat.blockIndent</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>indent</codeph>: Legt den Einzug vom linken Rand bis zum ersten Zeichen im Absatz fest; entspricht <codeph>TextFormat.indent</codeph>. Es können positive und negative Werte verwendet werden. 
	 </li>
	 
	 <li>
	 <codeph>leading</codeph>: Legt den Zeilenabstand (vertikal) fest; entspricht <codeph>TextFormat.leading</codeph>. Es können positive und negative Werte verwendet werden. 
	 </li>
	 
	 <li>
	 <codeph>leftmargin</codeph>: Legt den linken Rand im Absatz in Punkten fest; entspricht <codeph>TextFormat.leftMargin</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>rightmargin</codeph>: Legt den rechten Rand im Absatz in Punkten fest; entspricht <codeph>TextFormat.rightMargin</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>tabstops</codeph>: Gibt benutzerdefinierte Tabstopps als Array aus nicht negativen Ganzzahlen an; entspricht <codeph>TextFormat.tabStops</codeph>. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Unterstreichungs-Tag
	 </entry>
	 
	 <entry>
	 Mit dem <codeph>&lt;u></codeph>-Tag markierter Text wird unterstrichen angezeigt.
	 </entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Flash Player und AIR unterstützen die folgenden HTML-Entitäten:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 Entität
	 </entry><entry>
	 Beschreibung
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 
	 &amp;amp;lt;	
	 
	 </entry>
	 
	 <entry>
	 
	 &lt; (kleiner als)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;gt;	
	 
	 </entry>
	 
	 <entry>
	 
	 > (größer als)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;amp;	
	 
	 </entry>
	 
	 <entry>
	 
	 &amp; (Und-Zeichen)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 &amp;amp;quot;	
	 
	 </entry>
	 
	 <entry>
	 
	 " (doppelte Anführungszeichen)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;apos;	
	 
	 </entry>
	 
	 <entry>
	 
	 ' (Apostroph, einfaches Anführungszeichen)
	 
	 </entry>
	 
	 </row></tbody></tgroup></adobetable>
	  
	  <p>Flash Player und AIR unterstützen auch explizite Zeichencodes wie z. B. &amp;#38; (Und-Zeichen, ASCII) und &amp;#x20AC; ( €-Symbol, Unicode). </p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> Im folgenden Beispiel wird ein TextField-Objekt mit der Bezeichnung <codeph>tf1</codeph> erstellt, und der Eigenschaft <codeph>text</codeph> wird ein String im HTML-Format zugewiesen. Wenn die Eigenschaft <codeph>htmlText</codeph> nachverfolgt wird, wird der String im HTML-Format mit zusätzlichen Tags (z. B. &lt;P> und &lt;FONT>) automatisch von Flash Player hinzugefügt. Wenn der Wert der Eigenschaft <codeph>text</codeph> nachverfolgt wird, wird der unformatierte String ohne HTML-Tags angezeigt.
 
 <p>Zum Vergleich werden die gleichen Schritte mit einem weiteren TextField-Objekt mit der Bezeichnung <codeph>tf2</codeph>. Zusätzlich wird der Eigenschaft <codeph>styleSheet</codeph> von <codeph>tf2</codeph> ein StyleSheet-Objekt zugewiesen, bevor die Eigenschaft <codeph>htmlText</codeph> festgelegt wird. In diesem Fall enthält die Eigenschaft <codeph>htmlText</codeph>, wenn sie nachverfolgt wird, nur den genauen HTML-Text, der ursprünglich der Eigenschaft <codeph>htmlText</codeph> zugewiesen war. Es wurden keine zusätzlichen Tags von Flash Player eingefügt.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/text"><linktext>flash.text.TextField.text</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link><link href="flash.events.xml#TextEvent"><linktext>flash.events.TextEvent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:length:get"><apiName>length</apiName><shortdesc>
	 Die Anzahl der Zeichen in einem Textfeld.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.length, length
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Die Anzahl der Zeichen in einem Textfeld.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die Anzahl der Zeichen in einem Textfeld. Ein Steuerzeichen wie Tab (<codeph>\t</codeph>) zählt als ein Zeichen.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxChars:get"><apiName>maxChars</apiName><shortdesc>
	 Die von einem Benutzer festgelegte maximale Anzahl von Zeichen, die das Textfeld enthalten kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxChars, maxChars
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
	 
	 </apiDefaultValue><apiTipTexts><apiTipText>Die maximale Anzahl der Zeichen, die das Textfeld enthalten kann.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die von einem Benutzer festgelegte maximale Anzahl von Zeichen, die das Textfeld enthalten kann. Mit einem Skript kann mehr Text eingefügt werden, als die Eigenschaft <codeph>maxChars</codeph> zulässt. <codeph>maxChars</codeph> gibt lediglich an, wie viel Text ein Benutzer eingeben kann. Wenn der Wert dieser Eigenschaft <codeph>0</codeph> ist, können die Benutzer unbegrenzt viel Text eingeben.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxScrollH:get"><apiName>maxScrollH</apiName><shortdesc>
	 Der maximale Wert der Eigenschaft „scrollH“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollH, maxScrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Der maximale Wert der Eigenschaft „scrollH“.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Der maximale Wert der Eigenschaft <codeph>scrollH</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:maxScrollV:get"><apiName>maxScrollV</apiName><shortdesc>
	 Der maximale Wert der Eigenschaft „scrollV“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollV, maxScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Der maximale Wert der Eigenschaft <codeph>scrollV</codeph>.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Der maximale Wert der Eigenschaft <codeph>scrollV</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:mouseWheelEnabled:get"><apiName>mouseWheelEnabled</apiName><shortdesc>
	 Ein Boolescher Wert, der angibt, ob Flash Player für mehrzeilige Textfelder automatisch einen Bildlauf durchführt, wenn der Benutzer ein Textfeld anklickt und das Mausrad dreht.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.mouseWheelEnabled, mouseWheelEnabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Gibt an, ob Flash Player automatisch einen Bildlauf in mehrzeiligen Textfeldern durchführt.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein Boolescher Wert, der angibt, ob Flash Player für mehrzeilige Textfelder automatisch einen Bildlauf durchführt, wenn der Benutzer ein Textfeld anklickt und das Mausrad dreht. Der Standardwert ist <codeph>true</codeph>. Diese Eigenschaft ist nützlich, wenn Sie verhindern möchten, dass in Textfeldern ein Bildlauf mit dem Mausrad durchgeführt wird oder wenn Sie Ihre eigene Bildlaufeigenschaften für Textfelder erstellen möchten.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:multiline:get"><apiName>multiline</apiName><shortdesc>
	 Gibt an, ob das Feld ein mehrzeiliges Textfeld ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.multiline, multiline
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Gibt an, ob es sich um ein mehrzeiliges Textfeld handelt.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Gibt an, ob das Feld ein mehrzeiliges Textfeld ist. Bei <codeph>true</codeph> ist das Textfeld mehrzeilig, bei <codeph>false</codeph> ist es einzeilig. In einem Feld des Typs <codeph>TextFieldType.INPUT</codeph> gibt der <codeph>multiline</codeph>-Wert an, ob die <codeph>Enter</codeph>-Taste eine neue Zeile erstellt (bei <codeph>false</codeph> wird die <codeph>Enter</codeph>-Taste ignoriert). Wenn Sie Text in ein <codeph>TextField</codeph> einfügen, dessen <codeph>multiline</codeph>-Wert auf <codeph>false</codeph> gesetzt ist, werden neue Zeilen aus dem Text entfernt.

	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/numLines"><linktext>numLines</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:numLines:get"><apiName>numLines</apiName><shortdesc>
	 Gibt die Anzahl der Textzeilen in einem mehrzeiligen Textfeld an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.numLines, numLines
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Gibt die Anzahl der Textzeilen in einem mehrzeiligen Textfeld an.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Gibt die Anzahl der Textzeilen in einem mehrzeiligen Textfeld an. Falls die Eigenschaft <codeph>wordWrap</codeph> auf <codeph>true</codeph> gesetzt ist, erhöht sich die Zeilenzahl beim Textumbruch.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/multiline"><linktext>multiline</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:restrict:get"><apiName>restrict</apiName><shortdesc>
	 Gibt die Zeichen an, die ein Benutzer in das Textfeld eingeben kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.restrict, restrict
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>null
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Die Menge der Zeichen, die ein Benutzer in ein Textfeld eingeben kann.
	 

	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Gibt die Zeichen an, die ein Benutzer in das Textfeld eingeben kann. Wenn die <codeph>restrict</codeph>-Eigenschaft auf <codeph>null</codeph> gesetzt ist, kann jedes beliebige Zeichen eingegeben werden. Wenn die <codeph>restrict</codeph>-Eigenschaft einen leeren String enthält, können keine Zeichen eingegeben werden. Weist die Eigenschaft <codeph>restrict</codeph> eine bestimmte Zeichenfolge als Wert auf, können nur diese Zeichen in das Textfeld eingegeben werden. Der String wird von links nach rechts gelesen. Sie können mithilfe eines Bindestrichs (-) einen Zeichenbereich angeben. Nur die Benutzerinteraktion ist beschränkt; ein Skript kann jeden Text in das Textfeld einfügen. <ph outputclass="flashonly">Diese Eigenschaft wird nicht an die Optionen unter „Schriftarten einbetten“ im Eigenschafteninspektor angeglichen.</ph>
	 
	 <p>Wenn der String mit dem Einfügezeichen (^) beginnt, werden anfänglich alle Zeichen akzeptiert, aber nachfolgende Zeichen im String werden nicht in die Liste der zulässigen Zeichen aufgenommen. Wenn der String nicht mit dem Einfügezeichen (^) beginnt, werden anfänglich keine Zeichen akzeptiert, aber nachfolgende Zeichen im String werden in die Liste der zulässigen Zeichen aufgenommen.</p>
	 
	 <p>Im folgenden Beispiel können nur Großbuchstaben, Leerzeichen und Zahlen in das Textfeld eingegeben werden:</p>
	 <pre>
	 my_txt.restrict = "A-Z 0-9";
	 </pre>
	 <p>Im folgenden Beispiel werden alle Zeichen bis auf Kleinbuchstaben akzeptiert:</p>
	 <pre>
	 my_txt.restrict = "^a-z";
	 </pre>
	 <p>Wenn Sie „^“ bzw. „-“ als normale Zeichen verwenden möchten, müssen Sie ihnen einen umgekehrten Schrägstrich (\) voranstellen. Zulässige Backslash-Folgen: \-, \^ oder \\. Der umgekehrte Schrägstrich muss ein echtes Zeichen im String sein; in ActionScript muss der umgekehrte Schrägstrich also doppelt eingegeben werden. Im folgenden Beispiel werden nur der Bindestrich (-) und das Einfügezeichen (^) zugelassen:</p>
	 <pre>
	 my_txt.restrict = "\\-\\^";
	 </pre>
	 <p>Das Einfügezeichen (^) kann an jeder beliebigen Stelle im String verwendet werden, um Zeichen ein- oder auszuschließen. Im folgenden Beispiel werden alle Großbuchstaben außer Q akzeptiert:</p>
	 <pre>
	 my_txt.restrict = "A-Z^Q";
	 </pre>
	 <p>Sie können die Escape-Sequenz <codeph>\u</codeph> verwenden, um <codeph>restrict</codeph>-Strings zu konstruieren. Im folgenden Beispiel werden nur die Zeichen zwischen ASCII 32 (Leerzeichen) und ASCII 126 (Tilde) akzeptiert:</p>
	 <pre>
     my_txt.restrict = "\u0020-\u007E";
	 </pre>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:scrollH:get"><apiName>scrollH</apiName><shortdesc>
	 Die aktuelle horizontale Bildlaufposition.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollH, scrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Die aktuelle horizontale Bildlaufposition.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die aktuelle horizontale Bildlaufposition. Ist die Eigenschaft <codeph>scrollH</codeph> auf 0 gesetzt, erfolgt kein horizontaler Bildlauf. Bei diesem Eigenschaftswert handelt es sich um eine Ganzzahl, die die horizontale Position in Pixeln angibt.
	 
	 
	 <p>Die Maßeinheit für den horizontalen Bildlauf sind Pixel, die Maßeinheit für den vertikalen Bildlauf Zeilen. Der horizontale Bildlauf wird in Pixeln gemessen, da die am häufigsten verwendeten Schriftarten normalerweise Proportionalschriftarten sind, die unterschiedlich breite Zeichen aufweisen. Flash Player nimmt den vertikalen Bildlauf nach Zeilen vor, da Benutzer normalerweise eine Textzeile vollständig und nicht nur teilweise sehen möchten. Hierbei kommt es nicht darauf an, ob eine Zeile mehrere Schriftarten enthält, da die Höhe der Zeile immer an die größte verwendete Schriftart angepasst wird.</p>
	 
	 <p><b>Hinweis: </b>Die Eigenschaft <codeph>scrollH</codeph> basiert auf 0, nicht auf 1 wie die Eigenschaft <codeph>scrollV</codeph> für den vertikalen Bildlauf.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/maxScrollH"><linktext>flash.text.TextField.maxScrollH</linktext></link><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:scrollV:get"><apiName>scrollV</apiName><shortdesc>
	 Die vertikale Textposition in einem Textfeld.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollV, scroll
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Die vertikale Textposition in einem Textfeld.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die vertikale Textposition in einem Textfeld. Die Eigenschaft <codeph>scrollV</codeph> ist besonders nützlich, wenn Benutzer auf einen bestimmten Abschnitt in einem längeren Text hingewiesen werden sollen, und bietet sich auch zum Erstellen von Textfeldern an, in denen ein Bildlauf durchgeführt werden kann.
	 
	 <p>Die Maßeinheit für den vertikalen Bildlauf sind Zeilen, die Maßeinheit für den horizontalen Bildlauf Pixel. Wenn die erste angezeigte Zeile auch die erste Zeile im Textfeld ist, hat „scrollV“ den Wert 1 (nicht 0). Der horizontale Bildlauf wird in Pixeln gemessen, da die meisten Schriftarten Proportionalschriftarten sind, die unterschiedlich breite Zeichen aufweisen. Flash Player nimmt den vertikalen Bildlauf nach Zeilen vor, da Benutzer normalerweise eine Textzeile vollständig und nicht nur teilweise sehen möchten. Selbst wenn eine Zeile mehrere Schriftarten enthält, wird die Höhe der Zeile an die größte verwendete Schriftart angepasst.</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link><link href="flash.text.xml#TextField/maxScrollV"><linktext>flash.text.TextField.maxScrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectable:get"><apiName>selectable</apiName><shortdesc>
	 Ein boolescher Wert, der angibt, ob das Textfeld ausgewählt werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.selectable, selectable
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
     
         </apiDefaultValue><apiTipTexts><apiTipText>Gibt an, ob das Textfeld ausgewählt werden kann.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein boolescher Wert, der angibt, ob das Textfeld ausgewählt werden kann. Bei <codeph>true</codeph> kann der Text ausgewählt werden. Die Eigenschaft <codeph>selectable</codeph> steuert, ob ein Textfeld ausgewählt werden kann, und nicht, ob es bearbeitet werden kann. Ein dynamisches Textfeld kann auswählbar sein, ohne dass es bearbeitet werden kann. Wenn ein dynamisches Textfeld nicht auswählbar ist, kann der enthaltene Text nicht ausgewählt werden.
	 
	 <p>Wenn <codeph>selectable</codeph> auf <codeph>false</codeph> gesetzt ist, kann der Text im Textfeld nicht über die Maus oder Tastatur mit den Auswahlbefehlen ausgewählt und daher nicht mit dem Befehl „Kopieren“ kopiert werden. Wenn <codeph>selectable</codeph> auf <codeph>true</codeph> gesetzt ist, kann der Text im Textfeld über die Maus oder Tastatur mit den Auswahlbefehlen ausgewählt und daher mit dem Befehl „Kopieren“ kopiert werden. In diesem Feld können Sie Text auch dann auswählen, wenn es sich um ein dynamisches Textfeld und nicht um ein Eingabetextfeld handelt. </p>
	 
     </apiDesc><example conref="examples\TextField_selectable.as"> Das folgende Beispiel erstellt zwei dynamische Textfelder: ein Textfeld, in dem die <codeph>selectable</codeph>-Eigenschaft auf <codeph>true</codeph> gesetzt ist, und ein anderes Textfeld, in dem die <codeph>selectable</codeph>-Eigenschaft auf <codeph>false</codeph> gesetzt ist. Wenn Sie dieses Beispiel verwenden, versuchen Sie, den Text in diesen Feldern mit der Maus oder der Tastatur auszuwählen.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class selectableExample extends Sprite
    {
        public function selectableExample()
        {
    var tf1:TextField = createCustomTextField(10, 10);
    tf1.text="This text can be selected";
    tf1.selectable=true;

    var tf2:TextField = createCustomTextField(10, 30);
    tf2.text="This text cannot be selected";
    tf2.selectable=false;
        }

        private function createCustomTextField(x:Number, y:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.autoSize=TextFieldAutoSize.LEFT;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionBeginIndex:get"><apiName>selectionBeginIndex</apiName><shortdesc>
	 Der auf null basierende Zeichenindexwert des ersten Zeichens in der aktuellen Auswahl.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Der auf null basierende Indexwert des ersten Zeichens in der Auswahl. 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Der auf null basierende Indexwert des ersten Zeichens in der aktuellen Auswahl. Das erste Zeichen ist beispielsweise 0, das zweite Zeichen 1 usw. Wenn kein Text ausgewählt ist, hat diese Eigenschaft den Wert <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> In diesem Beispiel wird eine TextField-Instanz erstellt und mit Text gefüllt. Es wird ein Ereignis-Listener zugewiesen, damit die <codeph>printCursorPosition</codeph>-Methode aufgerufen wird, sobald der Benutzer auf die TextField-Instanz klickt. In diesem Fall werden die Werte der Eigenschaften <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> ausgegeben.
 
 <p>Führen Sie dieses Beispiel aus, und versuchen Sie, durch Klicken in die TextField-Instanz Text auszuwählen. Klicken Sie anschließend in das Feld, ohne Text auszuwählen. Wenn Sie in den Text klicken, ohne eine Auswahl vorzunehmen, gibt die Eigenschaft <codeph>caretIndex</codeph> an, wo sich die Einfügemarke befindet, und die Eigenschaften <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> sind identisch mit dem Wert der Eigenschaft <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionEndIndex:get"><apiName>selectionEndIndex</apiName><shortdesc>
	 Der auf null basierende Indexwert des letzten Zeichens in der aktuellen Auswahl.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Der auf null basierende Indexwert des letzten Zeichens in der Auswahl.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Der auf null basierende Indexwert des letzten Zeichens in der aktuellen Auswahl. Das erste Zeichen ist beispielsweise 0, das zweite Zeichen 1 usw. Wenn kein Text ausgewählt ist, hat diese Eigenschaft den Wert <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> In diesem Beispiel wird eine TextField-Instanz erstellt und mit Text gefüllt. Es wird ein Ereignis-Listener zugewiesen, damit die <codeph>printCursorPosition</codeph>-Methode aufgerufen wird, sobald der Benutzer auf die TextField-Instanz klickt. In diesem Fall werden die Werte der Eigenschaften <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> ausgegeben.
 
 <p>Führen Sie dieses Beispiel aus, und versuchen Sie, durch Klicken in die TextField-Instanz Text auszuwählen. Klicken Sie anschließend in das Feld, ohne Text auszuwählen. Wenn Sie in den Text klicken, ohne eine Auswahl vorzunehmen, gibt die Eigenschaft <codeph>caretIndex</codeph> an, wo sich die Einfügemarke befindet, und die Eigenschaften <codeph>selectionBeginIndex</codeph> und <codeph>selectionEndIndex</codeph> sind identisch mit dem Wert der Eigenschaft <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:sharpness:get"><apiName>sharpness</apiName><shortdesc>
	 Die Schärfe der Glyphenkanten in diesem Textfeld.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates three text fields with
	 <code>sharpness</code> set to <code>400</code>, <code>0</code>, and <code>-400</code>.
	 It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 400, 100);
	 my_text1.text = "This text has sharpness set to 400."
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "pixel";
	 my_text1.sharpness = 400;
	 my_text1.setTextFormat(my_format);
         
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 40, 400, 100);
	 my_text2.text = "This text has sharpness set to 0."
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.sharpness = 0;
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 10, 70, 400, 100);
	 my_text3.text = "This text has sharpness set to -400."
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "pixel";
	 my_text3.sharpness = -400;
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
         </apiDefaultValue><apiTipTexts><apiTipText>Die Schärfe der Glyphenkanten.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die Schärfe der Glyphenkanten in diesem Textfeld. Diese Eigenschaft gilt nur dann, wenn die Eigenschaft <codeph>flash.text.AntiAliasType</codeph> des Textfelds auf <codeph>flash.text.AntiAliasType.ADVANCED</codeph> gesetzt ist. Der Wert für <codeph>sharpness</codeph> kann aus dem Bereich von -400 bis 400 gewählt werden. Wenn Sie versuchen, <codeph>sharpness</codeph> auf einen Wert außerhalb dieses Bereichs zu setzen, setzt Flash die Eigenschaft auf den nächstgelegenen Wert im Bereich (-400 oder 400).
	 
	 </apiDesc><example conref="examples\TextField_sharpness.as"> Das folgende Beispiel zeigt, was passiert, wenn die <codeph>sharpness</codeph>-Eigenschaft für ein TextField-Objekt geändert wird. Sie müssen die Schriftart einbetten und die <codeph>antiAliasType</codeph>-Eigenschaft auf <codeph>ADVANCED</codeph> setzen.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class sharpnessExample extends Sprite
    {
        public function sharpnessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-400);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,400);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldSharpness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.sharpness=fldSharpness;
            result..setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:styleSheet:get"><apiName>styleSheet</apiName><shortdesc>
	 Fügt ein Stylesheet an das Textfeld an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet, style sheet, stylesheet
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:StyleSheet</apiValueClassifier><apiTipTexts><apiTipText>Fügt ein Stylesheet an das Textfeld an.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Fügt ein Stylesheet an das Textfeld an. Informationen zum Erstellen von Stylesheets finden Sie im Eintrag zur StyleSheet-Klasse und im Handbuch <i>Programmieren mit ActionScript 3.0</i>.
	 
	 <p>Sie können das mit einem Textfeld verknüpfte Stylesheet jederzeit ändern. Bei Änderung des verwendeten Stylesheets wird das Textfeld mit dem neuen Stylesheet neu gezeichnet. Wenn Sie das Stylesheet entfernen möchten, setzen Sie es auf <codeph>null</codeph> oder <codeph>undefined</codeph>. Wenn Sie das verwendete Stylesheet entfernen, wird das Textfeld ohne Stylesheet neu gezeichnet. </p>
     <p><b>Hinweis:</b> Wenn das Stylesheet entfernt wird, wird der Inhalt von <codeph>TextField.text</codeph> und <codeph>TextField.htmlText</codeph> in der vorher vom Stylesheet angewendeten Formatierung angezeigt. Um den ursprünglichen Inhalt von <codeph>TextField.htmlText</codeph> ohne Formatierung zu bewahren, speichern Sie den Wert in einer Variablen, bevor Sie das Stylesheet entfernen.</p>
	 
     </apiDesc><example conref="examples\TextField_styleSheet.as"> Im folgenden Beispiel wird ein einfaches StyleSheet-Objekt definiert und mit einem Textfeld mit HTML-Inhalt verknüpft. Legen Sie die <codeph>stylesheet</codeph>-Eigenschaft fest, bevor Sie den Inhalt festlegen.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.StyleSheet;

    public class TextStylesheetExample extends Sprite {
        var myLabel:TextField = new TextField();
        var labelText:String = "Hello world.";
        var newStyle:StyleSheet = new StyleSheet();

        public function TextStylesheetExample()
       {
            var styleObj:Object = new Object();
            styleObj.fontWeight = "bold";
            styleObj.color = "#660066";
            newStyle.setStyle(".defStyle", styleObj);

            myLabel.styleSheet=newStyle;
            myLabel.htmlText=labelText;
            addChild(myLabel);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:text:get"><apiName>text</apiName><shortdesc>
	 Ein String, bei dem es sich um den aktuellen Text im Textfeld handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.text, text
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Ein String, bei dem es sich um den aktuellen Text im Textfeld handelt.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein String, bei dem es sich um den aktuellen Text im Textfeld handelt. Zeilen sind durch das Wagenrücklaufzeichen (<codeph>'\r'</codeph> , ASCII 13) getrennt. Diese Eigenschaft enthält unformatierten Text im Textfeld (ohne HTML-Tags).
	 
	 <p>Verwenden Sie die Eigenschaft <codeph>htmlText</codeph>, um den Text in das HTML-Format zu konvertieren.</p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> Im folgenden Beispiel wird ein TextField-Objekt mit der Bezeichnung <codeph>tf1</codeph> erstellt, und der Eigenschaft <codeph>text</codeph> wird ein String im HTML-Format zugewiesen. Wenn die Eigenschaft <codeph>htmlText</codeph> nachverfolgt wird, wird der String im HTML-Format mit zusätzlichen Tags (z. B. &lt;P> und &lt;FONT>) automatisch von Flash Player hinzugefügt. Wenn der Wert der Eigenschaft <codeph>text</codeph> nachverfolgt wird, wird der unformatierte String ohne HTML-Tags angezeigt.
 
 <p>Zum Vergleich werden die gleichen Schritte mit einem weiteren TextField-Objekt mit der Bezeichnung <codeph>tf2</codeph>. Zusätzlich wird der Eigenschaft <codeph>styleSheet</codeph> von <codeph>tf2</codeph> ein StyleSheet-Objekt zugewiesen, bevor die Eigenschaft <codeph>htmlText</codeph> festgelegt wird. In diesem Fall enthält die Eigenschaft <codeph>htmlText</codeph>, wenn sie nachverfolgt wird, nur den genauen HTML-Text, der ursprünglich der Eigenschaft <codeph>htmlText</codeph> zugewiesen war. Es wurden keine zusätzlichen Tags von Flash Player eingefügt.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textColor:get"><apiName>textColor</apiName><shortdesc>
	 Die Farbe des Textes in einem Textfeld (im Hexadezimalformat).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textColor, textColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiDefaultValue>0 (0x000000)
	 </apiDefaultValue><apiTipTexts><apiTipText>Die Farbe des Textes in einem Textfeld (im Hexadezimalformat).
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die Farbe des Textes in einem Textfeld (im Hexadezimalformat). Das Hexadezimalfarbsystem stellt Farbwerte anhand von sechs Ziffern dar. Jede Ziffer hat 16 mögliche Werte oder Zeichen. Die Zeichen reichen von 0-9 und dann A-F. Schwarz ist beispielsweise <codeph>0x000000</codeph>; weiß ist <codeph>0xFFFFFF</codeph>.
	 
     </apiDesc><example conref="examples\TextField_textColor.as"> Mit dem folgenden ActionScript wird ein TextField-Objekt erstellt und die Eigenschaft <codeph>textColor</codeph> in Rot (<codeph>0xFF0000</codeph>) geändert.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textColor extends Sprite {
        public function TextField_textColor() {
            var tf:TextField = createCustomTextField(10, 10, 100, 300);
            tf.text = "This will be red text";
            tf.textColor = 0xFF0000;            
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:textHeight:get"><apiName>textHeight</apiName><shortdesc>
	 Die Höhe des Texts in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textHeight, textHeight
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Höhe des Texts in Pixel.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die Höhe des Texts in Pixel.
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> Im folgenden Beispiel wird ein TextField-Objekt erstellt. Anschließend wird dem Objekt Text zugewiesen. Mit den <codeph>trace</codeph>-Anweisungen werden die Werte der Eigenschaften <codeph>textWidth</codeph> und <codeph>textHeight</codeph> aufgerufen. Zum Vergleich werden auch die Eigenschaften <codeph>width</codeph> und <codeph>height</codeph> angezeigt. (Beachten Sie, dass die Werte für <codeph>textHeight</codeph> und <codeph>textWidth</codeph> von der auf Ihrem Computer verwendeten Schriftart abhängen).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textWidth"><linktext>flash.text.TextField.textWidth</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textWidth:get"><apiName>textWidth</apiName><shortdesc>
	 Die Breite des Texts in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textWidth, textWidth
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Die Breite des Texts in Pixel.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die Breite des Texts in Pixel.
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> Im folgenden Beispiel wird ein TextField-Objekt erstellt. Anschließend wird dem Objekt Text zugewiesen. Mit den <codeph>trace</codeph>-Anweisungen werden die Werte der Eigenschaften <codeph>textWidth</codeph> und <codeph>textHeight</codeph> aufgerufen. Zum Vergleich werden auch die Eigenschaften <codeph>width</codeph> und <codeph>height</codeph> angezeigt. (Beachten Sie, dass die Werte für <codeph>textHeight</codeph> und <codeph>textWidth</codeph> von der auf Ihrem Computer verwendeten Schriftart abhängen).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textHeight"><linktext>flash.text.TextField.textHeight</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:thickness:get"><apiName>thickness</apiName><shortdesc>
	 Die Stärke der Glyphenkanten in diesem Textfeld.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates two text fields and applies a <code>thickness</code> of -200 to one
	 and 200 to the other.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "thickness = 200";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.thickness = 200;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "thickness = -200."
	 my_text2.antiAliasType = "advanced";
	 my_text2.thickness = -200;
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
     
         </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Die Stärke der Glyphenkanten.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Die Stärke der Glyphenkanten in diesem Textfeld. Diese Eigenschaft gilt nur dann, wenn <codeph>flash.text.AntiAliasType</codeph> auf <codeph>flash.text.AntiAliasType.ADVANCED</codeph> gesetzt ist.
	 
	 <p>Der Wert für <codeph>thickness</codeph> kann aus dem Bereich von -200 bis 200 gewählt werden. Wenn Sie versuchen, <codeph>thickness</codeph> auf einen Wert außerhalb dieses Bereichs zu setzen, wird die Eigenschaft auf den nächstgelegenen Wert im Bereich gesetzt (-200 oder 200).</p>
	 
     </apiDesc><example conref="examples\TextField_thickness.as"> Das folgende Beispiel zeigt, was passiert, wenn die <codeph>thickness</codeph>-Eigenschaft für ein TextField-Objekt geändert wird. Sie müssen die Schriftart einbetten und die <codeph>antiAliasType</codeph>-Eigenschaft auf <codeph>ADVANCED</codeph> setzen.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class thicknessExample extends Sprite
    {
        public function thicknessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-200);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,200);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldThickness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.thickness=fldThickness;
            result.setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:type:get"><apiName>type</apiName><shortdesc>
	 Der Typ des Textfelds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.type, type
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der angegebene <codeph>type</codeph>-Wert gehört nicht zu „flash.text.TextFieldType“.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>dynamic
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Der Typ des Textfelds.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Der Typ des Textfelds. Eine der folgenden TextFieldType-Konstanten: <codeph>TextFieldType.DYNAMIC</codeph> zur Angabe eines dynamischen Textfelds, das nicht von den Benutzern bearbeitet werden kann, oder <codeph>TextFieldType.INPUT</codeph> zur Angabe eines Eingabefelds, das von den Benutzern bearbeitet werden kann.
	 
     </apiDesc><example conref="examples\TextField_type.as"> Im folgenden Beispiel werden zwei Textfelder erstellt: <codeph>tfDynamic</codeph> und <codeph>tfInput</codeph>. In beide Felder wird Text eingegeben. Für <codeph>tfDynamic</codeph> wird die <codeph>type</codeph>-Eigenschaft jedoch auf <codeph>TextFieldType.DYNAMIC</codeph> gesetzt wohingegen die <codeph>type</codeph>-Eigenschaft von <codeph>tfInput</codeph> auf <codeph>TextFieldType.INPUT</codeph> gesetzt wird. Daher kann der Benutzer den Text bei <codeph>tfInput</codeph> bearbeiten, während er bei <codeph>tfDynamic</codeph> keine Änderungen am Text vornehmen kann.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_type extends Sprite {
        public function TextField_type() {
            var tfDynamic:TextField = createCustomTextField(10, 10, 100, 20);
            tfDynamic.type = TextFieldType.DYNAMIC;
            tfDynamic.text = "hello";

            var tfInput:TextField = createCustomTextField(10, 45, 100, 20);
            tfInput.type = TextFieldType.INPUT;
            tfInput.text = "world";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextFieldType"><linktext>flash.text.TextFieldType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:useRichTextClipboard:set"><apiName>useRichTextClipboard</apiName><shortdesc>
	 Gibt an, ob beim Kopieren und Einfügen auch die Textformatierung übernommen wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob beim Kopieren und Einfügen auch die Textformatierung übernommen wird. Wenn dieses Objekt auf <codeph>true</codeph> gesetzt ist, kopiert Flash Player Formatierungen (wie z. B. Ausrichtung, fett und kursiv) und fügt diese ein, wenn Sie zwischen Textfeldern kopieren und einfügen. Sowohl im Ausgangs- als auch im Zieltextfeld des Kopier- und Einfügevorgangs muss <codeph>useRichTextClipboard</codeph> auf <codeph>true</codeph> gesetzt sein. Der Standardwert ist <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_useRichTextClipboard.as"> Dieses Beispiel erstellt ein Eingabetextfeld (<codeph>tf1</codeph>) und zwei dynamische Textfelder (<codeph>tf2</codeph> und <codeph>tf3</codeph>). Der Code verknüpft jedes dynamische Feld mit einem TextFormat-Objekt (Courier Bold-Schrift). Für das Textfeld <codeph>tf2</codeph> ist die Eigenschaft <codeph>useRichTextClipboard</codeph> auf <codeph>false</codeph> gesetzt. Für das Textfeld <codeph>tf3</codeph> ist die Eigenschaft <codeph>useRichTextClipboard</codeph> auf <codeph>true</codeph> gesetzt. Wenn Sie den Text im Textfeld <codeph>tf2</codeph> kopieren und ihn in das Textfeld <codeph>tf1</codeph> einfügen, enthält der eingefügte Text keine Formatierung. Wenn Sie den Text im Textfeld <codeph>tf3</codeph> (für das <codeph>useRichTextClipboard</codeph> auf <codeph>true</codeph> gesetzt ist) kopieren und ihn in das Textfeld <codeph>tf1</codeph> einfügen, enthält der eingefügte Text die Formatierung.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;

    public class useRichTextClipboard extends Sprite
    {
        public function useRichTextClipboard()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Courier";
    format1.bold=true;

    var tf1:TextField = createCustomTextField(10, 10, 200, 20);
    tf1.type=TextFieldType.INPUT;
    tf1.useRichTextClipboard=true;

    var tf2:TextField = createCustomTextField(220, 10, 200, 20);
    tf2.text="1.Text loses format";
    tf2.setTextFormat(format1);
    tf2.useRichTextClipboard=false;

    var tf3:TextField = createCustomTextField(220, 50, 200, 20);
    tf3.text="2.Text includes format";
    tf3.setTextFormat(format1);
    tf3.useRichTextClipboard=true;
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:wordWrap:get"><apiName>wordWrap</apiName><shortdesc>
	 Ein boolescher Wert, der angibt, ob im Textfeld ein Zeilenumbruch durchgeführt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.wordWrap, wordWrap
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Gibt an, ob der Text im Textfeld umbrochen wird.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein boolescher Wert, der angibt, ob im Textfeld ein Zeilenumbruch durchgeführt wird. Wenn die Eigenschaft <codeph>wordWrap</codeph> auf <codeph>true</codeph> gesetzt ist, findet im Textfeld ein Zeilenumbruch statt. Wenn der Wert <codeph>false</codeph> ist, findet im Textfeld kein Zeilenumbruch statt. Der Standardwert ist <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_wordWrap.as"> Aus dem folgenden Beispiel geht der Unterschied zwischen der Einstellung <codeph>true</codeph> und <codeph>false</codeph> für <codeph>wordWrap</codeph> hervor: Es werden zwei TextField-Instanzen erstellt, deren Inhalt zu groß für die Breite der Textfelder ist. Die Eigenschaft <codeph>wordWrap</codeph> der ersten Instanz (<codeph>tfWrap</codeph>) wird auf <codeph>true</codeph> gesetzt, die der zweiten Instanz (<codeph>tfNoWrap</codeph>) auf <codeph>false</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_wordWrap extends Sprite {
        public function TextField_wordWrap() {
            var tfWrap:TextField = createCustomTextField(10, 10, 100, 100);
            tfWrap.wordWrap = true;
            tfWrap.text = "(wordWrap = true):\nThis is very long text that will certainly extend beyond the width of this text field";

            var tfNoWrap:TextField = createCustomTextField(10, 150, 100, 100);
            tfNoWrap.wordWrap = false;
            tfNoWrap.text = "(wordWrap = false):\nThis is very long text that will certainly extend beyond the width of this text field";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 Die TextFormat-Klasse enthält Zeichenformatierungsinformationen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Insure the above example is correct and meets example standards
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Erstellt Textformatierungen in Textfeldern.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die TextFormat-Klasse enthält Zeichenformatierungsinformationen. Verwenden Sie diese Klasse zum Erstellen spezieller Textformatierungen für Textfelder. Textformatierungen können sowohl auf statische als auch auf dynamische Textfelder angewendet werden. Die Eigenschaften der TextFormat-Klasse gelten für Geräte- und eingebettete Schriftarten. Bei eingebetteten Schriftarten sind jedoch für Fett- und Kursivformatierungen spezielle Schriftarten erforderlich. Wenn Sie bei Verwendung einer eingebetteten Schriftart fett bzw. kursiv formatierten Text einsetzen möchten, müssen Sie die Fett- und Kursivvarianten dieser Schriftart einbetten.
 
 <p> Bevor Sie die Eigenschaften eines TextFormat-Objekts einstellen können, müssen Sie das Objekt mithilfe des Konstruktors <codeph>new TextFormat()</codeph> erstellen. Wenn Sie ein TextFormat-Objekt über die <codeph>TextField.defaultTextFormat</codeph>-Eigenschaft oder die <codeph>TextField.setTextFormat()</codeph>-Methode auf ein Textfeld anwenden, werden nur die definierten Eigenschaften angewendet. Verwenden Sie die <codeph>TextField.defaultTextFormat</codeph>-Eigenschaft, um Formatierung anzuwenden, BEVOR Sie dem <codeph>TextField</codeph> Text hinzufügen, und die <codeph>setTextFormat()</codeph>-Methode, um Formatierung hinzuzufügen, NACHDEM Sie dem <codeph>TextField</codeph> Text hinzufügen. Die TextFormat-Eigenschaften lauten standardmäßig <codeph>null</codeph>, da die Flash Player-eigene Standardformatierung verwendet wird, wenn Sie keine Werte für die Eigenschaften angeben. Die von Flash Player verwendete Standardformatierung sieht wie folgt aus (falls der Wert der Eigenschaft <codeph>null</codeph> beträgt):</p>
 
 <adobetable class="innertable">
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="1"><tbody><row><entry>align = "left"</entry></row><row><entry>blockIndent = 0</entry></row><row><entry>bold = false</entry></row><row><entry>bullet = false</entry></row><row><entry>color = 0x000000</entry></row><row><entry>font = "Times New Roman" („Times“ bei Mac OS X)</entry></row><row><entry>indent = 0</entry></row><row><entry>italic = false</entry></row><row><entry>kerning = false</entry></row><row><entry>leading = 0</entry></row><row><entry>leftMargin = 0</entry></row><row><entry>letterSpacing = 0</entry></row><row><entry>rightMargin = 0</entry></row><row><entry>size = 12</entry></row><row><entry>tabStops = [] (leeres Array)</entry></row><row><entry>target = "" (leerer String)</entry></row><row><entry>underline = false</entry></row><row><entry>url = "" (leerer String)</entry></row></tbody></tgroup></adobetable>
 
 <p>Die Standardformatierung für die einzelnen Eigenschaften befindet sich auch in den einzelnen Eigenschaftsbeschreibungen.</p>
 
 </apiDesc><example conref="examples\TextFormatExample.as"> Im folgenden Beispiel wird die TextFieldExample-Klasse verwendet, um eine Textmeldung an der Standardposition (x = 0, y = 0) anzuzeigen. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Es wird eine <codeph>label</codeph>-Eigenschaft vom Typ „TextField“ erstellt.</li>
  <li>Der Klassenkonstruktor ruft die Funktion <codeph>configureLabel()</codeph> auf.</li>
  <li>Mit der Funktion <codeph>configureLabel()</codeph> wird zuerst ein neues TextField-Objekt erstellt, das anschließend der Eigenschaft <codeph>label</codeph> zugewiesen wird. Danach werden die Parameter wie folgt eingestellt:
  <ul>
      <li>Textfeld links ausrichten</li>
      <li>Hintergrundfüllung aktivieren</li>
      <li>Rahmen aktivieren.</li>
  </ul>
  </li>
  <li>Anschließend erstellt <codeph>configureLable()</codeph> die lokale Variable, <codeph>formatiert</codeph> und weist sie einer neuer TextFormat-Instanz mit Parametern zu, die wie folgt definiert sind:
  <ul>
      <li>Schriftart = Verdana</li>
      <li>Schriftfarbe = reines Rot</li>
      <li>Schriftgröße = 10</li>
      <li>Unterstreichung = true.</li>
  </ul>
  </li>
  <li>Die Eigenschaft <codeph>defaultTextFormat</codeph> von „label“ ist auf <codeph>format</codeph> gesetzt, und die <codeph>label</codeph>-Instanz wird der Anzeigeliste hinzugefügt. In dieser wird zuerst ein Textfeld ohne Text (als kleines Feld mit weißem Hintergrund) angezeigt.</li>
  <li>Zum Schluss (im Konstruktor) wird durch den Aufruf von <codeph>setLabel()</codeph> der label-Text auf „Hello World and welcome to the show“ gesetzt, und als Koordinaten werden x = 0 und y = 0 festgelegt.</li>
 </ol>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFormatExample extends Sprite {
        private var label:TextField;

        public function TextFormatExample() {
            configureLabel();
            setLabel("Hello World and welcome to the show");
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link></related-links><apiConstructor id="flash.text:TextFormat:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 	 Erstellt ein TextFormat-Objekt mit den angegebenen Eigenschaften.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat
 	 
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Der Name der Schriftart für Text als String.
 	 </apiDesc></apiParam><apiParam><apiItemName>size</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine ganze Zahl, die die Größe in Pixeln angibt.
 	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Die Farbe des Textes mit diesem Textformat. Eine Zahl mit drei 8-Bit-RGB-Komponenten. 0xFF0000 ist beispielsweise Rot und 0x00FF00 Grün.
 	 </apiDesc></apiParam><apiParam><apiItemName>bold</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein boolescher Wert, der angibt, ob der Text fett formatiert wird.
 	 </apiDesc></apiParam><apiParam><apiItemName>italic</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein boolescher Wert, der angibt, ob der Text kursiv formatiert wird.
 	 </apiDesc></apiParam><apiParam><apiItemName>underline</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Ein boolescher Wert, der angibt, ob der Text unterstrichen formatiert wird.
 	 </apiDesc></apiParam><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Die URL, auf die der Text in diesem Textformat mit einem Hyperlink verweist. Wenn für <codeph>url</codeph> ein leerer String angegeben wird, weist der Text keinen Hyperlink auf.
 	 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Das Zielfenster im Browser, in dem der Hyperlink angezeigt werden soll. Wenn als Zielfenster ein leerer String angegeben wird, erscheint der Text im Standardzielfenster (<codeph>_self</codeph>). Wenn der Parameter <codeph>url</codeph> auf einen leeren String oder den Wert <codeph>null</codeph> gesetzt ist, kann diese Eigenschaft zwar abgerufen und eingestellt werden, hat aber keine Auswirkung.
 	 </apiDesc></apiParam><apiParam><apiItemName>align</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Die Absatzausrichtung dargestellt als TextFormatAlign-Wert.
 	 </apiDesc></apiParam><apiParam><apiItemName>leftMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Gibt den linken Rand des Absatzes in Pixeln an.
 	 </apiDesc></apiParam><apiParam><apiItemName>rightMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Gibt den rechten Rand des Absatzes in Pixeln an.
 	 </apiDesc></apiParam><apiParam><apiItemName>indent</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine Ganzzahl, die den Einzug vom linken Rand bis zum ersten Zeichen im Absatz angibt.
 	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Eine Zahl, die den Zeilenabstand angibt.
 	 
   	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Erstellt ein TextFormat-Objekt mit den angegebenen Eigenschaften. Später können Sie die Eigenschaften des TextFormat-Objekts ändern, um die Formatierung von Textfeldern zu modifizieren.
	 
 	 <p>Jeder Parameter kann auf den Wert <codeph>null</codeph> gesetzt werden, wenn er nicht definiert werden soll. Alle Parameter sind optional. Ein weggelassener Parameter wird wie ein Parameter mit dem Wert <codeph>null</codeph> behandelt.</p>
  	 
 	 </apiDesc><example conref="examples\TextFormat_constructorExample.as"> Im folgenden Beispiel kann ein Benutzer verschiedene Textformatierungsoptionen aus einer Liste auswählen, die auf den Inhalt eines anderen Textfelds angewendet werden. Wenn der Benutzer auf den Inhalt des Textfelds klickt, wird wieder das Standardformat (das ursprüngliche Format) verwendet.
 
 <p>Im Textfeld <codeph>formatTextField</codeph> sind alle Eigenschaftenoptionen der TextField-Klasse (mit Ausnahme von <codeph>kerning</codeph>) jeweils in einer separaten Zeile aufgeführt. Wenn ein Benutzer auf eine Zeile im Textfeld <codeph>formatTextField</codeph> klickt, wird die <codeph>formatTextFieldClickHandler()</codeph>-Methode ausgelöst.</p> 
 
 <p>Die <codeph>formatTextFieldClickHandler()</codeph>-Methode ruft die <codeph>TextField.getLineIndexAtPoint()</codeph>-Methode auf, um den Index der Zeile, auf die geklickt wurde, abzurufen, und ruft dann die <codeph>TextField.getLineText()</codeph>-Methode auf, um den Inhalt der Zeile abzurufen. Die switch-Anweisung überprüft den Inhalt der Zeile und legt eine Eigenschaft des TextFormat-Objekts <codeph>newformat</codeph> entsprechend fest. Die <codeph>setTextFormat()</codeph>-Methode legt dann das Textformat des Textfelds <codeph>contentTextField</codeph> auf das neue Format fest. Durch das Klicken auf verschiedene <codeph>formatTextField</codeph>-Zeilen kann ein Benutzer verschiedene Formatierungen auf das Textfeld <codeph>contentTextField</codeph> anwenden. (Bei der tab-Einstellung handelt es sich um ein Array, das separate Tab-Stopps für jeden Tabulator in der Zeile definiert.) Wenn die Zeile <codeph>url</codeph> oder <codeph>target</codeph> ausgewählt wird, muss der Benutzer auf das Textfeld <codeph>contentTextField</codeph> klicken, um den Link zu aktivieren und den Inhalt der Ziel-URL (Flex-Homepage) anzuzeigen). Der Standardwert der <codeph>target</codeph>-Eigenschaft ist „_self“, was bedeutet, dass der Inhalt im aktuellen Fenster angezeigt wird, wenn der Benutzer die Zeile <codeph>url</codeph> auswählt. Damit die <codeph>target</codeph>-Eigenschaft funktioniert, muss eine URL bereits in der <codeph>url</codeph>-Eigenschaft festgelegt werden.</p>
 
 <p>Wenn ein Benutzer auf das Textfeld <codeph>contentTextField</codeph> klickt, wird die <codeph>contentTextFieldClickHandler()</codeph>-Methode ausgelöst, die sowohl das Format des Feldes als auch das <codeph>newFormat</codeph> des TextFormat-Objekts auf das Standardtextformat (das ursprüngliche Format) des Textfeldes festlegt. Damit werden alle vom Benutzer vorgenommenen Formatänderungen gelöscht.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormatAlign;
    
    public class TextFormat_constructorExample extends Sprite {
        private var contentTextField:TextField = new TextField();
        private var formatTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextFormat_constructorExample() {
            contentTextField.x = 10;
            contentTextField.y = 10;
            contentTextField.background = true;
            contentTextField.border = true;
            contentTextField.multiline = true;
            contentTextField.wordWrap = true;
            contentTextField.selectable = false;
            contentTextField.width = 250;
            contentTextField.height = 120; 
  
            contentTextField.htmlText = "&lt;p>The TextFormat class represents character formatting "
                + "information. Use the TextFormat class to create specific text formatting "
                + "for text fields." + 
                " &lt;/p>&lt;br>" + "\tTab One" + "\tTab Two&lt;br>";
              
            formatTextField.x = 10;
            formatTextField.y = 140;
            formatTextField.background = true;
            formatTextField.border = true;
            formatTextField.autoSize = TextFieldAutoSize.LEFT;
            
            formatTextField.text = "align: right\n" + "blockIndent: 10 pixels\n" + "bold:\n" + "bullet:\n" + "color: red\n"
                                + "font: Arial\n" + "indent: 20 pixels\n" + "italic:\n" + "leading: 5 spaces\n" 
                                + "leftMargin: 20 pixels\n" + "letterSpacing: 4 pixels\n" + "rightMargin: 20 pixels\n" 
                                + "size: 16 point\n" + "target: new window\n" + "tabStops: 50 and 150 pixel\n" 
                                + "underline:\n" + "url: Adobe Flex page\n";

            formatTextField.addEventListener(MouseEvent.CLICK, formatTextFieldClickHandler);
            
            contentTextField.addEventListener(MouseEvent.CLICK, contentTextFieldClickHandler);
            
            this.addChild(contentTextField);
            this.addChild(formatTextField);
        }

        private function formatTextFieldClickHandler(e:MouseEvent):void {
                var value:String= "";
                var i:uint = 0;
                var index:int = formatTextField.getLineIndexAtPoint(e.localX, e.localY);
                var line:String = formatTextField.getLineText(index);;

                line = line.substr(0, (line.indexOf(":")));

                switch(line) {
                    case "align":
                        newFormat.align = TextFormatAlign.RIGHT;
                        break;
                    case "blockIndent":
                        newFormat.blockIndent = 10;
                        break;
                    case "bold":
                        newFormat.bold = true;
                        break;
                    case "bullet":
                        newFormat.bullet = true;
                        break;
                    case "color":
                        newFormat.color = 0xFF0000;        
                        break;
                    case "font":
                        newFormat.font = "Arial";
                        break;
                    case "indent":
                        newFormat.indent = 20;
                        break;
                    case "italic":
                        newFormat.italic = true;
                        break;
                    case "leading":
                        newFormat.leading = 5;
                        break;
                    case "leftMargin":
                        newFormat.leftMargin = 20;
                        break;
                    case "letterSpacing":
                        newFormat.letterSpacing = 4;
                        break;
                    case "rightMargin":
                        newFormat.rightMargin = 20;
                        break;
                    case "size":
                        newFormat.size = 16;
                        break;
                    case "tabStops":                
                        newFormat.tabStops = [50, 150];
                        break;
                    case "target":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        newFormat.target = "_blank";
                        break;    
                    case "underline":
                        newFormat.underline = true;
                        break;
                    case "url":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        break;
                }    

                contentTextField.setTextFormat(newFormat);
        }

        private function contentTextFieldClickHandler(e:MouseEvent):void {
            contentTextField.setTextFormat(contentTextField.defaultTextFormat);
            newFormat = contentTextField.defaultTextFormat;
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextFormat:align:get"><apiName>align</apiName><shortdesc>
	 Gibt die Ausrichtung des Absatzes an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.align, align
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Der angegebene <codeph>align</codeph>-Wert gehört nicht zu „flash.text.TextFormatAlign“.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>TextFormatAlign.LEFT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Gibt die Ausrichtung des Absatzes an. Gültige Werte sind TextFormatAlign-Konstanten.
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormatAlign"><linktext>flash.text.TextFormatAlign</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:blockIndent:get"><apiName>blockIndent</apiName><shortdesc>
	 Gibt den Blockeinzug in Pixeln an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.blockIndent, blockIndent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt den Blockeinzug in Pixeln an. Der Blockeinzug gilt für den gesamten Textblock, d. h. für alle Textzeilen. Im Gegensatz dazu wirkt sich der normale Einzug (<codeph>TextFormat.indent</codeph>) nur auf die erste Zeile in einem Absatz aus. Wenn diese Eigenschaft auf <codeph>null</codeph> gesetzt ist, wird in diesem TextFormat-Objekt kein Blockeinzug angegeben (Blockeinzug = 0).
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
 	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bold:get"><apiName>bold</apiName><shortdesc>
	 Gibt an, ob der Text fett formatiert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bold, bold
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob der Text fett formatiert wird. Der Standardwert <codeph>null</codeph> bedeutet, dass keine Fettformatierung erfolgt. Wenn der Wert <codeph>true</codeph> ist, ist der Text fett formatiert.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bullet:get"><apiName>bullet</apiName><shortdesc>
	 Gibt an, dass der Text Bestandteil einer Aufzählung ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bullet, bullet
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, dass der Text Bestandteil einer Aufzählung ist. In einer Aufzählung ist jeder Textabsatz eingerückt. Vor der ersten Zeile in einem Absatz wird ein Aufzählungszeichen angezeigt. Der Standardwert <codeph>null</codeph> bedeutet, dass keine Aufzählung verwendet wird.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:color:get"><apiName>color</apiName><shortdesc>
	 Gibt die Textfarbe an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.color, color
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Textfarbe an. Eine Zahl mit drei 8-Bit-RGB-Komponenten. 0xFF0000 ist beispielsweise Rot und 0x00FF00 Grün. Der Standardwert <codeph>null</codeph> bedeutet, dass in Flash Player die Farbe Schwarz (0x000000) verwendet wird.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:font:get"><apiName>font</apiName><shortdesc>
	 Ein String mit dem Namen der Schriftart für Text in diesem Textformat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.font, font
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Ein String mit dem Namen der Schriftart für Text in diesem Textformat. Der Standardwert <codeph>null</codeph> bedeutet, dass in Flash Player Times New Roman für den Text verwendet wird.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:indent:get"><apiName>indent</apiName><shortdesc>
	 Gibt den Einzug vom linken Rand bis zum ersten Zeichen im Absatz an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.indent, indent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt den Einzug vom linken Rand bis zum ersten Zeichen im Absatz an. Der Standardwert ist <codeph>null</codeph>, d. h., es erfolgt kein Einzug.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/blockIndent"><linktext>flash.text.TextFormat.blockIndent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:italic:get"><apiName>italic</apiName><shortdesc>
	 Gibt an, ob Text in diesem Textformat kursiv formatiert wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.italic, italic
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob Text in diesem Textformat kursiv formatiert wird. Der Standardwert <codeph>null</codeph> bedeutet, dass keine Kursivformatierung erfolgt.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:kerning:get"><apiName>kerning</apiName><shortdesc>
	 Ein boolescher Wert, der angibt, ob Kerning aktiviert (true) oder deaktiviert (false) ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Ein boolescher Wert, der angibt, ob Kerning aktiviert (<codeph>true</codeph>) oder deaktiviert (<codeph>false</codeph>) ist. Der Begriff „Kerning“ bezeichnet die Anpassung der Pixel zwischen bestimmten Zeichenpaaren zur Verbesserung der Lesbarkeit. Diese Funktion sollte nur verwendet werden, wenn sie unbedingt erforderlich ist, beispielsweise bei Überschriften in großen Schriftarten. Kerning wird nur für eingebettete Schriftarten unterstützt.
	 
	 <p>Bestimmte Schriftarten wie Verdana und Schriftarten mit fester Breite wie Courier New unterstützen Kerning nicht.</p>
	 
	 <p>Der Standardwert <codeph>null</codeph> bedeutet, dass Kerning deaktiviert ist.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leading:get"><apiName>leading</apiName><shortdesc>
	 Eine Ganzzahl, die den Abstand zwischen den Zeilen (leading) angibt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leading, leading
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Eine Ganzzahl, die den Abstand zwischen den Zeilen (<i>leading</i>) angibt. Der Standardwert ist <codeph>null</codeph>, d. h., es wird kein Zeilenabstand verwendet.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leftMargin:get"><apiName>leftMargin</apiName><shortdesc>
	 Der linke Rand des Absatzes in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leftMargin, leftMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Der linke Rand des Absatzes in Pixel. Der Standardwert ist <codeph>null</codeph>, d. h., der linke Rand ist 0 Pixel breit.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:letterSpacing:get"><apiName>letterSpacing</apiName><shortdesc>
     Eine Zahl für den insgesamt verfügbaren Platz, der gleichmäßig zwischen den Zeichen aufgeteilt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Eine Zahl für den insgesamt verfügbaren Platz, der gleichmäßig zwischen den Zeichen aufgeteilt wird. Der Wert gibt an, wie viele Pixel Leerraum hinter jedem Zeichen einzufügen sind. Der Standardwert <codeph>null</codeph> bedeutet, dass ein Zeichenabstand von 0 Pixel verwendet wird. Sie können Dezimalwerte verwenden, zum Beispiel <codeph>1.75</codeph>.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:rightMargin:get"><apiName>rightMargin</apiName><shortdesc>
	 Der rechte Rand des Absatzes in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.rightMargin, rightMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Der rechte Rand des Absatzes in Pixel. Der Standardwert ist <codeph>null</codeph>, d. h., der rechte Rand ist 0 Pixel breit.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:size:get"><apiName>size</apiName><shortdesc>
	 Die Größe des Texts in diesem Textformat in Pixeln.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.size, size
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Die Größe des Texts in diesem Textformat in Pixeln. Der Standardwert ist <codeph>null</codeph>, was bedeutet, das als Größe 12 verwendet wird.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:tabStops:get"><apiName>tabStops</apiName><shortdesc>
	 Gibt benutzerdefinierte Tabstopps als Array aus nicht negativen Ganzzahlen an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.tabStops, tabStops
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt benutzerdefinierte Tabstopps als Array aus nicht negativen Ganzzahlen an. Jeder Tabstopp wird in Pixeln angegeben. Wenn keine benutzerdefinierten Tabstopps definiert werden (<codeph>null</codeph>), wird als Standardtabstopp 4 verwendet (durchschnittliche Zeichenbreite).
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:target:get"><apiName>target</apiName><shortdesc>
	 Gibt das Zielfenster an, in dem der Hyperlink angezeigt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.target, target
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt das Zielfenster an, in dem der Hyperlink angezeigt werden soll. Wenn als Zielfenster ein leerer String angegeben wird, erscheint der Text im Standardzielfenster (<codeph>_self</codeph>). Sie können einen benutzerdefinierten Namen oder einen der folgenden vier Namen auswählen: Mit der Option <codeph>_self</codeph> wird der aktuelle Frame im aktuellen Fenster angegeben, mit <codeph>_blank</codeph> ein neues Fenster, mit <codeph>_parent</codeph> der dem aktuellen Frame übergeordnete Frame und mit <codeph>_top</codeph> der Frame der obersten Stufe im aktuellen Fenster. Wenn die Eigenschaft <codeph>TextFormat.url</codeph> ein leerer String oder <codeph>null</codeph> ist, kann sie zwar abgerufen und gesetzt werden, hat aber keine Auswirkung.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/url"><linktext>flash.text.TextFormat.url</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:underline:get"><apiName>underline</apiName><shortdesc>
	 Gibt an, ob der Text mit diesem Textformat unterstrichen ist (true) oder nicht (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.underline, underline
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt an, ob der Text mit diesem Textformat unterstrichen ist (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). Dieser Unterstreichungseffekt ähnelt dem, der mit dem <codeph>&lt;U></codeph>-Tag erzielt wird. Hierbei handelt es sich jedoch nicht um eine echte Unterstreichung, da Unterlängen nicht korrekt übersprungen werden. Der Standardwert <codeph>null</codeph> bedeutet, dass keine Unterstreichung verwendet wird.
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:url:get"><apiName>url</apiName><shortdesc>
	 Gibt die Ziel-URL für den Text in diesem Textformat an.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.url, url
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Ziel-URL für den Text in diesem Textformat an. Wenn für die Eigenschaft <codeph>url</codeph> ein leerer String angegeben wird, weist der Text keinen Hyperlink auf. Der Standardwert ist <codeph>null</codeph>, d. h., der Text weist keinen Hyperlink auf.
	 <p><b>Hinweis:</b> Damit der Hyperlink funktioniert, muss für den Text mit dem zugewiesenen Textformat die Eigenschaft <codeph>htmlText</codeph> festgelegt werden.</p>
	 
	 </apiDesc><example>Die Verwendung dieser Eigenschaft wird im Beispiel für den <xref href="TextFormat.html#TextFormat()">TextFormat()-Konstruktor</xref> veranschaulicht. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextDisplayMode"><apiName>TextDisplayMode</apiName><shortdesc>
 Die TextDisplayMode-Klasse enthält Werte zur Steuerung des Anti-Aliasing des erweitertem Anti-Aliasing-Systems für Subpixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die TextDisplayMode-Klasse enthält Werte zur Steuerung des Anti-Aliasing des erweitertem Anti-Aliasing-Systems für Subpixel. 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/displayMode"><linktext>flash.text.TextRenderer.displayMode</linktext></link></related-links><apiValue id="flash.text:TextDisplayMode:CRT"><apiName>CRT</apiName><shortdesc>
	 Zwingt Flash Player zur Verwendung des Anti-Aliasing für Graustufen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>crt</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Zwingt Flash Player zur Verwendung des Anti-Aliasing für Graustufen. Diese Einstellung verhindert zwar die Farbformatierung von Text, führt aber unter Umständen zu einer leicht verschwommenen Darstellung.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 Ermöglicht Flash Player die Auswahl zwischen LCD- und CRT-Modus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Ermöglicht Flash Player die Auswahl zwischen LCD- und CRT-Modus.	
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:LCD"><apiName>LCD</apiName><shortdesc> 
	 Zwingt Flash Player zur Verwendung des Anti-Aliasing für LCD-Subpixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lcd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	 Zwingt Flash Player zur Verwendung des Anti-Aliasing für LCD-Subpixel. Je nach Schriftart und Hardware führt diese Einstellung zu einer deutlich höheren Auflösung des Texts bzw. der Textfarbe.
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:AntiAliasType"><apiName>AntiAliasType</apiName><shortdesc>
Die AntiAliasType-Klasse enthält Werte für Anti-Aliasing in der flash.text.TextField-Klasse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die AntiAliasType-Klasse enthält Werte für Anti-Aliasing in der flash.text.TextField-Klasse.
</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:AntiAliasType:ADVANCED"><apiName>ADVANCED</apiName><shortdesc>
	Legt erweiterte Anti-Aliasing-Einstellungen fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>advanced</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Legt erweiterte Anti-Aliasing-Einstellungen fest. Das erweiterte Anti-Aliasing ermöglicht es, kleine Schriftgrößen mit sehr hoher Qualität wiederzugeben. Sein Einsatz bietet sich vor allem bei Anwendungen mit sehr viel kleinem Text an. Das erweiterte Anti-Aliasing bietet sich hingegen nicht für große Schriften (über 48 Punkt) an. Diese Konstante wird für die Eigenschaft <codeph>antiAliasType</codeph> in der TextField-Klasse verwendet. Verwenden Sie die Syntax <codeph>AntiAliasType.ADVANCED</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:AntiAliasType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	Legt das Anti-Aliasing auf Einstellungen für Flash Player 7 und früher fest.</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Legt das Anti-Aliasing auf Einstellungen für Flash Player 7 und früher fest. Diese Einstellung empfiehlt sich für Anwendungen mit wenig Text. Diese Konstante wird für die Eigenschaft <codeph>antiAliasType</codeph> in der TextField-Klasse verwendet. Verwenden Sie die Syntax <codeph>AntiAliasType.NORMAL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:FontType"><apiName>FontType</apiName><shortdesc>
	 Die FontType-Klasse enthält die aufgezählten Konstanten „embedded“ und „device“ für die Eigenschaft „fontType“ der Font-Klasse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Die FontType-Klasse enthält die aufgezählten Konstanten <codeph>"embedded"</codeph> und <codeph>"device"</codeph> für die Eigenschaft <codeph>fontType</codeph> der Font-Klasse. 
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#Font/fontType"><linktext>flash.text.Font.fontType</linktext></link></related-links><apiValue id="flash.text:FontType:DEVICE"><apiName>DEVICE</apiName><shortdesc>
		 Gibt an, dass es sich um eine Geräteschriftart handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>device</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass es sich um eine Geräteschriftart handelt. Die SWF-Datei gibt Schriftarten mit den auf dem System installierten Schriftarten wieder.
		 
		 <p>Die Verwendung von Geräteschriftarten führt zu einer Reduzierung der Filmgröße, da die Schriftartdaten nicht in der Datei gespeichert werden. Geräteschriftarten sind häufig eine gute Wahl zur Anzeige von Text mit kleiner Schriftgröße, da das Anti-Aliasing hierbei häufig zu unscharfen Ergebnissen führt. Geräteschriftarten sind auch eine gute Wahl für große Textblöcke wie z. B. Bildlauftext.</p>
		 
		 <p>Textfelder mit Geräteschriftarten werden unter Umständen auf verschiedenen Systemen und Plattformen unterschiedlich angezeigt, da die jeweils auf dem System installierten Schriftarten verwendet werden. Aus dem gleichen Grund findet bei Geräteschriftarten kein Anti-Aliasing statt, was bei großen Schriftgrößen zu einer gezackten Darstellung führen kann.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED"><apiName>EMBEDDED</apiName><shortdesc>
		 Gibt an, dass es sich um eine eingebettete Schriftart handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embedded</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass es sich um eine eingebettete Schriftart handelt. Schriftkonturen sind in die veröffentlichte SWF-Datei eingebettet.
		 
		 <p>Textfelder mit eingebetteten Schriftarten werden immer in der gewünschten Schriftart angezeigt. Dies erfolgt unabhängig davon, ob die Schriftart auf dem Wiedergabesystem installiert ist. Textfelder mit eingebetteten Schriftarten werden außerdem immer durch Anti-Aliasing geglättet. Der Umfang des Anti-Aliasing kann mit der Eigenschaft <codeph>TextField.antiAliasType</codeph> festgelegt werden.</p>
		 
		 <p>Eingebettete Schriftarten haben den Nachteil, dass sie die Größe der SWF-Datei erheblich vergrößern.</p>
		 
		 <p>Schriftarten des Typs <codeph>EMBEDDED</codeph> können nur vom TextField verwendet werden. Wenn flash.text.engine-Klassen angewiesen werden, eine derartige Schriftart zu verwenden, verwenden sie stattdessen Geräteschriftarten.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED_CFF"><apiName>EMBEDDED_CFF</apiName><shortdesc>
		 Gibt an, dass es sich um eine eingebettete CFF-Schriftart handelt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embeddedCFF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Gibt an, dass es sich um eine eingebettete CFF-Schriftart handelt. Schriftartkonturen und ein Teilsatz der OpenType-Tabellen werden in der veröffentlichten SWF-Datei eingebettet.
		 
		 <p>Text, der eingebettete CFF-Schriftarten verwendet, wird immer und unabhängig davon, ob die Schriftart auf dem Wiedergabesystem installiert ist, in der gewählten Schriftart angezeigt. Außerdem wird Text, der eingebettete CFF-Schriftarten verwendet, immer von Flash Player geglättet. Sie können den Wiedergabemodus und Hinweise für eine eingebettete CFF-Schriftart über die Eigenschaft <codeph>flash.text.engine.FontDescription.renderingMode</codeph> und <codeph>flash.text.engine.FontDescription.cffHinting</codeph> auswählen.</p>
		 
		 <p>Ein Nachteil eingebetteter CFF-Schriftarten ist, dass sie die SWF-Datei vergrößern. Eingebettete CFF-Schriftarten sind jedoch normalerweise 20 bis 30 % kleiner als reguläre eingebettete Schriftarten.</p>
		 
		 <p>Schriftarten des Typs <codeph>EMBEDDED_CFF</codeph> können nur von den flash.text.engine-Klassen verwendet werden. Ein TextField, für das eine derartige Schriftart definiert wird, kann nicht wiedergegeben werden.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormatAlign"><apiName>TextFormatAlign</apiName><shortdesc>
 Die TextFormatAlign-Klasse enthält Werte zur Textausrichtung in der TextFormat-Klasse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die TextFormatAlign-Klasse enthält Werte zur Textausrichtung in der TextFormat-Klasse.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links><apiValue id="flash.text:TextFormatAlign:CENTER"><apiName>CENTER</apiName><shortdesc>
	 Konstante; zentriert den Text im Textfeld.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Konstante; zentriert den Text im Textfeld. Verwenden Sie die Syntax <codeph>TextFormatAlign.CENTER</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:JUSTIFY"><apiName>JUSTIFY</apiName><shortdesc>
	 Konstante; formatiert den Text im Textfeld als Blocksatz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>justify</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Konstante; formatiert den Text im Textfeld als Blocksatz. Verwenden Sie die Syntax <codeph>TextFormatAlign.JUSTIFY</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
	 Konstante; richtet Text innerhalb des Textfelds linksbündig aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Konstante; richtet Text innerhalb des Textfelds linksbündig aus. Verwenden Sie die Syntax <codeph>TextFormatAlign.LEFT</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
	 Konstante; richtet Text innerhalb des Textfelds rechtsbündig aus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Konstante; richtet Text innerhalb des Textfelds rechtsbündig aus. Verwenden Sie die Syntax <codeph>TextFormatAlign.RIGHT</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:Font"><apiName>Font</apiName><shortdesc>
 Die Font-Klasse wird zur Verwaltung von in SWF-Dateien eingebetteten Schriftarten verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die Font-Klasse wird zur Verwaltung von in SWF-Dateien eingebetteten Schriftarten verwendet. Eingebettete Schriftarten werden als Unterklasse der Font-Klasse dargestellt. Die Font-Klasse wird zurzeit nur dazu verwendet, Informationen zu eingebetteten Schriftarten zu ermitteln. Sie können die Schriftart nicht mithilfe dieser Klasse ändern. Sie können die Font-Klasse nicht zum Laden externer Schriftarten oder zum Erstellen einer Instanz eines Font-Objekts selbst verwenden. Verwenden Sie die Font-Klasse als abstrakte Basisklasse.
 
 </apiDesc></apiClassifierDetail><apiOperation id="flash.text:Font:enumerateFonts"><apiName>enumerateFonts</apiName><shortdesc> 
    Gibt an, ob eine Liste der aktuell verfügbaren eingebetteten Schriftarten bereitgestellt wird.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Eine Liste der verfügbaren Schriftarten in Form eines Arrays von Font-Objekten.
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>enumerateDeviceFonts</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Gibt an, ob Sie die Liste auf die aktuell verfügbaren Schriftarten begrenzen möchten. Bei der Einstellung <codeph>true</codeph> wird eine Liste sämtlicher Schriftarten (Geräteschriftarten und eingebettete Schriftarten) zurückgegeben. Bei <codeph>false</codeph> wird nur eine Liste der eingebetteten Schriftarten zurückgegeben.
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
    Gibt an, ob eine Liste der aktuell verfügbaren eingebetteten Schriftarten bereitgestellt wird.
        </apiDesc><example conref="examples\Font.enumerateFonts.1.as"> In diesem Beispiel wird zuerst die statische Methode <codeph>Font.enumerateFonts()</codeph> zur Erstellung einer Liste mit allen Geräte- und eingebetteten Schriftarten aufgerufen. Anschließend wird das Array mit Font-Objekten nach der Eigenschaft <codeph>fontName</codeph> sortiert.
 
 <p>Aus dem Beispiel geht zudem hervor, wie die <codeph>Font.enumerateFonts()</codeph>-Methode mit dem auf „false“ eingestellten <codeph>enumerateDeviceFonts</codeph>-Parameter aufgerufen wird. Das resultierende Array enthält nur eingebettete Font-Objekte. (Wenn Sie diesen Code in einer Anwendung durchführen, die keine eingebetteten Schriftarten enthält, ist das Array <codeph>embeddedFonts</codeph> leer.)</p>
<codeblock>
 
import flash.text.Font;

var allFonts:Array = Font.enumerateFonts(true);
allFonts.sortOn("fontName", Array.CASEINSENSITIVE);

var embeddedFonts:Array = Font.enumerateFonts(false);
embeddedFonts.sortOn("fontName", Array.CASEINSENSITIVE);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:hasGlyphs"><apiName>hasGlyphs</apiName><shortdesc> 
        Gibt an, ob ein vorgegebener String mit der aktuell zugewiesenen Schriftart angezeigt werden kann.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Der Wert <codeph>true</codeph> bedeutet, dass der vorgegebene String in der Schriftart vollständig dargestellt werden kann.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der String, dessen Darstellung in der aktuellen Schriftart getestet wird.
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
        Gibt an, ob ein vorgegebener String mit der aktuell zugewiesenen Schriftart angezeigt werden kann.
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:registerFont"><apiName>registerFont</apiName><shortdesc> 
	Registriert eine Font-Klasse in der globalen Schriftartenliste.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>Die Klasse, die Sie der globalen Schriftartenliste hinzufügen möchten.
	</apiDesc></apiParam></apiOperationDef><apiDesc> 
	Registriert eine Font-Klasse in der globalen Schriftartenliste.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.text:Font:fontName:get"><apiName>fontName</apiName><shortdesc> 
	Der Name einer eingebetteten Schriftart.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Der Name einer eingebetteten Schriftart. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:Font:fontStyle:get"><apiName>fontStyle</apiName><shortdesc> 
	Der Stil der Schriftart.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Der Stil der Schriftart. Hierbei kann es sich um einen beliebigen Wert aus der FontStyle-Klasse handeln.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link></related-links></apiValue><apiValue id="flash.text:Font:fontType:get"><apiName>fontType</apiName><shortdesc> 
	Der Typ der Schriftart.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Der Typ der Schriftart. Hierbei kann es sich um eine beliebige Konstante aus der FontType-Klasse handeln.
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontType"><linktext>flash.text.FontType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextRenderer"><apiName>TextRenderer</apiName><shortdesc>
 Die TextRenderer-Klasse enthält Funktionen für das erweiterte Anti-Aliasing eingebetteter Schriftarten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>-- Class sample changed due to bug 193833
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Steuert das Anti-Aliasing von eingebetteten Schriftarten.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die TextRenderer-Klasse enthält Funktionen für das erweiterte Anti-Aliasing eingebetteter Schriftarten. Das erweiterte Anti-Aliasing ermöglicht es, Schriften in sehr kleinen Größen mit sehr hoher Qualität wiederzugeben. Verwenden Sie erweitertes Anti-Aliasing vor allem bei Anwendungen mit sehr viel kleinem Text an. Adobe empfiehlt erweitertes Anti-Aliasing nicht für sehr große Schriften (über 48 Punkt). Erweitertes Anti-Aliasing steht erst ab Flash Player 8 zur Verfügung.
 
 <p>Wenn Sie das erweiterte Anti-Aliasing für ein Textfeld verwenden möchten, setzen Sie die <codeph>antiAliasType</codeph>-Eigenschaft der Textfeldinstanz:</p>
 
 <p>Erweitertes Anti-Aliasing bietet Continuous Stroke Modulation (CSM), d. h. die fortlaufende Modulierung von Strichstärke und Kantenschärfe. Zu den erweiterten Funktionen gehört die Möglichkeit, mit der <codeph>setAdvancedAntiAliasingTable()</codeph>-Methode Einstellungen für bestimmte Schriftarten und Schriftgrade zu definieren.</p>
 
 </apiDesc><example conref="examples\TextRendererExample2.as"> Im folgenden Beispiel wird eine TextRendererExample-Klasse erstellt, um visuelle Beispiele für erweiterte Anti-Aliasing-Einstellungen mit kleinen und großen Schriftgrößen zu zeigen. Vor dem Testen dieses Beispiels müssen Sie eine Schrift einbetten. Wenn Sie Flex verwenden, wird die Schriftart folgendermaßen eingebettet:
 <ol>
    <li>Platzieren Sie die Schriftart Georgia (georgia.ttf) in dasselbe Verzeichnis wie diese AS-Datei.</li>
    <li>Fügen Sie direkt unterhalb der Klassendefinition folgende Zeilen hinzu:</li>
    <li><codeph>[Embed(source="georgia.ttf", fontFamily="Georgia")]</codeph></li>
    <li><codeph>private var embeddedFont:String;</codeph></li>
 </ol>
 Wenn Sie Flash verwenden, wird die Schriftart folgendermaßen eingebettet:
 <ol>
     <li>Platzieren Sie ein Textfeld auf der Bühne und wählen Sie es aus.</li>
     <li>Setzen Sie im Eigenschaftsinspektor die Schriftart dieses Textfelds auf Georgia.</li>
     <li>Klicken Sie im Eigenschaftsinspektor auf „Embed...“ und wählen Sie „All“ aus.</li>
 </ol>
 <p> <b>Hinweise:</b>
  <ul>
     <li>Für die Kompilierung der SWF-Datei müssen Sie die Option „Sicherheit bei lokaler Wiedergabe“ auf „Nur auf lokale Dateien zugreifen“ einstellen.</li>
    </ul>
 </p>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.text.*;
    
    public class TextRendererExample2 extends Sprite {

        private var gutter:int = 10;

        public function TextRendererExample2() {
            createTextField(8,AntiAliasType.NORMAL);
            createTextField(8,AntiAliasType.ADVANCED);
            createTextField(24,AntiAliasType.NORMAL);
            createTextField(24,AntiAliasType.ADVANCED);
        }
            
        private function createTextField(fontSize:Number,antiAliasType:String):TextField {
            var tf:TextField = new TextField();
            tf.embedFonts = true;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.antiAliasType = antiAliasType;
            tf.defaultTextFormat = getTextFormat(fontSize);
            tf.selectable = false;
            tf.mouseEnabled = true;
            tf.text = "The quick brown fox jumped over the lazy dog.";
            if(numChildren > 0) {
                var sibling:DisplayObject = getChildAt(numChildren - 1);
                tf.y = sibling.y + sibling.height + gutter;
            }
            addChild(tf);
            return tf;
        }
        
        private function getTextFormat(fontSize:Number):TextFormat {
            var format:TextFormat = new TextFormat();
            format.size = fontSize;
            format.font = "Georgia";
            return format;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links><apiOperation id="flash.text:TextRenderer:setAdvancedAntiAliasingTable"><apiName>setAdvancedAntiAliasingTable</apiName><shortdesc>
	 Legt eine benutzerdefinierte CSM-Nachschlagetabelle für eine Schriftart fest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two anti-alias entries and two text fields to 
	 illustrate them. For this example to work, the SWF file must have a shared font embedded with a linkage identifier of <code>
	 "myArial"</code>. 
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library.</li>
	 <li>Click the Library options menu in the upper-right corner of the Library.</li>
	 <li>Select New Font from the pop-up menu.</li>
	 <li>Name the font <b>myArial</b>.</li>
	 <li>Select Arial from the font pop-up menu.</li>
	 <li>Click OK.</li>
	 <li>Right-click the newly created font, and select Linkage.</li>
	 <li>Select the Export for ActionScript check box.</li>
	 <li>Click OK to accept the default identifier, myArial.</li>
	 </ol>
	 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 
	 var antiAliasEntry_1 = {fontSize:24, insideCutoff:1.61, outsideCutoff:-3.43};
	 var antiAliasEntry_2 = {fontSize:48, insideCutoff:0.8, outsideCutoff:-0.8};
	 var arialTable:Array = new Array(antiAliasEntry_1, antiAliasEntry_2);
	 
	 var lbl_1:TextField = createLabel(0, 0, 300, 100, 24);
	 var lbl_2:TextField = createLabel(0, 100, 300, 100, 48);
	 
	 TextRenderer.setAdvancedAntiAliasingTable("Arial", "none", "dark", arialTable);
	 
	 function createLabel(x:Number, y:Number, width:Number, height:Number, fontSize:Number):TextField {
	 var depth:Number = this.getNextHighestDepth();
	 
	 var tmpTxt = this.createTextField("txt_" + depth, depth, x, y, width, height);
	 tmpTxt.antiAliasType = "advanced";
	 tmpTxt.gridFitType = "pixel";
	 tmpTxt.border = true;
	 tmpTxt.text = "Hello World";
	 tmpTxt.embedFonts = true;
	 tmpTxt.setTextFormat(getTextFormat(fontSize));
	 return tmpTxt;
	 }
	 
	 function getTextFormat(fontSize:Number):TextFormat {
	 	var tf:TextFormat = new TextFormat();
	 	tf.align = "center";
	 	tf.size = fontSize;
	 	tf.font = "myArial";
	 	return tf;
	 }
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der Name der Schriftart, auf die Sie Einstellungen anwenden.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der durch einen der Werte aus der flash.text.FontStyle-Klasse angegebene Schriftstil.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Mit diesem Wert wird bestimmt, ob der Strich dunkel oder hell ist. Verwenden Sie einen der Werte aus der flash.text.TextColorType-Klasse. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>advancedAntiAliasingTable</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Ein Array mit einem oder mehreren CSMSettings-Objekten für die angegebene Schriftart. Jedes Objekt enthält die folgenden Eigenschaften:
	 
	 <ul>
	 
	   <li><codeph>fontSize</codeph></li>
	   <li><codeph>insideCutOff</codeph></li>
	   <li><codeph>outsideCutOff</codeph></li>
	 
	 </ul>
	 
	 <p>Der Array <codeph>advancedAntiAliasingTable</codeph> kann mehrere Einträge für CSM-Einstellungen zu verschiedenen Schriftgrößen enthalten.</p>
	 
	 <p><codeph>fontSize</codeph> ist die Größe in Pixel, für die die Einstellungen gelten.</p>
	 
	 <p>Beim erweiterten Anti-Aliasing werden die Konturen, die ein Zeichen bestimmen, mittels ADFs (Adaptively Sampled Distance Fields) dargestellt. In Flash Player wird ein <codeph>outsideCutOff</codeph>-Wert verwendet, unterhalb dessen die Dichten auf 0 gesetzt werden, und ein <codeph>insideCutOff</codeph>-Wert, oberhalb dessen die Dichten auf eine Höchstdichte (z. B. 255) gesetzt werden. Zwischen diesen beiden Werten verläuft die Zuordnungsfunktion linear von 0 am unteren Schwellenwert bis zur Höchstdichte am oberen Schwellenwert.</p>
	 
	 <p>Die Anpassung der Werte für den unteren und den oberen Schwellenwert wirken sich auf die Strichbreite und die Kantenschärfe aus. Der Abstand zwischen diesen beiden Parametern ist mit dem doppelten Filterradius klassischer Anti-Aliasing-Methoden vergleichbar. Ein geringer Abstand bewirkt schärfere Kanten, ein größerer Abstand weichere, stärker gefilterte Kanten. Bei einem Abstand von null ist das Bild mit der resultierenden Dichte ein Bi-level-Bild (Bitmapbild). Bei einem sehr großen Abstand entsteht ein Bild mit wasserfarbenähnlichen Kanten.</p>
	 
	 <p>Normalerweise werden scharfe, kontrastreiche Kanten für kleinere Punktgrößen und weichere Kanten für Lauftext und höhere Punktgrößen bevorzugt. </p>
	 
	 <p>Der untere Schwellenwert ist normalerweise ein negativer Wert, der obere Schwellenwert ein positiver. Ihr Mittelpunkt liegt normalerweise um 0. Wenn Sie diese Parameter ändern, um den Mittelpunkt in Richtung negativer Unendlichkeit zu verschieben, erhöht sich die Strichbreite. Bei Verschiebung des Mittelpunkts zur positiven Unendlichkeit hin wird die Strichbreite verringert. Beachten Sie, dass der untere Schwellenwert nicht größer als der obere Schwellenwert sein darf.</p>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Legt eine benutzerdefinierte CSM-Nachschlagetabelle für eine Schriftart fest. Flash Player versucht, die beste CSM für Ihre Schriftart zu ermitteln. Wenn Sie mit der von Flash Player bereitgestellten CSM nicht zufrieden sind, können Sie Ihre eigene CSM mit der Methode <codeph>setAdvancedAntiAliasingTable()</codeph> festlegen.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link><link href="flash.text.xml#TextColorType"><linktext>flash.text.TextColorType</linktext></link><link href="flash.text.xml#CSMSettings"><linktext>CSMSettings</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextRenderer:displayMode:get"><apiName>displayMode</apiName><shortdesc> 
	 Steuert die Wiedergabe von erweitertem Anti-Aliasing-Text.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>"default"
	 </apiDefaultValue></apiValueDef><apiDesc> 
	 Steuert die Wiedergabe von erweitertem Anti-Aliasing-Text. Die optische Qualität von Text wird subjektiv sehr unterschiedlich beurteilt. Flash Player versucht, die jeweils besten Einstellungen unter verschiedenen Bedingungen vorzunehmen. Unter Umständen wählen Designer für ihren Text jedoch eine andere Einstellung aus. Mit <codeph>displayMode</codeph> kann ein Designer auch die Subpixel-Auswahl in Flash Player außer Kraft setzen und unabhängig von der Hardware des Benutzers eine optische Einheitlichkeit erzielen. Legen Sie diese Eigenschaft mithilfe der Werte in der TextDisplayMode-Klasse fest.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextDisplayMode"><linktext>TextDisplayMode-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.text:TextRenderer:maxLevel:get"><apiName>maxLevel</apiName><shortdesc>
	 Die ADF-Qualitätsstufe (Adaptively Sampled Distance Fields) für erweitertes Anti-Aliasing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example specifies the <code>maxLevel</code> value for the entire
	 SWF file, and then displays a text field with the value set. For the 
	 text in this example to display correctly, there must be a font symbol available with
	 a linkage identifier of <code>"CustomFont"</code>. 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 TextRenderer.maxLevel = 3;
	 
	 var txtFormat:TextFormat = new TextFormat();
	 txtFormat.font = "CustomFont";
	 txtFormat.size = 64;
	 
	 var label:TextField = this.createTextField("label", this.getNextHighestDepth(), 10, 10, 500, 100);
	 label.setNewTextFormat(txtFormat);
	 label.text = "Hello World";
	 label.embedFonts = true;
	 trace("TextRenderer.maxLevel: " + TextRenderer.maxLevel);
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>4
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Die ADF-Qualitätsstufe (Adaptively Sampled Distance Fields) für erweitertes Anti-Aliasing. Die einzigen zulässigen Werte sind 3, 4 und 7. 
	 
	 <p>Beim erweiterten Anti-Aliasing werden die Konturen, die ein Zeichen bestimmen, mittels ADFs (Adaptively Sampled Distance Fields) dargestellt. Je höher die Qualität, desto mehr Cache-Speicherplatz wird für ADF-Strukturen benötigt. Der Wert <codeph>3</codeph> bedeutet die geringste Speicherbelastung und liefert die geringste Qualität. Größere Schriften erfordern mehr Pufferplatz. Bei einer Schriftgröße von 64 Pixel steigt die Qualitätsstufe von <codeph>3</codeph> auf <codeph>4</codeph> bzw. von <codeph>4</codeph> auf <codeph>7</codeph>, sofern nicht bereits die Stufe <codeph>7</codeph> eingestellt ist.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
 Die TextLineMetrics-Klasse enthält Informationen zur Textposition und zu den Abmessungen einer Textzeile innerhalb eines Textfelds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Enthält Informationen zur Textposition und zu den Maßen einer Textzeile innerhalb eines Textfelds.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Die TextLineMetrics-Klasse enthält Informationen zur Textposition und zu den Maßen einer <i>Textzeile</i> innerhalb eines Textfelds. Alle Maße werden in Pixeln angegeben. Objekte dieser Klasse werden von der Methode <codeph>flash.text.TextField.getLineMetrics()</codeph> zurückgegeben.
 <p>Die Maße im Zusammenhang mit dem Textfeld, das die Textzeile enthält (z. B. das Maß „Textfeldhöhe“ im Diagramm), finden Sie unter „flash.text.TextField“. </p>
 
 <p>Aus dem folgenden Diagramm gehen die Punkte und Maße eines Textfelds und der Textzeile innerhalb des Textfelds hervor:</p>
 <p>
 <adobeimage alt="Ein Bild zur Verdeutlichung von Textkriterien" href="../../images/text-metrics.jpg"/></p>
 
 </apiDesc><example conref="examples\TextLineMetricsExample.as"> Im folgenden Beispiel werden die Klassen TextLineMetricsExample und LineMetricsReader zum Druck einer Meldung im Flash Player über ein XML-Objekt erstellt. Dies wird in den folgenden Schritten erreicht:
 <ol>
  <li>Erstellen Sie die Eigenschaft <codeph>label</codeph> vom Typ „TextField“.</li>
  <li>Der Konstruktor ruft die <codeph>configureAssets()</codeph>-Methode auf, die Folgendes durchführt:
  <ul>
      <li>Die Bühne wird oben links ausgerichtet und ohne Skalierung angezeigt.</li>
      <li>Es wird das neue TextField-Objekt <codeph>label</codeph> erstellt.</li>
      <li>Der Hintergrund von <codeph>label</codeph> wird aktiviert, und die Farbe wird auf weiß eingestellt.</li>
      <li>Es wird festgelegt, dass sich der Text von <codeph>label</codeph> über mehrere Zeilen mit automatischem Zeilenumbruch erstrecken kann.</li>
      <li>Das Ergebnis eines Aufrufs an <codeph>getLabelText()</codeph> wird der <codeph>text</codeph>-Eigenschaft von <codeph>label</codeph> zugewiesen. Mit der Methode <codeph>getLabelText()</codeph> wird eine Variable vom Typ XML erstellt und dem XML-Knoten <codeph>body</codeph> zugewiesen, der einen langen Satz enthält.</li>
      <li><codeph>label</codeph> wird der Anzeigeliste mithilfe von <codeph>addChild()</codeph> hinzugefügt.</li>
  </ul>
  </li>
  <li>Anschließend wird die <codeph>resizeHandler()</codeph>-Methode hinzugefügt, die als Listener für <codeph>resize</codeph>-Ereignisse auf der Bühne fungiert. Bei jeder Größenänderung des Flash Player-Fensters wird ein <codeph>RESIZE</codeph>-Ereignis ausgelöst. Dies hat die folgenden Auswirkungen: 
  <ul>
      <li><codeph>draw()</codeph> wird aufgerufen, damit <codeph>label</codeph> in der Mitte der Bühne, umgeben von einem 10-Pixel-Puffer, angezeigt wird.</li>
      <li><codeph>setTimeout()</codeph> führt <codeph>showMetrics()</codeph> anschließend nach einer kurzen Verzögerung aus. Die Verzögerung wird dadurch verursacht, dass die Textzeilenmaße erst nach Abschluss des <codeph>RESIZE</codeph>-Ereignisses und nach der vollständigen Neuzeichnung der Bühne aktualisiert werden.</li>
      <li>Mit <codeph>showMetrics()</codeph> wird die TextLineMetrics-Variable <codeph>metrics</codeph> dem Ergebnis eines Aufrufs von <codeph>getLineMetrics()</codeph> zugewiesen. Diese Variable wird anschließend an eine neue Instanz der LineMetricsReader-Instanz <codeph>reader</codeph> übergeben. Die beiden Variablen werden anschließend in Aufrufen von <codeph>trace()</codeph> zum Drucken der ersten (und einzigen) Zeile von <codeph>label</codeph> und Informationen aus der LineMetricsReader-Instanz (über die <codeph>toString()</codeph>-Methode) verwendet.</li>
  </ul>
  </li>
  <li>Der Konstruktor erzwingt eine einmalige Auslösung <codeph>resize</codeph>-Ereignisses, damit <codeph>label</codeph> beim ersten Laden der SWF-Datei richtig gezeichnet wird.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.utils.setTimeout;

    public class TextLineMetricsExample extends Sprite {
        private var gutter:int = 10;
        private var label:TextField;

        public function TextLineMetricsExample() {
            configureAssets();
            configureListeners();
            resizeHandler(new Event(Event.RESIZE));
        }

        private function showMetrics():void {
            var metrics:TextLineMetrics = label.getLineMetrics(0);
            var reader:LineMetricsReader = new LineMetricsReader(metrics);
            trace("lineText: " + label.getLineText(0));
            trace("metrics: " + reader);
        }

        private function configureAssets():void {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            label = new TextField();
            label.background = true;
            label.backgroundColor = 0xFFFFFF;
            label.multiline = true;
            label.wordWrap = true;
            label.text = getLabelText();
            addChild(label);
        }

        private function configureListeners():void {
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function resizeHandler(event:Event):void {
            draw();
            setTimeout(showMetrics, 100);
        }

        private function draw():void {
            label.x = gutter;
            label.y = gutter;
            label.width = stage.stageWidth - (gutter * 2);
            label.height = stage.stageHeight - (gutter * 2);
        }

        private function getLabelText():String {
            var text:XML = &lt;body>The Flex product line enables developers to build rich Internet applications that blend the responsiveness of desktop software, the cross-platform reach of the web, and the expressiveness of the Flash Platform.&lt;/body>
            return text.toString();
        }
    }
}

import flash.text.TextLineMetrics;

class LineMetricsReader {
    private var metrics:TextLineMetrics;

    public function LineMetricsReader(metrics:TextLineMetrics) {
        this.metrics = metrics;
    }

    public function toString():String {
        return "[TextLineMetrics ascent:" + metrics.ascent
            + ", descent:" + metrics.descent
            + ", leading:" + metrics.leading
            + ", width:" + metrics.width
            + ", height:" + metrics.height
            + ", x:" + metrics.x
            + "]";
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:TextLineMetrics:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
	 Erstellt ein TextLineMetrics-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die linke Position des ersten Zeichens in Pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>[Die Breite des Texts in den ausgewählten Zeilen (nicht unbedingt des gesamten Texts) in Pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Höhe des Texts in den ausgewählten Zeilen (nicht unbedingt des gesamten Texts) in Pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Länge von der Grundlinie bis zur obersten Stelle der Zeile in Pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Die Länge von der Grundlinie bis zur untersten Stelle der Zeile in Pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Der vertikale Abstand zwischen den Textzeilen.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Enthält Informationen zur Textposition und zu den Maßen einer Textzeile innerhalb eines Textfelds.
  	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Erstellt ein TextLineMetrics-Objekt. Das TextLineMetrics-Objekt enthält Informationen zu den Maßen einer Textzeile innerhalb eines Textfelds. Objekte dieser Klasse werden von der Methode <codeph>flash.text.TextField.getLineMetrics()</codeph> zurückgegeben.
	 <p>Kontextinformationen zu den verschiedenen Eigenschaften finden Sie im Übersichtsdiagramm für diese Klasse.</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Übersicht über die TextLineMetrics-Klasse</linktext></link><link href="flash.text.xml#TextField/getLineMetrics()"><linktext>flash.text.TextField.getLineMetrics()</linktext></link></related-links></apiConstructor><apiValue id="flash.text:TextLineMetrics:ascent"><apiName>ascent</apiName><shortdesc>
	 Die Oberlänge des Texts ist die Länge von der Grundlinie bis zur Oberkante der Zeile in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>including accents? is it really the line or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Oberlänge des Texts ist die Länge von der Grundlinie bis zur Oberkante der Zeile in Pixel. Siehe „Oberlänge“ im Übersichtsdiagramm für diese Klasse.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Übersicht über die TextLineMetrics-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:descent"><apiName>descent</apiName><shortdesc>
	 Die Unterlänge des Texts ist die Länge von der Grundlinie bis zur Unterkante der Zeile in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>is it really the line? or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Unterlänge des Texts ist die Länge von der Grundlinie bis zur Unterkante der Zeile in Pixel. Siehe „Unterlänge“ im Übersichtsdiagramm für diese Klasse.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Übersicht über die TextLineMetrics-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:height"><apiName>height</apiName><shortdesc>
	 Die Höhe des Texts in den ausgewählten Zeilen (nicht unbedingt des gesamten Texts) in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Die Höhe des Texts in den ausgewählten Zeilen (nicht unbedingt des gesamten Texts) in Pixel. Die Höhe der Textzeile umfasst nicht die Höhe des Zwischenraums. Siehe „Zeilenhöhe“ im Übersichtsdiagramm für diese Klasse.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Übersicht über die TextLineMetrics-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:leading"><apiName>leading</apiName><shortdesc>
	 [Der Zeilenabstand ist der vertikale Abstand zwischen den Textzeilen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 [Der Zeilenabstand ist der vertikale Abstand zwischen den Textzeilen. Siehe „Zeilenabstand“ im Übersichtsdiagramm für diese Klasse.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Übersicht über die TextLineMetrics-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:width"><apiName>width</apiName><shortdesc>
	 Der Wert für die Breite ist die Textbreite in den ausgewählten Zeilen (nicht unbedingt des gesamten Texts) in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der Wert für die Breite ist die Textbreite in den ausgewählten Zeilen (nicht unbedingt des gesamten Texts) in Pixel. Die Breite der Textzeile ist nicht identisch mit der Breite des Textfelds. Die Breite der Textzeile muss relativ zur Textfeldbreite gesehen werden (abzüglich des Zwischenraums von 4 Pixel, d. h. 2 Pixel auf jeder Seite). Siehe „Breite der Textzeile“ im Übersichtsdiagramm für diese Klasse.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Übersicht über die TextLineMetrics-Klasse</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:x"><apiName>x</apiName><shortdesc>
	 Der x-Wert ist die linke Position des ersten Zeichens in Pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Der x-Wert ist die linke Position des ersten Zeichens in Pixel. Dieser Wert umfasst den Rand, eventuelle Einzüge und den Zwischenraum. Siehe „x-Position der Textzeile“ im Übersichtsdiagramm für diese Klasse.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Übersicht über die TextLineMetrics-Klasse</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
 Mit der StyleSheet-Klasse können Sie ein StyleSheet-Objekt erstellen, das Textformatierungsregeln für Schriftgröße und Farbe sowie für weitere Stile enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet class, built-in class, style sheet, stylesheet
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Ermöglicht die Erstellung eines StyleSheet-Objekts.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Mit der StyleSheet-Klasse können Sie ein StyleSheet-Objekt erstellen, das Textformatierungsregeln für Schriftgröße und Farbe sowie für weitere Stile enthält. Anschließend können Sie durch ein Stylesheet definierte Stile auf ein TextField-Objekt anwenden, das HTML- oder XML-formatierten Text enthält. Der im TextField-Objekt enthaltene Text wird dann automatisch entsprechend den Tag-Stilen formatiert, die durch das StyleSheet-Objekt definiert sind. Sie können Textstile zum Definieren von Formatierungstags verwenden, integrierte HTML-Tags neu definieren oder Stilklassen erstellen, die auf bestimmte HTML-Tags angewendet werden.
 
 <p>Wenn Sie auf ein TextField-Objekt Stile anwenden möchten, weisen Sie das StyleSheet-Objekt der Eigenschaft <codeph>styleSheet</codeph> eines TextField-Objekts zu.</p>
 <p><b>Hinweis:</b> Ein Textfeld mit einem Stylesheet, das nicht bearbeitet werden kann. Mit anderen Worten: Ein Textfeld, bei dem die <codeph>type</codeph>-Eigenschaft auf <codeph>TextFieldType.INPUT</codeph> gesetzt ist, wendet das Stylesheet auf den Standardtext eines Textfelds an, aber der Inhalt kann vom Benutzer nicht mehr bearbeitet werden. Ziehen Sie es in Betracht, die TextFormat-Klasse für die Zuweisung von Stilen zu Eingabetextfeldern zu verwenden.</p> 
 
 <p>Flash Player unterstützt einen Teilsatz der Eigenschaften aus der ursprünglichen CSS1-Spezifikation (<xref href="http://www.w3.org/TR/REC-CSS1" scope="external">www.w3.org/TR/REC-CSS1</xref>). In der folgenden Tabelle finden Sie die unterstützten CSS-Eigenschaften (Cascading Style Sheet) und Werte sowie die entsprechenden ActionScript-Eigenschaftennamen. (Die Namen der einzelnen ActionScript-Eigenschaften werden von der entsprechenden Bezeichnung der CSS-Eigenschaften abgeleitet, wenn der Name einen Bindestrich enthält. Dabei fällt der Bindestrich weg, und das nachfolgende Zeichen wird groß geschrieben.)</p>
 
 <adobetable class="innertable">
 
   
 
   
 
   
 
   
 
   
 
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
 <tgroup cols="3"><thead><row><entry>CSS-Eigenschaft</entry><entry>ActionScript-Eigenschaft</entry><entry>Verwendung und unterstützte Werte</entry></row></thead><tbody><row>
     <entry><codeph>color</codeph></entry>
     <entry><codeph>color</codeph></entry>
     <entry>Es werden nur hexadezimale Farbwerte unterstützt. Benannte Farben (wie <codeph>blue</codeph>) werden nicht unterstützt. Farben werden im folgenden Format geschrieben: <codeph>#FF0000</codeph> .</entry>
   </row><row>
     <entry><codeph>display</codeph></entry>
     <entry><codeph>display</codeph></entry>
     <entry>Unterstützte Werte sind <codeph>inline</codeph>, <codeph>block</codeph> und <codeph>none</codeph>.</entry>
   </row><row>
     <entry><codeph>font-family</codeph></entry>
     <entry><codeph>fontFamily</codeph></entry>
     <entry>Eine zu verwendende kommagetrennte Schriftenliste, in absteigender Reihenfolge der Präferenz. Es lassen sich beliebige Namen für die Schriftart verwenden. Wenn Sie eine generische Schriftartbezeichnung wählen, wird diese in eine entsprechende Geräteschriftart konvertiert. Die folgenden Schriftkonvertierungen stehen zur Verfügung: <codeph>mono</codeph> wird in <codeph>_typewriter</codeph> konvertiert, <codeph>sans-serif</codeph> in <codeph>_sans</codeph> und <codeph>serif</codeph> in <codeph>_serif</codeph>.</entry>
   </row><row>
     <entry><codeph>font-size</codeph></entry>
     <entry><codeph>fontSize</codeph> </entry>
     <entry>Nur der numerische Teil des Werts wird verwendet. Einheiten (px, pt) werden nicht geparst; Pixel und Punkte sind gleichwertig.</entry>
   </row><row>
     <entry><codeph>font-style</codeph></entry>
     <entry><codeph>fontStyle</codeph></entry>
     <entry>Die Werte <codeph>normal</codeph> und <codeph>italic</codeph> werden erkannt.</entry>
   </row><row>
     <entry><codeph>font-weight</codeph></entry>
     <entry><codeph>fontWeight</codeph></entry>
     <entry>Die Werte <codeph>normal</codeph> und <codeph>bold</codeph> sind gültig.</entry>
   </row><row>
     <entry><codeph>kerning</codeph></entry>
     <entry><codeph>kerning</codeph></entry>
     <entry>Die Werte <codeph>true</codeph> und <codeph>false</codeph> werden erkannt. Kerning wird nur für eingebettete Schriftarten unterstützt. Gewisse Schriftarten wie beispielsweise Courier New unterstützen Kerning nicht. Die Kerning-Eigenschaft wird nur in unter Windows erzeugten SWF-Dateien unterstützt, nicht jedoch in auf Macintosh-Systemen erzeugten SWF-Dateien. Diese SWF-Dateien können jedoch in Nicht-Windows-Versionen von Flash Player wiedergegeben werden. Das Kerning bleibt hierbei erhalten.</entry>
   </row><row>
     <entry><codeph>leading</codeph></entry>
     <entry><codeph>leading</codeph></entry>
     <entry>Der Platz, der gleichmäßig zwischen den Zeilen aufgeteilt wird. Der Wert gibt an, wie viele Pixel Leerraum hinter jeder Zeile einzufügen sind. Bei einem negativen Wert wird der Platz zwischen den Zeilen verkleinert. Nur der numerische Teil des Werts wird verwendet. Einheiten (px, pt) werden nicht geparst; Pixel und Punkte sind gleichwertig.</entry>
   </row><row>
     <entry><codeph>letter-spacing</codeph></entry>
     <entry><codeph>letterSpacing</codeph></entry>
     <entry>Der Platz, der gleichmäßig zwischen den Zeichen aufgeteilt wird. Der Wert gibt an, wie viele Pixel Leerraum hinter jedem Zeichen einzufügen sind. Bei einem negativen Wert wird der Platz zwischen den Zeichen verkleinert. Nur der numerische Teil des Werts wird verwendet. Einheiten (px, pt) werden nicht geparst; Pixel und Punkte sind gleichwertig.</entry>
   </row><row>
     <entry><codeph>margin-left</codeph></entry>
     <entry><codeph>marginLeft</codeph></entry>
     <entry>Nur der numerische Teil des Werts wird verwendet. Einheiten (px, pt) werden nicht geparst; Pixel und Punkte sind gleichwertig. </entry>
   </row><row>
     <entry><codeph>margin-right</codeph></entry>
     <entry><codeph>marginRight</codeph></entry>
     <entry>Nur der numerische Teil des Werts wird verwendet. Einheiten (px, pt) werden nicht geparst; Pixel und Punkte sind gleichwertig.</entry>
   </row><row>
     <entry><codeph>text-align</codeph></entry>
     <entry><codeph>textAlign</codeph></entry>
     <entry>Die Werte <codeph>left</codeph>, <codeph>center</codeph>, <codeph>right</codeph> und <codeph>justify</codeph> werden erkannt.</entry>
   </row><row>
     <entry><codeph>text-decoration</codeph></entry>
     <entry><codeph>textDecoration</codeph></entry>
     <entry>Die Werte <codeph>none</codeph> und <codeph>underline</codeph> werden erkannt.</entry>
   </row><row>
     <entry><codeph>text-indent</codeph></entry>
     <entry><codeph>textIndent</codeph></entry>
     <entry>Nur der numerische Teil des Werts wird verwendet. Einheiten (px, pt) werden nicht geparst; Pixel und Punkte sind gleichwertig. </entry>
   </row></tbody></tgroup></adobetable> 
 
 <p><ph outputclass="flexonly">Mit der StyleSheet-Klasse können Sie Text-Rendering auf niedriger Ebene durchführen. In Flex verwenden Sie jedoch normalerweise die Steuerelemente „Label“, „Text“, „TextArea“ und „TextInput“ zur Textverarbeitung.</ph></p>
 
 
 </apiDesc><example conref="examples\StyleSheetExample.as"> Im folgenden Beispiel wird ein neues Stylesheet erstellt, und für die Überschrift wird ein Stil mit roter Schrift und Fettformatierung festgelegt.
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class StyleSheetExample extends Sprite {

        public function StyleSheetExample() {
            var style:StyleSheet = new StyleSheet();

            var heading:Object = new Object();
            heading.fontWeight = "bold";
            heading.color = "#FF0000";

            var body:Object = new Object();
            body.fontStyle = "italic";

            style.setStyle(".heading", heading);
            style.setStyle("body", body);

            var label:TextField = new TextField();
            label.styleSheet = style;
            label.htmlText = "&lt;body>&lt;span class='heading'>Hello &lt;/span>World...&lt;/body>";
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:StyleSheet:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
	 Erstellt ein neues StyleSheet-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet, constructor
	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Erstellt ein neues StyleSheet-Objekt.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#StyleSheet/getStyle()"><linktext>flash.text.StyleSheet.getStyle()</linktext></link></related-links></apiConstructor><apiOperation id="flash.text:StyleSheet:clear"><apiName>clear</apiName><shortdesc>
	 Entfernt sämtliche Stile aus dem StyleSheet-Objekt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.clear, clear
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Entfernt sämtliche Stile aus dem StyleSheet-Objekt.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:getStyle"><apiName>getStyle</apiName><shortdesc> 
	 Gibt eine Kopie des Stilobjekts zurück, das mit dem Stil „styleName“ verknüpft ist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyle, getStyle
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Objekt.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String, der den Namen des abzurufenden Stils angibt.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc> 
	 Gibt eine Kopie des Stilobjekts zurück, das mit dem Stil <codeph>styleName</codeph> verknüpft ist. Wenn kein Stilobjekt mit <codeph>styleName</codeph> verknüpft ist, wird <codeph>null</codeph> zurückgegeben.
	 
	 </apiDesc><example>Die Verwendung der Methode <xref href="StyleSheet.html#parseCSS()">getStyle()</xref> wird im Beispiel für die <xref href="StyleSheet.html#transform()">parseCSS()</xref>- oder <codeph>transform()</codeph>-Methode veranschaulicht. 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#StyleSheet/setStyle()"><linktext>flash.text.StyleSheet.setStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:StyleSheet:parseCSS"><apiName>parseCSS</apiName><shortdesc>
	 Parst die CSS-Datei in CSSText und lädt gleichzeitig das Stylesheet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.parseCSS, parseCSS
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>CSSText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Der zu parsende CSS-Text (ein String).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Liest die CSS-Datei in cssText ein und lädt gleichzeitig das Stylesheet.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Parst die CSS-Datei in <codeph>CSSText</codeph> und lädt gleichzeitig das Stylesheet. Wenn sich ein Stil in <codeph>CSSText</codeph> bereits im <codeph>styleSheet</codeph>-Objekt befindet, behält dieses seine <codeph>styleSheet</codeph>-Eigenschaften bei, und nur die Eigenschaften in <codeph>CSSText</codeph> werden dem <codeph>styleSheet</codeph> hinzugefügt oder geändert.
	 
	 <p>Wenn Sie die native CSS-Parsingfähigkeit erweitern möchten, können Sie diese Methode übersteuern, indem Sie eine Unterklasse der StyleSheet-Klasse erstellen.</p>
	 
	 </apiDesc><example conref="examples\StyleSheet_parseCSSExample.as"> Im folgenden Beispiel werden beim Klicken auf das Textfeld aus einer Datei geladene CSS-Stile auf den Inhalt angewendet.
 
 <p>Im Konstruktor wird ein mehrzeiliges Textfeld erstellt, und der Inhalt wird auf einen HTML-formatierten String festgelegt. (Die HTML-Tags „heading“ und „span“ werden nicht dargestellt, bevor der CSS-Stil angewendet wird.) Es wird ein <codeph>URLRequest</codeph>-Objekt erstellt, um den Speicherort der CSS-Datei anzugeben. In diesem Beispiel befindet sie sich im selben Verzeichnis wie die SWF-Datei. Die Datei wird mit einem <codeph>URLLoader</codeph>-Objekt geladen. Zwei Ereignis-Listener werden für das URLLoader-Objekt <codeph>loader</codeph> hinzugefügt. Wenn ein IO-Fehler auftritt, wird die <codeph>errorHandler()</codeph>-Methode aufgerufen, die eine Fehlermeldung im Textfeld anzeigt. Nachdem alle Daten empfangen und in der Dateneigenschaft des <codeph>loader</codeph>-Objekts URLLoader platziert wurden, wird die <codeph>loaderCompleteHandler()</codeph>-Methode aufgerufen. Diese Methode parst dann die CSS-Stile aus den aus der Datei geladenen Daten und füllt das StyleSheet-Objekt <codeph>sheet</codeph> mit den Stildefinitionen.</p>
 
 <p>Wenn der Benutzer auf das Textfeld klickt, wird die <codeph>clickHandler()</codeph>-Methode aufgerufen. Mit der if-Anweisung in der <codeph>clickHandler()</codeph>-Methode wird überprüft, ob der Dateiladevorgang abgeschlossen wurde, bevor das Stylesheet auf das Textfeld angewendet wird. Damit das Stylesheet wirksam wird, muss die <codeph>htmlText</codeph>-Eigenschaft dem Inhalt neu zugewiesen werden, nachdem das Stylesheet dem Textfeld zugewiesen wurde. Die Werte der CSS-Eigenschaft <codeph>font-family</codeph> und der <codeph>color</codeph>-Eigenschaft für das Heading-Tag werden ebenfalls dem Inhalt des Textfelds angehängt. (Die Werte dieser Eigenschaften sind „undefined“, wenn keine Stylesheet-Werte wirksam sind.)</p> 
 
 <p>Nachstehend finden Sie ein Beispiel für Inhalt einer CSS-Datei, die mit diesem Beispiel verwendet werden kann. Bevor Sie dieses Beispiel ausführen, erstellen Sie eine Textdatei, kopieren Sie den nachstehenden CSS-Inhalt in diese Datei, speichern Sie sie unter dem Dateinamen <codeph>test.css</codeph> und legen Sie sie im selben Verzeichnis wie die SWF-Datei ab.</p>
 
 <pre>
   p {
      font-family: Times New Roman, Times, _serif;
      font-size: 14;
       font-Style: italic;
        margin-left: 10;  
   }
   h1 {
      font-family: Arial, Helvetica, _sans;
      font-size: 20;
      font-weight: bold;
   }
   .bluetext {
      color: #0000CC;
   }
 </pre>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class StyleSheet_parseCSSExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var field:TextField = new TextField();
        private var exampleText:String = "&lt;h1>This is a headline&lt;/h1>"
                    + "&lt;p>This is a line of text. &lt;span class='bluetext'>" 
                    + "This line of text is colored blue.&lt;/span>&lt;/p>";
        private var sheet:StyleSheet = new StyleSheet();
        private var cssReady:Boolean = false;

        public function StyleSheet_parseCSSExample() {
            field.x = 10;
            field.y = 10;
            field.background = true;
            field.multiline = true;
            field.autoSize = TextFieldAutoSize.LEFT;
            field.htmlText = exampleText;

            field.addEventListener(MouseEvent.CLICK, clickHandler);
            
            addChild(field);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            field.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            sheet.parseCSS(loader.data);
            cssReady = true;
        }

        public function clickHandler(e:MouseEvent):void {

            if (cssReady) {
                field.styleSheet = sheet;
                field.htmlText = exampleText;
                
                var style:Object = sheet.getStyle("h1");
                field.htmlText += "&lt;p>Headline font-family is: " + style.fontFamily + "&lt;/p>";
                field.htmlText += "&lt;p>Headline color is: " + style.color + "&lt;/p>";  

            } else {
                field.htmlText = "Couldn't apply the CSS styles.";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:setStyle"><apiName>setStyle</apiName><shortdesc>
	 Fügt dem StyleSheet-Objekt einen neuen Stil mit dem angegebenen Namen hinzu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example adds a style named <code>emphasized</code> to the 
	 StyleSheet <code>myStyleSheet</code>. The style includes two style properties: <code>color</code> 
	 and <code>fontWeight</code>. The style object is defined with the <code>{}</code> operator.
	 <pre><code>
	 myStyleSheet.setStyle("emphasized", {color:'#000000',fontWeight:'bold'});
	 </code></pre>
	 
	 <p>You could also create a style object using an instance of the Object class, and 
	 then pass that object (<code>styleObj</code>) as 
	 the <code>style</code> parameter, as the next example shows:</p>
	 <listing version="2.0">
	 import TextField.StyleSheet;
	 var my_styleSheet:StyleSheet = new StyleSheet();
	 
	 var styleObj:Object = new Object();
	 styleObj.color = "#000000";
	 styleObj.fontWeight = "bold";
	 my_styleSheet.setStyle("emphasized", styleObj);
	 delete styleObj;
	 
	 var styleNames_array:Array = my_styleSheet.getStyleNames();
	 for (var i=0;i&lt;styleNames_array.length;i++) {
	 	var styleName:String = styleNames_array[i];
	 	var thisStyle:Object = my_styleSheet.getStyle(styleName);
	 	trace(styleName);
	 	for (var prop in thisStyle) {
	 		trace("\t"+prop+": "+thisStyle[prop]);
	 	}
	 	trace("");
	 }
	 </listing>
	 <p><span class="flashonly">The following information appears in the Output 
	 panel:</span><span class="flexonly">The following information writes to the 
	 log file:</span></p>
	 <pre><code>
	 emphasized
	   fontWeight: bold
	   color: #000000
	 </code></pre>
	 
	 <p><strong>Note: </strong>Because Flash Player creates a copy of the style object
	 you pass to <code>setStyle()</code>, the <code> delete styleObj</code> command in the 
	 code example reduces memory usage by deleting the original style object passed to 
	 <code>setStyle()</code>.</p>
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ein String, der den Namen des Stils angibt, der dem Stylesheet hinzugefügt werden soll.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>styleObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein Objekt, das den Stil beschreibt (oder <codeph>null</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Fügt dem StyleSheet-Objekt einen neuen Stil mit dem angegebenen Namen hinzu. Der benannte Stil wird hinzugefügt, wenn er nicht bereits im Stylesheet vorhanden ist. Der benannte Stil wird ersetzt, wenn er bereits im Stylesheet vorhanden ist. Wenn der <codeph>styleObject</codeph>-Parameter auf <codeph>null</codeph> gesetzt ist, wird der benannte Stil entfernt.
	 
	 <p>Flash Player erstellt eine Kopie des Stilobjekts, das dieser Methode übergeben wird.</p>
	 
	 <p>Eine Liste der unterstützten Stile finden Sie in der Tabelle zur Beschreibung der StyleSheet-Klasse.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:transform"><apiName>transform</apiName><shortdesc>
	 Erweitert die CSS-Parsingfähigkeit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.transform, transform
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein TextFormat-Objekt, das das Ergebnis der Zuordnung von CSS-Regeln zu Textformateigenschaften enthält.
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>formatObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Ein Objekt, das den Stil beschreibt und das Stilregeln als Objekteigenschaften (bzw. <codeph>null</codeph>) enthält.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Erweitert die CSS-Parsingfähigkeit. Erfahrene Entwickler können diese Methode durch Erweitern der StyleSheet-Klasse überschreiben. 
	 
	 </apiDesc><example conref="examples\StyleSheet_transformExample.as"> In diesem Beispiel wird mit der <codeph>transform()</codeph>-Methode ein Stil aus einer CSS-Datei auf ein TextFormat-Objekt für ein Textfeld angewendet.
 
 <p>CSS-Stile werden im Allgemeinen für die Formatierung von HTML-Inhalten verwendet. Mit der <codeph>transform()</codeph>-Methode eines StyleSheet-Objekts können bestimmte CSS-Stile jedoch einem TextFormat-Objekt zugewiesen und dann auf ein beliebiges Textfeld angewendet werden.</p> 
 
 <p>Die <codeph>URLRequest</codeph>- und <codeph>URLLoader</codeph>-Objekte werden zum Laden der CSS-Datei verwendet. Es wird ein Ereignis-Listener für das <codeph>Event.COMPLETE</codeph>-Ereignis hinzugefügt, das eintritt, nachdem alle Daten empfangen und in der data-Eigenschaft des URLLoader-Objekts <codeph>loader</codeph> platziert wurden. Die <codeph>loaderCompleteHandler()</codeph>-Methode parst dann den CSS aus den aus der Datei geladenen Daten und füllt das StyleSheet-Objekt <codeph>sheet</codeph> mit den Stilen. Die <codeph>getStyle()</codeph>-Methode des Stylesheets ruft die HTML-Absatzstile ab, die dann mit der <codeph>transform()</codeph>-Methode des Stylesheets dem TextFormat-Objekt <codeph>cssFormat</codeph> zugewiesen werden. Schließlich wird das Standardtextformat des Textfelds <codeph>inputField</codeph> auf das neue Textformat <codeph>cssFormat</codeph> gesetzt.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldType;
    import flash.events.IOErrorEvent;
    import flash.events.Event;

    public class StyleSheet_transformExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var inputField:TextField = new TextField();
        private var sheet:StyleSheet = new StyleSheet();

        public function StyleSheet_transformExample() {
            inputField.x = 10;
            inputField.y = 10;
            inputField.background = true;
            inputField.width = 300;
            inputField.height = 200;
            inputField.wordWrap = true;
            inputField.multiline = true;    
            inputField.type = TextFieldType.INPUT;

            addChild(inputField);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            inputField.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            var cssFormat:TextFormat = new TextFormat();
            sheet.parseCSS(loader.data);
            var style:Object = sheet.getStyle("p");
            cssFormat = sheet.transform(style);
            inputField.defaultTextFormat = cssFormat;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:StyleSheet:styleNames:get"><apiName>styleNames</apiName><shortdesc>
	 Ein Array, das die Namen aller in diesem Stylesheet registrierten Stile als Strings enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyleNames, getStyleNames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>Gibt die Namen aller in diesem Stylesheet registrierten Stile zurück.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ein Array, das die Namen aller in diesem Stylesheet registrierten Stile als Strings enthält.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextSnapshot"><apiName>TextSnapshot</apiName><shortdesc> 
 Mit TextSnapshot-Objekten können Sie mit statischem Text in einem Movieclip arbeiten.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Mit TextSnapshot-Objekten können Sie mit statischem Text in einem Movieclip arbeiten. Sie können die Objekte beispielsweise für ein präziseres Textlayout verwenden, als dies mit dynamischem Text möglich ist, jedoch weiterhin gewährleisten, dass der Text beim Zugriff schreibgeschützt ist.
 
 <p>Zum Erstellen eines TextSnapshot-Objekts ist kein Konstruktor erforderlich. Das Objekt wird von der Eigenschaft <codeph>flash.display.DisplayObjectContainer.textSnapshot</codeph> zurückgegeben.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/textSnapshot"><linktext>flash.display.DisplayObjectContainer.textSnapshot</linktext></link></related-links><apiOperation id="flash.text:TextSnapshot:findText"><apiName>findText</apiName><shortdesc>
	 Sucht nach dem angegebenen TextSnapshot-Objekt und gibt die Position des ersten Auftretens von „textToFind“ bei oder nach „beginIndex“ zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.findText, findText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Die auf null basierende Indexposition des ersten Vorkommens des angegebenen Texts (oder -1).
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Gibt den Startpunkt für die Suche nach dem angegebenen Text an.	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>textToFind</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Gibt den zu suchenden Text an. Wenn Sie ein Stringliteral statt einer Variable vom Typ „String“ angeben, setzen Sie Anführungszeichen um den String.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>caseSensitive</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Gibt an, ob der Text dem String aus <codeph>textToFind</codeph> in Groß- und Kleinschreibung entsprechen muss. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sucht nach dem angegebenen TextSnapshot-Objekt und gibt die Position des ersten Auftretens von <codeph>textToFind</codeph> bei oder nach <codeph>beginIndex</codeph> zurück. Wenn <codeph>textToFind</codeph> nicht gefunden wird, gibt die Methode <codeph>-1</codeph> zurück.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelected"><apiName>getSelected</apiName><shortdesc>
	 Gibt einen Booleschen Wert zurück, der angibt, ob ein TextSnapshot-Objekt ausgewählten Text im angegebenen Bereich enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelected, getSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein boolescher Wert, der angibt, ob mindestens ein Zeichen im Bereich von der jeweiligen <codeph>setSelected()</codeph>-Methode ausgewählt wurde (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>).
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Gibt die Position des ersten zu untersuchenden Zeichens an. Gültige Werte für <codeph>beginIndex</codeph> sind <codeph>0</codeph> bis <codeph>TextSnapshot.charCount - 1</codeph>. Ist <codeph>beginIndex</codeph> ein negativer Wert, wird <codeph>0</codeph> verwendet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Ein Wert, der gegenüber der Indexposition des letzten zu prüfenden Zeichens um eins erhöht wurde. Gültige Werte für <codeph>endIndex</codeph> sind <codeph>0</codeph> bis <codeph>charCount</codeph>. Das durch den Parameter <codeph>endIndex</codeph> indizierte Zeichen wird nicht in den extrahierten String aufgenommen. Wenn Sie diesen Parameter weglassen, wird <codeph>charCount</codeph> verwendet. Ist dieser Wert kleiner oder gleich dem Wert von <codeph>beginIndex</codeph>, wird <codeph>beginIndex + 1</codeph> verwendet.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen Booleschen Wert zurück, der angibt, ob ein TextSnapshot-Objekt ausgewählten Text im angegebenen Bereich enthält. 
	 
	 <p>Wenn Sie alle Zeichen durchsuchen möchten, übergeben Sie den Wert <codeph>0</codeph> für <codeph>start</codeph> und <codeph>charCount</codeph> (oder eine sehr große Zahl) für <codeph>end</codeph>. Wenn Sie nur ein Zeichen durchsuchen möchten, übergeben Sie für den Parameter <codeph>end</codeph> eine Zahl, die um eins größer ist als der Wert des Parameters <codeph>start</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelectedText"><apiName>getSelectedText</apiName><shortdesc>
	 Gibt einen String zurück, der alle von der entsprechenden setSelected()-Methode angegebenen Zeichen enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelectedText, getSelectedText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, der alle vom entsprechenden <codeph>setSelected()</codeph>-Befehl angegebenen Zeichen enthält.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein optionaler boolescher Wert, der festlegt, ob bei Bedarf Zeilenumbrüche in den Rückgabestring integriert werden. Der Standardwert ist <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen String zurück, der alle von der entsprechenden <codeph>setSelected()</codeph>-Methode angegebenen Zeichen enthält. Werden (von der <codeph>setSelected()</codeph>-Methode) keine Zeichen angegeben, wird ein leerer String zurückgegeben.
	 
	 <p>Wenn Sie <codeph>true</codeph> für <codeph>includeLineEndings</codeph> übergeben, werden in den Rückgabe-String Zeilenumbrüche integriert, sodass dieser länger als der Eingabebereich sein kann. Ist <codeph>includeLineEndings</codeph> <codeph>false</codeph> oder wird dieser Wert weggelassen, gibt die Methode den ausgewählten Text zurück, ohne Zeichen hinzuzufügen.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getSelected()"><linktext>flash.text.TextSnapshot.getSelected()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getText"><apiName>getText</apiName><shortdesc>
	 Gibt einen String zurück, der alle Zeichen enthält, die mit den Parametern „beginIndex“·und „endIndex“ angegeben werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getText, getText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein String, der die Zeichen des angegebenen Bereichs enthält, oder ein leerer String, wenn im angegebenen Bereich keine Zeichen gefunden wurden.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Gibt die Position des ersten Zeichens an, das in den Rückgabestring aufgenommen werden soll. Gültige Werte für <codeph>beginIndex</codeph> sind <codeph>0</codeph> bis <codeph>charCount - 1</codeph>. Ist <codeph>beginIndex</codeph> ein negativer Wert, wird <codeph>0</codeph> verwendet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Ein Wert, der gegenüber der Indexposition des letzten zu prüfenden Zeichens um eins erhöht wurde. Gültige Werte für <codeph>endIndex</codeph> sind <codeph>0</codeph> bis <codeph>charCount</codeph>. Das durch den Parameter <codeph>endIndex</codeph> indizierte Zeichen wird nicht in den extrahierten String aufgenommen. Wenn Sie diesen Parameter weglassen, wird <codeph>charCount</codeph> verwendet. Ist dieser Wert kleiner oder gleich dem Wert von <codeph>beginIndex</codeph>, wird <codeph>beginIndex + 1</codeph> verwendet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Ein optionaler boolescher Wert, der festlegt, ob bei Bedarf Zeilenumbrüche in den Rückgabestring integriert werden (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>). Der Standardwert ist <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt einen String zurück, der alle Zeichen enthält, die mit den Parametern <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> angegeben werden. Werden keine Zeichen ausgewählt, wird ein leerer String zurückgegeben. 
	 
	 <p>Wenn alle Zeichen zurückgegeben werden sollen, übergeben Sie den Wert <codeph>0</codeph> für <codeph>beginIndex</codeph> und <codeph> charCount</codeph> (oder eine sehr große Zahl) für <codeph>endIndex</codeph>. Um ein einzelnes Zeichen zurückzugeben, geben Sie den Wert <codeph>beginIndex + 1</codeph> für <codeph>endIndex</codeph> an. </p>
	 
	 <p>Wenn Sie den Wert <codeph>true</codeph> für <codeph>includeLineEndings</codeph> übergeben, werden bei Bedarf Zeilenumbrüche in den Rückgabestring eingefügt. In diesem Fall überschreitet der Rückgabestring unter Umständen den zulässigen Eingabebereich. Ist <codeph>includeLineEndings</codeph> <codeph>false</codeph> oder wird dieser Wert weggelassen, wird der ausgewählte Text ohne zusätzliche Zeichen zurückgegeben.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getTextRunInfo"><apiName>getTextRunInfo</apiName><shortdesc>
	 Gibt ein Array von Objekten zurück, das Informationen über eine Textreihe enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Ein Objekt-Array, in dem jedes Objekt Informationen zu einem bestimmten Zeichen im von den Parametern <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> angegebenen Bereich enthält. Jedes Objekt enthält die folgenden elf Eigenschaften:
	 <ul>
	 
	  	<li><codeph>indexInRun</codeph>: Ganzzahliger Index des Zeichens mit der Basis null. Dieser ist nicht relativ zur ausgewählten Textreihe, sondern zum gesamten String.</li>
	 
	  	<li><codeph>selected</codeph>: Ein boolescher Wert, der angibt, ob das Zeichen ausgewählt ist (<codeph>true</codeph>) oder nicht (<codeph>false</codeph>).</li>
	 
	  	<li><codeph>font</codeph>: Die Schriftart des Zeichens.</li>
	 
	  	<li><codeph>color</codeph>: Der kombinierte Alpha- und Farbwert des Zeichens. Die ersten beiden hexadezimalen Stellen stehen für den Alphawert, die übrigen für den Farbwert.</li>
	 
	  	<li><codeph>height</codeph>: Die Höhe des Zeichens in Pixel.</li>
	 
	  	<li><codeph>matrix_a</codeph>, <codeph>matrix_b</codeph>, <codeph>matrix_c</codeph>, <codeph>matrix_d</codeph>, <codeph>matrix_tx</codeph> und <codeph>matrix_ty</codeph>: Die Werte einer Matrix, die die geometrische Umwandlung des Zeichens definieren. In der Regel weist aufrechter Text eine Matrix in der Form <codeph>[1 0 0 1 x y]</codeph> auf. Hierbei stehen <codeph>x</codeph> und <codeph>y</codeph> für die Position des Zeichens im übergeordneten Movieclip (unabhängig von der Texthöhe). Die Matrix liegt im Koordinatensystem des übergeordneten Movieclips und umfasst keine Transformationen im Movieclip selbst (oder in dessen übergeordnetem Element). </li>
	 
	 	<li><codeph>corner0x</codeph>, <codeph>corner0y</codeph>, <codeph>corner1x</codeph>, <codeph>corner1y</codeph>, <codeph>corner2x</codeph>, <codeph>corner2y</codeph>, <codeph>corner3x</codeph> und <codeph>corner3y</codeph>: Die Ecken des Begrenzungsrahmens des Zeichens, basierend auf dem Koordinatensystem des übergeordneten Movieclips. Diese Werte stehen nur dann zur Verfügung, wenn die vom Zeichen verwendete Schrift in die SWF-Datei eingebettet ist.</li>
	 
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert des ersten Zeichens in einem Zeichenbereich eines TextSnapshot-Objekts.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Der Indexwert des letzten Zeichens in einem Zeichenbereich eines TextSnapshot-Objekts.
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt ein Array von Objekten zurück, das Informationen über eine Textreihe enthält. Jedes Objekt entspricht einem Zeichen in dem mit den zwei Methodenparametern angegebenen Zeichenbereich. 
	 
	 <p><b>Hinweis: </b> Bei Verwendung der <codeph>getTextRunInfo()</codeph>-Methode für einen großen Textbereich kann ein großes Objekt zurückgegeben werden. Adobe empfiehlt, den durch die Parameter <codeph>beginIndex</codeph> und <codeph>endIndex</codeph> definierten Textbereich zu begrenzen. </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>Matrix-Klasse</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:hitTestTextNearPos"><apiName>hitTestTextNearPos</apiName><shortdesc>
	 Hiermit können Sie bestimmen, welches Zeichen innerhalb eines TextSnapshot-Objekts sich nahe an oder auf den angegebenen x- und y-Koordinaten des Movieclips befindet, der den Text im TextSnapshot-Objekt enthält.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.hitTestTextNearPos, hitTestTextNearPos
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Eine Zahl, die für den Indexwert des Zeichens steht, das sich am nächsten an der angegebenen <codeph>x</codeph>- und <codeph>y</codeph>-Koordinate befindet. Gibt <codeph>-1</codeph> zurück, wenn kein Zeichen gefunden wurde oder die Schriftart keine metrischen Zeicheninformationen enthält.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die für die <codeph>x</codeph>-Koordinate des Movieclips mit dem Text steht.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Eine Zahl, die für die <codeph>y</codeph>-Koordinate des Movieclips mit dem Text steht.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>maxDistance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Eine optionale Zahl, die den maximalen Abstand von dem durch <codeph>x</codeph> und <codeph>y</codeph> definierten Punkt darstellt, an dem nach Text gesucht werden kann. Der Abstand wird vom Mittelpunkt der einzelnen Zeichen gemessen. Der Standardwert ist <codeph>0</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Damit können Sie bestimmen, welches Zeichen innerhalb eines TextSnapshot-Objekts sich nahe an oder auf den angegebenen <codeph>x</codeph>, <codeph>y</codeph>-Koordinaten des Movieclips befindet, der den Text im TextSnapshot-Objekt enthält.
	 
	 <p>Wenn Sie den Wert <codeph>0</codeph> für <codeph>maxDistance</codeph> übergeben oder diesen Parameter auslassen, muss sich der durch die <codeph>x</codeph>-, <codeph>y</codeph>-Koordinaten angegebene Ort innerhalb der Begrenzungsbox des TextSnapshot-Objekts befinden. 
	 </p>
	 
	 <p>Diese Methode funktioniert nur für Schriftarten ordnungsgemäß, die metrische Zeicheninformationen enthalten. Das Flash-Authoring-Tool nimmt diese Informationen für statische Textfelder jedoch standardmäßig nicht auf. <ph outputclass="flashonly">Aus diesem Grund kann die Methode an Stelle eines Indexwerts <codeph>-1</codeph> zurückgeben. Um die Rückgabe eines Indexwerts sicherzustellen, können Sie die Flash-Authoring-Anwendung zwingen, die metrischen Zeicheninformationen für eine Schriftart aufzunehmen. Dazu müssen Sie ein dynamisches Textfeld hinzufügen, das diese Schriftart verwendet, für dieses dynamische Textfeld „Zeichenoptionen“ auswählen und angeben, dass die Schriftkonturen für mindestens ein Zeichen eingebettet werden sollen. Es ist gleich, welche Zeichen Sie angeben; sie müssen nicht einmal in den fraglichen statischen Textfeldern verwendet werden.</ph></p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/x"><linktext>flash.display.DisplayObject.x</linktext></link><link href="flash.display.xml#DisplayObject/y"><linktext>flash.display.DisplayObject.y</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelectColor"><apiName>setSelectColor</apiName><shortdesc>
	 Gibt die zu verwendende Farbe zum Hervorheben von Zeichen an, die mit der Methode „setSelected()“ ausgewählt wurden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelectColor, setSelectColor
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>hexColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFF00</apiData><apiDesc>Die Farbe für die Begrenzungen um Zeichen, die mit dem entsprechenden <codeph>setSelected()</codeph>-Befehl ausgewählt wurden. Die Farbe wird im Hexadezimalformat (0x<i>RRGGBB</i>) angegeben.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt die zu verwendende Farbe zum Hervorheben von Zeichen an, die mit der Methode <codeph>setSelected()</codeph> ausgewählt wurden. Die Farbe ist immer undurchsichtig; Sie können keinen Transparenzwert festlegen.
	 
	 <p>Diese Methode funktioniert nur für Schriftarten ordnungsgemäß, die metrische Zeicheninformationen enthalten. Das Flash-Authoring-Tool nimmt diese Informationen für statische Textfelder jedoch standardmäßig nicht auf. Aus diesem Grund kann die Methode an Stelle eines Indexwerts <codeph>-1</codeph> zurückgeben.<ph outputclass="flashonly"> Um die Rückgabe eines Indexwerts sicherzustellen, können Sie die Flash-Authoring-Anwendung zwingen, die metrischen Zeicheninformationen für eine Schriftart aufzunehmen. Dazu müssen Sie ein dynamisches Textfeld hinzufügen, das diese Schriftart verwendet, für dieses dynamische Textfeld „Zeichenoptionen“ auswählen und angeben, dass die Schriftkonturen für mindestens ein Zeichen eingebettet werden sollen. Es ist gleich, welche Zeichen Sie angeben; sie müssen nicht einmal in den fraglichen statischen Textfeldern verwendet werden.</ph></p>	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelected"><apiName>setSelected</apiName><shortdesc>
	 Gibt eine Reihe von Zeichen in einem TextSnapshot-Objekt an, die ausgewählt werden sollen bzw. deren Auswahl aufgehoben werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelected, setSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Gibt die Position des ersten auszuwählenden Zeichens an. Gültige Werte für <codeph>beginIndex</codeph> sind <codeph>0</codeph> bis <codeph>charCount - 1</codeph>. Ist <codeph>beginIndex</codeph> ein negativer Wert, wird <codeph>0</codeph> verwendet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Eine Ganzzahl, die um 1 größer ist als der Index des letzten zu prüfenden Zeichens. Gültige Werte für <codeph>end</codeph> sind <codeph>0</codeph> bis <codeph>charCount</codeph>. Das durch den Parameter <codeph>end</codeph> indizierte Zeichen wird nicht in den extrahierten String aufgenommen. Wenn Sie diesen Parameter weglassen, wird <codeph>TextSnapshot.charCount</codeph> verwendet. Ist der Wert von <codeph>beginIndex</codeph> kleiner oder gleich dem Wert von <codeph>endIndex</codeph>, wird <codeph>beginIndex + 1</codeph> verwendet.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>select</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Ein boolescher Wert, der angibt, ob der Text ausgewählt werden soll (<codeph>true</codeph>) oder ob die Textauswahl aufgehoben werden soll (<codeph>false</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Gibt eine Reihe von Zeichen in einem TextSnapshot-Objekt an, die ausgewählt werden sollen bzw. deren Auswahl aufgehoben werden soll. Ausgewählte Zeichen werden mit einem farbigen Rechteck hinterlegt dargestellt, das der Begrenzungsbox des Zeichens entspricht. Die Farbe der Begrenzungsbox wird von <codeph>setSelectColor()</codeph> definiert.
	 
	 <p>Wenn Sie alle Zeichen auswählen oder die Auswahl für alle Zeichen aufheben möchten, übergeben Sie den Wert <codeph>0</codeph> für <codeph>beginIndex</codeph> und <codeph>charCount</codeph> (oder eine sehr große Zahl) für <codeph>endIndex</codeph>. Um ein einzelnes Zeichen anzugeben, geben Sie den Wert <codeph>start + 1</codeph> für <codeph>endIndex</codeph> an. </p>
	 
	 <p>Da Zeichen individuell als ausgewählt markiert sind, können Sie diese Methode mehrfach aufrufen, um mehrere Zeichen auszuwählen; d. h., durch Verwendung dieser Methode wird die Auswahl anderer Zeichen, die durch diesen Befehl gesetzt wurden, nicht aufgehoben.</p>
	 
	 <p>Das farbige Rechteck, mit dem eine Auswahl markiert ist, wird nur für Schriftarten angezeigt, die metrische Zeicheninformationen enthalten. Flash nimmt diese Informationen für statische Textfelder standardmäßig nicht auf. In einigen Fällen bedeutet dieses Verhalten, dass ausgewählter Text nicht als ausgewählt auf dem Bildschirm angezeigt wird.<ph outputclass="flashonly"> Um sicherzustellen, dass ausgewählter Text auch ausgewählt angezeigt wird, können Sie die Flash-Authoring-Anwendung zwingen, die Flash-Authoring-Anwendung für eine Schriftart aufzunehmen. Dazu müssen Sie ein dynamisches Textfeld hinzufügen, das diese Schriftart verwendet, für dieses dynamische Textfeld „Zeichenoptionen“ auswählen und angeben, dass die Schriftkonturen für mindestens ein Zeichen eingebettet werden sollen. Es spielt keine Rolle, welche Zeichen Sie angeben; sie müssen nicht einmal in den fraglichen statischen Textfeldern verwendet werden.</ph></p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/setSelectColor()"><linktext>flash.text.TextSnapshot.setSelectColor()</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextSnapshot:charCount:get"><apiName>charCount</apiName><shortdesc>
	 Gibt die Zeichenanzahl in einem TextSnapshot-Objekt zurück.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.charCount, charCount, count
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Gibt die Zeichenanzahl in einem TextSnapshot-Objekt zurück.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldAutoSize"><apiName>TextFieldAutoSize</apiName><shortdesc>
Die TextFieldAutoSize-Klasse ist eine Zusammenfassung von Konstantenwerten, die zur Einstellung der Eigenschaft „autoSize“ in der TextField-Klasse verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die TextFieldAutoSize-Klasse ist eine Zusammenfassung von Konstantenwerten, die zur Einstellung der Eigenschaft <codeph>autoSize</codeph> in der TextField-Klasse verwendet werden. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link></related-links><apiValue id="flash.text:TextFieldAutoSize:CENTER"><apiName>CENTER</apiName><shortdesc> 
	Gibt an, dass der Text als zentriert ausgerichteter Text behandelt werden soll.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Gibt an, dass der Text als zentriert ausgerichteter Text behandelt werden soll. Eine Größenänderungen in einem einzeiligen Textfeld wird gleichmäßig auf den rechten und linken Rand verteilt. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:LEFT"><apiName>LEFT</apiName><shortdesc> 
	Gibt an, dass der Text als linksbündiger Text behandelt werden soll, d. h., die linke Seite des Textfelds bleibt fixiert, und Größenänderungen eines einzeiligen Textfelds werden auf der rechten Seite vorgenommen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Gibt an, dass der Text als linksbündiger Text behandelt werden soll, d. h., die linke Seite des Textfelds bleibt fixiert, und Größenänderungen eines einzeiligen Textfelds werden auf der rechten Seite vorgenommen. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:NONE"><apiName>NONE</apiName><shortdesc> 
	
	Gibt an, dass keine Größenänderung erfolgt.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	
	Gibt an, dass keine Größenänderung erfolgt.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:RIGHT"><apiName>RIGHT</apiName><shortdesc> 
	Gibt an, dass der Text als rechtsbündiger Text behandelt werden soll, d. h., die rechte Seite des Textfelds bleibt fixiert, und Größenänderungen eines einzeiligen Textfelds werden auf der linken Seite vorgenommen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Gibt an, dass der Text als rechtsbündiger Text behandelt werden soll, d. h., die rechte Seite des Textfelds bleibt fixiert, und Größenänderungen eines einzeiligen Textfelds werden auf der linken Seite vorgenommen. 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:FontStyle"><apiName>FontStyle</apiName><shortdesc>
Die FontStyle-Klasse enthält Werte für die TextRenderer-Klasse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die FontStyle-Klasse enthält Werte für die TextRenderer-Klasse.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:FontStyle:BOLD"><apiName>BOLD</apiName><shortdesc>
    Definiert den Fettstil einer Schriftart für den Parameter „fontStyle“ in der Methode „setAdvancedAntiAliasingTable()“.</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bold</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Definiert den Fettstil einer Schriftart für den Parameter <codeph>fontStyle</codeph> in der Methode <codeph>setAdvancedAntiAliasingTable()</codeph>. Verwenden Sie die Syntax <codeph>FontStyle.BOLD</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:BOLD_ITALIC"><apiName>BOLD_ITALIC</apiName><shortdesc>
    Definiert den Fett- und Kursivstil einer Schriftart für den Parameter „fontStyle“ in der Methode „setAdvancedAntiAliasingTable()“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>boldItalic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Definiert den Fett- und Kursivstil einer Schriftart für den Parameter <codeph>fontStyle</codeph> in der Methode <codeph>setAdvancedAntiAliasingTable()</codeph>. Verwenden Sie die Syntax <codeph>FontStyle.BOLD_ITALIC</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:ITALIC"><apiName>ITALIC</apiName><shortdesc>
    Definiert den Kursivstil einer Schriftart für den Parameter „fontStyle“ in der Methode „setAdvancedAntiAliasingTable()“.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>italic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Definiert den Kursivstil einer Schriftart für den Parameter <codeph>fontStyle</codeph> in der Methode <codeph>setAdvancedAntiAliasingTable()</codeph>. Verwenden Sie die Syntax <codeph>FontStyle.ITALIC</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:REGULAR"><apiName>REGULAR</apiName><shortdesc>
    Definiert den Normalstil einer Schriftart für den Parameter „fontStyle“ in der Methode „setAdvancedAntiAliasingTable()“.</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>regular</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Definiert den Normalstil einer Schriftart für den Parameter <codeph>fontStyle</codeph> in der Methode <codeph>setAdvancedAntiAliasingTable()</codeph>. Verwenden Sie die Syntax <codeph>FontStyle.REGULAR</codeph>. 
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldType"><apiName>TextFieldType</apiName><shortdesc>
Die TextFieldType-Klasse ist eine Zusammenfassung von Konstantenwerten, die zur Einstellung der Eigenschaft „type“ in der TextField-Klasse verwendet werden.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Die TextFieldType-Klasse ist eine Zusammenfassung von Konstantenwerten, die zur Einstellung der Eigenschaft <codeph>type</codeph> in der TextField-Klasse verwendet werden. 


</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/type"><linktext>flash.text.TextField.type</linktext></link></related-links><apiValue id="flash.text:TextFieldType:DYNAMIC"><apiName>DYNAMIC</apiName><shortdesc> 
	Wird zur Angabe eines TextField-Objekts vom Typ „dynamic“ verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dynamic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Wird zur Angabe eines TextField-Objekts vom Typ <codeph>dynamic</codeph> verwendet. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldType:INPUT"><apiName>INPUT</apiName><shortdesc> 
	Wird zur Angabe eines TextField-Objekts vom Typ „input“·verwendet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>input</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Wird zur Angabe eines TextField-Objekts vom Typ <codeph>input</codeph> verwendet. 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>