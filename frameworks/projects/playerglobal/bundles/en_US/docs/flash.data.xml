 
<apiPackage id="flash.data"><apiName>flash.data</apiName><apiDetail/><apiClassifier id="flash.data:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
 A SQLViewSchema instance provides information describing a specific view
 in a database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLTableSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 A SQLViewSchema instance provides information describing a specific view
 in a database.
 
 It contains the name of the view (the <codeph>name</codeph> property), the
 SQL statement used to create the view (the <codeph>sql</codeph> property), and
 information about the view's columns (the <codeph>columns</codeph> property).
 
 <p>To obtain view schema information for a database, use the
 <codeph>SQLConnection.loadSchema()</codeph> method to load the schema information, making certain to
 use <codeph>null</codeph> or <codeph>SQLViewSchema</codeph> for the <codeph>type</codeph> argument's value.
 In the resulting SQLSchemaResult instance, the <codeph>views</codeph> property contains an array
 of SQLViewSchema instances representing the views in the database.</p>
 
 <p>Generally, developer code does not construct SQLViewSchema instances directly.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLViewSchema:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
     Creates a SQLViewSchema instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the associated database.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the view.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The SQL statement used to create the view.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Array of SQLColumnSchema instances describing this view's columns.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a SQLViewSchema instance. Generally, developer code does not call the SQLViewSchema
     constructor directly. To obtain schema information for a database, call the
	 <codeph>SQLConnection.loadSchema()</codeph> method.
     
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.data:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
 The SQLColumnSchema class provides information describing the characteristics of a specific column
 within a table in a database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The SQLColumnSchema class provides information describing the characteristics of a specific column
 within a table in a database.
 
 <p>To obtain column schema information for one or more tables in a database, use the
 <codeph>SQLConnection.loadSchema()</codeph> method to load the schema information, making certain to
 use <codeph>true</codeph> for the <codeph>includeColumnSchema</codeph> argument's value. In the resulting
 SQLSchemaResult instance, each table and view definition includes a <codeph>columns</codeph>
 property â€” an array of SQLColumnSchema instances representing the columns in the
 table or view.</p>
 
 <p>Generally, developer code does not construct SQLColumnSchema instances directly.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLColumnSchema:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
     Constructs a SQLColumnSchema instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the column.
     
     </apiDesc></apiParam><apiParam><apiItemName>primaryKey</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Indicates whether this column is a part of the primary
     key for the associated table.
     
     </apiDesc></apiParam><apiParam><apiItemName>allowNull</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Indicates whether this column can contain <codeph>NULL</codeph> values.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoIncrement</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Indicates whether this is an auto increment column.
     
     </apiDesc></apiParam><apiParam><apiItemName>dataType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The declared type of the column.
     
     </apiDesc></apiParam><apiParam><apiItemName>defaultCollationType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The collation sequence defined for this column.
     This value corresponds to one of the constants in the SQLCollationType class:
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> indicates that the column uses the
	 			<codeph>BINARY</codeph> collation sequence.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> indicates that the column uses the <codeph>NOCASE</codeph>
	 			collation sequence, meaning text comparisons are made in a case-insensitive manner.</li>
     </ul>
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Constructs a SQLColumnSchema instance. Generally, developer code does not call the SQLColumnSchema
     constructor directly. To obtain schema information for a database, call the
	 <codeph>SQLConnection.loadSchema()</codeph> method.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLColumnSchema:allowNull:get"><apiName>allowNull</apiName><shortdesc>
     Indicates whether NULL values are allowed in this column.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indicates whether <codeph>NULL</codeph> values are allowed in this column. A column
     that is declared with a <codeph>NOT NULL</codeph> constraint has a <codeph>false</codeph>
	 value for the <codeph>allowNull</codeph> property.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:autoIncrement:get"><apiName>autoIncrement</apiName><shortdesc>
     Indicates whether this is an auto-increment column.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indicates whether this is an auto-increment column. An auto-increment column is a special type
	 of <codeph>PRIMARY KEY</codeph> column whose value is automatically generated as the next value
	 in a sequence of integers when a new row is inserted into the table.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:dataType:get"><apiName>dataType</apiName><shortdesc>
     Gets the data type of the column as a string.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gets the data type of the column as a string. The value is the literal data type name that was
	 specified in the <codeph>CREATE TABLE</codeph> statement that was used to define the table, or
	 <codeph>null</codeph> if no data type was specified.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:defaultCollationType:get"><apiName>defaultCollationType</apiName><shortdesc>
     Indicates the default collation sequence that is defined for this column.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the default collation sequence that is defined for this column.
	 The value of this property corresponds to one of the constants in the SQLCollationType class:
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> indicates that the column uses the
	 			<codeph>BINARY</codeph> collation sequence.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> indicates that the column uses the <codeph>NOCASE</codeph>
	 			collation sequence, meaning that text comparisons are made in a case-insensitive manner.</li>
     </ul>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnSchema:name:get"><apiName>name</apiName><shortdesc>
     Gets the name of the column.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Gets the name of the column.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:primaryKey:get"><apiName>primaryKey</apiName><shortdesc>
     Indicates whether this column is the primary key column (or one of the primary key columns
	 in a composite key) for its associated table.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indicates whether this column is the primary key column (or one of the primary key columns
	 in a composite key) for its associated table.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLColumnNameStyle"><apiName>SQLColumnNameStyle</apiName><shortdesc>
 This class contains the constants that represent the possible values for the
 SQLConnection.columnNameStyle property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 This class contains the constants that represent the possible values for the
 <codeph>SQLConnection.columnNameStyle</codeph> property. These values indicate
 different options that control how column names (property names) are formatted in the objects
 returned as a result of a SQL <codeph>SELECT</codeph> statement.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links><apiValue id="flash.data:SQLColumnNameStyle:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
     Indicates that column names returned from a SELECT statement
	 use the default format.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indicates that column names returned from a <codeph>SELECT</codeph> statement
	 use the default format. In the default format, column names have the form
     <codeph>[table-name]_[column-name]</codeph> when multiple tables are
	 included in the <codeph>SELECT</codeph> statement, or <codeph>[column-name]</codeph> when
	 the <codeph>SELECT</codeph> statement includes a single table.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:LONG"><apiName>LONG</apiName><shortdesc>
     Indicates that column names returned from a SELECT statement use
	 long-column-name format.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>long</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indicates that column names returned from a <codeph>SELECT</codeph> statement use
	 long-column-name format. In this format, column names use the form
	 <codeph>[table-name]_[column-name]</codeph> regardless of how many
	 tables are included in the <codeph>SELECT</codeph> statement.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:SHORT"><apiName>SHORT</apiName><shortdesc>
     Indicates that column names returned from a SELECT statement use short-column-name
	 format.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>short</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indicates that column names returned from a <codeph>SELECT</codeph> statement use short-column-name
	 format. In this format, column names use the form <codeph>[column-name]</codeph>,
	 regardless of how many tables are included in the <codeph>SELECT</codeph> statement.
	 
	 <p>If the result set contains multiple columns with the same name, only one property with that
	 name is added to the result object. The value assigned to that property is taken from the last
	 column with that name in the result row. For example, consider the following <codeph>SELECT</codeph>
	 statement:</p>
	 
	 <pre>
	 SELECT customers.customerId, addresses.customerId
	 FROM customers INNER JOIN addresses
	    ON customers.customerId = addresses.customerId
	 </pre>
	 
	 <p>When this statement is executed on a SQLConnection instance with short column name format,
	 each result object has a property named <codeph>customerId</codeph>, containing the
	 value from the <codeph>addresses</codeph> table's <codeph>customerId</codeph> column.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
 The SQLSchema class is the base class for schema information for database objects
 such as tables, views, and indices.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The SQLSchema class is the base class for schema information for database objects
 such as tables, views, and indices.
 
 <p>To obtain schema information for a database, use the
 <codeph>SQLConnection.loadSchema()</codeph> method to load the schema information.
 The resulting SQLSchemaResult instance contains arrays of instances representing the objects
 in the database.</p>
 
 <p>Generally, developer code does not construct SQLSchema instances directly.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchema:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
     Creates a SQLSchema instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the associated database.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the database object.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The SQL used to construct the database
     object.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a SQLSchema instance. Generally, developer code does not call the SQLSchema
     constructor directly. To obtain schema information for a database, call the
	 <codeph>SQLConnection.loadSchema()</codeph> method.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLSchema:database:get"><apiName>database</apiName><shortdesc>
     The name of the database to which this schema object belongs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     The name of the database to which this schema object belongs. The name is "main" for the main
	 database associated with a SQLConnection instance (the database file that is
	 opened by calling a SQLConnection instance's <codeph>open()</codeph> or <codeph>openAsync()</codeph> method). For other
	 databases that are attached to the connection using the
	 <codeph>SQLConnection.attach()</codeph> method, the value is the name specified in the <codeph>attach()</codeph>
     method call.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>flash.data.SQLConnection.attach()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchema:name:get"><apiName>name</apiName><shortdesc>
     The name of this schema object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     The name of this schema object. Each object within a
     database has a unique name. The name is defined in the SQL statement that creates the object
	 (such as the <codeph>CREATE TABLE</codeph> statement for a table).
	 
	 <p>For example, if a database index is created using the following SQL statement, the value of the
	 <codeph>name</codeph> property for that index's schema would be <codeph>"customer_index"</codeph>:</p>
	 
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLSchema:sql:get"><apiName>sql</apiName><shortdesc>
     Returns the entire text of the SQL statement that was used to create this schema object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Returns the entire text of the SQL statement that was used to create this schema object.
	 Each object within a database is created using a SQL statement.
	 
	 <p>For example, if a database index is created using the following SQL:</p>
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
	 <p>the <codeph>sql</codeph> property for that index's schema would be the entire text of
	 the statement.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLCollationType"><apiName>SQLCollationType</apiName><shortdesc>
 This class contains the constants that represent the possible values for the
 defaultCollationType parameter of the SQLColumnSchema constructor, as well as the
 SQLColumnSchema.defaultCollationType property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 This class contains the constants that represent the possible values for the
 <codeph>defaultCollationType</codeph> parameter of the SQLColumnSchema constructor, as well as the
 <codeph>SQLColumnSchema.defaultCollationType</codeph> property.
 
 <p>These values represent different collation sequences that can be specified for a column
 in a database table. A <i>collation sequence</i> is a way of sorting and comparing data,
 for example whether the database differentiates between uppercase and lowercase characters.</p>
 
 <p>For more information about defining and using collation sequences, see the 
 "<xref href="../../localDatabaseSQLSupport.html#collate">COLLATE</xref>" section in the appendix
 "<xref href="../../localDatabaseSQLSupport.html">SQL support in local databases</xref>."</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links><apiValue id="flash.data:SQLCollationType:BINARY"><apiName>BINARY</apiName><shortdesc>
     Indicates that the column is defined to use the BINARY collation sequence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indicates that the column is defined to use the <codeph>BINARY</codeph> collation sequence.
     A <codeph>SQLCollationType.BINARY</codeph> collation compares two
     values using their byte values, regardless of the text encoding of the characters.
	 
	 <p>When binary collation is used with values of the <codeph>TEXT</codeph> storage class, the database
	 differentiates between uppercase and lowercase characters when sorting and comparing the column's
	 values.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLCollationType:NO_CASE"><apiName>NO_CASE</apiName><shortdesc>
     Indicates that the column is defined to use the NOCASE collation sequence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noCase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indicates that the column is defined to use the <codeph>NOCASE</codeph> collation sequence.
     A <codeph>SQLCollationType.NO_CASE</codeph> collation ignores uppercase and lowercase differences
	 when sorting and comparing two values.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTransactionLockType"><apiName>SQLTransactionLockType</apiName><shortdesc>
 This class contains the constants that represent the possible values for the
 option parameter of the SQLConnection.begin() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 This class contains the constants that represent the possible values for the
 <codeph>option</codeph> parameter of the <codeph>SQLConnection.begin()</codeph> method.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links><apiValue id="flash.data:SQLTransactionLockType:DEFERRED"><apiName>DEFERRED</apiName><shortdesc>
     Specifies the deferred locking transaction option.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>deferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies the deferred locking transaction option.
     A deferred-lock transaction does not acquire a lock on the database
     until the database is first accessed. With a deferred
     transaction, a lock is not acquired until the first read or write
     operation.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:EXCLUSIVE"><apiName>EXCLUSIVE</apiName><shortdesc>
     Specifies the exclusive locking transaction option.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exclusive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies the exclusive locking transaction option.
	 An exclusive-locked transaction acquires a lock on the database immediately.
	 Other SQLStatement objects executing against the same database through a
	 different SQLConnection (in the same AIR application or a different one)
	 can't read data from or write data to the database.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:IMMEDIATE"><apiName>IMMEDIATE</apiName><shortdesc>
     Specifies the immediate locking transaction option.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>immediate</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies the immediate locking transaction option.
     An immediate-locked transaction acquires a lock on the database immediately.
	 SQLStatement objects executing against the same database through a
	 different SQLConnection (in the same AIR application or a different one)
	 can read data from the database but can't write data to it. However, for those 
	 other connections reading data from the database, the initial state of the data 
	 in the database is identical to the state of the database before the 
	 in-transaction SQLConnection instance's <codeph>begin()</codeph> method was called. 
	 Any uncommitted data changes made within the immediate-locked transaction are 
	 not available to the other connections.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
 A SQLSchemaResult instance contains the information resulting from a call to
 the SQLConnection.loadSchema() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 A SQLSchemaResult instance contains the information resulting from a call to
 the <codeph>SQLConnection.loadSchema()</codeph> method. It contains four Array properties
 that hold the requested schema data, based on the argument values
 used when calling <codeph>SQLConnection.loadSchema()</codeph>.
 
 <p>To retrieve the SQLSchemaResult instance for a <codeph>SQLConnection.loadSchema()</codeph>
 call, call the SQLConnection instance's <codeph>getSchemaResult()</codeph> method. Generally, developer
 code does not create SQLSchemaResult instances directly.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchemaResult:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
     Creates a SQLSchemaResult instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>tables</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of SQLTableSchema instances as specified in the <codeph>loadSchema()</codeph> request.
     
     </apiDesc></apiParam><apiParam><apiItemName>views</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of SQLViewSchema instances as specified in the <codeph>loadSchema()</codeph> request.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of SQLIndexSchema instances as specified in the <codeph>loadSchema()</codeph> request.
     
     </apiDesc></apiParam><apiParam><apiItemName>triggers</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of SQLTriggerSchema instances as specified in the <codeph>loadSchema()</codeph> request.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a SQLSchemaResult instance. Generally, developer code does not call the SQLSchemaResult
     constructor directly. To obtain schema information for a database, call the
	 <codeph>SQLConnection.loadSchema()</codeph> method.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLSchemaResult:indices:get"><apiName>indices</apiName><shortdesc>
     An array of SQLIndexSchema instances requested in a call
     to SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of SQLIndexSchema instances requested in a call
     to <codeph>SQLConnection.loadSchema()</codeph>. If the specified databases
	 do not contain any indices, or if the <codeph>loadSchema()</codeph> call
	 specifies to exclude indices from the result, the <codeph>indices</codeph>
	 property is an empty array (an array whose <codeph>length</codeph> property
	 is 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:tables:get"><apiName>tables</apiName><shortdesc>
     An array of SQLTableSchema instances requested in a call
     to SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of SQLTableSchema instances requested in a call
     to <codeph>SQLConnection.loadSchema()</codeph>. If the specified databases
	 do not contain any tables, or if the <codeph>loadSchema()</codeph> call
	 specifies to exclude tables from the result, the <codeph>tables</codeph>
	 property is an empty array (an array whose <codeph>length</codeph> property
	 is 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:triggers:get"><apiName>triggers</apiName><shortdesc>
     An array of SQLTriggerSchema instances requested in a call
     to SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of SQLTriggerSchema instances requested in a call
     to <codeph>SQLConnection.loadSchema()</codeph>. If the specified databases
	 do not contain any triggers, or if the <codeph>loadSchema()</codeph> call
	 specifies to exclude triggers from the result, the <codeph>triggers</codeph>
	 property is an empty array (an array whose <codeph>length</codeph> property
	 is 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:views:get"><apiName>views</apiName><shortdesc>
     An array of SQLViewSchema instances requested in a call
     to SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of SQLViewSchema instances requested in a call
     to <codeph>SQLConnection.loadSchema()</codeph>. If the specified databases
	 do not contain any views, or if the <codeph>loadSchema()</codeph> call
	 indicates that views should be excluded from the result, the <codeph>views</codeph>
	 property is an empty array (an array whose <codeph>length</codeph> property
	 is 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
 A SQLConnection instance is used to manage the creation of and connection to local SQL database files
 (local databases).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 A SQLConnection instance is used to manage the creation of and connection to local SQL database files
 (local databases).
 
 <p>The functionality of the SQLConnection class falls into several categories:</p>
 
 <ul>
   <li><p>A local SQL database file is created or opened by calling the <codeph>open()</codeph> method or the
   <codeph>openAsync()</codeph> method.
   If the database file does not exist, these methods can optionally create the
   database file while opening the connection.
   Once a connection is made to a database, a SQL statement can be created and executed
   against the database by creating a SQLStatement instance and assigning the
   SQLConnection instance to the SQLStatement's <codeph>sqlConnection</codeph> property.</p></li>
 
   <li><p>The SQLConnection class also provides state for SQL statements, including a
   mechanism for executing multiple statements in a transaction, using the <codeph>begin()</codeph>,
   <codeph>commit()</codeph>, and <codeph>rollback()</codeph> methods.</p></li>
 
   <li><p>The SQLConnection class provides access to database schema information for connected
   databases. A database's schema describes the definitions of its tables, columns, indices, and triggers.
   See the <codeph>loadSchema()</codeph> method for more information.</p></li>
 
   <li><p>The SQLConnection class provides the ability to encrypt databases using AES with CCM. This provides
   both authentication and privacy for data. To encrypt a database, a 16 byte key (specified using a 
   ByteArray) must be specified when the database is created. This key can later be changed
   using the <codeph>SQLConnection.reencrypt()</codeph> method. Encryption imposes a performance penalty on
   writes to and reads from the database. Encryption is applied to data stored on the disk, but not to a 
   temporary data cache in memory. Encryption is <i>not</i> supported for in-memory databases.</p></li>
 
   <li><p>A SQLConnection instance can be used to receive database-level
   event notifications and provide configuration control for
   all aspects of a database, including cache page size, process canceling, and statement execution
   options.</p></li>
 </ul>
 
 <p>A <codeph>SQLConnection</codeph> instance operates in one of two distinct execution modes: asynchronous
 and synchronous. To use synchronous execution, you use the <codeph>open()</codeph> method to connect to the
 main database for the SQLConnection instance. To use asynchronous execution, use the <codeph>openAsync()</codeph>
 method to connect to the main database for the instance.</p>
 
 <p>When you're using asynchronous execution, you use event listeners or a Responder instance to
 determine when an operation completes or fails. The operations run in the
 background rather than in the main application thread, so the application continues
 to run and respond to user interaction even while the database operations are being performed.</p>
 
 <p>In asynchronous execution mode, you begin a specific operation
 by calling the appropriate method, and you can detect the completion (or failure) of the operation
 by registering a listener for the appropriate event. Each operation has an associated event that
 is dispatched when the operation completes successfully; for example, when an <codeph>openAsync()</codeph>
 method call completes successfully (when the database connection is opened) the <codeph>open</codeph>
 event is dispatched. When any operation fails,
 an <codeph>error</codeph> event is dispatched. The SQLError instance in the SQLErrorEvent
 object's <codeph>error</codeph> property contains information about the specific error,
 including the operation that was being attempted and the reason the operation failed.</p>
 
 <p>When you're using synchronous execution, you do not need to register event
 listeners to determine when an operation completes or fails. To identify errors,
 enclose the error-throwing statements in a <codeph>try..catch</codeph> block. Because
 synchronous operations execute in the main execution thread, all application
 functionality (including refreshing the screen and allowing mouse and keyboard
 interaction) is paused while the database operation or operations are performed.
 For long-running operations this can cause a noticeable pause in the application.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link><link href="flash.events.xml#SQLEvent"><linktext>flash.events.SQLEvent</linktext></link><link href="flash.events.xml#SQLErrorEvent"><linktext>flash.events.SQLErrorEvent</linktext></link><link href="flash.errors.xml#SQLError"><linktext>flash.errors.SQLError</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_en"><linktext>Quick Start: Working asynchronously with a local SQL database (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_flash_en"><linktext>Quick Start: Working asynchronously with a local SQL database (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_html_en"><linktext>Quick Start: Working asynchronously with a local SQL database (HTML)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_en"><linktext>Quick Start: Working synchronously with a local SQL database (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_flash_en"><linktext>Quick Start: Working synchronously with a local SQL database (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_html_en"><linktext>Quick Start: Working synchronously with a local SQL database (HTML)</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.UPDATE_update"><apiName>update</apiName><shortdesc>
 Dispatched when data in any table in any of the connected databases changes as a result
 of a SQL UPDATE command.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.UPDATE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when data in any table in any of the connected databases changes as a result
 of a SQL <codeph>UPDATE</codeph> command. The data change can be a direct result of a <codeph>UPDATE</codeph>
 statement executed through a SQLStatement instance, or an indirect result caused by a trigger firing
 in response to a statement execution.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.SCHEMA_schema"><apiName>schema</apiName><shortdesc>
 Dispatched when a loadSchema() method call's operation completes
 successfully and the schema results are ready.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.SCHEMA</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>loadSchema()</codeph> method call's operation completes
 successfully and the schema results are ready.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ROLLBACK_rollback"><apiName>rollback</apiName><shortdesc>
 Dispatched when a rollback() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ROLLBACK</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>rollback()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.REENCRYPT_reencrypt"><apiName>reencrypt</apiName><shortdesc>
 Dispatched when a reencrypt() method call's operation completes
 successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.REENCRYPT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>reencrypt()</codeph> method call's operation completes
 successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/reencrypt()"><linktext>reencrypt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.OPEN_open"><apiName>open</apiName><shortdesc>
 Dispatched when an openAsync() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.OPEN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when an <codeph>openAsync()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.INSERT_insert"><apiName>insert</apiName><shortdesc>
 Dispatched when data in any table in any of the connected databases changes as a result
 of a SQL INSERT command.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.INSERT</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when data in any table in any of the connected databases changes as a result
 of a SQL <codeph>INSERT</codeph> command. The data change can be a direct result of an <codeph>INSERT</codeph>
 statement executed through a SQLStatement instance, or an indirect result caused by a trigger firing
 in response to a statement execution.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Dispatched when any of the SQLConnection object's asynchronous operations results
 in an error.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when any of the SQLConnection object's asynchronous operations results
 in an error. The SQLErrorEvent instance that's dispatched as the event object
 has an <codeph>error</codeph> property that contains information about the operation that
 was attempted and the cause of the failure.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DETACH_detach"><apiName>detach</apiName><shortdesc>
 Dispatched when a detach() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DETACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>detach()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.DELETE_delete"><apiName>delete</apiName><shortdesc>
 Dispatched when data in any table in any of the connected databases changes as a result
 of a SQL DELETE command.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.DELETE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when data in any table in any of the connected databases changes as a result
 of a SQL <codeph>DELETE</codeph> command. The data change can be a direct result of a <codeph>DELETE</codeph>
 statement executed through a SQLStatement instance, or an indirect result caused by a trigger firing
 in response to a statement execution.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DEANALYZE_deanalyze"><apiName>deanalyze</apiName><shortdesc>
 Dispatched when a deanalyze() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DEANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>deanalyze()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMMIT_commit"><apiName>commit</apiName><shortdesc>
 Dispatched when a commit() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMMIT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>commit()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CLOSE_close"><apiName>close</apiName><shortdesc>
 Dispatched when a close() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>close()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMPACT_compact"><apiName>compact</apiName><shortdesc>
 Dispatched when a compact() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMPACT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>compact()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/compact()"><linktext>compact()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Dispatched when a cancel() method call's operation completes
 successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>cancel()</codeph> method call's operation completes
 successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/cancel()"><linktext>cancel()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.BEGIN_begin"><apiName>begin</apiName><shortdesc>
 Dispatched when a begin() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.BEGIN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a <codeph>begin()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ATTACH_attach"><apiName>attach</apiName><shortdesc>
 Dispatched when an attach() method call's operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ATTACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when an <codeph>attach()</codeph> method call's operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ANALYZE_analyze"><apiName>analyze</apiName><shortdesc>
 Dispatched when an analyze() operation
 completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when an <codeph>analyze()</codeph> operation
 completes successfully.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLConnection:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
     Creates a SQLConnection instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>if constructor is called from any sandbox outside
     of the main application sandbox. 
      
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Creates a SQLConnection instance.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLConnection:addEventListener"><apiName>addEventListener</apiName><shortdesc>
     
	Registers an event listener object with an EventDispatcher object so that the listener 
	receives notification of an event.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The type of event.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>The listener function that processes the event. This function must accept
    an Event object as its only parameter and must return nothing<ph platform="actionscript">, as this example shows:</ph>
	<ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>The function can have any name.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">This parameter applies to display objects in the
	ActionScript 3.0 display list architecture, used by SWF content.</ph>
	
	<ph platform="actionscript">Determines whether the listener works in the capture phase or the 
	target and bubbling phases. If <codeph>useCapture</codeph> is set to <codeph>true</codeph>, 
	the listener processes the event only during the capture phase and not in the 
	target or bubbling phase. If <codeph>useCapture</codeph> is <codeph>false</codeph>, the
	listener processes the event only during the target or bubbling phase. To listen for
	the event in all three phases, call <codeph>addEventListener</codeph> twice, once with 
	<codeph>useCapture</codeph> set to <codeph>true</codeph>, then again with
	<codeph>useCapture</codeph> set to <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0.0</apiData><apiDesc>The priority level of the event listener. The priority is designated by
	a signed 32-bit integer. The higher the number, the higher the priority. All listeners
	with priority <i>n</i> are processed before listeners of priority <i>n</i>-1. If two
	or more listeners share the same priority, they are processed in the order in which they
	were added. The default priority is 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Determines whether the reference to the listener is strong or
	weak. A strong reference (the default) prevents your listener from being garbage-collected.
    A weak reference does not. <p>Class-level member functions are not subject to garbage 
    collection, so you can set <codeph>useWeakReference</codeph> to <codeph>true</codeph> for 
    class-level member functions without subjecting them to garbage collection. If you set
    <codeph>useWeakReference</codeph> to <codeph>true</codeph> for a listener that is a nested inner 
    function, the function will be garbage-collected and no longer persistent. If you create 
    references to the inner function (save it in another variable) then it is not 
    garbage-collected and stays persistent.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Registers an event listener object with an EventDispatcher object so that the listener 
	receives notification of an event. <ph platform="actionscript">You can register event listeners on all nodes in the 
	display list for a specific type of event, phase, and priority.</ph>
	
	<p platform="javascript">JavaScript code in the AIR runtime uses this method to register
	event listeners for events defined by the AIR APIs. For other JavaScript events (such as the <codeph>onload</codeph>
	event of the DOM <codeph>body</codeph> object), you can use standard event handling techniques, as you would 
	for content running in the browser.</p>
	
	<p>After you successfully register an event listener, you cannot change its priority
	through additional calls to <codeph>addEventListener()</codeph>. To change a listener's
	priority, you must first call <codeph>removeListener()</codeph>. Then you can register the
	listener again with the new priority level. </p>
	
	<p>Keep in mind that after the listener is registered, subsequent calls to
	<codeph>addEventListener()</codeph> with a different <codeph>type</codeph> or
	<codeph>useCapture</codeph> value result in the creation of a separate listener registration. 
	<ph platform="actionscript">For example, if you first register a listener with <codeph>useCapture</codeph> set to 
	<codeph>true</codeph>, it listens only during the capture phase. If you call 
	<codeph>addEventListener()</codeph> again using the same listener object, but with
	<codeph>useCapture</codeph> set to <codeph>false</codeph>, you have two separate listeners: one
	that listens during the capture phase and another that listens during the target and
	bubbling phases.</ph>
	</p>
	
	<p platform="actionscript">You cannot register an event listener for only the target phase or the bubbling 
	phase. Those phases are coupled during registration because bubbling 
	applies only to the ancestors of the target node.</p>
	
	<p>If you no longer need an event listener, remove it by calling 
	<codeph>removeEventListener()</codeph>, or memory problems could result. Event listeners are not automatically
	removed from memory because the garbage
	collector does not remove the listener as long as the dispatching object exists (unless the <codeph>useWeakReference</codeph>
	parameter is set to <codeph>true</codeph>).</p>
		
	<p>Copying an EventDispatcher instance does not copy the event listeners attached to it. 
	(If your newly created node needs an event listener, you must attach the listener after
    creating the node.) However, if you move an EventDispatcher instance, the event listeners 
    attached to it move along with it.</p>
	
	
	<p platform="actionscript">If the event listener is being registered on a node while an event is being processed
	on this node, the event listener is not triggered during the current phase but can be 
	triggered during a later phase in the event flow, such as the bubbling phase.</p>
	
	<p platform="actionscript">If an event listener is removed from a node while an event is being processed on the node,
	it is still triggered by the current actions. After it is removed, the event listener is
	never invoked again (unless registered again for future processing). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:analyze"><apiName>analyze</apiName><shortdesc>
     Gathers statistics about database indices and
     stores them in the database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When this method is called while the SQLConnection instance
     isn't connected to a database (the <codeph>connected</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>if the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>resourceName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>The name of the database or
     table whose indices are to be analyzed. If the specified resource is a table
     whose name is unique among all the attached databases, only the table name needs
     to be specified. However, a table name can be specified in the form
     <codeph>[database-name].[table-name]</codeph> to prevent ambiguity when the table name
     is not unique. If the <codeph>resourceName</codeph> parameter is <codeph>null</codeph>
     (the default), all the indices in all attached databases are analyzed.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> an <codeph>analyze</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Gathers statistics about database indices and
     stores them in the database. These statistics can then be used by the query optimizer
	 (the portion of the database engine that determines the most efficient way to
	 execute each statement). The statistics help the query optimizer make better
	 choices about which index or indices to use when executing a particular query.
	 
	 <p>If a database has indices defined, but the <codeph>analyze()</codeph> method hasn't
	 been called, the runtime still uses those indices to execute statements. However,
	 without the additional statistical information generated by the <codeph>analyze()</codeph> method,
	 the runtime may not choose the most efficient index for a particular query.</p>
	 
	 <p>When a table's data changes (as a result of <codeph>INSERT</codeph>, <codeph>UPDATE</codeph>,
	 or <codeph>DELETE</codeph> statements) the indices associated with that table change as well.
	 The statistical information generated by <codeph>analyze()</codeph> is not automatically
	 updated. Consequently, after a large number of data changes, calling the 
	 <codeph>analyze()</codeph> method again might be beneficial. However, the benefit obtained
	 from calling <codeph>analyze()</codeph> again depends on several factors, including the
	 number of indices defined on a table, the relationship between the number of changed
	 rows and the total number of rows in the table, how much variation there is in the
	 table's indexed data, and how different the changed data is from the prechange data.</p>
     
     <p>The <codeph>resourceName</codeph> parameter indicates whether the operation is 
	 performed on the indices of all attached databases, a specific database, or a specific
     table.</p>
     
     <p>Each time this method is called, any previously created statistical
     data is purged and recreated for the database or table specified in the <codeph>resourceName</codeph>
	 parameter (or all tables in all connected databases if <codeph>resourceName</codeph> is <codeph>null</codeph>).
	 This method can be called at any time
     while a database connection is open. The <codeph>analyze()</codeph> operation and its statistical
	 data are not included in a transaction; however, it is best
     not to call <codeph>analyze()</codeph> when the database has a current transaction (the
     <codeph>inTransaction</codeph> property is <codeph>true</codeph>). This is because any data, table schema,
	 or index changes that have been executed in the transaction but not yet committed
	 are not taken into account by the <codeph>analyze()</codeph> call, and the
	 <codeph>analyze()</codeph> data is out of date as soon as the transaction is committed.</p>
     
     <p>To remove the statistical data created with the <codeph>analyze()</codeph> method, use
     the <codeph>deanalyze()</codeph> method.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:analyze_analyze"><apiName>analyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:analyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:attach"><apiName>attach</apiName><shortdesc>
     Adds another database to the SQLConnection instance, giving the new database
     the specified name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the <codeph>name</codeph> parameter is an empty string (<codeph>""</codeph>)
     or <codeph>null</codeph>
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the value specified for the <codeph>reference</codeph> parameter is not a
	 flash.filesystem.File instance
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the <codeph>encryptionKey</codeph> argument is not <codeph>null</codeph> and 
	 its <codeph>length</codeph> is not 16 bytes
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the <codeph>reference</codeph> parameter is <codeph>null</codeph> and the 
	 <codeph>encryptionKey</codeph> argument is not <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the SQLConnection instance isn't connected to a database
	 (the <codeph>connected</codeph> property is <codeph>false</codeph>);
     or if a transaction is currently open (the <codeph>inTransaction</codeph> property is <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>if the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name that is used to identify the newly attached database.
     This name can be used in SQL statements to explicitly indicate that a table belongs
     to the specified database, when using the format <codeph>[database-name].[table-name]</codeph>.
     The names "main" and "temp" are reserved and cannot be used.
     
     </apiDesc></apiParam><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>A reference to the database file to attach
	 (a flash.filesystem.File instance). If the reference refers to a file that doesn't exist, either
	 a new database file is created or an error is thrown according to the value that was specified for the
	 <codeph>openMode</codeph> parameter in the <codeph>open()</codeph> or <codeph>openAsync()</codeph> call that
	 connected the main database.
	 
     <p>If the parameter's value is <codeph>null</codeph>, an in-memory database is created and attached.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> an <codeph>attach</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>The encryption key for the database file.
	 If the <codeph>attach()</codeph> call creates a database, the database is encrypted and the 
	 specified key is used as the encryption key for the database. If the call attaches an 
	 existing encrypted database, the value must match the database's encryption key or an error occurs.
	 If the database being attached is not encrypted, or to create an unencrypted database, 
	 the value must be <codeph>null</codeph> (the default).
	 
	 <p>A valid encryption key is 16 bytes long. An in-memory database cannot be encrypted, so this 
	 parameter must be <codeph>null</codeph> when the <codeph>reference</codeph> parameter's value is 
	 <codeph>null</codeph>.</p>
	 
	 <p>When attaching an encrypted database, if the encryption key provided doesn't match the 
	 database's encryption key, an exception occurs. In synchronous execution mode, a SQLError 
	 exception is thrown. In asynchronous execution mode, a SQLErrorEvent is dispatched, and the event  
	 object's <codeph>error</codeph> property contains a SQLError instance. In either case, the 
	 SQLError object's <codeph>errorID</codeph> property is 3138 ("File opened is not a database file").</p>
	 
	 <p>The <codeph>encryptionKey</codeph> parameter is available starting with AIR 1.5.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Adds another database to the SQLConnection instance, giving the new database
     the specified name. Attaching a database allows that database to be used in SQL
     statements executed against this SQLConnection instance.
     
     <p>If a database is already attached using the specified name, calling <codeph>attach()</codeph>
     results in an <codeph>error</codeph> event. However, the same database may
     be attached multiple times using unique names. Only ten databases can be attached
     to a single SQLConnection instance.</p>
     
     <p>Any SQL statement can be executed on a database connected using
     <codeph>attach()</codeph> that can be executed on the main database (the database
     connected using <codeph>open()</codeph> or <codeph>openAsync()</codeph>).
     A SQL statement can access tables in any of the databases attached to the
     statement's associated SQLConnection instance, including accessing tables from
     multiple databases in a single statement. When the runtime is resolving table names
     in a statement, it searches through the SQLConnection instance's databases in the order
     in which the databases were attached, starting with the database that was connected
     using the <codeph>open()</codeph> or <codeph>openAsync()</codeph> method. Use the database name (as specified in the
     <codeph>attach()</codeph> method's <codeph>name</codeph> parameter) in the statement
     to explicitly qualify a table name.</p>
     
     <p>To remove a database attached using the <codeph>attach()</codeph> method,
     use the <codeph>detach()</codeph> method. When the SQLConnection instance is closed (by
     calling the <codeph>close()</codeph> method), all
     attached databases are detached.</p>
     
     <p>The attached database uses the same execution mode (synchronous or asynchronous) as
	 the main database, according to whether the main database was connected using the <codeph>open()</codeph>
	 method or the <codeph>openAsync()</codeph> method.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:attach_attach"><apiName>attach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:attach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:begin"><apiName>begin</apiName><shortdesc>
     Begins a transaction within which all SQL statements executed against
     the connection's database or databases are grouped.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When this method is called while the SQLConnection instance
     isn't connected to a database (the <codeph>connected</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the option specified is not one of the <codeph>SQLTransactionLockType</codeph>
     constants.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>if the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>option</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Indicates the locking strategy that is used by
     the transaction. The value can be one of the constants defined
     in the SQLTransactionLockType class:
     <ul>
        <li><codeph>SQLTransactionLockType.DEFERRED</codeph> indicates that a lock is not acquired
	    until the first read or write operation.</li>
        <li><codeph>SQLTransactionLockType.EXCLUSIVE</codeph> indicates that a lock is acquired as soon
	    as possible, and no other SQLConnection instance can read from or write to the database.</li>
        <li><codeph>SQLTransactionLockType.IMMEDIATE</codeph> indicates that a lock is acquired as soon
	    as possible, in which other SQLConnection instances can read from but can't write to the database.</li>
     </ul>
	 <p>The default value (<codeph>null</codeph>) is equivalent to <codeph>SQLTransactionLockType.DEFERRED</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>begin</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Begins a transaction within which all SQL statements executed against
     the connection's database or databases are grouped.
     
     <p>By default, each SQL statement
     is executed within its own transaction, and the transaction ends when
     the statement's execution succeeds or fails. Creating a transaction using the
     <codeph>begin()</codeph> method causes a new, manual transaction to be created.
     From that point on, all SQL statements executed against the SQLConnection instance
     take place within the transaction, and any actions or modifications performed
     by the statements can be committed (made permanent) or rolled back (undone) as
     a group.</p>
     
     <p>Nested transactions are not allowed (nested calls to <codeph>begin()</codeph>
     are ignored). To end a transaction, call the <codeph>commit()</codeph> or
     <codeph>rollback()</codeph> method, depending on whether the changes made by the
     transactions' statements are to be made permanent or discarded.</p>
	 
	 <p>If the database connection closes while a transaction is currently open, AIR rolls back
	 the transaction automatically. (Note: for AIR 1.1 and previous versions, an 
	 open transaction is automatically committed when a connection closes.)</p>
     
     <p>A transaction is not limited to statement executions in a single
     database; it can include statements executed on different attached
     databases.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link><link href="flash.data.xml#SQLTransactionLockType"><linktext>flash.data.SQLTransactionLockType</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:begin_begin"><apiName>begin</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:begin_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:cancel"><apiName>cancel</apiName><shortdesc>
     Aborts all SQL statements that are currently executing on databases connected to the SQLConnection
     instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When this method is called while the SQLConnection instance
     isn't connected to a database (the <codeph>connected</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>cancel</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Aborts all SQL statements that are currently executing on databases connected to the SQLConnection
     instance. This method can be used to stop long running or runaway queries.
     
     <p>If there are statements executing when the <codeph>cancel()</codeph> method is called, this method
     aborts the statements' operations and any incomplete updates or transactions are rolled back.
     If there are no statements currently executing, calling this method rolls back an open transaction
	 but otherwise does nothing.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:cancel_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:cancel_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:close"><apiName>close</apiName><shortdesc>
     Closes the current database connection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>close</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Closes the current database connection. Any attached databases are
     detached as well.
     
     <p>If there is an open
     transaction when <codeph>close()</codeph> is called, the transaction is committed.
     When a SQLConnection instance is
     garbage-collected, the runtime calls <codeph>close()</codeph> automatically, including
     if an AIR application is closed while a SQLConnection is still connected to a database.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:close_close"><apiName>close</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:close_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:commit"><apiName>commit</apiName><shortdesc>
     Commits an existing transaction, causing any actions performed by the transaction's
     statements to be permanently applied to the database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the method is called while the SQLConnection instance
	 isn't connected to a database (the <codeph>connected</codeph> property is
	 <codeph>false</codeph>); or if no transaction is currently open (the
	 <codeph>inTransaction</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>commit</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Commits an existing transaction, causing any actions performed by the transaction's
     statements to be permanently applied to the database.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:commit_commit"><apiName>commit</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:commit_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes with a failure.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes with a failure.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:compact"><apiName>compact</apiName><shortdesc>
     Reclaims all unused space in the database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the method is called while the SQLConnection instance
	 isn't connected to a database (the <codeph>connected</codeph> property is <codeph>false</codeph>);
	 or if a transaction is currently in progress (the <codeph>inTransaction</codeph>
	 property is <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>compact</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Reclaims all unused space in the database. When an object (table, index, or trigger) is
     dropped from the database, it leaves behind empty space. This makes the database file
     larger than it needs to be, but can speed up <codeph>INSERT</codeph> operations.
     Over time, <codeph>INSERT</codeph> and <codeph>DELETE</codeph> operations can leave the database
     file structure fragmented, which slows down disk access to the database contents. This
     method compacts the database file, eliminating free pages, aligning table data to be
     contiguous, and otherwise cleaning up the database file structure.
     
     <p>The <codeph>compact()</codeph> operation can't be performed on an attached database file;
     it can only be performed on the main (original) database file opened by the SQLConnection
     instance. This operation fails if there is an active transaction, and has no effect
     on an in-memory database.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:compact_compact"><apiName>compact</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:compact_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:deanalyze"><apiName>deanalyze</apiName><shortdesc>
     Removes all statistical information created by a call to the
     analyze() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When this method is called while the SQLConnection instance
     isn't connected to a database (the <codeph>connected</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>deanalyze</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Removes all statistical information created by a call to the
     <codeph>analyze()</codeph> method.
	 
	 <p>Because the statistics generated by the <codeph>analyze()</codeph> method take up space in
	 a database, calling <codeph>deanalyze()</codeph> allows you to reclaim that space, such as
	 after dropping several indices or tables.</p>
     
     <p>This operation is not included in an active transaction.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:deanalyze_deanalyze"><apiName>deanalyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:deanalyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:detach"><apiName>detach</apiName><shortdesc>
     Detaches an additional database previously attached to the SQLConnection instance using
     the attach() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>name</codeph> argument is <codeph>null</codeph> or contains
     an empty string (<codeph>""</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If this method is called while the SQLConnection instance
     isn't connected to a database (the <codeph>connected</codeph> property is <codeph>false</codeph>); or
	 if the SQLConnection instance has an open transaction (the <codeph>inTransaction</codeph>
	 property is <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The given name of the database to detach.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>detach</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Detaches an additional database previously attached to the SQLConnection instance using
     the <codeph>attach()</codeph> method. It is possible to have the same database file
     attached multiple times using different names, and detaching one
     connection to a file leaves the others intact. A database cannot be detached
     if the database has an open transaction (if the <codeph>inTransaction</codeph>
     property is <codeph>true</codeph>).
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:detach_detach"><apiName>detach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:detach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:getSchemaResult"><apiName>getSchemaResult</apiName><shortdesc>
     Provides access to the result of a call to the loadSchema() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.data:SQLSchemaResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Provides access to the result of a call to the <codeph>loadSchema()</codeph> method.
	 The <codeph>getSchemaResult()</codeph> method behaves as a first-in, first-out queue of
	 results. Each time the <codeph>loadSchema()</codeph> method call completes (each time the
	 <codeph>schema</codeph> event is dispatched in asynchronous execution mode),
	 a new SQLSchemaResult object is added to the queue.
	 Each time the <codeph>getSchemaResult()</codeph> method
     is called, the earliest result (the one that was added to the queue first) is returned and removed
	 from the queue. When there are no more objects left in the queue, <codeph>getSchemaResult()</codeph>
	 returns <codeph>null</codeph>.
     
     <p>When the database connection is closed the method returns <codeph>null</codeph>.</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>schema</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLConnection:loadSchema"><apiName>loadSchema</apiName><shortdesc>
     Loads schema information from the connected database or any attached databases.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the method is called while the SQLConnection instance
     isn't connected to a database (the <codeph>connected</codeph> property is <codeph>false</codeph>).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>When the specified <codeph>type</codeph> argument value isn't
	 one of the allowed types.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When using synchronous execution mode, if an invalid value is supplied for the name
	 or database parameters.
	 
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiData>null</apiData><apiDesc>Indicates the type of schema to load. A <codeph>null</codeph> value (the
	 default) indicates that all the schema information should be loaded.
     Specifying a non-<codeph>null</codeph> value for this parameter narrows the scope of the
	 resulting schema, removing potentially unneeded information from the results
	 and making the operation more efficient. The value must be the class name of
	 one of the following classes:
	 <ul>
	     <li>SQLIndexSchema</li>
	     <li>SQLTableSchema</li>
	     <li>SQLTriggerSchema</li>
	     <li>SQLViewSchema</li>
	 </ul>
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Indicates which resource's schema is loaded. How this value is
     used depends on the <codeph>type</codeph> argument specified. Typically, this is the name of a database
	 object such as a table name, an index or view name, and so forth. If a value is specified,
	 only schema information for the database object with the specified name is included in the
	 result.
	 
	 <p>If the specified value is not valid an <codeph>error</codeph> event is
	 dispatched (or an error is thrown in synchronous execution mode). The <codeph>type</codeph> parameter
	 value must correspond to the type of the object named in order for the value to be valid, as described
	 in the method description.</p>
	 
	 <p>If the <codeph>name</codeph> argument is <codeph>null</codeph> then all schemata of the specified
	 type are included. If the value specified is not valid an <codeph>error</codeph> event is dispatched.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>main</apiData><apiDesc>The name of the database whose schema is loaded. If the value specified
     is not valid an <codeph>error</codeph> event is dispatched.
     
     </apiDesc></apiParam><apiParam><apiItemName>includeColumnSchema</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Indicates whether the result includes schema information for the
	 columns of tables and views.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>schema</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Loads schema information from the connected database or any attached databases.
     The schema indicates the structure of the database's tables, columns, indices, and triggers.
	 
     <p>To access the loaded schema use the <codeph>SQLConnection.getSchemaResult()</codeph> method.</p>
	 
     <p>In asynchronous execution mode, a <codeph>schema</codeph> event is dispatched if the operation
	 is successful, or an <codeph>error</codeph> event is dispatched if the operation fails.</p>
	 
	 <p>The combination of the <codeph>type</codeph> and <codeph>name</codeph> parameter values determines the
	 type of schema data that's generated by the <codeph>loadSchema()</codeph> method and, consequently, the
	 values of the properties of the SQLSchemaResult instance that's generated. The following
	 table lists the valid <codeph>type</codeph> and <codeph>name</codeph> pairs and the schema data that's
	 generated as a result:</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry><codeph>type</codeph> argument</entry><entry><codeph>name</codeph> argument</entry><entry>Retrieves schema data for: </entry></row></thead><tbody><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>all objects in the database (all tables, views, triggers, and indices)</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>all indices in the database</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>valid table name</entry>
	     <entry>all indices defined on the specified table</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>valid index name</entry>
	     <entry>the specified index</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>all tables in the database</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry>valid table name</entry>
	     <entry>the specified table</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>all triggers in the database</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>valid table name</entry>
	     <entry>all triggers associated with the specified table</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>valid view name</entry>
	     <entry>all triggers associated with the specified view </entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>valid trigger name</entry>
	     <entry>the specified trigger </entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>all views in the database</entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry>valid view name</entry>
	     <entry>the specified view </entry>
	   </row></tbody></tgroup></adobetable>
	 
	 <p>If the combination of <codeph>type</codeph> and <codeph>name</codeph> arguments does not correspond to
	 one of the specified combinations, an <codeph>error</codeph> event is dispatched in asynchronous
	 execution mode or an exception is thrown in synchronous execution mode.
	 For instance, if the <codeph>type</codeph> argument is <codeph>SQLViewSchema</codeph> and the <codeph>name</codeph>
	 argument is the name of a table (rather than the name of a view), an error is raised indicating that
	 the database doesn't contain an object of the specified type with the specified name.</p>
	 
	 <p>If the database is empty (it doesn't contain any tables, views, triggers, 
	 or indices), calling the <codeph>loadSchema()</codeph> method results in an error.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>getSchemaResult()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>schema</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:loadSchema_schema"><apiName>schema</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:loadSchema_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes with a failure.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes with a failure.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:open"><apiName>open</apiName><shortdesc>
     Opens a synchronous connection to the database file at the specified location in the file system,
     or creates and opens a new database file at the location, or creates and opens an
     in-memory database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the SQLConnection instance already has an open connection
     to a database (the <codeph>connected</codeph> property is <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails. The connection is never left open after a failed
     operation.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiException><apiDesc>When the value specified for the <codeph>reference</codeph> parameter is not a
	 flash.filesystem.File instance
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the <codeph>encryptionKey</codeph> argument is not <codeph>null</codeph> and 
	 its <codeph>length</codeph> is not 16 bytes
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the <codeph>reference</codeph> parameter is <codeph>null</codeph> and the 
	 <codeph>encryptionKey</codeph> argument is not <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If an invalid <codeph>pageSize</codeph> parameter is specified. 
	 This includes passing a page size when the mode is <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>The location of the database file that is opened. This value must be
     a flash.filesystem.File instance. If the parameter's value is <codeph>null</codeph>, an in-memory database
     is created and opened.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Indicates how the database is opened. The value can be any of the
	 constants defined in the SQLMode class. The default value is
     <codeph>SQLMode.CREATE</codeph>, indicating that if a database file is not found at the specified
     location, one is created. If <codeph>openMode</codeph> is <codeph>SQLMode.READ</codeph> and
     the specified file does not exist then an error event is dispatched. This parameter is ignored
     when the <codeph>reference</codeph> parameter is <codeph>null</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indicates whether unused space in the database is reclaimed automatically.
     This parameter is only valid when creating a new database file or opening a database file in which
     no tables have been created. By default, the space taken up by removed data is left in the database
     file and reused when needed. Setting this parameter to <codeph>true</codeph> causes the database to
     automatically reclaim unused space. This can negatively affect performance because it requires
	 additional processing each time data is written to the database and can also cause the
	 database data to become fragmented over time.
	 To force the database to reclaim unused space in a database file at any time and to
	 defragment the database file, use the <codeph>compact()</codeph> method.
	 
	 <p>This parameter is ignored when the <codeph>openMode</codeph> parameter is <codeph>SQLMode.READ</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Indicates the page size (in bytes) for the database. This parameter is
	 only valid when creating a new database file or opening a database file in which
     no tables have been created. The value must be a power of two greater than or equal to 
     512 and less than or equal to 32768. The default value is 1024 bytes. This value can only be set
     before any tables are created. Once the tables are created attempting to change this value
     results in an error. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>The encryption key for the database file.
	 If the <codeph>open()</codeph> call creates a database, the database is encrypted and the 
	 specified key is used as the encryption key for the database. If the call opens an 
	 encrypted database, the value must match the database's encryption key or an error occurs.
	 If the database being opened is not encrypted, or to create an unencrypted database, 
	 the value must be <codeph>null</codeph> (the default) or an error occurs.
	 
	 <p>A valid encryption key is 16 bytes long. An in-memory database cannot be encrypted, so this 
	 parameter must be <codeph>null</codeph> when the <codeph>reference</codeph> parameter's value is 
	 <codeph>null</codeph>.</p>
	 
	 <p>When opening an encrypted database, if the encryption key provided doesn't match the 
	 database's encryption key, a SQLError exception is thrown. In that case the SQLError object's 
	 <codeph>errorID</codeph> property is 3138 ("File opened is not a database file").</p>
	 
	 <p>The <codeph>encryptionKey</codeph> parameter is available starting with AIR 1.5.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Opens a synchronous connection to the database file at the specified location in the file system,
     or creates and opens a new database file at the location, or creates and opens an
     in-memory database. The operations of creating and opening the database, as well as all other operations
	 that are performed using this SQLConnection instance (including statement execution and other operations
	 performed by a SQLStatement instance associated with this SQLConnection instance) are performed
	 <i>synchronously</i> when the database is opened using this method. To perform operations
	 asynchronously, open the database connection using the <codeph>openAsync()</codeph> method instead.
	 
	 <p>Once a database is connected, use a <xref href="SQLStatement.html">SQLStatement</xref> instance to execute SQL commands. 
	 Database-level operations such as beginning or ending transactions, loading schema information,
	 and other operations are performed using the SQLConnection instance.</p>
     
     <p>A database that is connected using the <codeph>open()</codeph> method is automatically
     assigned the database name "main"; that name can be used to explicitly qualify
     table names in SQL statements using the format <codeph>[database-name].[table-name]</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:open_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:openAsync"><apiName>openAsync</apiName><shortdesc>
     Opens an asynchronous connection to the database file at the specified location in the file system,
     or creates and opens a new database file at the location, or creates and opens an
     in-memory database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the SQLConnection instance already has an open connection
     to a database (the <codeph>connected</codeph> property is <codeph>true</codeph>).
     
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>When the value specified for the <codeph>reference</codeph> parameter is not a
	 flash.filesystem.File instance
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the <codeph>encryptionKey</codeph> argument is not <codeph>null</codeph> and 
	 its <codeph>length</codeph> is not 16 bytes
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the <codeph>reference</codeph> parameter is <codeph>null</codeph> and the 
	 <codeph>encryptionKey</codeph> argument is not <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If an invalid <codeph>pageSize</codeph> parameter is specified. 
	 This includes passing a page size when the mode is <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>The location of the database file that is opened. This value must be
     a flash.filesystem.File instance. If the parameter's value is <codeph>null</codeph>, an in-memory database
     is created and opened.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Indicates how the database is opened. The value can be any of the
	 constants defined in the SQLMode class. The default value is
     <codeph>SQLMode.CREATE</codeph>, indicating that if a database file is not found at the specified
     location, one is created. If <codeph>openMode</codeph> is <codeph>SQLMode.READ</codeph> and
     the specified file does not exist then an error event is dispatched. This parameter is ignored
     when the <codeph>reference</codeph> parameter is <codeph>null</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when the operation succeeds or fails.
     If the <codeph>responder</codeph> argument is <codeph>null</codeph> an <codeph>open</codeph> or <codeph>error</codeph>
	 event is dispatched when execution completes.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indicates whether unused space in the database is reclaimed automatically.
     This parameter is only valid when creating a new database file or opening a database file in which
     no tables have been created. By default, the space taken up by removed data is left in the database
     file and reused when needed. Setting this parameter to <codeph>true</codeph> causes the database to
     automatically reclaim unused space. This can negatively affect performance because it requires
	 additional processing each time data is written to the database and can also cause the
	 database data to become fragmented over time.
	 To force the database to reclaim unused space in a database file at any time and to
	 defragment the database file, use the <codeph>compact()</codeph> method.
	 
	 <p>This parameter is ignored when the <codeph>openMode</codeph> parameter is <codeph>SQLMode.READ</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Indicates the page size (in bytes) for the database. This parameter is
	 only valid when creating a new database file or opening a database file in which
     no tables have been created. The value must be a power of two greater than or equal to 
     512 and less than or equal to 32768. The default value is 1024 bytes. This value can only be set
     before any tables are created.  Once the tables are created attempting to change this value
     results in an error. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>The encryption key for the database file.
	 If the <codeph>openAsync()</codeph> call creates a database, the database is encrypted and the 
	 specified key is used as the encryption key for the database. If the call opens an 
	 encrypted database, the value must match the database's encryption key or an error occurs.
	 If the database being opened is not encrypted, the value must be <codeph>null</codeph> (the 
	 default) or an error occurs.
	 
	 <p>A valid encryption key is 16 bytes long. An in-memory database cannot be encrypted, so this 
	 parameter must be <codeph>null</codeph> when the <codeph>reference</codeph> parameter's value is 
	 <codeph>null</codeph>.</p>
	 
	 <p>When opening an encrypted database, if the encryption key provided doesn't match the 
	 database's encryption key, a SQLErrorEvent is dispatched. The event object's 
	 <codeph>error</codeph> property contains a SQLError instance. That SQLError object's 
	 <codeph>errorID</codeph> property is 3138 ("File opened is not a database file").</p>
	 
	 <p>The <codeph>encryptionKey</codeph> parameter is available starting with AIR 1.5.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Opens an asynchronous connection to the database file at the specified location in the file system,
     or creates and opens a new database file at the location, or creates and opens an
     in-memory database. The operations of creating and opening the database, as well as all other operations
	 that are performed using this SQLConnection instance (including statement execution and other operations
	 performed by a SQLStatement instance associated with this SQLConnection instance) are performed
	 <i>asynchronously</i> when the database is opened using this method. To perform operations
	 synchronously, open the database connection using the <codeph>open()</codeph> method instead.
     
	 <p>Once a database is connected, use a <xref href="SQLStatement.html">SQLStatement</xref> instance to execute SQL commands. 
	 Database-level operations such as beginning or ending transactions, loading schema information,
	 and other operations are performed using the SQLConnection instance.</p>
     
     <p>A database that is connected using the <codeph>openAsync()</codeph> method is automatically
     assigned the database name "main"; that name can be used to explicitly qualify
     table names in SQL statements using the format <codeph>[database-name].[table-name]</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:openAsync_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:openAsync_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails. The connection is never left open after a
     failed operation.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:reencrypt"><apiName>reencrypt</apiName><shortdesc>
	 Changes the encryption key of an encrypted database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the <codeph>newEncryptionKey</codeph> value is <codeph>null</codeph> or its 
	 <codeph>length</codeph> is not 16 bytes.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the connection is not open, or if there is an open transaction.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newEncryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>A ByteArray containing the new encryption key for the database. A valid 
	 encryption key is 16 bytes long.
	 
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when the operation succeeds or fails.
     If the <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>reencrypt</codeph> or 
	 <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Changes the encryption key of an encrypted database. This method only affects the encryption 
	 key of the main database (the database that was connected using the <codeph>open()</codeph> or 
	 <codeph>openAsync()</codeph> method). You can only call <codeph>reencrypt()</codeph> on a database 
	 that was encrypted when it was created. Once a database has been created as an encrypted database, 
	 it cannot be unencrypted. Likewise, a database that is created without encryption cannot be 
	 encrypted later.
	 
	 <p>The reencryption operation runs in its own transaction. If the reencryption process 
	 is interrupted, the database rolls back the transaction and the encryption key is not changed.</p> 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:reencrypt_reencrypt"><apiName>reencrypt</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:reencrypt_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:removeEventListener"><apiName>removeEventListener</apiName><shortdesc>
     
	Removes a listener from the EventDispatcher object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The type of event.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>The listener object to remove.
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">This parameter applies to display objects in the
	ActionScript 3.0 display list architecture, used by SWF content.</ph>
	
	<ph platform="actionscript">Specifies whether the listener was registered for the capture phase or the 
	target and bubbling phases. If the listener was registered for both the capture phase and the
	target and bubbling phases, two calls to <codeph>removeEventListener()</codeph> are required 
	to remove both, one call with <codeph>useCapture()</codeph> set to <codeph>true</codeph>, and another 
	call with <codeph>useCapture()</codeph> set to <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Removes a listener from the EventDispatcher object. If there is no matching listener registered with the EventDispatcher object, a call to this method has no effect.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:rollback"><apiName>rollback</apiName><shortdesc>
     Rolls back an existing transaction created using the begin() method, meaning all changes
     made by any SQL statements in the transaction are discarded.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the method is called while the SQLConnection instance
	 isn't connected to a database (the <codeph>connected</codeph> property is
	 <codeph>false</codeph>); or if no transaction is currently open (the
	 <codeph>inTransaction</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph> a <codeph>rollback</codeph>
	 or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Rolls back an existing transaction created using the <codeph>begin()</codeph> method, meaning all changes
     made by any SQL statements in the transaction are discarded.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:rollback_rollback"><apiName>rollback</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation completes successfully.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation completes successfully.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:rollback_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLConnection:autoCompact:get"><apiName>autoCompact</apiName><shortdesc>
     Indicates whether autocompacting was enabled when the current database
	 was originally created (the value that was specified for the autoCompact
	 parameter in the open() or openAsync() call that created the
	 database).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indicates whether autocompacting was enabled when the current database
	 was originally created (the value that was specified for the <codeph>autoCompact</codeph>
	 parameter in the <codeph>open()</codeph> or <codeph>openAsync()</codeph> call that created the
	 database). If this property is <codeph>true</codeph>, unused space is removed from the database file
	 automatically after each write operation, keeping the database file smaller. If the property
	 is <codeph>false</codeph>, the space previously occupied by removed data is left in the database
	 file and reused when needed. Even when <codeph>autoCompact</codeph> is <codeph>false</codeph>, you can force the
	 database to reclaim unused space by calling the <codeph>compact()</codeph> method.
     
     <p>If the <codeph>connected</codeph> property is <codeph>false</codeph>, this property
	 is set to <codeph>false</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:cacheSize:get"><apiName>cacheSize</apiName><shortdesc>
     Provides access to the cache size for this connection, which represents the maximum number
     of database disk pages that are held in memory at one time.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>When an attempt is made to set this
     property while the SQLConnection instance isn't connected to a database (the
	 <codeph>connected</codeph> property is <codeph>false</codeph>); or if a transaction is currently open (the
	 <codeph>inTransaction</codeph> property is <codeph>true</codeph>).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Provides access to the cache size for this connection, which represents the maximum number
     of database disk pages that are held in memory at one time. Each page
     uses about 1.5 KB of memory (depending on the value specified for the <codeph>pageSize</codeph>
	 parameter of the <codeph>open()</codeph> or <codeph>openAsync()</codeph> method call that created the
	 database). The default cache size is 2000. If an application is executing
     <codeph>UPDATE</codeph> or <codeph>DELETE</codeph> operations that change many rows of a database,
	 increasing the cache size can improve speed at the cost of increased memory consumption.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:columnNameStyle:get"><apiName>columnNameStyle</apiName><shortdesc>
     Indicates how column names are reported in the
     result of a SELECT statement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>When an attempt is made to set this
     property while the SQLConnection instance isn't connected to a database (the
	 <codeph>connected</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Indicates how column names are reported in the
     result of a <codeph>SELECT</codeph> statement.
     
     <p>The constants defined in the SQLColumnNameStyle class
     represent the possible values for this property:</p>
     
     <ul>
         <li><codeph>SQLColumnNameStyle.LONG</codeph> indicates that
         column names are returned in the format <codeph>[table-name]_[column-name]</codeph>.</li>
         <li><codeph>SQLColumnNameStyle.SHORT</codeph> specifies that column names are given
         the format <codeph>[column-name]</codeph>. If there are multiple columns with the same name,
	     only one property with that name is added to the result object.</li>
         <li><codeph>SQLColumnNameStyle.DEFAULT</codeph> is the default value. When
         this value is used, result column names are formatted according to the number of
         tables in the <codeph>SELECT</codeph> statement that have similar column names. If the
	     <codeph>SELECT</codeph> statement includes only one table, the short name format
	     <codeph>[column-name]</codeph> is used, and if the <codeph>SELECT</codeph>
         statement includes multiple tables joined together, whenever there is a naming collision
	     because two column names are identical, the long name format
         <codeph>[table-name]_[column-name]</codeph> is used for the identically named columns.</li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnNameStyle"><linktext>flash.data.SQLColumnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:connected:get"><apiName>connected</apiName><shortdesc>
     Indicates whether the SQLConnection instance has an open connection
     to a database file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indicates whether the SQLConnection instance has an open connection
     to a database file.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:inTransaction:get"><apiName>inTransaction</apiName><shortdesc>
	 Indicates whether this connection is currently involved in a transaction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates whether this connection is currently involved in a transaction.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     The last generated row identifier created by a SQL INSERT
	 statement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The last generated row identifier created by a SQL <codeph>INSERT</codeph>
	 statement. A row identifier is used to uniquely identify a row in a table within
     the database. The value is frequently generated by the database.
	 
     <p>The value is zero if no database is connected or no
	 <codeph>INSERT</codeph> statement has been executed.</p>
	 
	 <p>The row identifier for a single SQL <codeph>INSERT</codeph> statement execution
	 can be obtained through the <codeph>lastInsertRowID</codeph> property of the SQLResult object
	 returned by the SQLStatement object's <codeph>getResult()</codeph> method (when called after the
	 SQLStatement dispatches its <codeph>result</codeph> event).</p>
	 
	 <p>For more information on primary keys and generated row identifiers,
	 see the "<xref href="../../localDatabaseSQLSupport.html#createTable">CREATE TABLE</xref>" and
	 "<xref href="../../localDatabaseSQLSupport.html#expressions">Expressions</xref>" sections in the appendix
	 "<xref href="../../localDatabaseSQLSupport.html">SQL support in local databases</xref>."</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/lastInsertRowID"><linktext>flash.data.SQLResult.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:pageSize:get"><apiName>pageSize</apiName><shortdesc>
     Indicates the database page size (in bytes) that was specified when the current database
	 was originally created (the value that was specified for the pageSize
	 parameter in the open() or openAsync() call that created the
	 database).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the database page size (in bytes) that was specified when the current database
	 was originally created (the value that was specified for the <codeph>pageSize</codeph>
	 parameter in the <codeph>open()</codeph> or <codeph>openAsync()</codeph> call that created the
	 database).
     
     <p>If the <codeph>connected</codeph> property is <codeph>false</codeph>, this property's
     value is 0.</p>
     
	 <p>The page size for a database can be changed (using the <codeph>open()</codeph> or <codeph>openAsync()</codeph>
	 methods) until the first table is created in the database.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:totalChanges:get"><apiName>totalChanges</apiName><shortdesc>
     Contains the total number of data changes that have been made since the
	 connection to the database was opened.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Contains the total number of data changes that have been made since the
	 connection to the database was opened. In addition to tracking changes
	 made by <codeph>INSERT</codeph>, <codeph>DELETE</codeph>, and <codeph>UPDATE</codeph>
	 statements, this value includes changes caused by triggers.
	 
	 <p>When the database connection is closed, the value is
     reset to 0. When the SQLConnection instance isn't connected
	 to a database file, the value is 0.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/rowsAffected"><linktext>flash.data.SQLResult.rowsAffected</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
 A SQLTriggerSchema instance provides information describing a specific trigger
 in a database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 A SQLTriggerSchema instance provides information describing a specific trigger
 in a database.
 
 It contains the name of the trigger (the <codeph>name</codeph> property),
 the name of the associated table (the <codeph>table</codeph> property), and the
 SQL statement used to create the trigger (the <codeph>sql</codeph> property).
 
 <p>To obtain trigger schema information for a database, use the
 <codeph>SQLConnection.loadSchema()</codeph> method to load the schema information, making certain to
 use <codeph>null</codeph> or <codeph>SQLTriggerSchema</codeph> for the <codeph>type</codeph> argument's value.
 In the resulting SQLSchemaResult instance, the <codeph>triggers</codeph> property contains an array
 of SQLTriggerSchema instances representing the triggers in the database.</p>
 
 <p>Generally, developer code does not construct SQLTriggerSchema instances directly.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLTriggerSchema:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
     Creates a SQLTriggerSchema instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the associated database.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the trigger.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The SQL used to create the trigger.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the trigger's associated table.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a SQLTriggerSchema instance.  Generally, developer code does not call the SQLTriggerSchema
     constructor directly. To obtain schema information for a database, call the
	 <codeph>SQLConnection.loadSchema()</codeph> method.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLTriggerSchema:table:get"><apiName>table</apiName><shortdesc>
     The name of the table on which this trigger is defined, or the name of the view if
	 the trigger is defined on a view.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     The name of the table on which this trigger is defined, or the name of the view if
	 the trigger is defined on a view.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
 A SQLStatement instance is used to execute a SQL statement against a local SQL database
 that is open through a SQLConnection instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 A SQLStatement instance is used to execute a SQL statement against a local SQL database
 that is open through a SQLConnection instance.
 
 <p>A SQLStatement instance is linked to a SQLConnection instance by setting the SQLConnection instance as the
 value of the SQLStatement instance's <codeph>sqlConnection</codeph> property. The <codeph>text</codeph> property
 is populated with the actual text of the SQL statement to execute. If necessary, SQL statement parameter
 values are specified using the <codeph>parameters</codeph> property, and the statement is
 carried out by calling the <codeph>execute()</codeph> method.</p>
 
 <p>For a complete description of the SQL dialect supported in local SQL databases, see the appendix
 <xref href="../../localDatabaseSQLSupport.html">SQL support in local databases</xref>.</p>
 
 <p>In asynchronous execution mode, the <codeph>execute()</codeph> and <codeph>next()</codeph> methods are executed
 in the background, and the runtime dispatches events to registered event listeners or to a specified Responder
 instance when the operations complete or fail.
 In synchronous mode, the methods are executed on the main application thread, meaning that no other code executes
 until the database operations are completed. In addition, in synchronous mode if the methods fail the runtime
 throws an exception rather than dispatching an error event.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection"><linktext>flash.data.SQLConnection</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Dispatched when an error occurs during an operation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when an error occurs during an operation.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLEvent.RESULT_result"><apiName>result</apiName><shortdesc>
 Dispatched when an execute() or
 next() method call's operation completes successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.RESULT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when an <codeph>execute()</codeph> or
 <codeph>next()</codeph> method call's operation completes successfully. Once the
 <codeph>result</codeph> event is dispatched the <codeph>getResult()</codeph>
 method can be called to retrieve statement results.
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLStatement:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
     Creates a SQLStatement instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>If the constructor is called from any sandbox outside
     of the main application sandbox. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Creates a SQLStatement instance.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLStatement:cancel"><apiName>cancel</apiName><shortdesc>
     Cancels execution of this statement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Cancels execution of this statement.  Like <codeph>SQLConnection.cancel()</codeph>
     this method is used to stop a long running query or to cancel a query that is not
     yet complete. However, unlike <codeph>SQLConnection.cancel()</codeph> this method only cancels the
     single statement. If the statement is not currently executing, calling this method does
     nothing.
	 
	 <p>No events are dispatched in direct response to the completion of the <codeph>cancel()</codeph>
	 operation. However, once the <codeph>cancel()</codeph> operation completes and statement execution
	 is cancelled, the SQLStatement instance dispatches an <codeph>error</codeph> event indicating that
	 the statement execution (the <codeph>execute()</codeph> or <codeph>next()</codeph> call) did not complete.
	 Alternatively, if a value was specified for the <codeph>responder</codeph> parameter of the
	 <codeph>execute()</codeph> or <codeph>next()</codeph> call, the specified fault handler method is called.
	 In either case, the SQLError instance that's passed to the listeners has an <codeph>errorID</codeph>
     property with a value of 3118 (Operation aborted).</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLStatement:clearParameters"><apiName>clearParameters</apiName><shortdesc>
     Clears all current parameter settings.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Clears all current parameter settings.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/parameters"><linktext>parameters</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:execute"><apiName>execute</apiName><shortdesc>
     Executes the SQL in the text property against the database that
     is connected to the SQLConnection object in the sqlConnection
     property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>text</codeph> property is <codeph>null</codeph>
     or contains an empty string (<codeph>""</codeph>); if the <codeph>sqlConnection</codeph> property is
     not set; if the SQLConnection instance assigned to the <codeph>sqlConnection</codeph> property is not
     connected; or if the statement is currently executing.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the operation fails in synchronous execution mode.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>When the statement's <codeph>text</codeph> property is a
	 <codeph>SELECT</codeph> statement, this value indicates how many rows are
	 returned at one time by the statement.
     The default value is -1, indicating that all the result rows are returned
     at one time. This parameter is used in conjunction with the <codeph>next()</codeph>
     method to divide large result sets into smaller sets of data. This can improve
	 users' perceptions of application performance by returning initial results more
	 quickly and dividing result-processing operations.
     
     <p>When the SQL statement is a <codeph>SELECT</codeph> query and a <codeph>prefetch</codeph>
     argument greater than zero is specified, the statement is considered to be executing
     until the entire result set is returned or either the <codeph>SQLStatement.cancel()</codeph>
     or <codeph>SQLConnection.cancel()</codeph> method is called. Note that because the number of
	 rows in a result set is unknown at execution time, the database cursor must move beyond
     the last row in the result set before the statement is considered complete. When a
	 <codeph>prefetch</codeph> argument is specified in an <codeph>execute()</codeph> call, at least
	 one row more than the total number of rows in the result set must be requested
	 (either through a <codeph>prefetch</codeph> value that's larger than the number of rows in the
	 result set, or through subsequent calls to the <codeph>next()</codeph> method) before
	 the resulting SQLResult instance's <codeph>complete</codeph> property is <codeph>true</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. In asynchronous execution mode, if the
	 <codeph>responder</codeph> argument is <codeph>null</codeph>
     a <codeph>result</codeph> or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Executes the SQL in the <codeph>text</codeph> property against the database that
     is connected to the SQLConnection object in the <codeph>sqlConnection</codeph>
     property.
     
	 <p>In asynchronous execution mode, if the <codeph>responder</codeph> argument is not
	 <codeph>null</codeph> the specified
	 Responder object indicates the methods that are called to handle the results
     of the operation. If the <codeph>responder</codeph> argument is <codeph>null</codeph>, a
	 <codeph>result</codeph> event is dispatched if the operation is successful, or an
	 <codeph>error</codeph> event is dispatched if the operation fails.</p>
	 
	 <p>To access the results of a statement, such as the result rows of a <codeph>SELECT</codeph>
	 statement or the database generated primary key of an <codeph>INSERT</codeph> statement, call
	 the <codeph>getResult()</codeph> method. The results are available immediately after the 
	 statement executes in synchronous mode, and when the <codeph>result</codeph> event
	 is dispatched in asynchronous mode.</p>
     
     <p>Every statement must be prepared (compiled) before it can be executed. The first time
	 a SQLStatement instance's <codeph>execute()</codeph> method is called, the statement is
	 prepared by the runtime. Once a statement is prepared it does not need to be prepared
	 again unless the <codeph>text</codeph> property changes. Setting one or more parameter values
	 does not require the statement to be prepared again.</p>
	 
     </apiDesc><example conref="examples\SQLStatement.execute.1.as"> The following example demonstrates executing a SQLStatement,
 using event listeners to determine when the statement execution completes
 or fails.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example><example conref="examples\SQLStatement.execute.2.as"> The following example demonstrates executing a SQLStatement,
 using a Responder object to indicate which functions are called when the statement 
 execution completes or fails.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;
var employeeResponder:Responder;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    employeeResponder = new Responder(resultHandler, errorHandler);
    dbStatement.execute(-1, employeeResponder);
}

function resultHandler(result:SQLResult):void
{
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(error:SQLError):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:execute_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the statement execution completes
     successfully, or when a <codeph>prefetch</codeph> argument value is specified and a <codeph>SELECT</codeph>
     statement returns one or more rows of data.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the statement execution completes
     successfully, or when a prefetch argument value is specified and a SELECT
     statement returns one or more rows of data.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:execute_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLStatement:getResult"><apiName>getResult</apiName><shortdesc>
     Provides access to a SQLResult object containing the results of the statement
     execution, including any result rows from a SELECT statement, and other
     information about the statement execution for all executed statements.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A SQLResult object containing the result of a call to the <codeph>execute()</codeph>
     or <codeph>next()</codeph> method.
     
     </apiDesc><apiOperationClassifier>flash.data:SQLResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Provides access to a SQLResult object containing the results of the statement
     execution, including any result rows from a <codeph>SELECT</codeph> statement, and other
     information about the statement execution for all executed statements.
     In asynchronous execution mode, the result information is not available until the
	 <codeph>result</codeph> event is dispatched.
     
     <p>When a <codeph>SELECT</codeph> statement is executed, if the <codeph>execute()</codeph>
     method is called with the default <codeph>prefetch</codeph> argument of -1, the returned
     SQLResult object contains the entire result set of the query.</p>
     
     <p>When a <codeph>prefetch</codeph> argument is specified for an <codeph>execute()</codeph> or <codeph>next()</codeph>
     method call, the <codeph>getResult()</codeph> method behaves as a first-in, first-out queue
     of results. Each time the <codeph>result</codeph> event is dispatched, a new SQLResult object
     is added to the queue. Each time the <codeph>getResult()</codeph> method is called, the earliest
     SQLResult object (the one that was added to the queue first) is returned and removed
     from the queue. When there are no more SQLResult objects left in the queue, <codeph>getResult()</codeph>
     returns <codeph>null</codeph>.</p>
	 
	 <p>Note that unless they are removed by calling <codeph>getResult()</codeph>,
	 SQLResult objects remain in the queue. For example, if the <codeph>execute()</codeph>
	 method is called multiple times without calling <codeph>getResult()</codeph>, the
	 SQLResult objects associated with each <codeph>execute()</codeph> call remains in
	 the queue.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/result"><linktext>result</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:next"><apiName>next</apiName><shortdesc>
     Retrieves the next portion of a SELECT statement's result set.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the method is called while the statement is not
     currently executing (the <codeph>executing</codeph> property is <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>if the operation fails in synchronous execution mode.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>When the statement's <codeph>text</codeph> property is a <codeph>SELECT</codeph>
     statement, this value indicates how many rows are returned at one time by
     the statement.
     The default value is -1, indicating that all the result rows are returned
     at one time.  This can improve
	 users' perceptions of application performance by returning initial results more
	 quickly and dividing result-processing operations.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>An object that designates methods to be called when
     the operation succeeds or fails. If the <codeph>responder</codeph> argument is <codeph>null</codeph>
     a <codeph>result</codeph> or <codeph>error</codeph> event is dispatched when execution completes.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Retrieves the next portion of a <codeph>SELECT</codeph> statement's result set.
     If there are no more rows in the result set, a <codeph>result</codeph> event is dispatched but
     no additional SQLResult object is added to the <codeph>getResult()</codeph> queue.
     
     <p>In asynchronous execution mode, if the <codeph>responder</codeph> argument is not
	 <codeph>null</codeph> the specified
     Responder object indicates the methods that are called to handle the results
     of the operation.
     If the <codeph>responder</codeph> argument is <codeph>null</codeph>, a
	 <codeph>result</codeph> event is dispatched if the operation is successful, or an
	 <codeph>error</codeph> event is dispatched if the operation fails.</p>
     
     <p>This method can only be called when the statement is still executing.
     When the statement is a <codeph>SELECT</codeph> query and a <codeph>prefetch</codeph>
     argument greater than zero is specified, the statement is considered to be executing
     until the entire result set is returned or either the
	 <codeph>SQLStatement.cancel()</codeph> or <codeph>SQLConnection.cancel()</codeph>
     method is called.</p>
     
     </apiDesc><example conref="examples\SQLStatement.next.1.as"> The following example demonstrates executing a SQLStatement,
 explicitly indicating that only the first 10 rows of the result set are 
 to be returned the first time the result returns. The code checks the
 <codeph>complete</codeph> property of the SQLResult and, if not all the rows
 have been retrieved, calls the <codeph>next()</codeph> method.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute(10);
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
        if (!result.complete)
        {
            dbStatement.next(10);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:next_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the statement execution completes
     successfully, or when a <codeph>prefetch</codeph> argument value is specified and the
     <codeph>next()</codeph> call returns one or more rows of data.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the statement execution completes
     successfully, or when a prefetch argument value is specified and the
     next() call returns one or more rows of data.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:next_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation fails in asynchronous execution mode.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation fails in asynchronous execution mode.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLStatement:executing:get"><apiName>executing</apiName><shortdesc>
     Indicates whether the statement is currently executing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indicates whether the statement is currently executing.
     
     <p>This property is true if <codeph>execute()</codeph> has been called and
     not all of the results have been returned from the database.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:itemClass:get"><apiName>itemClass</apiName><shortdesc>
     Indicates a class (data type) that is used for each
     row returned as a result of the statement's execution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Class</apiValueClassifier></apiValueDef><apiDesc>
     Indicates a class (data type) that is used for each
     row returned as a result of the statement's execution.
     
     <p platform="javascript">This property is intended for use in SWF-based AIR application only. 
     You cannot use it in JavaScript. (ActionScript lets you define custom classes, which you
     can use with this property.)</p>
     
     <p platform="actionscript">By default, each row returned by a <codeph>SELECT</codeph> statement is
     created as an Object instance, with the result set's column names as the
     names of the properties of the object, and the value of each column as the
     value of its associated property.</p>
     
     <p platform="actionscript">By specifying a class for the <codeph>itemClass</codeph> property,
     each row returned by a <codeph>SELECT</codeph> statement executed by this SQLStatement instance
     is created as an instance of the designated class. Each property of the <codeph>itemClass</codeph> instance is
     assigned the value from the column with the same name as the property.</p>
     
     <p platform="actionscript">Any class assigned to this property must have a constructor
     that does not require any parameters. In addition, the class must
     have a single property for each column returned by the <codeph>SELECT</codeph> statement.
     It is considered an error if a column in the <codeph>SELECT</codeph> list
     does not have a matching property name in the <codeph>itemClass</codeph> class.</p>
     
     </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> The following code demonstrates using the <codeph>itemClass</codeph> property 
 to have the runtime create instances of a custom class from SQL <codeph>SELECT</codeph> statement
 results.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/data"><linktext>flash.data.SQLResult.data</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:parameters:get"><apiName>parameters</apiName><shortdesc>
     Serves as an associative array to which you add values for the
     parameters specified in the SQL statement's
     text property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Serves as an associative array to which you add values for the
     parameters specified in the SQL statement's
     <codeph>text</codeph> property. The array keys are
     the names of the parameters. If an unnamed parameter is specified
     in the statement text, its key is the index of the parameter.
     
     <p>Within the text of a SQL statement, a parameter is indicated with
     one of the following characters: "?", ":", or "@".</p>
     
     <p>The ":" and "@" tokens indicate a named parameter; the characters following
     the token designate the name of the parameter.</p>
     
     <p>For example, in the following SQL statement, a parameter named <codeph>firstName</codeph>
     is specified using the ":" character:</p>
     
     <pre>SELECT FROM employees WHERE firstName = :firstName</pre>
     
     <p>The "?" token indicates an indexed (numbered) parameter; each parameter
     is automatically given an index according to the sequence of parameters
     in the statement text. Parameter index values are zero based. In other words, the first parameter's index is 0.</p>
     
     <p>Parameters are used to allow for typed substitution of
     values that are unknown at the time the SQL statement is constructed.
     The use of parameters is the only way to guarantee the storage class for
     a value passed in to the database. When parameters are not used, all values are
	 converted from their text representation to a storage class based on the
     associated column's type affinity. For more information on storage classes and
	 column affinity, see the 
	 "<xref href="../../localDatabaseSQLSupport.html#dataTypes">Data type support</xref>" section
	 in the appendix
	 "<xref href="../../localDatabaseSQLSupport.html">SQL support in local databases</xref>".</p>
     
     <p>Parameters are also used as a security measure to prevent a malicious technique known
     as a SQL injection attack. In a SQL injection attack, a user enters SQL code in a
     user-accessible location (for example, a data entry field). If application code constructs
     a SQL statement by directly concatenating user input into the SQL text, the user-entered
     SQL code is executed against the database. The following listing shows an
     example of concatenating user input into SQL text. <b>Do not use this
     technique</b>:</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement = new air.SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <p>Using statement parameters instead of concatenating user-entered values into
     a statement's text prevents a SQL injection attack, because the parameter values are
     treated explicitly as substituted values, rather than becoming part of the literal statement
     text. The following is the recommended alternative to the previous listing:</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement = new air.SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <p>All parameter values must be set before
     the statement is executed. Parameter values specified in the <codeph>parameters</codeph>
     array are bound (that is,
     combined with the statement text) when the <codeph>execute()</codeph> method is called. Once
     <codeph>execute()</codeph> has been called, any
     subsequent changes to the values are not applied to the executing
     statement. However, on a subsequent <codeph>execute()</codeph> call the changed
     values are used. If the statement text includes a parameter that doesn't have a value specified
     in the <codeph>parameters</codeph> property, the result is an error.</p>
     
     <p>To clear all the parameter values from the <codeph>parameters</codeph> property,
     use the <codeph>clearParameters()</codeph> method.</p>
     
	 </apiDesc><example conref="examples\SQLStatement.parameters.1.as"> The following example shows the use of a named parameter, 
 <codeph>:firstName</codeph>, in a SQL statement.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = :firstName";
employees.parameters[":firstName"] = "Sam";
employees.execute();
</codeblock></example><example conref="examples\SQLStatement.parameters.2.as"> The following example shows the use of a unnamed parameter
 in a SQL statement.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = ?";
employees.parameters[0] = "Sam";
employees.execute();
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/text"><linktext>text</linktext></link><link href="flash.data.xml#SQLStatement/clearParameters()"><linktext>clearParameters()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:sqlConnection:get"><apiName>sqlConnection</apiName><shortdesc>
     The SQLConnection object that manages the connection to the database or databases on which
     the statement is executed.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.data:SQLConnection</apiValueClassifier><apiException><apiDesc>When an attempt is made to change the value
     of this property while the statement is executing.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     The SQLConnection object that manages the connection to the database or databases on which
     the statement is executed.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLStatement:text:get"><apiName>text</apiName><shortdesc>
     The actual SQL text of the statement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>When an attempt is made to change the <codeph>text</codeph>
     property while the statement is executing.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     The actual SQL text of the statement.
	 
     <p>The text can be any supported SQL. For a complete description of the
	 SQL dialect supported in local SQL databases, see the appendix
	 "<xref href="../../localDatabaseSQLSupport.html">SQL support in local databases</xref>".</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLMode"><apiName>SQLMode</apiName><shortdesc>
 This class contains the constants that represent the possible values for the
 openMode parameter of the SQLConnection.open() and 
 SQLConnection.openAsync() methods.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 This class contains the constants that represent the possible values for the
 <codeph>openMode</codeph> parameter of the <codeph>SQLConnection.open()</codeph> and 
 <codeph>SQLConnection.openAsync()</codeph> methods.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links><apiValue id="flash.data:SQLMode:CREATE"><apiName>CREATE</apiName><shortdesc>
	 Indicates that the connection is opened for updates, and a database 
	 file is created if the specified file doesn't exist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>create</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates that the connection is opened for updates, and a database 
	 file is created if the specified file doesn't exist. In this
	 mode reading and writing are allowed to the database. If the database
	 does not exist one is created before the operation completes.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:READ"><apiName>READ</apiName><shortdesc>
	 Indicates that the connection is opened in read-only mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>read</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates that the connection is opened in read-only mode. In this
	 mode writes are not allowed to the database. If the database does not 
	 exist the open operation fails.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:UPDATE"><apiName>UPDATE</apiName><shortdesc>
	 Indicates that the connection is opened for updates but a 
	 new database file is not created if the specified file doesn't exist.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>update</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates that the connection is opened for updates but a 
	 new database file is not created if the specified file doesn't exist. In this
	 mode reading and writing are allowed to the database. If the database
	 does not exist the open operation fails.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:EncryptedLocalStore"><apiName>EncryptedLocalStore</apiName><shortdesc>
	The EncryptedLocalStore class provides methods for setting and getting objects in the encrypted local data store
	for an AIR application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	The EncryptedLocalStore class provides methods for setting and getting objects in the encrypted local data store
	for an AIR application. A persistent encrypted local store is available for each AIR application installed on a user's  
	computer. This lets you save and retrieve data that is stored on the user's local hard drive in an encrypted format 
	that cannot be deciphered by other applications or users. A separate encrypted local store is used for each AIR 
	application, and each AIR application uses a separate encrypted local store for each user. 
	
	<p>You may want to use the encrypted local store to store  
	information that must be secured, such as login credentials for web services.</p>
	
	<p>When testing an application in the AIR Debug Launcher (ADL), the application uses a different
	encrypted local store than is used by the installed AIR application.</p>
	
	<p>AIR uses DPAPI on Windows<sup>Â®</sup>, KeyChain on Mac<sup>Â®</sup> 
	OS<sup>Â®</sup>, and KeyRing or KWallet on Linux<sup>Â®</sup> to associate the encrypted local store 
	to each application and user. The encrypted local store uses AES-CBC 128-bit encryption.</p>
	
	<p>Information in the encrypted local store is available only to AIR application content in the 
	application security sandbox. </p>
	
	<p>Items in the encrypted local store are identified with a string. All items are
	stored as byte array data.</p>
	
	<p>The encrypted local store may perform more slowly if the stored data exceeds 10MB.</p>
	
	<p>When you uninstall an AIR application, the uninstaller does not delete data stored in the 
	encrypted local store.</p>
	
	<p>Encrypted local store data is put in a subdirectory of the user's application data directory; 
	the subdirectory path is Adobe/AIR/ELS/ followed by the application ID.</p>
	
	</apiDesc><example conref="examples\EncryptedLocalStore.1.as"> The following code stores a string in the encrypted local store, retrieves it, and then deletes it:
<codeblock>
var str:String = "Bob";
var bytes:ByteArray = new ByteArray();
bytes.writeUTFBytes(str);
EncryptedLocalStore.setItem("firstName", bytes);

var storedValue:ByteArray = EncryptedLocalStore.getItem("firstName");
trace(storedValue.readUTFBytes(storedValue.length)); // "Bob"

EncryptedLocalStore.removeItem("firstName");
</codeblock></example></apiClassifierDetail><apiOperation id="flash.data:EncryptedLocalStore:getItem"><apiName>getItem</apiName><shortdesc>
		Returns the data for the item with the given name in the encrypted local store.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>The <codeph>name</codeph> value is <codeph>null</codeph> or an empty string.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>The ByteArray data. If there is no data for the provided <codeph>name</codeph>, 
		the method returns <codeph>null</codeph>.
		
		</apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the item in the encrypted local store.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Returns the data for the item with the given name in the encrypted local store.
		If an item does not exist by the specified name, this method returns <codeph>null</codeph>.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:removeItem"><apiName>removeItem</apiName><shortdesc>
		Removes the item with the given name from the encrypted local store.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>The <codeph>name</codeph> value is <codeph>null</codeph> or an empty string.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the item in the encrypted local store.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Removes the item with the given name from the encrypted local store.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:reset"><apiName>reset</apiName><shortdesc>
		Clears the entire encrypted local store, deleting all data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		Clears the entire encrypted local store, deleting all data.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:setItem"><apiName>setItem</apiName><shortdesc>
		Sets the item with the given name to the provided ByteArray data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>The <codeph>name</codeph> value is <codeph>null</codeph> or an empty string.
		
		<p>By default, an AIR application cannot read the encrypted local store of another application.
		The <codeph>stronglyBound</codeph> setting provides extra binding (to the data in the application bits) 
		that prevents an attacker application from attempting to read from your application's 
		encrypted local store by trying to hijack your application's publisher ID.</p> 
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the item in the encrypted local store.
		
		</apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>The data.
		
		</apiDesc></apiParam><apiParam><apiItemName>stronglyBound</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>If set to <codeph>true</codeph>, the stored item is strongly bound to the   
		digital signature and bits of the AIR application (the contents of the application directory), 
		in addition to the application's publisher ID. 
		A subsequent call to <codeph>getItem()</codeph> for this item results in a run-time exception if the 
		calling AIR application's bits do not match those of the storing application. If you update your 
		application, it cannot read strongly bound data that was previously written to the encrypted 
		local store. 
		
		<p>If the <codeph>stronglyBound</codeph> parameter is set to <codeph>false</codeph> (the default), 
		only the publisher ID needs to stay the same for the application to read the data. The bits of 
		the application may change (and they need to be signed by the publisher), but they do not need 
		to be the exact same bits as were in application that stored the data.</p>
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Sets the item with the given name to the provided ByteArray <codeph>data</codeph>.
		
		</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.data:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
 A SQLIndexSchema instance provides information describing a specific index
 in a database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 A SQLIndexSchema instance provides information describing a specific index
 in a database.
 
 The available information includes the name of the associated table
 (the <codeph>table</codeph> property), the
 SQL statement used to create the index (the <codeph>sql</codeph> property), 
 and the name of the index (the <codeph>name</codeph> property).
 
 <p>To obtain index schema information for a database, use the
 <codeph>SQLConnection.loadSchema()</codeph> method to load the schema information, making certain to
 use <codeph>null</codeph> or <codeph>SQLIndexSchema</codeph> for the <codeph>type</codeph> argument's value.
 In the resulting SQLSchemaResult instance, the <codeph>indices</codeph> property contains an array
 of SQLIndexSchema instances representing the indices in the database.</p>
 
 <p>Generally, developer code does not construct SQLIndexSchema instances directly.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLIndexSchema:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
     Creates a SQLIndexSchema instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the associated database.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the index.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The SQL statement used to create this index.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the table to which this index is attached.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a SQLIndexSchema instance. Generally, developer code does not call the SQLIndexSchema
     constructor directly. To obtain schema information for a database, call the
	 <codeph>SQLConnection.loadSchema()</codeph> method.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/indices"><linktext>flash.data.SQLSchemaResult.indices</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLIndexSchema:table:get"><apiName>table</apiName><shortdesc>
     The name of the table to which this index is attached.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     The name of the table to which this index is attached.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
 A SQLTableSchema instance provides information describing a specific table
 in a database.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 A SQLTableSchema instance provides information describing a specific table
 in a database.
 
 It contains the name of the table (the <codeph>name</codeph> property), the
 SQL statement used to create the table (the <codeph>sql</codeph> property), and
 information about the table's columns (the <codeph>columns</codeph> property).
 
 <p>To obtain table schema information for a database, use the
 <codeph>SQLConnection.loadSchema()</codeph> method to load the schema information, making certain to
 use <codeph>null</codeph> or <codeph>SQLTableSchema</codeph> for the <codeph>type</codeph> argument's value.
 In the resulting SQLSchemaResult instance, the <codeph>tables</codeph> property contains an array
 of SQLTableSchema instances representing the tables in the database.</p>
 
 <p>Generally, developer code does not construct SQLTableSchema instances directly.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLTableSchema:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
     Creates a SQLTableSchema instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the associated database.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the table.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The SQL statement used to create the table.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Array of SQLColumnSchema instances describing this table's columns.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a SQLTableSchema instance. Generally, developer code does not call the SQLTableSchema
     constructor directly. To obtain schema information for a database, call the
	 <codeph>SQLConnection.loadSchema()</codeph> method.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/tables"><linktext>flash.data.SQLSchemaResult.tables</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLTableSchema:columns:get"><apiName>columns</apiName><shortdesc>
     An array of SQLColumnSchema instances containing schema information for this table's columns.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of SQLColumnSchema instances containing schema information for this table's columns.
	 If the <codeph>SQlConnection.loadSchema()</codeph> call indicates that column information
     is excluded from the result, the <codeph>columns</codeph> property is an empty array
	 (an array whose <codeph>length</codeph> property is 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLResult"><apiName>SQLResult</apiName><shortdesc>
 The SQLResult class provides access to data returned in response to the execution of a
 SQL statement (a SQLStatement instance).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The SQLResult class provides access to data returned in response to the execution of a
 SQL statement (a SQLStatement instance).
 
 <p>The SQLResult instance for a SQL statement is accessed by calling the
 <codeph>SQLStatement.getResult()</codeph> method or
 as an argument passed to the result handler of a Responder instance specified in a call to
 <codeph>SQLStatement.execute()</codeph> or <codeph>SQLStatement.next()</codeph>. Generally, developer
 code does not construct SQLResult instances directly.</p>
 
 <p>You use a SQLResult object to access the rows of data returned from a
 <codeph>SELECT</codeph> statement (using the <codeph>data</codeph> property), to get
 row identifier information for an <codeph>INSERT</codeph> statement (using the
 <codeph>lastInsertRowID</codeph> property), to determine the number of rows affected
 by an <codeph>INSERT</codeph>, <codeph>UPDATE</codeph>, or <codeph>DELETE</codeph> statement
 (using the <codeph>rowsAffected</codeph> property), or to determine whether there are
 additional <codeph>SELECT</codeph> result rows that haven't been retrieved (using the
 <codeph>complete</codeph> property).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement/getResult()"><linktext>flash.data.SQLStatement.getResult()</linktext></link><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links><apiConstructor id="flash.data:SQLResult:SQLResult"><apiName>SQLResult</apiName><shortdesc>
     Creates a SQLResult instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>The array of rows returned from the execution of a statement. If
     the statement doesn't return any rows this value should be null.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowsAffected</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Indicates how many rows the executed statement affected.
     
     </apiDesc></apiParam><apiParam><apiItemName>complete</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Indicates whether there are additional rows that can
     be fetched or whether all data has been returned.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowID</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>If the statement was a SQL <codeph>INSERT</codeph> operation this is the new
     unique identifier for the row.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a SQLResult instance. Generally, developer code does not call the SQLResult
     constructor directly. To retrieve a SQLResult instance associated with a particular SQLStatement
     instance, call the instance's <codeph>getResult()</codeph> method. A SQLResult
	 instance is also passed as an argument to the result handler function when
	 a Responder instance is specified for an <codeph>execute()</codeph> or <codeph>next()</codeph>
	 method call.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLResult:complete:get"><apiName>complete</apiName><shortdesc>
     Indicates whether all the resulting data from a statement execution has been returned.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indicates whether all the resulting data from a statement execution has been returned.
     
     <p>When a statement returns one or more rows this property indicates
     whether all of the rows have been returned. When a SQLStatement object's <codeph>execute()</codeph>
     method is called with a <codeph>prefetch</codeph> argument value, only the specified number of
     rows of the resulting
     data are returned in the SQLResult object's <codeph>data</codeph> property. Subsequent calls
     to <codeph>SQLStatement.next()</codeph> cause additional data to become available. This property
     is used to determine when the final results have been returned.</p>
     
     <p>Note that because the number of rows is unknown at execution time, the database cursor must move beyond
     the last row before a statement's execution is considered complete. When the
	 <codeph>SQLStatement.execute()</codeph> method is called with a <codeph>prefetch</codeph> argument, at least one
	 row more than the total number of rows in the result set must be requested before
	 the resulting SQLResult instance's <codeph>complete</codeph> property is <codeph>true</codeph>.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:data:get"><apiName>data</apiName><shortdesc>
     The data returned as a result of the statement execution, specifically when
     a SQL SELECT statement is executed.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     The data returned as a result of the statement execution, specifically when
     a SQL <codeph>SELECT</codeph> statement is executed.
     
     <p>When a statement returns one or more rows this property is an array containing objects 
	 that represent the rows of result data. Each object in the array has 
     property names that correspond to the result data set's column names.</p>
	 
	 <p>For example, suppose you execute the following SQL <codeph>SELECT</codeph> statement:</p>
	 
	 <codeblock>
	 SELECT lastName, firstName
	 FROM employees
	 </codeblock>
	 
	 <p>Assuming the <codeph>employees</codeph> table contains 10 rows, the 
	 <codeph>SQLResult.data</codeph> property is an Array with 10 elements. Each element 
	 is an object with two properties, <codeph>lastName</codeph> and <codeph>firstName</codeph>.</p>
	 
	 <p>The situation is more complex when you are using a <codeph>SELECT</codeph> statement
	 with a complex result column, such as an aggregate function. For example,
	 suppose you execute the following SQL:</p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary)
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>In the results from this statement, each object in the <codeph>data</codeph> Array has 
	 two properties named <codeph>departmentId</codeph> and <codeph>SUM(salary)</codeph>. However, 
	 "SUM(salary)" is not a valid identifier. If you are using a computed column such as an 
	 aggregate or other function, specify an alias for the computed column in your SQL 
	 statement. The alias is used as the property name in the result data objects. For 
	 example, consider this alternative to the previous statement:</p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary) AS salarySubtotal
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>In this statement's <codeph>data</codeph> array, the result objects have two 
	 properties named <codeph>departmentId</codeph> and <codeph>salarySubtotal</codeph>.</p>
	 
	 <p>The <codeph>data</codeph> property is always an Array regardless of how many rows
	 and columns are in the result set. For example, the following <codeph>SELECT</codeph> statement
	 results in one row and one column, which is essentially a single value:</p>
	 
	 <codeblock>
	 SELECT COUNT(~~) AS numEmployees
	 FROM employees
	 </codeblock>
	 
	 <p>After executing the query the <codeph>data</codeph> property contains an Array object
	 with one element. That element is an object with a single property, 
	 <codeph>numEmployees</codeph>.</p>
	 
	 <p>If there are duplicate column names in the result data, for example if the 
	 <codeph>SELECT</codeph> statement includes an two different <codeph>id</codeph> columns 
	 from two different tables, the duplicate names are given property names according 
	 to the value of the <codeph>SQLConnection.columnNameStyle</codeph> property. By default, 
	 each column's name is used as the property name, but if there is are multiple columns 
	 in the result set with the same name, the long name format 
	 <codeph>[table-name]_[column-name]</codeph> is used for the identically named columns. 
	 This behavior can be changed by setting the <codeph>SQLConnection.columnNameStyle</codeph> 
	 property.</p>
	 
	 <p>By default the objects in the <codeph>data</codeph> Array are Object instances. 
	 However, by setting the value of the <codeph>SQLStatement.itemClass</codeph> property 
	 to a class, the <codeph>data</codeph> Array elements are created as instances of 
	 that class instead. For every column in the result data set, the 
	 <codeph>itemClass</codeph> class must have a property whose name exactly matches the 
	 column name.</p> 
	 
	 <p>If a statement does not return any data this property is <codeph>null</codeph>. 
	 This is the case if the statement is not a <codeph>SELECT</codeph> statement, or if 
	 it is a <codeph>SELECT</codeph> statement that returns 0 rows.</p>
     
	 </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> The following code demonstrates using the <codeph>itemClass</codeph> property 
 to have the runtime create instances of a custom class from SQL <codeph>SELECT</codeph> statement
 results.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>SQLConnection.columnNameStyle</linktext></link><link href="flash.data.xml#SQLStatement/itemClass"><linktext>SQLStatement.itemClass</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     The last generated row identifier generated by a SQL INSERT
	 statement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The last generated row identifier generated by a SQL <codeph>INSERT</codeph>
	 statement.
	 
     <p>The value is 0 if the executed statement was not an
	 <codeph>INSERT</codeph> statement.</p>
	 
	 <p>A row identifier is used to uniquely identify a row in a table within
     the database. The value is frequently generated by the database.</p>
	 
	 <p>For more information about primary keys and generated row identifiers,
	 see the "<xref href="../../localDatabaseSQLSupport.html#createTable">CREATE TABLE</xref>" and
	 "<xref href="../../localDatabaseSQLSupport.html#expressions">Expressions</xref>" sections in the appendix
	 "<xref href="../../localDatabaseSQLSupport.html">SQL support in local databases</xref>."</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/lastInsertRowID"><linktext>flash.data.SQLConnection.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:rowsAffected:get"><apiName>rowsAffected</apiName><shortdesc>
     Indicates how many rows were affected by the operation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates how many rows were affected by the operation.
     Only changes that are directly specified by an <codeph>INSERT</codeph>,
     <codeph>UPDATE</codeph>, or <codeph>DELETE</codeph> statement are counted.
     
     <p>Auxiliary changes caused by triggers are not counted.
     Use the <codeph>SQLConnection.totalChanges</codeph> property to find the total
     number of changes including changes caused by triggers.</p>
	 
	 <p>Note that when the related SQL operation is a <codeph>DELETE</codeph> statement
	 with no <codeph>WHERE</codeph> clause (that is, the statement deletes all the rows in the table),
	 the <codeph>rowsAffected</codeph> property is always 0, regardless of the number of rows
	 that were deleted. If you need to know the number of rows that are deleted, you can
	 include the <codeph>WHERE</codeph> clause <codeph>WHERE 1 = 1</codeph>, in which case all
	 the rows are deleted, and the <codeph>rowsAffected</codeph> property accurately
	 reflects the number of rows that were deleted. However, depending on the number of
	 rows being deleted, doing so may have a negative impact on the statement's performance.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/totalChanges"><linktext>flash.data.SQLConnection.totalChanges</linktext></link></related-links></apiValue></apiClassifier></apiPackage>