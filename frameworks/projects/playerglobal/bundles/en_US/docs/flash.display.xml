 
<apiPackage id="flash.display"><apiName>flash.display</apiName><apiDetail/><apiClassifier id="flash.display:FrameLabel"><apiName>FrameLabel</apiName><shortdesc>
	
	The FrameLabel object contains properties that specify a frame number and the 
	corresponding label name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	
	The FrameLabel object contains properties that specify a frame number and the 
	corresponding label name.
	The Scene class includes a <codeph>labels</codeph> property, which is an array 
	of FrameLabel objects for the scene. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Scene/labels"><linktext>Scene.labels</linktext></link><link href="flash.display.xml#MovieClip/currentLabel"><linktext>MovieClip.currentLabel</linktext></link><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:FrameLabel:frame:get"><apiName>frame</apiName><shortdesc>
		The frame number containing the label.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		The frame number containing the label.
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FrameLabel:name:get"><apiName>name</apiName><shortdesc>
		The name of the label.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		The name of the label.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
 The InteractiveObject class is the abstract base class for all display objects with which the user can 
 interact, using the mouse and keyboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 The InteractiveObject class is the abstract base class for all display objects with which the user can 
 interact, using the mouse and keyboard.
 
 <p>You cannot instantiate the InteractiveObject class directly. A call to the <codeph>new 
 InteractiveObject()</codeph> constructor throws an <codeph>ArgumentError</codeph> exception.</p>
 
 <p>The InteractiveObject class itself does not include any APIs for rendering content onscreen. 
 For that reason, if you want create a custom subclass of the InteractiveObject class, you will want
 to extend one of its subclasses that do have APIs for rendering content onscreen, 
 such as the Sprite, SimpleButton, TextField, or MovieClip class.</p>
 
 </apiDesc><example conref="examples\InteractiveObjectExample.as"> The following example uses the <codeph>InteractiveObjectExample</codeph> class, which in
 turn uses the <codeph>ChildSprite</codeph> class to draw a rectangle and then manipulate that rectangle
 based on various mouse events.  This task is accomplished by performing the following steps:
 <ol>
    <li>In the <codeph>InteractiveObjectExample</codeph> constructor, a new ChildSprite object of type Sprite
     called <codeph>child</codeph> is created, which calls the ChildSprite constructor method to draw the shape
     and add mouse events for the shape (as explained in the following steps).  The <codeph>child</codeph> 
     object is added to the top of the display list at coordinates <i>x = 0, y = 0</i>.  </li>
 
    <li>In the <codeph>ChildSprite</codeph> class, declare the <codeph>size</codeph> and
     <codeph>overSize</codeph> properties that are used later in the <codeph>draw()</codeph> method and 
     MouseEvent methods.</li>
 
     <li>Declare properties that set the background color to orange, the mouse-over color to
     dark yellow, and the mouse-down color to light blue.</li>
 
    <li>In the <codeph>ChildSprite</codeph> constructor, an orange square is drawn by using methods from
     the Graphics class and the <codeph>draw()</codeph> method.</li>
 
    <li>The constructor adds four MouseEvent event listener methods:
 
     <ul>
        <li><codeph>mouseOverHandler</codeph>: redraws a larger 60 x 60 pixel square with a dark-yellow color
         at the original coordinates.</li>
        <li><codeph>mouseOutHandler</codeph>: returns the square to its original size and color.</li>
        <li><codeph>mouseDownHandler</codeph>: redraws a larger 60 x 60 pixel square with a light-blue color
         at the original coordinates.</li>
        <li><codeph>mouseUpHandler</codeph>: same as <codeph>mouseOverHandler</codeph>.</li>
     </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class InteractiveObjectExample extends Sprite {

        public function InteractiveObjectExample() {
            var child:Sprite = new ChildSprite();
            addChild(child);
        }
    }
}

import flash.display.Sprite;
import flash.events.MouseEvent;

class ChildSprite extends Sprite {
    private var size:uint = 50;
    private var overSize:uint = 60;
    private var backgroundColor:uint = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;

    public function ChildSprite() {
        buttonMode = true;
        draw(size, size, backgroundColor);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
        addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
    }

    private function draw(w:uint, h:uint, bgColor:uint):void {
        graphics.clear();
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }

    public function mouseOverHandler(event:MouseEvent):void {
        trace("mouseOverHandler");
        draw(overSize, overSize, overColor);
    }

    public function mouseOutHandler(event:MouseEvent):void {
        trace("mouseOutHandler");
        draw(size, size, backgroundColor);
    }

    public function mouseDownHandler(event:MouseEvent):void {
        trace("mouseDownHandler");
        draw(overSize, overSize, downColor);
    }

    public function mouseUpHandler(event:MouseEvent):void {
        trace("mouseUpHandler");
        draw(overSize, overSize, overColor);
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.display:InteractiveObject_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 Dispatched when a user enters one or more 
 characters of text.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user enters one or more 
 characters of text. Various 
 text input methods can generate this event, including standard keyboards,
 input method editors (IMEs), voice or speech recognition systems, and even the act
 of pasting plain text with no formatting or style information.
 </apiDesc><example conref="examples\TextField_textInput.as"/></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CONTEXT_MENU_contextMenu"><apiName>contextMenu</apiName><shortdesc>
 Dispatched when a user gesture triggers the context menu associated with this interactive
 object in an AIR application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CONTEXT_MENU</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user gesture triggers the context menu associated with this interactive
 object in an AIR application.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>contextMenu</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE_nativeDragComplete"><apiName>nativeDragComplete</apiName><shortdesc>
 Dispatched by the drag initiator InteractiveObject when the user releases the drag gesture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by the drag initiator InteractiveObject when the user releases the drag gesture.
 
 <p>The event's dropAction property indicates the action set
 by the drag target object; a value of "none" (<codeph>DragActions.NONE</codeph>) 
 indicates that the drop was canceled or was not accepted.</p>
 
 <p>The <codeph>nativeDragComplete</codeph> event handler is a convenient place
 to update the state of the initiating display object, for example, by removing
 an item from a list (on an drag action of "move"), or by changing the visual
 properties.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE_nativeDragUpdate"><apiName>nativeDragUpdate</apiName><shortdesc>
 Dispatched during a drag operation by the InteractiveObject that is 
 specified as the drag initiator in the DragManager.doDrag() call.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched during a drag operation by the InteractiveObject that is 
 specified as the drag initiator in the DragManager.doDrag() call.
 
 <p><codeph>nativeDragUpdate</codeph> events are not dispatched on Linux.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_START_nativeDragStart"><apiName>nativeDragStart</apiName><shortdesc>
 Dispatched at the beginning of a drag operation by the InteractiveObject that is 
 specified as the drag initiator in the DragManager.doDrag() call.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_START</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched at the beginning of a drag operation by the InteractiveObject that is 
 specified as the drag initiator in the DragManager.doDrag() call.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_EXIT_nativeDragExit"><apiName>nativeDragExit</apiName><shortdesc>
 Dispatched by an InteractiveObject when a drag gesture leaves its boundary.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_EXIT</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by an InteractiveObject when a drag gesture leaves its boundary.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_DROP_nativeDragDrop"><apiName>nativeDragDrop</apiName><shortdesc>
 Dispatched by the target InteractiveObject when a dragged object is 
 dropped on it and the drop has been accepted with a call to
 DragManager.acceptDragDrop().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_DROP</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by the target InteractiveObject when a dragged object is 
 dropped on it and the drop has been accepted with a call to
 DragManager.acceptDragDrop().
 
 <p>Access the dropped data using the event object <codeph>clipboard</codeph>
 property.</p>
 
 <p>The handler for this event should set the <codeph>DragManager.dropAction</codeph>
 property to provide feedback to the initiator object about which drag action 
 was taken. If no value is set, the DragManager will select a default value 
 from the list of allowed actions.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_OVER_nativeDragOver"><apiName>nativeDragOver</apiName><shortdesc>
 Dispatched by an InteractiveObject continually while a drag gesture remains within its
 boundary.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_OVER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by an InteractiveObject continually while a drag gesture remains within its
 boundary.
 
 <p><codeph>nativeDragOver</codeph> events are dispatched whenever the mouse is moved. On Windows and
 Mac, they are also dispatched on a short timer interval even when the mouse has not moved.</p>
 
 <p>Handle either the <codeph>nativeDragOver</codeph> or <codeph>nativeDragEnter</codeph> 
 events to allow the display object to become the drop target.</p> 
 
 <p>To determine whether the dispatching display object can accept the drop,
 check the suitability of the data in <codeph>clipboard</codeph> property of 
 the event object, and the allowed drag actions in the <codeph>allowedActions</codeph> 
 property.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_ENTER_nativeDragEnter"><apiName>nativeDragEnter</apiName><shortdesc>
 Dispatched by an InteractiveObject when a drag gesture enters its boundary.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_ENTER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by an InteractiveObject when a drag gesture enters its boundary.
 
 <p>Handle either the <codeph>nativeDragEnter</codeph> or <codeph>nativeDragOver</codeph> 
 events to allow the display object to become the drop target.</p>
 
 <p>To determine whether the dispatching display object can accept the drop,
 check the suitability of the data in <codeph>clipboard</codeph> property of 
 the event object, and the allowed drag actions in the <codeph>allowedActions</codeph> 
 property.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_INDEX_CHANGE_tabIndexChange"><apiName>tabIndexChange</apiName><shortdesc>
 Dispatched when the value of the object's tabIndex property changes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_INDEX_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the value of the object's <codeph>tabIndex</codeph> property changes. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_ENABLED_CHANGE_tabEnabledChange"><apiName>tabEnabledChange</apiName><shortdesc>
 Dispatched when the object's tabEnabled flag changes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_ENABLED_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the object's <codeph>tabEnabled</codeph> flag changes. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_CHILDREN_CHANGE_tabChildrenChange"><apiName>tabChildrenChange</apiName><shortdesc>
 Dispatched when the value of the object's tabChildren flag changes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_CHILDREN_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the value of the object's <codeph>tabChildren</codeph> flag changes. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_UP_keyUp"><apiName>keyUp</apiName><shortdesc>
 Dispatched when the user releases a key.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_UP</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user releases a key. Mappings between keys and specific characters vary 
 by device and operating system. This event type is generated after such a mapping occurs 
 but before the processing of an input method editor (IME). IMEs are used to enter 
 characters, such as Chinese ideographs, that the standard QWERTY keyboard is 
 ill-equipped to produce. This event occurs after a <codeph>keyDown</codeph> event and has 
 the following characteristics:
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_DOWN_keyDown"><apiName>keyDown</apiName><shortdesc>
 Dispatched when the user presses a key.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_DOWN</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user presses a key. Mappings between keys and specific characters 
 vary by device and operating system. This event type is generated after such a mapping 
 occurs but before the processing of an input method 
 editor (IME). IMEs are used to enter characters, such as Chinese ideographs, that the standard QWERTY keyboard is ill-equipped 
 to produce. This event occurs before the <codeph>keyUp</codeph> event.
 
 <p>In AIR, canceling this event prevents the character from being entered into a text field.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
 Dispatched when a user releases the pointing device button over an 
 InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user releases the pointing device button over an 
 InteractiveObject instance. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
 Dispatched when a user presses the pointing device button over an InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user presses the pointing device button over an InteractiveObject instance. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
 Dispatched when a user presses and releases the right button of the user's 
 pointing device over the same InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user presses and releases the right button of the user's 
 pointing device over the same InteractiveObject. For a <codeph>rightClick</codeph> event to occur, it must always follow this series of 
 events in the order of occurrence: <codeph>rightMouseDown</codeph> event, then <codeph>rightMouseUp</codeph>. The target object 
 must be identical for both of these events; otherwise the <codeph>rightClick</codeph> event does not 
 occur. Any number of other mouse events can occur at any time between the 
 <codeph>rightMouseDown</codeph> or <codeph>rightMouseUp</codeph> events; the <codeph>rightClick</codeph> event 
 still occurs. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_UP_middleMouseUp"><apiName>middleMouseUp</apiName><shortdesc>
 Dispatched when a user releases the pointing device button over an 
 InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user releases the pointing device button over an 
 InteractiveObject instance. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_DOWN_middleMouseDown"><apiName>middleMouseDown</apiName><shortdesc>
 Dispatched when a user presses the middle pointing device button over an InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user presses the middle pointing device button over an InteractiveObject instance. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_CLICK_middleClick"><apiName>middleClick</apiName><shortdesc>
 Dispatched when a user presses and releases the middle button of the user's 
 pointing device over the same InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user presses and releases the middle button of the user's 
 pointing device over the same InteractiveObject. For a <codeph>middleClick</codeph> event to occur, it must always follow this series of 
 events in the order of occurrence: <codeph>middleMouseDown</codeph> event, then <codeph>middleMouseUp</codeph>. The target object 
 must be identical for both of these events; otherwise the <codeph>middleClick</codeph> event does not 
 occur. Any number of other mouse events can occur at any time between the 
 <codeph>middleMouseDown</codeph> or <codeph>middleMouseUp</codeph> events; the <codeph>middleClick</codeph> event 
 still occurs. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OVER_rollOver"><apiName>rollOver</apiName><shortdesc>
 Dispatched when the user moves a pointing device over an InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user moves a pointing device over an InteractiveObject instance. 
 The event target is the object under the pointing device or a parent of that object. 
 The <codeph>relatedObject</codeph> is the object that was previously under the pointing 
 device. The <codeph>rollOver</codeph> events are dispatched consecutively down the parent 
 chain of the object, starting with the highest parent that is neither the root 
 nor an ancestor of the <codeph>relatedObject</codeph> and ending with the object.
 <p>The purpose of the <codeph>rollOver</codeph> event is to simplify the coding of rollout behaviors for
 display object containers with children. When the mouse enters the area of a display 
 object or the area of any of its children from an object that is not one of its 
 children, the display object dispatches the <codeph>rollOver</codeph> event. This is different behavior 
 than that of the <codeph>mouseOver</codeph> event, which is dispatched each time the mouse 
 enters the area of any child object of the display object container, even if the mouse 
 was already over another child object of the display object container. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OUT_rollOut"><apiName>rollOut</apiName><shortdesc>
 Dispatched when the user moves a pointing device away from an InteractiveObject 
 instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user moves a pointing device away from an InteractiveObject 
 instance. The event target is the object previously under the pointing device or a parent of 
 that object. The <codeph>relatedObject</codeph> is the object that the pointing device has moved to. 
 The <codeph>rollOut</codeph> events are dispatched consecutively up the parent chain of the object, 
 starting with the object and ending with the highest parent that is neither the root nor an 
 ancestor of the <codeph>relatedObject</codeph>. 
 <p>The purpose of the <codeph>rollOut</codeph> event is to simplify the 
 coding of rollover behaviors for display object containers with children. When the mouse leaves 
 the area of a display object or the area of any of its children to go to an object that is not 
 one of its children, the display object dispatches the <codeph>rollOut</codeph> event. This is different behavior
 than that of the <codeph>mouseOut</codeph> event, which is dispatched each time the mouse leaves the 
 area of any child object of the display object container, even if the mouse remains over another 
 child object of the display object container.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_WHEEL_mouseWheel"><apiName>mouseWheel</apiName><shortdesc>
 Dispatched when a mouse wheel is spun over an InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_WHEEL</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a mouse wheel is spun over an InteractiveObject instance. 
 If the target is a text field, the text scrolls as the default behavior. 
 Only available on Microsoft Windows operating systems.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 Dispatched when a user releases the pointing device button over an 
 InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user releases the pointing device button over an 
 InteractiveObject instance. 
 If the target is a SimpleButton instance, the object displays the <codeph>upState</codeph> 
 display object. 
 If the target is a selectable text field, the text field ends selection as the default 
 behavior.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OVER_mouseOver"><apiName>mouseOver</apiName><shortdesc>
 Dispatched when the user moves a pointing device over an InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user moves a pointing device over an InteractiveObject instance. 
 The <codeph>relatedObject</codeph> is the object that was previously under 
 the pointing device.
 If the target is a SimpleButton instance, the object displays the <codeph>overState</codeph> 
 or <codeph>upState</codeph> display object, depending on whether the mouse button is down, as the default behavior.
 <p>The <codeph>mouseOver</codeph> event is dispatched each time the mouse enters the area of any child object of the display object container, 
 even if the mouse was already over another child object of the display object container. 
 This is different behavior than the purpose of the <codeph>rollOver</codeph> event, which is to simplify the coding of rollout behaviors for
 display object containers with children. When the mouse enters the area of a display object or the area of any of its children from an object 
 that is not one of its children, the display object dispatches the <codeph>rollOver</codeph> event.
 The <codeph>rollOver</codeph> events are dispatched consecutively down the parent chain of the object, 
 starting with the highest parent that is neither the root nor an ancestor of the <codeph>relatedObject</codeph> and ending with the object.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OUT_mouseOut"><apiName>mouseOut</apiName><shortdesc>
 Dispatched when the user moves a pointing device away from an InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user moves a pointing device away from an InteractiveObject instance. 
 The event target is the object previously under the pointing device. The <codeph>relatedObject</codeph> 
 is the object the pointing device has moved to. 
 If the target is a SimpleButton instance, the button displays the <codeph>upState</codeph> 
 display object as the default behavior.
 <p>The <codeph>mouseOut</codeph> event is dispatched each time the mouse leaves the 
 area of any child object of the display object container, even if the mouse remains over another 
 child object of the display object container. This is different behavior than the purpose of the <codeph>rollOut</codeph> event, which is to simplify the 
 coding of rollover behaviors for display object containers with children. When the mouse leaves 
 the area of a display object or the area of any of its children to go to an object that is not 
 one of its children, the display object dispatches the <codeph>rollOut</codeph> event.The <codeph>rollOut</codeph> events are dispatched consecutively 
 up the parent chain of the object, starting with the object and ending with the highest parent that is neither the root nor an 
 ancestor of the <codeph>relatedObject</codeph>.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_MOVE_mouseMove"><apiName>mouseMove</apiName><shortdesc>
 Dispatched when a user moves the pointing device while it is over an InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_MOVE</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user moves the pointing device while it is over an InteractiveObject. 
 If the target is a text field that the user is selecting, the selection is updated as the default behavior.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 Dispatched when a user presses the pointing device button over an InteractiveObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user presses the pointing device button over an InteractiveObject instance. 
 If the target is a SimpleButton instance, the SimpleButton instance displays the 
 <codeph>downState</codeph> display object as the default behavior. If the target is a 
 selectable text field, the text field begins selection as the default behavior.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.DOUBLE_CLICK_doubleClick"><apiName>doubleClick</apiName><shortdesc>
 Dispatched when a user presses and releases the main button of a pointing device twice in 
 rapid succession over the same InteractiveObject when that object's 
 doubleClickEnabled flag is set to true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.DOUBLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user presses and releases the main button of a pointing device twice in 
 rapid succession over the same InteractiveObject when that object's 
 <codeph>doubleClickEnabled</codeph> flag is set to <codeph>true</codeph>.
 For a <codeph>doubleClick</codeph> event to occur, it must immediately follow the following 
 series of events: <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>, <codeph>click</codeph>, 
 <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>. All of these events must share the same 
 target as the <codeph>doubleClick</codeph> event. The second click, represented by 
 the second <codeph>mouseDown</codeph> and <codeph>mouseUp</codeph> events, must occur within 
 a specific period of time after the <codeph>click</codeph> event. The allowable length of
 this period varies by operating system and can often be configured by the user. 
 If the target is a selectable text field, the word under the pointer is selected as the 
 default behavior. If the target InteractiveObject does not have its 
 <codeph>doubleClickEnabled</codeph> flag set to <codeph>true</codeph> it receives two 
 <codeph>click</codeph> events.  
 
 <p>The <codeph>doubleClickEnabled</codeph> property defaults 
 to <codeph>false</codeph>.  </p>
 
 <p>The double-click text selection behavior of a TextField object
 is not related to the <codeph>doubleClick</codeph> event. Use 
 <codeph>TextField.doubleClickEnabled</codeph> to control TextField selections.</p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/doubleClickEnabled"><linktext>doubleClickEnabled</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 Dispatched when a user presses and releases the main button of the user's 
 pointing device over the same InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a user presses and releases the main button of the user's 
 pointing device over the same InteractiveObject. For a click event to occur, it must always follow this series of 
 events in the order of occurrence: mouseDown event, then mouseUp. The target object 
 must be identical for both of these events; otherwise the <codeph>click</codeph> event does not 
 occur. Any number of other mouse events can occur at any time between the 
 <codeph>mouseDown</codeph> or <codeph>mouseUp</codeph> events; the <codeph>click</codeph> event 
 still occurs. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.MOUSE_FOCUS_CHANGE_mouseFocusChange"><apiName>mouseFocusChange</apiName><shortdesc>
 Dispatched when the user attempts to change focus by using a pointer device.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.MOUSE_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user attempts to change focus by using a pointer device. 
 The default behavior of this event is to change the focus and dispatch the corresponding 
 <codeph>focusIn</codeph> and <codeph>focusOut</codeph> events. 
 
 <p>This event is dispatched to the object that currently has focus. The related object for this event is the 
 InteractiveObject instance that receives focus if you do not prevent the default behavior. You can prevent the change in 
 focus by calling <codeph>preventDefault()</codeph> in an event listener that is properly registered with the target object. 
 The <codeph>shiftKey</codeph> property is not used. Focus changes and
 <codeph>focusIn</codeph> and <codeph>focusOut</codeph> events are dispatched by default.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.KEY_FOCUS_CHANGE_keyFocusChange"><apiName>keyFocusChange</apiName><shortdesc>
 Dispatched when the user attempts to change focus by using keyboard navigation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.KEY_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user attempts to change focus by using keyboard navigation. 
 The default behavior of this event is to change the focus and dispatch the 
 corresponding <codeph>focusIn</codeph> and <codeph>focusOut</codeph> events.
 
 <p>This event is dispatched to the object that currently has focus. 
 The related object for this event is the InteractiveObject instance that receives focus 
 if you do not prevent the default behavior. 
 You can prevent the change in focus by calling the <codeph>preventDefault()</codeph> method 
 in an event listener that is properly registered with the target object. 
 Focus changes and <codeph>focusIn</codeph> and <codeph>focusOut</codeph> 
 events are dispatched by default.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_OUT_focusOut"><apiName>focusOut</apiName><shortdesc>
 Dispatched after a display object loses focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_OUT</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched <i>after</i> a display object loses focus. 
 This happens when a user highlights a different object with a pointing device or keyboard navigation. 
 The object that loses focus is called the target object of this event, while the corresponding InteractiveObject 
 instance that receives focus is called the related object. A reference to the related object is stored in the target object's 
 <codeph>relatedObject</codeph> property. The <codeph>shiftKey</codeph> property is not used. This event precedes the dispatch 
 of the <codeph>focusIn</codeph> event by the related object.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_IN_focusIn"><apiName>focusIn</apiName><shortdesc>
 Dispatched after a display object gains focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_IN</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched <i>after</i> a display object gains focus. 
 This situation happens when a user highlights the object with a pointing device or keyboard navigation. 
 The recipient of such focus is called the target object of this event, 
 while the corresponding InteractiveObject instance that lost focus because of this change is called the related object.
 A reference to the related object is stored in the receiving object's <codeph>relatedObject</codeph> property. 
 The <codeph>shiftKey</codeph> property is not used. 
 This event follows the dispatch of the previous object's <codeph>focusOut</codeph> event.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.SELECT_ALL_selectAll"><apiName>selectAll</apiName><shortdesc>
 Dispatched when the user activates the platform specific accelerator key combination for a select all operation
 or selects 'Select All' from the text context menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT_ALL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user activates the platform specific accelerator key combination for a select all operation
 or selects 'Select All' from the text context menu.
 This event is dispatched to the object that currently has focus. 
 If the object that currently has focus is a TextField, the default behavior of this event is to cause
 all the contents of the text field to be selected. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.PASTE_paste"><apiName>paste</apiName><shortdesc>
 Dispatched when the user activates the platform specific accelerator key combination for a paste operation
 or selects 'Paste' from the text context menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.PASTE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user activates the platform specific accelerator key combination for a paste operation
 or selects 'Paste' from the text context menu.
 This event is dispatched to the object that currently has focus. 
 If the object that currently has focus is a TextField, the default behavior of this event is to cause
 the contents of the clipboard to be pasted into the text field at the current insertion point
 replacing any currently selected text in the text field. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CUT_cut"><apiName>cut</apiName><shortdesc>
 Dispatched when the user activates the platform specific accelerator key combination for a cut operation
 or selects 'Cut' from the text context menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CUT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user activates the platform specific accelerator key combination for a cut operation
 or selects 'Cut' from the text context menu.
 This event is dispatched to the object that currently has focus. 
 If the object that currently has focus is a TextField, the default behavior of this event is to cause
 any currently selected text in the text field to be cut to the clipboard. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.COPY_copy"><apiName>copy</apiName><shortdesc>
 Dispatched when the user activates the platform specific accelerator key combination for a copy operation
 or selects 'Copy' from the text context menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COPY</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user activates the platform specific accelerator key combination for a copy operation
 or selects 'Copy' from the text context menu. 
 This event is dispatched to the object that currently has focus. 
 If the object that currently has focus is a TextField, the default behavior of this event is to cause
 any currently selected text in the text field to be copied to the clipboard. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CLEAR_clear"><apiName>clear</apiName><shortdesc>
 Dispatched when the user selects 'Clear' (or 'Delete') from the text context menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLEAR</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the user selects 'Clear' (or 'Delete') from the text context menu. 
 This event is dispatched to the object that currently has focus. 
 If the object that currently has focus is a TextField, the default behavior of this event is to cause
 any currently selected text in the text field to be deleted. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:InteractiveObject:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
	Calling the new InteractiveObject() constructor 
	throws an ArgumentError exception.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Calling the <codeph>new InteractiveObject()</codeph> constructor 
	throws an <codeph>ArgumentError</codeph> exception. 
	You can, however, call constructors for the following subclasses of InteractiveObject:
	
	<ul>
	
		<li><codeph>new SimpleButton()</codeph></li>
		<li><codeph>new TextField()</codeph></li>
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:InteractiveObject:contextMenu:get"><apiName>contextMenu</apiName><shortdesc> 
	 Specifies the context menu associated with this object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier><apiTipTexts><apiTipText>The context menu associated with this object
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Specifies the context menu associated with this object.
	 
	 <p>For content running in Flash Player, this property is a ContextMenu object. In the AIR runtime, 
	 the ContextMenu class extends the NativeMenu class, however Flash Player only supports the 
	 ContextMenu class, not the NativeMenu class.
	 </p>
	 
	 <p><b>Note:</b> TextField objects always include a clipboard menu in the context menu. The clipboard menu contains
	 Cut, Copy, Paste, Clear, and Select All commands. You cannot remove these commands from the context menu for TextField objects. 
	 For TextField objects, selecting these commands (or their keyboard equivalents) does not generate <codeph>clear</codeph>, 
	 <codeph>copy</codeph>, <codeph>cut</codeph>, <codeph>paste</codeph>, or <codeph>selectAll</codeph> events.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:doubleClickEnabled:get"><apiName>doubleClickEnabled</apiName><shortdesc> 
	 Specifies whether the object receives doubleClick events.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Whether this object receives double click messages.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Specifies whether the object receives <codeph>doubleClick</codeph> events. The default value 
	 is <codeph>false</codeph>, which means that by default an InteractiveObject instance does not receive
	 <codeph>doubleClick</codeph> events. If the <codeph>doubleClickEnabled</codeph> property is set to 
	 <codeph>true</codeph>, the instance receives <codeph>doubleClick</codeph> events within its bounds. 
	 The <codeph>mouseEnabled</codeph> property of the InteractiveObject instance must also be 
	 set to <codeph>true</codeph> for the object to receive <codeph>doubleClick</codeph> events.
	 
	 <p>No event is dispatched by setting this property. You must use the
	 <codeph>addEventListener()</codeph> method to add an event listener 
	 for the <codeph>doubleClick</codeph> event.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InteractiveObject/event:doubleClick"><linktext>doubleClick</linktext></link><link href="flash.display.xml#InteractiveObject/mouseEnabled"><linktext>mouseEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:focusRect:get"><apiName>focusRect</apiName><shortdesc> 
	 Specifies whether this object displays a focus rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip._focusRect, Button._focusRect, and 
	 _focusRect (global property) topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc> 
	 Specifies whether this object displays a focus rectangle. It can take one of three 
	 values: <codeph>true</codeph>, <codeph>false</codeph>, or <codeph>null</codeph>. Values of <codeph>true</codeph> 
	 and <codeph>false</codeph> work as expected, specifying whether or not the focus rectangle 
	 appears. A value of <codeph>null</codeph> indicates that this object obeys the 
	 <codeph>stageFocusRect</codeph> property of the Stage.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:mouseEnabled:get"><apiName>mouseEnabled</apiName><shortdesc> 
	 Specifies whether this object receives mouse messages.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 Specifies whether this object receives mouse messages. The default value is <codeph>true</codeph>,
	 which means that by default any InteractiveObject instance that is on the display list
	 receives mouse events.
	 If <codeph>mouseEnabled</codeph> is set to <codeph>false</codeph>, the instance does not receive any
	 mouse events. Any children of this instance on the display list are not affected. To change
	 the <codeph>mouseEnabled</codeph> behavior for all children of an object on the display list, use
	 <codeph>flash.display.DisplayObjectContainer.mouseChildren</codeph>.
	 <p> No event is dispatched by setting this property. You must use the 
	 <codeph>addEventListener()</codeph> method to create interactive functionality.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:tabEnabled:get"><apiName>tabEnabled</apiName><shortdesc> 
	 Specifies whether this object is in the tab order.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip.tabEnabled, Button.tabEnabled, and 
	 TextField.tabEnabled topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Whether this object is in the tab order.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Specifies whether this object is in the tab order. If this object is in the tab order, 
	 the value is <codeph>true</codeph>; otherwise, the value is <codeph>false</codeph>. By default,
     the value is <codeph>false</codeph>, except for the following:
     <ul><li>For a SimpleButton object, the value is <codeph>true</codeph>.</li>
     <li>For a TextField object with <codeph>type = "input"</codeph>, the value is <codeph>true</codeph>.</li>
     <li>For a Sprite object or MovieClip object with <codeph>buttonMode = true</codeph>, the value is <codeph>true</codeph>.</li></ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:tabIndex:get"><apiName>tabIndex</apiName><shortdesc> 
   	 Specifies the tab ordering of objects in a SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>The tab index for this object.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
   	 Specifies the tab ordering of objects in a SWF file. The <codeph>tabIndex</codeph> 
	 property is -1 by default, meaning no tab index is set for the object.
	 
   	 <p>If any currently displayed object in the SWF file contains a <codeph>tabIndex</codeph> property, automatic 
	 tab ordering is disabled, and the tab ordering is calculated from the <codeph>tabIndex</codeph> properties of 
	 objects in the SWF file. The custom tab ordering includes only objects that have <codeph>tabIndex</codeph> 
	 properties.</p>
	 
   	 <p>The <codeph>tabIndex</codeph> property can be a non-negative integer. The objects are ordered according to 
	 their <codeph>tabIndex</codeph> properties, in ascending order. An object with a <codeph>tabIndex</codeph> 
     value of 1 precedes an object with a <codeph>tabIndex</codeph> value of 2. Do not use the same <codeph>tabIndex</codeph> 

	 value for multiple objects.</p>
	 
	 <p>The custom tab ordering that the <codeph>tabIndex</codeph> property defines is <i>flat</i>. 
	 This means that no attention is paid to the hierarchical relationships of objects in the SWF file. 
	 All objects in the SWF file with <codeph>tabIndex</codeph> properties are placed in the tab order, and the 
	 tab order is determined by the order of the <codeph>tabIndex</codeph> values. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
 Defines an ordered set of triangles that can be rendered using 
 either (u,v) fill coordinates or a normal fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines an ordered set of triangles that can be rendered using 
 either (u,v) fill coordinates or a normal fill.
 
 Each triangle in the path is represented by three sets of (x, y) 
 coordinates, each of which is one point of the triangle.
 
 <p>
 The triangle vertices do not contain z coordinates and do not necessarily
 represent 3D faces. However a triangle path can be used to support the rendering
 of 3D geometry in a 2D space.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsTrianglePath:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
     Creates a new GraphicsTrianglePath object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>A Vector of Numbers where each pair of numbers is treated as a point (an x, y pair). Required.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>A Vector of integers or indexes, where every three indexes define a triangle. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>A Vector of normalized coordinates used to apply texture mapping.
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Specifies whether to render triangles that face in a given direction. Used to 
                     prevent the rendering of triangles that cannot be seen in the current view. 
                     Can be set to any value defined by the TriangleCulling class.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new GraphicsTrianglePath object.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsTrianglePath/culling"><linktext>culling</linktext></link><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsTrianglePath:indices"><apiName>indices</apiName><shortdesc>
     A Vector of integers or indexes, where every three indexes define a triangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     A Vector of integers or indexes, where every three indexes define a triangle. If the indexes parameter
     is null then every three vertices (six x,y pairs in the vertices Vector) defines a triangle. 
     Otherwise each index refers to a vertex, which is a pair of numbers in the vertices Vector. 
     For example <codeph>indexes[1]</codeph> refers to (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>). 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:uvtData"><apiName>uvtData</apiName><shortdesc>
     A Vector of normalized coordinates used to apply texture mapping.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     A Vector of normalized coordinates used to apply texture mapping.
     Each coordinate refers to a point on the bitmap used for the fill. 
     There must be one UV or one UVT coordinate per vertex.
     
     <p>
     In UV coordinates, (0,0) is the upper left of the bitmap, and (1,1) is the lower right of the bitmap. 
     </p>
                    
     <p>
     If the length of this vector is twice the length of the <codeph>vertices</codeph> vector then normalized 
     coordinates are used without perspective correction.
     </p>
     
     <p>
     If the length of this vector is three times the length of the <codeph>vertices</codeph> vector then the 
     third coordinate is interpreted as 't', the distance from the eye to the texture in eye space. 
     This helps the rendering engine correctly apply perspective when mapping textures in 3D.
     </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:vertices"><apiName>vertices</apiName><shortdesc>
     A Vector of Numbers where each pair of numbers is treated as a point (an x, y pair).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     A Vector of Numbers where each pair of numbers is treated as a point (an x, y pair).
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:culling:get"><apiName>culling</apiName><shortdesc>
     Specifies whether to render triangles that face in a given direction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies whether to render triangles that face in a given direction. Used to 
     prevent the rendering of triangles that cannot be seen in the current view. 
     <p>
     Can be set to any value defined by the TriangleCulling class.
     </p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObject"><apiName>DisplayObject</apiName><shortdesc>
 The DisplayObject class is the base class for all objects that can be placed on 
 the display list.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 The DisplayObject class is the base class for all objects that can be placed on 
 the display list. The display list manages all objects displayed in Flash Player or Adobe AIR. 
 Use the DisplayObjectContainer class to arrange the display objects in the display list.
 DisplayObjectContainer objects can have child display objects, while other display objects, such as
 Shape and TextField objects, are "leaf" nodes that have only parents and siblings, no children. 
 
 <p>The DisplayObject class supports basic functionality like the <i>x</i> and <i>y</i> position of 
 an object, as well as more advanced properties of the object such as its transformation matrix. 
 </p>
 
 <p>DisplayObject is an abstract base class; therefore, you cannot call DisplayObject directly. Invoking
 <codeph>new DisplayObject()</codeph> throws an <codeph>ArgumentError</codeph> exception. </p>
 
 <p>All display objects inherit from the DisplayObject class.</p>
 
 <p>The DisplayObject class itself does not include any APIs for rendering content onscreen. 
 For that reason, if you want create a custom subclass of the DisplayObject class, you will want
 to extend one of its subclasses that do have APIs for rendering content onscreen, 
 such as the Shape, Sprite, Bitmap, SimpleButton, TextField, or MovieClip class.</p>
 
 <p>The DisplayObject class contains several broadcast events. Normally, the target
 of any particular event is a specific DisplayObject instance. For example,
 the target of an <codeph>added</codeph> event is the specific DisplayObject instance
 that was added to the display list. Having a single target restricts the placement of
 event listeners to that target and in some cases the target's ancestors on the display list.
 With broadcast events, however, the target is not a specific DisplayObject instance,
 but rather all DisplayObject instances, including those that are not on the display list.
 This means that you can add a listener to any DisplayObject instance to listen for broadcast events.
 In addition to the broadcast events listed in the DisplayObject class's Events table,
 the DisplayObject class also inherits two broadcast events from the EventDispatcher
 class: <codeph>activate</codeph> and <codeph>deactivate</codeph>.</p>
 
 <p>Some properties previously used in the ActionScript 1.0 and 2.0 MovieClip, TextField, and Button
 classes (such as <codeph>_alpha</codeph>, <codeph>_height</codeph>, <codeph>_name</codeph>, <codeph>_width</codeph>,
 <codeph>_x</codeph>, <codeph>_y</codeph>, and others) have equivalents in the ActionScript 3.0
 DisplayObject class that are renamed so that they no longer begin with the underscore (_) character.</p>
 
 <p>For more information, see the "Display Programming" chapter of the <i>Programming 
 ActionScript 3.0</i> book.</p>
 
 </apiDesc><example conref="examples\DisplayObjectExample.as"> The following example uses the <codeph>DisplayObjectExample</codeph> class to
 draw an orange square in the corner of the Stage and then respond to events by displaying text
 information for each event.  This task is accomplished by performing the following steps:
 <ol>
    <li>Class properties are declared for the color and size of the square.</li>
     <li>The constructor calls the <codeph>draw()</codeph> method, which draws an orange square on
     the Stage at the default coordinates of <i>x = 0, y = 0</i>.</li>
    <li>The following event listener methods are attached to the square:
     <ul>
        <li><codeph>addedHandler()</codeph> listens for <codeph>added</codeph> events, dispatched when the
         square is added to the display list.</li>
        <li><codeph>enterFrameHandler()</codeph> listens for <codeph>enterFrame</codeph> events, which have no
         real meaning in this example.</li>
        <li><codeph>removedHandler()</codeph> listens for <codeph>removed</codeph> events, dispatched when
         the square is removed from the display list, which happens when the square is clicked.</li>
        <li><codeph>clickHandler()</codeph> listens for <codeph>click</codeph> events, dispatched when the
         orange square is clicked.</li>
        <li><codeph>renderHandler()</codeph> listens for <codeph>render</codeph> events after the display
         list is updated.</li>
  </ul></li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class DisplayObjectExample extends Sprite {
        public function DisplayObjectExample() {
            var child:CustomDisplayObject = new CustomDisplayObject();
            addChild(child);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.events.*;

class CustomDisplayObject extends Sprite {
    private var bgColor:uint = 0xFFCC00;
    private var size:uint    = 80;

    public function CustomDisplayObject() {
        draw();
        addEventListener(Event.ADDED, addedHandler);
        addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        addEventListener(Event.REMOVED, removedHandler);
        addEventListener(MouseEvent.CLICK, clickHandler);
        addEventListener(Event.RENDER, renderHandler);
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }

    private function clickHandler(event:MouseEvent):void {
        trace("clickHandler: " + event);
        parent.removeChild(this);
    }

    private function addedHandler(event:Event):void {
        trace("addedHandler: " + event);
        stage.scaleMode = StageScaleMode.NO_SCALE;
        stage.align = StageAlign.TOP_LEFT;
        stage.addEventListener("resize", resizeHandler);
    }

    private function enterFrameHandler(event:Event):void {
        trace("enterFrameHandler: " + event);
        removeEventListener("enterFrame", enterFrameHandler);
    }

    private function removedHandler(event:Event):void {
        trace("removedHandler: " + event);
        stage.removeEventListener("resize", resizeHandler);
    }

    private function renderHandler(event:Event):void {
        trace("renderHandler: " + event);
    }

    private function resizeHandler(event:Event):void {
        trace("resizeHandler: " + event);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.RENDER_render"><apiName>render</apiName><shortdesc>
 [broadcast event] Dispatched when the display list is about to be updated and rendered.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RENDER</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Dispatched when the display list is about to be updated and rendered. This event provides the last opportunity 
 for objects listening for this event to make changes before the display list is rendered. 
 You must call the <codeph>invalidate()</codeph> method 
 of the Stage object 
 each time you want a <codeph>render</codeph> event to be dispatched. <codeph>Render</codeph> events 
 are dispatched to an object only if there is mutual trust between it and the object that called 
 <codeph>Stage.invalidate()</codeph>.
 This event is a broadcast event, which means that it is dispatched 
 by all display objects with a listener registered for this event.
 
 <p><b>Note: </b>This event is not dispatched if the display is 
 not rendering. This is the case when the content is either minimized or obscured. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_FROM_STAGE_removedFromStage"><apiName>removedFromStage</apiName><shortdesc>
 Dispatched when a display object is about to be removed from the display list, 
 either directly or through the removal of a sub tree in which the display object is contained.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED_FROM_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a display object is about to be removed from the display list, 
 either directly or through the removal of a sub tree in which the display object is contained. 
 Two methods of the DisplayObjectContainer class generate this event: 
 <codeph>removeChild()</codeph> and <codeph>removeChildAt()</codeph>. 
 
 <p>The following methods of a DisplayObjectContainer object also generate this event if an object must be removed 
 to make room for the new object:  <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph>, and 
 <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_removed"><apiName>removed</apiName><shortdesc>
 Dispatched when a display object is about to be removed from the display list.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a display object is about to be removed from the display list. 
 Two methods of the DisplayObjectContainer class generate this event: 
 <codeph>removeChild()</codeph> and <codeph>removeChildAt()</codeph>. 
 
 <p>The following methods of a DisplayObjectContainer object also generate this event if an object must be removed 
 to make room for the new object:  <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph>, and 
 <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.EXIT_FRAME_exitFrame"><apiName>exitFrame</apiName><shortdesc>
 [broadcast event] Dispatched when the playhead is exiting the current frame.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXIT_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Dispatched when the playhead is exiting the current frame. 
 All frame scripts have been run. If the playhead is not moving, or if there is only one frame, this event
 is dispatched continuously in conjunction with the frame rate. 
 This event is a broadcast event, which means that it is dispatched 
 by all display objects with a listener registered for this event.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.FRAME_CONSTRUCTED_frameConstructed"><apiName>frameConstructed</apiName><shortdesc>
 [broadcast event] Dispatched after the constructors of frame display objects have run but before frame scripts have run.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.FRAME_CONSTRUCTED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Dispatched after the constructors of frame display objects have run but before frame scripts have run. 
 If the playhead is not moving, or if there is only one frame, this event
 is dispatched continuously in conjunction with the frame rate. 
 This event is a broadcast event, which means that it is dispatched 
 by all display objects with a listener registered for this event.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ENTER_FRAME_enterFrame"><apiName>enterFrame</apiName><shortdesc>
 [broadcast event] Dispatched when the playhead is entering a new 
 frame.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ENTER_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [broadcast event] Dispatched when the playhead is entering a new 
 frame. If the playhead is not moving, or if there is only one frame, this event
 is dispatched continuously in conjunction with the frame rate. 
 This event is a broadcast event, which means that it is dispatched 
 by all display objects with a listener registered for this event.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_TO_STAGE_addedToStage"><apiName>addedToStage</apiName><shortdesc>
 Dispatched when a display object is added to the on stage display list, 
 either directly or through the addition of a sub tree in which the display object is contained.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED_TO_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a display object is added to the on stage display list, 
 either directly or through the addition of a sub tree in which the display object is contained. The 
 following methods trigger this event: <codeph>DisplayObjectContainer.addChild()</codeph>, 
 <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_added"><apiName>added</apiName><shortdesc>
 Dispatched when a display object is added to the display list.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a display object is added to the display list. The 
 following methods trigger this event: <codeph>DisplayObjectContainer.addChild()</codeph>, 
 <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:DisplayObject:getBounds"><apiName>getBounds</apiName><shortdesc>
     Returns a rectangle that defines the area of the display object relative to the coordinate system
     of the targetCoordinateSpace object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The rectangle that defines the area of the display object relative to
     the <codeph>targetCoordinateSpace</codeph> object's coordinate system.
     
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The display object that defines the coordinate system to use.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Returns a rectangle that defines the area of the display object relative to the coordinate system
     of the <codeph>targetCoordinateSpace</codeph> object.
     Consider the following code, which shows how the rectangle returned can vary depending on the
     <codeph>targetCoordinateSpace</codeph> parameter that you pass to the method:
     
     <codeblock>
     var container:Sprite = new Sprite();
     container.x = 100;
     container.y = 100;
     this.addChild(container);
     var contents:Shape = new Shape();
     contents.graphics.drawCircle(0,0,100);
     container.addChild(contents);
     trace(contents.getBounds(container));
      // (x=-100, y=-100, w=200, h=200)
     trace(contents.getBounds(this));
      // (x=0, y=0, w=200, h=200)
     </codeblock>
     
     
     <p><b>Note:</b> Use the <codeph>localToGlobal()</codeph> and
     <codeph>globalToLocal()</codeph> methods to convert the display object's local coordinates
     to display coordinates, or display coordinates to local coordinates, respectively.</p>
     
     <p>The <codeph>getBounds()</codeph> method is similar to the <codeph>getRect()</codeph> method; 
     however, the Rectangle returned by the <codeph>getBounds()</codeph> method includes any strokes 
     on shapes, whereas the Rectangle returned by the <codeph>getRect()</codeph> method does not. 
     For an example, see the description of the <codeph>getRect()</codeph> method.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getRect()"><linktext>getRect()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:getRect"><apiName>getRect</apiName><shortdesc>
    Returns a rectangle that defines the boundary of the display object, 
    based on the coordinate system defined by the targetCoordinateSpace 
    parameter, excluding any strokes on shapes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The rectangle that defines the area of the display object relative to
    the <codeph>targetCoordinateSpace</codeph> object's coordinate system.
    
    </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The display object that defines the coordinate system to use.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Returns a rectangle that defines the boundary of the display object, 
    based on the coordinate system defined by the <codeph>targetCoordinateSpace</codeph> 
    parameter, excluding any strokes on shapes. The values that the <codeph>getRect()</codeph> method
    returns are the same or smaller than those returned by the <codeph>getBounds()</codeph> method.
    
    <p><b>Note:</b> Use <codeph>localToGlobal()</codeph> and <codeph>globalToLocal()</codeph> methods 
    to convert the display object's local coordinates to Stage coordinates, or Stage coordinates to 
    local coordinates, respectively.</p>
    
    </apiDesc><example conref="examples\DisplayObject.getRect.1.as"> The following example shows how the <codeph>getBounds()</codeph> method can return a larger
 rectangle than the <codeph>getRect()</codeph> method does, because of the additional area taken up by
 strokes. In this case, the <codeph>triangle</codeph> sprite includes extra strokes because of the
 <codeph>width</codeph> and <codeph>jointStyle</codeph> parameters of the <codeph>lineStyle()</codeph>
 method. The <codeph>trace()</codeph> output (in the last two lines) shows the differences between
 the <codeph>getRect()</codeph> and <codeph>getBounds()</codeph> rectangles:
<codeblock>

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.geom.Rectangle;

var triangle:Sprite = new Sprite();
var color:uint = 0xFF0044;
var width:Number = 20;
var alpha:Number = 1.0;
var pixelHinting:Boolean = true;
var scaleMode:String = LineScaleMode.NORMAL;
var caps:String = CapsStyle.SQUARE;
var joints:String = JointStyle.MITER;
triangle.graphics.lineStyle(width, color, alpha, pixelHinting, scaleMode, caps, joints);

var triangleSide:Number = 100;
triangle.graphics.moveTo(0, 0);
triangle.graphics.lineTo(0, triangleSide);
triangle.graphics.lineTo(triangleSide, triangleSide);
triangle.graphics.lineTo(0, 0);

addChild(triangle);

trace(triangle.getBounds(this)); // (x=-10, y=-24.1, w=134.10000000000002, h=134.1)
trace(triangle.getRect(this));     // (x=0, y=0, w=100, h=100)
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getBounds()"><linktext>getBounds()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal"><apiName>globalToLocal</apiName><shortdesc>
     Converts the point object from the Stage (global) coordinates
     to the display object's (local) coordinates.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Point object with coordinates relative to the display object.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>An object created with the Point class. The Point object
     specifies the <i>x</i> and <i>y</i> coordinates as properties.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Converts the <codeph>point</codeph> object from Stage (global) coordinates to the display
     object's (local) coordinates.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Converts the <codeph>point</codeph> object from the Stage (global) coordinates
     to the display object's (local) coordinates.
     
     <p>To use this method, first create an instance of the Point class. The
     <i>x</i> and <i>y</i> values that you assign represent global coordinates because they
     relate to the origin (0,0) of the main display area. Then pass the Point instance
     as the parameter to the <codeph>globalToLocal()</codeph> method. The method returns a new Point object with
     <i>x</i> and <i>y</i> values that relate to the origin of the display object
     instead of the origin of the Stage.</p>
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> The following code creates a Shape object and shows the
 result of calling the <codeph>hitTestPoint()</codeph> method, using different
 points as parameters. The <codeph>globalToLocal()</codeph> method converts the 
 point from Stage coordinates to the coordinate space of the shape:
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point class</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal3D"><apiName>globalToLocal3D</apiName><shortdesc>
     Converts a two-dimensional point from the Stage (global) coordinates to a
     three-dimensional display object's (local) coordinates.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Vector3D object with coordinates relative to the three-dimensional
     display object. 
     
     </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>A two dimensional Point object representing global x and y coordinates.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Converts a two-dimensional point from the Stage (global) coordinates to a
     three-dimensional display object's (local) coordinates.
     
     <p>To use this method, first create an instance of the Point class. 
     The x and y values that you assign to the Point object represent global 
     coordinates because they are relative to the origin (0,0) of the main display area. 
     Then pass the Point object to the <codeph>globalToLocal3D()</codeph> 
     method as the <codeph>point</codeph> parameter. The method returns three-dimensional 
     coordinates as a Vector3D object containing <codeph>x</codeph>, <codeph>y</codeph>, and 
     <codeph>z</codeph> values that are relative to the origin 
     of the three-dimensional display object.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestObject"><apiName>hitTestObject</apiName><shortdesc>
     Evaluates the bounding box of the display object to see if it overlaps or intersects with the
     bounding box of the obj display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if the bounding boxes of the display objects intersect; <codeph>false</codeph> if not.
     
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The display object to test against.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Evaluates the bounding box of the display object to see if it overlaps or intersects with the
     bounding box of the display object passed as a parameter.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Evaluates the bounding box of the display object to see if it overlaps or intersects with the
     bounding box of the <codeph>obj</codeph> display object.
     
     </apiDesc><example conref="examples\DisplayObject.hitTestObject.1.as"> The following code creates three Shape objects and shows the
 result of calling the <codeph>hitTestObject()</codeph> method. Note that although
 circle2 and circle3 do not overlap, their bounding boxes do. Thus, the hit test
 of circle2 and circle3 returns <codeph>true</codeph>.
<codeblock>

import flash.display.Shape;

var circle1:Shape = new Shape();
circle1.graphics.beginFill(0x0000FF);
circle1.graphics.drawCircle(40, 40, 40);
addChild(circle1);

var circle2:Shape = new Shape();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(40, 40, 40);
circle2.x = 50;
addChild(circle2);

var circle3:Shape = new Shape();
circle3.graphics.beginFill(0xFF0000);
circle3.graphics.drawCircle(40, 40, 40);
circle3.x = 100;
circle3.y = 67;
addChild(circle3);

trace(circle1.hitTestObject(circle2)); // true
trace(circle1.hitTestObject(circle3)); // false
trace(circle2.hitTestObject(circle3)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestPoint"><apiName>hitTestPoint</apiName><shortdesc>
     Evaluates the display object to see if it overlaps or intersects with the
     point specified by the x and y parameters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if the display object overlaps or intersects with the specified point;
     <codeph>false</codeph> otherwise.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>x</i> coordinate to test against this object.
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>y</i> coordinate to test against this object.
     
     </apiDesc></apiParam><apiParam><apiItemName>shapeFlag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Whether to check against the actual pixels of the object (<codeph>true</codeph>)
     or the bounding box (<codeph>false</codeph>). 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Evaluates the display object to see if it overlaps or intersects with a point specified
     by x and y.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Evaluates the display object to see if it overlaps or intersects with the
     point specified by the <codeph>x</codeph> and <codeph>y</codeph> parameters.
     The <codeph>x</codeph> and <codeph>y</codeph> parameters specify a point in the 
     coordinate space of the Stage, not the display object container that contains the 
     display object (unless that display object container is the Stage).
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> The following code creates a Shape object and shows the
 result of calling the <codeph>hitTestPoint()</codeph> method, using different
 points as parameters. The <codeph>globalToLocal()</codeph> method converts the 
 point from Stage coordinates to the coordinate space of the shape:
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:local3DToGlobal"><apiName>local3DToGlobal</apiName><shortdesc>
     Converts a three-dimensional point of the three-dimensional display 
     object's (local) coordinates to a two-dimensional point in the Stage (global) coordinates.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A two-dimensional point representing a three-dimensional point
     in two-dimensional space.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point3d</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>A Vector3D object containing either a three-dimensional point or 
     the coordinates of the three-dimensional display object.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Converts a three-dimensional point of the three-dimensional display 
     object's (local) coordinates to a two-dimensional point in the Stage (global) coordinates.
     
     <p>For example, you can only use two-dimensional coordinates (x,y) to
     draw with the <codeph>display.Graphics</codeph> methods. To draw a three-dimensional
     object, you need to map the three-dimensional coordinates of a
     display object to two-dimensional coordinates. First, create an instance of 
     the Vector3D class that holds the x-, y-, and z- coordinates of the three-dimensional
     display object. Then pass the Vector3D object to the <codeph>local3DToGlobal()</codeph> 
     method as the <codeph>point3d</codeph> parameter. The method returns a two-dimensional Point 
     object that can be used 
     with the Graphics API to draw the three-dimensional object.</p>
     
     
     </apiDesc><example conref="examples\Local3DToGlobalExample.as"> This example draws a simple three-dimensional cube in a two dimensional space
 using <codeph>display.Graphics</codeph> methods. The location of <codeph>this</codeph> display 
 object is offset, so the cube's registration point is in its center. A vector 
 of Vector3D objects holds the cube's three dimensional coordinates. The top 
 of the cube is draw first, the bottom is drawn second, and then the top and bottom 
 four corners are connected. You need to add the cube to the display object 
 container before drawing the cube in order to use the <codeph>local3DToGlobal()</codeph> method. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.geom.*;

    public class Local3DToGlobalExample extends MovieClip {
        private var myCube:Sprite = new Sprite();
        private var v8:Vector.&lt;Vector3D&gt; = new Vector.&lt;Vector3D&gt;(8);

        public function Local3DToGlobalExample():void {
            this.x = -(this.stage.stageWidth / 2);
            this.y = -(this.stage.stageWidth / 2);

            v8[0] = new Vector3D(-40,-40,-40);
            v8[1] = new Vector3D(40,-40,-40);
            v8[2] = new Vector3D(40,-40,40);
            v8[3] = new Vector3D(-40,-40,40);
            v8[4] = new Vector3D(-40,100,-40);
            v8[5] = new Vector3D(40,100,-40);
            v8[6] = new Vector3D(40,100,40);
            v8[7] = new Vector3D(-40,100,40);

            myCube.x = (this.stage.stageWidth / 2);
            myCube.y = (this.stage.stageWidth / 2);
            myCube.z = 1;
            addChild(myCube);

            Cube();         
        }

        private function Cube():void {
            var ps:Point = new Point(0,0);

            myCube.graphics.lineStyle(2,0xFF0000);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:localToGlobal"><apiName>localToGlobal</apiName><shortdesc>
     Converts the point object from the display object's (local) coordinates to the
     Stage (global) coordinates.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Point object with coordinates relative to the Stage.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The name or identifier of a point created with the Point class, specifying the
     <i>x</i> and <i>y</i> coordinates as properties.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Converts the <codeph>point</codeph> object from the display object's (local) coordinates to the
     Stage (global) coordinates.
     
     <p>This method allows you to convert any given <i>x</i> and <i>y</i> coordinates from
     values that are relative to the origin (0,0) of a specific display object (local coordinates)
     to values that are relative to the origin of the Stage (global coordinates).</p>
     
     <p>To use this method, first create an instance of the Point class. The
     <i>x</i> and <i>y</i> values that you assign represent local coordinates because they
     relate to the origin of the display object.</p>
     
     <p>You then pass the Point instance that you created as the parameter to
     the <codeph>localToGlobal()</codeph> method. The method returns a new Point object with
     <i>x</i> and <i>y</i> values that relate to the origin of the Stage
     instead of the origin of the display object.</p>
     
     </apiDesc><example conref="examples\DisplayObject.localToGlobal.1.as"> The following code creates a Sprite object. The <codeph>mouseX</codeph> and 
 <codeph>mouseY</codeph> properties of the sprite are in the coordinate space of the display 
 object. This code uses the <codeph>localToGlobal()</codeph> method to translate these 
 properties to the global (Stage) coordinates:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.Point;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
square.x = 100;
square.y = 200;

addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates)

function traceCoordinates(event:MouseEvent):void {
    var clickPoint:Point = new Point(square.mouseX, square.mouseY);
    trace("display object coordinates:", clickPoint);
    trace("stage coordinates:", square.localToGlobal(clickPoint));
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point class</linktext></link></related-links></apiOperation><apiValue id="flash.display:DisplayObject:accessibilityProperties:get"><apiName>accessibilityProperties</apiName><shortdesc>
     The current accessibility options for this display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.accessibility:AccessibilityProperties</apiValueClassifier></apiValueDef><apiDesc>
     The current accessibility options for this display object. If you modify the <codeph>accessibilityProperties</codeph>
     property or any of the fields within <codeph>accessibilityProperties</codeph>, you must call 
     the <codeph>Accessibility.updateProperties()</codeph> method to make your changes take effect.
     
     <p class="flashonly"><b>Note</b>: For an object created in the Flash authoring environment, the value of <codeph>accessibilityProperties</codeph>
     is prepopulated with any information you entered in the Accessibility panel for
     that object.</p>
     
     </apiDesc><example conref="examples\DisplayObject.accessibilityProperties.1.as"> The following example shows how the to attach a simple AccessibilityProperties
 object to a TextField instance:
<codeblock>

import flash.text.TextField;
import flash.accessibility.AccessibilityProperties;
import flash.accessibility.Accessibility;
import flash.system.Capabilities;

var tf:TextField = new TextField();
tf.text = "hello";

var accessProps:AccessibilityProperties = new AccessibilityProperties();
accessProps.name = "Greeting";

tf.accessibilityProperties = accessProps;

if (Capabilities.hasAccessibility) {
    Accessibility.updateProperties();
}

trace(tf.accessibilityProperties.name); // Greeting
</codeblock></example></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link><link href="flash.accessibility.xml#AccessibilityProperties"><linktext>flash.accessibility.AccessibilityProperties</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:alpha:get"><apiName>alpha</apiName><shortdesc>
     Indicates the alpha transparency value of the object specified.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the alpha transparency value of the object specified.
     Valid values are 0 (fully transparent) to 1 (fully opaque).
     The default value is 1. Display objects with <codeph>alpha</codeph>
     set to 0 <i>are</i> active, even though they are invisible.
     
     </apiDesc><example conref="examples\DisplayObject.alpha.1.as"> The following code sets the <codeph>alpha</codeph> property of a sprite
 to 50% when the mouse rolls over the sprite:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.alpha = 0.5;
}

function restoreObject(event:MouseEvent):void {
    event.target.alpha = 1.0;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:blendMode:get"><apiName>blendMode</apiName><shortdesc>
     A value from the BlendMode class that specifies which blend mode to use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     A value from the BlendMode class that specifies which blend mode to use.
     A bitmap can be drawn internally in two ways. If you have a blend mode enabled or an
     external clipping mask, the bitmap is drawn by adding a bitmap-filled square shape to the vector
     render. If you attempt to set this property to an invalid value, Flash Player or Adobe AIR sets the value
     to <codeph>BlendMode.NORMAL</codeph>.
     
     <p>The <codeph>blendMode</codeph> property affects each pixel of the display object.
     Each pixel is composed of three constituent
     colors (red, green, and blue), and each constituent color has a value between 0x00 and 0xFF.
     Flash Player or Adobe AIR compares each constituent color of one pixel in the movie clip with
     the corresponding color of the pixel in the background. For example, if <codeph>blendMode</codeph>
     is set to <codeph>BlendMode.LIGHTEN</codeph>, Flash Player or Adobe AIR compares the red value of the display object with
     the red value of the background, and uses the lighter of the two as the
     value for the red component of the displayed color.</p>
     
     <p>The following table describes the <codeph>blendMode</codeph> settings. 
     The BlendMode class defines string values you can use.
     The illustrations in the table show <codeph>blendMode</codeph> values applied to a circular
     display object (2) superimposed on another display object (1).</p>
     
     
     <p>
      <adobeimage alt="Square Number 1" href="../../images/blendMode-0a.jpg"/>
     
      <adobeimage alt="Circle Number 2" href="../../images/blendMode-0b.jpg"/>
     
     </p>
     
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="3"><thead><row><entry>BlendMode Constant</entry><entry>Illustration</entry><entry>Description</entry></row></thead><tbody><row valign="top">
     <entry><codeph>BlendMode.NORMAL</codeph></entry>
     <entry><adobeimage alt="blend mode NORMAL" href="../../images/blendMode-1.jpg"/></entry>
     <entry>The display object appears in front of the background. Pixel values of the display object
     override those of the background. Where the display object is transparent, the background is
     visible.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LAYER</codeph></entry>
     <entry><adobeimage alt="blend mode LAYER" href="../../images/blendMode-2.jpg"/></entry>
     
     <entry>Forces the creation of a transparency group for the display object. This means that the display 
     object is pre-composed in a temporary buffer before it is processed further. This is done 
     automatically if the display object is pre-cached using bitmap caching or if the display object is 
     a display object container with at least one child object with a <codeph>blendMode</codeph> 
     setting other than <codeph>BlendMode.NORMAL</codeph>.
     </entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.MULTIPLY</codeph></entry>
     <entry><adobeimage alt="blend mode MULTIPLY" href="../../images/blendMode-3.jpg"/></entry>
     
     <entry>Multiplies the values of the display object constituent colors by the colors of the background color,
     and then normalizes by dividing by 0xFF,
     resulting in darker colors. This setting is commonly used for shadows and depth effects.
     
     <p>For example, if a constituent color (such as red) of one pixel in the display object and the
     corresponding color of the pixel in the background both have the value 0x88, the multiplied
     result is 0x4840. Dividing by 0xFF yields a value of 0x48 for that constituent color,
     which is a darker shade than the color of the display object or the color of the background.</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SCREEN</codeph></entry>
     <entry><adobeimage alt="blend mode SCREEN" href="../../images/blendMode-4.jpg"/></entry>
     
     <entry>Multiplies the complement (inverse) of the display object color by the complement of the background
     color, resulting in a bleaching effect. This setting is commonly used for highlights or to remove black
     areas of the display object.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LIGHTEN</codeph></entry>
     <entry><adobeimage alt="blend mode LIGHTEN" href="../../images/blendMode-5.jpg"/></entry>
     
     <entry>Selects the lighter of the constituent colors of the display object and the color of the background (the
     colors with the larger values). This setting is commonly used for superimposing type.
     
     <p>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background
     pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is
     0xFFF833 (because 0xFF &gt; 0xDD, 0xCC &lt; 0xF8, and 0x33 &gt; 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DARKEN</codeph></entry>
     <entry><adobeimage alt="blend mode DARKEN" href="../../images/blendMode-6.jpg"/></entry>
     
     <entry>Selects the darker of the constituent colors of the display object and the colors of the 
     background (the colors with the smaller values). This setting is commonly used for superimposing type.
     
     <p>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background
     pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is
     0xDDCC00 (because 0xFF &gt; 0xDD, 0xCC &lt; 0xF8, and 0x33 &gt; 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DIFFERENCE</codeph></entry>
     <entry><adobeimage alt="blend mode DIFFERENCE" href="../../images/blendMode-7.jpg"/></entry>
     
     <entry>Compares the constituent colors of the display object with the colors of its background, and subtracts
     the darker of the values of the two constituent colors from the lighter value. This setting is commonly
     used for more vibrant colors.
     
     <p>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background
     pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is
     0x222C33 (because 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ADD</codeph></entry>
     <entry><adobeimage alt="blend mode ADD" href="../../images/blendMode-8.jpg"/></entry>
     
     <entry>Adds the values of the constituent colors of the display object to the colors of its background, applying a
     ceiling of 0xFF. This setting is commonly used for animating a lightening dissolve between
     two objects.
     
     <p>For example, if the display object has a pixel with an RGB value of 0xAAA633, and the background
     pixel has an RGB value of 0xDD2200, the resulting RGB value for the displayed pixel is
     0xFFC833 (because 0xAA + 0xDD &gt; 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.SUBTRACT</codeph></entry>
     <entry><adobeimage alt="blend mode SUBTRACT" href="../../images/blendMode-9.jpg"/></entry>
     
     <entry>Subtracts the values of the constituent colors in the display object from the values of the 
     background color, applying a floor of 0. This setting is commonly used for animating a 
     darkening dissolve between two objects.
     
     <p>For example, if the display object has a pixel with an RGB value of 0xAA2233, and the background
     pixel has an RGB value of 0xDDA600, the resulting RGB value for the displayed pixel is
     0x338400 (because 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 &lt; 0x00).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.INVERT</codeph></entry>
     <entry><adobeimage alt="blend mode INVERT" href="../../images/blendMode-10.jpg"/></entry>
     
     <entry>Inverts the background.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ALPHA</codeph></entry>
     <entry><adobeimage alt="blend mode ALPHA" href="../../images/blendMode-11.jpg"/></entry>
     
     <entry>Applies the alpha value of each pixel of the display object to the background.
     This requires the <codeph>blendMode</codeph> setting of the parent display object to be set to
     <codeph>BlendMode.LAYER</codeph>.
     For example, in the illustration, the parent display object, which is a white background,
     has <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ERASE</codeph></entry>
     <entry><adobeimage alt="blend mode ERASE" href="../../images/blendMode-12.jpg"/></entry>
     
     <entry>Erases the background based on the alpha value of the display object. This requires the
     <codeph>blendMode</codeph> of the parent display object to be set to
     <codeph>BlendMode.LAYER</codeph>. For example, in the
     illustration, the parent display object, which is a white background, has
     <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.OVERLAY</codeph></entry>
     <entry><adobeimage alt="blend mode OVERLAY" href="../../images/blendMode-13.jpg"/></entry>
     
     <entry>Adjusts the color of each pixel based on the darkness of the background.
     If the background is lighter than 50% gray, the display object and background colors are
     screened, which results in a lighter color. If the background is darker than 50% gray,
     the colors are multiplied, which results in a darker color.
     This setting is commonly used for shading effects.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.HARDLIGHT</codeph></entry>
     <entry><adobeimage alt="blend mode HARDLIGHT" href="../../images/blendMode-14.jpg"/></entry>
     
     <entry>Adjusts the color of each pixel based on the darkness of the display object.
     If the display object is lighter than 50% gray, the display object and background colors are
     screened, which results in a lighter color. If the display object is darker than 50% gray,
     the colors are multiplied, which results in a darker color.
     This setting is commonly used for shading effects.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SHADER</codeph></entry>
     <entry align="center" valign="middle">N/A</entry>
     
     <entry>Adjusts the color using a custom shader routine. The shader that is used is specified 
     as the Shader instance assigned to the <codeph>blendShader</codeph> property. Setting the 
     <codeph>blendShader</codeph> property of a display object to a Shader instance 
     automatically sets the display object's <codeph>blendMode</codeph> property to 
     <codeph>BlendMode.SHADER</codeph>. If the <codeph>blendMode</codeph> property is set to 
     <codeph>BlendMode.SHADER</codeph> without first setting the <codeph>blendShader</codeph> property,
     the <codeph>blendMode</codeph> property is set to <codeph>BlendMode.NORMAL</codeph>.</entry>
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\DisplayObject.blendMode.1.as"> The following code creates two sprite objects, a square and a circle, 
 and sets the blend mode of the circle (in the foreground) to <codeph>BlendMode.SUBTRACT</codeph>
 when the pointer rolls over the circle:
<codeblock>
import flash.display.Sprite;
import flash.display.BlendMode;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF88CC);
square.graphics.drawRect(0, 0, 80, 80);
addChild(square);

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.SUBTRACT;
}

function restoreObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.NORMAL;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>blendShader</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:cacheAsBitmap:get"><apiName>cacheAsBitmap</apiName><shortdesc>
     If set to true, Flash Player or Adobe AIR caches an internal bitmap representation of the
     display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Whether to cache this DisplayObject as a bitmap.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     If set to <codeph>true</codeph>, Flash Player or Adobe AIR caches an internal bitmap representation of the
     display object. This caching can increase performance for display objects that contain complex
     vector content.
     
     <p>All vector data for a display object that has a cached bitmap is drawn to the bitmap
     instead of the main display. The bitmap is then copied to the main display as unstretched,
     unrotated pixels snapped to the nearest pixel boundaries. Pixels are mapped 1 to 1 with
     the parent object. If the bounds of the bitmap change, the bitmap is recreated instead
     of being stretched.</p>
     
     <p>No internal bitmap is created unless the <codeph>cacheAsBitmap</codeph> property is set to
     <codeph>true</codeph>.</p>
     
     <p>After you set the <codeph>cacheAsBitmap</codeph> property to <codeph>true</codeph>,
     the rendering does not change, however the display object performs pixel snapping
     automatically. The animation speed can be significantly faster depending
     on the complexity of the vector content.
     </p>
     
     <p>The <codeph>cacheAsBitmap</codeph> property is automatically set to <codeph>true</codeph>
     whenever you apply a filter to a display object (when its <codeph>filter</codeph> array is not empty),
     and if a display object has a filter applied to it, <codeph>cacheAsBitmap</codeph> is reported as
     <codeph>true</codeph> for that display object, even if you set the property to <codeph>false</codeph>.
     If you clear all filters for a display object, the <codeph>cacheAsBitmap</codeph> setting changes to
     what it was last set to.</p>
     
     <p>A display object does not use a bitmap even if the <codeph>cacheAsBitmap</codeph>
     property is set to <codeph>true</codeph> and instead renders from vector data in the following cases:</p>
     
     <ul>
     
       <li>The bitmap is too large.
     In  AIR 1.5 and Flash Player 10, the maximum size for a bitmap image is 8,191 pixels in width or height, 
     and the total number of pixels cannot exceed 16,777,215 pixels. (So, if a bitmap image is 8,191 pixels 
     wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation is
     is 2880 pixels in height and 2,880 pixels in width.</li>
     
       <li>The bitmap fails to allocate (out of memory error). </li>
     
     </ul>
     
     <p>The <codeph>cacheAsBitmap</codeph> property is best used with movie clips that have
     mostly static content and that do not scale and rotate frequently. With such movie
     clips, <codeph>cacheAsBitmap</codeph> can lead to performance increases when the
     movie clip is translated (when its <i>x</i> and <i>y</i> position is changed).</p>
     
     </apiDesc><example conref="examples\DisplayObject.cacheAsBitmap.1.as"> The following example applies a drop shadow to a Shape instance. 
 It then traces the value of the <codeph>cacheAsBitmap</codeph> property, which is set to 
 <codeph>true</codeph> when the filter is applied:
<codeblock>
import flash.display.Sprite;
import flash.filters.DropShadowFilter

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);

addChild(circle);

trace(circle.cacheAsBitmap); // false

var filter:DropShadowFilter = new DropShadowFilter();
circle.filters = [filter];

trace(circle.cacheAsBitmap); // true
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:filters:get"><apiName>filters</apiName><shortdesc>
     An indexed array that contains each filter object currently associated with the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>When <codeph>filters</codeph> includes a ShaderFilter and the shader 
                           output type is not compatible with this operation 
                           (the shader must specify a <codeph>pixel4</codeph> 
                           output).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When <codeph>filters</codeph> includes a ShaderFilter and the shader 
                           doesn't specify any image input or the first
                           input is not an <codeph>image4</codeph> inputs.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When <codeph>filters</codeph> includes a ShaderFilter and the shader 
                           specifies an image input that isn't provided.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When <codeph>filters</codeph> includes a ShaderFilter, a 
                           ByteArray or Vector.&lt;Number&gt; instance as 
                           a shader input, and the <codeph>width</codeph> 
                           and <codeph>height</codeph> properties aren't specified for the 
                           ShaderInput object, or the specified values don't match the amount of 
                           data in the input data. See the <codeph>ShaderInput.input</codeph> 
                           property for more information.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     An indexed array that contains each filter object currently associated with the display object.
     The flash.filters package contains several classes that define specific filters you can
     use.
     
     <p>Filters can be applied in the Flash authoring tool at design time, or at run time by using
     ActionScript code. To apply a filter by using ActionScript, you must make a temporary copy of the
     entire <codeph>filters</codeph> array, modify the temporary array, then assign the value
     of the temporary array back to the <codeph>filters</codeph> array. You cannot directly
     add a new filter object to the <codeph>filters</codeph> array.</p>
     
     <p>To add a filter by using ActionScript, perform the following steps (assume that the
     target display object is named <codeph>myDisplayObject</codeph>):</p>
     
     <ol>
     
       <li>Create a new filter object by using the constructor method of your chosen filter
     class.</li>
     
       <li>Assign the value of the <codeph>myDisplayObject.filters</codeph> array to a temporary array, such
     as one named <codeph>myFilters</codeph>.</li>
     
       <li>Add the new filter object to the <codeph>myFilters</codeph> temporary array.</li>
     
       <li>Assign the value of the temporary array to the <codeph>myDisplayObject.filters</codeph> array.</li>
     
     </ol>
     
     <p>If the <codeph>filters</codeph> array is undefined, you do not need to use a temporary array.
     Instead, you can directly assign an array literal that contains one or more filter objects that
     you create. The first example in the Examples section adds a drop shadow filter by using
     code that handles both defined and undefined <codeph>filters</codeph> arrays.</p>
     
     <p>To modify an existing filter object,
     you must use the technique of modifying a copy of the <codeph>filters</codeph> array:</p>
     
     <ol>
     
       <li>Assign the value of the <codeph>filters</codeph> array to a temporary array, such as one
     named <codeph>myFilters</codeph>.</li>
     
       <li>Modify the property by using the temporary array, <codeph>myFilters</codeph>. For example, 
     to set the quality property of the first filter in the array, you could use the
     following code: <codeph>myFilters[0].quality = 1;</codeph></li>
     
       <li>Assign the value of the temporary array to the <codeph>filters</codeph> array.</li>
     
     </ol>
     
     <p>At load time, if a display object has an associated filter, it is marked to cache itself as a
     transparent bitmap. From this point forward, as long as the display object has a valid filter list,
     the player caches the display object as a bitmap. This source bitmap is used as a source
     image for the filter effects. Each display object usually has two bitmaps: one with the
     original unfiltered source display object and another for the final image after filtering.
     The final image is used when rendering. As long as the display object does not
     change, the final image does not need updating.</p>
     
     <p>The flash.filters package includes classes for filters. For example, to create a DropShadow
     filter, you would write:</p>
     
     <codeblock>
     import flash.filters.DropShadowFilter
     var myFilter:DropShadowFilter = new DropShadowFilter (distance, angle, color, alpha, blurX, blurY, quality, inner, knockout)
     </codeblock>
     
     <p>You can use the <codeph>is</codeph> operator to determine the type of filter assigned to 
     each index position in the <codeph>filter</codeph> array. For example, the following code shows
     how to determine the position of the first filter in the <codeph>filters</codeph> array that 
     is a DropShadowFilter:
     </p>
     
     <codeblock>
     import flash.text.TextField;
     import flash.filters.~~;
     var tf:TextField = new TextField();
     var filter1:DropShadowFilter = new DropShadowFilter();
     var filter2:GradientGlowFilter = new GradientGlowFilter();
     tf.filters = [filter1, filter2];
     
     tf.text = "DropShadow index: " + filterPosition(tf, DropShadowFilter).toString(); // 0
     addChild(tf)
     
     function filterPosition(displayObject:DisplayObject, filterClass:Class):int {
         for (var i:uint = 0; i &lt; displayObject.filters.length; i++) {
             if (displayObject.filters[i] is filterClass) {
                 return i;
             }
         }
         return -1;
     }
     </codeblock>
     <p><b>Note:</b> Since you cannot directly add a new filter object to the
     <codeph>DisplayObject.filters</codeph> array, the following code has no
     effect on the target display object, named <codeph>myDisplayObject</codeph>:</p>
     
     <codeblock>
     myDisplayObject.filters.push(myDropShadow);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="../../flash/filters/package-detail.html"><linktext>flash.filters package</linktext></link><link href="flash.display.xml#ShaderInput/input"><linktext>flash.display.ShaderInput.input</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:height:get"><apiName>height</apiName><shortdesc>
     Indicates the height of the display object, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the height of the display object, in pixels. The height is calculated based on the bounds of the content of the display object.
     When you set the <codeph>height</codeph> property, the <codeph>scaleY</codeph> property is adjusted accordingly, as shown in the 
     following code:
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>Except for TextField and Video objects, a display object with no content (such as an empty sprite) has a height 
    of 0, even if you try to set <codeph>height</codeph> to a different value.</p>
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> The following code creates two TextField objects and adjusts the 
 <codeph>height</codeph> property of each based on the <codeph>textHeight</codeph> property of 
 each; it also positions the second text field by setting its <codeph>y</codeph> property:
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:loaderInfo:get"><apiName>loaderInfo</apiName><shortdesc>
     Returns a LoaderInfo object containing information about loading the file
     to which this display object belongs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Returns a LoaderInfo object containing information about loading the file
     to which this display object belongs. The <codeph>loaderInfo</codeph> property is defined only
     for the root display object of a SWF file or for a loaded Bitmap (not for a Bitmap that is drawn 
     with ActionScript). To find the <codeph>loaderInfo</codeph> object associated with the SWF file that contains 
     a display object named <codeph>myDisplayObject</codeph>, use <codeph>myDisplayObject.root.loaderInfo</codeph>.
     
     <p>A large SWF file can monitor its download by calling 
     <codeph>this.root.loaderInfo.addEventListener(Event.COMPLETE, func)</codeph>.</p>
     
     </apiDesc><example conref="examples\DisplayObject.loaderInfo.1.as"> The following code assumes that <codeph>this</codeph> refers to 
 a display object. The code outputs the URL of the root SWF file for the 
 display object:
<codeblock>
 trace (this.loaderInfo.url);
 
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>LoaderInfo class</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:mask:get"><apiName>mask</apiName><shortdesc>
     The calling display object is masked by the specified mask object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Sets a mask for the display object.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     The calling display object is masked by the specified <codeph>mask</codeph> object.
     To ensure that masking works when the Stage is scaled, the <codeph>mask</codeph> display object
     must be in an active part of the display list. The <codeph>mask</codeph> object itself is not drawn.
     Set <codeph>mask</codeph> to <codeph>null</codeph> to remove the mask.
     
     <p>To be able to scale a mask object, it must be on the display list. To be able to drag a mask Sprite object 
     (by calling its <codeph>startDrag()</codeph> method), it must be on the display list. To call the 
     <codeph>startDrag()</codeph> method for a mask sprite based on a <codeph>mouseDown</codeph> event 
     being dispatched by the sprite, set the sprite's <codeph>buttonMode</codeph> property to <codeph>true</codeph>.</p>
     
     <p><b>Note:</b> A single <codeph>mask</codeph> object cannot be used to mask more than one calling display object. 
     When the <codeph>mask</codeph> is assigned to a second display object, it is removed as the mask of the first 
     object, and that object's <codeph>mask</codeph> property becomes <codeph>null</codeph>.</p>  
     
     </apiDesc><example conref="examples\DisplayObject.mask.1.as"> The following code creates a TextField object as well as a Sprite object
 that is set as a mask for the TextField object. When the user clicks the text
 field, the <codeph>drag()</codeph> event listener function calls the <codeph>startDrag()</codeph>
 method of the mask Sprite object:
<codeblock>
import flash.text.TextField;
import flash.display.Sprite;
import flash.events.MouseEvent;

var tf:TextField = new TextField();
tf.text = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " 
            + "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
tf.selectable = false;
tf.wordWrap = true;
tf.width = 150;
addChild(tf);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 40, 40);
addChild(square);

tf.mask = square;

tf.addEventListener(MouseEvent.MOUSE_DOWN, drag);
tf.addEventListener(MouseEvent.MOUSE_UP, noDrag);

function drag(event:MouseEvent):void {
    square.startDrag();
}
function noDrag(event:MouseEvent):void {
    square.stopDrag();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseX:get"><apiName>mouseX</apiName><shortdesc>
     Indicates the x coordinate of the mouse position, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the x coordinate of the mouse position, in pixels.
     
     <p><b>Note</b>: For a DisplayObject that has been rotated, the returned x coordinate will reflect the
     non-rotated object.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> The following code creates a Sprite object and traces the <codeph>mouseX</codeph>
 and <codeph>mouseY</codeph> positions when the user clicks the sprite:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseY:get"><apiName>mouseY</apiName><shortdesc>
     Indicates the y coordinate of the mouse position, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the y coordinate of the mouse position, in pixels.
     
     <p><b>Note</b>: For a DisplayObject that has been rotated, the returned y coordinate will reflect the
     non-rotated object.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> The following code creates a Sprite object and traces the <codeph>mouseX</codeph>
 and <codeph>mouseY</codeph> positions when the user clicks the sprite:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:name:get"><apiName>name</apiName><shortdesc>
     Indicates the instance name of the DisplayObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>If you are attempting to set this property on an object that was 
     placed on the timeline in the Flash authoring tool.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>The name of this DisplayObject.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Indicates the instance name of the DisplayObject. The object can be identified in 
     the child list of its parent display object container by calling the 
     <codeph>getChildByName()</codeph> method of the display object container.
     
     </apiDesc><example conref="examples\DisplayObject.name.1.as"> The following code creates two Sprite object and traces the 
 associated <codeph>name</codeph> property when the user clicks either of the objects:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.name = "circle1";
addChild(circle1);
circle1.addEventListener(MouseEvent.CLICK, traceName);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x0000FF);
circle2.graphics.drawCircle(140, 40, 40);
circle2.name = "circle2";
addChild(circle2);
circle2.addEventListener(MouseEvent.CLICK, traceName);

function traceName(event:MouseEvent):void {
    trace(event.target.name);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:opaqueBackground:get"><apiName>opaqueBackground</apiName><shortdesc>
     Specifies whether the display object is opaque with a certain background color.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Specifies whether the display object is opaque with a certain background color.
     A transparent bitmap contains alpha
     channel data and is drawn transparently. An opaque bitmap has no alpha channel (and renders faster
     than a transparent bitmap). If the bitmap is opaque, you specify its own background color to use.
     
     <p>If set to a number value, the surface is opaque (not transparent) with the RGB background
     color that the number specifies. If set to <codeph>null</codeph> (the default value), the display 
     object has a transparent background.</p>
     
     <p>The <codeph>opaqueBackground</codeph> property is intended mainly for use with the 
     <codeph>cacheAsBitmap</codeph> property, for rendering optimization. For display objects in which the 
     <codeph>cacheAsBitmap</codeph> property is set to true, setting <codeph>opaqueBackground</codeph> can 
     improve rendering performance.</p>
     
     <p>The opaque background region is <i>not</i> matched when calling the <codeph>hitTestPoint()</codeph> 
     method with the <codeph>shapeFlag</codeph> parameter set to <codeph>true</codeph>.</p>
     
     <p>The opaque background region does not respond to mouse events.</p>
     
     </apiDesc><example conref="examples\DisplayObject.opaqueBackground.1.as"> The following code creates a Shape object with a blue circle
 and sets its <codeph>opaqueBackground</codeph> property to red (0xFF0000):
<codeblock>
import flash.display.Shape;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.opaqueBackground = 0xFF0000;
addChild(circle);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/hitTestPoint()"><linktext>hitTestPoint()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:parent:get"><apiName>parent</apiName><shortdesc>
     Indicates the DisplayObjectContainer object that contains this display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObjectContainer</apiValueClassifier><apiException><apiDesc>The parent display object belongs to a security sandbox
     to which you do not have access. You can avoid this situation by having
     the parent movie call the <codeph>Security.allowDomain()</codeph> method.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Indicates the DisplayObjectContainer object that contains this display object. Use the <codeph>parent</codeph>
     property to specify a relative path to display objects that are above the
     current display object in the display list hierarchy.
     
     <p>You can use <codeph>parent</codeph> to move up multiple levels in the display list as in the following:</p>
     
     <codeblock>
     this.parent.parent.alpha = 20;
     </codeblock>
     
     </apiDesc><example conref="examples\DisplayObject.parent.1.as"> The following code creates three Sprite objects and shows how
 the <codeph>parent</codeph> property reflects the display list hierarchy:
<codeblock>

import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite2.parent.name); // sprite1
trace(sprite3.parent.name); // sprite2
trace(sprite3.parent.parent.name); // sprite1
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:root:get"><apiName>root</apiName><shortdesc>
     For a display object in a loaded SWF file, the root property is the 
     top-most display object in the portion of the display list's tree structure represented by that SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Return the root display object for this object.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     For a display object in a loaded SWF file, the <codeph>root</codeph> property is the 
     top-most display object in the portion of the display list's tree structure represented by that SWF file.
     For a Bitmap object representing a loaded image file, the <codeph>root</codeph> property is the Bitmap object
     itself. For the instance of the main class of the first SWF file loaded, the <codeph>root</codeph> property is the 
     display object itself. The <codeph>root</codeph> property of the Stage object is the Stage object itself. The <codeph>root</codeph>  
     property is set to <codeph>null</codeph> for any display object that has not been added to the display list, unless 
     it has been added to a display object container that is off the display list but that is a child of the 
     top-most display object in a loaded SWF file.
     
     <p>For example, if you create a new Sprite object by calling the <codeph>Sprite()</codeph> constructor method, 
     its <codeph>root</codeph> property is <codeph>null</codeph> until you add it to the display list (or to a display 
     object container that is off the display list but that is a child of the top-most display object in a SWF file).</p>
     
     <p>For a loaded SWF file, even though the Loader object used to load the file may not be on the display list, 
     the top-most display object in the SWF file has its <codeph>root</codeph> property set to itself.  The Loader object 
     does not have its <codeph>root</codeph> property set until it is added as a child of a display object for which the 
     <codeph>root</codeph> property is set.</p>
     
     </apiDesc><example conref="examples\DisplayObject.root.1.as"> The following code shows the difference between the <codeph>root</codeph>
 property for the Stage object, for a display object (a Loader object) that is not loaded (both before
 and after it has been added to the display list), and for a loaded object (a loaded Bitmap object):
<codeblock>
import flash.display.Loader;
import flash.net.URLRequest;
import flash.events.Event;

trace(stage.root); // [object Stage]

var ldr:Loader = new Loader();
trace (ldr.root); // null

addChild(ldr); 
trace (ldr.root); // [object ...]

var urlReq:URLRequest = new URLRequest("example.jpg");
ldr.load(urlReq);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void {
    trace(ldr.content.root); // [object Bitmap]
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotation:get"><apiName>rotation</apiName><shortdesc>
     Indicates the rotation of the DisplayObject instance, in degrees, from its original orientation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the rotation of the DisplayObject instance, in degrees, from its original orientation. Values from 0 to 180 represent
     clockwise rotation; values from 0 to -180 represent counterclockwise rotation. Values outside this range are added to or
     subtracted from 360 to obtain a value within the range. For example, the statement <codeph>my_video.rotation = 450</codeph> is the
     same as <codeph> my_video.rotation = 90</codeph>.
     
     </apiDesc><example conref="examples\DisplayObject.rotation.1.as"> The following code creates a Sprite object and rotates
 the object when the user clicks it:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(-50, -50, 100, 100);
square.x = 150;
square.y = 150;
addChild(square);

square.addEventListener(MouseEvent.CLICK, rotate);

function rotate(event:MouseEvent):void {
        square.rotation += 15;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationX:get"><apiName>rotationX</apiName><shortdesc>
     Indicates the x-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the x-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container. Values from 0 to 180 represent
     clockwise rotation; values from 0 to -180 represent counterclockwise rotation. Values outside this range are added to or
     subtracted from 360 to obtain a value within the range.
     
     </apiDesc><example conref="examples\RotationExample1.as"> In this example, two ellipses rotate using their <codeph>rotationX</codeph> and 
 <codeph>rotationY</codeph> properties. The first ellipse's registration point is set 
 to its center. It rotates around itself. The second ellipse rotates around 
 an external point. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationY:get"><apiName>rotationY</apiName><shortdesc>
     Indicates the y-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the y-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container. Values from 0 to 180 represent
     clockwise rotation; values from 0 to -180 represent counterclockwise rotation. Values outside this range are added to or
     subtracted from 360 to obtain a value within the range.
     
     
     </apiDesc><example conref="examples\RotationExample1.as"> In this example, two ellipses rotate using their <codeph>rotationX</codeph> and 
 <codeph>rotationY</codeph> properties. The first ellipse's registration point is set 
 to its center. It rotates around itself. The second ellipse rotates around 
 an external point. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationZ:get"><apiName>rotationZ</apiName><shortdesc>
     Indicates the z-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the z-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container. Values from 0 to 180 represent
     clockwise rotation; values from 0 to -180 represent counterclockwise rotation. Values outside this range are added to or
     subtracted from 360 to obtain a value within the range.
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scale9Grid:get"><apiName>scale9Grid</apiName><shortdesc>
     The current scaling grid that is in effect.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following creates a movie clip that contains a 20-pixel line (which forms a border)
     and a gradient fill. The movie clip scales based on the mouse position, and because of the
     <code>scale9Grid</code> set for the movie clip, the thickness of the 20-pixel line does not
     vary when the clip scales (although the gradient in the movie clip <em>does</em> scale):
     
     <listing version="2.0">
     import flash.geom.Rectangle;
     import flash.geom.Matrix;
     
     this.createEmptyMovieClip("my_mc", this.getNextHighestDepth());
     
     var grid:Rectangle = new Rectangle(20, 20, 260, 260);
     my_mc.scale9Grid = grid ;
     
     my_mc._x = 50;
     my_mc._y = 50;
     
     function onMouseMove()
     {
      my_mc._width  = _xmouse;
      my_mc._height = _ymouse;
     }
     
     my_mc.lineStyle(20, 0xff3333, 100);
     var gradient_matrix:Matrix = new Matrix();
     gradient_matrix.createGradientBox(15, 15, Math.PI, 10, 10);
     my_mc.beginGradientFill("radial", [0xffff00, 0x0000ff],
              [100, 100], [0, 0xFF], gradient_matrix,
              "reflect", "RGB", 0.9);
     my_mc.moveTo(0, 0);
     my_mc.lineTo(0, 300);
     my_mc.lineTo(300, 300);
     my_mc.lineTo(300, 0);
     my_mc.lineTo(0, 0);
     my_mc.endFill();
     </listing>
     
     </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>If you pass an invalid argument to the method.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     The current scaling grid that is in effect. If set to <codeph>null</codeph>,
     the entire display object is scaled normally when any scale transformation is
     applied.
     
     <p>When you define the <codeph>scale9Grid</codeph> property, the display object is divided into a
     grid with nine regions based on the <codeph>scale9Grid</codeph> rectangle, which defines the
     center region of the grid. The eight other regions of the grid are the following areas: </p>
     
     <ul>
       <li>The upper-left corner outside of the rectangle</li>
       <li>The area above the rectangle </li>
       <li>The upper-right corner outside of the rectangle</li>
       <li>The area to the left of the rectangle</li>
       <li>The area to the right of the rectangle</li>
       <li>The lower-left corner outside of the rectangle</li>
       <li>The area below the rectangle</li>
       <li>The lower-right corner outside of the rectangle</li>
     </ul>
     
     <p>You can think of the eight regions outside of the center (defined by the rectangle)
     as being like a picture frame that has special rules applied to it when scaled.</p>
     
     <p>When the <codeph>scale9Grid</codeph> property is set and a display object is scaled, all text and
     gradients are scaled normally; however, for other types of objects the following rules apply:</p>
     
     <ul>
       <li>Content in the center region is scaled normally. </li>
       <li>Content in the corners is not scaled. </li>
       <li>Content in the top and bottom regions is scaled horizontally only. Content in the
     left and right regions is scaled vertically only.</li>
      <li>All fills (including bitmaps, video, and gradients) are stretched to fit their shapes.</li>
     </ul>
     
     <p>If a display object is rotated, all subsequent scaling is normal (and the
     <codeph>scale9Grid</codeph> property is ignored).</p>
     
     <p>For example, consider the following display object and a rectangle that is applied as the display
     object's <codeph>scale9Grid</codeph>:</p>
     
     <adobetable>
     
       
     
     <tgroup cols="2"><tbody><row>
      <entry align="center"><adobeimage alt="display object image" href="../../images/scale9Grid-a.jpg"/>
     <p>The display object.</p></entry>
     
      <entry align="center"><adobeimage alt="display object scale 9 region" href="../../images/scale9Grid-b.jpg"/>
      <p>The red rectangle shows the <codeph>scale9Grid</codeph>.</p></entry>
       </row></tbody></tgroup></adobetable>
     
     <p>When the display object is scaled or stretched, the objects within the rectangle scale
     normally, but the objects outside of the rectangle scale according to the
     <codeph>scale9Grid</codeph> rules:</p>
     
     <adobetable>
      
     
      
     
      
     
      
     
     <tgroup cols="2"><tbody><row>
      <entry>Scaled to 75%:</entry>
      <entry><adobeimage alt="display object at 75%" href="../../images/scale9Grid-c.jpg"/></entry>
      </row><row>
      <entry>Scaled to 50%:</entry>
      <entry><adobeimage alt="display object at 50%" href="../../images/scale9Grid-d.jpg"/></entry>
      </row><row>
      <entry>Scaled to 25%:</entry>
      <entry><adobeimage alt="display object at 25%" href="../../images/scale9Grid-e.jpg"/></entry>
      </row><row>
      <entry>Stretched horizontally 150%: </entry>
      <entry><adobeimage alt="display stretched 150%" href="../../images/scale9Grid-f.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     
     <p>A common use for setting <codeph>scale9Grid</codeph> is to set up a display object to be used
     as a component, in which edge regions retain the same width when the component is scaled.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scale9Grid.1.as"> The following code creates a Shape object with a rectangle drawn in its 
 <codeph>graphics</codeph> property. The rectangle has a 20-pixel-thick line as the border and 
 it is filled with a gradient. The timer event calls the <codeph>scale()</codeph> function, which
 scales the Shape object by adjusting the <codeph>scaleX</codeph> and <codeph>scaleY</codeph> properties.
 The <codeph>scale9Grid</codeph> applied to the Shape object prevents the rectangle's border line 
 from scaling  only the gradient fill scales:
<codeblock>

import flash.display.Shape;
import flash.display.GradientType;
import flash.display.SpreadMethod;
import flash.display.InterpolationMethod;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var square:Shape = new Shape();
square.graphics.lineStyle(20, 0xFFCC00);
var gradientMatrix:Matrix = new Matrix();
gradientMatrix.createGradientBox(15, 15, Math.PI, 10, 10);
square.graphics.beginGradientFill(GradientType.RADIAL, 
            [0xffff00, 0x0000ff], 
            [100, 100], 
            [0, 0xFF], 
            gradientMatrix, 
            SpreadMethod.REFLECT, 
            InterpolationMethod.RGB, 
            0.9);
square.graphics.drawRect(0, 0, 100, 100);

var grid:Rectangle = new Rectangle(20, 20, 60, 60);
square.scale9Grid = grid ;

addChild(square);

var tim:Timer = new Timer(100);
tim.start();
tim.addEventListener(TimerEvent.TIMER, scale);

var scaleFactor:Number = 1.01;

function scale(event:TimerEvent):void {
    square.scaleX *= scaleFactor;
    square.scaleY *= scaleFactor;
    
    if (square.scaleX &gt; 2.0) {
        scaleFactor = 0.99;
    }
    if (square.scaleX &lt; 1.0) {
        scaleFactor = 1.01;
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scaleX:get"><apiName>scaleX</apiName><shortdesc>
     Indicates the horizontal scale (percentage) of the object as applied from the registration point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the horizontal scale (percentage) of the object as applied from the registration point. The default
     registration point is (0,0). 1.0 equals 100% scale.
     
     <p>Scaling the local coordinate system changes the <codeph>x</codeph> and <codeph>y</codeph> property values, which are defined in
     whole pixels. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> The following code creates a Sprite object with a rectangle drawn in its 
 <codeph>graphics</codeph> property. When the user clicks the sprite, it scales by 10%:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleY:get"><apiName>scaleY</apiName><shortdesc>
     Indicates the vertical scale (percentage) of an object as applied from the registration point of the object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the vertical scale (percentage) of an object as applied from the registration point of the object. The
     default registration point is (0,0). 1.0 is 100% scale.
     
     <p>Scaling the local coordinate system changes the <codeph>x</codeph> and <codeph>y</codeph> property values, which are defined in
     whole pixels. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> The following code creates a Sprite object with a rectangle drawn in its 
 <codeph>graphics</codeph> property. When the user clicks the sprite, it scales by 10%:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleZ:get"><apiName>scaleZ</apiName><shortdesc>
     Indicates the depth scale (percentage) of an object as applied from the registration point of the object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the depth scale (percentage) of an object as applied from the registration point of the object. The
     default registration point is (0,0). 1.0 is 100% scale.
     
     <p>Scaling the local coordinate system changes the <codeph>x</codeph>, <codeph>y</codeph> and <codeph>z</codeph> property values, which are defined in
     whole pixels. </p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/z"><linktext>z</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scrollRect:get"><apiName>scrollRect</apiName><shortdesc>
     The scroll rectangle bounds of the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     The scroll rectangle bounds of the display object. The display object is cropped to the size 
     defined by the rectangle, and it scrolls within the rectangle when you change the 
     <codeph>x</codeph> and <codeph>y</codeph> properties of the <codeph>scrollRect</codeph> object.
     
     <p>The properties of the <codeph>scrollRect</codeph> Rectangle object use the display object's coordinate space 
     and are scaled just like the overall display object. The corner bounds of the cropped window on the scrolling 
     display object are the origin of the display object (0,0) and the point defined by the
     width and height of the rectangle. They are not centered around the origin, but 
     use the origin to define the upper-left corner of the area. A scrolled display object always 
     scrolls in whole pixel increments. </p>
     
     <p>You can scroll an object left and right by setting the <codeph>x</codeph> property of the 
     <codeph>scrollRect</codeph> Rectangle object. You can scroll an object up and down by setting 
     the <codeph>y</codeph> property of the <codeph>scrollRect</codeph> Rectangle object. If the display object 
     is rotated 90° and you scroll it left and right, the display object actually scrolls up and down.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scrollRect.1.as"> The following example shows how the <codeph>scrollRect</codeph> property defines the
 scrolling area for a display object, <codeph>circle</codeph>. When you click the <codeph>circle</codeph> object,
 the <codeph>clicked()</codeph> event handler method adjusts the <codeph>y</codeph> property of the 
 <codeph>scrollRect</codeph> property of the <codeph>circle</codeph> object, causing the object to scroll down:
<codeblock>

import flash.display.Sprite;
import flash.geom.Rectangle;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(200, 200, 200);
circle.scrollRect = new Rectangle(0, 0, 200, 200);
addChild(circle);

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    var rect:Rectangle = event.target.scrollRect;
    rect.y -= 5;
    event.target.scrollRect = rect;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:stage:get"><apiName>stage</apiName><shortdesc>
     The Stage of the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
     The Stage of the display object. A Flash application has only one Stage object.
     For example, you can create and load multiple display objects into the display list, and the
     <codeph>stage</codeph> property of each display object refers to the same Stage object (even if the
     display object belongs to a loaded SWF file).
     
     <p>If a display object is not added to the display list, its <codeph>stage</codeph> property is set to 
     <codeph>null</codeph>.</p>
     
     </apiDesc><example conref="examples\DisplayObject.stage.1.as"> The following code creates two TextField objects and uses the 
 <codeph>width</codeph> property of the Stage object to position the text fields:
<codeblock>

import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.x = 10;
addChild(tf1);
tf1.width = tf1.stage.stageWidth / 2 - 10;

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.x = tf1.x + tf1.width + 5;
addChild(tf2);
tf2.width = tf2.stage.stageWidth / 2 - 10;

trace(stage.stageWidth);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:transform:get"><apiName>transform</apiName><shortdesc>
    An object with properties pertaining to a display object's matrix, color transform, and pixel bounds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Transform</apiValueClassifier></apiValueDef><apiDesc>
    An object with properties pertaining to a display object's matrix, color transform, and pixel bounds.
    The specific properties — matrix, colorTransform, and three read-only properties 
    (<codeph>concatenatedMatrix</codeph>, <codeph>concatenatedColorTransform</codeph>, 
    and <codeph>pixelBounds</codeph>) — are described in the entry for the Transform class.
    
    <p>Each of the transform object's properties is itself an object. This concept is important because the only
    way to set new values for the matrix or colorTransform objects is to create a new object and copy that
    object into the transform.matrix or transform.colorTransform property.</p>
    
    <p>For example, to increase the <codeph>tx</codeph> value of a display object's matrix, you must make a
    copy of the entire matrix object, then copy the new object into the matrix property of the transform
    object:</p>
    
    <pre><codeph>
    var myMatrix:Matrix = myDisplayObject.transform.matrix;  
    myMatrix.tx += 10; 
    myDisplayObject.transform.matrix = myMatrix;  
    </codeph></pre>
    
    <p>You cannot directly set the <codeph>tx</codeph> property. The following code has
    no effect on <codeph>myDisplayObject</codeph>: </p>
    
    <pre><codeph>
    myDisplayObject.transform.matrix.tx += 10;
    </codeph></pre>
    
    <p>You can also copy an entire transform object and assign it to another
    display object's transform property. For example, the following code 
    copies the entire transform object from <codeph>myOldDisplayObj</codeph> to
    <codeph>myNewDisplayObj</codeph>:</p>
    <codeph>myNewDisplayObj.transform = myOldDisplayObj.transform;</codeph>
    <p>The resulting display object, <codeph>myNewDisplayObj</codeph>, now has the same values for its
    matrix, color transform, and pixel bounds as the old display object, <codeph>myOldDisplayObj</codeph>.</p>
     
    </apiDesc><example conref="examples\DisplayObject.transform.1.as"> The following code sets up a <codeph>square</codeph> Sprite object. 
 When the user clicks the sprite, the <codeph>transformer()</codeph> method adjusts
 the <codeph>colorTransform</codeph> and <codeph>matrix</codeph> properties of the 
 <codeph>transform</codeph> property of the sprite:
<codeblock>

import flash.display.Sprite;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Transform;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.lineStyle(20, 0xFF2200);
square.graphics.beginFill(0x0000DD);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

var resultColorTransform:ColorTransform = new ColorTransform();
resultColorTransform.alphaMultiplier = 0.5;
resultColorTransform.redOffset = 155;
resultColorTransform.greenMultiplier = 0.5;

var skewMatrix:Matrix = new Matrix(1, 1, 0, 1);

square.addEventListener(MouseEvent.CLICK, transformer);

function transformer(event:MouseEvent):void {
    var transformation:Transform = square.transform;
    var tempMatrix:Matrix = square.transform.matrix;
    tempMatrix.concat(skewMatrix);
    square.transform.colorTransform = resultColorTransform;
    
    square.transform.matrix = tempMatrix;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Transform"><linktext>Transform class</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:visible:get"><apiName>visible</apiName><shortdesc>
     Whether or not the display object is visible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Whether or not the display object is visible. Display objects that are not visible
     are disabled. For example, if <codeph>visible=false</codeph> for an InteractiveObject instance,
     it cannot be clicked.
     
     </apiDesc><example conref="examples\DisplayObject.visible.1.as"> The following code uses a Timer object to call a function that 
 periodically changes the <codeph>visible</codeph> property of a display object,
 resulting in a blinking effect:
<codeblock>

import flash.text.TextField;
import flash.utils.Timer;
import flash.events.TimerEvent;

var tf:TextField = new TextField();
tf.text = "Hello.";
addChild(tf);

var tim:Timer = new Timer(250);
tim.start();
tim.addEventListener(TimerEvent.TIMER, blinker);

function blinker(event:TimerEvent):void {
    tf.visible = !tf.visible;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:width:get"><apiName>width</apiName><shortdesc>
     Indicates the width of the display object, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the width of the display object, in pixels. The width is calculated based on the bounds of the content of the display object.
     When you set the <codeph>width</codeph> property, the <codeph>scaleX</codeph> property is adjusted accordingly, as shown in the 
     following code:
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>Except for TextField and Video objects, a display object with no content (such as an empty sprite) has a width 
    of 0, even if you try to set <codeph>width</codeph> to a different value.</p>
     
     </apiDesc><example conref="examples\DisplayObject.width.1.as"> The following code sets up a <codeph>square</codeph> Sprite object. 
 When the user clicks the sprite, the <codeph>widen()</codeph> method increases
 the <codeph>width</codeph> property of the sprite:
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, widen);

function widen(event:MouseEvent):void {
    square.width += 10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:x:get"><apiName>x</apiName><shortdesc>
     Indicates the x coordinate of the DisplayObject instance relative to the local coordinates of
     the parent DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the <i>x</i> coordinate of the DisplayObject instance relative to the local coordinates of
     the parent DisplayObjectContainer. If the object is inside a DisplayObjectContainer that has
     transformations, it is in the local coordinate system of the enclosing DisplayObjectContainer.
     Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the DisplayObjectContainer's
     children inherit a coordinate system that is rotated 90° counterclockwise.
     The object's coordinates refer to the registration point position.
     
     </apiDesc><example conref="examples\DisplayObject.x.1.as"> The following code sets up a <codeph>circle</codeph> Sprite object. 
 A Timer object is used to change the <codeph>x</codeph> property of the sprite
 every 50 milliseconds:
<codeblock>

import flash.display.Sprite;
import flash.utils.Timer;
import flash.events.TimerEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(100, 100, 100);
addChild(circle);

var tim:Timer = new Timer(50);
tim.start();
tim.addEventListener(TimerEvent.TIMER, bounce);

var xInc:Number = 2;

function bounce(event:TimerEvent):void {
    circle.x += xInc;
    if (circle.x &gt; circle.width) {
        xInc = -2;
    }
    if (circle.x &lt; 0) {
        xInc = 2;
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:y:get"><apiName>y</apiName><shortdesc>
     Indicates the y coordinate of the DisplayObject instance relative to the local coordinates of
     the parent DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the <i>y</i> coordinate of the DisplayObject instance relative to the local coordinates of
     the parent DisplayObjectContainer. If the object is inside a DisplayObjectContainer that has
     transformations, it is in the local coordinate system of the enclosing DisplayObjectContainer.
     Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the DisplayObjectContainer's
     children inherit a coordinate system that is rotated 90° counterclockwise.
     The object's coordinates refer to the registration point position.
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> The following code creates two TextField objects and adjusts the 
 <codeph>height</codeph> property of each based on the <codeph>textHeight</codeph> property of 
 each; it also positions the second text field by setting its <codeph>y</codeph> property:
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:z:get"><apiName>z</apiName><shortdesc>
     Indicates the z coordinate position along the z-axis of the DisplayObject
     instance relative to the 3D parent container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the z coordinate position along the z-axis of the DisplayObject
     instance relative to the 3D parent container. The z property is used for
     3D coordinates, not screen or pixel coordinates. 
     <p>When you set a <codeph>z</codeph> property for a display object to something other than the default 
     value of <codeph>0</codeph>, a corresponding Matrix3D object is automatically created. for adjusting a 
     display object's position and orientation
     in three dimensions. When working with the z-axis, 
     the existing behavior of x and y properties changes from screen or pixel coordinates to
     positions relative to the 3D parent container.</p>
     <p>For example, a child of the <codeph>_root</codeph>  at position x = 100, y = 100, z = 200
     is not drawn at pixel location (100,100). The child is drawn wherever the 3D projection
     calculation puts it. The calculation is:</p>
     <p><codeph> (x~~cameraFocalLength/cameraRelativeZPosition, y~~cameraFocalLength/cameraRelativeZPosition)</codeph></p>
     
     
     </apiDesc><example conref="examples\ZAxisExample1.as"> This example draws two ellipses and has them go back and forth (down and up the 
 <codeph>z</codeph> axis) toward the vanishing point. One ellipse is set to move faster 
 than the other. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.geom.*;

    public class ZAxisExample1 extends MovieClip {
        private var ellipse1Back:int = 1;
        private var ellipse2Back:int = 1;
        private var depth:int = 1000;
        
        public function ZAxisExample1():void {
            
            var ellipse1 = drawEllipse((this.stage.stageWidth / 2) - 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 10);
            var ellipse2 = drawEllipse((this.stage.stageWidth / 2) + 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 300);

            this.addChild(ellipse1);
            this.addChild(ellipse2);
            
            ellipse1.addEventListener(Event.ENTER_FRAME, ellipse1FrameHandler);
            ellipse2.addEventListener(Event.ENTER_FRAME, ellipse2FrameHandler);
        }

        private function drawEllipse(x:Number, y:Number, w:Number, h:Number, z:Number):Shape {
            var s:Shape = new Shape();                            
            s.z = z;
            s.graphics.beginFill(0xFF0000);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(x, y, w, h);
            s.graphics.endFill();
            return s;
        }

        private function ellipse1FrameHandler(e:Event):void {
            ellipse1Back = setDepth(e, ellipse1Back);
            e.currentTarget.z += ellipse1Back * 10;
        }

        private function ellipse2FrameHandler(e:Event):void {
            ellipse2Back = setDepth(e, ellipse2Back);
            e.currentTarget.z += ellipse2Back * 20;
        }

        private function setDepth(e:Event, d:int):int {
            if(e.currentTarget.z &gt; depth) {
                e.currentTarget.z = depth; 
                d = -1;
            }else if (e.currentTarget.z &lt;  0) {
                e.currentTarget.z = 0;
                d = 1;
            }
            return d;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>transform</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:blendShader:set"><apiName>blendShader</apiName><shortdesc>
     Sets a shader that is used for blending the foreground and background.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.display:Shader</apiValueClassifier><apiException><apiDesc>When the shader output type is not compatible with this operation 
                           (the shader must specify a <codeph>pixel4</codeph> 
                           output).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the shader specifies fewer than two image inputs or the first
                           two inputs are not an <codeph>image4</codeph> inputs.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the shader specifies an image input that isn't provided.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When a ByteArray or Vector.&lt;Number&gt; instance is used as 
                           an input and the <codeph>width</codeph> 
                           and <codeph>height</codeph> properties aren't specified for the 
                           ShaderInput, or the specified values don't match the amount of 
                           data in the input object. See the <codeph>ShaderInput.input</codeph> 
                           property for more information.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Sets a shader that is used for blending the foreground and background. When the 
     <codeph>blendMode</codeph> property is set to <codeph>BlendMode.SHADER</codeph>, the specified 
     Shader is used to create the blend mode output for the display object.
     
     <p>Setting the <codeph>blendShader</codeph> property of a display object to a Shader instance 
     automatically sets the display object's <codeph>blendMode</codeph> property to 
     <codeph>BlendMode.SHADER</codeph>. If the <codeph>blendShader</codeph> property is set (which sets the 
     <codeph>blendMode</codeph> property to <codeph>BlendMode.SHADER</codeph>), then the value of the 
     <codeph>blendMode</codeph> property is changed, the blend mode can be reset to use the blend 
     shader simply by setting the <codeph>blendMode</codeph> property to <codeph>BlendMode.SHADER</codeph>. 
     The <codeph>blendShader</codeph> property does not need to be set again except to change the 
     shader that's used for the blend mode.</p>
     
     <p>The Shader assigned to the <codeph>blendShader</codeph> property must specify at least two 
     <codeph>image4</codeph> inputs. The inputs <b>do not</b> need to be specified in code using the 
     associated ShaderInput objects' <codeph>input</codeph> properties. The background display object 
     is automatically 
     used as the first input (the input with <codeph>index</codeph> 0). The foreground display object 
     is used as the second input (the input with <codeph>index</codeph> 1). A shader used as a blend 
     shader can specify more than two inputs. In that case any additional input must be specified 
     by setting its ShaderInput instance's <codeph>input</codeph> property.</p>
     
     <p>When you assign a Shader instance to this property the shader is copied internally. The 
     blend operation uses that internal copy, not a reference to the original shader. Any changes 
     made to the shader, such as changing a parameter value, input, or bytecode, are not applied 
     to the copied shader that's used for the blend mode.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Loader"><apiName>Loader</apiName><shortdesc>
 The Loader class is used to load SWF files or image (JPG, PNG, or GIF) files.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Loader class is used to load SWF files or image (JPG, PNG, or GIF) files. Use the 
 <codeph>load()</codeph> method to initiate loading. The loaded display object is added as a child 
 of the Loader object.
 
 <p>Use the URLLoader class to load text or binary data.</p>
 
 <p>The Loader class overrides the following methods that it inherits, because a Loader object can only
 have one child display object—the display object that it loads. Calling the following methods throws an
 exception: <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph>, <codeph>removeChild()</codeph>,
 <codeph>removeChildAt()</codeph>, and <codeph>setChildIndex()</codeph>. To remove a loaded display object, 
 you must remove the <i>Loader</i> object from its parent DisplayObjectContainer child array. </p>
 
 <p><b>Note:</b> The ActionScript 2.0 MovieClipLoader and LoadVars classes are not used 
 in ActionScript 3.0. The Loader and URLLoader classes replace them.</p>
 
 <p>When you use the Loader class, consider the Flash Player and Adobe AIR security model: </p>
 
 <ul>
  <li>You can load content from any accessible source. </li>
 
  <li>Loading is not allowed if the calling SWF file is in a network sandbox and the file 
 to be loaded is local. </li>
 
  <li>If the loaded content is a SWF file written with ActionScript 3.0, it cannot be 
 cross-scripted by a SWF file in another security sandbox unless that cross-scripting 
 arrangement was approved through a call to the <codeph>System.allowDomain()</codeph> or  
 the <codeph>System.allowInsecureDomain()</codeph> method in the loaded content file.</li>
  
  <li>If the loaded content is an AVM1 SWF file (written using ActionScript 1.0 or 2.0), 
 it cannot be cross-scripted by an AVM2 SWF file (written using ActionScript 3.0). However, 
 you can communicate between the two SWF files by using the LocalConnection class.</li>
  
  <li>If the loaded content is an image, its data cannot be accessed by a SWF file    
 outside of the security sandbox, unless the domain of that SWF file was included in a 
 URL policy file at the origin domain of the image.</li>
 
  <li>Movie clips in the local-with-file-system sandbox cannot script movie clips in the 
 local-with-networking sandbox, and the reverse is also prevented. </li>
 
  <li>You cannot connect to commonly reserved ports. For a complete list of blocked
  ports, see "Restricting Networking APIs" in the 
  <ph product="flex">
  <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
  </ph>
  <ph product="flash">
  <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
  </ph>
  of the <i>Programming ActionScript 3.0</i> book. </li>
 
 
 </ul>
 
 <p>However, in AIR, content in the <codeph>application</codeph> security sandbox (content
 installed with the AIR application) are not restricted by these security limitations.</p>
 
 <p>For more information, see the following:</p>
 
 <ul>
 
 <li class="flexonly">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref> in the
 <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
 <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
 in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
 
 <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
 
 </ul>
 
 <p>When loading a SWF file from an untrusted source (such as a domain other than that of 
 the Loader object's root SWF file), you may want to define a mask for the Loader object, 
 to prevent the loaded content (which is a child of the Loader object) from drawing to 
 portions of the Stage outside of that mask, as shown in the following code:</p>
 
 <codeblock>import flash.display.~~;
 import flash.net.URLRequest;
 var rect:Shape = new Shape();
 rect.graphics.beginFill(0xFFFFFF);
 rect.graphics.drawRect(0, 0, 100, 100);
 rect.graphics.endFill();
 addChild(rect);
 var ldr:Loader = new Loader();
 ldr.mask = rect;
 var url:String = "http://www.unknown.example.com/content.swf";
 var urlReq:URLRequest = new URLRequest(url);
 ldr.load(urlReq);
 addChild(ldr);
 </codeblock>
 
 </apiDesc><example conref="examples\LoaderExample.as"> The following example uses the LoaderExample class to illustrate how various
 event listeners are used.  This task is accomplished by performing the following steps:
 <ol>
  <li>A <codeph>url</codeph> property is created, which is the location and name of the image file</li>
  <li>In the <codeph>LoaderExample</codeph> constructor, a new Loader object named <codeph>loader</codeph> is
  created, which is then passed to the <codeph>configureListeners()</codeph> method, described in step 3.</li>
  <li>The constructor creates a new instance of a URLRequest object,
  <codeph>request</codeph>, with <codeph>url</codeph> passed so that the file name and location are known.</li>
  <li>The <codeph>request</codeph> object is passed to the <codeph>loader</codeph> object's 
  <codeph>load()</codeph> method, which loads the image onto the display list.</li>
  <li>A <codeph>clickHandler</codeph> event listener is registered for the <codeph>click</codeph> event on the loader.
      After a mouse click, the loaded image is unloaded.</li>
  <li>The <codeph>configureListeners()</codeph> method adds seven event listeners by using the following methods:
  <ul>
      <li>The <codeph>completeHandler()</codeph> method executes when the image finishes loading.</li>
 
      <li>The <codeph>httpStatusHandler()</codeph> method executes if the image is not loaded 
      locally and only if the network request is made available and the Flash Player can detect it.</li>
 
      <li>The <codeph>initHandler()</codeph> method executes before the <codeph>completeHandler()</codeph> 
      method and after the <codeph>progressHandler()</codeph> method. Generally, the <codeph>init</codeph> 
      event is more useful when loading SWF files.</li>
 
      <li>The <codeph>ioErrorHandler()</codeph> method executes if the image file is not available or not 
      accessible.</li>
 
      <li>The <codeph>openHandler()</codeph> method executes when the image file is first opened.</li>
 
      <li>The <codeph>progressHandler()</codeph> method executes when the image file starts to load and 
      again when the image is finished loading.</li>
 
      <li>The <codeph>unLoadHandler()</codeph> method executes when the image is unloaded by using the 
      <codeph>unload()</codeph> method when the user clicks the image.</li>
 
  </ul>
  </li>
 </ol>
 <p> Keep in mind the following requirements:</p>
 
 <ul>
  <li>This example requires that you place a file named Image.gif in the same directory as the compiled SWF file.
  Use an image that has an area that fits within the dimensions of the main SWF file.</li>
 
  <li>Although this example makes use of all events available to the LoaderInfo object, most situations 
  require only a subset.  In particular, when loading only an image file, the <codeph>complete</codeph> event 
  (and perhaps the <codeph>ioError</codeph> event) are sufficient when loading a local image.</li>
 
 </ul>
 
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderExample() {
            var loader:Loader = new Loader();
            configureListeners(loader.contentLoaderInfo);
            loader.addEventListener(MouseEvent.CLICK, clickHandler);

            var request:URLRequest = new URLRequest(url);
            loader.load(request);

            addChild(loader);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(Event.INIT, initHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(Event.UNLOAD, unLoadHandler);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function initHandler(event:Event):void {
            trace("initHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function unLoadHandler(event:Event):void {
            trace("unLoadHandler: " + event);
        }

        private function clickHandler(event:MouseEvent):void {
            trace("clickHandler: " + event);
            var loader:Loader = Loader(event.target);
            loader.unload();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:Loader:Loader"><apiName>Loader</apiName><shortdesc>
     Creates a Loader object that you can use to load files, such as SWF, JPEG, GIF, or PNG files.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need wording on parent/child relationships, root DisplayObjects, and so on.
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Creates a Loader object that you can use to load files, such as SWF, JPEG, GIF, or PNG files.
     Call the <codeph>load()</codeph> method to load the asset as a child of the Loader instance. 
     You can then add the Loader object to the display list (for instance, by using the 
     <codeph>addChild()</codeph> method of a DisplayObjectContainer instance).  
     The asset appears on the Stage as it loads.
     
     <p>You can also use a Loader instance "offlist," that is without adding it to a display object
     container on the display list. In this mode, the Loader instance might be used to load a SWF file 
     that contains additional modules of an application. </p>
     
     <p>To detect when the SWF file is finished loading, you can use the events of the LoaderInfo  
     object associated with the <codeph>contentLoaderInfo</codeph> property of the Loader object.
     At that point, the code in the module SWF file can be executed to initialize and start the module.
     In the offlist mode, a Loader instance might also be used to load a SWF file that contains components or 
     media assets. Again, you can use the LoaderInfo object event notifications to detect when the 
	 components are finished loading. At that point, the application can start using the components 
     and media assets in the library of the SWF file by instantiating the ActionScript 3.0 classes that represent 
     those components and assets.</p>
     
     <p>To determine the status of a Loader object, monitor the following events that the LoaderInfo  
     object associated with the <codeph>contentLoaderInfo</codeph> property of the Loader object:</p>
     
     <ul>
       
     <li>The <codeph>open</codeph> event is dispatched when loading begins.</li>
       
     <li>The <codeph>ioError</codeph> or <codeph>securityError</codeph> event is dispatched if the file 
     cannot be loaded or if an error occured during the load process. </li>
       
     <li>The <codeph>progress</codeph> event fires continuously while the file is being loaded.</li>
       
     <li>The <codeph>complete</codeph> event is dispatched when a file completes downloading, but before
     the loaded movie clip's methods and properties are available. </li>
       
     <li>The <codeph>init</codeph> event is dispatched after the properties and methods of the loaded SWF file
     are accessible, so you can begin manipulating the loaded SWF file. 
     This event is dispatched before the <codeph>complete</codeph> handler. In streaming SWF files, 
     the <codeph>init</codeph> event can occur significantly earlier than the <codeph>complete</codeph> event. 
     For most purposes, use the <codeph>init</codeph> handler.</li>
     
     </ul>
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:Loader:close"><apiName>close</apiName><shortdesc>
     Cancels a load() method operation that is currently in progress for the Loader instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Cancels a <codeph>load()</codeph> method operation that is currently in progress for the Loader instance.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:load"><apiName>load</apiName><shortdesc>
     Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an object that is a child of 
     this Loader object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how to use the <code>MovieClipLoader.loadClip()</code> 
     method by creating a handler for the <code>onLoadInit</code> event and then making the request.
     <p>You should either place the following code directly into a frame action on a Timeline, or 
     paste it into a class that extends MovieClip. This code also expects an image named YourImage.jpg
     to exist in the same directory as the compiled SWF file.</p>
     
     <listing version="2.0">
     var container:MovieClip = createEmptyMovieClip("container", getNextHighestDepth());
     var mcLoader:MovieClipLoader = new MovieClipLoader();
     mcLoader.addListener(this);
     mcLoader.loadClip("YourImage.jpg", container);
     
     function onLoadInit(mc:MovieClip) {
         trace("onLoadInit: " + mc);
     }
     </listing>
     
     </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The <codeph>digest</codeph> property of the <codeph>request</codeph> object is not 
     <codeph>null</codeph>. You should only set the <codeph>digest</codeph> property of a URLRequest object
     when calling the <codeph>URLLoader.load()</codeph> method when loading a SWZ file (an Adobe 
     platform component).
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>The value of <codeph>LoaderContext.securityDomain</codeph> must be either <codeph>null</codeph>
     or <codeph>SecurityDomain.currentDomain</codeph>.  This reflects the fact that you can only
     place the loaded media in its natural security sandbox or your own (the latter requires a
     policy file).
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Local SWF files may not set LoaderContext.securityDomain to anything
     other than <codeph>null</codeph>.  It is not permitted to import non-local media into a local
     sandbox, or to place other local media in anything other than its natural sandbox.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If you are trying to connect to a commonly reserved port. 
      For a complete list of blocked ports, see "Restricting Networking APIs" in the 
      security chapter of the <i>Programming ActionScript 3.0</i> book.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the <codeph>applicationDomain</codeph> or <codeph>securityDomain</codeph> 
     properties of the <codeph>context</codeph> parameter are from a disallowed domain.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If a local SWF file is attempting to use the <codeph>securityDomain</codeph> property
     of the <codeph>context</codeph> parameter.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> The absolute or relative URL of the SWF, JPEG, GIF, or PNG file to be loaded. A 
     relative path must be relative to the main SWF file. Absolute URLs must include the 
     protocol reference, such as http:// or file:///. Filenames cannot include disk drive 
     specifications.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>A LoaderContext object, which has properties that define the following:
     
     <ul>
     
	 <li>Whether or not to check for the existence of a policy file 
     upon loading the object</li>
     
     <li>The ApplicationDomain for the loaded object</li>
     
     <li>The SecurityDomain for the loaded object</li>
     
     </ul>
     <p>If the <codeph>context</codeph> parameter is not specified or refers to a null object,
     the loaded content remains in its own security domain.</p>
     
     <p>For complete details, see the description of the properties in the 
     <xref href="../system/LoaderContext.html">LoaderContext</xref> class.</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Loads a SWF file or image file into a DisplayObject that is a child of this Loader instance.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an object that is a child of 
     this Loader object. If you load an animated GIF file, only the first frame is displayed.
     As the Loader object can contain only a single child, issuing a subsequent <codeph>load()</codeph> 
     request terminates the previous request, if still pending, and commences a new load.
     
     <p><b>Note</b>: 
     In  AIR 1.5 and Flash Player 10, the maximum size for a loaded image is 8,191 pixels in width or height, 
     and the total number of pixels cannot exceed 16,777,215 pixels. (So, if an loaded image is 8,191 pixels 
     wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation
     is 2,880 pixels in height and 2,880 pixels in width.</p>
     
     <p>A SWF file or image loaded into a Loader object inherits the position, rotation, and scale 
     properties of the parent display objects of the Loader object. </p>
     
     <p>Use the <codeph>unload()</codeph> method to remove movies or images loaded with this 
     method, or to cancel a load operation that is in progress.</p>
     
     <p>You can prevent a SWF file from using this method by setting the  <codeph>allowNetworking</codeph> 
     parameter of the the <codeph>object</codeph> and <codeph>embed</codeph> tags in the HTML 
     page that contains the SWF content.</p>
     
     <p>When you use this method, consider the Flash Player security model,
      which is described in the Loader class description. </p>
     
     <p> In Flash Player 10 and later, if you use a multipart Content-Type (for example "multipart/form-data") 
	 that contains an upload (indicated by a "filename" parameter in a "content-disposition" header within the POST body),
	 the POST operation is subject to the security rules applied to uploads:</p>
	 <ul>
	 <li>The POST operation must be performed in response to a user-initiated action, such as a mouse click or key press.</li>
	 <li>If the POST operation is cross-domain (the POST target is not on the same server as the SWF file 
	 that is sending the POST request),
	 the target server must provide a URL policy file that permits cross-domain access.</li>
	 </ul>
     <p>Also, for any multipart Content-Type, the syntax must be valid (according to the RFC2046 standard).
     If the syntax appears to be invalid, the POST operation is subject to the security rules applied to uploads.</p>
     <p>For more information related to security, see the following:</p>
     
     <ul>
     
     <li class="flexonly">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     
     <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
     
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/contentLoaderInfo"><linktext>contentLoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>flash.display.Loader.unload()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><adobeApiEvent id="flash.display:Loader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object when the file has 
     completed loading. The <codeph>complete</codeph> event is always dispatched after the <codeph>init</codeph> event.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object when the file has 
     completed loading.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object when a network 
     request is made over HTTP and Flash Player can detect the HTTP status code.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object when a network 
     request is made over HTTP and Flash Player can detect the HTTP status code.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_init"><apiName>init</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object when the properties and methods 
     of the loaded SWF file are accessible. The <codeph>init</codeph> event always precedes the <codeph>complete</codeph> 
     event.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object when the properties and methods 
     of the loaded SWF file are accessible.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object when an input or output 
     error occurs that causes a load operation to fail.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object when an input or output 
     error occurs that causes a load operation to fail.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object when the loading operation starts.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object when the loading operation starts.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object as data is received 
     while load operation progresses.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object as data is received 
     while load operation progresses.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object if a SWF file 
     in the local-with-filesystem sandbox attempts to load content in the local-with-networking sandbox, or vice versa.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object if a SWF file 
     in the local-with-filesystem sandbox attempts to load content in the local-with-networking sandbox, or vice versa.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_unload"><apiName>unload</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched by the <codeph>contentLoaderInfo</codeph> object when a loaded object is removed.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched by the contentLoaderInfo object when a loaded object is removed.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:Loader:loadBytes"><apiName>loadBytes</apiName><shortdesc>
     Loads from binary data stored in a ByteArray object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>length</codeph> property of the ByteArray object is not
     greater than 0.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the <codeph>checkPolicyFile</codeph> or <codeph>securityDomain</codeph> 
     property of the <codeph>context</codeph> parameter are non-null.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If the provided <codeph>applicationDomain</codeph> property of the 
     <codeph>context</codeph> property is from a disallowed domain.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If you are trying to connect to a commonly reserved port. 
      For a complete list of blocked ports, see "Restricting Networking APIs" in the 
      security chapter of the <i>Programming ActionScript 3.0</i> book.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>A ByteArray object. The contents of the ByteArray can be 
     any of the file formats supported by the Loader class: SWF, GIF, JPEG, or PNG.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>A LoaderContext object. Only the <codeph>applicationDomain</codeph> property 
     of the LoaderContext object applies; the <codeph>checkPolicyFile</codeph> and <codeph>securityDomain</codeph> 
     properties of the LoaderContext object do not apply. 
     
     <p>If the <codeph>context</codeph> parameter is not 
     specified or refers to a null object, the content is loaded into the current security domain— a
     process referred to as "import loading" in Flash Player security documentation. Specifically, 
     if the loading SWF file trusts the remote SWF by incorporating the remote SWF into its code, 
     then the loading SWF can import it directly into its own security domain.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Loads from binary data stored in a ByteArray object.
     
     <p>When you use this method, consider the Flash Player security model,
      which is described in the Loader class description. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unload"><apiName>unload</apiName><shortdesc>
     Removes a child of this Loader object that was loaded by using the load() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The funky-looking code formatting above is intentional to work around a bug!
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Removes a child of this Loader object that was loaded by using the <codeph>load()</codeph> method. 
     The <codeph>property</codeph> of the associated LoaderInfo object is reset to <codeph>null</codeph>.  
     The child is not necessarily destroyed because other objects might have references to it; however,
     it is no longer a child of the Loader object.
     
     <p>As a best practice, before you unload a child SWF file, you should explicitly
     close any streams in the child SWF file's objects, such as LocalConnection, NetConnection,
     NetStream, and Sound objects. Otherwise, audio in the child SWF file might continue to play, even
     though the child SWF file was unloaded. To close streams in the child SWF file, add an event listener
     to the child that listens for the <codeph>unload</codeph> event. When the parent calls
     <codeph>Loader.unload()</codeph>, the <codeph>unload</codeph> event is dispatched to the child.
     The following code shows how you might do this:</p>
<pre>
function closeAllStreams(evt:Event) { 
    myNetStream.close();
    mySound.close();
    myNetConnection.close();
    myLocalConnection.close();
}

myMovieClip.loaderInfo.addEventListener(Event.UNLOAD, closeAllStreams);</pre>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.media.xml#Sound/close()"><linktext>flash.media.Sound.close()</linktext></link><link href="flash.net.xml#LocalConnection/close()"><linktext>flash.net.LocalConnection.close()</linktext></link><link href="flash.net.xml#NetConnection/close()"><linktext>flash.net.NetConnection.close()</linktext></link><link href="flash.net.xml#NetStream/close()"><linktext>flash.net.NetStream.close()</linktext></link><link href="../../operators.html#delete"><linktext>delete operator</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unloadAndStop"><apiName>unloadAndStop</apiName><shortdesc>
     Attempts to unload child SWF file contents and stops the execution of commands from loaded SWF files.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>gc</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Provides a hint to the garbage collector to run on the child SWF objects (<codeph>true</codeph>) or not (<codeph>false</codeph>).
	 If you are unloading many objects asynchronously, setting the <codeph>gc</codeph> paramter to <codeph>false</codeph> might improve 
	 application performance. However, if the parameter is set to 
	 <codeph>false</codeph>, media and display objects of the child SWF file might persist in memory after running the 
	 <codeph>unloadAndStop()</codeph> command.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Attempts to unload child SWF file contents and stops the execution of commands from loaded SWF files. 
     This method attempts to unload SWF files
     that were loaded using <codeph>Loader.load()</codeph> or <codeph>Loader.loadBytes()</codeph> by removing references to EventDispatcher,
     NetConnection, Timer, Sound, or Video objects of the child SWF file. As a result, the following occurs for the child SWF file
     and the child SWF file's display list:
     <ul><li>Sounds are stopped.</li>
     <li>Stage event listeners are removed.</li>
     <li>Event listeners for <codeph>enterFrame</codeph>, <codeph>frameConstructed</codeph>, <codeph>exitFrame</codeph>,
     <codeph>activate</codeph> and <codeph>deactivate</codeph> are removed.</li>
     <li>Timers are stopped.</li>
     <li>Camera and Microphone instances are detached</li>
     <li>Movie clips are stopped.</li></ul>
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Loader:content:get"><apiName>content</apiName><shortdesc>
     Contains the root display object of the SWF file or image (JPG, PNG, or GIF) 
     file that was loaded by using the load() or loadBytes() methods.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>The loaded SWF file or image file belongs to a security 
     sandbox to which you do not have access. For a loaded SWF file, you can avoid this situation by having
     the file call the <codeph>Security.allowDomain()</codeph> method or by having the loading file specify a
     <codeph>loaderContext</codeph> parameter with its <codeph>securityDomain</codeph> property set to 
     <codeph>SecurityDomain.currentDomain</codeph> when you call the <codeph>load()</codeph>  or 
     <codeph>loadBytes()</codeph> method.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Contains the root display object of the SWF file or image (JPG, PNG, or GIF) 
     file that was loaded by using the <codeph>load()</codeph> or <codeph>loadBytes()</codeph> methods.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:Loader:contentLoaderInfo:get"><apiName>contentLoaderInfo</apiName><shortdesc>
     Returns a LoaderInfo object corresponding to the object being loaded.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Returns a LoaderInfo object corresponding to the object being loaded. LoaderInfo objects 
     are shared between the Loader object and the loaded content object. The LoaderInfo object 
     supplies loading progress information and statistics about the loaded file. 
     
     <p>Events related to the load are dispatched by the LoaderInfo object referenced by the 
     <codeph>contentLoaderInfo</codeph> property of the Loader object. The <codeph>contentLoaderInfo</codeph> 
     property is set to a valid LoaderInfo object, even before the content is loaded, so that you can add 
     event listeners to the object prior to the load.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
     The NativeMenuItem class represents a single item in a menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     The NativeMenuItem class represents a single item in a menu.
     
     <p>A menu item can be a command, a submenu, or a separator line:</p> 
     
     <ul>
     <li>To create a command item, call the NativeMenuItem constructor, passing in a 
     string for the label and <codeph>false</codeph> for the <codeph>isSeparator</codeph>
     parameter.</li>
     
     <li>To create a submenu, create a command item for the parent menu and 
     assign the NativeMenu object of the submenu to the item's <codeph>submenu</codeph>
     property. You can also call the <codeph>addSubmenu()</codeph> method of the 
     parent NativeMenu object to create the item and set the <codeph>submenu</codeph> 
     property at the same time.</li>
     
     <li>To create a separator, call the NativeMenuItem constructor, passing in an empty 
     string for the label and <codeph>true</codeph> for the <codeph>isSeparator</codeph>
     parameter.</li>
     </ul>
     
     <p>Listen for <codeph>select</codeph> events on an item or a parent menu to detect when a
     menu command is selected. Neither submenus nor separators dispatch 
     select events. Listen for <codeph>displaying</codeph> events to determine when 
     a menu item is about to be displayed.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Dispatched by this NativeMenuItem object immediately before the 
     menu containing the item is displayed.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Dispatched by this NativeMenuItem object immediately before the 
     menu containing the item is displayed. 
     
	 <p>The <codeph>target</codeph> property of the event object references the
	 NativeMenu object containing this NativeMenuItem object; the 
	 <codeph>currentTarget</codeph> property references this NativeMenuItem.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Dispatched whenever a menu item is selected by the user.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Dispatched whenever a menu item is selected by the user. 
     
     <p>A <codeph>select</codeph> event <i>bubbles</i> from this item to its containing menu and on up 
     through the parent menu chain to the root menu object. The <codeph>target</codeph>
     property of the event object references this NativeMenuItem object;
     the <codeph>currentTarget</codeph> property references the dispatching 
     object (either this NativeMenuItem or an ancestral NativeMenu object).</p>
	 
	 <p><b>Note:</b> If the window containing the menu is in fullscreen mode,
	 the NativeMenuItem object does <i>not</i> dispatch a <codeph>select</codeph> event 
	 when the user enters a keyboard equivalent for a menu item. You can, however, listen
	 for a <codeph>keyDown</codeph> event dispatched by the <codeph>stage</codeph> property of the 
	 NativeWindow object.</p>
       
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeMenuItem:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
         Creates a new NativeMenuItem object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData></apiData><apiDesc>The display label for the item, or an empty string for separators.
         </apiDesc></apiParam><apiParam><apiItemName>isSeparator</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Set to <codeph>true</codeph> to create a separator; set to
         <codeph>false</codeph> otherwise.
         
         </apiDesc></apiParam></apiConstructorDef><apiDesc>
         Creates a new NativeMenuItem object.
         
         <p>To create a menu command, set the <codeph>label</codeph> parameter to a
	     string containing the display label and set <codeph>isSeparator</codeph> 
	     to <codeph>false</codeph>.</p>
	     
	     <p>To create a submenu command, create a command item and then assign the 
	     NativeMenu object for the submenu to the item's <codeph>submenu</codeph> 
	     property. Add the item to the parent menu.</p>
		  
	     <p>To create a separator, set the <codeph>label</codeph> parameter to an empty 
	     string and set <codeph>isSeparator</codeph> to <codeph>true</codeph>.</p>
         
         <p>Add and remove items from a menu using the NativeMenu <codeph>addItem()</codeph>
         and <codeph>removeItem()</codeph> methods.</p>
         
         </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeMenuItem:clone"><apiName>clone</apiName><shortdesc>
         Creates a copy of the NativeMenuItem object.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Creates a copy of the NativeMenuItem object.
         
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenuItem:toString"><apiName>toString</apiName><shortdesc>
         Returns a string containing all the properties of the NativeMenuItem object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>A string containing all the properties of the Event object.
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Returns a string containing all the properties of the NativeMenuItem object.
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenuItem:checked:get"><apiName>checked</apiName><shortdesc>
         Controls whether this menu item displays a checkmark.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Controls whether this menu item displays a checkmark.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:data:get"><apiName>data</apiName><shortdesc>
         An arbitrary data object associated with this menu item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
         An arbitrary data object associated with this menu item.
         
         <p>You can assign any object to this property. The assigned object is 
         not used by the menu system, but is available to event handling code 
         (through the target property of the event object).
         By default, the value of this property is <codeph>null</codeph>.</p>
           
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:enabled:get"><apiName>enabled</apiName><shortdesc>
         Controls whether this menu item is enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Controls whether this menu item is enabled.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:isSeparator:get"><apiName>isSeparator</apiName><shortdesc>
         Reports whether this item is a menu separator line.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Reports whether this item is a menu separator line.
         
         <p>Create a separator line by setting the <codeph>isSeparator</codeph>
         parameter in the NativeMenuItem constructor to <codeph>true</codeph>.</p> 
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalent:get"><apiName>keyEquivalent</apiName><shortdesc>
         The key equivalent for this menu item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         The key equivalent for this menu item.
		 
		 <p>Set the <codeph>keyEquivalent</codeph> with a lowercase letter to assign
		 a shortcut without a Shift-key modifier. Set with an uppercase letter
		 to assign a shortcut with the Shift-key modifier.</p>
		 
		 <p>By default, a key equivalent modifier (Ctrl on Windows or Linux and 
		 Command on Mac OS X) is included as part of the key equivalent. 
		 If you want the key equivalent to be a key with no modifier, 
		 set the <codeph>keyEquivalentModifiers</codeph> property to an 
		 empty array.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalentModifiers:get"><apiName>keyEquivalentModifiers</apiName><shortdesc>
         The array of key codes for the key equivalent modifiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         The array of key codes for the key equivalent modifiers.
         
         <p>Use the constants defined in the Keyboard class to specify the 
         modifier key codes. Valid modifer keys include:</p>
         <ul>
         <li><codeph>Keyboard.ALTERNATE</codeph></li>
         <li><codeph>Keyboard.COMMAND</codeph></li>
         <li><codeph>Keyboard.CONTROL</codeph></li>
         </ul>
		 
		 <p>If you do not assign any modifiers, then by default the <codeph>Keyboard.CONTROL</codeph> key is
		 assigned on Windows or Linux and the <codeph>Keyboard.COMMAND</codeph> key is assigned on Mac OS X. If you 
		 do not want the key equivalent to include these modifiers, set this property to an empty array.</p>
		 
		 <p>If you assign an uppercase letter to the <codeph>keyEquivalent</codeph> property, the Shift key is
		 used as a modifier automatically. Setting <codeph>keyEquivalentModifier</codeph> to an empty array
		 does not remove the Shift key as a modifier.</p> 
         
         </apiDesc></apiValueDetail><related-links><link href="flash.ui.xml#Keyboard"><linktext>flash.ui.Keyboard</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeMenuItem:label:get"><apiName>label</apiName><shortdesc>
         The display string of this menu item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         The display string of this menu item.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:menu:get"><apiName>menu</apiName><shortdesc>
         The menu that contains this item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         The menu that contains this item.  
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:mnemonicIndex:get"><apiName>mnemonicIndex</apiName><shortdesc>
         The position of the mnemonic character in the menu item label.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         The position of the mnemonic character in the menu item label.
         
         <p>The character at the specified position is the mnemonic
         character for the menu item. The index is zero-based, so the first 
         character has an index of 0.</p>
         
         <p>This property is ignored on operating systems that do not use
         menu mnemonics.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:name:get"><apiName>name</apiName><shortdesc>
         The name of this menu item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         The name of this menu item.  
         
         <p>The name value is not displayed and can be used as a 
         locale-independent identifier. A name is not assigned automatically.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:submenu:get"><apiName>submenu</apiName><shortdesc>
		 The submenu associated with this menu item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 The submenu associated with this menu item.  
		 
		 <p>Assigning a NativeMenu object to this property changes the
		 appearance and behavior of the menu item. A submenu item displays
		 the submenu icon and no longer dispatches select events.</p>
         
        <p><b>Note:</b> Adding a menu as a submenu of itself (in a circular reference) 
        can cause an application to hang.</p>
        
         </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenu"><apiName>NativeMenu</apiName><shortdesc>
     The NativeMenu class contains methods and properties for defining menus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     The NativeMenu class contains methods and properties for defining menus.
     
     <p>AIR supports the following types of menus:</p>
     <adobetable class="innertable">
     
     
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>Menu</entry><entry>Instance</entry><entry>Capability test</entry><entry>Supported on</entry><entry>Default provided?</entry></row></thead><tbody><row><entry>Application</entry><entry><codeph>NativeApplication.nativeApplication.menu</codeph></entry><entry><codeph>NativeApplication.supportsMenu</codeph></entry><entry>Mac OS X</entry><entry>Yes</entry></row><row><entry>Window</entry><entry><codeph>NativeWindow.menu</codeph></entry><entry><codeph>NativeWindow.supportsMenu</codeph></entry><entry>Windows, Linux</entry><entry>No</entry></row><row><entry>Dock icon</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsDockIcon</codeph></entry><entry>Mac OS X</entry><entry>Yes</entry></row><row><entry>System tray icon</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry><entry>Windows, Linux</entry><entry>No</entry></row><row><entry>Context</entry><entry><codeph>InteractiveObject.contextMenu</codeph></entry><entry>Always supported</entry><entry>All</entry><entry>No</entry></row><row><entry>Pop-up</entry><entry>Any NativeMenu instance</entry><entry>Always supported</entry><entry>All</entry><entry>No</entry></row></tbody></tgroup></adobetable>
     
     <p>A menu can contain items for commands, submenus, and separator lines.
     Menu items are added to a menu with the <codeph>addItem()</codeph>,
     <codeph>addItemAt()</codeph>, <codeph>addSubmenu()</codeph>, and 
     <codeph>addSubmenuAt()</codeph> methods. The display order of a menu's items 
     matches the order of the items in the menu's <codeph>items</codeph> array.</p>
      
     <p>Submenus are attached to their parent menu through the <codeph>submenu</codeph>
     property of the matching menu item in the parent menu. The root menu of 
     window and application menus must contain only submenu items; items
     without submenus may not be displayed and are contrary to user expectation for
     these types of menus.</p>
     
     <p>Menus dispatch <codeph>select</codeph> events when a command item in the menu or one of its
     submenus is selected. (Submenu and separator items are not selectable.) The
     <codeph>target</codeph> property of the event object references the 
     selected item.</p>
     
     <p>Menus dispatch <codeph>displaying</codeph> events just before the menu is displayed. You
     can use this event to update the contents of the menu based on the current 
     state of the application.</p> 
     
     <p platform="actionscript"><b>Note:</b> You can use either a NativeMenu or a ContextMenu 
     object to set a context menu. Flash Player supports only the 
	 ContextMenu class, not the NativeMenu class.
	 </p>
     
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>flash.display.InteractiveObject.contextMenu</linktext></link><link href="flash.display.xml#NativeMenuItem"><linktext>flash.display.NativeMenuItem</linktext></link><link href="flash.display.xml#NativeWindow/menu"><linktext>flash.display.NativeWindow.menu</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/menu"><linktext>flash.desktop.NativeApplication.menu</linktext></link><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Dispatched by this NativeMenu object immediately before the 
     menu is to be displayed.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Dispatched by this NativeMenu object immediately before the 
     menu is to be displayed. 
     
     <p>Listen to this event to update the menu before it is displayed. 
     Displaying events are also dispatched by the items in a menu.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Dispatched by this NativeMenu object when one of its menu items or an item 
     in one of its descendant submenus is selected.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Dispatched by this NativeMenu object when one of its menu items or an item 
     in one of its descendant submenus is selected. 
     
     <p>A select event <i>bubbles</i> from a menu item to its containing menu and on up 
     through the parent menu chain to the root menu object. The <codeph>target</codeph>
     property of the event object references the selected NativeMenuItem object;
     the <codeph>currentTarget</codeph> property references this NativeMenu object.</p>  
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:NativeMenu:addItem"><apiName>addItem</apiName><shortdesc>
         Adds a menu item at the bottom of the menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If <codeph>item</codeph> is <codeph>null</codeph>.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If <codeph>item</codeph> is a member of another menu.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>The NativeMenuItem object to add at the bottom of the menu.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Adds a menu item at the bottom of the menu.
         
         <p platform="actionscript">When creating a context menu, you can add either NativeMenuItem or
         ContextMenuItem objects. However, it is advisable to use only one type of object in a context
         menu so that all items in the menu have the same properties.</p>
         
         <p><b>Note:</b> Adding an item to a menu can cause an application to hang if the item's
         submenu is set to the menu itself (causing a circular reference).</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addItemAt"><apiName>addItemAt</apiName><shortdesc>
         Inserts a menu item at the specified position.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If <codeph>item</codeph> is <codeph>null</codeph>.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If <codeph>item</codeph> is a member of another menu.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the index is outside the bounds of the menu's 
         <codeph>items</codeph> array.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>The NativeMenuItem object to insert.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The (zero-based) position in menu 
         at which to insert the menu item.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Inserts a menu item at the specified position.
         
         <p><b>Note:</b> Adding an item to a menu can cause an application to hang if the item's
         submenu is set to the menu itself (causing a circular reference).</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenu"><apiName>addSubmenu</apiName><shortdesc>
        Adds a submenu to the menu by inserting a new menu item.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The NativeMenuItem object created for the submenu. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>The NativeMenu object that defines the submenu to be added.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The display label for the menu item to be added.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Adds a submenu to the menu by inserting a new menu item.
        
        <p>Calling the <codeph>addSubMenu()</codeph> method is equivalent to creating a new menu 
        item, adding it to the menu, and assigning a NativeMenu object to the 
        item's <codeph>submenu</codeph> property.</p>
        
        <p><b>Note:</b> Adding a menu as a submenu of itself (in a circular reference) 
        can cause an application to hang.</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenuAt"><apiName>addSubmenuAt</apiName><shortdesc>
        Adds a submenu to the menu by inserting a new menu item at the 
        specified position.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The NativeMenuItem object created for the submenu. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>The NativeMenu object that defines the submenu to be added.
        </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The position in the <codeph>items</codeph> array of this
        menu at which to insert the menu item to be added.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The display label for the menu item to be added.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Adds a submenu to the menu by inserting a new menu item at the 
        specified position.
        
        <p>Calling the <codeph>addSubMenuAt()</codeph> method is equivalent to creating a new menu 
        item, inserting it at the desired position in the menu, and assigning 
        a NativeMenu object to the item's <codeph>submenu</codeph> property.</p>
        
        <p><b>Note:</b> Adding a menu as a submenu of itself (in a circular reference) 
        can cause an application to hang.</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:clone"><apiName>clone</apiName><shortdesc>
        
        Creates a copy of the menu and all items.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
        
        Creates a copy of the menu and all items.
        
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:containsItem"><apiName>containsItem</apiName><shortdesc>
         Reports whether this menu contains the specified menu item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if <codeph>item</codeph> is in this menu.
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>The NativeMenuItem object to look up.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Reports whether this menu contains the specified menu item.
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:display"><apiName>display</apiName><shortdesc>
        Pops up this menu at the specified location.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stage</apiItemName><apiOperationClassifier>flash.display:Stage</apiOperationClassifier><apiDesc>The Stage object on which to display this menu.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The number of horizontal pixels, relative to the origin 
        of stage, at which to display this menu.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The number of vertical pixels, relative to the origin 
        of stage, at which to display this menu.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
        Pops up this menu at the specified location.
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemAt"><apiName>getItemAt</apiName><shortdesc>
         Gets the menu item at the specified index.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If <codeph>index</codeph> is outside the bounds of the menu's 
         <codeph>items</codeph> array.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>The NativeMenuItem object at the specified position in the menu.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The (zero-based) position of the item to return.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Gets the menu item at the specified index.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemByName"><apiName>getItemByName</apiName><shortdesc>
         Gets the menu item with the specified name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The NativeMenuItem object with the specified name or 
         <codeph>null</codeph>, if no such item exists in the menu.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The string to look up.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Gets the menu item with the specified name.
         
         <p><b>Note:</b> The <codeph>name</codeph> property of menu items is not assigned by
         default.</p>
            
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemIndex"><apiName>getItemIndex</apiName><shortdesc>
         Gets the position of the specified item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The (zero-based) position of the specified item in this menu
		 or <codeph>null</codeph>, if the item is not in this menu.
         
         </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>The NativeMenuItem object to look up.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Gets the position of the specified item. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeAllItems"><apiName>removeAllItems</apiName><shortdesc>
         Removes all items from the menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
         Removes all items from the menu.  
         
         
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItem"><apiName>removeItem</apiName><shortdesc>
         Removes the specified menu item.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>item</codeph> is not in this menu
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>The NativeMenuItem object to remove from this menu.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Removes the specified menu item. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItemAt"><apiName>removeItemAt</apiName><shortdesc>
         Removes and returns the menu item at the specified index.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If <codeph>index</codeph> is outside the bounds of 
         this menu's <codeph>items</codeph> array.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>The NativeMenuItem object removed.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The (zero-based) position of the item to remove.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Removes and returns the menu item at the specified index.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:setItemIndex"><apiName>setItemIndex</apiName><shortdesc>
         Moves a menu item to the specified position.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If <codeph>index</codeph> is outside the bounds of the 
         menu's <codeph>items</codeph> array.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>The NativeMenuItem object to move.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The (zero-based) position in the menu to which to move the
         <codeph>item</codeph>.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Moves a menu item to the specified position. If the item is not already in the menu,
         calling this method adds the item to the menu.
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenu:items:get"><apiName>items</apiName><shortdesc>
         The array of NativeMenuItem objects in this menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         The array of NativeMenuItem objects in this menu.
         
         <p>The array is sorted in display order.</p>
         
         <p><i>Note:</i> This property is read-only in AIR 1.0. It became read/write in AIR 1.1.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:numItems:get"><apiName>numItems</apiName><shortdesc>
         The number of NativeMenuItem objects in this menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         The number of NativeMenuItem objects in this menu.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:parent:get"><apiName>parent</apiName><shortdesc>
         The parent menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         The parent menu.  
         
         <p>The <codeph>parent</codeph> of the root (top-level) menu object is 
         <codeph>null</codeph>.</p>
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
The DisplayObjectContainer class is the base class for all objects that can serve as display object containers on 
the display list.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>The abstract base class for all display objects that can contain child objects.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
The DisplayObjectContainer class is the base class for all objects that can serve as display object containers on 
the display list. The display list manages all objects displayed in Flash Player or Adobe AIR. 
 Use the DisplayObjectContainer class to arrange the display objects in the display list.
 Each DisplayObjectContainer object has its own child list for organizing the z-order of the objects.
 The z-order is the front-to-back order that determines which object is drawn in front, which is behind,
 and so on. 
 
 <p>DisplayObject is an abstract base class; therefore, you cannot call DisplayObject directly. Invoking
 <codeph>new DisplayObject()</codeph> throws an <codeph>ArgumentError</codeph> exception.</p>
 
 The DisplayObjectContainer class is an abstract base class for all objects that can contain child objects. 
 It cannot be instantiated directly; calling the <codeph>new DisplayObjectContainer()</codeph> constructor 
 throws an <codeph>ArgumentError</codeph> exception.
 
 <p>For more information, see the "Display Programming" chapter of the <i>Programming 
 ActionScript 3.0</i> book.</p>
 
 </apiDesc><example conref="examples\DisplayObjectContainerExample.as"> The following example uses the class <codeph>DisplayObjectContainerExample</codeph> to
 create five orange squares in succession. This task is accomplished by performing the following steps:
 
 <ol>
     <li>The constructor calls the <codeph>configureAssets()</codeph> method.</li>
 
  <li>The <codeph>configureAssets()</codeph> method creates <codeph>child</codeph> and 
      <codeph>lastChild</codeph> Sprite objects.</li>
 
    <li>A <codeph>for</codeph> loop creates the five orange squares and positions 
         them one after another.</li>
 
     <li>Each time a CustomSprite object is created, its constructor calls the <codeph>draw()</codeph> 
      method of the <codeph>CustomSprite</codeph> object, which creates a 50-by-50-pixel square
      by calling the <codeph>beginFill()</codeph>, <codeph>drawRect()</codeph>, and <codeph>endFill()</codeph> 
      methods of the Graphics class.  The <codeph>addChild()</codeph> method adds each square to the
      display list.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class DisplayObjectContainerExample extends Sprite {
        private var gutter:uint     = 5;
        private var childCount:uint = 5;

        public function DisplayObjectContainerExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var child:Sprite = new CustomSprite();
            var lastChild:Sprite = child;
            for (var i:uint = 1; i &lt;= childCount; i++) {
                child = new CustomSprite();
                child.x = lastChild.x + lastChild.width + gutter;
                addChild(child);
                lastChild = child;
            }
        }
    }
}

import flash.display.Sprite;

class CustomSprite extends Sprite {
    private var size:uint = 50;
    private var bgColor:uint = 0xFFCC00;

    public function CustomSprite() {
        draw(size, size);
    }

    private function draw(w:uint, h:uint):void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:DisplayObjectContainer:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
	Calling the new DisplayObjectContainer() constructor throws an 
	ArgumentError exception.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Calling the <codeph>new DisplayObjectContainer()</codeph> constructor throws an 
	<codeph>ArgumentError</codeph> exception. You <i>can</i>, however, call constructors for 
	the following subclasses of DisplayObjectContainer:
	
	<ul>
	
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
 	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:DisplayObjectContainer:addChild"><apiName>addChild</apiName><shortdesc>
     Adds a child DisplayObject instance to this DisplayObjectContainer instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Throws if the child is the same as the parent.  Also throws if
     the caller is a child (or grandchild etc.) of the child being added.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>The DisplayObject instance that you pass in the 
	 <codeph>child</codeph> parameter.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The DisplayObject instance to add as a child of this DisplayObjectContainer instance.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Adds a child object to this DisplayObjectContainer instance.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Adds a child DisplayObject instance to this DisplayObjectContainer instance. The child is added
     to the front (top) of all other children in this DisplayObjectContainer instance. (To add a child to a 
     specific index position, use the <codeph>addChildAt()</codeph> method.)
     
	 <p>If you add a child object that already has a different display object container as
	 a parent, the object is removed from the child list of the other display object container. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> The following example sets up two Sprite objects named <codeph>container1</codeph> and
 <codeph>container2</codeph>. A Sprite is a type of display object container. The example calls the 
 <codeph>addChild()</codeph> method to set up the display hierarchy: <codeph>container1</codeph> is a child of
 <codeph>container2</codeph>, and two other display objects, <codeph>circle1</codeph> and <codeph>circle2</codeph>,
 are children of <codeph>container1</codeph>. The calls to the <codeph>trace()</codeph> method show the number
 of children of each object. Note that grandchildren are not included in the <codeph>numChildren</codeph> count:
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChild_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when a display object is added to the display list.
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when a display object is added to the display list.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 Adds a child DisplayObject instance to this DisplayObjectContainer 
	 instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Throws if the index position does not exist in the child list.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Throws if the child is the same as the parent.  Also throws if
     the caller is a child (or grandchild etc.) of the child being added.
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>The DisplayObject instance that you pass in the 
	 <codeph>child</codeph> parameter.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The DisplayObject instance to add as a child of this 
	 DisplayObjectContainer instance.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The index position to which the child is added. If you specify a 
	 currently occupied index position, the child object that exists at that position and all
	 higher positions are moved up one position in the child list. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Adds a child object to this DisplayObjectContainer instance.
     
  	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Adds a child DisplayObject instance to this DisplayObjectContainer 
	 instance.  The child is added
	 at the index position specified. An index of 0 represents the back (bottom) 
	 of the display list for this DisplayObjectContainer object.
	 
	 <p>For example, the following example shows three display objects, labeled a, b, and c, at
	 index positions 0, 2, and 1, respectively:</p>
	 
	 <p><adobeimage alt="b over c over a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>If you add a child object that already has a different display object container as
	 a parent, the object is removed from the child list of the other display object container. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.addChildAt.1.as"> The following example creates a <codeph>container</codeph> display object container and
 adds a display objects <codeph>circle1</codeph> to its display list. Then, by calling 
 <codeph>container.addChildAt(circle2, 0)</codeph>, it adds the <codeph>circle2</codeph> object to index position
 zero (the back), and moves the <codeph>circle1</codeph> object to index position 1:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
var circle2:Sprite = new Sprite();

container.addChild(circle1);
container.addChildAt(circle2, 0);

trace(container.getChildAt(0) == circle2); // true
trace(container.getChildAt(1) == circle1); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>addChild()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChildAt_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when a display object is added to the display list.
     </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when a display object is added to the display list.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:areInaccessibleObjectsUnderPoint"><apiName>areInaccessibleObjectsUnderPoint</apiName><shortdesc>
	 Indicates whether the security restrictions 
	 would cause any display objects to be omitted from the list returned by calling
	 the DisplayObjectContainer.getObjectsUnderPoint() method
	 with the specified point point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if the point contains child display objects with security restrictions.
	 
 	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point under which to look.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indicates whether the security restrictions 
	 would cause any display objects to be omitted from the list returned by calling
	 the <codeph>DisplayObjectContainer.getObjectsUnderPoint()</codeph> method
	 with the specified <codeph>point</codeph> point. By default, content from one domain cannot 
	 access objects from another domain unless they are permitted to do so with a call to the 
	 <codeph>Security.allowDomain()</codeph> method. 
	 
	 <p>For more information, see the following: </p>
	 
     <ul>
     
     <li class="flexonly">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref> in the
     <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     
     <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
     </ul>     
     
	 <p>The <codeph>point</codeph> parameter is in the coordinate space of the Stage, 
	 which may differ from the coordinate space of the display object container (unless the
	 display object container is the Stage). You can use the <codeph>globalToLocal()</codeph> and 
	 the <codeph>localToGlobal()</codeph> methods to convert points between these coordinate
	 spaces.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.areInaccessibleObjectsUnderPoint.as"> The following code creates a display object container named <codeph>container</codeph>.
 The next block of code uses a Loader object to load a JPEG file named "test.jpg" from a remote file server.
 Note that the <codeph>checkPolicyFile</codeph> property of the LoaderContext object used as a parameter in the 
 <codeph>load()</codeph> method is set to <codeph>false</codeph>. Once the file is loaded, the code calls 
 the <codeph>loaded()</codeph> method, which in turn calls <codeph>container.areInaccessibleObjectsUnderPoint()</codeph>, 
 which returns a value of <codeph>true</codeph> because the loaded content is assumed to be from an 
 inaccessible domain:
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.system.LoaderContext;
import flash.net.URLRequest;
import flash.events.Event;
import flash.geom.Point;

var container:Sprite = new Sprite();

var urlReq:URLRequest = new URLRequest("http://localhost/RemoteFile.swf");
var ldr:Loader = new Loader();
var context:LoaderContext = new LoaderContext();
context.checkPolicyFile = false;
ldr.load(urlReq, context);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);

function loaded(event:Event):void {
    var pt:Point = new Point(1, 1);
    trace(container.areInaccessibleObjectsUnderPoint(pt)); // true
}

function urlNotFound(event:Event):void {
    trace("The URL was not found."); 
}
</codeblock> This example assumes that the SWF file produced by this code is loaded from a different domain 
 than that of the JPEG file, and that the loaded JPEG file occupies the point (1, 1). 
</example></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getObjectsUnderPoint()"><linktext>getObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:contains"><apiName>contains</apiName><shortdesc>
	 Determines whether the specified display object is a child of the DisplayObjectContainer instance or
	 the instance itself.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if the <codeph>child</codeph> object is a child of the DisplayObjectContainer
	 or the container itself; otherwise <codeph>false</codeph>.
	 
	  
	  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The child object to test.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Determines whether the specified display object is a child of the DisplayObjectContainer instance or
	 the instance itself. 
	 The search includes the entire display list including this DisplayObjectContainer instance. Grandchildren, 
	 great-grandchildren, and so on each return <codeph>true</codeph>.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.contains.1.as"> The following example sets up a number of Sprite objects and adds some to the child list 
 of others. (A Sprite object is a type of display object container.) The relationship between various objects is 
 shown by calling the <codeph>contains()</codeph> method:
<codeblock>
import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();
var sprite4:Sprite = new Sprite();

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite1.contains(sprite1)); // true
trace(sprite1.contains(sprite2)); // true
trace(sprite1.contains(sprite3)); // true
trace(sprite1.contains(sprite4)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildAt"><apiName>getChildAt</apiName><shortdesc>
     Returns the child display object instance that exists at the specified index.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Throws if the index does not exist in the child list.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>This child display object belongs to a sandbox
     to which you do not have access. You can avoid this situation by having
     the child movie call <codeph>Security.allowDomain()</codeph>.
     
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>The child display object at the specified index position.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The index position of the child object.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Returns the child display object instance that exists at the specified index.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildAt.1.as"> The following example creates a display object container named <codeph>container</codeph>
 and then adds a three display objects to the child list of the <codeph>container</codeph> object. The calls to the
 <codeph>getChildAt()</codeph> method then reveal the positions of the child objects:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();

container.addChild(sprite1);
container.addChild(sprite2);
container.addChildAt(sprite3, 0);

trace(container.getChildAt(0) == sprite3); // true
trace(container.getChildAt(1) == sprite1); // true
trace(container.getChildAt(2) == sprite2); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildByName()"><linktext>getChildByName()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildByName"><apiName>getChildByName</apiName><shortdesc>
     Returns the child display object that exists with the specified name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>This child display object belongs to a sandbox
     to which you do not have access. You can avoid this situation by having
     the child movie call the <codeph>Security.allowDomain()</codeph> method.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>The child display object with the specified name.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The name of the child to return.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Returns the child display object that exists with the specified name.
     If more that one child display object has the specified name, 
     the method returns the first object in the child list.
     
	 <p>The <codeph>getChildAt()</codeph> method is faster than the 
	 <codeph>getChildByName()</codeph> method. The <codeph>getChildAt()</codeph> method accesses 
	 a child from a cached array, whereas the <codeph>getChildByName()</codeph> method
	 has to traverse a linked list to access a child.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> The following example creates a display object container named 
 <codeph>container</codeph> and then adds two child display objects to the container. 
 Then, the code calls the <codeph>getChildByName()</codeph> and <codeph>getChildIndex()</codeph> 
 methods to return the index position of the child of the <codeph>container</codeph> object that 
 has the <codeph>name "sprite1"</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildAt()"><linktext>getChildAt()</linktext></link><link href="flash.display.xml#DisplayObject/name"><linktext>flash.display.DisplayObject.name</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildIndex"><apiName>getChildIndex</apiName><shortdesc>
     Returns the index position of a child DisplayObject instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Throws if the child parameter is not a child of this object.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>The index position of the child display object to identify.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The DisplayObject instance to identify.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Returns the index number of a child DisplayObject instance.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Returns the index position of a <codeph>child</codeph> DisplayObject instance.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> The following example creates a display object container named 
 <codeph>container</codeph> and then adds two child display objects to the container. 
 Then, the code calls the <codeph>getChildByName()</codeph> and <codeph>getChildIndex()</codeph> 
 methods to return the index position of the child of the <codeph>container</codeph> object that 
 has the <codeph>name "sprite1"</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getObjectsUnderPoint"><apiName>getObjectsUnderPoint</apiName><shortdesc>
     Returns an array of objects that lie under the specified point and are children 
     (or grandchildren, and so on) of this DisplayObjectContainer instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An array of objects that lie under the specified point and are children 
     (or grandchildren, and so on) of this DisplayObjectContainer instance.
     
 	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point under which to look.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Returns an array of objects that lie under the specified point and are children 
     (or grandchildren, and so on) of this DisplayObjectContainer instance. Any child objects that
     are inaccessible for security reasons are omitted from the returned array. To determine whether 
     this security restriction affects the returned array, call the 
     <codeph>areInaccessibleObjectsUnderPoint()</codeph> method.
	 
	 <p>The <codeph>point</codeph> parameter is in the coordinate space of the Stage, 
	 which may differ from the coordinate space of the display object container (unless the
	 display object container is the Stage). You can use the <codeph>globalToLocal()</codeph> and 
	 the <codeph>localToGlobal()</codeph> methods to convert points between these coordinate
	 spaces.</p>
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getObjectsUnderPoint.1.as"> The following example creates a display object container named <codeph>container</codeph>
 and then adds two overlapping child display objects to the container. Then the code calls the 
 <codeph>getObjectsUnderPoint()</codeph> twice  first using a point that touches only one object,
 then using a point where the objects overlap  and the <codeph>length</codeph> of the return
 Array shows the number of objects at each point in the container:
<codeblock>
import flash.display.Sprite;
import flash.geom.Point;

var container:Sprite = new Sprite();

var square1:Sprite = new Sprite();
square1.graphics.beginFill(0xFFCC00);
square1.graphics.drawRect(0, 0, 40, 40);

var square2:Sprite = new Sprite();
square2.graphics.beginFill(0x00CCFF);
square2.graphics.drawRect(20, 0, 30, 40);

container.addChild(square1);
container.addChild(square2);

var pt:Point = new Point(10, 20);
var objects:Array = container.getObjectsUnderPoint(pt); 
trace(objects.length); // 1

pt = new Point(35, 20);
objects = container.getObjectsUnderPoint(pt);
trace(objects.length);  // 2
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/areInaccessibleObjectsUnderPoint()"><linktext>areInaccessibleObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChild"><apiName>removeChild</apiName><shortdesc>
	 Removes the specified child DisplayObject instance from the child list of the DisplayObjectContainer instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Throws if the child parameter is not a child of this object.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>The DisplayObject instance that you pass in the 
	 <codeph>child</codeph> parameter.
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The DisplayObject instance to remove.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Removes a child display object from the DisplayObjectContainer 
	 instance.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Removes the specified <codeph>child</codeph> DisplayObject instance from the child list of the DisplayObjectContainer instance.  
	 The <codeph>parent</codeph> property of the removed child is set to <codeph>null</codeph>
	 , and the object is garbage collected if no other
	 references to the child exist. The index positions of any display objects above the child in the 
	 DisplayObjectContainer are decreased by 1.
	 
	 <p>The garbage collector reallocates unused memory space. When a variable 
	 or object is no longer actively referenced or stored somewhere, the garbage collector sweeps 
	 through and wipes out the memory space it used to occupy if no other references to it exist.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChild.1.as"> The following example creates a display object container named 
 <codeph>container</codeph> and then adds two child display objects to the container. 
 An event listener is added to the <codeph>container</codeph> object, so that when the 
 user clicks a child object of the container, the <codeph>removeChild()</codeph> method
 removes the child clicked from the child list of the container:
<codeblock>
 
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);

container.addChild(circle1);
container.addChild(circle2);

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    container.removeChild(DisplayObject(event.target)); 
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 Removes a child DisplayObject from the specified index position in the child list of 
	 the DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>This child display object belongs to a sandbox
     to which the calling object does not have access. You can avoid this situation by having
     the child movie call the <codeph>Security.allowDomain()</codeph> method.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Throws if the index does not exist in the child list.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>The DisplayObject instance that was removed.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The child index of the DisplayObject to remove.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Removes a child display object, at the specified <codeph>index</codeph> position, from the 
	 DisplayObjectContainer instance.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Removes a child DisplayObject from the specified <codeph>index</codeph> position in the child list of 
	 the DisplayObjectContainer. The <codeph>parent</codeph> property of the removed child is set to 
	 <codeph>null</codeph>, and the object is garbage collected if no other references to the child exist. The index  
	 positions of any display objects above the child in the DisplayObjectContainer are decreased by 1.
	 
	 <p>The garbage collector reallocates unused memory space. When a variable or
	 object is no longer actively referenced or stored somewhere, the garbage collector sweeps 
	 through and wipes out the memory space it used to occupy if no other references to it exist.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChildAt.1.as"> The following example creates a display object container named 
 <codeph>container</codeph> and then adds two child display objects to the container. 
 The code then shows that when you call the <codeph>removeChildAt()</codeph> method
 to remove the child at the lowest index position (0), any other child object in the list
 moves down one position:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.numChildren) // 2
container.removeChildAt(0); 
trace(container.numChildren) // 1
trace(container.getChildAt(0).name); // sprite2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	Changes the  position of an existing child in the display object container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Throws if the index does not exist in the child list.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Throws if the child parameter is not a child of this object.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The child DisplayObject instance for which you want to change
     the index number.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The resulting index number for the <codeph>child</codeph> display object.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Changes the index number of an existing child.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Changes the  position of an existing child in the display object container.
	This affects the layering of child objects. For example, the following example shows three 
	display objects, labeled a, b, and c, at index positions 0, 1, and 2, respectively:
	
	<p><adobeimage alt="c over b over a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>When you use the <codeph>setChildIndex()</codeph> method and specify an index position
	that is already occupied, the only positions that change are those in between the display object's former and new position. 
	All others will stay the same. 
	If a child is moved to an index LOWER than its current index, all children in between will INCREASE by 1 for their index reference.
	If a child is moved to an index HIGHER than its current index, all children in between will DECREASE by 1 for their index reference.
	For example, if the display object container
	in the previous example is named <codeph>container</codeph>, you can swap the position 
	of the display objects labeled a and b by calling the following code:</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>This code results in the following arrangement of objects:</p>
	
    <p><adobeimage alt="c over a over b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc><example conref="examples\DisplayObjectContainer.setChildIndex.1.as"> The following example creates a display object container named 
 <codeph>container</codeph> and then adds three slightly overlapping child display 
 objects to the container. When the user clicks any of these objects, the 
 <codeph>clicked()</codeph> method calls the <codeph>setChildIndex()</codeph>
 method to move the clicked object to the top-most position in the child list of 
 the <codeph>container</codeph> object:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.addEventListener(MouseEvent.CLICK, clicked);
 
var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(100, 40, 40);
circle2.addEventListener(MouseEvent.CLICK, clicked);
 
var circle3:Sprite = new Sprite();
circle3.graphics.beginFill(0x0000FF);
circle3.graphics.drawCircle(70, 80, 40);
circle3.addEventListener(MouseEvent.CLICK, clicked);
 
container.addChild(circle1);
container.addChild(circle2);
container.addChild(circle3);
addChild(container);
 
function clicked(event:MouseEvent):void {
    var circle:Sprite = Sprite(event.target);
    var topPosition:uint = container.numChildren - 1;
    container.setChildIndex(circle, topPosition);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getChildIndex()"><linktext>getChildIndex()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildren"><apiName>swapChildren</apiName><shortdesc>
	 Swaps the z-order (front-to-back order) of the two specified child objects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Throws if either child parameter is not a child of this object.
	 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The first child object.
	 
     </apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The second child object.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Swaps the z-order (front-to-back order) of the two specified child objects.  All other child 
	 objects in the display object container remain in the same index positions.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildren.1.as"> The following example creates a display object container named 
 <codeph>container</codeph>, then adds two child display objects to the container, 
 and then shows the effect of a call to the <codeph>swapChildren()</codeph> method:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2

container.swapChildren(sprite1, sprite2);

trace(container.getChildAt(0).name); // sprite2
trace(container.getChildAt(1).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 Swaps the z-order (front-to-back order) of the child objects at the two specified index positions in the 
	 child list.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If either index does not exist in the child list.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The index position of the first child object.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The index position of the second child object.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Swaps the z-order (front-to-back order) of the child objects at the two specified index positions in the 
	 child list. All other child objects in the display object container remain in the same index positions.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildrenAt.1.as"> The following example creates a display object container named 
 <codeph>container</codeph>, then adds three child display objects to the container, 
 and then shows how a call to the <codeph>swapChildrenAt()</codeph> method rearranges
 the child list of the display object container:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

container.addChild(sprite1);
container.addChild(sprite2);
container.addChild(sprite3);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite3

container.swapChildrenAt(0, 2);

trace(container.getChildAt(0).name); // sprite3
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:DisplayObjectContainer:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 Determines whether or not the children of the object are mouse enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Determines whether or not the children of the object are mouse enabled. 
	 If an object is mouse enabled, a user can interact with it by using a mouse. The default is <codeph>true</codeph>.
	 
	 <p>This property is useful when you create a button with an instance of the Sprite class
	 (instead of using the SimpleButton class). When you use a Sprite instance to create a button,
	 you can choose to decorate the button by using the <codeph>addChild()</codeph> method to add additional
	 Sprite instances. This process can cause unexpected behavior with mouse events because
	 the Sprite instances you add as children can become the target object of a mouse event
	 when you expect the parent instance to be the target object. To ensure that the parent
	 instance serves as the target objects for mouse events, you can set the 
	 <codeph>mouseChildren</codeph> property of the parent instance to <codeph>false</codeph>.</p>
	 <p> No event is dispatched by setting this property. You must use the
	 <codeph>addEventListener()</codeph> method to create interactive functionality.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.mouseChildren.1.as"> The following example sets up a Sprite object (a type of display object container) named 
 <codeph>container</codeph> and shows that when you set its <codeph>mouseChildren</codeph> property to
 <codeph>false</codeph>, the target of a <codeph>mouseClick</codeph> event is the <codeph>container</codeph>
 object, not any one of its child objects:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
container.name = "container";
addChild(container);

var circle:Sprite = new Sprite();
circle.name = "circle";
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);

container.addChild(circle);

container.mouseChildren = false;

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace(event.target.name); // container
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>flash.display.Sprite.buttonMode</linktext></link><link href="flash.events.xml#EventDispatcher/addEventListener()"><linktext>flash.events.EventDispatcher.addEventListener()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObjectContainer:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 Returns the number of children of this object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Returns the number of children of this object.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> The following example sets up two Sprite objects named <codeph>container1</codeph> and
 <codeph>container2</codeph>. A Sprite is a type of display object container. The example calls the 
 <codeph>addChild()</codeph> method to set up the display hierarchy: <codeph>container1</codeph> is a child of
 <codeph>container2</codeph>, and two other display objects, <codeph>circle1</codeph> and <codeph>circle2</codeph>,
 are children of <codeph>container1</codeph>. The calls to the <codeph>trace()</codeph> method show the number
 of children of each object. Note that grandchildren are not included in the <codeph>numChildren</codeph> count:
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 Determines whether the children of the object are tab enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Calling this property of the Stage object 
	 throws an exception. The Stage object does not implement this property.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Determines whether the children of the object are tab enabled. Enables or disables tabbing for the 
     children of the object. The default is <codeph>true</codeph>.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.tabChildren.1.as"> The following example creates a <codeph>container1</codeph> display object container and
 adds two display objects, <codeph>circle1</codeph> and <codeph>circle2</codeph>,
 to its child list. The example sets tabChildren to <codeph>false</codeph> for the children so it can
 manage its own tab order using <codeph>tabIndex</codeph>:
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();
container.tabChildren = false;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.tabIndex = 1;

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);
circle2.tabIndex = 0;

container.addChild(circle1);
container.addChild(circle2);
</codeblock> To see the results of this example, compile and run the file. When you click one of the circles, 
 you can press the TAB key to switch the display object that has focus (indicated by a yellow highlight rectangle).
</example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
     Returns a TextSnapshot object for this DisplayObjectContainer instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier></apiValueDef><apiDesc>
     Returns a TextSnapshot object for this DisplayObjectContainer instance.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.textSnapshot.1.as"> The following example works only in the Flash authoring environment. Flex does not include any 
 ways of adding static text to a file. To prepare the Flash file for this example, add one or more static text fields
 in the first frame of a movie. Then insert the following script into the first frame and run the file. The output
 will be the static text that you added:
<codeblock>
trace(this.textSnapshot.getText(0, this.textSnapshot.charCount));
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot"><linktext>flash.text.TextSnapshot</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
 Defines a gradient fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines a gradient fill. 
 
 <p>
 Use a GraphicsGradientFill object with the <codeph>Graphics.drawGraphicsData()</codeph> method.
 Drawing a GraphicsGradientFill object is the equivalent of calling the <codeph>Graphics.beginGradientFill()</codeph> method.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsGradientFill:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
     Creates a new GraphicsGradientFill object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>linear</apiData><apiDesc>A value from the GradientType class that 
     specifies which gradient type to use: <codeph>GradientType.LINEAR</codeph> or 
     <codeph>GradientType.RADIAL</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>An array of RGB hexadecimal color values used in the gradient; for example,
     red is 0xFF0000, blue is 0x0000FF, and so on. You can specify up to 15 colors. 
     For each color, specify a corresponding value in the alphas and ratios parameters.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>An array of alpha values for the corresponding colors in the colors array; 
     valid values are 0 to 1. If the value is less than 0, 0 is used. If the value is 
     greater than 1, 1 is used.
     
     </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>An array of color distribution ratios; valid values are 0-255. This value 
     defines the percentage of the width where the color is sampled at 100%. The value 0 represents 
     the left position in the gradient box, and 255 represents the right position in the 
     gradient box. 
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>A transformation matrix as defined by the 
     flash.geom.Matrix class. The flash.geom.Matrix class includes a 
     <codeph>createGradientBox()</codeph> method, which lets you conveniently set up 
     the matrix for use with the <codeph>beginGradientFill()</codeph> method.
     
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>pad</apiData><apiDesc>A value from the SpreadMethod class that 
     specifies which spread method to use, either: <codeph>SpreadMethod.PAD</codeph>,
     <codeph>SpreadMethod.REFLECT</codeph>, or <codeph>SpreadMethod.REPEAT</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiType value=""/><apiData>rgb</apiData><apiDesc>A value from the InterpolationMethod class that 
     specifies which value to use: <codeph>InterpolationMethod.LINEAR_RGB</codeph> or 
     <codeph>InterpolationMethod.RGB</codeph>
     
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiType value=""/><apiData>0.0</apiData><apiDesc>A number that controls the 
     location of the focal point of the gradient. A value of 0 sets the focal point in the center. A value of 1 
     sets the focal point at one border of the gradient circle. A value of -1 sets the focal point 
     at the other border of the gradient circle. A value less than -1 or greater than
     1 is rounded to -1 or 1, respectively.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new GraphicsGradientFill object.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsGradientFill:alphas"><apiName>alphas</apiName><shortdesc>
     An array of alpha values for the corresponding colors in the colors array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of alpha values for the corresponding colors in the colors array. 
     Valid values are between 0 and 1. If the value is less than 0, 0 is used. If the value is 
     greater than 1, 1 is used.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:colors"><apiName>colors</apiName><shortdesc>
     An array of RGB hexadecimal color values to use in the gradient.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of RGB hexadecimal color values to use in the gradient. For example,
     red is 0xFF0000, blue is 0x0000FF, and so on. You can specify up to 15 colors. 
     For each color, specify a corresponding value in the alphas and ratios properties.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:focalPointRatio"><apiName>focalPointRatio</apiName><shortdesc>
     A number that controls the 
     location of the focal point of the gradient.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     A number that controls the 
     location of the focal point of the gradient. A value of 0 sets the focal point in the center. A value of 1 
     means that the focal point is at one border of the gradient circle.A value of -1 sets the focal point 
     at the other border of the gradient circle. A value of less than -1 or greater than
     1 is rounded to -1 or 1, respectively. For example, the following 
     shows a <codeph>focalPointRatio</codeph> set to 0.75:
     
     <p><adobeimage alt="radial gradient with focalPointRatio set to 0.75" href="../../images/radial_sketch.jpg"/> </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:matrix"><apiName>matrix</apiName><shortdesc>
     A transformation matrix as defined by the 
     Matrix class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     A transformation matrix as defined by the 
     Matrix class. The flash.geom.Matrix class includes a 
     <codeph>createGradientBox()</codeph> method to set up 
     the matrix for use with the <codeph>beginGradientFill()</codeph> method.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:ratios"><apiName>ratios</apiName><shortdesc>
     An array of color distribution ratios.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     An array of color distribution ratios. Valid values are between 0 and 255. This value 
     defines the percentage of the width where the color is sampled at 100%. The value 0 represents 
     the left position in the gradient box, and the value 255 represents the right position in the 
     gradient box. 
     
     <p><b>Note:</b> This value represents positions in the gradient box, not the 
     coordinate space of the final gradient which can be wider or thinner than the gradient box. 
     Specify a value for corresponding to each value in the <codeph>colors</codeph> property. </p>
     
     <p>For example, for a linear gradient that includes two colors (blue and green) the 
     following example illustrates the placement of the colors in the gradient based on different values
     in the <codeph>ratios</codeph> array:</p>
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Gradient</entry></row></thead><tbody><row>
     
      <entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 0 and 127" href="../../images/gradient-ratios-1.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 0 and 255" href="../../images/gradient-ratios-2.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 127 and 255" href="../../images/gradient-ratios-3.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     <p>The values in the array must increase sequentially; for example, 
     <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:interpolationMethod:get"><apiName>interpolationMethod</apiName><shortdesc>
     A value from the InterpolationMethod class that 
     specifies which value to use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     A value from the InterpolationMethod class that 
     specifies which value to use. Valid values are: <codeph>InterpolationMethod.LINEAR_RGB</codeph> or 
     <codeph>InterpolationMethod.RGB</codeph>
     
     <p>For example, the following shows a simple linear gradient between two colors (with the <codeph>spreadMethod</codeph> 
     parameter set to <codeph>SpreadMethod.REFLECT</codeph>). The different interpolation methods change 
     the appearance as follows: </p>
     
      <adobetable>
      
      
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="linear gradient with InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="linear gradient with InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
      </row><row>
      <entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
      <entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
      </row></tbody></tgroup></adobetable>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:spreadMethod:get"><apiName>spreadMethod</apiName><shortdesc>
     A value from the SpreadMethod class that 
     specifies which spread method to use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     A value from the SpreadMethod class that 
     specifies which spread method to use. Valid values are: <codeph>SpreadMethod.PAD</codeph>,
     <codeph>SpreadMethod.REFLECT</codeph>, or <codeph>SpreadMethod.REPEAT</codeph>. 
     
     <p>For example, the following shows a simple linear gradient between two colors:</p>
     
     <codeblock>
     import flash.geom.*
     import flash.display.*
     var fillType:String = GradientType.LINEAR;
     var colors:Array = [0xFF0000, 0x0000FF];
     var alphas:Array = [1, 1];
     var ratios:Array = [0x00, 0xFF];
     var matr:Matrix = new Matrix();
     matr.createGradientBox(20, 20, 0, 0, 0);
     var spreadMethod:String = SpreadMethod.PAD;
     this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       
     this.graphics.drawRect(0,0,100,100);
     </codeblock>
     
      <p>This example uses <codeph>SpreadMethod.PAD</codeph> for the spread method, and 
     the gradient fill looks like the following:</p>
     
      <p><adobeimage alt="linear gradient with SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
     
      <p>If you use <codeph>SpreadMethod.REFLECT</codeph> for the spread method, the gradient fill  
     looks like the following:</p>
     
      <p><adobeimage alt="linear gradient with SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
     
      <p>If you use <codeph>SpreadMethod.REPEAT</codeph> for the spread method, the gradient fill  
     looks like the following:</p>
     
      <p><adobeimage alt="linear gradient with SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:type:get"><apiName>type</apiName><shortdesc>
     A value from the GradientType class that 
     specifies which gradient type to use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     A value from the GradientType class that 
     specifies which gradient type to use. Values are <codeph>GradientType.LINEAR</codeph> or 
     <codeph>GradientType.RADIAL</codeph>. 
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Sprite"><apiName>Sprite</apiName><shortdesc>
 The Sprite class is a basic display list building block: a display list node that can display
 graphics and can also contain children.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>The basic display object for ActionScript created objects.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Sprite class is a basic display list building block: a display list node that can display
 graphics and can also contain children.
 
 <p>A Sprite object is similar to a movie clip, but does not have a timeline. Sprite is an
 appropriate base class for objects that do not require timelines. For example, Sprite would be a
 logical base class for user interface (UI) components that typically do not use the timeline.</p>
 
 <p>The Sprite class is new in ActionScript 3.0. It provides an alternative to the functionality of
 the MovieClip class, which retains all the functionality of previous ActionScript releases to
 provide backward compatibility.</p>
 
 </apiDesc><example conref="examples\SpriteExample.as"> The following example uses the SpriteExample class to draw an 
 orange square on the stage, and then dispatches events whenever the user clicks or drags the 
 square.  This task is accomplished by performing the following steps:
 <ol>
  <li>Declare the <codeph>size</codeph> property (100 x 100 pixels) and the background color
  (orange) for later use in drawing the square.</li>
 
  <li>The constructor then creates a new <codeph>child</codeph> Sprite object and uses it to add 
  two event listeners and their associated methods: <codeph>mouseDownHandler()</codeph> and
  <codeph>mouseUpHandler()</codeph>.</li>
 
  <li>The <codeph>child</codeph> Sprite object  is then passed to the 
  <codeph>draw()</codeph> method, which draws the orange square.</li>
 
  <li>The child is then placed on the display list by a call to the <codeph>addChild()</codeph>
  method. </li>
 
  <li>The event listeners work as follows:
 
  <ul>
      <li><codeph>mouseDownHandler()</codeph>: when the user clicks the Sprite object,
      this method adds a mouseMove event listener, the <codeph>mouseMoveHandler()</codeph> method, 
      which processes the mouse moves.  Then the <codeph>startDrag()</codeph> method is called, which
      allows the Sprite object to be dragged.</li>
 
      <li><codeph>mouseUpHandler()</codeph>: when the mouse button is released, the mouseMove event listener
      is removed and the <codeph>stopDrag()</codeph> method is called, which freezes the orange square in 
      place.</li>
 
      <li><codeph>mouseMoveHandler</codeph>: as long as the left mouse button is being held down, this
      method instructs the player to continuously redraw the orange square.</li>
 
  </ul>
  </li>
 
 </ol>
 
 <p><b>Note: </b>Each of the event listener methods declares a local <codeph>sprite</codeph>
 variable,  which is assigned the <codeph>target</codeph> property of the event.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;

    public class SpriteExample extends Sprite {
        private var size:uint    = 100;
        private var bgColor:uint = 0xFFCC00;

        public function SpriteExample() {
            var child:Sprite = new Sprite();
            child.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
            child.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
            draw(child);
            addChild(child);
        }

        private function mouseDownHandler(event:MouseEvent):void {
            trace("mouseDownHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.startDrag();
        }

        private function mouseUpHandler(event:MouseEvent):void {
            trace("mouseUpHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.stopDrag();
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            trace("mouseMoveHandler");
            event.updateAfterEvent();
        }

        private function draw(sprite:Sprite):void {
            sprite.graphics.beginFill(bgColor);
            sprite.graphics.drawRect(0, 0, size, size);
            sprite.graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:Sprite:Sprite"><apiName>Sprite</apiName><shortdesc>
	Creates a new Sprite instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Creates a new Sprite instance. After you create the Sprite instance, call the
	<codeph>DisplayObjectContainer.addChild()</codeph> or <codeph>DisplayObjectContainer.addChildAt()</codeph>
	method to add the Sprite to a parent DisplayObjectContainer.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:Sprite:startDrag"><apiName>startDrag</apiName><shortdesc>
	 Lets the user drag the specified sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.startDrag, startDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lockCenter</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Specifies whether the draggable sprite is locked to the center of
	 the mouse position (<codeph>true</codeph>), or locked to the point where the user first clicked the
	 sprite (<codeph>false</codeph>). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>bounds</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Value relative to the coordinates of the Sprite's parent that specify a constraint
	 rectangle for the Sprite. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Lets the user drag the specified sprite. The sprite remains draggable until explicitly
	 stopped through a call to the <codeph>Sprite.stopDrag()</codeph> method, or until 
	 another sprite is made draggable. Only one sprite is draggable at a time.
	 <p>Three-dimensional display objects follow the mouse and 
	 <codeph>Sprite.startDrag()</codeph> moves the object within
	 the three-dimensional plane defined by the display object. Or, if the display object is a two-dimensional object
	 and the child of a three-dimensional object, the two-dimensional object 
	 moves within the three dimensional plane defined by the three-dimensional parent object.</p>
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> The following example creates a <codeph>circle</codeph> sprite and two <codeph>target</codeph>
 sprites. The <codeph>startDrag()</codeph> method is called on the <codeph>circle</codeph> sprite when the user
 positions the cursor over the sprite and presses the mouse button, and the <codeph>stopDrag()</codeph> method 
 is called when the user releases the mouse button. This lets the user drag the sprite. On release of the mouse
 button, the <codeph>mouseRelease()</codeph> method is called, which in turn traces the <codeph>name</codeph> 
 of the <codeph>dropTarget</codeph> object  the one to which the user dragged the 
 <codeph>circle</codeph> sprite:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Sprite:stopDrag"><apiName>stopDrag</apiName><shortdesc>
	 Ends the startDrag() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sprite, movieclip.stopDrag, stopDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Ends the <codeph>startDrag()</codeph> method. A sprite that was made draggable with the 
	 <codeph>startDrag()</codeph> method remains draggable until a 
	 <codeph>stopDrag()</codeph> method is added, or until another
	 sprite becomes draggable. Only one sprite is draggable at a time.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> The following example creates a <codeph>circle</codeph> sprite and two <codeph>target</codeph>
 sprites. The <codeph>startDrag()</codeph> method is called on the <codeph>circle</codeph> sprite when the user
 positions the cursor over the sprite and presses the mouse button, and the <codeph>stopDrag()</codeph> method 
 is called when the user releases the mouse button. This lets the user drag the sprite. On release of the mouse
 button, the <codeph>mouseRelease()</codeph> method is called, which in turn traces the <codeph>name</codeph> 
 of the <codeph>dropTarget</codeph> object  the one to which the user dragged the 
 <codeph>circle</codeph> sprite:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Sprite:buttonMode:get"><apiName>buttonMode</apiName><shortdesc>
     Specifies the button mode of this sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Specifies the button mode of this sprite.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Specifies the button mode of this sprite. If <codeph>true</codeph>, this
     sprite behaves as a button, which means that it triggers the display
     of the hand cursor when the mouse passes over the sprite and can
     receive a <codeph>click</codeph> event if the enter or space keys are pressed
     when the sprite has focus. You can suppress the display of the hand cursor
     by setting the <codeph>useHandCursor</codeph> property to <codeph>false</codeph>,
     in which case the pointer is displayed.
     
     <p>Although it is better to use the SimpleButton class to create buttons, 
     you can use the <codeph>buttonMode</codeph> property to give a sprite 
     some button-like functionality. To include a sprite in the tab order,
     set the <codeph>tabEnabled</codeph> property (inherited from the
     InteractiveObject class and <codeph>false</codeph> by default) to
     <codeph>true</codeph>. Additionally, consider whether you want
     the children of your sprite to be mouse enabled. Most buttons
     do not enable mouse interactivity for their child objects because
     it confuses the event flow. To disable mouse interactivity for all child
     objects, you must set the <codeph>mouseChildren</codeph> property (inherited
     from the DisplayObjectContainer class) to <codeph>false</codeph>.</p>
     
     <p>If you use the <codeph>buttonMode</codeph> property with the MovieClip class (which is a
     subclass of the Sprite class), your button might have some added
     functionality. If you include frames labeled _up, _over, and _down,
     Flash Player provides automatic state changes (functionality
     similar to that provided in previous versions of ActionScript for movie
     clips used as buttons). These automatic state changes are
     not available for sprites, which have no timeline, and thus no frames
     to label. </p>
	 
	 </apiDesc><example conref="examples\Sprite.buttonMode.1.as"> The following example creates two sprites and sets the <codeph>buttonMode</codeph> 
 property to <codeph>true</codeph> for one and <codeph>false</codeph> for the other. When you compile 
 and run the application, both sprites respond to mouse events, but only the one in which 
 <codeph>buttonMode</codeph> is set to <codeph>true</codeph> uses the hand cursor and is included
 in the tab order:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton"><linktext>SimpleButton</linktext></link><link href="flash.display.xml#Sprite/useHandCursor"><linktext>Sprite.useHandCursor</linktext></link><link href="flash.display.xml#InteractiveObject/tabEnabled"><linktext>InteractiveObject.tabEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:dropTarget:get"><apiName>dropTarget</apiName><shortdesc>
	 Specifies the display object over which the sprite is being dragged, or on
	 which the sprite was dropped.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Sprite, Sprite.dropTarget, dropTarget
	 
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Specifies the DisplayObject over which the sprite is being dragged, or on which the
	 sprite was dropped.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Specifies the display object over which the sprite is being dragged, or on
	 which the sprite was dropped.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> The following example creates a <codeph>circle</codeph> sprite and two <codeph>target</codeph>
 sprites. The <codeph>startDrag()</codeph> method is called on the <codeph>circle</codeph> sprite when the user
 positions the cursor over the sprite and presses the mouse button, and the <codeph>stopDrag()</codeph> method 
 is called when the user releases the mouse button. This lets the user drag the sprite. On release of the mouse
 button, the <codeph>mouseRelease()</codeph> method is called, which in turn traces the <codeph>name</codeph> 
 of the <codeph>dropTarget</codeph> object  the one to which the user dragged the 
 <codeph>circle</codeph> sprite:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:graphics:get"><apiName>graphics</apiName><shortdesc>
     Specifies the Graphics object that belongs to this sprite where vector
     drawing commands can occur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Specifies a Graphics object.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Specifies the Graphics object that belongs to this sprite where vector
     drawing commands can occur.
     
	 </apiDesc><example conref="examples\Sprite.graphics.1.as"> The following example creates a <codeph>circle</codeph> sprite and uses its 
 <codeph>graphics</codeph> property to draw a circle with a yellow (0xFFCC00) fill:
<codeblock>
import flash.display.Sprite;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:hitArea:get"><apiName>hitArea</apiName><shortdesc>
	 Designates another sprite to serve as the hit area for a sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Sprite</apiValueClassifier></apiValueDef><apiDesc>
	 Designates another sprite to serve as the hit area for a sprite. If the <codeph>hitArea</codeph>
	 property does not exist or the value is <codeph>null</codeph> or <codeph>undefined</codeph>, the
	 sprite itself is used as the hit area. The value of the <codeph>hitArea</codeph> property can
	 be a reference to a Sprite object.
	 
	 <p>You can change the <codeph>hitArea</codeph> property at any time; the modified sprite immediately
	 uses the new hit area behavior. The sprite designated as the hit area does not need to be
	 visible; its graphical shape, although not visible, is still detected as the hit area.</p>
	 
	 <p><b>Note:</b> You must set to <codeph>false</codeph> the <codeph>mouseEnabled</codeph> 
	 property of the sprite designated as the hit area. Otherwise, your sprite button might
	 not work because the sprite designated as the hit area receives the mouse events instead
	 of your sprite button.</p>
	 
	 </apiDesc><example conref="examples\Sprite.hitArea.1.as"> The following example creates a <codeph>circle</codeph> sprite and a <codeph>square</codeph>
 sprite. The <codeph>square</codeph> sprite is the <codeph>hitArea</codeph> for the <codeph>circle</codeph> sprite.
 So when the user clicks the <codeph>square</codeph> sprite, the <codeph>circle</codeph> sprite dispatches 
 a <codeph>click</codeph> event:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xCCFF00);
square.graphics.drawRect(200, 0, 100, 100);

circle.hitArea = square;
square.mouseEnabled = false;

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void{
    trace(event.target == circle); // true
    trace(event.target == square); // false
}

addChild(circle);
addChild(square);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Controls sound within this sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Controls sound within this sprite.
	 
	 </apiDesc><example conref="examples\Sprite.soundTransform.1.as"> The following example creates a sprite named <codeph>container</codeph> 
 and adds a Loader object to its child list. The Loader object loads a SWF file. 
 When the user clicks the link in the <codeph>tf</codeph> text field <codeph>true</codeph>, the 
 <codeph>mute()</codeph> method sets the <codeph>volume</codeph> property of the 
 <codeph>soundTransform</codeph> property of the <codeph>container</codeph> sprite:
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.events.IOErrorEvent;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.text.TextField;
import flash.media.SoundTransform;

var container:Sprite = new Sprite();
addChild(container);

var ldr:Loader = new Loader;
var urlReq:URLRequest = new URLRequest("SoundPlayer.swf");
ldr.load(urlReq);

container.addChild(ldr);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);
            
var tf:TextField = new TextField();
tf.htmlText = "&lt;a href = 'event:Mute'&gt;Mute / Unmute&lt;/a&gt;";
addChild(tf);

var mySoundTransform:SoundTransform = new SoundTransform();
mySoundTransform.volume = 1;

tf.addEventListener(MouseEvent.CLICK, mute);

function mute(event:MouseEvent):void {    
    if (mySoundTransform.volume == 0) {
        mySoundTransform.volume = 1;
    } else {
        mySoundTransform.volume = 0;        
    }
    container.soundTransform = mySoundTransform;
}

function urlNotFound(event:IOErrorEvent):void {
    trace("The URL was not found."); 
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
	 A Boolean value that indicates whether the pointing hand (hand cursor) appears when the mouse rolls 
	 over a sprite in which the buttonMode property is set to true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>A Boolean value that indicates whether the pointing hand (hand cursor) appears when the
	 mouse rolls over a sprite in which the buttonMode property is set to true. 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 A Boolean value that indicates whether the pointing hand (hand cursor) appears when the mouse rolls 
	 over a sprite in which the <codeph>buttonMode</codeph> property is set to <codeph>true</codeph>. 
	 The default value of the <codeph>useHandCursor</codeph> property is <codeph>true</codeph>.
	 If <codeph>useHandCursor</codeph> is set to <codeph>true</codeph>, the pointing hand used for buttons
	 appears when the mouse rolls over a button sprite. If <codeph>useHandCursor</codeph> is
	 <codeph>false</codeph>, the arrow pointer is used instead.
	 
	 <p>You can change the <codeph>useHandCursor</codeph> property at any time; the modified sprite
	 immediately takes on the new cursor appearance. </p>
     
     <p product="flex"><b>Note:</b> If your sprite has child sprites, you might want to 
     set the <codeph>mouseChildren</codeph> property to <codeph>false</codeph>. For example, if you want a hand 
     cursor to appear over a Flex &lt;mx:Label&gt; control, set the <codeph>useHandCursor</codeph> and 
     <codeph>buttonMode</codeph> properties to <codeph>true</codeph>, and the <codeph>mouseChildren</codeph> property 
     to <codeph>false</codeph>.</p>
	 
	 </apiDesc><example conref="examples\Sprite.useHandCursor.1.as"> The following example creates two sprites and sets the <codeph>buttonMode</codeph> 
 property to <codeph>true</codeph> for both, yet it sets the <codeph>useHandCursor</codeph> 
 property to <codeph>true</codeph> for one and <codeph>false</codeph> for the other. When you compile 
 and run the application, both sprites respond as buttons (and are included in the tab order), but 
 only the one in which <codeph>useHandCursor</codeph> is set to <codeph>true</codeph> uses the hand cursor:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.useHandCursor = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = true;
circle2.useHandCursor = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>buttonMode</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
 Defines a bitmap fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines a bitmap fill. The bitmap can be smoothed, repeated or tiled to fill 
 the area; or manipulated using a transformation matrix.
 <p>
 Use a GraphicsBitmapFill object with the <codeph>Graphics.drawGraphicsData()</codeph> method.
 Drawing a GraphicsBitmapFill object is the equivalent of calling the <codeph>Graphics.beginBitmapFill()</codeph> method.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsBitmapFill:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
     Creates a new GraphicsBitmapFill object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>A transparent or opaque bitmap image that contains the bits to display.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>A matrix object (of the flash.geom.Matrix class), which you use to
     define transformations on the bitmap.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>If <codeph>true</codeph>, the bitmap image repeats in a tiled pattern. If 
     <codeph>false</codeph>, the bitmap image does not repeat, and the edges of the bitmap are 
     used for any fill area that extends beyond the bitmap. 
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>If <codeph>false</codeph>, upscaled bitmap images are rendered using a 
     nearest-neighbor algorithm and appear pixelated. If <codeph>true</codeph>, upscaled 
     bitmap images are rendered using a bilinear algorithm. Rendering that uses the nearest-neighbor
     algorithm is usually faster.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new GraphicsBitmapFill object.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsBitmapFill:bitmapData"><apiName>bitmapData</apiName><shortdesc>
     A transparent or opaque bitmap image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
     A transparent or opaque bitmap image.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:matrix"><apiName>matrix</apiName><shortdesc>
     A matrix object (of the flash.geom.Matrix class) that
     defines transformations on the bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     A matrix object (of the flash.geom.Matrix class) that
     defines transformations on the bitmap. For example, the following matrix
     rotates a bitmap by 45 degrees (pi/4 radians):
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:repeat"><apiName>repeat</apiName><shortdesc>
     Specifies whether to repeat the bitmap image in a tiled pattern.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Specifies whether to repeat the bitmap image in a tiled pattern.
     
     <p>
     If <codeph>true</codeph>, the bitmap image repeats in a tiled pattern. If 
     <codeph>false</codeph>, the bitmap image does not repeat, and the outermost pixels along 
     the edges of the bitmap are used for any fill area that extends beyond the bounds of the bitmap.</p>
     
     <p>For example, consider the following bitmap (a 20 x 20-pixel checkerboard pattern):</p>
     
     <p><adobeimage alt="20 by 20 pixel checkerboard" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
     
     <p>When <codeph>repeat</codeph> is set to <codeph>true</codeph> (as in the following example), the bitmap fill 
     repeats the bitmap:</p>
     
     <p><adobeimage alt="60 by 60 pixel checkerboard" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
     
     <p>When <codeph>repeat</codeph> is set to <codeph>false</codeph>, the bitmap fill uses the edge
     pixels for the fill area outside the bitmap:</p>
     
     <p><adobeimage alt="60 by 60 pixel image with no repeating" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsBitmapFill:smooth"><apiName>smooth</apiName><shortdesc>
     Specifies whether to apply a smoothing algorithm to the bitmap image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Specifies whether to apply a smoothing algorithm to the bitmap image.
     <p>
     If <codeph>false</codeph>, upscaled bitmap images are rendered by using a 
     nearest-neighbor algorithm and look pixelated. If <codeph>true</codeph>, upscaled 
     bitmap images are rendered by using a bilinear algorithm. Rendering by using the nearest 
     neighbor algorithm is usually faster.
     </p>
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Defines a line style or stroke.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsStroke</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines a line style or stroke. 
 
 <p>
 Use a GraphicsStroke object with the <codeph>Graphics.drawGraphicsData()</codeph> method.
 Drawing a GraphicsStroke object is the equivalent of calling one of the methods of the Graphics
 class that sets the line style, such as the <codeph>Graphics.lineStyle()</codeph> method, the 
 <codeph>Graphics.lineBitmapStyle()</codeph> method, or the <codeph>Graphics.lineGradientStyle()</codeph> 
 method.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>flash.display.Graphics.lineBitmapStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsStroke:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Creates a new GraphicsStroke object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>An integer that indicates the thickness of the line in 
 points; valid values are 0-255. If a number is not specified, or if the 
 parameter is undefined, a line is not drawn. If a value of less than 0 is passed, 
 the default is 0. The value 0 indicates hairline thickness; the maximum thickness 
 is 255. If a value greater than 255 is passed, the default is 255. 
 
 </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>A Boolean value that specifies whether to hint strokes 
 to full pixels. This affects both the position of anchors of a curve and the line stroke size 
 itself. With <codeph>pixelHinting</codeph> set to <codeph>true</codeph>, Flash Player hints line widths  
 to full pixel widths. With <codeph>pixelHinting</codeph> set to <codeph>false</codeph>, disjoints can 
 appear for curves and straight lines. For example, the following illustrations show how 
 Flash Player renders two rounded rectangles that are identical, except that the 
 <codeph>pixelHinting</codeph> parameter used in the <codeph>lineStyle()</codeph> method is set 
 differently (the images are scaled by 200%, to emphasize the difference):
 
 <p><adobeimage alt="pixelHinting false and pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 <p>If a value is not supplied, the line does not use pixel hinting.</p>
  
 </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>A value from the LineScaleMode class that 
 specifies which scale mode to use:
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph>—Always scale the line thickness when the object is scaled 
 (the default).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph>—Never scale the line thickness.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph>—Do not scale the line thickness if the object is scaled vertically 
 <i>only</i>. For example, consider the following circles, drawn with a one-pixel line, and each with the 
 <codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.VERTICAL</codeph>. The circle on the left 
 is scaled vertically only, and the circle on the right is scaled both vertically and horizontally:
 
 <p><adobeimage alt="A circle scaled vertically, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph>—Do not scale the line thickness if the object is scaled horizontally 
 <i>only</i>. For example, consider the following circles, drawn with a one-pixel line, and each with the 
 <codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.HORIZONTAL</codeph>. The circle on the left 
 is scaled horizontally only, and the circle on the right is scaled both vertically and horizontally:
 
 <p><adobeimage alt="A circle scaled horizontally, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 
 </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>A value from the CapsStyle class that specifies the type of caps at the end 
 of lines. Valid values are: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph>, and <codeph>CapsStyle.SQUARE</codeph>. 
 If a value is not indicated, Flash uses round caps. 
 <p>For example, the following illustrations show the different <codeph>capsStyle</codeph> 
 settings. For each setting, the illustration shows a blue line with a thickness of 30 (for 
 which the <codeph>capsStyle</codeph> applies), and a superimposed black line with a thickness of 1 
 (for which no <codeph>capsStyle</codeph> applies):
 </p>
 <p><adobeimage alt="NONE, ROUND, and SQUARE" href="../../images/linecap.jpg"/></p>
 
 </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>round</apiData><apiDesc>A value from the JointStyle class that specifies the type of joint appearance
 used at angles. Valid 
 values are: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph>, and <codeph>JointStyle.ROUND</codeph>.
 If a value is not indicated, Flash uses round joints. 
 
 <p>For example, the following illustrations show the different <codeph>joints</codeph> 
 settings. For each setting, the illustration shows an angled blue line with a thickness of 
 30 (for which the <codeph>jointStyle</codeph> applies), and a superimposed angled black line with a 
 thickness of 1 (for which no <codeph>jointStyle</codeph> applies):
 </p>
 
 <p><adobeimage alt="MITER, ROUND, and BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Note:</b> For <codeph>joints</codeph> set to <codeph>JointStyle.MITER</codeph>, 
 you can use the <codeph>miterLimit</codeph> parameter to limit the length of the miter.</p>
 
 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3.0</apiData><apiDesc>A number that indicates the limit at which a miter is cut off. 
 Valid values range from 1 to 255 (and values outside that range are rounded to 1 or 255). 
 This value is only used if the <codeph>jointStyle</codeph> 
 is set to <codeph>"miter"</codeph>. The 
 <codeph>miterLimit</codeph> value represents the length that a miter can extend beyond the point
 at which the lines meet to form a joint. The value expresses a factor of the line
 <codeph>thickness</codeph>. For example, with a <codeph>miterLimit</codeph> factor of 2.5 and a 
 <codeph>thickness</codeph> of 10 pixels, the miter is cut off at 25 pixels. 
 
 <p>For example, consider the following angled lines, each drawn with a <codeph>thickness</codeph> 
 of 20, but with <codeph>miterLimit</codeph> set to 1, 2, and 4. Superimposed are black reference
 lines showing the meeting points of the joints:</p>
 
 <p><adobeimage alt="lines with miterLimit set to 1, 2, and 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Notice that a given <codeph>miterLimit</codeph> value has a specific maximum angle 
 for which the miter is cut off. The following table lists some examples:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> value:</entry><entry>Angles smaller than this are cut off:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 degrees</entry></row><row><entry>2</entry>      <entry>60 degrees</entry></row><row><entry>4</entry>      <entry>30 degrees</entry></row><row><entry>8</entry>      <entry>15 degrees</entry></row></tbody></tgroup></adobetable>
 </apiDesc></apiParam><apiParam><apiItemName>fill</apiItemName><apiOperationClassifier>flash.display:IGraphicsFill</apiOperationClassifier><apiData>null</apiData><apiDesc>An IGraphicsFill instance containing data for filling a stroke. An IGraphicsFill
 instance can represent a series of fill commands.
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Creates a new GraphicsStroke object.
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsStroke:fill"><apiName>fill</apiName><shortdesc>
 Specifies the instance containing data for filling a stroke.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:IGraphicsFill</apiValueClassifier></apiValueDef><apiDesc>
 Specifies the instance containing data for filling a stroke. An IGraphicsFill
 instance can represent a series of fill commands.
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:miterLimit"><apiName>miterLimit</apiName><shortdesc>
 Indicates the limit at which a miter is cut off.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Indicates the limit at which a miter is cut off. 
 Valid values range from 1 to 255 (and values outside that range are rounded to 1 or 255). 
 This value is only used if the <codeph>jointStyle</codeph> 
 is set to <codeph>"miter"</codeph>. The 
 <codeph>miterLimit</codeph> value represents the length that a miter can extend beyond the point
 at which the lines meet to form a joint. The value expresses a factor of the line
 <codeph>thickness</codeph>. For example, with a <codeph>miterLimit</codeph> factor of 2.5 and a 
 <codeph>thickness</codeph> of 10 pixels, the miter is cut off at 25 pixels. 
 
 <p>For example, consider the following angled lines, each drawn with a <codeph>thickness</codeph> 
 of 20, but with <codeph>miterLimit</codeph> set to 1, 2, and 4. Superimposed are black reference
 lines showing the meeting points of the joints:</p>
 
 <p><adobeimage alt="lines with miterLimit set to 1, 2, and 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Notice that a given <codeph>miterLimit</codeph> value has a specific maximum angle 
 for which the miter is cut off. The following table lists some examples:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> value:</entry><entry>Angles smaller than this are cut off:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 degrees</entry></row><row><entry>2</entry>      <entry>60 degrees</entry></row><row><entry>4</entry>      <entry>30 degrees</entry></row><row><entry>8</entry>      <entry>15 degrees</entry></row></tbody></tgroup></adobetable>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:pixelHinting"><apiName>pixelHinting</apiName><shortdesc>
 Specifies whether to hint strokes 
 to full pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
 Specifies whether to hint strokes 
 to full pixels. This affects both the position of anchors of a curve and the line stroke size 
 itself. With <codeph>pixelHinting</codeph> set to <codeph>true</codeph>, Flash Player hints line widths  
 to full pixel widths. With <codeph>pixelHinting</codeph> set to <codeph>false</codeph>, disjoints can 
 appear for curves and straight lines. For example, the following illustrations show how 
 Flash Player renders two rounded rectangles that are identical, except that the 
 <codeph>pixelHinting</codeph> parameter used in the <codeph>lineStyle()</codeph> method is set 
 differently (the images are scaled by 200%, to emphasize the difference):
 
 <p><adobeimage alt="pixelHinting false and pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:thickness"><apiName>thickness</apiName><shortdesc>
 Indicates the thickness of the line in 
 points; valid values are 0-255.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Indicates the thickness of the line in 
 points; valid values are 0-255. If a number is not specified, or if the 
 parameter is undefined, a line is not drawn. If a value of less than 0 is passed, 
 the default is 0. The value 0 indicates hairline thickness; the maximum thickness 
 is 255. If a value greater than 255 is passed, the default is 255.
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:caps:get"><apiName>caps</apiName><shortdesc>
 Specifies the type of caps at the end 
 of lines.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Specifies the type of caps at the end 
 of lines. Valid values are: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph>, and <codeph>CapsStyle.SQUARE</codeph>. 
 If a value is not indicated, Flash uses round caps. 
 <p>For example, the following illustrations show the different <codeph>capsStyle</codeph> 
 settings. For each setting, the illustration shows a blue line with a thickness of 30 (for 
 which the <codeph>capsStyle</codeph> applies), and a superimposed black line with a thickness of 1 
 (for which no <codeph>capsStyle</codeph> applies):
 </p>
 <p><adobeimage alt="NONE, ROUND, and SQUARE" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:joints:get"><apiName>joints</apiName><shortdesc>
 Specifies the type of joint appearance
 used at angles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Specifies the type of joint appearance
 used at angles. Valid 
 values are: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph>, and <codeph>JointStyle.ROUND</codeph>.
 If a value is not indicated, Flash uses round joints. 
 
 <p>For example, the following illustrations show the different <codeph>joints</codeph> 
 settings. For each setting, the illustration shows an angled blue line with a thickness of 
 30 (for which the <codeph>jointStyle</codeph> applies), and a superimposed angled black line with a 
 thickness of 1 (for which no <codeph>jointStyle</codeph> applies):
 </p>
 
 <p><adobeimage alt="MITER, ROUND, and BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Note:</b> For <codeph>joints</codeph> set to <codeph>JointStyle.MITER</codeph>, 
 you can use the <codeph>miterLimit</codeph> parameter to limit the length of the miter.</p>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
 Specifies the stroke thickness scaling.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Specifies the stroke thickness scaling. Valid values are:
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph>—Always scale the line thickness when the object is scaled 
 (the default).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph>—Never scale the line thickness.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph>—Do not scale the line thickness if the object is scaled vertically 
 <i>only</i>. For example, consider the following circles, drawn with a one-pixel line, and each with the 
 <codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.VERTICAL</codeph>. The circle on the left 
 is scaled vertically only, and the circle on the right is scaled both vertically and horizontally:
 
 <p><adobeimage alt="A circle scaled vertically, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph>—Do not scale the line thickness if the object is scaled horizontally 
 <i>only</i>. For example, consider the following circles, drawn with a one-pixel line, and each with the 
 <codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.HORIZONTAL</codeph>. The circle on the left 
 is scaled horizontally only, and the circle on the right is scaled both vertically and horizontally:
 
 <p><adobeimage alt="A circle scaled horizontally, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Indicates the end of a graphics fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Indicates the end of a graphics fill. Use a GraphicsEndFill object with the <codeph>Graphics.drawGraphicsData()</codeph> method.
 
 <p>
 Drawing a GraphicsEndFill object is the equivalent of calling the <codeph>Graphics.endFill()</codeph> method.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsEndFill:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Creates an object to use with the Graphics.drawGraphicsData() method to end
 the fill, explicitly.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 Creates an object to use with the <codeph>Graphics.drawGraphicsData()</codeph> method to end
 the fill, explicitly.
 
 
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderPrecision"><apiName>ShaderPrecision</apiName><shortdesc>
	 This class defines the constants that represent the possible values for 
	 the Shader class's precisionHint property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 This class defines the constants that represent the possible values for 
	 the Shader class's <codeph>precisionHint</codeph> property. Each constant 
	 represents one of the precision modes for executing shader operations.
	 
	 <p>The precision mode selection affects the following shader operations. 
	 These operations are faster on an Intel processor 
	 with the SSE instruction set:</p>
	 
	 <ul>
	   <li><codeph>sin(x)</codeph></li>
	   <li><codeph>cos(x)</codeph></li>
	   <li><codeph>tan(x)</codeph></li>
	   <li><codeph>asin(x)</codeph></li>
	   <li><codeph>acos(x)</codeph></li>
	   <li><codeph>atan(x)</codeph></li>
	   <li><codeph>atan(x, y)</codeph></li>
	   <li><codeph>exp(x)</codeph></li>
	   <li><codeph>exp2(x)</codeph></li>
	   <li><codeph>log(x)</codeph></li>
	   <li><codeph>log2(x)</codeph></li>
	   <li><codeph>pow(x, y)</codeph></li>
	   <li><codeph>reciprocal(x)</codeph></li>
	   <li><codeph>sqrt(x)</codeph></li>
	 </ul>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links><apiValue id="flash.display:ShaderPrecision:FAST"><apiName>FAST</apiName><shortdesc>
		 Represents fast precision mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fast</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Represents fast precision mode.
		 
		 <p>Fast precision mode is designed for 
		 maximum performance but does not work consistently on different platforms 
		 and individual CPU configurations. In many cases, this level of precision
		 is sufficient to create graphic effects without visible artifacts.</p>
		 
		 <p>It is usually faster to use fast precision mode than to use lookup tables.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderPrecision:FULL"><apiName>FULL</apiName><shortdesc>
		 Represents full precision mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Represents full precision mode.
		 
		 <p>In full precision mode, the shader computes all math 
		 operations to the full width of the IEEE 32-bit floating standard. This mode provides 
		 consistent behavior on all platforms. In this mode, some math operations such 
		 as trigonometric and exponential functions can be slow.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:BlendMode"><apiName>BlendMode</apiName><shortdesc>
A class that provides constant values for visual blend mode effects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
A class that provides constant values for visual blend mode effects. These constants are used in the following:

<ul>

	<li> The <codeph>blendMode</codeph> property of the flash.display.DisplayObject class.</li>

	<li> The <codeph>blendMode</codeph> parameter of the <codeph>draw()</codeph> method of the 
		flash.display.BitmapData class</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiValue id="flash.display:BlendMode:ADD"><apiName>ADD</apiName><shortdesc>
Adds the values of the constituent colors of the display object to the colors of its background, applying a 
ceiling of 0xFF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>add</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Adds the values of the constituent colors of the display object to the colors of its background, applying a 
ceiling of 0xFF. This setting is commonly used for animating a lightening dissolve between 
two objects.

<p>For example, if the display object has a pixel with an RGB value of 0xAAA633, and the background
pixel has an RGB value of 0xDD2200, the resulting RGB value for the displayed pixel is 
0xFFC833 (because 0xAA + 0xDD &gt; 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ALPHA"><apiName>ALPHA</apiName><shortdesc>
Applies the alpha value of each pixel of the display object to the background.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>alpha</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Applies the alpha value of each pixel of the display object to the background. 
This requires the <codeph>blendMode</codeph> property of the parent display object be set to
<codeph>flash.display.BlendMode.LAYER</codeph>. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DARKEN"><apiName>DARKEN</apiName><shortdesc>
Selects the darker of the constituent colors of the display object and the colors of the background (the 
colors with the smaller values).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>darken</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Selects the darker of the constituent colors of the display object and the colors of the background (the 
colors with the smaller values). This setting is commonly used for superimposing type. 

<p>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background
pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 
0xDDCC00 (because 0xFF &gt; 0xDD, 0xCC &lt; 0xF8, and 0x33 &gt; 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DIFFERENCE"><apiName>DIFFERENCE</apiName><shortdesc>
Compares the constituent colors of the display object with the colors of its background, and subtracts 
the darker of the values of the two constituent colors from the lighter value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>difference</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Compares the constituent colors of the display object with the colors of its background, and subtracts 
the darker of the values of the two constituent colors from the lighter value. This setting is commonly
used for more vibrant colors. 

<p>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background
pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 
0x222C33 (because 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ERASE"><apiName>ERASE</apiName><shortdesc>
Erases the background based on the alpha value of the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>erase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Erases the background based on the alpha value of the display object. This process requires 
that the <codeph>blendMode</codeph> property of the parent display object be set to
<codeph>flash.display.BlendMode.LAYER</codeph>. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:HARDLIGHT"><apiName>HARDLIGHT</apiName><shortdesc>
Adjusts the color of each pixel based on the darkness of the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>hardlight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Adjusts the color of each pixel based on the darkness of the display object. 
If the display object is lighter than 50% gray, the display object and background colors are 
screened, which results in a lighter color. If the display object is darker than 50% gray, 
the colors are multiplied, which results in a darker color. 
This setting is commonly used for shading effects. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:INVERT"><apiName>INVERT</apiName><shortdesc>
Inverts the background.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>invert</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Inverts the background.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LAYER"><apiName>LAYER</apiName><shortdesc>
Forces the creation of a transparency group for the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>layer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Forces the creation of a transparency group for the display object. This means that the display 
object is precomposed in a temporary buffer before it is processed further. The precomposition is done 
automatically if the display object is precached by means of bitmap caching or if the display object is 
a display object container that has at least one child object with a <codeph>blendMode</codeph> 
setting other than <codeph>"normal"</codeph>.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LIGHTEN"><apiName>LIGHTEN</apiName><shortdesc>
Selects the lighter of the constituent colors of the display object and the colors of the background (the 
colors with the larger values).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lighten</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Selects the lighter of the constituent colors of the display object and the colors of the background (the 
colors with the larger values). This setting is commonly used for superimposing type. 

<p>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background
pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 
0xFFF833 (because 0xFF &gt; 0xDD, 0xCC &lt; 0xF8, and 0x33 &gt; 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:MULTIPLY"><apiName>MULTIPLY</apiName><shortdesc>
Multiplies the values of the display object constituent colors by the constituent colors of 
the background color, and normalizes by dividing by 0xFF, 
resulting in darker colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>multiply</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Multiplies the values of the display object constituent colors by the constituent colors of 
the background color, and normalizes by dividing by 0xFF, 
resulting in darker colors. This setting is commonly used for shadows and depth effects.

<p>For example, if a constituent color (such as red) of one pixel in the display object and the
corresponding color of the pixel in the background both have the value 0x88, the multiplied
result is 0x4840. Dividing by 0xFF yields a value of 0x48 for that constituent color, 
which is a darker shade than the color of the display object or the color of the background.</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
The display object appears in front of the background.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The display object appears in front of the background. Pixel values of the display object
override the pixel values of the background. Where the display object is transparent, the 
background is visible.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:OVERLAY"><apiName>OVERLAY</apiName><shortdesc>
Adjusts the color of each pixel based on the darkness of the background.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>overlay</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Adjusts the color of each pixel based on the darkness of the background. 
If the background is lighter than 50% gray, the display object and background colors are 
screened, which results in a lighter color. If the background is darker than 50% gray, 
the colors are multiplied, which results in a darker color. 
This setting is commonly used for shading effects. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SCREEN"><apiName>SCREEN</apiName><shortdesc>
Multiplies the complement (inverse) of the display object color by the complement of the background 
color, resulting in a bleaching effect.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>screen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Multiplies the complement (inverse) of the display object color by the complement of the background 
color, resulting in a bleaching effect. This setting is commonly used for highlights or to remove black 
areas of the display object. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SHADER"><apiName>SHADER</apiName><shortdesc>
Uses a shader to define the blend between objects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>shader</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Uses a shader to define the blend between objects.

<p>Setting the <codeph>blendShader</codeph> property to a Shader instance 
automatically sets the display object's <codeph>blendMode</codeph> property to 
<codeph>BlendMode.SHADER</codeph>. If the <codeph>blendMode</codeph> property is set to 
<codeph>BlendMode.SHADER</codeph> without first setting the <codeph>blendShader</codeph> property,
the <codeph>blendMode</codeph> property is set to <codeph>BlendMode.NORMAL</codeph> instead. 
If the <codeph>blendShader</codeph> property is set (which sets the 
<codeph>blendMode</codeph> property to <codeph>BlendMode.SHADER</codeph>), then later the value of the 
<codeph>blendMode</codeph> property is changed, the blend mode can be reset to use the blend 
shader simply by setting the <codeph>blendMode</codeph> property to <codeph>BlendMode.SHADER</codeph>. 
The <codeph>blendShader</codeph> property does not need to be set again except to change the 
shader that's used to define the blend mode.</p>

</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue><apiValue id="flash.display:BlendMode:SUBTRACT"><apiName>SUBTRACT</apiName><shortdesc>
Subtracts the values of the constituent colors in the display object from the values of the background
color, applying a floor of 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subtract</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Subtracts the values of the constituent colors in the display object from the values of the background
color, applying a floor of 0. This setting is commonly used for animating a darkening dissolve between 
two objects.

<p>For example, if the display object has a pixel with an RGB value of 0xAA2233, and the background
pixel has an RGB value of 0xDDA600, the resulting RGB value for the displayed pixel is 
0x338400 (because 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 &lt; 0x00).</p>
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Graphics"><apiName>Graphics</apiName><shortdesc>
 The Graphics class contains a set of methods that you can use to create a vector shape.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Graphics class contains a set of methods that you can use to create a vector shape. 
 Display objects that support drawing include Sprite and Shape objects.
 Each of these classes includes a <codeph>graphics</codeph> property that is a Graphics object. 
 The following are among those helper functions provided for ease of use: 
 <codeph>drawRect()</codeph>, <codeph>drawRoundRect()</codeph>, 
 <codeph>drawCircle()</codeph>, and <codeph>drawEllipse()</codeph>.
 
 <p>You cannot create a Graphics object directly from ActionScript code. 
 If you call <codeph>new Graphics()</codeph>, an exception is thrown.</p>
 
 <p>The Graphics class is final; it cannot be subclassed.</p>
 
 
 </apiDesc><example conref="examples\GraphicsExample.as"> The following example uses the GraphicsExample class to draw a circle,
 a rounded rectangle, and a square.  This task is accomplished by using the following steps:
 <ol>
    <li>Declare a <codeph>size</codeph> property for later use in determining the size of each shape.</li>
     <li>Declare properties that set the background color to orange, the border color to
     dark gray, the border size to 0 pixels, the corner radius to 9 pixels, and set the space
     between the stage edge and the other objects to be 5 pixels.</li>
    <li>Use the properties declared in the preceding steps along with the built in methods of the
     Graphics class to draw the circle, rounded rectangle, and square at coordinates x = 0, y = 0.</li>
    <li>Redraw each of the shapes along the top of the stage, starting at x = 5, y = 5, with
     a 5-pixel spacing between shapes.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class GraphicsExample extends Sprite {
        private var size:uint         = 80;
        private var bgColor:uint      = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function GraphicsExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size / 2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Graphics:beginBitmapFill"><apiName>beginBitmapFill</apiName><shortdesc>
	 Fills a drawing area with a bitmap image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>A transparent or opaque bitmap image that contains the bits to be displayed.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>A matrix object (of the flash.geom.Matrix class), which you can use to
	 define transformations on the bitmap. For example, you can use the following matrix
	 to rotate a bitmap by 45 degrees (pi/4 radians):
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>If <codeph>true</codeph>, the bitmap image repeats in a tiled pattern. If 
	 <codeph>false</codeph>, the bitmap image does not repeat, and the edges of the bitmap are 
	 used for any fill area that extends beyond the bitmap. 
	 
	 <p>For example, consider the following bitmap (a 20 x 20-pixel checkerboard pattern):</p>
	 
     <p><adobeimage alt="20 by 20 pixel checkerboard" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
	 
	 <p>When <codeph>repeat</codeph> is set to <codeph>true</codeph> (as in the following example), the bitmap fill 
	 repeats the bitmap:</p>
	 
     <p><adobeimage alt="60 by 60 pixel checkerboard" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
	 
	 <p>When <codeph>repeat</codeph> is set to <codeph>false</codeph>, the bitmap fill uses the edge
	 pixels for the fill area outside the bitmap:</p>
	 
     <p><adobeimage alt="60 by 60 pixel image with no repeating" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 
   	 
	 </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>If <codeph>false</codeph>, upscaled bitmap images are rendered by using a 
	 nearest-neighbor algorithm and look pixelated. If <codeph>true</codeph>, upscaled 
   	 bitmap images are rendered by using a bilinear algorithm. Rendering by using the nearest 
	 neighbor algorithm is faster.
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Begins a bitmap filled shape.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Fills a drawing area with a bitmap image. The bitmap can be repeated or tiled to fill 
	 the area. The fill remains in effect until you call the <codeph>beginFill()</codeph>,  
	 <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph>, or <codeph>beginShaderFill()</codeph> method. 
	 Calling the <codeph>clear()</codeph> method clears the fill.
	 
	 <p>The application renders the fill whenever three or more points are drawn, or when 
	 the <codeph>endFill()</codeph> method is called. </p>
	 
	 </apiDesc><example conref="examples\Graphics_beginBitmapFillExample.as"> The following example uses an image (<codeph>image1.jpg</codeph>) that is rotated and repeated to fill in a rectangle.
 
 <ol>
    <li>The image file (<codeph>image1.jpg</codeph>) is loaded using the <codeph>Loader</codeph> and <codeph>URLRequest</codeph> objects. 
 Here the file is in the same directory as the SWF file. The SWF file needs to be compiled with Local Playback 
 Security set to Access Local Files Only.</li>
     <li>When the image is loaded (<codeph>Event</codeph> is complete), the <codeph>drawImage()</codeph> method is called. 
 The <codeph>ioErrorHandler()</codeph> method writes a trace comment if the image was not loaded properly.</li>  
  <li>In <codeph>drawImage()</codeph> method, a <codeph>BitmapData</codeph> object is instantiated and its width and height 
 are set to the image (<codeph>image1.jpg</codeph>). Then the source image is drawn into the BitmapData
 object. Next, a rectangle is drawn in the <codeph>mySprite</codeph> Sprite object and the BitmapData object is used to 
 fill it. Using a <codeph>Matrix</codeph> object, the <codeph>beginBitmapFill()</codeph> method rotates the image 45 degrees, 
 then it begins filling the rectangle with the image until it is finished.</li> 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.geom.Matrix;

    public class Graphics_beginBitmapFillExample extends Sprite {
 
        private var url:String = "image1.jpg";
        private var loader:Loader = new Loader();

        public function Graphics_beginBitmapFillExample() {

            var request:URLRequest = new URLRequest(url);
            
            loader.load(request);
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, drawImage);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function drawImage(event:Event):void {

            var mySprite:Sprite = new Sprite();
            var myBitmap:BitmapData = new BitmapData(loader.width, loader.height, false);
  
            myBitmap.draw(loader, new Matrix());
            
            var matrix:Matrix = new Matrix();
            matrix.rotate(Math.PI/4);
            
            mySprite.graphics.beginBitmapFill(myBitmap, matrix, true);
            mySprite.graphics.drawRect(100, 50, 200, 90);
            mySprite.graphics.endFill();
            
            addChild(mySprite);
        }
 
         private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }   
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginFill"><apiName>beginFill</apiName><shortdesc>
 	 Specifies a simple one-color fill that subsequent calls to other 
	 Graphics methods (such as lineTo() or drawCircle()) use when drawing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The color of the fill (0xRRGGBB).
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>The alpha value of the fill (0.0 to 1.0). 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Specifies a single-color fill.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Specifies a simple one-color fill that subsequent calls to other 
	 Graphics methods (such as <codeph>lineTo()</codeph> or <codeph>drawCircle()</codeph>) use when drawing.
	 The fill remains in effect until you call the <codeph>beginFill()</codeph>,  
	 <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph>, or <codeph>beginShaderFill()</codeph> method. 
	 Calling the <codeph>clear()</codeph> method clears the fill.
	 
	 <p>The application renders the fill whenever three or more points are drawn, or when 
	 the <codeph>endFill()</codeph> method is called.</p>
	 
	 </apiDesc><example>Please see the <xref href="Graphics.html#includeExamplesSummary">example</xref> at the end of this 
     class for an illustration of how to use this method. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginGradientFill"><apiName>beginGradientFill</apiName><shortdesc>
	 Specifies a gradient fill used by subsequent calls to other 
	 Graphics methods (such as lineTo() or drawCircle()) for the object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>type</codeph> parameter is not valid.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>A value from the GradientType class that 
	 specifies which gradient type to use: <codeph>GradientType.LINEAR</codeph> or 
	 <codeph>GradientType.RADIAL</codeph>. 
	 
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of RGB hexadecimal color values used in the gradient; for example,
     red is 0xFF0000, blue is 0x0000FF, and so on. You can specify up to 15 colors. 
     For each color, specify a corresponding value in the alphas and ratios parameters.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of alpha values for the corresponding colors in the colors array; 
     valid values are 0 to 1. If the value is less than 0, the default is 0. If the value is 
     greater than 1, the default is 1.
     
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of color distribution ratios; valid values are 0-255. This value 
	 defines the percentage of the width where the color is sampled at 100%. The value 0 represents 
	 the left position in the gradient box, and 255 represents the right position in the 
	 gradient box. 
	 
	 <p><b>Note:</b> This value represents positions in the gradient box, not the 
	 coordinate space of the final gradient, which can be wider or thinner than the gradient box. 
	 Specify a value for each value in the <codeph>colors</codeph> parameter. </p>
	 
	 <p>For example, for a linear gradient that includes two colors, blue and green, the 
	 following example illustrates the placement of the colors in the gradient based on different values
	 in the <codeph>ratios</codeph> array:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Gradient</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
	 	<entry><adobeimage alt="linear gradient blue to green with ratios 0 and 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 0 and 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 127 and 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>The values in the array must increase sequentially; for example, 
	 <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>A transformation matrix as defined by the 
	 flash.geom.Matrix class. The flash.geom.Matrix class includes a 
	 <codeph>createGradientBox()</codeph> method, which lets you conveniently set up 
	 the matrix for use with the <codeph>beginGradientFill()</codeph> method.
	 
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>A value from the SpreadMethod class that 
	 specifies which spread method to use, either: <codeph>SpreadMethod.PAD</codeph>,
	 <codeph>SpreadMethod.REFLECT</codeph>, or <codeph>SpreadMethod.REPEAT</codeph>. 
	 
	 <p>For example, consider a simple linear gradient between two colors:</p>
	 
	 <codeblock>
	 import flash.geom.*
	 import flash.display.*
	 var fillType:String = GradientType.LINEAR;
	 var colors:Array = [0xFF0000, 0x0000FF];
	 var alphas:Array = [1, 1];
	 var ratios:Array = [0x00, 0xFF];
	 var matr:Matrix = new Matrix();
	 matr.createGradientBox(20, 20, 0, 0, 0);
	 var spreadMethod:String = SpreadMethod.PAD;
	 this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);		
	 this.graphics.drawRect(0,0,100,100);
	 </codeblock>
	 
	 	<p>This example uses <codeph>SpreadMethod.PAD</codeph> for the spread method, and 
	 the gradient fill looks like the following:</p>
	 
      <p><adobeimage alt="linear gradient with SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
 	 
	 	<p>If you use <codeph>SpreadMethod.REFLECT</codeph> for the spread method, the gradient fill  
	 looks like the following:</p>
 	 
      <p><adobeimage alt="linear gradient with SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
 	 
	 	<p>If you use <codeph>SpreadMethod.REPEAT</codeph> for the spread method, the gradient fill  
	 looks like the following:</p>
 	 
      <p><adobeimage alt="linear gradient with SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>A value from the InterpolationMethod class that 
	 specifies which value to use: <codeph>InterpolationMethod.LINEAR_RGB</codeph> or 
	 <codeph>InterpolationMethod.RGB</codeph>
	 
	 <p>For example, consider a simple linear gradient between two colors (with the <codeph>spreadMethod</codeph> 
	 parameter set to <codeph>SpreadMethod.REFLECT</codeph>). The different interpolation methods affect 
	 the appearance as follows: </p>
	 
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="linear gradient with InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="linear gradient with InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>A number that controls the 
	 location of the focal point of the gradient. 0 means that the focal point is in the center. 1 
	 means that the focal point is at one border of the gradient circle. -1 means that the focal point 
	 is at the other border of the gradient circle. A value less than -1 or greater than
	 1 is rounded to -1 or 1. For example, the following example
	 shows a <codeph>focalPointRatio</codeph> set to 0.75:
	 
     <p><adobeimage alt="radial gradient with focalPointRatio set to 0.75" href="../../images/radial_sketch.jpg"/> </p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Specifies a gradient fill.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Specifies a gradient fill used by subsequent calls to other 
	 Graphics methods (such as <codeph>lineTo()</codeph> or <codeph>drawCircle()</codeph>) for the object.
	 The fill remains in effect until you call the <codeph>beginFill()</codeph>,  
	 <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph>, or <codeph>beginShaderFill()</codeph> method. 
	 Calling the <codeph>clear()</codeph> method clears the fill.
	 
	 <p>The application renders the fill whenever three or more points are drawn, or when 
	 the <codeph>endFill()</codeph> method is called. </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginShaderFill"><apiName>beginShaderFill</apiName><shortdesc>
 	 Specifies a shader fill used by subsequent calls to other Graphics methods
	 (such as lineTo() or drawCircle()) for the object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the shader output type is not compatible with this operation 
	                       (the shader must specify a <codeph>pixel3</codeph> or <codeph>pixel4</codeph> 
	                       output).
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the shader specifies an image input that isn't provided.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When a ByteArray or Vector.&lt;Number&gt; instance is used as 
	                       an input and the <codeph>width</codeph> 
	                       and <codeph>height</codeph> properties aren't specified for the 
	                       ShaderInput, or the specified values don't match the amount of 
	                       data in the input object. See the <codeph>ShaderInput.input</codeph> 
	                       property for more information.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>The shader to use for the fill. This Shader instance is not required to 
	 specify an image input. However, if an image input is specified in the shader, the input 
	 must be provided manually. To specify the input, set the <codeph>input</codeph> property 
	 of the corresponding ShaderInput 
	 property of the <codeph>Shader.data</codeph> property.
	 
	 <p>When you pass a Shader instance as an argument the shader is copied internally. The 
	 drawing fill operation uses that internal copy, not a reference to the original shader. Any changes 
	 made to the shader, such as changing a parameter value, input, or bytecode, are not applied 
	 to the copied shader that's used for the fill.</p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>A matrix object (of the flash.geom.Matrix class), which you can use to
	 define transformations on the shader. For example, you can use the following matrix
	 to rotate a shader by 45 degrees (pi/4 radians):
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 <p>The coordinates received in the shader are based on the matrix that is specified
	 for the <codeph>matrix</codeph> parameter. For a default (<codeph>null</codeph>) matrix, the 
	 coordinates in the shader are local pixel coordinates which can be used to sample an 
	 input.</p>
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Specifies a shader fill.
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Specifies a shader fill used by subsequent calls to other Graphics methods
	 (such as <codeph>lineTo()</codeph> or <codeph>drawCircle()</codeph>) for the object.
	 The fill remains in effect until you call the <codeph>beginFill()</codeph>,  
	 <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph>, or <codeph>beginShaderFill()</codeph> method. 
	 Calling the <codeph>clear()</codeph> method clears the fill.
	 
	 <p>The application renders the fill whenever three or more points are drawn, or when 
	 the <codeph>endFill()</codeph> method is called.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:clear"><apiName>clear</apiName><shortdesc>
     Clears the graphics that were drawn to this Graphics object, and resets fill and
     line style settings.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Clears the graphics that were drawn to this Graphics object, and resets fill and
     line style settings.
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:copyFrom"><apiName>copyFrom</apiName><shortdesc>
	 Copies all of drawing commands from the source Graphics object into the 
	 calling Graphics object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceGraphics</apiItemName><apiOperationClassifier>flash.display:Graphics</apiOperationClassifier><apiDesc>The Graphics object from which to copy the drawing commands.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Copies all of drawing commands from the source Graphics object into the 
	 calling Graphics object.
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:curveTo"><apiName>curveTo</apiName><shortdesc>
	 Draws a curve using the current line style from the current drawing position 
	 to (anchorX, anchorY) and using the control point that (controlX, 
	 controlY) specifies.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the horizontal position of the control 
     point relative to the registration point of the parent display object.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the vertical position of the control 
     point relative to the registration point of the parent display object.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the horizontal position of the next anchor 
     point relative to the registration point of the parent display object.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the vertical position of the next anchor 
     point relative to the registration point of the parent display object.  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Draws a curve from the current drawing position 
     to (anchorX, anchorY) using the control point specified by (controlX, controlY).
     
	 
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Draws a curve using the current line style from the current drawing position 
	 to (anchorX, anchorY) and using the control point that (<codeph>controlX</codeph>, 
	 <codeph>controlY</codeph>) specifies. The current drawing position is then set to 
	 (<codeph>anchorX</codeph>, <codeph>anchorY</codeph>). If the movie clip in which you are 
	 drawing contains content created with the Flash drawing tools, calls to the 
	 <codeph>curveTo()</codeph> method are drawn underneath this content. If you call the 
	 <codeph>curveTo()</codeph> method before any calls to the <codeph>moveTo()</codeph> method, 
	 the default of the current drawing position is (0, 0). If any of the parameters are 
	 missing, this method fails and the current drawing position is not changed.
	 
	 <p>The curve drawn is a quadratic Bezier curve. Quadratic Bezier curves 
	 consist of two anchor points and one control point. The curve interpolates the two anchor 
	 points and curves toward the control point. </p>
	 
	 <p><adobeimage alt="quadratic bezier and cubic bezier" href="../../images/quad_bezier.jpg"/></p>
	 
  	 </apiDesc><example conref="examples\Graphics_curveToExample1.as"> The following example draws a green circular object with a width and height of 100
 pixels, 250 pixels to the right from the registration point (0, 0) of Sprite display object. 
 <p>Draw four curves to produce a circle and fill it green.</p>
   
 <p>Note that due to the nature of the quadratic Bezier equation, this is not a perfect circle.
 The best way to draw a circle is to use the Graphics class's <codeph>drawCircle()</codeph> method.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_curveToExample1 extends Sprite
    {
        public function Graphics_curveToExample1():void
        {
            var roundObject:Shape = new Shape();

            roundObject.graphics.beginFill(0x00FF00);
            roundObject.graphics.moveTo(250, 0);
            roundObject.graphics.curveTo(300, 0, 300, 50);
            roundObject.graphics.curveTo(300, 100, 250, 100);
            roundObject.graphics.curveTo(200, 100, 200, 50);
            roundObject.graphics.curveTo(200, 0, 250, 0);
            roundObject.graphics.endFill();
            
            this.addChild(roundObject);
        }
    }
}
</codeblock></example><example conref="examples\Graphics_curveToExample2.as"> The following example draws a new moon using <codeph>curveTo()</codeph> method.
 
 <p>Two curve lines of 1 pixel are drawn and the space in between is filled white. The <codeph>moveTo()</codeph> 
 method is used to position the current drawing position to coordinates (100, 100). The first curve moves the drawing
 position to (100, 200), its destination point. The second curve returns the position back to 
 the starting position (100, 100), its destination point. The horizontal control points determine 
 the different curve sizes.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_curveToExample2 extends Sprite
    {
        public function Graphics_curveToExample2() {
            var newMoon:Shape = new Shape();
            
            newMoon.graphics.lineStyle(1, 0);
            newMoon.graphics.beginFill(0xFFFFFF);
            newMoon.graphics.moveTo(100, 100); 
            newMoon.graphics.curveTo(30, 150, 100, 200);    
            newMoon.graphics.curveTo(50, 150, 100, 100);
            graphics.endFill();
            
            this.addChild(newMoon);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:drawCircle"><apiName>drawCircle</apiName><shortdesc>
	 Draws a circle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>x</i> location of the center of the circle relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>y</i> location of the center of the circle relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>radius</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The radius of the circle (in pixels).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Draws a circle.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Draws a circle. Set the line style, fill, or both before 
	 you call the <codeph>drawCircle()</codeph> method, by calling the <codeph>linestyle()</codeph>, 
	 <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph>, 
	 or <codeph>beginBitmapFill()</codeph> method.
	 
	 </apiDesc><example>Please see the <xref href="Graphics.html#includeExamplesSummary">example</xref> at the end of this 
     class for an illustration of how to use this method. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawEllipse()"><linktext>drawEllipse()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawEllipse"><apiName>drawEllipse</apiName><shortdesc>
	 Draws an ellipse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>x</i> location of the top-left of the bounding-box of the ellipse relative to the 
	registration point of the parent display object (in pixels).
	
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>y</i> location of the top left of the bounding-box of the ellipse relative to the 
	registration point of the parent display object (in pixels).
	
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The width of the ellipse (in pixels).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The height of the ellipse (in pixels).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Draws an ellipse.
         
         </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Draws an ellipse. Set the line style, fill, or both before 
	 you call the <codeph>drawEllipse()</codeph> method, by calling the <codeph>linestyle()</codeph>, 
	 <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph>, 
	 or <codeph>beginBitmapFill()</codeph> method.
	 
	 </apiDesc><example conref="examples\Graphics_drawEllipseExample.as"> The following example uses the function <codeph>drawEgg()</codeph> to draw three different sized eggs 
 (three sizes of ellipses), depending on the <codeph>eggSize</codeph> parameter.  
 <ol>
 <li>The constructor calls the function <codeph>drawEgg()</codeph> and passes the horizontal and vertical parameters for 
 where the egg should be drawn, plus the type of egg (<codeph>eggSize</codeph>). (The height and width of the 
 eggs (the ellipses) can be used to decide where to display them.)</li> 
 <li>Function <codeph>drawEgg()</codeph> draws the different size ellipses and fills them white using 
 <codeph>beginFill()</codeph> method. There is no advance error handling written for his function.</li>
 </ol>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_drawEllipseExample extends Sprite
    {
        public static const SMALL:uint = 0;
        public static const MEDIUM:uint = 1;
        public static const LARGE:uint = 2;

        public function Graphics_drawEllipseExample()
        {
            drawEgg(SMALL, 0, 100);
            drawEgg(MEDIUM, 100, 60);
            drawEgg(LARGE, 250, 35);    
        }

        public function drawEgg(eggSize:uint, x:Number, y:Number):void  {
            
            var myEgg:Shape = new Shape();
            
            myEgg.graphics.beginFill(0xFFFFFF);
            myEgg.graphics.lineStyle(1);

            switch(eggSize) {
                case SMALL:
                    myEgg.graphics.drawEllipse(x, y, 60, 70);
                    break;
                case MEDIUM:
                    myEgg.graphics.drawEllipse(x, y, 120, 150);    
                    break;
                case LARGE:
                    myEgg.graphics.drawEllipse(x, y, 150, 200);
                    break;
                default:
                    trace ("Wrong size! There is no egg.");
                break;            
            }
            
            myEgg.graphics.endFill();
    
            this.addChild(myEgg);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawCircle()"><linktext>drawCircle()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawGraphicsData"><apiName>drawGraphicsData</apiName><shortdesc>
	 Submits a series of IGraphicsData instances for drawing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>graphicsData</apiItemName><apiType value="Vector$flash.display:IGraphicsData"/><apiDesc>A Vector containing graphics objects, each of which much implement the IGraphicsData interface.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Submits a series of IGraphicsData instances for drawing. This method accepts a Vector containing objects
	 including paths, fills, and strokes 
	 that implement the IGraphicsData interface. A  
	 Vector of IGraphicsData instances can refer to a part of a shape, or a complex fully defined 
	 set of data for rendering a complete shape.
     
     
     <p>
     Graphics paths can contain other graphics paths. If the <codeph>graphicsData</codeph> Vector 
     includes a path, that path and all its sub-paths are rendered during this operation.
     </p>
     
     </apiDesc><example conref="examples\Graphics_DrawGraphicsDataExample.as"> The following example creates a GraphicsGradientFill object to establish the fill properties
 for a square. Then, the example creates a GraphicsStroke object (for the line thickness) class and a GraphicsSolidFill
 object (for the line color) to set the properties for the border line of the square. The example then creates a 
 GraphicsPath object to contain the values for drawing the shape. All of these objects are stored in an IGraphicsData object,
 and passed to the <codeph>drawGraphicsData()</codeph> command to render the shape.
<codeblock>
package{
    import flash.display.*;
    import flash.geom.*;
    
    public class DrawGraphicsDataExample extends Sprite {

    public function DrawGraphicsDataExample(){    

    // establish the fill properties
    var myFill:GraphicsGradientFill = new GraphicsGradientFill();
    myFill.colors = [0xEEFFEE, 0x0000FF];
    myFill.matrix = new Matrix();
    myFill.matrix.createGradientBox(100, 100, 0);
 
    // establish the stroke properties
    var myStroke:GraphicsStroke = new GraphicsStroke(2);
    myStroke.fill = new GraphicsSolidFill(0x000000);
 
    // establish the path properties
    var myPath:GraphicsPath = new GraphicsPath(new Vector.&lt;int&gt;(), new Vector.&lt;Number&gt;());
    myPath.commands.push(1,2,2,2,2);
    myPath.data.push(10,10, 10,100, 100,100, 100,10, 10,10);
 
    // populate the IGraphicsData Vector array
    var myDrawing:Vector.&lt;IGraphicsData&gt; = new Vector.&lt;IGraphicsData&gt;();
    myDrawing.push(myFill, myStroke, myPath);
 
    // render the drawing 
    graphics.drawGraphicsData(myDrawing);
    }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#IGraphicsData"><linktext>flash.display.IGraphicsData</linktext></link><link href="flash.display.xml#GraphicsBitmapFill"><linktext>flash.display.GraphicsBitmapFill</linktext></link><link href="flash.display.xml#GraphicsEndFill"><linktext>flash.display.GraphicsEndFill</linktext></link><link href="flash.display.xml#GraphicsGradientFill"><linktext>flash.display.GraphicsGradientFill</linktext></link><link href="flash.display.xml#GraphicsPath"><linktext>flash.display.GraphicsPath</linktext></link><link href="flash.display.xml#GraphicsShaderFill"><linktext>flash.display.GraphicsShaderFill</linktext></link><link href="flash.display.xml#GraphicsSolidFill"><linktext>flash.display.GraphicsSolidFill</linktext></link><link href="flash.display.xml#GraphicsStroke"><linktext>flash.display.GraphicsStroke</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawPath"><apiName>drawPath</apiName><shortdesc>
	 Submits a series of commands for drawing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiDesc>A Vector of integers representing commands defined by the GraphicsPathCommand class. The
     GraphicsPathCommand class maps commands to numeric identifiers for this vector array.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiDesc>A Vector of Numbers where each pair of numbers is treated as a coordinate location (an x, y pair).
     The x- and y-coordinate value pairs are not Point objects; the <codeph>data</codeph> vector is 
	 a series of numbers where each group of two numbers represents a coordinate location. 
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Specifies the winding rule using a value defined in the GraphicsPathWinding class.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Submits a series of commands for drawing. The <codeph>drawPath()</codeph> method uses vector arrays to consolidate
	 individual <codeph>moveTo()</codeph>, <codeph>lineTo()</codeph>, and <codeph>curveTo()</codeph> drawing commands
	 into a single call. The <codeph>drawPath()</codeph> method parameters combine drawing commands with x- and y-coordinate
	 value pairs and a drawing direction. The drawing commands are values from the GraphicsPathCommand class. The
	 x- and y-coordinate value pairs are Numbers in an array where each pair defines a coordinate location. The drawing
	 direction is a value from the GraphicsPathWinding class.
     
	 <p>
	 Generally, drawings render faster with <codeph>drawPath()</codeph> than with
	 a series of individual <codeph>lineTo()</codeph> and <codeph>curveTo()</codeph> methods. 
	 </p>
     
	 <p>
     The <codeph>drawPath()</codeph> method uses a uses a floating computation so rotation and scaling 
     of shapes is more accurate and gives better results. However, curves submitted using the
     <codeph>drawPath()</codeph> method can have small sub-pixel alignment errors when used in conjunction 
     with the <codeph>lineTo()</codeph> and <codeph>curveTo()</codeph> methods.
     </p>
     
	 <p>
	 The <codeph>drawPath()</codeph> method also uses slightly different rules for filling and drawing lines.
     They are:
     </p>
     
	 <ul>
     <li>When a fill is applied to rendering a path:
	  <ul>
          <li>A sub-path of less than 3 points is not rendered. (But note that the stroke rendering will 
              still occur, consistent with the rules for strokes below.)</li>
	      <li>A sub-path that isn't closed (the end point is not equal to the begin point) is implicitly 
              closed.</li>
	   </ul>
     </li>
     <li>When a stroke is applied to rendering a path:
       <ul>
	     <li>The sub-paths can be composed of any number of points.</li>
	     <li>The sub-path is never implicitly closed.</li>
        </ul>
     </li>
     </ul>
     
     </apiDesc><example conref="examples\Graphics_DrawPathExample.as"> The following example populates two Vector objects, then passes them to the
 <codeph>drawPath()</codeph> method to render a blue star. The first Vector, <codeph>star_commands</codeph>, contains a series of
 integers representing drawing commands from the flash.display.GraphicsPathCommand class,
 where the value 1 is a <codeph>MoveTo()</codeph> command and the value 2 is a <codeph>LineTo()</codeph>
 command. The second Vector, <codeph>star_coord</codeph>, contains 5 sets of x- and y-coordinate pairs.
 The <codeph>drawPath()</codeph> method matches the commands with the positions to draw a star.
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {

    public function DrawPathExample(){

    var star_commands:Vector.&lt;int&gt; = new Vector.&lt;int&gt;(5, true);
    
    star_commands[0] = 1;
    star_commands[1] = 2;
    star_commands[2] = 2;
    star_commands[3] = 2;
    star_commands[4] = 2;

    var star_coord:Vector.&lt;Number&gt; = new Vector.&lt;Number&gt;(10, true);
    star_coord[0] = 66; //x
    star_coord[1] = 10; //y 
    star_coord[2] = 23; 
    star_coord[3] = 127; 
    star_coord[4] = 122; 
    star_coord[5] = 50; 
    star_coord[6] = 10; 
    star_coord[7] = 49; 
    star_coord[8] = 109; 
    star_coord[9] = 127;


    graphics.beginFill(0x003366);
    graphics.drawPath(star_commands, star_coord);

    }

    }
}

</codeblock></example><example conref="examples\Graphics_DrawPathExample2.as"> In the above example, each command and coordinate pair is assigned individually to show their position in the array,
 but they can be assigned in a single statement. The following example draws the same star by assigning the values for each array in a single
 <codeph>push()</codeph> statement:
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {
    public function DrawPathExample(){
        var star_commands:Vector.&lt;int&gt; = new Vector.&lt;int&gt;();
        star_commands.push(1, 2, 2, 2, 2);

           var star_coord:Vector.&lt;Number&gt; = new Vector.&lt;Number&gt;();
           star_coord.push(66,10, 23,127, 122,50, 10,49, 109,127);

        graphics.beginFill(0x003366);
        graphics.drawPath(star_commands, star_coord);
    }
    }
}


</codeblock> <b>Note:</b> By default, the <codeph>drawPath()</codeph> method uses the even-odd winding type. So,
 the center of the star is not filled. Specify the non-zero winding type for the third parameter
 and it fills the center of the star:
 <codeblock>
 graphics.drawPath(star_commands, star_coord, GraphicsPathWinding.NON_ZERO);
 </codeblock>
 
</example></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRect"><apiName>drawRect</apiName><shortdesc>
	 Draws a rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>width</codeph> or <codeph>height</codeph> parameters 
	 are not a number (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number indicating the horizontal position relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number indicating the vertical position relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The width of the rectangle (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The height of the rectangle (in pixels).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Draws a round rectangle.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Draws a rectangle. Set the line style, fill, or both before 
	 you call the <codeph>drawRect()</codeph> method, by calling the <codeph>linestyle()</codeph>, 
	 <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph>, 
	 or <codeph>beginBitmapFill()</codeph> method.
	 
	 </apiDesc><example>Please see the <xref href="Graphics.html#includeExamplesSummary">example</xref> at the end of this 
     class for an illustration of how to use this method. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRoundRect()"><linktext>drawRoundRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRoundRect"><apiName>drawRoundRect</apiName><shortdesc>
	 Draws a rounded rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>width</codeph>, <codeph>height</codeph>, <codeph>ellipseWidth</codeph> 
     or <codeph>ellipseHeight</codeph> parameters are not a number (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number indicating the horizontal position relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number indicating the vertical position relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The width of the round rectangle (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The height of the round rectangle (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The width of the ellipse used to draw the rounded corners (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>The height of the ellipse used to draw the rounded corners (in pixels). 
     Optional; if no value is specified, the default value matches that provided for the 
     <codeph>ellipseWidth</codeph> parameter.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Draws a round rectangle.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Draws a rounded rectangle. Set the line style, fill, or both before 
	 you call the <codeph>drawRoundRect()</codeph> method, by calling the <codeph>linestyle()</codeph>, 
	 <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph>, or 
	 <codeph>beginBitmapFill()</codeph> method.
	 
	 </apiDesc><example>Please see the <xref href="Graphics.html#includeExamplesSummary">example</xref> at the end of this 
     class for an illustration of how to use this method. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRect()"><linktext>drawRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawTriangles"><apiName>drawTriangles</apiName><shortdesc>
	 Renders a set of triangles, typically to distort bitmaps and give them a three-dimensional appearance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiDesc>A Vector of Numbers where each pair of numbers is treated as a coordinate location (an x, y pair). The
     <codeph>vertices</codeph> parameter is required.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>A Vector of integers or indexes, where every three indexes define a triangle. If the <codeph>indexes</codeph> parameter
     is null then every three vertices (six x,y pairs in the <codeph>vertices</codeph> Vector) defines a triangle. 
     Otherwise each index refers to a vertex, which is a pair of numbers in the <codeph>vertices</codeph> Vector. 
     For example <codeph>indexes[1]</codeph> refers to (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>).
     The <codeph>indexes</codeph> parameter is optional, but indexes generally reduce the amount of data submitted
     and the amount of data computed. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>A Vector of normalized coordinates used to apply texture mapping.
     Each coordinate refers to a point on the bitmap used for the fill. 
     You must have one UV or one UVT coordinate per vertex.
     In UV coordinates, (0,0) is the upper left of the bitmap, and (1,1) is the lower right of the bitmap. 
     <p>If the length of this vector is twice the length of the <codeph>vertices</codeph> vector then normalized 
     coordinates are used without perspective correction. </p>
     <p>If the length of this vector is three times the length of the <codeph>vertices</codeph> vector then the 
     third coordinate is interpreted as 't' (the distance from the eye to the texture in eye space). 
     This helps the rendering engine correctly apply perspective when mapping textures in three dimensions.</p>
     <p>If the <codeph>uvtData</codeph> parameter is null, then normal fill rules (and any fill type) apply.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Specifies whether to render triangles that face in a specified direction. This parameter prevents
     the rendering of triangles that cannot be seen in the current view. 
     This parameter can be set to any value defined by the TriangleCulling class. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renders a set of triangles, typically to distort bitmaps and give them a three-dimensional appearance. The
	 <codeph>drawTriangles()</codeph> method maps either the current fill, or a bitmap fill, to the 
     triangle faces using a set of (u,v) coordinates. 
     <p>
     Any type of fill can be used, but if the fill has a transform matrix that 
     transform matrix is ignored.
     </p>
     
     <p>
     A <codeph>uvtData</codeph> parameter improves texture mapping when a bitmap fill is used. 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:endFill"><apiName>endFill</apiName><shortdesc>
	 Applies a fill to the lines and curves that were added since the last call to the 
	 beginFill(), beginGradientFill(), or 
	 beginBitmapFill() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a square with red fill on the Stage:
	 
	 <listing>
	 this.createEmptyMovieClip("square_mc", this.getNextHighestDepth());
	 square_mc.beginFill(0xFF0000);
	 square_mc.moveTo(10, 10);
	 square_mc.lineTo(100, 10);
	 square_mc.lineTo(100, 100);
	 square_mc.lineTo(10, 100);
	 square_mc.lineTo(10, 10);
	 square_mc.endFill();
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Applies a fill to the lines and curves.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Applies a fill to the lines and curves that were added since the last call to the 
	 <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph>, or 
	 <codeph>beginBitmapFill()</codeph> method. Flash uses the fill that was specified in the previous 
	 call to the <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph>, or <codeph>beginBitmapFill()</codeph>
	 method. If the current drawing position does not equal the previous position specified in a 
	 <codeph>moveTo()</codeph> method and a fill is defined, the path is closed with a line and then 
	 filled.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineBitmapStyle"><apiName>lineBitmapStyle</apiName><shortdesc>
	 Specifies a bitmap to use for the line stroke when drawing lines.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The bitmap to use for the line stroke.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>An optional transformation matrix as defined by the flash.geom.Matrix class.
                   The matrix can be used to scale or otherwise manipulate the bitmap before 
                   applying it to the line style.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Whether to repeat the bitmap in a tiled fashion.
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Whether smoothing should be applied to the bitmap.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Specifies a bitmap to use for the line stroke when drawing lines. 
     
     <p>The bitmap line style is used for subsequent calls to Graphics 
     methods such as the <codeph>lineTo()</codeph> method or the <codeph>drawCircle()</codeph> method.
     The line style remains in effect until you call the <codeph>lineStyle()</codeph> or 
     <codeph>lineGradientStyle()</codeph> methods, or the <codeph>lineBitmapStyle()</codeph> method 
     again with different parameters. </p>
     
     <p>You can call the <codeph>lineBitmapStyle()</codeph> method in the middle of drawing a path 
     to specify different styles for different line segments within a path. </p>
     
     <p>Call the <codeph>lineStyle()</codeph> method before you call the
     <codeph>lineBitmapStyle()</codeph> method to enable a stroke, or else the value of the line style  
     is <codeph>undefined</codeph>.</p>
     
     <p>Calls to the <codeph>clear()</codeph> method set the line style back to <codeph>undefined</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineGradientStyle"><apiName>lineGradientStyle</apiName><shortdesc>
	 Specifies a gradient to use for the stroke when drawing lines.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>A value from the GradientType class that 
	 specifies which gradient type to use, either GradientType.LINEAR or GradientType.RADIAL.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of RGB hex color values to be used in the gradient (for example, 
	 red is 0xFF0000, blue is 0x0000FF, and so on).
	 
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of alpha values for the corresponding colors in the colors array; 
     valid values are 0 to 1. If the value is less than 0, the default is 0. If the value is 
     greater than 1, the default is 1.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>An array of color distribution ratios; valid values are from 0 to 255. This value 
	 defines the percentage of the width where the color is sampled at 100%. The value 0 represents 
	 the left position in the gradient box, and 255 represents the right position in the 
	 gradient box. This value represents positions in the gradient box, not the 
	 coordinate space of the final gradient, which can be wider or thinner than the gradient box. 
	 Specify a value for each value in the <codeph>colors</codeph> parameter. 
	 
	 <p>For example, for a linear gradient that includes two colors, blue and green, the 
	 following figure illustrates the placement of the colors in the gradient based on different values
	 in the <codeph>ratios</codeph> array:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Gradient</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 0 and 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 0 and 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="linear gradient blue to green with ratios 127 and 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>The values in the array must increase, sequentially; for example, 
	 <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
   	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>A transformation matrix as defined by the 
	 flash.geom.Matrix class. The flash.geom.Matrix class includes a 
	 <codeph>createGradientBox()</codeph> method, which lets you conveniently set up 
	 the matrix for use with the <codeph>lineGradientStyle()</codeph> method.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>A value from the SpreadMethod class that 
	 specifies which spread method to use: 
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="3"><tbody><row><entry align="center"><adobeimage alt="linear gradient with SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>
      <entry align="center"><adobeimage alt="linear gradient with SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>
      <entry align="center"><adobeimage alt="linear gradient with SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>A value from the InterpolationMethod class that 
	 specifies which value to use. For example, consider a simple linear gradient between two colors (with the <codeph>spreadMethod</codeph> 
	 parameter set to <codeph>SpreadMethod.REFLECT</codeph>). The different interpolation methods affect 
	 the appearance as follows:
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="linear gradient with InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="linear gradient with InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>A number that controls the location of the focal
	 point of the gradient. The value 0 means the focal point is in the center. The value 1 means the focal  	
	 point is at one border of the gradient circle. The value -1 means that the focal point is 
   	 at the other border of the gradient circle. Values less than -1 or greater than 1 are
	 rounded to -1 or 1. The following image shows a gradient with a
   	 <codeph>focalPointRatio</codeph> of -0.75:
   	 
     <p><adobeimage alt="radial gradient with focalPointRatio set to 0.75" href="../../images/radial_sketch.jpg"/> </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Specifies a gradient to use for the stroke when drawing lines.
     
     <p>The gradient line style is used for subsequent calls to Graphics 
     methods such as the <codeph>lineTo()</codeph> methods or the <codeph>drawCircle()</codeph> method.
     The line style remains in effect until you call the <codeph>lineStyle()</codeph> or 
     <codeph>lineBitmapStyle()</codeph> methods, or the <codeph>lineGradientStyle()</codeph> method 
     again with different parameters. </p>
     
     <p>You can call the <codeph>lineGradientStyle()</codeph> method in the middle of drawing a path 
     to specify different styles for different line segments within a path. </p>
     
     <p>Call the <codeph>lineStyle()</codeph> method before you call the
     <codeph>lineGradientStyle()</codeph> method to enable a stroke, or else the value of the line style  
     is <codeph>undefined</codeph>.</p>
     
     <p>Calls to the <codeph>clear()</codeph> method set the line style back to <codeph>undefined</codeph>.
     </p>
	 
	 </apiDesc><example conref="examples\Graphics_lineGradientStyleExample.as"> The following example draws a rectangle and a circle that use 
 a gradient stroke from red to green to blue.
 
 <p>The method <codeph>createGradientBox()</codeph> from the <codeph>Matrix</codeph> class is used to define the 
 gradient box to 200 width and 40 height. The thickness of line is set to 5 pixels. Thickness of the stroke
 must be defined for <codeph>lineGradientStyle()</codeph> method. The gradient is set to linear. Colors for the
 gradient are set to red, green, and blue. Transparency (alpha value) for the colors is set to 1 (opaque). 
 The distribution of gradient is even, where the colors are sampled at 100% at 0 (left-hand position in the 
 gradient box), 128 (middle in the box) and 255 (right-hand position in the box). The width of the rectangle 
 encompasses all the spectrum of the gradient, while the circle encompasses 50% from the middle of the spectrum.</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    import flash.geom.Matrix; 
    import flash.display.GradientType;
    
    public class Graphics_lineGradientStyleExample extends Sprite
    {
        public function Graphics_lineGradientStyleExample()
        {
            var myShape:Shape = new Shape();
            var gradientBoxMatrix:Matrix = new Matrix();
  
            gradientBoxMatrix.createGradientBox(200, 40, 0, 0, 0);  
            
            myShape.graphics.lineStyle(5);
  
            myShape.graphics.lineGradientStyle(GradientType.LINEAR, [0xFF0000,
            0x00FF00, 0x0000FF], [1, 1, 1], [0, 128, 255], gradientBoxMatrix);
            
            myShape.graphics.drawRect(0, 0, 200, 40);
            myShape.graphics.drawCircle(100, 120, 50);  
             
            this.addChild(myShape);
    
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineShaderStyle"><apiName>lineShaderStyle</apiName><shortdesc>
	 Specifies a shader to use for the line stroke when drawing lines.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>The shader to use for the line stroke.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>An optional transformation matrix as defined by the flash.geom.Matrix class.
                   The matrix can be used to scale or otherwise manipulate the bitmap before 
                   applying it to the line style.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Specifies a shader to use for the line stroke when drawing lines. 
     
     <p>The shader line style is used for subsequent calls to Graphics 
     methods such as the <codeph>lineTo()</codeph> method or the <codeph>drawCircle()</codeph> method.
     The line style remains in effect until you call the <codeph>lineStyle()</codeph> or 
     <codeph>lineGradientStyle()</codeph> methods, or the <codeph>lineBitmapStyle()</codeph> method 
     again with different parameters. </p>
     
     <p>You can call the <codeph>lineShaderStyle()</codeph> method in the middle of drawing a path 
     to specify different styles for different line segments within a path. </p>
     
     <p>Call the <codeph>lineStyle()</codeph> method before you call the
     <codeph>lineShaderStyle()</codeph> method to enable a stroke, or else the value of the line style  
     is <codeph>undefined</codeph>.</p>
     
     <p>Calls to the <codeph>clear()</codeph> method set the line style back to <codeph>undefined</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineStyle"><apiName>lineStyle</apiName><shortdesc>
     Specifies a line style used for subsequent calls to 
	 Graphics methods such as the lineTo() method or the drawCircle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following code draws a triangle with a 5-pixel, solid magenta line with 
	 no fill, with pixel hinting, no stroke scaling, no caps, and miter joints with 
	 <code>miterLimit</code> set to 1:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", this.getNextHighestDepth());
	 triangle_mc.lineStyle(5, 0xff00ff, 100, true, "none", "round", "miter", 1);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 </listing>
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>An integer that indicates the thickness of the line in 
     points; valid values are 0-255. If a number is not specified, or if the 
     parameter is undefined, a line is not drawn. If a value of less than 0 is passed, 
     the default is 0. The value 0 indicates hairline thickness; the maximum thickness 
     is 255. If a value greater than 255 is passed, the default is 255. 
     
     </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>A hexadecimal color value of the line; for example, red is 0xFF0000, blue is 
	 0x0000FF, and so on. If a value is not indicated, the default is 0x000000 (black). Optional.
	 
 	 
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>A number that indicates the alpha value of the color of the line; 
     valid values are 0 to 1. If a value is not indicated, the default is 1 (solid). If 
     the value is less than 0, the default is 0. If the value is greater than 1, the default is 1. 
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>A Boolean value that specifies whether to hint strokes 
	 to full pixels. This affects both the position of anchors of a curve and the line stroke size 
	 itself. With <codeph>pixelHinting</codeph> set to <codeph>true</codeph>, line widths are adjusted  
	 to full pixel widths. With <codeph>pixelHinting</codeph> set to <codeph>false</codeph>, disjoints can 
	 appear for curves and straight lines. For example, the following illustrations show how 
	 Flash Player or Adobe AIR renders two rounded rectangles that are identical, except that the 
	 <codeph>pixelHinting</codeph> parameter used in the <codeph>lineStyle()</codeph> method is set 
	 differently (the images are scaled by 200%, to emphasize the difference):
	 
	 <p><adobeimage alt="pixelHinting false and pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
	 
	 <p>If a value is not supplied, the line does not use pixel hinting.</p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>A value from the LineScaleMode class that 
	 specifies which scale mode to use:
	 
	 <ul>
	 
	 <li>
	 <codeph>LineScaleMode.NORMAL</codeph>—Always scale the line thickness when the object is scaled 
	 (the default).
	 </li>
	 
	 <li>
	 <codeph>LineScaleMode.NONE</codeph>—Never scale the line thickness.
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.VERTICAL</codeph>—Do not scale the line thickness if the object is scaled vertically 
	 <i>only</i>. For example, consider the following circles, drawn with a one-pixel line, and each with the 
	 <codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.VERTICAL</codeph>. The circle on the left 
	 is scaled vertically only, and the circle on the right is scaled both vertically and horizontally:
	 
     <p><adobeimage alt="A circle scaled vertically, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	 
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.HORIZONTAL</codeph>—Do not scale the line thickness if the object is scaled horizontally 
	 <i>only</i>. For example, consider the following circles, drawn with a one-pixel line, and each with the 
	 <codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.HORIZONTAL</codeph>. The circle on the left 
	 is scaled horizontally only, and the circle on the right is scaled both vertically and horizontally:
	 
     <p><adobeimage alt="A circle scaled horizontally, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	 
	 </li>
	 
	 
	 </ul>
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>A value from the CapsStyle class that specifies the type of caps at the end 
	 of lines. Valid values are: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph>, and <codeph>CapsStyle.SQUARE</codeph>. 
	 If a value is not indicated, Flash uses round caps. 
	 <p>For example, the following illustrations show the different <codeph>capsStyle</codeph> 
	 settings. For each setting, the illustration shows a blue line with a thickness of 30 (for 
	 which the <codeph>capsStyle</codeph> applies), and a superimposed black line with a thickness of 1 
	 (for which no <codeph>capsStyle</codeph> applies):
	 </p>
	 <p><adobeimage alt="NONE, ROUND, and SQUARE" href="../../images/linecap.jpg"/></p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>A value from the JointStyle class that specifies the type of joint appearance
	 used at angles. Valid 
	 values are: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph>, and <codeph>JointStyle.ROUND</codeph>.
	 If a value is not indicated, Flash uses round joints. 
	 
	 <p>For example, the following illustrations show the different <codeph>joints</codeph> 
	 settings. For each setting, the illustration shows an angled blue line with a thickness of 
	 30 (for which the <codeph>jointStyle</codeph> applies), and a superimposed angled black line with a 
	 thickness of 1 (for which no <codeph>jointStyle</codeph> applies):
	 </p>
	 
     <p><adobeimage alt="MITER, ROUND, and BEVEL" href="../../images/linejoin.jpg"/></p>
	 
	 <p><b>Note:</b> For <codeph>joints</codeph> set to <codeph>JointStyle.MITER</codeph>, 
	 you can use the <codeph>miterLimit</codeph> parameter to limit the length of the miter.</p>
 	 
	 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3</apiData><apiDesc>A number that indicates the limit at which a miter is cut off. 
	 Valid values range from 1 to 255 (and values outside that range are rounded to 1 or 255). 
	 This value is only used if the <codeph>jointStyle</codeph> 
	 is set to <codeph>"miter"</codeph>. The 
	 <codeph>miterLimit</codeph> value represents the length that a miter can extend beyond the point
	 at which the lines meet to form a joint. The value expresses a factor of the line
	 <codeph>thickness</codeph>. For example, with a <codeph>miterLimit</codeph> factor of 2.5 and a 
	 <codeph>thickness</codeph> of 10 pixels, the miter is cut off at 25 pixels. 
	 
	 <p>For example, consider the following angled lines, each drawn with a <codeph>thickness</codeph> 
	 of 20, but with <codeph>miterLimit</codeph> set to 1, 2, and 4. Superimposed are black reference
	 lines showing the meeting points of the joints:</p>
	 
     <p><adobeimage alt="lines with miterLimit set to 1, 2, and 4" href="../../images/miterLimit.jpg"/></p>
	 
	 <p>Notice that a given <codeph>miterLimit</codeph> value has a specific maximum angle 
	 for which the miter is cut off. The following table lists some examples:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> value:</entry><entry>Angles smaller than this are cut off:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 degrees</entry></row><row><entry>2</entry>      <entry>60 degrees</entry></row><row><entry>4</entry>      <entry>30 degrees</entry></row><row><entry>8</entry>      <entry>15 degrees</entry></row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Specifies a line style that Flash uses for drawing lines.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Specifies a line style used for subsequent calls to 
	 Graphics methods such as the <codeph>lineTo()</codeph> method or the <codeph>drawCircle()</codeph> method. 
	 The line style remains in effect until you call the <codeph>lineGradientStyle()</codeph> 
	 method, the <codeph>lineBitmapStyle()</codeph> method, or the <codeph>lineStyle()</codeph> method with different parameters. 
     
     <p>You can call the <codeph>lineStyle()</codeph> method in the middle of drawing a path to specify different 
	 styles for different line segments within the path.</p> 
	 
	 <p><b>Note: </b>Calls to the <codeph>clear()</codeph> method set the line style back to 
	 <codeph>undefined</codeph>.</p>
     
	 </apiDesc><example>Please see the <xref href="Graphics.html#lineTo()">lineTo()</xref> or <xref href="Graphics.html#moveTo()">moveTo()</xref> 
     method's example for illustrations of how to use the <codeph>getStyle()</codeph> method. 
     
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineBitmapStyle"><linktext>lineBitmapStyle</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle"><linktext>lineGradientStyle</linktext></link><link href="flash.display.xml#LineScaleMode"><linktext>LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>JointStyle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineTo"><apiName>lineTo</apiName><shortdesc>
	 Draws a line using the current line style from the current drawing position to (x, y); 
	 the current drawing position is then set to (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill.
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that indicates the horizontal position relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that indicates the vertical position relative to the 
     registration point of the parent display object (in pixels).
     
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Draws a line from the current drawing position to (x, y).
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Draws a line using the current line style from the current drawing position to (<codeph>x</codeph>, <codeph>y</codeph>); 
	 the current drawing position is then set to (<codeph>x</codeph>, <codeph>y</codeph>).
	 If the display object in which you are drawing contains content that was created with 
	 the Flash drawing tools, calls to the <codeph>lineTo()</codeph> method are drawn underneath the content. If 
	 you call <codeph>lineTo()</codeph> before any calls to the <codeph>moveTo()</codeph> method, the 
	 default position for the current drawing is (<i>0, 0</i>). If any of the parameters are missing, this 
	 method fails and the current drawing position is not changed.
	 
	 </apiDesc><example conref="examples\Graphics_lineToExample.as"> The following example draws a trapezoid using <codeph>lineTo()</codeph> method, starting at
 pixels (100, 100). 
 <p>The line thickness is set to 10 pixels, color is gold and opaque, caps at the end of lines
 is set to none (since all lines are jointed), and the joint between the lines is set to 
 <codeph>MITER</codeph> with miter limit set to 10, to have sharp, pointed corners.</p>     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.LineScaleMode;
    import flash.display.CapsStyle;
    import flash.display.JointStyle;
    import flash.display.Shape;


    public class Graphics_lineToExample extends Sprite {

        public function Graphics_lineToExample() {

            var trapezoid:Shape = new Shape();    

            trapezoid.graphics.lineStyle(10, 0xFFD700, 1, false, LineScaleMode.VERTICAL,
                               CapsStyle.NONE, JointStyle.MITER, 10);

            trapezoid.graphics.moveTo(100, 100);
 
            trapezoid.graphics.lineTo(120, 50);
            trapezoid.graphics.lineTo(200, 50);
            trapezoid.graphics.lineTo(220, 100);
            trapezoid.graphics.lineTo(100, 100); 

            this.addChild(trapezoid);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:moveTo"><apiName>moveTo</apiName><shortdesc>
     Moves the current drawing position to (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
	 
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that indicates the horizontal position relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that indicates the vertical position relative to the 
     registration point of the parent display object (in pixels).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Moves the current drawing position to (x, y).
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Moves the current drawing position to (<codeph>x</codeph>, <codeph>y</codeph>). If any of the parameters 
     are missing, this method fails and the current drawing position is not changed.
     
	 </apiDesc><example conref="examples\Graphics_moveToExample.as"> The following example draws a dashed line of three pixels thickness
 using <codeph>moveTo()</codeph> and <codeph>lineTo()</codeph> methods.
 
 <p>Using the <codeph>lineStyle()</codeph> method, the line thickness is set to 3 pixels. It is also set not
 to scale. Color is set to red with 25 percent opacity. The <codeph>CapsStyle</codeph> property is set to 
 square (the default is round).</p>
 
 <p>Since <codeph>Graphics_moveToExample</codeph> is an instance of the <codeph>Sprite</codeph> class, it has access 
 to all the Graphics class methods. The Graphics class methods can be used to directly draw on the
 <codeph>Graphic_moveToExample</codeph> Sprite object. However, not putting the vector drawing object in a 
 <codeph>Shape</codeph> limits the way they can be managed, moved, or changed.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.CapsStyle;
    import flash.display.LineScaleMode;

    public class Graphics_moveToExample extends Sprite
    {
        public function Graphics_moveToExample() {
            
            graphics.lineStyle(3, 0x990000, 0.25, false, 
                            LineScaleMode.NONE, CapsStyle.SQUARE);

            graphics.moveTo(10, 20);
            graphics.lineTo(20, 20);
            graphics.moveTo(30, 20);
            graphics.lineTo(50, 20);
            graphics.moveTo(60, 20);
            graphics.lineTo(80, 20);
            graphics.moveTo(90, 20);
            graphics.lineTo(110, 20);            
            graphics.moveTo(120, 20);
            graphics.lineTo(130, 20);           
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.display:NativeWindowType"><apiName>NativeWindowType</apiName><shortdesc>
	 The NativeWindowType class defines constants for the type property of the 
	 NativeWindowInitOptions object used to create a native window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 The NativeWindowType class defines constants for the <codeph>type</codeph> property of the 
	 NativeWindowInitOptions object used to create a native window.
	 
	 <p><b>Note:</b> The type value is specified when a window is 
	 created and cannot be changed.</p>
	 	  
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowType:LIGHTWEIGHT"><apiName>LIGHTWEIGHT</apiName><shortdesc>
		 A minimal window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lightweight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 A minimal window.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
		 A typical window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 A typical window.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:UTILITY"><apiName>UTILITY</apiName><shortdesc>
		 A utility window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>utility</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 A utility window.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowDisplayState"><apiName>NativeWindowDisplayState</apiName><shortdesc>
     The NativeWindowDisplayState class defines constants for the names of the window display states.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     The NativeWindowDisplayState class defines constants for the names of the window display states.
     
     <p><b>Note:</b> The fullscreen modes are set using the Stage object <codeph>displayState</codeph> property, 
     not the window <codeph>displaySate</codeph>.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link></related-links><apiValue id="flash.display:NativeWindowDisplayState:MAXIMIZED"><apiName>MAXIMIZED</apiName><shortdesc>
         The maximized display state.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>maximized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         The maximized display state.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:MINIMIZED"><apiName>MINIMIZED</apiName><shortdesc>
         The minimized display state.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>minimized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         The minimized display state.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
         The normal display state.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         The normal display state.
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Screen"><apiName>Screen</apiName><shortdesc>
	 The Screen class provides information about the display screens available to this application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 The Screen class provides information about the display screens available to this application.
	 
	 <p>Screens are independent desktop areas within a possibly larger 
	 "virtual desktop." The origin of the virtual desktop is the top-left corner 
	 of the operating-system-designated main screen. Thus, the coordinates for the 
	 bounds of an individual display screen may be negative. There may also be areas 
	 of the virtual desktop that are not within any of the display screens.</p>
	 
	 <p>The Screen class includes static class members for accessing the available
	 screen objects and instance members for accessing the properties of an
	 individual screen. Screen information should not be cached since
	 it can be changed by a user at any time.</p>
	  
	 <p>Note that there is not necessarily a one-to-one correspondance between
	 screens and the physical monitors attached to a computer. For example, two monitors
	 may display the same screen.</p>
	 
	 <p>You cannot instantiate the Screen class directly. Calls to 
	 the <codeph>new Screen()</codeph> constructor throw an 
	 <codeph>ArgumentError</codeph> exception.</p>
	 
	 </apiDesc><example conref="examples\ScreenExample.as"> The following example defines a DockingWindow class 
 to create a window that docks to the sides of the screen.  
 This task is accomplished by performing the following steps:
 
 <ol>
     <li>Responding to keyboard events to determine the side of the screen on which to 
  dock.</li>
 
    <li>Accessing the static Screen class method <codeph>getScreensForRectangle()</codeph>
  to get the Screen object for the screen upon which the window is currently
  displayed.</li>
 
    <li>Resetting the window bounds based on the screen dimensions.</li>
 
    <li>Redrawing the window content based on the new window dimensions.</li>
 
 </ol>
 
 <p>Note, this class is intended to be used as the root class of an AIR application
 with the settings <codeph>SystemChrome="none"</codeph> and 
 <codeph>transparent="true"</codeph>. To use this class in a window with system
 chrome, you must take the chrome thickness and the minimum width of
 the window into account when calculating window location and size.</p>
<codeblock>

package
{
    import flash.display.Screen;
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.KeyboardEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;

    public class DockingWindow extends Sprite
    {
        private const dockedWidth:uint = 80;
        private const dockedHeight:uint = 80;
        
        public function DockingWindow():void{
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onKey);
            dockLeft();
        }
        
        private function onKey(event:KeyboardEvent):void{
            switch(event.keyCode){
                case Keyboard.LEFT :
                    dockLeft();
                    break;
                case Keyboard.RIGHT :
                    dockRight();
                    break;
                case Keyboard.UP :
                    dockTop();
                    break;
                case Keyboard.DOWN :
                    dockBottom();
                    break;
                case Keyboard.SPACE :
                    stage.nativeWindow.close();
            }    
        }
        
        public function dockLeft():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.height = screen.visibleBounds.height;
            stage.stageWidth = dockedWidth;
            drawContent();
        }
        
        public function dockRight():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.width - dockedWidth;            
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.stageWidth = dockedWidth;
            stage.nativeWindow.height = screen.visibleBounds.height;
            drawContent();
        }
        
        public function dockTop():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;
            drawContent();
        }
        
        public function dockBottom():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.height - dockedHeight;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;    
            drawContent();        
        }
        
        private function getCurrentScreen():Screen{
            return Screen.getScreensForRectangle(stage.nativeWindow.bounds)[0];
        }
        
        private function drawContent():void{
            const size:int = 60;
            const pad:int = 10;
            var numHSquares:int = Math.floor(stage.stageWidth/(size + pad));
            var numVSquares:int = Math.floor(stage.stageHeight/(size + pad));
            with (graphics){
                clear();
                lineStyle(1);
                beginFill(0x3462d5,.7);
                for(var i:int = 0; i &lt; numHSquares; i++){
                    for(var j:int = 0; j &lt; numVSquares; j++){                
                            drawRect((i * (size + pad)) + pad, (j * (size + pad)) + pad, size, size);
                    }
                }
                endFill();
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Screen:getScreensForRectangle"><apiName>getScreensForRectangle</apiName><shortdesc>
		 Returns the (possibly empty) set of screens that intersect 
		 the provided rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An array of Screen objects containing the screens that contain any
 		 part of the area defined by the <codeph>rect</codeph> parameter.
		 
		 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle with coordinates relative to the origin of
		 the virtual desktop, which is the top-left corner of the primary
		 screen.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the (possibly empty) set of screens that intersect 
		 the provided rectangle.
		  
		 </apiDesc><example conref="examples\Screen.getScreensForRectangle.1.as"> The following example shows how to get the array of screens containing
 at least part of a given rectangle:
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var rect:Rectangle = new Rectangle(-200, 100, 1000, 600);
var intersectedScreens:Array = Screen.getScreensForRectangle(rect);
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:Screen:bounds:get"><apiName>bounds</apiName><shortdesc>
		 The bounds of this screen.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 The bounds of this screen.
		 
		 <p>The screen location is relative to the virtual desktop.</p>
		 
		 </apiDesc><example conref="examples\Screen.bounds.1.as"> The following example shows how to get the bounds of a screen 
 (in this case, the primary display screen):
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.bounds;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:colorDepth:get"><apiName>colorDepth</apiName><shortdesc>
		 The color depth of this screen (expressed in number of bits).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 The color depth of this screen (expressed in number of bits).
		 
		 </apiDesc><example conref="examples\Screen.colorDepth.1.as"> The following example shows how to get the color depth of a screen 
 (in this case, the primary display screen):
<codeblock>

var mainScreen:Screen = Screen.mainScreen;
var colors:uint = mainScreen.colorDepth;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:mainScreen:get"><apiName>mainScreen</apiName><shortdesc>
		 The primary display.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Screen</apiValueClassifier></apiValueDef><apiDesc>
		 The primary display.
		 
		 </apiDesc><example conref="examples\Screen.mainScreen.1.as"> The following example shows how to get the Screen object representing the 
 "main" screen of this computer:
<codeblock>

var primaryScreen:Screen = Screen.mainScreen;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:screens:get"><apiName>screens</apiName><shortdesc>
		 The array of the currently available screens.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3."/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 The array of the currently available screens. 
		 
		 <p>Modifying the returned array has no effect on 
		 the available screens.</p>
		 
		 </apiDesc><example conref="examples\Screen.screens.1.as"> The following example shows how to get the array containing the available screens:
<codeblock>

var screenArray:Array = Screen.screens;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:visibleBounds:get"><apiName>visibleBounds</apiName><shortdesc>
		 The bounds of the area on this screen in which windows can be visible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 The bounds of the area on this screen in which windows can be visible.
		 
		 <p>The <codeph>visibleBounds</codeph> of a screen excludes the task bar 
		 (and other docked desk bars) on Windows, and excludes the 
		 menu bar and, depending on system settings, the dock on Mac OS X.
		 On some Linux configurations, it is not possible to determine the visible bounds.
		 In these cases, the <codeph>visibleBounds</codeph> property returns the same
		 value as the <codeph>screenBounds</codeph> property.</p>
		 
		 </apiDesc><example conref="examples\Screen.usableBounds.1.as"> The following example shows how to get the usable bounds of a screen 
 (in this case, the primary display screen):
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.visibleBounds;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Bitmap"><apiName>Bitmap</apiName><shortdesc>
 The Bitmap class represents display objects that represent bitmap images.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Represents display objects that derive from images.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Bitmap class represents display objects that represent bitmap images. These can be images
 that you load with the flash.display.Loader class, or they can be images that you create with
 the <codeph>Bitmap()</codeph> constructor. 
 
 <p>The <codeph>Bitmap()</codeph> constructor allows you to create a Bitmap object that 
 contains a reference to a BitmapData object. After you create a Bitmap object, use the 
 <codeph>addChild()</codeph> or <codeph>addChildAt()</codeph> method of the parent DisplayObjectContainer 
 instance to place the bitmap on the display list.</p>
 
 <p>A Bitmap object can share its BitmapData reference among several Bitmap objects,
 independent of translation or rotation properties. Because you can create multiple Bitmap
 objects that reference the same BitmapData object, multiple display objects can use the
 same complex BitmapData object without incurring the memory overhead of a BitmapData
 object for each display object instance.</p>
 
 <p>A BitmapData object can be drawn to the screen by a Bitmap object in one of two ways:
 by using the vector renderer as a fill-bitmap shape, or by using a faster pixel-copying routine.
 The pixel-copying routine is substantially faster than the vector renderer, but the Bitmap object
 must meet certain conditions to use it:</p>
 
 <ul>
 
 <li> No stretching, rotation, or skewing can be applied to the Bitmap object.</li>
 <li> No color transform can be applied to the Bitmap object. </li>
 <li> No blend mode can be applied to the Bitmap object. </li>
 <li> No clipping can be done through mask layers or <codeph>setMask()</codeph> methods. </li>
 <li> The image itself cannot be a mask. </li>
 <li> The destination coordinates must be on a whole pixel boundary. </li>
 
 </ul>
 
 <p>If you load a Bitmap object from a domain other than that of the Loader object used to
 load the image, and there is no URL policy file that permits access to the domain of
 the Loader object, then a script in that domain cannot access the Bitmap
 object or its properties and methods. For more information, see the following:</p>
 
 <ul>
 
 <li class="flexonly">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref> 
 in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
 <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
 in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
 
 <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
 </ul>
 
 
 <p><b>Note:</b> The Bitmap class is not a subclass of the InteractiveObject class, so
 it cannot dispatch mouse events. However, you can use the <codeph>addEventListener()</codeph> method
 of the display object container that contains the Bitmap object.</p>
 
 </apiDesc><example conref="examples\BitmapExample.as"> The following example uses the BitmapExample class to load the
 "Image.gif" image into a DisplayObject in the default location (<i>x = 0, y = 0</i>). A copy
 of Image.gif is then placed to the right of the original, which has new colors applied to pixels
 that pass a test using the <codeph>threshold()</codeph> method.
 This task is accomplished using the following steps:
 <ol>
  <li>A property <codeph>url</codeph> is created, which is the location and name of the image file</li>
  <li>The class constructor calls the <codeph>configureAssets()</codeph> method, which, in turn, calls the 
  <codeph>completeHandler()</codeph> method.</li>
  <li><codeph>configureAssets()</codeph> creates a Loader object, which then instantiates an event listener,
  which is dispatched when <codeph>completeHandler()</codeph> completes the image manipulation.</li>
  <li>Next, the <codeph>buildChild()</codeph> method creates a new instance of a URLRequest object,
  <codeph>request</codeph>, with <codeph>url</codeph> passed so the file name and location are known.</li>
  <li>The <codeph>request</codeph> object is passed to the <codeph>loader.load()</codeph> method, which loads the image
  into memory via a display object.</li>
  <li>The image is then placed on the display list, which promptly displays the image on screen at
  coordinates <i>x = 0, y = 0</i>.</li>
  <li>The <codeph>completeHandler()</codeph> method then performs the following tasks:
  <ol outputclass="A">
      <li>Creates a second Loader object, along with a Bitmap object, which is initialized with the
      Loader object.</li>
      <li>Creates a second Bitmap object, <codeph>duplicate</codeph>, which in turn calls the
      <codeph>duplicateImage()</codeph> method, which creates a duplicate of the original image. </li>
      <li>Creates a BitmapData object, which is assigned to the <codeph>duplicate</codeph> object's
      BitmapData object.</li>
      <li>Creates a new Rectangle object initialized with the same coordinates, width, and height
      as the original image.</li>
      <li>Creates a new Point object, which defaults to <i>x = 0, y = 0</i>.</li>
      <li>Creates the following variables:
      <ul>
          <li><codeph>operation</codeph>: applies the new color when the threshold
          value is &gt;= the original.</li>
          <li><codeph>threshold</codeph>: the value against which each pixel is compared is set to
          light gray with an alpha of 0xCC. </li>
          <li><codeph>color</codeph>: the color that the pixels will be set to that pass the threshold
          test, which is solid yellow in this case.</li>
          <li><codeph>mask</codeph>: set to the exact opposite of color, (transparent blue).</li>
          <li><codeph>copySource</codeph>: set to false, indicating that the pixel values are not copied
          in the event the threshold value does not pass.  This value has no meaning because
          the image is duplicated and only pixels that pass the threshold test are changed.</li>
      </ul></li>
      <li>Calls the <codeph>threshold()</codeph> method by using the preceding variables.  The resulting threshold
      equation is as follows: <codeph>if (current pixel Value &amp; 0x000000FF) &gt;=
      (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>. </li>
  </ol></li>
 </ol>
 <p> <b>Notes:</b>
 <ul>
  <li>You will need to compile the SWF file with "Local playback security" set to "Access local files only".
 </li>
  <li>This example requires that a file named Image.gif be placed in the same directory as your SWF file.
 </li>
  <li>It is recommended that you use an image up to 80 pixels wide. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiConstructor id="flash.display:Bitmap:Bitmap"><apiName>Bitmap</apiName><shortdesc>
     Initializes a Bitmap object to refer to the specified BitmapData object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>The BitmapData object being referenced. 
     
     </apiDesc></apiParam><apiParam><apiItemName>pixelSnapping</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>auto</apiData><apiDesc>Whether or not the Bitmap object is snapped to the nearest pixel.
     
     </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Whether or not the bitmap is smoothed when scaled. For example, the 
     following examples show the same bitmap scaled by a factor of 3, with 
     <codeph>smoothing</codeph> set to <codeph>false</codeph> (left) and <codeph>true</codeph> (right):
     
     <p>
      <adobetable>
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="A bitmap without smoothing." href="../../images/bitmap_smoothing_off.jpg"/></entry>
      <entry align="center"><adobeimage alt="A bitmap with smoothing." href="../../images/bitmap_smoothing_on.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     </p>
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Initializes a Bitmap object to refer to the specified BitmapData object.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Bitmap:bitmapData:get"><apiName>bitmapData</apiName><shortdesc>
    The BitmapData object being referenced.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
    The BitmapData object being referenced.
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:pixelSnapping:get"><apiName>pixelSnapping</apiName><shortdesc>
    Controls whether or not the Bitmap object is snapped to the nearest pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Controls whether or not the Bitmap object is snapped to the nearest pixel. The PixelSnapping
    class includes possible values:
    
    <ul>
    
      <li><codeph>PixelSnapping.NEVER</codeph>—No pixel snapping occurs.</li>
    
      <li><codeph>PixelSnapping.ALWAYS</codeph>—The image is always snapped to the nearest
    pixel, independent of transformation.</li>
    
      <li><codeph>PixelSnapping.AUTO</codeph>—The image is snapped
    to the nearest pixel if it is drawn with no rotation
    or skew and it is drawn at a scale factor of 99.9% to 100.1%. If these conditions are satisfied,
    the bitmap image is drawn at 100% scale, snapped to the nearest pixel. Internally, this value allows the image
    to be drawn as fast as possible using the vector renderer.</li>
    
    </ul>
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:smoothing:get"><apiName>smoothing</apiName><shortdesc>
    Controls whether or not the bitmap is smoothed when scaled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    Controls whether or not the bitmap is smoothed when scaled. If <codeph>true</codeph>, the bitmap is
    smoothed when scaled. If <codeph>false</codeph>, the bitmap is not smoothed when scaled.
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Scene"><apiName>Scene</apiName><shortdesc>
	The Scene class includes properties for identifying the name, labels, and number of frames 
	in a scene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	The Scene class includes properties for identifying the name, labels, and number of frames 
	in a scene. The MovieClip class includes a <codeph>currentScene</codeph> property, which is 
	a Scene object that identifies the scene in which the playhead is located in the 
	timeline of the MovieClip instance. The <codeph>scenes</codeph> property of the 
	MovieClip class is an array of Scene objects. Also, the <codeph>gotoAndPlay()</codeph> 
	and <codeph>gotoAndStop()</codeph> methods of the MovieClip class use Scene objects as 
	parameters.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:Scene:labels:get"><apiName>labels</apiName><shortdesc>
		An array of FrameLabel objects for the scene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		An array of FrameLabel objects for the scene. Each FrameLabel object contains
		a <codeph>frame</codeph> property, which specifies the frame number corresponding to the 
		label, and a <codeph>name</codeph> property.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:Scene:name:get"><apiName>name</apiName><shortdesc>
		The name of the scene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		The name of the scene.
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Scene:numFrames:get"><apiName>numFrames</apiName><shortdesc>
		The number of frames in the scene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		The number of frames in the scene.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageDisplayState"><apiName>StageDisplayState</apiName><shortdesc>
The StageDisplayState class provides values for the Stage.displayState property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The StageDisplayState class provides values for the <codeph>Stage.displayState</codeph> property. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link></related-links><apiValue id="flash.display:StageDisplayState:FULL_SCREEN"><apiName>FULL_SCREEN</apiName><shortdesc>
Specifies that the Stage is in full-screen mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is in full-screen mode. Keyboard interactivity is disabled in this mode.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:FULL_SCREEN_INTERACTIVE"><apiName>FULL_SCREEN_INTERACTIVE</apiName><shortdesc>
Specifies that the Stage is in full-screen mode with keyboard interactivity enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreenInteractive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is in full-screen mode with keyboard interactivity enabled. 
<ph platform="actionscript">Only AIR applications support this capability.</ph>

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
Specifies that the Stage is in normal mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is in normal mode. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderData"><apiName>ShaderData</apiName><shortdesc>
	 A ShaderData object contains properties representing any parameters and 
	 inputs for a shader kernel, as well as properties containing any metadata 
	 specified for the shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A ShaderData object contains properties representing any parameters and 
	 inputs for a shader kernel, as well as properties containing any metadata 
	 specified for the shader.
	 
	 <p>These properties are added to the ShaderData object when it is created. The properties' 
	 names match the names specified in the shader's source code. The data type of each 
	 property varies according to what aspect of the shader the property represents. The 
	 properties that represent shader parameters are ShaderParameter instances, the properties 
	 that represent input images are ShaderInput instances, and the properties that represent 
	 shader metadata are instances of the ActionScript class corresponding to their data type 
	 (for example, a String instance for textual metadata and a uint for uint metadata).</p>
	 
	 <p>For example, consider this shader, which is defined with one input image (<codeph>src</codeph>), 
	 two parameters (<codeph>size</codeph> and <codeph>radius</codeph>), and three metadata values 
	 (<codeph>nameSpace</codeph>, <codeph>version</codeph>, and <codeph>description</codeph>):</p>
	 
	 <codeblock>
	 &lt;languageVersion : 1.0;&gt;
	 
	 kernel DoNothing
	 &lt;
	     namespace: "Adobe::Example";
	     vendor: "Adobe examples";
	     version: 1;
	     description: "A shader that does nothing, but does it well.";
	 &gt;
	 {
	     input image4 src;
	 
	     output pixel4 dst;
	     
	     parameter float2 size
	     &lt;
	         description: "The size of the image to which the kernel is applied";
	         minValue: float2(0.0, 0.0);
	         maxValue: float2(100.0, 100.0);
	         defaultValue: float2(50.0, 50.0);
	     &gt;;
	     
	     parameter float radius
	     &lt;
	         description: "The radius of the effect";
	         minValue: 0.0;
	         maxValue: 50.0;
	         defaultValue: 25.0;
	     &gt;;
	 
	     void evaluatePixel()
	     {
	         float2 one = (radius / radius) ∗ (size / size);
	         dst = sampleNearest(src, outCoord());
	     }
	 }
	 </codeblock>
	 
	 <p>If you create a Shader instance by loading the byte code for this shader, the ShaderData 
	 instance in its <codeph>data</codeph> property contains these properties:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Property</entry><entry>Data type</entry><entry>Value</entry></row></thead><tbody><row>
	   <entry>name</entry>
	   <entry>String</entry>
	   <entry>"DoNothing"</entry>
	 </row><row>
	   <entry>nameSpace</entry>
	   <entry>String</entry>
	   <entry>"Adobe::Example"</entry>
	 </row><row>
	   <entry>version</entry>
	   <entry>String</entry>
	   <entry>"1"</entry>
	 </row><row>
	   <entry>description</entry>
	   <entry>String</entry>
	   <entry>"A shader that does nothing, but does it well."</entry>
	 </row><row>
	   <entry>src</entry>
	   <entry>ShaderInput</entry>
	   <entry><i>[A ShaderInput instance]</i></entry>
	 </row><row>
	   <entry>size</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[A ShaderParameter instance, with properties for the parameter metadata]</i></entry>
	 </row><row>
	   <entry>radius</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[A ShaderParameter instance, with properties for the parameter metadata]</i></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Note that any input image or parameter that is defined in the shader source code 
	 but not used in the shader's <codeph>evaluatePixel()</codeph> function is removed when the 
	 shader is compiled to byte code. In that case, there is no corresponding ShaderInput 
	 or ShaderParameter instance added as a property of the ShaderData instance.</p> 
	 
	 <p>Generally, developer code does not create a ShaderData instance. 
	 A ShaderData instance containing data, parameters, and inputs 
	 for a shader is available as the Shader instance's <codeph>data</codeph> 
	 property.</p>
	 
	 </apiDesc><example conref="examples\ShaderDataExample.1.as"> The following example loads a shader and enumerates the ShaderData instance 
 in its <codeph>data</codeph> property to display the input, parameters, and metadata properties of 
 the shader.
 
 <p>Note that this example assumes there's a shader bytecode file named "donothing.pbj" in the same 
 directory as the output directory for the application.</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;&gt;

kernel DoNothing
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "A shader that does nothing, but does it well.";
&gt;
{
    input image4 src;
    
    output pixel4 dst;
    
    parameter float2 size
    &lt;
        description: "The size of the image to which the shader is applied";
        minValue: float2(0.0, 0.0);
        maxValue: float2(100.0, 100.0);
        defaultValue: float2(50.0, 50.0);
    &gt;;
    
    parameter float radius
    &lt;
        description: "The radius of the effect";
        minValue: float(0.0);
        maxValue: float(50.0);
        defaultValue: float(25.0);
    &gt;;

    void evaluatePixel()
    {
        float2 one = (radius / radius) * (size / size);
        dst = sampleNearest(src, outCoord());
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderDataExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function ShaderDataExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            for (var p:String in shader.data) {
                trace(p, ":", shader.data[p]);
                for (var d:String in shader.data[p]) {
                    trace("\t", d, ":", shader.data[p][d]);
                }
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links><apiConstructor id="flash.display:ShaderData:ShaderData"><apiName>ShaderData</apiName><shortdesc>
		 Creates a ShaderData instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>byteCode</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>The shader's byte code.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Creates a ShaderData instance. Generally, developer code does not call 
		 the ShaderData constructor directly. A ShaderData instance containing 
		 data, parameters, and inputs for a Shader instance is accessed using 
		 its <codeph>data</codeph> property.
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
	 A ShaderJob instance is used to execute a shader operation in stand-alone mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A ShaderJob instance is used to execute a shader operation in stand-alone mode.
	 The shader operation executes and returns its result data. It is up to the 
	 developer to determine how to use the result.
	 
	 <p>There are two primary reasons for using a shader in stand-alone mode:</p>
	 
	 <ul>
	   <li>Processing non-image data: Using a ShaderJob instance you have control 
	       over input values and over how the shader result is used. The shader can 
	       return the result as binary data or number data instead of image data.</li>
	   <li>Background processing: Some shaders are complex and require a notable 
	       amount of time to execute. Executing a complex shader in the main 
	       execution of an application could slow down other parts of the application 
	       such as user interaction or updating the screen. Using a ShaderJob instance, 
	       you can execute the shader in the background. 
	       When the shader is executed in this way, the shader operation runs separate 
	       from the main execution of the application.</li>
	 </ul>
	 
	 <p>The <codeph>shader</codeph> property (or constructor parameter) specifies the 
	 Shader instance representing the shader that is used for the operation. You 
	 provide any parameter or input that the shader expects using the 
	 associated ShaderParameter or ShaderInput instance.</p>
	 
	 <p>Before execution a ShaderJob operation, you provide an object into which the 
	 result is written, by setting it as the value of the <codeph>target</codeph> property. 
	 When the shader operation completes the result is written into the <codeph>target</codeph> object.</p>
	 
	 <p>To begin a background shader operation, 
	 call the <codeph>start()</codeph> method. When the operation finishes the result is 
	 written into the <codeph>target</codeph> object. At that point the ShaderJob 
	 instance dispatches a <codeph>complete</codeph> 
	 event, notifying listeners that the result is available.</p>
	 
	 <p>To execute a shader synchronously (that is, not running in the background), call 
	 the <codeph>start()</codeph> method and pass <codeph>true</codeph> as an argument. The shader 
	 runs in the main execution thread and your code pauses until the operation completes. When
	 it finishes the result is written into the <codeph>target</codeph> object. At that point
	 the application continues running at the next line of code.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader"><linktext>Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>ShaderParameter</linktext></link><link href="flash.events.xml#ShaderEvent"><linktext>ShaderEvent</linktext></link></related-links><adobeApiEvent id="flash.display:ShaderJob_flash.events.ShaderEvent.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	 Dispatched when a ShaderJob that executes asynchronously finishes processing 
	 the data using the shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ShaderEvent.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Dispatched when a ShaderJob that executes asynchronously finishes processing 
	 the data using the shader. A ShaderJob instance executes asynchronously when the 
	 <codeph>start()</codeph> method is called with a <codeph>false</codeph> value for the 
	 <codeph>waitForCompletion</codeph> parameter.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:ShaderJob:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
		 
		 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>The shader to use for the operation.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>The object into which the result of the shader operation
		                 is written. This argument must be a BitmapData, ByteArray, or 
		                 Vector.&lt;Number&gt; instance.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>The width of the result data in the <codeph>target</codeph> if it is 
		                a ByteArray or Vector.&lt;Number&gt; instance. The size of the 
		                ByteArray or Vector.&lt;Number&gt; instance is enlarged 
		                if necessary and existing data is overwritten.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>The height of the result data in the <codeph>target</codeph> if it is 
		                 a ByteArray or Vector.&lt;Number&gt; instance. The size of the 
		                 ByteArray or Vector.&lt;Number&gt; instance is enlarged 
		                 if necessary and existing data is overwritten.
         
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:ShaderJob:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels the currently running shader operation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels the currently running shader operation. Any result data that is already 
		 computed is discarded. The <codeph>complete</codeph> event is not dispatched.
		 
		 <p>Calling <codeph>cancel()</codeph> multiple times has no additional effect.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:ShaderJob:start"><apiName>start</apiName><shortdesc>
		 Starts a shader operation in synchronous or asynchronous mode, according to the 
		 value of the waitForCompletion parameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>When the <codeph>target</codeph> property is <codeph>null</codeph> or is not 
		                       a BitmapData, ByteArray, or Vector.&lt;Number&gt; instance.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When the shader specifies an image input that isn't provided.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>When a ByteArray or Vector.&lt;Number&gt; instance is used as 
		                       an input and the <codeph>width</codeph> 
		                       and <codeph>height</codeph> properties aren't specified for the 
		                       ShaderInput, or the specified values don't match the amount of 
		                       data in the input object. See the <codeph>ShaderInput.input</codeph> 
		                       property for more information.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>waitForCompletion</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Specifies whether to execute the shader in the background 
		                          (<codeph>false</codeph>, the default) or in the main program 
		                          execution (<codeph>true</codeph>).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Starts a shader operation in synchronous or asynchronous mode, according to the 
		 value of the <codeph>waitForCompletion</codeph> parameter.
		 
		 <p>In asynchronous mode (when <codeph>waitForCompletion</codeph> 
		 is <codeph>false</codeph>), which is the default, the 
		 ShaderJob execution runs in the background. The shader operation does not affect the 
		 responsiveness of the display or other operations. In asynchronous mode the <codeph>start()</codeph>
		 call returns immediately and the program continues with the next line of code. When the asynchronous 
		 shader operation finishes, the result is available and the <codeph>complete</codeph> 
		 event is dispatched.</p>
		 
		 <p>Only one background ShaderJob operation 
		 executes at a time. Shader operations are held in a queue until they execute. 
		 If you call the <codeph>start()</codeph> method while a shader 
		 operation is executing, the additional operation is added to the end of the queue. 
		 Later, when its turn comes, it executes.</p>
		 
		 <p>To execute a shader operation in synchronous mode, call <codeph>start()</codeph> with a 
		 <codeph>true</codeph> value for the <codeph>waitForCompletion</codeph> parameter (the only parameter). 
		 Your code pauses at the point where <codeph>start()</codeph> is called until the shader operation 
		 completes. At that point the result is available and execution continues with the next line 
		 of code.</p>
		 
		 <p>When you call the <codeph>start()</codeph> method the Shader instance in the <codeph>shader</codeph> 
		 property is copied internally. The 
		 shader operation uses that internal copy, not a reference to the original shader. Any changes 
		 made to the shader, such as changing a parameter value, input, or bytecode, are not applied 
		 to the copied shader that's used for the shader processing. To incorporate shader changes 
		 into the shader processing, call the <codeph>cancel()</codeph> method 
		 (if necessary) and call the <codeph>start()</codeph> method again to restart the shader processing.</p>
		 
		 <p>While a shader operation is executing, the <codeph>target</codeph> object's value 
		 is not changed. When the operation finishes (and the <codeph>complete</codeph> 
		 event is dispatched in asynchronous mode) the entire result is written to the 
		 <codeph>target</codeph> object at one time. If the <codeph>target</codeph> object is a 
		 BitmapData instance and its <codeph>dispose()</codeph> method is called 
		 before the operation finishes, the <codeph>complete</codeph> event is still 
		 dispatched in asynchronous mode. However, the result data is not 
		 written to the BitmapData object because it is in a disposed state.</p>
         
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.display:ShaderJob:start_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when the operation finishes, if the 
		                             <codeph>start()</codeph> method is called with a 
		                             <codeph>waitForCompletion</codeph> argument of <codeph>true</codeph>.
		 
		 </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when the operation finishes, if the 
		                             start() method is called with a 
		                             waitForCompletion argument of true.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.display:ShaderJob:height:get"><apiName>height</apiName><shortdesc>
		 The height of the result data in the target if it is 
		 a ByteArray or Vector.&amp;lt;Number&amp;gt; instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 The height of the result data in the <codeph>target</codeph> if it is 
		 a ByteArray or Vector.&lt;Number&gt; instance. The size of the 
		 ByteArray or Vector.&lt;Number&gt; instance is enlarged 
		 if necessary and existing data is overwritten.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:progress:get"><apiName>progress</apiName><shortdesc>
		 The progress of a running shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 The progress of a running shader. This property is a value from 0 through 1.  
		 Zero is the initial value (0% complete). One indicates that the shader 
		 has completed its operation.
		 
		 <p>If the <codeph>cancel()</codeph> method is called this property becomes 
		 <codeph>undefined</codeph>, and its value cannot be used reliably until the 
		 shader operation starts again.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:shader:get"><apiName>shader</apiName><shortdesc>
		 The shader that's used for the operation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 The shader that's used for the operation. Any input or parameter that the 
		 shader expects must be provided using the ShaderInput or ShaderParameter 
		 property of the Shader instance's <codeph>data</codeph> property. An input must 
		 be provided using its corresponding ShaderInput even if it is the same as 
		 the <codeph>target</codeph> object.
		 
		 <p>To process a ByteArray containing a linear array of data (as opposed to 
		 image data) set the corresponding ShaderInput instance's <codeph>height</codeph> 
		 to 1 and <codeph>width</codeph> to the number of 32-bit floating-point values in 
		 the ByteArray. In that case, the input in the shader must be defined with 
		 the <codeph>image1</codeph> data type.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderJob:target:get"><apiName>target</apiName><shortdesc>
		 The object into which the result of the shader operation is written.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 The object into which the result of the shader operation is written. 
		 This object must be a BitmapData, ByteArray, or Vector.&lt;Number&gt; instance.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:width:get"><apiName>width</apiName><shortdesc>
		 The width of the result data in the target if it is 
		 a ByteArray or Vector.&amp;lt;Number&amp;gt; instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 The width of the result data in the <codeph>target</codeph> if it is 
		 a ByteArray or Vector.&lt;Number&gt; instance. The size of the 
		 ByteArray or Vector.&lt;Number&gt; instance is enlarged 
		 if necessary and existing data is overwritten.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowSystemChrome"><apiName>NativeWindowSystemChrome</apiName><shortdesc>
	 The NativeWindowSystemChrome class defines constants for the systemChrome 
	 property of the NativeWindowInitOptions object used to create a native window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 The NativeWindowSystemChrome class defines constants for the <codeph>systemChrome</codeph> 
	 property of the NativeWindowInitOptions object used to create a native window.  
	 
	 <p>System chrome refers to the operating system-specific elements of a window 
	 such as a title bar, minimize, maximize, and close buttons.</p>
  	 
	 <p><b>Note:</b> The type of system chrome used is specified when a window is 
	 created and cannot be changed.</p>
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowSystemChrome:NONE"><apiName>NONE</apiName><shortdesc>
	 No system chrome.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 No system chrome. 
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowSystemChrome:STANDARD"><apiName>STANDARD</apiName><shortdesc>
	 The standard chrome for the host operating system.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The standard chrome for the host operating system.
	 
	 <p>Use this setting to emulate the look and feel of the native operating system.</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsStroke"><apiName>IGraphicsStroke</apiName><shortdesc>
	This interface is used to define objects that can be used as stroke parameters in the flash.display.Graphics
	methods and drawing classes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier></apiBaseClassifier></apiClassifierDef><apiDesc>
	This interface is used to define objects that can be used as stroke parameters in the flash.display.Graphics
	methods and drawing classes. Use the implementor classes of this interface to
	create and manage stroke property data, and to reuse the same data for different instances.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
 The SimpleButton class lets you control all instances of button symbols in a SWF
 file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>The SimpleButton class lets you control all instances of button symbols
 in a SWF file.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 The SimpleButton class lets you control all instances of button symbols in a SWF
 file. After you create an instance of a button in the authoring tool, you can
 use the methods and properties of the SimpleButton class to manipulate buttons
 with ActionScript.
 
 <p product="flash">You can give a button an instance name in the
 Property inspector. SimpleButton instance names are displayed in the Movie
 Explorer and in the Insert Target Path dialog box in the Actions
 panel.</p>
 
 <p>In ActionScript 3.0, you use the <codeph>new SimpleButton()</codeph> constructor to create a 
 SimpleButton instance.</p>
 
 <p>The SimpleButton class inherits from the InteractiveObject class.</p>
 
 </apiDesc><example conref="examples\SimpleButtonExample.as"> The following example uses the SimpleButtonExample class, which in
 turn uses the CustomSimpleButton class, and this class then instantiates four
 ButtonDisplayState objects.  The result is a button that is created in the shape of
 a square, whose background color changes based on the mouse state by overriding instance properties of
 the SimpleButton class.  This is accomplished by performing the following steps:
 <ol>
  <li>In the <codeph>SimpleButtonExample()</codeph> constructor, a new CustomSimpleButton object of type
  SimpleButton, called <codeph>button</codeph>, is created, which calls the <codeph>CustomSimpleButton</codeph> constructor
  method.  The <codeph>button</codeph> object is the added to the display list.  The button's color and size are
  determined in the steps that follow.</li>
 
  <li>In the CustomSimpleButton class, instance properties are declared that are later used
  to control the size and background color of <codeph>button</codeph>, based on the state it is in (orange
  in the normal state, dark yellow in the mouse over state, an light blue in the mouse down state).
  In all of the <codeph>button</codeph>'s states, the size of the square is set to 80 pixels by using the
  <codeph>size</codeph> property.</li>
 
  <li>The constructor function for the CustomSimpleButton class sets the 
  <codeph>downState</codeph>, <codeph>overState</codeph>, <codeph>upState</codeph>, 
  <codeph>hitTestState</codeph>, and <codeph>useHandCursor</codeph> properties with
  four instances of the ButtonDisplayState class.</li>
 
  <li>In the ButtonDisplayState class, the constructor sets the value of the
  square's size and background color and calls the <codeph>draw()</codeph> method.</li>
 
  <li>The <codeph>draw()</codeph> method redraws the square with the size and background color set in
  the constructor based on the button's state.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class SimpleButtonExample extends Sprite {
        public function SimpleButtonExample() {
            var button:CustomSimpleButton = new CustomSimpleButton();
            addChild(button);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.SimpleButton;

class CustomSimpleButton extends SimpleButton {
    private var upColor:uint   = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;
    private var size:uint      = 80;

    public function CustomSimpleButton() {
        downState      = new ButtonDisplayState(downColor, size);
        overState      = new ButtonDisplayState(overColor, size);
        upState        = new ButtonDisplayState(upColor, size);
        hitTestState   = new ButtonDisplayState(upColor, size * 2);
        hitTestState.x = -(size / 4);
        hitTestState.y = hitTestState.x;
        useHandCursor  = true;
    }
}

class ButtonDisplayState extends Shape {
    private var bgColor:uint;
    private var size:uint;

    public function ButtonDisplayState(bgColor:uint, size:uint) {
        this.bgColor = bgColor;
        this.size    = size;
        draw();
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject"><linktext>InteractiveObject class</linktext></link></related-links><apiConstructor id="flash.display:SimpleButton:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
	Creates a new SimpleButton instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>upState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>The initial value for the SimpleButton up state.
	</apiDesc></apiParam><apiParam><apiItemName>overState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>The initial value for the SimpleButton over state.
	</apiDesc></apiParam><apiParam><apiItemName>downState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>The initial value for the SimpleButton down state.
	</apiDesc></apiParam><apiParam><apiItemName>hitTestState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>The initial value for the SimpleButton hitTest state.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Creates a new SimpleButton instance.
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Creates a new SimpleButton instance. Any or all of the display objects that represent 
	the various button states can be set as parameters in the constructor.  
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:SimpleButton:downState:get"><apiName>downState</apiName><shortdesc>
	 Specifies a display object that is used as the visual
     object for the button "Down" state &amp;#8212;the state that the button is in when the user
	 clicks the hitTestState object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Specifies a DisplayObject value used for the
	 button "Down" state.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Specifies a display object that is used as the visual
     object for the button "Down" state —the state that the button is in when the user
	 clicks the <codeph>hitTestState</codeph> object.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:enabled:get"><apiName>enabled</apiName><shortdesc>
	 A Boolean value that specifies whether a button is enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button.enabled, enabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Specifies whether a button is enabled (true) or disabled (false).
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 A Boolean value that specifies whether a button is enabled. When a
	 button is disabled (the enabled property is set to <codeph>false</codeph>),
	 the button is visible but cannot be clicked. The default value is
	 <codeph>true</codeph>. This property is useful if you want to
	 disable part of your navigation; for example, you might want to disable a
	 button in the currently displayed page so that it can't be clicked and
	 the page cannot be reloaded.
	 
	 <p><b>Note:</b> To prevent mouseClicks on a button, set both the <codeph>enabled</codeph>
	 and <codeph>mouseEnabled</codeph> properties to <codeph>false</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:hitTestState:get"><apiName>hitTestState</apiName><shortdesc>
	 Specifies a display object that is used as the hit testing object for the button.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier></apiValueDef><apiDesc>
	 Specifies a display object that is used as the hit testing object for the button. For a basic button, set the 
	 <codeph>hitTestState</codeph> property to the same display object as the <codeph>overState</codeph>
	 property. If you do not set the <codeph>hitTestState</codeph> property, the SimpleButton 
     is inactive — it does not respond to mouse and keyboard events.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:overState:get"><apiName>overState</apiName><shortdesc>
	 Specifies a display object that is used as the visual
     object for the button over state &amp;#8212; the state that the button is in when 
	 the mouse is positioned over the button.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Specifies a DisplayObject value used for the
	 button "Over" state.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Specifies a display object that is used as the visual
     object for the button over state — the state that the button is in when 
	 the mouse is positioned over the button.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 The SoundTransform object assigned to this button.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should information from AS2 setTransform be here? e.g. percentage values indicating
	 how much of the left input to play in the left speaker or right speaker; it is generally
	 best to use 22-KHZ 6-bit mono sounds?
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 The SoundTransform object assigned to this button. A SoundTransform object
	 includes properties for setting volume, panning, left speaker assignment, and right
	 speaker assignment. This SoundTransform object applies to all states of the button. 
	 This SoundTransform object affects only embedded sounds.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Indicates whether other display objects that are SimpleButton or MovieClip objects can receive 
	 mouse release events.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates whether other display objects that are SimpleButton or MovieClip objects can receive 
	 mouse release events. The <codeph>trackAsMenu</codeph> property lets you create menus. You 
	 can set the <codeph>trackAsMenu</codeph> property on any SimpleButton or MovieClip object.
	 If the <codeph>trackAsMenu</codeph> property does not exist, the default behavior is 
	 <codeph>false</codeph>. 
	 
	 <p>You can change the <codeph>trackAsMenu</codeph> property at any time; the
	 modified button immediately takes on the new behavior. </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:upState:get"><apiName>upState</apiName><shortdesc>
	 Specifies a display object that is used as the visual
     object for the button up state &amp;#8212; the state that the button is in when
	 the mouse is not positioned over the button.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Specifies a DisplayObject value used for the
	 button "Up" state.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Specifies a display object that is used as the visual
     object for the button up state — the state that the button is in when
	 the mouse is not positioned over the button.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
     A Boolean value that, when set to true, indicates whether 
     the hand cursor is shown when the mouse rolls over a button.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create two buttons on the Stage with the instance names <code>myBtn1_btn</code> and <code>myBtn2_btn</code>. Enter the following ActionScript in Frame 1 of the Timeline:
	 <listing>
	 myBtn1_btn.useHandCursor = false;
	 myBtn1_btn.onRelease = buttonClick;
	 myBtn2_btn.onRelease = buttonClick;
	 function buttonClick() {
	   trace(this._name);
	 }
	 </listing>
	 <p>When the mouse is over and clicks <code>myBtn1_btn</code>, there is no pointing hand. However, you see the pointing hand when the button is over and clicks <code>myBtn2_btn</code>.</p>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Displays a pointing hand cursor when set to true.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     A Boolean value that, when set to <codeph>true</codeph>, indicates whether 
     the hand cursor is shown when the mouse rolls over a button.
	 If this property is set to <codeph>false</codeph>, the arrow pointer cursor is displayed
	 instead. The default is <codeph>true</codeph>.
	 
	 <p>You can change the <codeph>useHandCursor</codeph> property at any time;
	 the modified button immediately uses the new cursor behavior. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:TriangleCulling"><apiName>TriangleCulling</apiName><shortdesc>
 Defines codes for culling algorithms that determine which triangles not to render when drawing triangle paths.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines codes for culling algorithms that determine which triangles not to render when drawing triangle paths.
 
 <p>
 The terms <codeph>POSITIVE</codeph> and <codeph>NEGATIVE</codeph> refer to the sign of a triangle's normal along the z-axis. 
 The normal is a 3D vector that is perpendicular to the surface of the triangle.
 </p>
 
 <p>
 A triangle whose vertices 0, 1, and 2 are arranged in a clockwise order has a positive normal value. That is,
 its normal points in a positive z-axis direction, away from the current view point.  
 When the <codeph>TriangleCulling.POSITIVE</codeph> algorithm is used, triangles with positive normals
 are not rendered. Another term for this is backface culling.
 </p>
 
 <p>
 A triangle whose vertices are arranged in a counter-clockwise order has a negative normal value. That is,
 its normal points in a negative z-axis direction, toward the current view point. 
 When the <codeph>TriangleCulling.NEGATIVE</codeph> algorithm is used, triangles with negative normals will not 
 be rendered.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTrianglePath()"><linktext>flash.display.Graphics.drawTrianglePath()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="http://www.gamedev.net/reference/articles/article1089.asp"><linktext>Introduction to 3D Vectors</linktext></link><link href="http://www.gamedev.net/reference/articles/article1088.asp"><linktext>3D Backface Culling</linktext></link></related-links><apiValue id="flash.display:TriangleCulling:NEGATIVE"><apiName>NEGATIVE</apiName><shortdesc>
     Specifies culling of all triangles facing toward the current view point.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>negative</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies culling of all triangles facing toward the current view point.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:NONE"><apiName>NONE</apiName><shortdesc>
     Specifies no culling.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies no culling. All triangles in the path are rendered.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:POSITIVE"><apiName>POSITIVE</apiName><shortdesc>
     Specifies culling of all triangles facing away from the current view point.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>positive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies culling of all triangles facing away from the current view point. 
     This is also known as backface culling.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
 The NativeWindow class provides an interface for creating and controlling native desktop windows.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 The NativeWindow class provides an interface for creating and controlling native desktop windows.
  
 <p platform="actionscript">A reference to the NativeWindow instance is returned by the window constructor. 
 A reference to a NativeWindow instance can also be accessed using the <codeph>stage.nativeWindow</codeph> 
 property of any display object on that window's stage:
 </p>
 
 <pre platform="actionscript">var window:NativeWindow = displayObject.stage.nativeWindow;</pre>
 
 <p platform="javascript">A reference to the NativeWindow instance is returned by the window constructor. 
 JavaScript in an HTML page can reference the NativeWindow instance by using the <codeph>window.nativeWindow</codeph> 
 property.
 </p>
 
 <p>The properties of a NativeWindow instance can only be accessed by application
 content. If non-application content attempts to access the NativeWindow object, a
 security error will be thrown.</p>
 
 <p>Content can be added to a window using the 
 DisplayObjectContainer methods of the Stage object such as <codeph>addChild()</codeph>.</p>
 
 <p platform="actionscript">You cannot not add Flex components directly to the display list of a 
 NativeWindow instance. Instead, use the Flex mx:WindowedApplication
 and mx:Window components to create your windows and add the other Flex
 components as children of those objects. You can add Flex-based SWF content directly 
 to a NativeWindow window as long as the SWF file is loaded into its own 
 application domain and is application content.
 </p>
 
 <p>To create a root HTML window for displaying HTML content it is typically
 easier to create the window with <codeph>HTMLLoader.createRootWindow()</codeph>.
 Windows created in this way will have an HTMLLoader object added automatically.
  (From JavaScript code, you can also use the JavaScript
 <codeph>window.open()</codeph> function. However, this method gives you less control
 over the window appearance and behavior.)</p>
 
 <p>
 The following operations on NativeWindow objects are asynchronous: <codeph>close()</codeph>, 
 <codeph>maximize()</codeph>, <codeph>minimize()</codeph>, <codeph>restore()</codeph>, and <codeph>bounds</codeph> changes.
 An application can detect when these operations have completed by listening 
 for the appropriate events.
 </p>
 
 <p>
 If the <codeph>NativeApplication.autoExit</codeph> property is <codeph>true</codeph>, which is the default, 
 the application will close when its last window is closed (and all <codeph>close</codeph> event 
 handlers have returned). 
 If <codeph>autoExit</codeph> is <codeph>false</codeph>, then <codeph>NativeApplication.nativeApplication.exit()</codeph> 
 must be called to terminate the application.
 </p>
 <p>
 NativeWindow objects will not be garbage collected after the window constructor has been called 
 and before <codeph>close()</codeph>
 has been called.  It is the responsibility of the application to close its own windows.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/nativeWindow"><linktext>flash.display.Stage.nativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="flash.desktop.xml#NativeApplication"><linktext>flash.desktop.NativeApplication</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
 Dispatched by this NativeWindow object after the window has been deactivated.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object after the window has been deactivated.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
 Dispatched by this NativeWindow object after the window has been activated.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object after the window has been activated.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Dispatched by this NativeWindow object after the window has been closed.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object after the window has been closed.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSING_closing"><apiName>closing</apiName><shortdesc>
 Dispatched by this NativeWindow object immediately before the window is to be closed.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object immediately before the window is to be closed.
 This event can be canceled to prevent the window from being closed.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE_displayStateChange"><apiName>displayStateChange</apiName><shortdesc>
 Dispatched by this NativeWindow object after the window's displayState property has changed.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object after the window's <codeph>displayState</codeph> property has changed.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING_displayStateChanging"><apiName>displayStateChanging</apiName><shortdesc>
 Dispatched by this NativeWindow object immediately before the window changes its display state.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object immediately before the window changes its display state.
 This event can be canceled to prevent the change.
 
 </apiDesc><example conref="examples\NativeWindow.displayStateChanging.1.as"> The following example demonstrates how to cancel a <codeph>displayStateChanging</codeph> event.
<codeblock>
function displayStateChanging_handler(displayStateEvent:NativeWindowDisplayStateEvent):void
{
  //shouldStopStateChange is an application-defined Boolean indicating 
  //that display state changes should be canceled
  if (displayStateEvent.type == NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING 
                                  &amp;&amp;    shouldStopStateChange)
  {
    displayStateEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Dispatched by this NativeWindow object after the window has been resized.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object after the window has been resized.
 
 A <codeph>resize</codeph> event is dispatched whenever the size (<codeph>width</codeph> or <codeph>height</codeph> properties) of the window
 changes, which can occur because of a system-controlled window resize; minimizing, maximizing,
 or restoring the window; or changing the window size by setting the <codeph>width</codeph>, 
 <codeph>height</codeph>, or <codeph>bounds</codeph> properties.
 
 NativeWindow <codeph>resize</codeph> events are dispatched during system-controled resize loops. In contrast,
 Stage object <codeph>resize</codeph> events are dispatched when the Stage is ready for drawing.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Stage/resize"><linktext>flash.display.Stage.resize</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZING_resizing"><apiName>resizing</apiName><shortdesc>
 Dispatched by this NativeWindow object immediately before the window is to be resized on
 the desktop.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object immediately before the window is to be resized on
 the desktop. This event can be canceled to prevent or modify the resize.
 
 </apiDesc><example conref="examples\NativeWindow.resizing.1.as"> The following example demonstrates how to cancel a <codeph>resizing</codeph> event.
<codeblock>
function boundsChanging_handler(boundsEvent:NativeWindowBoundsEvent):void
{
  //shouldStopResize is an application-defined Boolean indicating 
  //that resize operations should be canceled
  if (boundsEvent.type == NativeWindowBoundsEvent.RESIZING &amp;&amp; shouldStopResize)
  {
    boundsEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVE_move"><apiName>move</apiName><shortdesc>
 Dispatched by this NativeWindow object after the window has been moved on the desktop.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by this NativeWindow object after the window has been moved on the desktop.
 <p>
 A <codeph>move</codeph> event is dispatched whenever the origin (<codeph>x</codeph> or <codeph>y</codeph> properties) of the window
 changes, which can occur because of a system-controlled window move; minimizing, maximizing,
 or restoring the window; or changing the window location by setting the <codeph>x</codeph>, 
 <codeph>y</codeph>, or <codeph>bounds</codeph> properties.
 </p>
 <p><b>Note:</b> Avoid actions that may open simultaneous operating system dialogs boxes
 in the handler functions for both the <codeph>moving</codeph> and <codeph>move</codeph> events 
 of a NativeWindow object. This may occur, for example, if both handler functions throw an error.
 If it does occur, the second dialog box opened will not
 register mouse clicks and must be closed using the keyboard.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVING_moving"><apiName>moving</apiName><shortdesc>
 Dispatched by the NativeWindow object immediately before the window is to be moved on
 the desktop.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by the NativeWindow object immediately before the window is to be moved on
 the desktop. This event can be canceled to prevent or modify the move.
 
 <p><b>Note:</b> Avoid actions that may open simultaneous operating system dialogs boxes
 in the handler functions for both the <codeph>moving</codeph> and <codeph>move</codeph> events 
 of a NativeWindow object. This may occur, for example, if both handler functions throw an error.
 If it does occur, the second dialog box opened will not
 register mouse clicks and must be closed using the keyboard.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeWindow:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
    Creates a new NativeWindow instance and a corresponding operating system window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>initOptions</codeph> parameter is invalid.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiParam><apiItemName>initOptions</apiItemName><apiOperationClassifier>flash.display:NativeWindowInitOptions</apiOperationClassifier><apiDesc>An object containing the initialization properties for this window.
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Creates a new NativeWindow instance and a corresponding operating system window.
    <p>
    The settings defined in the <codeph>initOptions</codeph> parameter cannot be changed after the
    window is created. Invalid <codeph>initOptions</codeph> settings will cause an illegal operation error 
    to be thrown. Settings that are valid but not available on the current system will not throw an exception.
    The window capabilities specific to the current operating system can be 
    detected, if desired, using the static NativeWindow members
    such as <codeph>systemMaxSize</codeph>.
    </p>
    
    <p>The default window size is determined by the operating system, but can be
    changed by setting the window bounds. The change will not be visible if the
    window <codeph>visible</codeph> property is <codeph>false</codeph>.</p>
    
    </apiDesc><example conref="examples\NativeWindow.constructor.1.as"> The following example creates and activates a new NativeWindow instance:
<codeblock>
import flash.display.NativeWindowInitOptions;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowType;
import flash.display.NativeWindow;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.geom.Rectangle;

var windowOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
windowOptions.systemChrome = NativeWindowSystemChrome.STANDARD;
windowOptions.type = NativeWindowType.NORMAL;

var newWindow:NativeWindow = new NativeWindow(windowOptions);
newWindow.stage.scaleMode = StageScaleMode.NO_SCALE;
newWindow.stage.align = StageAlign.TOP_LEFT;
newWindow.bounds = new Rectangle(100, 100, 800, 800);

newWindow.activate();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeWindow:activate"><apiName>activate</apiName><shortdesc>
	 Activates this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Activates this window. 
	 
	 <p>Activating a window will:</p>
	 <ul> 
	 <li>Make the window visible</li>
	 <li>Bring the window to the front</li> 
	 <li>Give the window keyboard and mouse focus</li>
	 </ul>
	 
	 <p>On Linux, <codeph>activate()</codeph> is an asynchronous operation.</p>
	 
	 <p>The NativeWindow object dispatches an <codeph>activate</codeph> event on all platforms.</p>
	 
	 </apiDesc><example conref="examples\NativeWindow.activate.1.as"> The following examples show how to activate a window.
  
 <p>With a reference to a display object on the window stage:</p>
<codeblock>
displayObject.stage.nativeWindow.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.2.as"> With a reference to an instance of the NativeWindow class:
<codeblock>
windowObj.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.3.as"> From JavaScript in an HTML page rendered in the window
 (where <codeph>window</codeph> is the global JavaScript window object):
<codeblock>
window.nativeWindow.activate();
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/visible"><linktext>visible</linktext></link><link href="flash.display.xml#NativeWindow/orderToFront"><linktext>orderToFront</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:close"><apiName>close</apiName><shortdesc>
      Closes this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Closes this window. 
      
      <p>A <codeph>close</codeph> event is dispatched as soon as the close operation is complete. 
      A <codeph>closing</codeph> event will not be dispatched. If cancellation of the close operation should
      be allowed, dispatch a <codeph>closing</codeph> event and check whether any registered listeners cancel
      the default behavior before calling the <codeph>close()</codeph> method.
      </p>
      <p>
      If display object instances that are currently in the window are not referenced elsewhere 
      they will be garbage collected and destroyed, except on the initial application window
      created by AIR. To allow display objects on the initial window to be garbage collected,
      remove them from the window stage.
      </p>
      <p>
      After being closed, the NativeWindow object is still a valid reference, but accessing most
      properties and methods will throw an illegal operation error.
      </p>
      <p>
      Closed windows cannot be reopened. If the window is already closed, no action is taken and 
      no events are dispatched.
      </p>
      
      <p>Note: to hide a window without closing it, set the window's <codeph>visible</codeph> property to
      <codeph>false</codeph>.
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.close.1.as"> The following examples show how to close a window:
  
 <p>With a reference to the NativeWindow instance (<codeph>windowObj</codeph>):</p>
<codeblock>
windowObj.close();

</codeblock></example><example conref="examples\NativeWindow.close.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObj.stage.nativeWindow.close();
</codeblock></example><example conref="examples\NativeWindow.close.3.as"> From a JavaScript routine running in an HTMLLoader object
 (or HTML root window):
<codeblock>
window.close(); //overriddable in HTMLHost
</codeblock></example><example conref="examples\NativeWindow.close.4.as"> Or:
<codeblock>
window.nativeWindow.close(); //not overriddable
</codeblock></example><example conref="examples\NativeWindow.close.5.as">  
 The following example illustrates how to allow cancellation of a close operation
 (where <codeph>windowObj</codeph> is the NativeWindow instance to be closed):
<codeblock>
public function closeCommand():Boolean{
    var closeEvent:Event = new Event(Event.CLOSING,true,true);
    windowObj.dispatchEvent(closeEvent);
    if(!closeEvent.isDefaultPrevented()){
        windowObj.close();
        return true;
    } else {
      return false;
    }
}
</codeblock></example><example conref="examples\NativeWindow.close.6.as"> The following example illustrates how to close a window from a
 JavaScript routine running in an HTMLLoader object (or HTML root window), while 
 allowing the operation to be canceled:
<codeblock>
&lt;script src="AIRAliases.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var dirtyData = false;
    function closeWindow(){
            var closingEvent = new air.Event(air.Event.CLOSING,true,true);
            window.nativeWindow.dispatchEvent(closingEvent);
               if(!closingEvent.isDefaultPrevented()){
                   window.nativeWindow.close();
                //or use: window.close(); 
               return true;
           } else {
               return false;
        }
    }
        
    function onClosing(event){
        if(dirtyData){
            event.preventDefault();
            //Save data...
        }
    }    

    window.nativeWindow.addEventListener(air.Event.CLOSING,onClosing);        
&lt;/script&gt;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/closed"><linktext>flash.display.NativeWindow.closed</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>flash.html.HTMLLoader</linktext></link><link href="../../flash/html/HTMLHost.html"><linktext>flash.html.HTMLHost</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:globalToScreen"><apiName>globalToScreen</apiName><shortdesc>
      Converts a point in pixel coordinates relative to the origin of the window stage 
      (a global point in terms of the display list), to a point on the virtual desktop.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The specified global point relative to the desktop.
      
      </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>globalPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point on the stage to convert to a point on the screen.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Converts a point in pixel coordinates relative to the origin of the window stage 
      (a global point in terms of the display list), to a point on the virtual desktop.
      
      <p>Virtual desktop coordinates are relative to the upper, lefthand corner of the primary 
      monitor.</p>
      
      </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:maximize"><apiName>maximize</apiName><shortdesc>
      Maximizes this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>maximizable</codeph> property of this window 
      is <codeph>false</codeph> or 
      if the method is called after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Maximizes this window.  
      <p>
      Calling <codeph>maximize()</codeph> method dispatches a <codeph>displayStateChange</codeph> 
      event, and, if applicable, a <codeph>move</codeph> and a <codeph>resize</codeph> event. 
      Whereas system chrome will dispatch a <codeph>displayStateChanging</codeph> event 
      that can be canceled when a maximize command is initiated by a user, your maximize 
      logic must implement this behavior, if desired.
      </p>
      <p>
      The <codeph>maximize()</codeph> method executes asynchronously. To detect the completion 
      of the state change, listen for the <codeph>displayStateChange</codeph> event.
      </p>
      <p>If the window is already maximized, no action is taken and no events are dispatched.</p>
      
      <p><b>Notes:</b></p> 
      <ul>
      <li>On operating systems, such as Mac OS X, in which maximizing
      a window does not also prevent resizing, calling <codeph>maximize()</codeph> will zoom the window
      to fill the screen, but will not prevent subsequent resizing of the window.
      Resizing a zoomed window will also restore the display state.</li>
      
      <li>On some operating systems, such as Mac OS X, as well as on some Linux window managers, 
      maximizing a window will not expand the window beyond
      the width and height specified in the <codeph>maxSize</codeph> property. On others, the window will expand
      to fill the screen even if the screen is larger than the <codeph>maxSize</codeph>.</li>
      
      <li>Some Linux window managers do not allow utility windows to be maximized.</li>
      
      </ul>
      
      </apiDesc><example conref="examples\NativeWindow.maximize.1.as">  
 The following example illustrates how to allow cancelation of a maximize operation:  
<codeblock>
public function maximizeWindow(nativeWin:NativeWindow):Boolean{
  if(nativeWin.displayState != NativeWindowDisplayState.MAXIMIZED){
    var beforeState:String = nativeWin.displayState;
    var afterState:String = NativeWindowDisplayState.MAXIMIZED;
    var displayStateEvent:NativeWindowDisplayStateEvent = 
        new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
    nativeWin.dispatchEvent(displayStateEvent);
    if(!displayStateEvent.isDefaultPrevented()){
        nativeWin.maximize();
        return true;
    } else {
      return false;
    }
  }
  return false;
}
</codeblock></example><example conref="examples\NativeWindow.maximize.2.as">  
 The following example illustrates how to allow cancelation of a maximize operation
 from a JavaScript routine running in an HTMLLoader object on the window (or an HTML window):  
<codeblock>
function maximizeWindow(nativeWin){
    if(nativeWin.displayState != air.NativeWindowDisplayState.MAXIMIZED){
        var beforeState = nativeWin.displayState;
        var afterState = air.NativeWindowDisplayState.MAXIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.maximize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:minimize"><apiName>minimize</apiName><shortdesc>
      Minimizes this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>minimizable</codeph> property of this window 
      is <codeph>false</codeph> or 
      if the method is called after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Minimizes this window. 
      <p>
      Calling <codeph>minimize()</codeph> dispatches a <codeph>displayStateChange</codeph> event, 
      and, if applicable, a <codeph>move</codeph> and a <codeph>resize</codeph> event. 
      Whereas system chrome will dispatch a <codeph>displayStateChanging</codeph> event 
      that can be canceled when a minimize command is initiated by a user, 
      calling <codeph>minimize()</codeph> directly does not. Your minimize logic may 
      implement this behavior, if desired.
      </p>
      
      <p>The <codeph>minimize()</codeph> method executes asynchronously. To detect the completion 
      of the state change, listen for the <codeph>displayStateChange</codeph> event.
      If the window is already minimized, no action is taken and no events are dispatched.</p>
      
      <p>Some Linux window managers do not allow utility windows to be minimized.</p>
      
	  </apiDesc><example conref="examples\NativeWindow.minimize.1.as"> The following example illustrates how to allow cancelation of a call to
 <codeph>minimize()</codeph> by dispatching a <codeph>displayStateChanging</codeph> event: 
<codeblock>
public function minimizeWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.MINIMIZED){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.minimize.2.as"> The following example illustrates how to allow cancelation of a call to
 <codeph>minimize()</codeph> in JavaScript running in an HTMLLoader object (or HTML window): 
<codeblock> 
function minimizeWindow(){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.MINIMIZED){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:notifyUser"><apiName>notifyUser</apiName><shortdesc>
      Triggers a visual cue through the operating system that an event of 
      interest has occurred.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>A string representing the urgency of the notification.   
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      Triggers a visual cue through the operating system that an event of 
      interest has occurred.
      
      <p>When <codeph>NativeWindow.supportsNotification</codeph> is <codeph>true</codeph>,
      the visual cue will conform to the operating system convention of the 
      native system. For example, on Windows, the task bar icon will flash.</p>
      
      <p>The <codeph>type</codeph> parameter determines the intensity of the cue.
      Constants for the permitted values are defined in the NotificationType 
      class, and may be:</p>
      <ul>
      <li><codeph>NotificationType.INFORMATIONAL</codeph></li>
      <li><codeph>NotificationType.CRITICAL</codeph></li>
      </ul>
      <p>The cues provided for informational notifications are of short duration;
      those provided for critical notifications will last until the user activates
      this window. Not all Linux window managers support two levels of notification.
      For such window managers, <codeph>notifyUser()</codeph> will have the same affect
      no matter which option is specified.</p>
      
      <p><b>Note:</b> Calling <codeph>notifyUser()</codeph> when 
      <codeph>NativeWindow.supportsNotification</codeph> is <codeph>false</codeph> 
      is allowed, but does nothing.</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInBackOf"><apiName>orderInBackOf</apiName><shortdesc>
      Sends this window directly behind the specified window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if this window was succesfully sent to the 
      back; <codeph>false</codeph> if this window is invisible or minimized.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>An application window.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Sends this window directly behind the specified window.
      
      <p>Does not activate or acquire the focus for the window or the application.
      Minimized or hidden (<codeph>visible</codeph> is <codeph>false</codeph>) windows cannot be
      reordered.</p>
      
      <p>Some Linux window managers do not allow utility windows to be ordered behind normal windows.</p>
      
      </apiDesc><example conref="NativeWindow.orderInBackOf.1.as"> The following examples show how to move a window just below another
 window with references to the NativeWindow instances:
<codeblock>
windowBehind.orderInBackOf(windowFront);
</codeblock></example><example conref="NativeWindow.orderInBackOf.2.as"> With references to display objects on the window stages:
<codeblock>
displayObjBehind.stage.nativeWindow.orderInBackOf(displayObjectFront.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInBackOf.3.as"> From a JavaScript routine running in an HTMLLoader object (or HTML root window)
 using references to two JavaScript Window objects:
<codeblock>
jsWindowObjBehind.nativeWindow.orderInBackOf(jsWindowObjFront.nativeWindow);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInFrontOf"><apiName>orderInFrontOf</apiName><shortdesc>
      Brings this window directly in front of the specified window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if this window was succesfully brought to the 
      front; <codeph>false</codeph> if this window is invisible or minimized.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>An application window.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Brings this window directly in front of the specified window.
      
      <p>Does not activate or acquire the focus for the window or the application.
      Minimized or hidden (<codeph>visible</codeph> is <codeph>false</codeph>) windows cannot be
      reordered.</p>
      
      <p>Some Linux window managers do not allow normal windows to be ordered in front of utility windows.</p>
      
      </apiDesc><example conref="NativeWindow.orderInFrontOf.1.as"> The following examples show how to move a window just above another
 window with references to the NativeWindow instances:
<codeblock>
windowFront.orderInFrontOf(windowBehind);
</codeblock></example><example conref="NativeWindow.orderInFrontOf.2.as"> With references to display objects on the window stages:
<codeblock>
displayObjFront.stage.nativeWindow.orderInFrontOf(displayObjectBehind.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInFrontOf.3.as"> From a JavaScript routine running in an HTMLLoader object (or HTML root window)
 using references to two JavaScript window objects:
<codeblock>
jsWindowObjFront.nativeWindow.orderInFrontOf(jsWindowObjBehind.nativeWindow);

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToBack"><apiName>orderToBack</apiName><shortdesc>
      Sends this window behind any other visible windows.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if this window was succesfully sent to the 
      back; <codeph>false</codeph> if this window is invisible or minimized.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Sends this window behind any other visible windows.
      
      <p>Does not activate or acquire the focus for this window or the application.
      Minimized or hidden (<codeph>visible</codeph> is <codeph>false</codeph>) windows cannot be
      reordered.</p>
      
      <p>If <codeph>alwaysInFront</codeph> is <codeph>true</codeph>, then calling this method will not 
      send this window behind any windows which have 
      <codeph>alwaysInFront</codeph> set to <codeph>false</codeph>.</p>
      
      <p>Some Linux window managers do not allow utility windows to be ordered behind normal windows.</p>
      
      </apiDesc><example conref="NativeWindow.orderToBack.1.as"> The following examples show how to move a window behind all other
 windows in the application (with the same <codeph>alwaysInFront</codeph> setting):
<codeblock>
windowObj.orderToBack();

</codeblock></example><example conref="NativeWindow.orderToBack.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObj.stage.nativeWindow.orderToBack();
</codeblock></example><example conref="NativeWindow.orderToBack.3.as"> From a JavaScript routine running in an HTMLLoader object in the window
 (or a root HTML window):
<codeblock>
window.nativeWindow.orderToBack();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToFront"><apiName>orderToFront</apiName><shortdesc>
      Brings this window in front of any other visible windows.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if this window was succesfully brought to the 
      front; <codeph>false</codeph> if this window is invisible or minimized.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Brings this window in front of any other visible windows. 
      
      <p>Does not activate or acquire the focus for this window or the application.
      Minimized or hidden (<codeph>visible</codeph> is <codeph>false</codeph>) windows cannot be
      reordered.</p>
       
      <p>If <codeph>alwaysInFront</codeph> is <codeph>false</codeph>, then calling this method will not 
      send this window in front of any windows which have 
      <codeph>alwaysInFront</codeph> set to <codeph>true</codeph>.</p>
      
      <p>Some Linux window managers do not allow normal windows to be ordered in front of utility windows.</p> 
      
      </apiDesc><example conref="NativeWindow.orderToFront.1.as"> The following examples show how to move a window in front of all other
 windows in the application (with the same <codeph>alwaysInFront</codeph> setting):
<codeblock>
windowObj.orderToFront();

</codeblock></example><example conref="NativeWindow.orderToFront.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObj.stage.nativeWindow.orderToFront();
</codeblock></example><example conref="NativeWindow.orderToFront.3.as"> From a JavaScript routine running in an HTMLLoader object in the window
 (or a root HTML window):
<codeblock>
window.nativeWindow.orderToFront();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:restore"><apiName>restore</apiName><shortdesc>
      Restores this window from either a minimized or a maximized state.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the method is called after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Restores this window from either a minimized or a maximized state.
      
      <p>Calling <codeph>restore()</codeph> dispatches a <codeph>displayStateChange</codeph> event, 
      and, if applicable, a <codeph>move</codeph> and a <codeph>resize</codeph> event. 
      Whereas system chrome will dispatch a <codeph>displayStateChanging</codeph> event that can 
      be canceled when a restore command is initiated by a user, your restore logic must 
      implement this behavior, if desired.
      </p>
      
      <p>If the window is already in the <codeph>NativeWindowDisplayState.NORMAL</codeph> state, 
      no action is taken and no events are dispatched.</p>
      
      <p>
      To detect the completion of the state change, listen for
      the <codeph>displayStateChange</codeph> event, which is dispatched on all platforms.
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.restore.1.as">  
 The following example illustrates how to allow cancelation of a restore operation: 
<codeblock>
public function restoreWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.NORMAL){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.NORMAL;
        var displayStateChangingEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateChangingEvent);
        if(!displayStateChangingEvent.isDefaultPrevented()){
            nativeWin.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.restore.2.as"> The following example illustrates how to allow cancelation of a restore operation from
 a JavaScript routine running in an HTMLLoader object on the window (or an HTML window): 
<codeblock>
function restoreWindow(nativeWin){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.NORMAL){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.NORMAL;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:startMove"><apiName>startMove</apiName><shortdesc>
      Starts a system-controlled move of this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the method is called after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> if the move was succesfully initiated and 
       <codeph>false</codeph> if the window is maximized.
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Starts a system-controlled move of this window.
      <p>
      When called from a <codeph>mouseDown</codeph> event, this method begins a mouse-driven move
      sequence that continues until a <codeph>mouseUp</codeph> event occurs. 
      </p>
      <p>
      When called from other code this method begins a keyboard- or mouse-driven move sequence 
      consistent with the operating system's default sequence.
      </p>
      
      <p>During a move sequence, a series of events will be dispatched as the window origin moves. For
      each incremental move, first a <codeph>moving</codeph> event is dispatched and then, if the 
      <codeph>moving</codeph> event is not canceled, the window location is updated and a 
      <codeph>move</codeph> event is dispatched. If a <codeph>moving</codeph> event is
      canceled, the move sequence is immediately terminated.</p>
      
      </apiDesc><example conref="NativeWindow.startMove.1.as"> The following example shows how to move a window in response to a 
 <codeph>mouseDown</codeph> event:
<codeblock>
var initOpts:NativeWindowInitOptions = new NativeWindowInitOptions();
var win:NativeWindow = new NativeWindow(initOpts);
win.activate();
win.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);

function mouseDownHandler(event:MouseEvent):void
{
    win.startMove();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:startResize"><apiName>startResize</apiName><shortdesc>
      Starts a system-controlled resize operation of this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the method is called after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> if the resize was succesfully initiated and 
       <codeph>false</codeph> if the window is maximized.

      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>edgeOrCorner</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>A constant from the NativeWindowResize class that specifies
      which edge or corner of this window to resize. The following are
      valid values:
      
      <p>
      <adobetable class="innertable">
          
           
           
           
           
            
            
            
            
            
           
      <tgroup cols="3"><thead><row><entry>Value</entry><entry>Vertical alignment</entry><entry>Horizontal alignment</entry></row></thead><tbody><row><entry><codeph>NativeWindowResize.TOP</codeph></entry>
           <entry>Top</entry>
           <entry>Center</entry>
           </row><row><entry><codeph>NativeWindowResize.BOTTOM</codeph></entry>
           <entry>Bottom</entry>
           <entry>Center</entry>
           </row><row><entry><codeph>NativeWindowResize.LEFT</codeph></entry>
           <entry>Center</entry>
           <entry>Left</entry>
           </row><row><entry><codeph>NativeWindowResize.RIGHT</codeph></entry>
           <entry>Center</entry>
           <entry>Right</entry>
           </row><row><entry><codeph>NativeWindowResize.TOP_LEFT</codeph></entry>
            <entry>Top</entry>
            <entry>Left</entry>
            </row><row><entry><codeph>NativeWindowResize.TOP_RIGHT</codeph></entry>
            <entry>Top</entry>
            <entry>Right</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_LEFT</codeph></entry>
            <entry>Bottom</entry>
            <entry>Left</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_RIGHT</codeph></entry>
            <entry>Bottom</entry>
            <entry>Right</entry>
            </row><row><entry><codeph>NativeWindowResize.NONE</codeph></entry>
            <entry>Bottom</entry>
            <entry>Right</entry>
            </row></tbody></tgroup></adobetable>
      </p>
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Starts a system-controlled resize operation of this window.
      <p>
      When called from a <codeph>mouseDown</codeph> event handler this method begins a mouse-driven resizing
      sequence that continues until a <codeph>mouseUp</codeph> event occurs.  
      </p>
      <p>
      When called from other code this method begins a keyboard- or mouse-driven resizing sequence consistent 
      with the operating system's default sequence.
      </p>
      <p>During the resize sequence, a series of events will be dispatched as the 
      window dimensions change. For each incremental change, first a <codeph>resizing</codeph> 
      event is dispatched and then, if the <codeph>resizing</codeph> event is not
      canceled, the window dimensions are updated and a <codeph>resize</codeph> event is dispatched. 
      If a <codeph>resizing</codeph> event is canceled, the the sequence is immediately terminated.</p>
      
      </apiDesc><example conref="NativeWindow.startResize.1.as"> The following example shows how to resize a window in response to a 
 <codeph>mouseDown</codeph> event:
<codeblock>
stage.addEventListener(MouseEvent.MOUSE_DOWN, onResizeCommand);

function onResizeCommand(event:MouseEvent):void
{
    var win:NativeWindow = event.target.nativeWindow;
    var resizeFrom:String = "";
    if (event.stageY &lt; win.height * .33)
    {
        resizeFrom = NativeWindowResize.TOP;
    }
    else if (event.stageY &gt; win.height * .66)
    {
        resizeFrom = NativeWindowResize.BOTTOM;
    }
    if (event.stageX &lt; win.width * .33)
    {
        resizeFrom += NativeWindowResize.LEFT;
    }
    else if (event.stageX &gt; win.width * .66)
    {
        resizeFrom += NativeWindowResize.RIGHT;
    }
    win.startResize(resizeFrom);    
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeWindow:active:get"><apiName>active</apiName><shortdesc>
      Indicates whether this window is the active application window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Indicates whether this window is the active application window.
      
      <p>Use the <codeph>activate()</codeph> method to make a window active.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate"><linktext>flash.display.NativeWindow.activate</linktext></link><link href="flash.desktop.xml#NativeApplication/activate"><linktext>flash.desktop.NativeApplication.activate</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:alwaysInFront:get"><apiName>alwaysInFront</apiName><shortdesc>
      Specifies whether this window will always be in front of other windows (including
      those of other applications).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Specifies whether this window will always be in front of other windows (including
      those of other applications).
      
      <p>There are two groups of windows in the system depth order.  Windows in the 
      <codeph>alwaysInFront</codeph> group are always displayed in front of all other
      windows. Depth ordering between windows within the same group is determined normally. 
      In other words, activating a window will bring it in front of other windows 
      in its group.</p>
      
      <p>Changing <codeph>alwaysInFront</codeph> from <codeph>false</codeph> to <codeph>true</codeph> will
      bring the window to the top of all other windows. Changing the property from <codeph>true</codeph> 
      to <codeph>false</codeph> will send the window to the back of "alwaysInFront" windows, but still 
      in front of other windows. Setting the property to its current value will not change the window 
      depth order.</p>
      
      <p>The <codeph>alwaysInFront</codeph> property should rarely be set to <codeph>true</codeph> since
      windows with this setting will appear in front of the windows of other applications
      even when the other application is active.</p>
      
      <p>Some Linux window managers always display utility windows in front of normal windows.</p>
      
      <p><b>Note:</b> On Mac<sup>®</sup> OS X, setting <codeph>alwaysInFront</codeph> to <codeph>true</codeph> will
      have no effect when the <codeph>displayState</codeph> property of the window stage
      is <codeph>fullScreen</codeph> or <codeph>fullScreenInteractive</codeph>. On Linux, fullscreen windows
      with <codeph>alwaysInFront</codeph> set to <codeph>true</codeph> always display in front of other
      windows that have <codeph>alwaysInFront</codeph> set to <codeph>true</codeph>.</p> 
      
      </apiDesc><example conref="NativeWindow.alwaysInFront.1.as"> The following examples force a window to be displayed in front
 of all other windows (that are not similarly forced to the front):
<codeblock>
windowObj.alwaysInFront = true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObject.stage.nativeWindow.alwaysInFront=true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.3.as"> From a JavaScript routine running in an HTMLLoader object in the 
 window (or a root HTML window):
<codeblock>
window.nativeWindow.alwaysInFront = true;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:bounds:set"><apiName>bounds</apiName><shortdesc>
      The size and location of this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>If the rectangle is null or contains invalid values.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the bounds property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The size and location of this window.  
      <p>
      The dimensions of a window include any system chrome. The dimensions of a window's stage are equal to the
      dimensions of the window, minus the size of any system chrome. Changing
      the width and height of the window will change the stage's <codeph>stageWidth</codeph> and <codeph>stageHeight</codeph>.
      The reverse also applies; changing the stage dimensions will change the window size.
      </p>
      <p>In a root HTML window, the <codeph>outerWidth</codeph> and <codeph>outerHeigth</codeph> properties
      are equivalent to the window <codeph>height</codeph> and <codeph>width</codeph> properties. 
      The <codeph>innerWidth</codeph> and <codeph>innerHeight</codeph> properties equal
      the <codeph>stage.stageWidth</codeph> and <codeph>stage.stageHeight</codeph>
      properties minus the thickness of any automatic scrollbars displayed
      by the window.</p>
      <p>
      A <codeph>resize</codeph> event is dispatched whenever the width or height of this window 
      changes. Likewise, a <codeph>move</codeph> event is dispatched whenever the origin (x,y) of this window 
      changes. On Mac OS and Windows, setting the <codeph>bounds</codeph> property directly will not 
      dispatch a <codeph>moving</codeph> or <codeph>resizing</codeph> event. However, on Linux the NativeWindow 
      <i>does</i> dispatch a <codeph>moving</codeph> and <codeph>resizing</codeph> events when you set 
      the <codeph>bounds</codeph> property. 
      </p>
      <p>
      Setting the <codeph>bounds</codeph> property of a window is equivalent to setting its 
      <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, and <codeph>height</codeph> properties.
      Likewise, setting any of the individual dimensions is equivalent to setting the 
      <codeph>bounds</codeph> property. When you set all the dimensions at the same time by using the 
      <codeph>bounds</codeph> property, fewer events are dispatched. 
      </p>
      <p>The order in which the individual dimensions are set is not guaranteed. On Linux
      window managers that do not allow windows to extend off the desktop area, a change to an individual
      property may be blocked even though the net affect of applying all the property changes would
      have resulted in a legal window.</p>
      
      <p>If the width or height specified is less than the minimum or greater than the maximum allowed
      width or height, then the window width or height is set to the closest legal size. The factors that 
      determine the minimum and maximum width and height are the following:</p>
      
      <ul>
      
      	<li>The <codeph>minSize</codeph> and <codeph>maxSize</codeph> properties of the 
      NativeWindow object</li>
      	<li>The minimum and maximum operating system limits, which are the values of 
      <codeph>NativeWindow.systemMinSize</codeph> and <codeph>NativeWindow.systemMaxSize</codeph>.</li>
      	<li>The maximum width and height of a window in Adobe AIR, which are each 2880 pixels.</li>
      	<li>The minimum width and height required by any displayed system chrome.</li>
      
      </ul>
      
	  </apiDesc><example conref="examples\NativeWindow.bounds.1.as"> The following examples set the bounds of a window with a 
 reference to a NativeWindow object:
<codeblock>
windowObj.bounds = new Rectangle(200, 200, 1000, 800);
</codeblock></example><example conref="examples\NativeWindow.bounds.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObject.stage.nativeWindow.bounds = new Rectangle(20, 20, 800, 600);
</codeblock></example><example conref="examples\NativeWindow.bounds.3.as"> From a JavaScript routine running in an HTMLLoader object in the window (or a root HTML window):
<codeblock>
window.nativeWindow.bounds = new air.Rectangle(20, 20, 800, 600);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:closed:get"><apiName>closed</apiName><shortdesc>
      Indicates whether this window has been closed.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Indicates whether this window has been closed.  
      
      <p>Accessing the following properties on a closed window will 
      throw an illegal operation error:</p>
      <ul> 
      <li><codeph>title</codeph></li>
      <li><codeph>bounds</codeph></li>
      <li><codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, <codeph>height</codeph></li>
      <li><codeph>displayState</codeph></li>
      <li><codeph>visible</codeph></li>
      </ul>
      <p>Likewise, calling the following methods on a closed window will 
      also throw an illegal operation error:</p>
      <ul>
      <li><codeph>minimize()</codeph></li>
      <li><codeph>maximize()</codeph></li>
      <li><codeph>restore()</codeph></li>
      <li><codeph>startResize()</codeph></li>
      <li><codeph>startMove()</codeph></li>
      </ul>
      
      </apiDesc><example conref="NativeWindow.closed.1.as"> The following examples show how to access the <codeph>closed</codeph> property
 of a window:
<codeblock>
var isWindowClosed:Boolean = windowObj.closed;
</codeblock></example><example conref="NativeWindow.closed.2.as"> With a reference to a display object on the window stage:
<codeblock>
var isWindowClosed:Boolean = displayObject.stage.nativeWindow.closed;
</codeblock></example><example conref="NativeWindow.closed.3.as"> From a JavaScript routine running in an HTMLLoader object in the window
 (or root HTML window):
<codeblock>
var isWindowClosed = window.nativeWindow.closed;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:displayState:get"><apiName>displayState</apiName><shortdesc>
     The display state of this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>If the <codeph>displayState</codeph> property is accessed 
     after this window has been closed.
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     The display state of this window.
     <p>
     Constants for the possible values are defined in the NativeWindowDisplayState class: 
     </p>
     <ul>
     <li><codeph>NativeWindowDisplayState.NORMAL</codeph></li>
     <li><codeph>NativeWindowDisplayState.MINIMIZED</codeph></li>
     <li><codeph>NativeWindowDisplayState.MAXIMIZED</codeph></li>
     </ul> 
     
     </apiDesc><example conref="examples\NativeWindow.displayState.1.as"> The following example shows how to get the current window
 display state given a reference to the window object:
<codeblock>
var state:String = windowObj.displayState;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:height:get"><apiName>height</apiName><shortdesc>
      The height of this window in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>If the value set is <codeph>null</codeph> or invalid.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The height of this window in pixels.
      
      <p>The dimensions of a window include any system window chrome that is displayed.
      The height of the usable display area inside a window is available from the 
      <codeph>Stage.stageHeight</codeph> property.</p>
      
      <p>Changing the <codeph>height</codeph> property of a window is equivalent to changing the
      height through the <codeph>bounds</codeph> property.</p>
      
      <p>If the height specified is less than the minimum or greater than the maximum allowed height, 
      then the window height is set to the closest legal size. The factors that determine the minimum
      and maximum height are the following:</p>
      
      <ul>
      
      	<li>The <codeph>minSize.x</codeph> and <codeph>maxSize.x</codeph> properties of the 
      NativeWindow object</li>
      	<li>The minimum and maximum operating system limits, which are the values of 
      <codeph>NativeWindow.systemMinSize.x</codeph> and <codeph>NativeWindow.systemMaxSize.x</codeph>.</li>
      	<li>The maximum height of a window in Adobe AIR, which is 2880 pixels.</li>
      
      </ul>
      
      <p>On Linux, setting the <codeph>height</codeph> property is an asynchronous operation.</p>
     
      <p>
      To detect the completion of the height change, listen for
      the <codeph>resize</codeph> event, which is dispatched on all platforms.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageHeight"><linktext>flash.display.Stage.stageHeight</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maxSize:get"><apiName>maxSize</apiName><shortdesc>
      The maximum size for this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>If assigned size is not within the 
      operating system minimum and maximum window sizes. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If size is forbidden for the content's current privilege.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the size is <codeph>null</codeph> or contains invalid values.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the <codeph>maxSize</codeph> property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The maximum size for this window.  
      
      <p>The size limit is specified as the coordinates of a Point object. 
      The point <codeph>x</codeph> property corresponds to the window width, 
      the <codeph>y</codeph> property to the window height.</p>
      
      <p>
      The <codeph>maxSize</codeph> restriction is enforced for window resizing operations
      invoked both through <ph platform="actionscript">ActionScript</ph> 
	  <ph platform="javascript">JavaScript</ph> code and through the operating system.
      </p>
      <p>
      Setting <codeph>maxSize</codeph> will change the window bounds if the 
      current bounds are larger than the new maximum size.
      </p>
      
      <p>If the width or height specified is greater than the maximum allowed width or height, 
      then the value is set to the closest legal size. The factors that determine the
      maximum width and height are the following:</p>
      
      <ul>
      
      	<li>The maximum operating system limit, which is the value <codeph>NativeWindow.systemMaxSize</codeph>.</li>
      	<li>The maximum width and height of a window in Adobe AIR, which is 2880 pixels for each.</li>
      
      </ul>
      
      <p>
      <b>Note:</b> On some operating systems, such as Mac OS X, maximizing a window will only enlarge the window to the <codeph>maxSize</codeph> 
      value even if the maximized window will be smaller than the operating system screen. The window will still be
      in the maximized display state.
      </p>
      
      </apiDesc><example conref="NativeWindow.maxSize.1.as"> The following examples show how to set the maximum allowed
 size for a window.
<codeblock>
windowObj.maxSize = new Point(1040,920);
</codeblock></example><example conref="NativeWindow.maxSize.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObject.stage.nativeWindow.maxSize = new Point(800,600);
</codeblock></example><example conref="NativeWindow.maxSize.3.as"> From a JavaScript routine running in an HTMLLoader object in a window
 (or in a root HTML window):
<codeblock>
window.nativeWindow.maxSize = new air.Point(960,960);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maximizable:get"><apiName>maximizable</apiName><shortdesc>
	 Reports the maximizable setting used to create this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>When trying to set to <codeph>false</codeph> without sufficient privilege.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Reports the <codeph>maximizable</codeph> setting used to create this window.
	  
	 <p>The <codeph>maximizable</codeph> setting cannot be changed after a window is created.</p>
	 
	 <p>Not all Linux window managers honor the <codeph>maximizable</codeph> setting.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/maximizable"><linktext>flash.display.NativeWindowInitOptions.maximizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:menu:get"><apiName>menu</apiName><shortdesc>
      The native menu for this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
      The native menu for this window. 
      
      <p>When a NativeMenu object is assigned to the window <codeph>menu</codeph> 
      property, a native menu will be displayed for a window if 
      <codeph>NativeWindow.supportsMenu</codeph> is <codeph>true</codeph>, unless the window
      <codeph>systemChrome</codeph> property is <codeph>NativeWindowSystemChrome.NONE</codeph>.</p>
      
      <p><b>Note:</b> Assigning a menu to a window when <codeph>NativeWindow.supportsMenu</codeph>
      is <codeph>false</codeph> or when the window <codeph>systemChrome</codeph> property is 
      <codeph>NativeWindowSystemChrome.NONE</codeph> is allowed, but does nothing. Be sure to 
      use the <codeph>NativeWindow.supportsMenu</codeph> property to determine whether the 
      operating system supports window menus. Using other means (such as <codeph>Capabilities.os</codeph>)
      to determine support can lead to programming errors (if some possible target operating systems 
      are not considered).</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minSize:get"><apiName>minSize</apiName><shortdesc>
      The minimum size for this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>If the assigned size is not within the 
      operating system minimum and maximum window sizes. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>If size is forbidden for the content's current privilege.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the size is <codeph>null</codeph> or contains invalid values.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>if the <codeph>minSize</codeph> property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The minimum size for this window. 
       
      <p>The size limit is specified as the coordinates of a Point object. 
      The point <codeph>x</codeph> property corresponds to the window width, 
      the <codeph>y</codeph> property to the window height.</p>
      <p>
      Setting <codeph>minSize</codeph>, will change the window bounds if the 
      current bounds are smaller than the new minimum size.
      </p>
      <p>
      The <codeph>minSize</codeph> restriction is enforced for window resizing operations
      invoked both through <ph platform="actionscript">ActionScript</ph> 
	  <ph platform="javascript">JavaScript</ph> code and through the operating system.
      </p>
      <p>
      <b>Note:</b> The width and height of any displayed system chrome may
      make it impossible to set a window as small as the specified minimum size. 
      </p>
      
      </apiDesc><example conref="NativeWindow.minSize.1.as"> The following examples show how to set the minimum allowed
 size for a window:
<codeblock>
windowObj.minSize = new Point(200,80);
</codeblock></example><example conref="NativeWindow.minSize.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObject.stage.nativeWindow.minSize = new Point(120,60);
</codeblock></example><example conref="NativeWindow.minSize.3.as"> From a JavaScript routine running in an HTMLLoader object in a window
 (or in a root HTML window):
<codeblock>
window.nativeWindow.minSize = new air.Point(80,60);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minimizable:get"><apiName>minimizable</apiName><shortdesc>
	 Reports the minimizable setting used to create this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>When trying to set to <codeph>false</codeph> without sufficient privilege.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Reports the <codeph>minimizable</codeph> setting used to create this window.
	 
	 <p>The <codeph>minimizable</codeph> setting cannot be changed after a window is created.</p>
	 
	 <p>Not all Linux window managers honor the <codeph>minimizable</codeph> setting.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/minimizable"><linktext>flash.display.NativeWindowInitOptions.minimizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:resizable:get"><apiName>resizable</apiName><shortdesc>
	 Reports the resizable setting used to create this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>When trying to set to <codeph>false</codeph> without sufficient privilege.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Reports the <codeph>resizable</codeph> setting used to create this window.
	 
	 <p>The <codeph>resizable</codeph> setting cannot be changed after a window is created.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:stage:get"><apiName>stage</apiName><shortdesc>
      The Stage object for this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
      The Stage object for this window. <ph platform="actionscript">The 
	  Stage object is the root object in the display list architecture used in ActionScript
	  3.0-based SWF content.</ph>
      
      <p>
      The stage is the root of the display list for the window. Add visual display objects to a window by
      adding them to the stage or to another object already in the display list of this stage. The stage 
      dimensions are those of the window client area when the window uses system chrome. The stage 
      dimensions are equal to the dimensions of the window if system chrome is not used.
      </p>
      
      <p platform="javascript">The HTMLLoader, which renders HTML content, 
      is a single leaf in the display list tree. ActionScript-defined display objects can be
      both above and below the HTMLLoader in the drawing order, but not
      in between the visual elements rendered by the HTMLLoader.</p>
      
      </apiDesc><example conref="NativeWindow.stage.1.as"> The following example shows how to set stage properties for a 
 NativeWindow instance:
<codeblock>
import flash.display.StageAlign;

windowObj.stage.align = StageAlign.TOP_LEFT;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage"><linktext>flash.display.Stage</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
      Indicates whether AIR supports native window menus on the current computer system.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Indicates whether AIR supports native window menus on the current computer system.
      
      <p>When <codeph>NativeWindow.supportsMenu</codeph> is <codeph>true</codeph>, 
      a native menu will be displayed for a window when a NativeMenu
      object is assigned to the window <codeph>menu</codeph> property (unless the window
      <codeph>systemChrome</codeph> property is <codeph>NativeWindowSystemChrome.NONE</codeph>).
      Be sure to use the <codeph>NativeWindow.supportsMenu</codeph> property to determine whether the 
      operating system native window menus. Using other means (such as <codeph>Capabilities.os</codeph>)
      to determine support can lead to programming errors (if some possible target operating systems 
      are not considered).</p>
      
      <p><b>Note:</b> Assigning a menu to a window when <codeph>NativeWindow.supportsMenu</codeph>
      is <codeph>false</codeph> or when the window <codeph>systemChrome</codeph> property is 
      <codeph>NativeWindowSystemChrome.NONE</codeph> is allowed, but does nothing.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsMenu"><linktext>flash.desktop.NativeApplication.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsNotification:get"><apiName>supportsNotification</apiName><shortdesc> 
      Indicates whether AIR supports window notification cueing on the current computer system.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Indicates whether AIR supports window notification cueing on the current computer system.
      
      <p>When <codeph>NativeWindow.supportsNotification</codeph> is <codeph>true</codeph>, 
      calling the window's <codeph>notifyUser()</codeph> method will result in a
      visual cue to the user that an event of interest has occurred. This visual
      cue will conform to the operating system convention of the native system.
      For example, on Windows<sup>®</sup>, the task bar icon will flash.</p>
      
      <p><b>Note:</b> Calling <codeph>notifyUser()</codeph> when 
      <codeph>NativeWindow.supportsNotification</codeph> is <codeph>false</codeph> 
      is allowed, but does nothing.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsTransparency:get"><apiName>supportsTransparency</apiName><shortdesc> 
      Indicates whether AIR supports native windows with transparent pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Indicates whether AIR supports native windows with transparent pixels.
      
      <p>When <codeph>NativeWindow.supportsTransparency</codeph> is <codeph>true</codeph>, 
      transparency in pixels of a native window will be honored, if the window
      <codeph>transparent</codeph> property is set to <codeph>true</codeph>. Opacity of 
      all pixels will be set to 1 if <codeph>NativeWindow.supportsTransparency</codeph> 
      is <codeph>false</codeph>, regardless of the value of the window <codeph>transparent</codeph> 
      property. Fully transparent pixels will render as black when 
      <codeph>NativeWindow.supportsTransparency</codeph> is <codeph>false</codeph>.
      Be sure to use the <codeph>NativeWindow.supportsTransparency</codeph> property to determine whether the 
      operating system supports transparency. Using other means (such as <codeph>Capabilities.os</codeph>)
      to determine support can lead to programming errors (if some possible target operating systems 
      are not considered).</p>
      
      <p><b>Note:</b> The value of this property might change while an appliction
      is running, based on user preferences set for the operating system.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/transparent"><linktext>flash.display.NativeWindow.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
	 Reports the system chrome setting used to create this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>When trying to set to <codeph>false</codeph> without sufficient privilege.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Reports the system chrome setting used to create this window.
	 
	 <p>The values returned by <codeph>NativeWindow.systemChrome</codeph> will be
	 one of the constants defined in the NativeWindowSystemChrome class.</p>
	 
	 <p>The system chrome setting cannot be changed after a window is created.</p>
	 
	 </apiDesc><example conref="NativeWindow.systemChrome.1.as"> The following example shows how to get the system chrome type for a window:
<codeblock>
var sysChromeType:String = windowObj.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.2.as"> With a reference to a display object on the window stage:
<codeblock>
var sysChromeType:String = displayObject.stage.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.3.as"> From a JavaScript routine running in an HTMLLoader object in the window
 (or root HTML window):
<codeblock>
var sysChromeType = window.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.4.as"> The following example shows how to change the apparent
 system chrome and transparency settings by creating a new window and moving all child
 display objects to the new window:
<codeblock>
import flash.display.NativeWindow;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowInitOptions;

public function deChromeWindow(oldWindow:NativeWindow):NativeWindow{
    if(oldWindow.systemChrome != NativeWindowSystemChrome.NONE){
        var newOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
        newOptions.systemChrome = NativeWindowSystemChrome.NONE;
        newOptions.transparent = true;
        
        var newWindow:NativeWindow = new NativeWindow(newOptions);
        newWindow.stage.stageWidth = oldWindow.stage.stageWidth;
        newWindow.stage.stageHeight = oldWindow.stage.stageHeight;
        newWindow.stage.align = oldWindow.stage.align;
        newWindow.stage.scaleMode = oldWindow.stage.scaleMode;
        
        for(var i:int = 0; i &lt; oldWindow.stage.numChildren; i++){
            newWindow.stage.addChild(oldWindow.stage.getChildAt(i));
        }
        newWindow.activate();
        oldWindow.close();
        
        return newWindow;
    }
    return oldWindow;
}

</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/systemChrome"><linktext>flash.display.NativeWindowInitOptions.systemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemMaxSize:get"><apiName>systemMaxSize</apiName><shortdesc>
	 The largest window size allowed by the operating system.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 The largest window size allowed by the operating system.
	 
      <p>The size limit is specified as the coordinates of a Point object. 
      The point <codeph>x</codeph> property corresponds to the window width, 
      the <codeph>y</codeph> property to the window height.</p>
      
      <p>In addition to the operating system size limit, AIR has a maximum
      window size limit of 2880 by 2880 pixels. And an application can set
      a limit using the <codeph>maxSize</codeph> property of the NativeWindow object.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:systemMinSize:get"><apiName>systemMinSize</apiName><shortdesc>
	 The smallest window size allowed by the operating system.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 The smallest window size allowed by the operating system.
	 
      <p>The size limit is specified as the coordinates of a Point object. 
      The point <codeph>x</codeph> property corresponds to the window width, 
      the <codeph>y</codeph> property to the window height.</p>
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:title:set"><apiName>title</apiName><shortdesc>
      The window title.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Low-privilege apps will probably have a string appended to all of their title strings
      
      </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>If the property is accessed after this window has been closed.
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The window title.  
      <p>
      The title will appear in the system chrome for the window, if displayed, as well as in other system-dependent
      locations (such as the task bar).
      </p>
      
      </apiDesc><example conref="NativeWindow.title.1.as"> The following example sets the title of a window object:
<codeblock>
windowObj.title = "Window Title";
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Reports the transparency setting used to create this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>When trying to set to <codeph>false</codeph> without sufficient privilege.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Reports the transparency setting used to create this window.
	 
     <p>The <codeph>transparent</codeph> property cannot be changed after a window is created.
     Transparency affects both the visual appearance and the mouse behavior of
     the window. On Windows and Mac OS X, the window will not capture mouse events when the alpha value 
     of the pixel is below a certain threshold, which varies between about .06 and .01 depending on the operating
     system. On Linux, the the window will capture mouse events above completely transparent areas and 
     therefore will prevent users from accessing other windows and items on the desktop.</p>
     
     <p><b>Note:</b> Window transparency cannot always be supported. If the user's
     operating system configuration is such that transparency is not available, the 
     window will be created without transparency. Areas that would have been transparent 
     are composited against black. Use the <codeph>NativeWindow.supportsTransparency</codeph>
     property to determine whether window transparency is supported.</p>
	 
	 </apiDesc><example conref="NativeWindow.transparent.1.as"/><example conref="NativeWindow.transparent.2.as"/><example conref="NativeWindow.transparent.3.as"/></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/transparent"><linktext>flash.display.NativeWindowInitOptions.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:type:get"><apiName>type</apiName><shortdesc>
	 Reports the window type setting used to create this window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>When trying to set to <codeph>false</codeph> without sufficient privilege.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Reports the window <codeph>type</codeph> setting used to create this window.
	 
	 <p>The values returned by <codeph>NativeWindow.type</codeph> will be
	 one of the constants defined in the NativeWindowType class.</p>
	 
	 <p>The <codeph>type</codeph> setting cannot be changed after a window is created.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/type"><linktext>flash.display.NativeWindowInitOptions.type</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:visible:get"><apiName>visible</apiName><shortdesc> 
      Specifies whether this window is visible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>When trying to set to <codeph>false</codeph> without sufficient privilege.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
      Specifies whether this window is visible.  
      
      <p>
      An invisible window is not displayed on the desktop, but all window 
      properties and methods are valid.
      </p> 
      <p>
      By default, <codeph>visible</codeph> is set to <codeph>false</codeph>. To display
      a window, set <codeph>visible</codeph> to <codeph>true</codeph> or call 
      <codeph>NativeWindow.activate()</codeph>.
      </p>
      <p>
      <b>Note:</b> On Mac OS X, setting <codeph>visible=false</codeph> on a 
      minimized window will not remove the window icon from the dock. If a
      user subsequently clicks the dock icon, the window will return to the
      visible state and be displayed on the desktop.
      </p>
      
      </apiDesc><example conref="NativeWindow.visible.1.as"> The following examples show how to access the <codeph>visible</codeph> property
 of a window:
<codeblock>
windowObj.visible = true;
</codeblock></example><example conref="NativeWindow.visible.2.as"> With a reference to a display object on the window stage:
<codeblock>
displayObj.stage.nativeWindow.visible = true;
</codeblock></example><example conref="NativeWindow.visible.3.as"> From a JavaScript routine running in an HTMLLoader object in the window
 (or root HTML window):
<codeblock>
window.nativeWindow.visible = true;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate()"><linktext>activate()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:width:get"><apiName>width</apiName><shortdesc>
      The width of this window in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>If the value set is <codeph>null</codeph> or invalid.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The width of this window in pixels.
      
      <p>The dimensions reported for a native window include any system window chrome 
      that is displayed.
      The width of the usable display area inside a window is available from the 
      <codeph>Stage.stageWidth</codeph> property.</p>
      
      <p>Changing the <codeph>width</codeph> property of a window is equivalent to changing the
      width through the <codeph>bounds</codeph> property.</p>
      
      <p>If the width specified is less than the minimum or greater than the maximum allowed width, 
      then the window width is set to the closest legal size. The factors that determine the minimum
      and maximum width are the following:</p>
      
      <ul>
      
      	<li>The <codeph>minSize.y</codeph> and <codeph>maxSize.y</codeph> properties of the 
      NativeWindow object</li>
      	<li>The minimum and maximum operating system limits, which are the values of 
      <codeph>NativeWindow.systemMinSize.y</codeph> and <codeph>NativeWindow.systemMaxSize.y</codeph>.</li>
      	<li>The maximum width of a window in Adobe AIR, which is 2880 pixels.</li>
      
      </ul>
      
      <p>On Linux, setting the <codeph>width</codeph> property is an asynchronous operation.</p>
      
      <p>
      To detect the completion of the width change, listen for
      the <codeph>resize</codeph> event, which is dispatched on all platforms.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageWidth"><linktext>flash.display.Stage.stageWidth</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:x:get"><apiName>x</apiName><shortdesc>
      The horizontal axis coordinate of this window's top left corner relative to the 
      origin of the operating system desktop.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>If the value set is <codeph>null</codeph> or invalid.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The horizontal axis coordinate of this window's top left corner relative to the 
      origin of the operating system desktop.
      
      <p>On systems with more than one monitor, <codeph>x</codeph> can be negative. If you
      save the value, perhaps to reposition a window at its previous location, you
      should always verify that the window is placed in a usable location when the
      position is restored. Changes in screen resolution or monitor arrangement can
      can result in a window being placed off screen. Use the Screen class to obtain
      information about the desktop geometry.</p> 
      
      <p>Changing the <codeph>x</codeph> property of a window is equivalent to changing the
      location through the <codeph>bounds</codeph> property.</p>
      
      <p>On Linux, setting the <codeph>x</codeph> property is an asynchronous operation.</p>
      
      <p>
      To detect the completion of the position change, listen for
      the <codeph>move</codeph> event, which is dispatched on all platforms.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:y:get"><apiName>y</apiName><shortdesc>
      The vertical axis coordinate of this window's top left corner relative to the  
      upper left corner of the operating system's desktop.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>If the value set is <codeph>null</codeph> or invalid.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>If the property is accessed after this window has been closed.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      The vertical axis coordinate of this window's top left corner relative to the  
      upper left corner of the operating system's desktop.
      
      <p>On systems with more than one monitor, <codeph>y</codeph> can be negative. If you
      save the value, perhaps to reposition a window at its previous location, you
      should always verify that the window is placed in a usable location when the
      position is restored. Changes in screen resolution or monitor arrangement can
      can result in a window being placed off screen. Use the Screen class to obtain
      information about the desktop geometry.</p> 
      
      <p>Changing the <codeph>y</codeph> property of a window is equivalent to changing the
      location through the <codeph>bounds</codeph> property.</p>
      
      <p>On Linux, setting the <codeph>y</codeph> property is an asynchronous operation.</p>
       
      <p>
      To detect the completion of the position change, listen for
      the <codeph>move</codeph> event, which is dispatched on all platforms.
      </p>
     
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Stage"><apiName>Stage</apiName><shortdesc>
 The Stage class represents the main drawing area.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Stage class represents the main drawing area. 
 
 <p platform="actionscript">For SWF content running in the browser (in 
 Flash<sup>®</sup> Player), the Stage represents the entire area where Flash 
 content is shown. For content running in AIR, each NativeWindow object has a corresponding
 Stage object.</p>
 
 <p platform="actionscript">The Stage object is not globally accessible. You need to access it through the
 <codeph>stage</codeph> property of a DisplayObject instance.</p> 
 
 <p platform="actionscript">The Stage class has several ancestor classes — DisplayObjectContainer, InteractiveObject, 
 DisplayObject, and EventDispatcher — from which it inherits properties and methods. 
 Many of these properties and methods are either inapplicable to Stage objects, 
 or require security checks when called on a Stage object.  The properties and methods that 
 require security checks are documented as part of the Stage class.</p>
 
 <p platform="actionscript">In addition, the following inherited properties are inapplicable to Stage objects. If you 
 try to set them, an IllegalOperationError is thrown. These properties may always be read, but
 since they cannot be set, they will always contain default values.</p>
 
 <ul platform="actionscript">
 <li><codeph>accessibilityProperties</codeph></li>
 <li><codeph>alpha</codeph></li>
 <li><codeph>blendMode</codeph></li>
 <li><codeph>cacheAsBitmap</codeph></li>
 <li><codeph>contextMenu</codeph></li>
 <li><codeph>filters</codeph></li>
 <li><codeph>focusRect</codeph></li>
 <li><codeph>loaderInfo</codeph></li>
 <li><codeph>mask</codeph></li>
 <li><codeph>mouseEnabled</codeph></li>
 <li><codeph>name</codeph></li>
 <li><codeph>opaqueBackground</codeph></li>
 <li><codeph>rotation</codeph></li>
 <li><codeph>scale9Grid</codeph></li>
 <li><codeph>scaleX</codeph></li>
 <li><codeph>scaleY</codeph></li>
 <li><codeph>scrollRect</codeph></li>
 <li><codeph>tabEnabled</codeph></li>
 <li><codeph>tabIndex</codeph></li>
 <li><codeph>transform</codeph></li>
 <li><codeph>visible</codeph></li>
 <li><codeph>x</codeph></li>
 <li><codeph>y</codeph></li>
 </ul>
 
 <p>Some events that you might expect to be a part of the Stage class,
 such as <codeph>enterFrame</codeph>, <codeph>exitFrame</codeph>, 
 <codeph>frameConstructed</codeph>, and <codeph>render</codeph>, 
 cannot be Stage events because a reference to the Stage object
 cannot be guaranteed to exist in every situation where these events
 are used. Because these events cannot be dispatched by the Stage
 object, they are instead dispatched by every DisplayObject instance,
 which means that you can add an event listener to
 any DisplayObject instance to listen for these events. 
 These events, which are part of the DisplayObject class,
 are called broadcast events to differentiate them from events 
 that target a specific DisplayObject instance.
 Two other broadcast events, <codeph>activate</codeph> and <codeph>deactivate</codeph>, 
 belong to DisplayObject's superclass, EventDispatcher.
 The <codeph>activate</codeph> and <codeph>deactivate</codeph> events
 behave similarly to the DisplayObject broadcast events, except 
 that these two events are dispatched not only by all DisplayObject
 instances, but also by all EventDispatcher instances and instances
 of other EventDispatcher subclasses.
 For more information on broadcast events, see the DisplayObject class.</p>
 
 </apiDesc><example conref="examples\StageExample.as"> The following example uses the <codeph>StageExample</codeph> class to dispatch
 events whenever the stage is activated or resized.  This is accomplished by performing the following steps:
 <ol>
  <li>The class constructor first sets the Flash application to be fixed, regardless of the size of
  the Flash Player window and then adds two event listeners with the 
  <codeph>activateHandler()</codeph> and <codeph>resizeHandler()</codeph> methods.</li>
 
  <li>The <codeph>activateHandler()</codeph> method runs when the left mouse button is clicked.</li>
 
  <li>The <codeph>resizeHandler()</codeph> method runs when the stage is resized.</li>
 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.Event;

    public class StageExample extends Sprite {

        public function StageExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.addEventListener(Event.ACTIVATE, activateHandler);
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function activateHandler(event:Event):void {
            trace("activateHandler: " + event);
        }

        private function resizeHandler(event:Event):void {
            trace("resizeHandler: " + event);
            trace("stageWidth: " + stage.stageWidth + " stageHeight: " + stage.stageHeight);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><adobeApiEvent id="flash.display:Stage_flash.events.FullScreenEvent.FULL_SCREEN_fullScreen"><apiName>fullScreen</apiName><shortdesc>
 Dispatched when the Stage object enters, or leaves, full-screen mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FullScreenEvent.FULL_SCREEN</apiEventType><adobeApiEventClassifier>flash.events.FullScreenEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the Stage object enters, or leaves, full-screen mode. A change
 in full-screen mode can be initiated through ActionScript, or the user invoking a keyboard shortcut,
 or if the current focus leaves the full-screen window.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Dispatched when the scaleMode property of the Stage object is set to 
 StageScaleMode.NO_SCALE and the SWF file is resized.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the <codeph>scaleMode</codeph> property of the Stage object is set to 
 <codeph>StageScaleMode.NO_SCALE</codeph> and the SWF file is resized. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.MOUSE_LEAVE_mouseLeave"><apiName>mouseLeave</apiName><shortdesc>
 Dispatched by the Stage object when the mouse pointer moves out of the  
 stage area.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.MOUSE_LEAVE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by the Stage object when the mouse pointer moves out of the  
 stage area. If the mouse button is pressed, the event is not dispatched.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:Stage:addChild"><apiName>addChild</apiName><shortdesc>
	 
     Adds a child DisplayObject instance to this DisplayObjectContainer instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>addChild()</codeph> method of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>The DisplayObject instance that you pass in the 
	 <codeph>child</codeph> parameter.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The DisplayObject instance to add as a child of this DisplayObjectContainer instance.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
     Adds a child DisplayObject instance to this DisplayObjectContainer instance. The child is added
     to the front (top) of all other children in this DisplayObjectContainer instance. (To add a child to a 
     specific index position, use the <codeph>addChildAt()</codeph> method.)
     
	 <p>If you add a child object that already has a different display object container as
	 a parent, the object is removed from the child list of the other display object container. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 
	 Adds a child DisplayObject instance to this DisplayObjectContainer 
	 instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>addChildAt()</codeph> method of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>The DisplayObject instance that you pass in the 
	 <codeph>child</codeph> parameter.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The DisplayObject instance to add as a child of this 
	 DisplayObjectContainer instance.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The index position to which the child is added. If you specify a 
	 currently occupied index position, the child object that exists at that position and all
	 higher positions are moved up one position in the child list. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Adds a child DisplayObject instance to this DisplayObjectContainer 
	 instance.  The child is added
	 at the index position specified. An index of 0 represents the back (bottom) 
	 of the display list for this DisplayObjectContainer object.
	 
	 <p>For example, the following example shows three display objects, labeled a, b, and c, at
	 index positions 0, 2, and 1, respectively:</p>
	 
	 <p><adobeimage alt="b over c over a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>If you add a child object that already has a different display object container as
	 a parent, the object is removed from the child list of the other display object container. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	 
	Registers an event listener object with an EventDispatcher object so that the listener 
	receives notification of an event.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>addEventListener</codeph> method of a Stage object throws an exception for 
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this situation, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The type of event.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>The listener function that processes the event. This function must accept
    an Event object as its only parameter and must return nothing<ph platform="actionscript">, as this example shows:</ph>
	<ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>The function can have any name.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">This parameter applies to display objects in the
	ActionScript 3.0 display list architecture, used by SWF content.</ph>
	
	<ph platform="actionscript">Determines whether the listener works in the capture phase or the 
	target and bubbling phases. If <codeph>useCapture</codeph> is set to <codeph>true</codeph>, 
	the listener processes the event only during the capture phase and not in the 
	target or bubbling phase. If <codeph>useCapture</codeph> is <codeph>false</codeph>, the
	listener processes the event only during the target or bubbling phase. To listen for
	the event in all three phases, call <codeph>addEventListener</codeph> twice, once with 
	<codeph>useCapture</codeph> set to <codeph>true</codeph>, then again with
	<codeph>useCapture</codeph> set to <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>The priority level of the event listener. The priority is designated by
	a signed 32-bit integer. The higher the number, the higher the priority. All listeners
	with priority <i>n</i> are processed before listeners of priority <i>n</i>-1. If two
	or more listeners share the same priority, they are processed in the order in which they
	were added. The default priority is 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Determines whether the reference to the listener is strong or
	weak. A strong reference (the default) prevents your listener from being garbage-collected.
    A weak reference does not. <p>Class-level member functions are not subject to garbage 
    collection, so you can set <codeph>useWeakReference</codeph> to <codeph>true</codeph> for 
    class-level member functions without subjecting them to garbage collection. If you set
    <codeph>useWeakReference</codeph> to <codeph>true</codeph> for a listener that is a nested inner 
    function, the function will be garbage-collected and no longer persistent. If you create 
    references to the inner function (save it in another variable) then it is not 
    garbage-collected and stays persistent.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Registers an event listener object with an EventDispatcher object so that the listener 
	receives notification of an event. <ph platform="actionscript">You can register event listeners on all nodes in the 
	display list for a specific type of event, phase, and priority.</ph>
	
	<p platform="javascript">JavaScript code in the AIR runtime uses this method to register
	event listeners for events defined by the AIR APIs. For other JavaScript events (such as the <codeph>onload</codeph>
	event of the DOM <codeph>body</codeph> object), you can use standard event handling techniques, as you would 
	for content running in the browser.</p>
	
	<p>After you successfully register an event listener, you cannot change its priority
	through additional calls to <codeph>addEventListener()</codeph>. To change a listener's
	priority, you must first call <codeph>removeListener()</codeph>. Then you can register the
	listener again with the new priority level. </p>
	
	<p>Keep in mind that after the listener is registered, subsequent calls to
	<codeph>addEventListener()</codeph> with a different <codeph>type</codeph> or
	<codeph>useCapture</codeph> value result in the creation of a separate listener registration. 
	<ph platform="actionscript">For example, if you first register a listener with <codeph>useCapture</codeph> set to 
	<codeph>true</codeph>, it listens only during the capture phase. If you call 
	<codeph>addEventListener()</codeph> again using the same listener object, but with
	<codeph>useCapture</codeph> set to <codeph>false</codeph>, you have two separate listeners: one
	that listens during the capture phase and another that listens during the target and
	bubbling phases.</ph>
	</p>
	
	<p platform="actionscript">You cannot register an event listener for only the target phase or the bubbling 
	phase. Those phases are coupled during registration because bubbling 
	applies only to the ancestors of the target node.</p>
	
	<p>If you no longer need an event listener, remove it by calling 
	<codeph>removeEventListener()</codeph>, or memory problems could result. Event listeners are not automatically
	removed from memory because the garbage
	collector does not remove the listener as long as the dispatching object exists (unless the <codeph>useWeakReference</codeph>
	parameter is set to <codeph>true</codeph>).</p>
		
	<p>Copying an EventDispatcher instance does not copy the event listeners attached to it. 
	(If your newly created node needs an event listener, you must attach the listener after
    creating the node.) However, if you move an EventDispatcher instance, the event listeners 
    attached to it move along with it.</p>
	
	
	<p platform="actionscript">If the event listener is being registered on a node while an event is being processed
	on this node, the event listener is not triggered during the current phase but can be 
	triggered during a later phase in the event flow, such as the bubbling phase.</p>
	
	<p platform="actionscript">If an event listener is removed from a node while an event is being processed on the node,
	it is still triggered by the current actions. After it is removed, the event listener is
	never invoked again (unless registered again for future processing). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:assignFocus"><apiName>assignFocus</apiName><shortdesc>
	 Sets keyboard focus to the interactive object specified by objectToFocus, with 
	 the focus direction specified by the direction parameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If focus cannot be set to the target or direction is not a valid type.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>objectToFocus</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>The object to focus, or <codeph>null</codeph> to clear the focus from 
	 any element on the Stage.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>direction</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The direction from which <codeph>objectToFocus</codeph> is being focused. 
	 Valid values are enumerated as constants in the FocusDirection class.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Assigns keyboard focus to an interactive object and specifies the direction focus is coming from.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Sets keyboard focus to the interactive object specified by <codeph>objectToFocus</codeph>, with 
	 the focus direction specified by the <codeph>direction</codeph> parameter. 
	 
	 <p>The concept of focus direction must be defined by the application (or application framework).
	 No intrinsic focus sorting of interactive objects exists, although you could use other available
	 properties to establish an ordering principle. For example, you could sort interactive objects
	 according to their positions on the Stage or in the display list. Calling <codeph>assignFocus()</codeph>
	 is equivalent to setting the <codeph>Stage.focus</codeph> property, with the additional ability to 
	 indicate the direction from which the focus is being set.</p>
	 
	 <p>The <codeph>objectToFocus</codeph> will dispatch a <codeph>focusIn</codeph> event on recieving focus.
	 The <codeph>direction</codeph> property of the FocusEvent object will report the setting of the
	 <codeph>direction</codeph> parameter.</p>
	 
	 <p>If you assign an HTMLLoader object to the <codeph>objectToFocus</codeph> parameter, the HTMLLoader
	 object selects the appropriate focusable object in the HTML DOM, based on the <codeph>direction</codeph> 
	 parameter value. If it is <codeph>FocusDirection.BOTTOM</codeph>, the focusable object in the HTML  
	 DOM at the end of the reading order is given focus. If it is <codeph>FocusDirection.TOP</codeph>, 
	 the focusable object in the HTML DOM at the beginning of the reading order is given focus. 
	 If it is <codeph>NONE</codeph>, the HTMLLoader object receives focus without changing its 
	 current focused element.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link><link href="flash.display.xml#FocusDirection"><linktext>flash.display.FocusDirection</linktext></link><link href="flash.events.xml#FocusEvent"><linktext>flash.events.FocusEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
	 
	Dispatches an event into the event flow.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>dispatchEvent()</codeph> method of a Stage object throws an exception for 
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>A value of <codeph>true</codeph> if the event was successfully dispatched. A value of <codeph>false</codeph> indicates failure or that <codeph>preventDefault()</codeph> was called 
	on the event.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>The Event object that is dispatched into the event flow.
	If the event is being redispatched, a clone of the event is created automatically.
	After an event is dispatched, its <codeph>target</codeph> property cannot be changed, so you
	must create a new copy of the event for redispatching to work.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Dispatches an event into the event flow. The event target is the EventDispatcher 
	object upon which the <codeph>dispatchEvent()</codeph> method is called.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:hasEventListener"><apiName>hasEventListener</apiName><shortdesc>
	 
	Checks whether the EventDispatcher object has any listeners registered for a specific type 
	of event.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>hasEventListener()</codeph> method of a Stage object throws an exception for 
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>A value of <codeph>true</codeph> if a listener of the specified type is registered; 
	<codeph>false</codeph> otherwise.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The type of event.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Checks whether the EventDispatcher object has any listeners registered for a specific type 
	of event. This allows you to determine where an EventDispatcher object has altered
	handling of an event type in the event flow hierarchy. To determine whether a specific
	event type actually triggers an event listener, use <codeph>willTrigger()</codeph>.
	
	<p>The difference between <codeph>hasEventListener()</codeph> and <codeph>willTrigger()</codeph> 
	is that <codeph>hasEventListener()</codeph> examines only the object to 
	which it belongs, whereas <codeph>willTrigger()</codeph> examines the entire 
    event flow for the event specified by the <codeph>type</codeph> parameter.
	<ph platform="javascript">The event flow applies to the ActionScript 3.0
	display list, used in SWF content.</ph>
	</p>
	
	<p>When <codeph>hasEventListener()</codeph> is called from a LoaderInfo object, only the 
	listeners that the caller can access are considered.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:invalidate"><apiName>invalidate</apiName><shortdesc>
     Calling the invalidate() method signals Flash Player to alert display objects 
     on the next opportunity it has to render the display list (for example, when the playhead 
     advances to a new frame).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Signals Flash Player to update properties of display objects on the next opportunity 
	 it has to refresh the Stage.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Calling the <codeph>invalidate()</codeph> method signals Flash Player to alert display objects 
     on the next opportunity it has to render the display list (for example, when the playhead 
     advances to a new frame). After you call the <codeph>invalidate()</codeph> method, when the display 
     list is next rendered, Flash Player sends a <codeph>render</codeph> event to each display object that has 
     registered to listen for the <codeph>render</codeph> event. You must call the <codeph>invalidate()</codeph> 
     method each time you want Flash Player to send <codeph>render</codeph> events. 
     
     <p>The <codeph>render</codeph> event gives you an opportunity to make changes to the display list 
     immediately before it is actually rendered. This lets you defer updates to the display list until the 
     latest opportunity. This can increase performance by eliminating unnecessary screen updates.</p>
     
     <p>The <codeph>render</codeph> event is dispatched only to display objects that are in the same 
     security domain as the code that calls the <codeph>stage.invalidate()</codeph> method, 
     or to display objects from a security domain that has been granted permission via the 
     <codeph>Security.allowDomain()</codeph> method.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/RENDER"><linktext>flash.events.Event.RENDER</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:isFocusInaccessible"><apiName>isFocusInaccessible</apiName><shortdesc>
	 Determines whether the Stage.focus property returns null for 
	 security reasons.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> if the object that has focus belongs to a security sandbox to which
	 the SWF file does not have access.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Determines whether the <codeph>Stage.focus</codeph> property would return <codeph>null</codeph> 
	 for security reasons.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Determines whether the <codeph>Stage.focus</codeph> property returns <codeph>null</codeph> for 
	 security reasons.
	 In other words, <codeph>isFocusInaccessible</codeph> returns <codeph>true</codeph> if the 
	 object that has focus belongs to a security sandbox to which the SWF file does not have access.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 
	 Removes a child DisplayObject from the specified index position in the child list of 
	 the DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>removeChildAt()</codeph> method of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the object to be removed. To avoid this, 
	 the owner of that object can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>The DisplayObject instance that was removed.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The child index of the DisplayObject to remove.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Removes a child DisplayObject from the specified <codeph>index</codeph> position in the child list of 
	 the DisplayObjectContainer. The <codeph>parent</codeph> property of the removed child is set to 
	 <codeph>null</codeph>, and the object is garbage collected if no other references to the child exist. The index  
	 positions of any display objects above the child in the DisplayObjectContainer are decreased by 1.
	 
	 <p>The garbage collector reallocates unused memory space. When a variable or
	 object is no longer actively referenced or stored somewhere, the garbage collector sweeps 
	 through and wipes out the memory space it used to occupy if no other references to it exist.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	 
	Changes the  position of an existing child in the display object container.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>setChildIndex()</codeph> method of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The child DisplayObject instance for which you want to change
     the index number.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The resulting index number for the <codeph>child</codeph> display object.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Changes the  position of an existing child in the display object container.
	This affects the layering of child objects. For example, the following example shows three 
	display objects, labeled a, b, and c, at index positions 0, 1, and 2, respectively:
	
	<p><adobeimage alt="c over b over a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>When you use the <codeph>setChildIndex()</codeph> method and specify an index position
	that is already occupied, the only positions that change are those in between the display object's former and new position. 
	All others will stay the same. 
	If a child is moved to an index LOWER than its current index, all children in between will INCREASE by 1 for their index reference.
	If a child is moved to an index HIGHER than its current index, all children in between will DECREASE by 1 for their index reference.
	For example, if the display object container
	in the previous example is named <codeph>container</codeph>, you can swap the position 
	of the display objects labeled a and b by calling the following code:</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>This code results in the following arrangement of objects:</p>
	
    <p><adobeimage alt="c over a over b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 
	 Swaps the z-order (front-to-back order) of the child objects at the two specified index positions in the 
	 child list.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>swapChildrenAt()</codeph> method of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the owner of either of the objects to be swapped. To avoid this, 
	 the object owners can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The index position of the first child object.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The index position of the second child object.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Swaps the z-order (front-to-back order) of the child objects at the two specified index positions in the 
	 child list. All other child objects in the display object container remain in the same index positions.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:willTrigger"><apiName>willTrigger</apiName><shortdesc>
	 
	Checks whether an event listener is registered with this EventDispatcher object or any of 
	its ancestors for the specified event type.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Calling the <codeph>willTrigger()</codeph> method of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>A value of <codeph>true</codeph> if a listener of the specified type will be triggered; <codeph>false</codeph> otherwise.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>The type of event.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Checks whether an event listener is registered with this EventDispatcher object or any of 
	its ancestors for the specified event type. This method returns <codeph>true</codeph> if an 
	event listener is triggered during any phase of the event flow when an event of the 
	specified type is dispatched to this EventDispatcher object or any of its descendants.
	
	<p>The difference between the <codeph>hasEventListener()</codeph> and the <codeph>willTrigger()</codeph> 
	methods is that <codeph>hasEventListener()</codeph> examines only the object to which it belongs, 
	whereas the <codeph>willTrigger()</codeph> method examines the entire event flow for the event specified by the
    <codeph>type</codeph> parameter. <ph platform="javascript">The event flow applies to the ActionScript 3.0
	display list, used in SWF content.</ph></p>
	
	<p>When <codeph>willTrigger()</codeph> is called from a LoaderInfo object, only the 
	listeners that the caller can access are considered.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:Stage:align:get"><apiName>align</apiName><shortdesc>
	 A value from the StageAlign class that specifies the alignment of the stage in
	 Flash Player or the browser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 A value from the StageAlign class that specifies the alignment of the stage in
	 Flash Player or the browser. The following are valid values:
	 
	 <p>
	 <adobetable class="innertable">
	 	
	 	 
	 	 
	 	 
	 	 
	 	  
	 	  
	 	  
	 	  
	 	 
	 <tgroup cols="3"><thead><row><entry>Value</entry><entry>Vertical Alignment</entry><entry>Horizontal</entry></row></thead><tbody><row><entry><codeph>StageAlign.TOP</codeph></entry>
	 	 <entry>Top</entry>
	 	 <entry>Center</entry>
	 	 </row><row><entry><codeph>StageAlign.BOTTOM</codeph></entry>
	 	 <entry>Bottom</entry>
	 	 <entry>Center</entry>
	 	 </row><row><entry><codeph>StageAlign.LEFT</codeph></entry>
	 	 <entry>Center</entry>
	 	 <entry>Left</entry>
	 	 </row><row><entry><codeph>StageAlign.RIGHT</codeph></entry>
	 	 <entry>Center</entry>
	 	 <entry>Right</entry>
	 	 </row><row><entry><codeph>StageAlign.TOP_LEFT</codeph></entry>
	 	  <entry>Top</entry>
	 	  <entry>Left</entry>
	 	  </row><row><entry><codeph>StageAlign.TOP_RIGHT</codeph></entry>
	 	  <entry>Top</entry>
	 	  <entry>Right</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_LEFT</codeph></entry>
	 	  <entry>Bottom</entry>
	 	  <entry>Left</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_RIGHT</codeph></entry>
	 	  <entry>Bottom</entry>
	 	  <entry>Right</entry>
	 	  </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>The <codeph>align</codeph> property is only available to an object that is in the same security sandbox 
	 as the Stage owner (the main SWF file).
	  To avoid this, the Stage owner can grant permission to the domain of the 
	 calling object by calling the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.alowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageAlign"><linktext>flash.display.StageAlign</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrection:get"><apiName>colorCorrection</apiName><shortdesc>
 	 Controls Flash Player color correction for displays.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Attempts to use monitor color correction
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
 	 Controls Flash Player color correction for displays.
     Color correction works only if the main monitor is assigned a valid ICC color profile, which specifies 
     the device's particular color attributes.
     By default, Flash Player tries to match the color correction of its host (usually a browser).
     
     <p>Use the <codeph>Stage.colorCorrectionSupport</codeph> property
     to determine if color correction is available on the current system and the default state. 
.    If color correction is available, all colors on the stage are assumed to be in 
     the sRGB color space, which is the most standard color space. Source profiles of input devices are not considered during color correction. 
     No input color correction is applied; only the stage output is mapped to the main 
     monitor's ICC color profile.</p>
      
     <p>In general, the benefits to activating color management include predictable and consistent color, better conversion, 
     accurate proofing and more efficient cross-media output. Be aware, though, that color management does not provide 
     perfect conversions due to devices having a different gamut from each other or original images. 
     Nor does color management eliminate the need for custom or edited profiles. 
     Color profiles are dependent on browsers, operating systems (OS), OS extensions, output devices, and application support.</p>
     
     <p>Applying color correction degrades Flash Player performance. 
     Flash Player's color correction is a document style color correction because
     all SWF movies are considered documents with implicit sRGB profiles. 
     Use the <codeph>Stage.colorCorrectionSupport</codeph> property to tell Flash Player 
     to correct colors as best as it can when displaying the SWF (document) to the display color space.
     Flash Player only compensates for differences between monitors, not for differences between input devices (camera/scanner/etc.).
     </p>
     
 	 <p>The three possible values are strings with corresponding constants in the flash.display.ColorCorrection class:</p>
 	  <ul><li><codeph>"default"</codeph>: Use the same color correction as the host system.</li> 
 	 <li><codeph>"on"</codeph>: Always perform color correction.</li>
 	 <li><codeph>"off"</codeph>: Never perform color correction.</li>
 	 </ul>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrection"><linktext>flash.display.ColorCorrection</linktext></link><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>colorCorrectionSupport</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrectionSupport:get"><apiName>colorCorrectionSupport</apiName><shortdesc>
      Specifies whether Flash Player is running on an operating system that supports 
      color correction and whether the color profile of the main (primary) 
      monitor can be read and understood by Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>ColorCorrection
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
      Specifies whether Flash Player is running on an operating system that supports 
      color correction and whether the color profile of the main (primary) 
      monitor can be read and understood by Flash Player. This property also returns the default state
      of color correction on the host system (usually the browser).
      Currently the return values can be:
 	  <p>The three possible values are strings with corresponding constants in the flash.display.ColorCorrectionSupport class:</p>
 	   <ul><li><codeph>"unsupported"</codeph>: Color correction is not available.</li> 
 	  <li><codeph>"defaultOn"</codeph>: Always performs color correction.</li>
 	  <li><codeph>"defaultOff"</codeph>: Never performs color correction.</li>
 	  </ul>      
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrectionSupport"><linktext>flash.display.ColorCorrectionSupport</linktext></link><link href="flash.display.xml#Stage/colorCorrection"><linktext>colorCorrection</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:displayState:get"><apiName>displayState</apiName><shortdesc>
	 A value from the StageDisplayState class that specifies which display state to use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Calling the <codeph>displayState</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 Trying to set the <codeph>displayState</codeph> property while the settings dialog is displayed, without a user response, or
     if the <codeph>param</codeph> or <codeph>embed</codeph> HTML tag's <codeph>allowFullScreen</codeph> attribute is not set to 
     <codeph>true</codeph> throws a security error.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 A value from the StageDisplayState class that specifies which display state to use. The following
	 are valid values: 
	 
	 <ul>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN</codeph> Sets AIR application or Flash Player to expand the 
	 stage over the user's entire screen, with keyboard input disabled.</li>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> Sets the AIR application to expand the 
	 stage over the user's entire screen, with keyboard input allowed. 
	 <ph platform="actionscript">(Not available for content running in Flash Player.)</ph></li>
	 
     <li><codeph>StageDisplayState.NORMAL</codeph> Sets the player back to the standard stage display mode.</li>
	 
	 </ul> 
	 
     <p platform="actionscript">The scaling behavior of the movie in full-screen mode is determined by the <codeph>scaleMode</codeph> 
     setting (set using the <codeph>Stage.scaleMode</codeph> property or the SWF file's <codeph>embed</codeph> 
     tag settings in the HTML file). If the <codeph>scaleMode</codeph> property is set to <codeph>noScale</codeph> 
     while the application transitions to full-screen mode, the Stage <codeph>width</codeph> and <codeph>height</codeph> 
     properties are updated, and the Stage the <codeph>resize</codeph> event.</p>
     
     <p platform="actionscript">The following restrictions apply to SWF files that play within an HTML page (not those using the stand-alone 
	 Flash Player or not running in the AIR runtime):</p>
     
     <ul platform="actionscript">
	 
	 <li>To enable full-screen mode, add the <codeph>allowFullScreen</codeph> parameter to the <codeph>object</codeph> 
	 and <codeph>embed</codeph> tags in the HTML page that includes the SWF file, with <codeph>allowFullScreen</codeph> set 
	 to <codeph>"true"</codeph>, as shown in the following example:
	 
	 <codeblock>&lt;param name="allowFullScreen" value="true" /&gt;
	        ...
	 &lt;embed src="example.swf" allowFullScreen="true" ... &gt;</codeblock>
	 
	 <p>An HTML page may also use a script to generate SWF-embedding tags. You need to alter the script 
	 so that it inserts the proper <codeph>allowFullScreen</codeph> settings. HTML pages generated by Flash and  
	 Flex Builder use the <codeph>AC_FL_RunContent()</codeph> function to embed references to SWF files, and you 
	 need to add the <codeph>allowFullScreen</codeph> parameter settings, as in the following:</p>
	 
	 <codeblock>AC_FL_RunContent( ... "allowFullScreen", "true", ... )</codeblock></li>
	 
     <li>Full-screen mode is initiated in response to a mouse click or key press by the user; the movie cannot change 
     <codeph>Stage.displayState</codeph> without user input. Flash Player restricts keyboard input  in full-screen mode. 
     Acceptable keys include keyboard shortcuts that terminate full-screen mode and non-printing keys such as arrows, space, Shift,
     and Tab keys. Keyboard shortcuts that terminate full-screen mode are: Escape (Windows, Linux, and Mac), Control+W (Windows), 
     Command+W (Mac), and Alt+F4.
     <p>A Flash Player dialog box appears over the movie when users enter full-screen mode to inform the users they are in 
     full-screen mode and that they can press the Escape key to end full-screen mode.</p></li>
     <li>Starting with Flash Player 9.0.115.0, full-screen works the same in windowless mode as it does in window mode. 
     If you set the Window Mode (<codeph>wmode</codeph> in the HTML) to Opaque Windowless (<codeph>opaque</codeph>) 
     or Transparent Windowless (<codeph>transparent</codeph>), full-screen can be initiated, 
	 but the full-screen window will always be opaque.</li> 
	 
     </ul>
     
 	 <p platform="actionscript">These restrictions are <i>not</i> present for SWF content running in the 
	 stand-alone Flash Player or in AIR. AIR supports an interactive full-screen mode which allows keyboard input.</p>  
	 
	 <p>For <ph platform="actionscript">AIR</ph> content running in full-screen mode, the system screen saver
	 and power saving options are disabled while video content is playing and until until either the video stops 
	 or full-screen mode is exited.</p>
 	 
	 <p>On Linux, setting <codeph>displayState</codeph> to <codeph>StageDisplayState.FULL_SCREEN</codeph> or
	 <codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> is an asynchronous operation.</p>
    
	 </apiDesc><example conref="examples\StageExample2.as"> The following example creates an interactive demonstration of 
 how to create a fullscreen experience by modifying the <codeph>displayState</codeph>
 property. <p><b>Note</b>: Fullscreen can only be triggered in certain situations, such as if the
 user has clicked or pressed a key, due to security restrictions. When run in a 
 browser, the allowFullScreen property must be set to true.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Stage;
    import flash.events.*;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.media.Video;
    
    public class FullScreenExample extends Sprite
    {
        private var videoURL:String = "testVideo.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var video:Video;        
        
        public function FullScreenExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
            
            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK,toggleFullScreen);
        }        
        
        private function toggleFullScreen(event:MouseEvent):void {
            switch(stage.displayState) {
                case "normal":
                    stage.displayState = "fullScreen";    
                    break;
                case "fullScreen":
                default:
                    stage.displayState = "normal";    
                    break;
            }
        }    
        
        // Video related:
        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }
        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);

            video = new Video(stage.stageWidth,stage.stageHeight);
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:focus:get"><apiName>focus</apiName><shortdesc>
	 The interactive object with keyboard focus; or null if focus is not set 
	 or if the focused object belongs to a security sandbox to which the calling object does not 
	 have access.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier><apiException><apiDesc>Throws an error if focus cannot be set to the target.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>The object with keyboard focus.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 The interactive object with keyboard focus; or <codeph>null</codeph> if focus is not set 
	 or if the focused object belongs to a security sandbox to which the calling object does not 
	 have access.
	 
	 </apiDesc><example conref="Stage.focus.as"> The following sets the initial focus to the text field <codeph>myTF</codeph> so the user can start typing without having to click anything. 
 If you test this code within the authoring tool interface, you can only have access to a few keys because the host (browser or tool) interprets most 
 key presses first. To see this example work as intended, compile it and run the SWF file.
<codeblock>
var myTF:TextField = new TextField();
myTF.border =true;
myTF.type = TextFieldType.INPUT;

addChild(myTF);
stage.focus= myTF;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Stage:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 Gets and sets the frame rate of the stage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Calling the <codeph>frameRate</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Gets and sets the frame rate of the stage. The frame rate is defined as frames per second. 
	 By default the rate is set to the frame rate of the first SWF file loaded. Valid range for the frame rate 
	 is from 0.01 to 1000 frames per second. 
	 
	 <p><codeph>Note:</codeph> An application might not be able to follow
	 high frame rate settings, either because the target platform is not fast enough or the player is
	 synchronized to the vertical blank timing of the display device (usually 60 Hz on LCD devices).
	 In some cases, a target platform might also choose to lower the maximum frame rate if it 
	 anticipates high CPU usage.</p>
	 
	 <p>For content running in Adobe AIR, setting the <codeph>frameRate</codeph> property of one Stage
	 object changes the frame rate for all Stage objects (used by different NativeWindow objects).
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:fullScreenHeight:get"><apiName>fullScreenHeight</apiName><shortdesc>
  Returns the height of the monitor that will be used when going to full screen size, if that state 
  is entered immediately.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Returns the height of the monitor that will be used when going to full screen size, if that state 
  is entered immediately. If the user has multiple monitors, the monitor that's used is the 
  monitor that most of the stage is on at the time.
  
  <p><b>Note</b>: If the user has the opportunity to move the browser from one 
  monitor to another between retrieving the value and going to full screen
  size, the value could be incorrect. If you retrieve the value in an event handler that
  sets <codeph>Stage.displayState</codeph> to <codeph>StageDisplayState.FULL_SCREEN</codeph>, the value will be
  correct.</p>
  
  <p>This is the pixel height of the monitor and is the same as the 
  stage height would be if <codeph>Stage.align</codeph> is set to <codeph>StageAlign.TOP_LEFT</codeph>
  and <codeph>Stage.scaleMode</codeph> is set to <codeph>StageScaleMode.NO_SCALE</codeph>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> This example creates a green rectangle the size of the stage and places a red square on it that
 it activates as a button. Clicking the red square triggers the <codeph>enterFullScreen()</codeph> event handler, 
 which sets the <codeph>fullScreenSourceRect</codeph> property and enters full screen mode. To set the
 <codeph>fullScreenSourceRect</codeph> property, the event handler starts with the location and dimensions of the 
 red square. It then compares the aspect ratio (width divided by height) of the red square to the 
 aspect ratio of the stage at full screen width and height so that it can expand the rectangle 
 (<codeph>fullScreenSourceRect</codeph>) to match the screen's aspect ratio. The result is that the red 
 square occupies the entire height of the monitor with the green background visible on each side.  
 If the aspect ratio was not matched, the stage background color, which is white by default, would show 
 on each side instead of the green background.
 
 <p><b>Note</b>: Test this example in the browser. In the Flash Publish Settings dialog, on the HTML tab, 
 select the template Flash Only - Allow Full Screen. Specify the Flash Player version 9.0.115.0, and make sure 
 the Flash and HTML formats are selected on the Formats tab. Then publish and open the resulting HTML file in 
 the browser.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio &gt; screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/fullScreenWidth"><linktext>fullScreenWidth</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenSourceRect:get"><apiName>fullScreenSourceRect</apiName><shortdesc>
  Sets Flash Player to scale a specific region of the stage to full-screen mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
  Sets Flash Player to scale a specific region of the stage to full-screen mode. 
  If available, Flash Player scales in hardware, which uses the graphics and video card on a user's computer,
  and generally displays content more quickly than software scaling.
  
  <p>When this property is set to a valid rectangle and the <codeph>displayState</codeph> property is set to full-screen mode, 
  Flash Player scales the specified area. The actual Stage size in pixels within ActionScript does not change.
  Flash Player enforces a minimum limit for the size of the rectangle to accommodate the standard "Press Esc to exit full-screen mode" message.
  This limit is usually around 260 by 30 pixels but can vary on platform and Flash Player version.</p>
  
  <p>This property can only be set when Flash Player is not in full-screen mode. 
  To use this property correctly, set this property first, then set the <codeph>displayState</codeph> property to full-screen mode, as shown in the code examples.</p>
  <p>To enable scaling, set the <codeph>fullScreenSourceRect</codeph> property to a rectangle object:</p>
  <codeblock>  
  // valid, will enable hardware scaling
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240); 
  </codeblock>
  
  <p>To disable scaling, set the <codeph>fullScreenSourceRect=null</codeph> in ActionScript 3.0, and <codeph>undefined</codeph> in ActionScript 2.0.</p>
  <codeblock>
  stage.fullScreenSourceRect = null;
  </codeblock>
  
  <p>The end user also can select within Flash Player Display Settings to turn off hardware scaling, which is enabled by default. 
  For more information, see <xref href="http://www.adobe.com/go/display_settings" scope="external">www.adobe.com/go/display_settings</xref>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenSourceRect.1.as"> To take advantage of hardware scaling, you set the whole stage or part of the stage to full-screen mode.
 The following ActionScript 3.0 code sets the whole stage to full-screen mode:
<codeblock>
 
import flash.geom.*; 
{
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240);
  stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example><example conref="examples\Stage_fullScreenSourceRectExample2.as"> In the following example, the user can switch between playing a video in full or normal
 screen mode by clicking on the stage. If the SWF for this example is running in Flash Player 9.0.115.0
 or later, then it will use hardware acceleration to improve the full-screen scaling of the display.
  
 <p>Before using the full-screen mode with hardware scaling, the following conditions must be met:</p>
 
 <ol>
 <li>Flash Player version 9.0.115.0 or later is needed, 
 as well as an authoring tool that supports it.</li>
 <li>HTML templates need to be modified to support full screen. The <codeph>allowFullScreen</codeph>
 attribute must be set to <codeph>true</codeph> for the <codeph>object</codeph> and <codeph>embed</codeph> tag. 
 (The scripts that generate SWF-embedding tags must also allow for full screen.) For sample of
 files that can be used for Flex Builder, see the article, 
 <xref href="http://www.adobe.com/devnet/flashplayer/articles/full_screen_mode.html" scope="external">Exploring full-screen 
 mode in Flash Player 9</xref>.</li>
 <li>Your application must have permission and access to an FLV video file. In this example, it is assumed 
 that Flash Video (FLV) file is in the same directory as the SWF file.</li>
 <li>The user must allow access to full screen.</li>
 <li>For additional information on hardware scaling, see the article 
 <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">Exploring Flash Player support for high-definition H.264 video and AAC audio</xref> for Flash Player.</li>
 </ol>
 
 <p>An FLV file is loaded using NetConnection and NetStream objects. Since the FLV file 
 is in the same directory as the SWF file and will connect via HTTP, the <codeph>NetConnection.connect()</codeph> 
 method's parameter is set to <codeph>null</codeph>. The <codeph>connect</codeph> NetConnection object 
 reports its status by dispatching a <codeph>netStatus</codeph> event which invokes 
 the <codeph>netStatusHandler()</codeph> method. The <codeph>netStatusHandler()</codeph> method
 checks if the connection was successful and invokes <codeph>connectStream()</codeph> method,
 which creates a NetStream object that takes the NetConnection object as a parameter.
 It also creates a video object and attached the NetStream object to the video object.
 The video object then is added to the display list and the stream is set to play. Since 
 the FLV video file does not contain metadata or cue point information, an <codeph>AsyncError</codeph> 
 event will be dispatched. A listener must be set up to handle the event. Here the listener
 is set up and it ignores the event. Another listener for <codeph>netStatus</codeph> event is also
 set up for the NetStream object. It will display an error message if the stream was not found.
 (Note that <codeph>netStatusHandler()</codeph> could be used to handle any number of different 
 status information reported for the stream or connection.)</p>
 
 <p>When the properties and methods of a loaded SWF file are accessible, the 
 <codeph>createMouseListener()</codeph> method is invoked. It sets up an event listener for when 
 the mouse is clicked on the stage. The <codeph>toggleFullScreen()</codeph> method checks if
 the display state is in the full or normal screen mode. If it is normal, the size of the video object
 is set to the size of the video stream. The <codeph>fullScreenSourceRect</codeph> property is set 
 to a rectangle matching the dimensions of the video object. Then the <codeph>Stage.displayMode</codeph> 
 property is set to full screen, which causes the video in the source rectangle to expand to fill 
 the full screen area. If system requirements are met, the machine's graphics hardware will be 
 used to improve the performance of the full-screen video rendering and the display state is set 
 to full-screen mode. In order to catch any security error that may occur while switching to 
 the full-screen mode, a <codeph>try...catch</codeph> is used. (Note that the display state must be 
 set to full-screen mode after the <codeph>fullScreenSourceRect</codeph> property is set.) Before 
 switching to the normal-screen mode, the video object's width and height are set back to the saved 
 original video object's width and height. Otherwise, the changes made to the video object for 
 the full-screen mode will determine the width and height.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageDisplayState;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.NetStatusEvent;
    import flash.events.AsyncErrorEvent;
    import flash.events.SecurityErrorEvent;
    import flash.events.MouseEvent;
    import flash.events.Event;
    import flash.geom.Rectangle;
    
    public class Stage_fullScreenSourceRectExample2 extends Sprite {
        private var videoURL:String = "testVideo1.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var myVideo:Video;        
        private    var savedWidth:uint;
        private    var savedHeight:uint;
 
        public function Stage_fullScreenSourceRectExample2() {
    
            connection = new NetConnection();
             connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);    
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);

            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK, toggleFullScreen);
        }        

        private function toggleFullScreen(event:MouseEvent):void {

            if(stage.displayState == StageDisplayState.NORMAL) {
                myVideo.width = myVideo.videoWidth;
                  myVideo.height = myVideo.videoHeight;

                try {
                    stage.fullScreenSourceRect = new Rectangle(myVideo.x, myVideo.y, 
                                                           myVideo.width, myVideo.height);
                     stage.displayState = StageDisplayState.FULL_SCREEN;

                 } catch (e:SecurityError) {
                     trace ("A security error occurred while switching to full screen: " + event);
                    myVideo.width = savedWidth;
                    myVideo.height = savedHeight;
                 }

            }else {
                myVideo.width = savedWidth;
                myVideo.height = savedHeight;
                stage.displayState = StageDisplayState.NORMAL;
            }
        }    

       private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace ("Unable to locate video: " + videoURL);
                    break;
            }
        }

       private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);     

             myVideo = new Video();
            myVideo.attachNetStream(stream);
            stream.play(videoURL);

            savedWidth = myVideo.width;
            savedHeight = myVideo.height;

            addChild(myVideo);
        }
       
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);    
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/displayState"><linktext>Stage.displayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenWidth:get"><apiName>fullScreenWidth</apiName><shortdesc>
  Returns the width of the monitor that will be used when going to full screen size, if that state 
  is entered immediately.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Returns the width of the monitor that will be used when going to full screen size, if that state 
  is entered immediately. If the user has multiple monitors, the monitor that's used is the
  monitor that most of the stage is on at the time. 
  
  <p><b>Note</b>: If the user has the opportunity to move the browser from one 
  monitor to another between retrieving the value and going to full screen
  size, the value could be incorrect. If you retrieve the value in an event handler that
  sets <codeph>Stage.displayState</codeph> to <codeph>StageDisplayState.FULL_SCREEN</codeph>, the value will be
  correct.</p>
  
  <p>This is the pixel width of the monitor and is the same as the stage width would be if 
  <codeph>Stage.align</codeph> is set to <codeph>StageAlign.TOP_LEFT</codeph> and 
  <codeph>Stage.scaleMode</codeph> is set to <codeph>StageScaleMode.NO_SCALE</codeph>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> This example creates a green rectangle the size of the stage and places a red square on it that
 it activates as a button. Clicking the red square triggers the <codeph>enterFullScreen()</codeph> event handler, 
 which sets the <codeph>fullScreenSourceRect</codeph> property and enters full screen mode. To set the
 <codeph>fullScreenSourceRect</codeph> property, the event handler starts with the location and dimensions of the 
 red square. It then compares the aspect ratio (width divided by height) of the red square to the 
 aspect ratio of the stage at full screen width and height so that it can expand the rectangle 
 (<codeph>fullScreenSourceRect</codeph>) to match the screen's aspect ratio. The result is that the red 
 square occupies the entire height of the monitor with the green background visible on each side.  
 If the aspect ratio was not matched, the stage background color, which is white by default, would show 
 on each side instead of the green background.
 
 <p><b>Note</b>: Test this example in the browser. In the Flash Publish Settings dialog, on the HTML tab, 
 select the template Flash Only - Allow Full Screen. Specify the Flash Player version 9.0.115.0, and make sure 
 the Flash and HTML formats are selected on the Formats tab. Then publish and open the resulting HTML file in 
 the browser.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio &gt; screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenHeight"><linktext>fullScreenHeight</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:height:get"><apiName>height</apiName><shortdesc>
	 
     Indicates the height of the display object, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Referencing the <codeph>height</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>It is always illegal to set the <codeph>height</codeph> property of a Stage object,
	 even if the calling object is the Stage owner (the main SWF file).
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Indicates the height of the display object, in pixels. The height is calculated based on the bounds of the content of the display object.
     When you set the <codeph>height</codeph> property, the <codeph>scaleY</codeph> property is adjusted accordingly, as shown in the 
     following code:
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>Except for TextField and Video objects, a display object with no content (such as an empty sprite) has a height 
    of 0, even if you try to set <codeph>height</codeph> to a different value.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 
	 Determines whether or not the children of the object are mouse enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Referencing the <codeph>mouseChildren</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Determines whether or not the children of the object are mouse enabled. 
	 If an object is mouse enabled, a user can interact with it by using a mouse. The default is <codeph>true</codeph>.
	 
	 <p>This property is useful when you create a button with an instance of the Sprite class
	 (instead of using the SimpleButton class). When you use a Sprite instance to create a button,
	 you can choose to decorate the button by using the <codeph>addChild()</codeph> method to add additional
	 Sprite instances. This process can cause unexpected behavior with mouse events because
	 the Sprite instances you add as children can become the target object of a mouse event
	 when you expect the parent instance to be the target object. To ensure that the parent
	 instance serves as the target objects for mouse events, you can set the 
	 <codeph>mouseChildren</codeph> property of the parent instance to <codeph>false</codeph>.</p>
	 <p> No event is dispatched by setting this property. You must use the
	 <codeph>addEventListener()</codeph> method to create interactive functionality.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:nativeWindow:get"><apiName>nativeWindow</apiName><shortdesc>
	 A reference to the NativeWindow object containing this Stage.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
	 A reference to the NativeWindow object containing this Stage. 
	 
	 <p>The window represents the native operating system window; the Stage
	 represents the content contained by the window.  This property is only 
	 valid for content running in AIR. In Flash Player (content running in a 
	 browser), this property will be <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 
	 Returns the number of children of this object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Referencing the <codeph>numChildren</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Returns the number of children of this object.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:quality:get"><apiName>quality</apiName><shortdesc>
	 A value from the StageQuality class that specifies which rendering quality is used.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Calling the <codeph>quality</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 A value from the StageQuality class that specifies which rendering quality is used.
	 The following are valid values:
	 
	 <ul>
	 
	 <li><codeph>StageQuality.LOW</codeph>—Low rendering quality. Graphics are not
	 anti-aliased, and bitmaps are not smoothed, but runtimes still use mip-mapping. This setting is not supported in Adobe AIR.</li>
	 
	 <li><codeph>StageQuality.MEDIUM</codeph>—Medium rendering quality. Graphics are
	 anti-aliased using a 2 x 2 pixel grid, bitmap smoothing is dependent on the <codeph>Bitmap.smoothing</codeph> setting.
	 Runtimes use mip-mapping. This setting is suitable for movies that do not contain text.
	 This setting is not supported in Adobe AIR.</li>
	 
	 <li><codeph>StageQuality.HIGH</codeph>—High rendering quality. Graphics are anti-aliased
	 using a 4 x 4 pixel grid, and bitmap smoothing is dependent on the <codeph>Bitmap.smoothing</codeph> setting.
	 Runtimes use mip-mapping. This is the default rendering quality setting that Flash Player uses.</li>
	 
	 <li><codeph>StageQuality.BEST</codeph>—Very high rendering quality. Graphics are
	 anti-aliased using a 4 x 4 pixel grid. If <codeph>Bitmap.smoothing</codeph> is <codeph>true</codeph> the runtime uses a high quality 
	 downscale algorithm that produces fewer artifacts (however, using <codeph>StageQuality.BEST</codeph> with <codeph>Bitmap.smoothing</codeph> set to <codeph>true</codeph>
	 slows performance significantly and is not a recommended setting).</li>
	 
	 </ul>
	 
	 <p>Higher quality settings produce better rendering of scaled bitmaps. However, higher 
	 quality settings are computationally more expensive. In particular, when rendering scaled video, 
	 using higher quality settings can reduce the frame rate.
	 </p>
	 
	 <p>For content running in Adobe AIR, <codeph>quality</codeph> can be set to <codeph>StageQuality.BEST</codeph>
	 or <codeph>StageQuality.HIGH</codeph> (and the default value is <codeph>StageQuality.HIGH</codeph>).
	 Attempting to set it to another value has no effect (and the property remains unchanged).
	 </p>
	 
	 <p>For content running in Adobe AIR, setting the <codeph>quality</codeph> property of one Stage
	 object changes the rendering quality for all Stage objects (used by different NativeWindow objects).
	 </p>
	 
	 <b><i>Note:</i></b> The operating system draws the device fonts, 
	 which are therefore unaffected by the <codeph>quality</codeph> property.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageQuality"><linktext>flash.display.StageQuality</linktext></link><link href="flash.display.xml#Bitmap/smoothing"><linktext>flash.display.Bitmap.smoothing</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
	 A value from the StageScaleMode class that specifies which scale mode to use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Calling the <codeph>scaleMode</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>A value from the StageScaleMode class that specifies which scale mode to use.
 	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 A value from the StageScaleMode class that specifies which scale mode to use.
	 The following are valid values:
	 
     <ul>
     
     <li><codeph>StageScaleMode.EXACT_FIT</codeph>—The entire application is visible
     in the specified area without trying to preserve the original aspect ratio. Distortion can occur, and the application may appear stretched or compressed.
     </li>
     
     <li><codeph>StageScaleMode.SHOW_ALL</codeph>—The entire application is visible 
     in the specified area without distortion while maintaining the original aspect ratio of the application. 
     Borders can appear on two sides of the application.   
     </li>
     
	 <li><codeph>StageScaleMode.NO_BORDER</codeph>—The entire application fills the specified area, 
	 without distortion but possibly with some cropping, while maintaining the original aspect ratio 
	 of the application.
	 </li>
	 
	 <li><codeph>StageScaleMode.NO_SCALE</codeph>—The entire application is fixed, so that 
	 it remains unchanged even as the size of the player window changes. Cropping might 
	 occur if the player window is smaller than the content.
	 </li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:showDefaultContextMenu:get"><apiName>showDefaultContextMenu</apiName><shortdesc>
     Specifies whether to show or hide the default items in the Flash Player 
     context menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Calling the <codeph>showDefaultContextMenu</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Specifies whether to show or hide the default items in the Flash Player 
     context menu.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Specifies whether to show or hide the default items in the Flash Player 
     context menu.
     
     <p>If the <codeph>showDefaultContextMenu</codeph> property is set to <codeph>true</codeph> (the 
	 default), all context menu items appear. If the <codeph>showDefaultContextMenu</codeph> property 
	 is set to <codeph>false</codeph>, only the Settings and About Adobe Flash Player menu items appear.</p>
     
 	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageFocusRect:get"><apiName>stageFocusRect</apiName><shortdesc>
	 Specifies whether or not objects display a glowing border when they have focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Calling the <codeph>stageFocusRect</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Specifies whether or not objects display a glowing border when they have focus.
	 
 	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Specifies whether or not objects display a glowing border when they have focus.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageHeight:get"><apiName>stageHeight</apiName><shortdesc>
     The current height, in pixels, of the Stage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Calling the <codeph>stageHeight</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     The current height, in pixels, of the Stage.
     
     <p>If the value of the <codeph>Stage.scaleMode</codeph> property is set to <codeph>StageScaleMode.NO_SCALE</codeph>
	 when the user resizes the window, the Stage content maintains its size while the 
     <codeph>stageHeight</codeph> property changes to reflect the new height size of the screen area occupied by 
     the SWF file. (In the other scale modes, the <codeph>stageHeight</codeph> property always reflects the original 
     height of the SWF file.) You can add an event listener for the <codeph>resize</codeph> event and then use the 
     <codeph>stageHeight</codeph> property of the Stage class to determine the actual pixel dimension of the resized 
     Flash Player window. The event listener allows you to control how 
	 the screen content adjusts when the user resizes the window.</p>
	 
	 <p><b>Note:</b> In an HTML page hosting the SWF file, both the <codeph>object</codeph> and <codeph>embed</codeph> tags' <codeph>height</codeph> attributes must be set to a percentage (such as <codeph>100%</codeph>), not pixels. If the 
     settings are generated by JavaScript code, the <codeph>height</codeph> parameter of the <codeph>AC_FL_RunContent()
     </codeph> method must be set to a percentage, too. This percentage is applied to the <codeph>stageHeight</codeph>
     value.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:stageWidth:get"><apiName>stageWidth</apiName><shortdesc>
     Specifies the current width, in pixels, of the Stage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Calling the <codeph>stageWidth</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Specifies the current width, in pixels, of the Stage.
     
     
     <p>If the value of the <codeph>Stage.scaleMode</codeph> property is set to <codeph>StageScaleMode.NO_SCALE</codeph>
	 when the user resizes the window, the Stage content maintains its defined size while the <codeph>stageWidth</codeph> 
	 property changes to reflect the new width size of the screen area occupied by the SWF file. (In the other scale
     modes, the <codeph>stageWidth</codeph> property always reflects the original width of the SWF file.) You can add an event 
	 listener for the <codeph>resize</codeph> event and then use the <codeph>stageWidth</codeph> property of the Stage class to
	 determine the actual pixel dimension of the resized Flash Player window. The event listener allows you to control how 
	 the screen content adjusts when the user resizes the window.</p>
	 
     <p><b>Note:</b> In an HTML page hosting the SWF file, both the <codeph>object</codeph> and <codeph>embed</codeph> tags' <codeph>width</codeph> attributes must be set to a percentage (such as <codeph>100%</codeph>), not pixels. If the 
     settings are generated by JavaScript code, the <codeph>width</codeph> parameter of the <codeph>AC_FL_RunContent()
     </codeph> method must be set to a percentage, too. This percentage is applied to the <codeph>stageWidth</codeph>
     value.</p>
     
 	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 
	 Determines whether the children of the object are tab enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Referencing the <codeph>tabChildren</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file). 
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Determines whether the children of the object are tab enabled. Enables or disables tabbing for the 
     children of the object. The default is <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
	 
     Returns a TextSnapshot object for this DisplayObjectContainer instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier><apiException><apiDesc>Referencing the <codeph>textSnapshot</codeph> property of a Stage object throws an 
	 exception because the Stage class does not implement this property. To avoid this, call the 
	 <codeph>textSnapshot</codeph> property of a display object container other than the Stage object.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Returns a TextSnapshot object for this DisplayObjectContainer instance.
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:width:get"><apiName>width</apiName><shortdesc>
	 
     Indicates the width of the display object, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Referencing the <codeph>width</codeph> property of a Stage object throws an exception for
	 any caller that is not in the same security sandbox as the Stage owner (the main SWF file).
	 To avoid this, the Stage owner can grant permission to the domain of the caller by calling 
	 the <codeph>Security.allowDomain()</codeph> method or the <codeph>Security.allowInsecureDomain()</codeph> method.
	 For more information, see the "Security" chapter in <i>Programming ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>It is always illegal to set the <codeph>width</codeph> property of a Stage object,
	 even if you are the Stage owner.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Indicates the width of the display object, in pixels. The width is calculated based on the bounds of the content of the display object.
     When you set the <codeph>width</codeph> property, the <codeph>scaleX</codeph> property is adjusted accordingly, as shown in the 
     following code:
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>Except for TextField and Video objects, a display object with no content (such as an empty sprite) has a width 
    of 0, even if you try to set <codeph>width</codeph> to a different value.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:wmodeGPU:get"><apiName>wmodeGPU</apiName><shortdesc>
	 Indicates whether GPU compositing is available and in use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates whether GPU compositing is available and in use. The <codeph>wmodeGPU</codeph> value is <codeph>true</codeph> <i>only</i>
	 when all three of the following conditions exist:
	 <p><ul><li>GPU compositing has been requested.</li>
	 <li>GPU compositing is available.</li>
	 <li>GPU compositing is in use.</li></ul></p>
	 <p>Specifically, the <codeph>wmodeGPU</codeph> property indicates one of the following:</p>
	 <p><ol><li>GPU compositing has not been requested or is unavailable. In this case, the <codeph>wmodeGPU</codeph> property value is <codeph>false</codeph>.</li>
	 <li>GPU compositing has been requested (if applicable and available), but the environment is operating in "fallback mode" 
	 (not optimal rendering) due to limitations of the content. In this case, the <codeph>wmodeGPU</codeph> property value is <codeph>true</codeph>.</li>
	 <li>GPU compositing has been requested (if applicable and available), and the environment is operating in the best mode. In this case, the 
	 <codeph>wmodeGPU</codeph> property value is also <codeph>true</codeph>.</li></ol></p>
	 <p>In other words, the <codeph>wmodeGPU</codeph> property identifies the capability and state of the rendering environment. For runtimes 
	 that do not support GPU compositing, such as AIR 1.5.2, the value is always <codeph>false</codeph>, because (as stated above) the value is 
	 <codeph>true</codeph> only when GPU compositing has been requested, is available, and is in use.</p>
	 <p>The <codeph>wmodeGPU</codeph> property is useful to determine, at runtime, whether or not GPU compositing is in use. The value of 
	 <codeph>wmodeGPU</codeph> indicates if your content is going to be scaled by hardware, or not, so you can present graphics at the correct size.
	 You can also determine if you're rendering in a fast path or not, so that you can adjust your content complexity accordingly.</p>
	 <p>For Flash Player in a browser, GPU compositing can be requested by the value of <codeph>gpu</codeph> for the <codeph>wmode</codeph> HTML 
	 parameter in the page hosting the SWF file. For other configurations, GPU compositing can be requested in the header of a SWF file 
	 (set using SWF authoring tools).</p>	 
	 <p>However, the <codeph>wmodeGPU</codeph> property does not identify the current rendering performance. Even if GPU compositing is "in use" the rendering 
	 process might not be operating in the best mode. To adjust your content for optimal rendering, use a Flash runtime debugger version, 
	 and set the <codeph>DisplayGPUBlendsetting</codeph> in your mm.cfg file.</p>
	 
	 <p><b>Note:</b> This property is always <codeph>false</codeph> when referenced
	 from ActionScript that runs before the runtime performs its first rendering
	 pass.  For example, if you examine <codeph>wmodeGPU</codeph> from a script in Frame 1 of
	 Adobe Flash Professional, and your SWF file is the first SWF file loaded in a new
	 instance of the runtime, then the <codeph>wmodeGPU</codeph> value is <codeph>false</codeph>.
	 To get an accurate value, wait until at least one rendering pass
	 has occurred. If you write an event listener for the
	 <codeph>exitFrame</codeph> event of any <codeph>DisplayObject</codeph>, the <codeph>wmodeGPU</codeph> value at
	 is the correct value.</p>
	 
	 </apiDesc><example conref="examples\Stage.wmodeGPU.as"> The following example examines the <codeph>wmodeGPU</codeph> property after the display object mySprite
 is rendered, so you can get an accurate value.
<codeblock>
mySprite.addEventListener(EXIT_FRAME, exithandler):

function exithandler(exiteventobject:Event):void {
                trace(stage.wmodeGPU);
}
</codeblock></example></apiValueDetail><related-links><link href="DisplayObject.html#event:exitFrame"><linktext>DisplayObject exitFrame event</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	 The NativeWindowInitOptions class defines the initialization options
	 used to construct a new NativeWindow instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 The NativeWindowInitOptions class defines the initialization options
	 used to construct a new NativeWindow instance. 
	 <p>The properties defined in the
	 initialization options cannot be changed after a window is created.</p>
	 
	 <p><b>Note:</b> For the initial application window created automatically 
	 by AIR, all of these properties (except <codeph>type</codeph>) are
	 set in the application descriptor. The initial window is always type normal.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links><apiConstructor id="flash.display:NativeWindowInitOptions:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	    Creates a new NativeWindowInitOptions object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	    Creates a new NativeWindowInitOptions object.
	    
        <p>The default values of the newly created object are:</p>
	    <ul>
        <li><codeph>systemChrome = NativeWindowSystemChrome.STANDARD</codeph></li>
        <li><codeph>type = NativeWindowType.NORMAL</codeph></li>
	    <li><codeph>transparent = false</codeph></li>
	    <li><codeph>resizable = true</codeph></li>
	    <li><codeph>maximizable = true</codeph></li>
	    <li><codeph>minimizable = true</codeph></li>
	    </ul>
	    
	    </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:NativeWindowInitOptions:maximizable:get"><apiName>maximizable</apiName><shortdesc>
		 Specifies whether the window can be maximized by the user.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MAXIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Specifies whether the window can be maximized by the user.  
		 
		 <p>
		 For windows with system chrome, this setting will affect the appearance of the window
		 maximize button.  It will also affect other parts of the system-managed 
		 user interface, such as the window menu on Microsoft Windows.
		 </p>
		 
		 <p>
		 When set to <codeph>false</codeph>, the window cannot be maximized by the user. Calling the
		 NativeWindow <codeph>maximize()</codeph> method directly will maximize the window.
		 </p>
		 
		 <p><b>Note:</b> On operating systems, such as Mac OS X, in which maximizing
         a window does not also prevent resizing, both <codeph>maximizable</codeph> and
		 <codeph>resizable</codeph> must be set to <codeph>false</codeph> to prevent
		 the window from being zoomed or resized.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:minimizable:get"><apiName>minimizable</apiName><shortdesc>
		 Specifies whether the window can be minimized by the user.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MINIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Specifies whether the window can be minimized by the user.
		 
		 <p>
		 For windows with system chrome, this setting will affect the appearance of the
		 window minimize button.  It will also affect other parts of the system-managed 
		 user interface, such as the window menu on Microsoft Windows.
		 </p>
		 
		 <p>
		 When set to <codeph>false</codeph>, the window cannot be minimized by the user. Calling the
		 NativeWindow <codeph>minimize()</codeph> method directly will minimize the window.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:resizable:get"><apiName>resizable</apiName><shortdesc>
		 Specifies whether the window can be resized by the user.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_SIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Specifies whether the window can be resized by the user.
		 
		 <p>
		 When set to <codeph>false</codeph>, the window cannot be resized by the user using system chrome. 
		 Calling the NativeWindow <codeph>startResize()</codeph> method in response to a mouse event will 
		 allow the user to resize the window. Setting the window bounds directly will also change the window size.
		 </p>
		 
		 <p><b>Note:</b> On operating systems, such as Mac OS X, in which
		 maximizing windows is a resizing operation, both <codeph>maximizable</codeph> and
		 <codeph>resizable</codeph> must be set to <codeph>false</codeph> to prevent
		 the window from being zoomed or resized.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
		 Specifies whether system chrome is provided for the window.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowSystemChrome.STANDARD
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Specifies whether system chrome is provided for the window. 
		  
		 <p> Chrome refers to the window controls that allow a user to control the desktop
		 properties of a window. System chrome uses the standard controls for the desktop
		 environment in which the AIR application is run and conforms to the standard
		 look-and-feel of the native operating system.</p>
		 <p>
		 To use chrome provided by a framework (such as Flex), or to provide your own window
		 chrome, set <codeph>systemChrome</codeph> to <codeph>NativeWindowSystemChrome.NONE</codeph>.
		 </p>
		 <p>Constants for the valid values of this property are defined in the
		 NativeWindowSystemChrome class:
         </p>
		 <ul>
         <li><codeph>NativeWindowSystemChrome.NONE</codeph></li>
		 <li><codeph>NativeWindowSystemChrome.STANDARD</codeph></li>
		 </ul>
		 
		 <p>If not specified, the default value for <codeph>systemChrome</codeph> is
		 <codeph>NativeWindowSystemChrome.STANDARD</codeph>.
		 </p>
		 
		 <p>Setting the <codeph>transparent</codeph> property to <codeph>true</codeph> for a window 
		 with system chrome is not supported.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:transparent:get"><apiName>transparent</apiName><shortdesc>
		 Specifies whether the window supports transparency and alpha blending against the desktop.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
		 
	     </apiDefaultValue></apiValueDef><apiDesc>
		 Specifies whether the window supports transparency and alpha blending against the desktop.
		 
		 <p>
		 If <codeph>true</codeph>, the window display is composited against the desktop. Areas of the window
		 not covered by a display object, or covered by display objects with an alpha setting near zero,
		 are effectively invisible and will not intercept mouse events (which will be received by the 
		 desktop object below the window). The alpha value at which an object will no longer 
		 intercepting mouse events varies between about .06 and .01, depending on the operating system.
		 </p>  
		 
		 <p>Setting the <codeph>transparent</codeph> property to <codeph>true</codeph> for a window 
		 with system chrome is not supported.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowInitOptions:type:get"><apiName>type</apiName><shortdesc>
		 Specifies the type of the window to be created.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowType.NORMAL
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Specifies the type of the window to be created.  
		 
		 <p>Constants for the valid values of this property are defined in the
		 NativeWindowType class:
         </p>
         
		 <ul>
		 <li><codeph>NativeWindowType.NORMAL</codeph> — A typical window. 
		 Normal windows use full-size chrome and appear on the Windows or Linux 
		 task bar and the Mac OS X window menu.</li>
		 
		 <li><codeph>NativeWindowType.UTILITY</codeph> — A tool palette. Utility 
		 windows use a slimmer version of the system chrome and do not appear 
		 on the Windows task bar and the Mac OS X window menu.</li>
		 
		 <li><codeph>NativeWindowType.LIGHTWEIGHT</codeph> — lightweight windows cannot have 
		 system chrome and do not appear on the Windows or Linux task bar and the 
		 Mac OS X window menu. In addition, lightweight windows do not have 
		 the System (Alt-Space) menu on Windows. Lightweight windows 
		 are suitable for notification bubbles and controls such as combo-boxes 
		 that open a short-lived display area. When the lightweight type is 
		 used, <codeph>systemChrome</codeph> must be set to <codeph>none</codeph>.</li>
		 </ul>
		 
		 <p>
		 If not specified, the default value for <codeph>type</codeph> is
		 <codeph>NativeWindowType.NORMAL</codeph>.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
	 A ShaderParameter instance represents a single input parameter of
	 a shader kernel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A ShaderParameter instance represents a single input parameter of
	 a shader kernel. A kernel can be defined to accept zero, one, or more 
	 parameters that are used in the kernel execution. A ShaderParameter 
	 provides information about the parameter, such as the type of data 
	 it expects. It also provides a mechanism for setting the parameter 
	 value that is used when the shader executes. To specify a value or 
	 values for the shader parameter, 
	 create an Array containing the value or values and assign it to the 
	 <codeph>value</codeph> property.
	 
	 <p>A ShaderParameter instance representing a parameter 
	 for a Shader instance is accessed as a property of the Shader instance's 
	 <codeph>data</codeph> property. The ShaderParameter property has the same name 
	 as the parameter's name in the shader code. 
	 For example, if a shader defines a parameter named <codeph>radius</codeph>, 
	 the ShaderParameter instance representing the <codeph>radius</codeph> parameter 
	 is available as the <codeph>radius</codeph> property, as shown here:</p>
	 
	 <codeblock>var radiusParam:ShaderParameter = myShader.data.radius;</codeblock>
	 
	 <p>In addition to the defined properties of the ShaderParameter class, 
	 each ShaderParameter instance has additional properties 
	 corresponding to any metadata defined for the parameter.	These properties 
	 are added to the ShaderParameter object when it is created. The properties' 
	 names match the metadata names specified in the shader's source code. 
	 The data type of each property varies according to the data type of the 
	 corresponding metadata. A text metadata value such as "description" is a String 
	 instance. A metadata property with a non-string value (such as <codeph>minValue</codeph>
	 or <codeph>defaultValue</codeph>) is represented as an Array instance. The number of elements and 
	 element data types correspond to the metadata values.</p>
	 
	 <p>For example, suppose a shader includes the following two parameter declarations:</p>
	 
	 <codeblock>
	 parameter float2 size
	 &lt;
	     description: "The size of the image to which the kernel is applied";
	     minValue: float2(0.0, 0.0);
	     maxValue: float2(100.0, 100.0);
	     defaultValue: float2(50.0, 50.0);
	 &gt;;
	 
	 parameter float radius
	 &lt;
	     description: "The radius of the effect";
	     minValue: 0.0;
	     maxValue: 50.0;
	     defaultValue: 25.0;
	 &gt;;
	 </codeblock>
	 
	 <p>The ShaderParameter instance 
	 corresponding to the <codeph>size</codeph> parameter has the following metadata 
	 properties in addition to its built-in properties:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Property name</entry><entry>Data type</entry><entry>Value</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"size"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"The size of the image to which the kernel is applied"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0, 0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[100, 100]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50, 50]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>The ShaderParameter corresponding to the <codeph>radius</codeph> parameter 
	 has the following additional properties:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Property name</entry><entry>Data type</entry><entry>Value</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"radius"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"The radius of the effect"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[25]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Generally, developer code does not create a ShaderParameter instance 
	 directly. A ShaderParameter instance is created for each of a shader's 
	 parameters when the Shader instance is created.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links><apiConstructor id="flash.display:ShaderParameter:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
		 Creates a ShaderParameter instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Creates a ShaderParameter instance. Developer code does 
		 not call the ShaderParameter constructor 
		 directly. A ShaderParameter instance is created for each of a 
		 shader's parameters when the Shader instance is created.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderParameter:index:get"><apiName>index</apiName><shortdesc>
         The zero-based index of the parameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         The zero-based index of the parameter.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameter:type:get"><apiName>type</apiName><shortdesc>
		The data type of the parameter as defined in the shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		The data type of the parameter as defined in the shader. The set of 
		possible values for the <codeph>type</codeph> property is defined by the 
		constants in the ShaderParameterType class.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameterType"><linktext>flash.display.ShaderParameterType</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameter:value:get"><apiName>value</apiName><shortdesc>
		The value or values that are passed in as the parameter value to the shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		The value or values that are passed in as the parameter value to the shader. 
		The <codeph>value</codeph> property is an indexed Array. The number and type of 
		the elements of the Array correspond to the data type of the parameter, which 
		can be determined using the <codeph>type</codeph> property.
		
		<p>The following table indicates the parameter type and corresponding 
		number and data type of the <codeph>value</codeph> Array's elements:</p>
		
		<adobetable class="innertable">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		<tgroup cols="3"><thead><row><entry>Parameter type</entry><entry># Elements</entry><entry>Element data type</entry></row></thead><tbody><row>
		  <entry>float (<codeph>ShaderParameterType.FLOAT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float2 (<codeph>ShaderParameterType.FLOAT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3 (<codeph>ShaderParameterType.FLOAT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4 (<codeph>ShaderParameterType.FLOAT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>int (<codeph>ShaderParameterType.INT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>int or uint</entry>
		</row><row>
		  <entry>int2 (<codeph>ShaderParameterType.INT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>int or uint</entry>
		</row><row>
		  <entry>int3 (<codeph>ShaderParameterType.INT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>int or uint</entry>
		</row><row>
		  <entry>int4 (<codeph>ShaderParameterType.INT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>int or uint</entry>
		</row><row>
		  <entry>bool (<codeph>ShaderParameterType.BOOL</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool2 (<codeph>ShaderParameterType.BOOL2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool3 (<codeph>ShaderParameterType.BOOL3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool4 (<codeph>ShaderParameterType.BOOL4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>float2x2 (<codeph>ShaderParameterType.MATRIX2X2</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3x3 (<codeph>ShaderParameterType.MATRIX3X3</codeph>)</entry>
		  <entry>9</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4x4 (<codeph>ShaderParameterType.MATRIX4X4</codeph>)</entry>
		  <entry>16</entry>
		  <entry>Number</entry>
		</row></tbody></tgroup></adobetable>
		
		<p>For the matrix parameter types, the array elements fill the rows of
		the matrix, then the columns. For example, suppose the following line 
		of ActionScript is used to fill a <codeph>float2x2</codeph> 
		parameter named <codeph>myMatrix</codeph>:</p>
		
		<codeblock>myShader.data.myMatrix.value = [.1, .2, .3, .4];</codeblock>
		
		<p>Within the shader, the matrix elements have the following values:</p>
		
		<ul>
		  <li><codeph>myMatrix[0][0]</codeph>: .1</li>
		  <li><codeph>myMatrix[0][1]</codeph>: .2</li>
		  <li><codeph>myMatrix[1][0]</codeph>: .3</li>
		  <li><codeph>myMatrix[1][1]</codeph>: .4</li>
		</ul>
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GradientType"><apiName>GradientType</apiName><shortdesc>
The GradientType class provides values for the type parameter in the 
beginGradientFill() and lineGradientStyle() methods of the flash.display.Graphics class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The GradientType class provides values for the <codeph>type</codeph> parameter in the 
<codeph>beginGradientFill()</codeph> and <codeph>lineGradientStyle()</codeph> methods of the flash.display.Graphics class.

</apiDesc></apiClassifierDetail><apiValue id="flash.display:GradientType:LINEAR"><apiName>LINEAR</apiName><shortdesc>
	Value used to specify a linear gradient fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linear</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Value used to specify a linear gradient fill.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GradientType:RADIAL"><apiName>RADIAL</apiName><shortdesc>
	Value used to specify a radial gradient fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>radial</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Value used to specify a radial gradient fill.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InterpolationMethod"><apiName>InterpolationMethod</apiName><shortdesc>
The InterpolationMethod class provides values for the interpolationMethod 
parameter in the Graphics.beginGradientFill() and 
Graphics.lineGradientStyle() methods.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The InterpolationMethod class provides values for the <codeph>interpolationMethod</codeph> 
parameter in the <codeph>Graphics.beginGradientFill()</codeph> and 
<codeph>Graphics.lineGradientStyle()</codeph> methods. This parameter determines
the RGB space to use when rendering the gradient. 

 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:InterpolationMethod:LINEAR_RGB"><apiName>LINEAR_RGB</apiName><shortdesc>
	Specifies that the linear RGB interpolation method should be used.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linearRGB</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Specifies that the linear RGB interpolation method should be used. This means that
	an RGB color space based on a linear RGB color model is used.
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/RGB"><linktext>RGB</linktext></link></related-links></apiValue><apiValue id="flash.display:InterpolationMethod:RGB"><apiName>RGB</apiName><shortdesc>
	Specifies that the RGB interpolation method should be used.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>rgb</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Specifies that the RGB interpolation method should be used. This means that the gradient is rendered with
	exponential sRGB (standard RGB) space. 
	The sRGB space is a W3C-endorsed standard that defines a non-linear conversion between
	red, green, and blue component values and the actual intensity of the visible component color.
	
	<p>For example, consider a simple linear gradient between two colors (with the <codeph>spreadMethod</codeph> 
	parameter set to <codeph>SpreadMethod.REFLECT</codeph>). The different interpolation methods affect 
	the appearance as follows: </p>
	
		<adobetable>
		
      
		
		
		
		<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="linear gradient with InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="linear gradient with InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
		</row><row>
		<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
		<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
		</row></tbody></tgroup></adobetable>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/LINEAR_RGB"><linktext>LINEAR_RGB</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsPath"><apiName>IGraphicsPath</apiName><shortdesc>
	This interface is used to define objects that can be used as path parameters in the flash.display.Graphics
	methods and drawing classes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier></apiBaseClassifier></apiClassifierDef><apiDesc>
	This interface is used to define objects that can be used as path parameters in the flash.display.Graphics
	methods and drawing classes. Use the implementor classes of this interface to
	create and manage path property data, and to reuse the same data for different instances.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:IGraphicsFill"><apiName>IGraphicsFill</apiName><shortdesc>
	This interface is used to define objects that can be used as fill parameters in the flash.display.Graphics
	methods and drawing classes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier></apiBaseClassifier></apiClassifierDef><apiDesc>
	This interface is used to define objects that can be used as fill parameters in the flash.display.Graphics
	methods and drawing classes. Use the implementor classes of this interface to
	create and manage fill property data, and to reuse the same data for different instances.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#GraphicsStroke/fill"><linktext>flash.display.GraphicsStroke.fill</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:LoaderInfo"><apiName>LoaderInfo</apiName><shortdesc>
 The LoaderInfo class provides information about a loaded SWF file or a loaded image file
 (JPEG, GIF, or PNG).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion><Exclude kind="method" name="dispatchEvent"/></asMetadata><asCustoms><internal>Update the places LoaderInfo can be obtained from (playerglobal.as) and double-check loader vs. loadee.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 The LoaderInfo class provides information about a loaded SWF file or a loaded image file
 (JPEG, GIF, or PNG).  LoaderInfo objects are available for any display object.
 The information provided includes load progress, the URLs of the loader and
 loaded content, the number of bytes total for the media, and the nominal height and width of the
 media.
 
 <p>You can access LoaderInfo objects in two ways: </p>
 
 <ul>
 
 	<li>The <codeph>contentLoaderInfo</codeph> property of a flash.display.Loader object—
 		The <codeph>contentLoaderInfo</codeph> property is always available for any Loader object.
 		For a Loader object that has not called the <codeph>load()</codeph> or <codeph>loadBytes()</codeph>
 		method, or that has not sufficiently loaded, attempting to access many of the properties of the 
 		<codeph>contentLoaderInfo</codeph> property throws an error.</li>
 
 	<li>The <codeph>loaderInfo</codeph> property of a display object. </li>
 
 </ul>
 
 <p>The <codeph>contentLoaderInfo</codeph> property of a Loader object provides information about
 the content that the Loader object is loading, whereas the <codeph>loaderInfo</codeph> property of
 a DisplayObject provides information about the root SWF file for that display object. </p>
 
 <p>When you use a Loader object to load a display object (such as a SWF file or a bitmap), the
 <codeph>loaderInfo</codeph> property of the display object is the same as the <codeph>contentLoaderInfo</codeph>
 property of the Loader object (<codeph>DisplayObject.loaderInfo = Loader.contentLoaderInfo</codeph>). 
 Because the instance of the main class of the SWF file has
 no Loader object, the <codeph>loaderInfo</codeph> property is the only way to
 access the LoaderInfo for the instance of the main class of the SWF file.</p>
 
 <p>The following diagram shows the different uses of the LoaderInfo object—for the instance of the main class of  
 the SWF file, for the <codeph>contentLoaderInfo</codeph> property of a Loader object, and for the <codeph>loaderInfo</codeph> 
 property of a loaded object:</p>
 
 <p>
 <adobeimage alt="An image of different LoaderInfo situations" href="../../images/loaderInfo_object.jpg"/>
 </p>
 
 <p>When a loading operation is not complete, some properties of the <codeph>contentLoaderInfo</codeph>
 property of a Loader object are not available.  You can obtain some properties, such as
 <codeph>bytesLoaded</codeph>, <codeph>bytesTotal</codeph>, <codeph>url</codeph>, <codeph>loaderURL</codeph>, 
 and <codeph>applicationDomain</codeph>. When the <codeph>loaderInfo</codeph> object dispatches the 
 <codeph>init</codeph> event, you can access all properties of the <codeph>loaderInfo</codeph> object and 
 the loaded image or SWF file.</p>
 
 <p><b>Note:</b> All properties of LoaderInfo objects are read-only.</p>
 
 <p>The <codeph>EventDispatcher.dispatchEvent()</codeph> method
 
 is not applicable to LoaderInfo objects. If you call <codeph>dispatchEvent()</codeph>
 on a LoaderInfo object, an IllegalOperationError exception is thrown.</p>
 
 
 
 </apiDesc><example conref="examples\LoaderInfoExample.as"> The following example uses the LoaderInfoExample class to display an image on
 the stage.  This is accomplished by performing the following steps:
 <ol>
  <li>A property <codeph>url</codeph> is created, which is the location and name of the image.</li>
 
  <li>The class constructor creates a Loader object named <codeph>loader</codeph>.</li>
 
  <li>The <codeph>loader</codeph> object instantiates an event listener to ensure that the image loads properly.</li>
 
  <li>The constructor creates a new instance of a URLRequest object, <codeph>request</codeph>,
  with <codeph>url</codeph> passed so that the file name and location are known.</li>
 
  <li>The <codeph>request</codeph> object is then passed to the <codeph>load()</codeph> method of the 
  <codeph>loader</codeph> object, which loads the image onto the display list.</li>
 
 </ol>
 <p><b>Important:</b> This example requires that you add a file named Image.gif in the same directory 
 as the compiled SWF file. Use an image that has an area that fits within the dimensions of the main SWF file.</p>
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.LoaderInfo;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderInfoExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderInfoExample() {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function initHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var info:LoaderInfo = LoaderInfo(loader.contentLoaderInfo);
            trace("initHandler: loaderURL=" + info.loaderURL + " url=" + info.url);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObject/loaderInfo"><linktext>flash.display.DisplayObject.loaderInfo</linktext></link></related-links><adobeApiEvent id="flash.display:LoaderInfo_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Dispatched when a network request is made over HTTP and an HTTP status code can be detected.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a network request is made over HTTP and an HTTP status code can be detected.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.UNLOAD_unload"><apiName>unload</apiName><shortdesc>
 Dispatched by a LoaderInfo object whenever a loaded object is removed by using the unload() 
 method of the Loader object, or when a second load is performed by the same Loader object and the
 original content is removed prior to the load beginning.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.UNLOAD</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by a LoaderInfo object whenever a loaded object is removed by using the <codeph>unload()</codeph> 
 method of the Loader object, or when a second load is performed by the same Loader object and the
 original content is removed prior to the load beginning.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>Loader.unload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Dispatched when data is received as the download operation progresses.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when data is received as the download operation progresses.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Dispatched when a load operation starts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a load operation starts.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Dispatched when an input or output error occurs that causes a load operation to fail.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when an input or output error occurs that causes a load operation to fail. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.INIT_init"><apiName>init</apiName><shortdesc>
 Dispatched when the properties and methods of a loaded SWF file are 
 accessible and ready for use.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.INIT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when the properties and methods of a loaded SWF file are 
 accessible and ready for use. The content, however, can still be downloading. A LoaderInfo object 
 dispatches the <codeph>init</codeph> event when the following conditions exist:
 <ul>
     <li>All properties and methods associated with the loaded object and those associated
 	with the LoaderInfo object are accessible.</li>
     <li>The constructors for all child objects have completed.</li>
     <li>All ActionScript code in the first frame of the loaded SWF's main timeline has been executed.</li>
 </ul>
 
 <p>For example, an <codeph>Event.INIT</codeph> is dispatched when the first frame of a movie or animation is loaded. 
 The movie is then accessible and can be added to the display list. The complete movie, however, can 
 take longer to download. The <codeph>Event.COMPLETE</codeph> is only dispatched once the full movie is loaded.</p>
 
 <p>The <codeph>init</codeph> event always precedes the <codeph>complete</codeph> event.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Dispatched when data has loaded successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when data has loaded successfully. In other words, it is dispatched when all the content 
 has been downloaded and the loading has finished. The <codeph>complete</codeph> event is always dispatched 
 after the <codeph>init</codeph> event. The <codeph>init</codeph> event is dispatched when the object 
 is ready to access, though the content may still be downloading.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:LoaderInfo:getLoaderInfoByDefinition"><apiName>getLoaderInfoByDefinition</apiName><shortdesc>
     Returns the LoaderInfo object associated with a SWF file defined as an object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>The caller is not running in the local trusted sandbox.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>The associated LoaderInfo object. Returns <codeph>null</codeph> when called
	 in non-debugger builds (or when debugging is not enabled) or if the referenced <codeph>object</codeph>
	 does not have an associated LoaderInfo object (such as some objects used by the AIR runtime).
	 
	 </apiDesc><apiOperationClassifier>flash.display:LoaderInfo</apiOperationClassifier></apiReturn><apiParam><apiItemName>object</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>The object for which you want to get an associated LoaderInfo object.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Returns the LoaderInfo object associated with a SWF file defined as an object.
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:LoaderInfo:actionScriptVersion:get"><apiName>actionScriptVersion</apiName><shortdesc>
	 The ActionScript version of the loaded SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>If the file is not downloaded sufficiently to retrieve the requested information.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>If the file is not a SWF file.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The ActionScript version of the loaded SWF file.
	 
	 The language version is specified by using the enumerations in the
	 ActionScriptVersion class, such as <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph>
	 and <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>.
	 
	 <p><b>Note:</b> This property always has a value of either <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> or 
	 <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>.  ActionScript 1.0 and 2.0 are
	 both reported as <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> (version 2.0).  This property
	 only distinguishes ActionScript 1.0 and 2.0 from ActionScript 3.0.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ActionScriptVersion"><linktext>flash.display.ActionScriptVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:applicationDomain:get"><apiName>applicationDomain</apiName><shortdesc>
	 When an external SWF file is loaded, all ActionScript 3.0 definitions contained in the loaded 
	 class are stored in the applicationDomain property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need better description and example.  
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier><apiException><apiDesc>This security sandbox of the caller is not allowed to access this ApplicationDomain.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 When an external SWF file is loaded, all ActionScript 3.0 definitions contained in the loaded 
	 class are stored in the <codeph>applicationDomain</codeph> property.
	 
	 <p>All code in a SWF file is defined to exist in an application domain. The current application 
	 domain is where your main application runs. The system domain contains all application domains,
	 including the current domain and all classes used by Flash Player or Adobe AIR.</p>
	 
	 <p>All application domains, except the system domain, have an associated parent domain. 
	 The parent domain of your main application's <codeph>applicationDomain</codeph> is the system domain. 
	 Loaded classes are defined only when their parent doesn't already define them. 
	 You cannot override a loaded class definition with a newer definition.</p>
	 
	 <p>For usage examples of application domains, see the "Client System Environment" chapter
 	 in <i>Programming ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:bytes:get"><apiName>bytes</apiName><shortdesc>
	 The bytes associated with a LoaderInfo object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>If the object accessing this API is prevented from
	 accessing the loaded object due to security restrictions. This situation can occur, 
	 for instance, when a Loader object attempts to access the <codeph>contentLoaderInfo.content</codeph> 
	 property and it is not granted security permission to access the loaded content.
	 
	 <p>For more information, see the "Flash Player Security" chapter
 	 in <i>Programming ActionScript 3.0</i>.</p>
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The bytes associated with a LoaderInfo object. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 The number of bytes that are loaded for the media.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 The number of bytes that are loaded for the media. When this number equals
	 the value of <codeph>bytesTotal</codeph>, all of the bytes are loaded.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 The number of compressed bytes in the entire media file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 The number of compressed bytes in the entire media file.
	 
	 <p>Before the first <codeph>progress</codeph> event is dispatched by
	 this LoaderInfo object's corresponding Loader object, <codeph>bytesTotal</codeph> is 0.
	 After the first <codeph>progress</codeph> event from the Loader object, <codeph>bytesTotal</codeph>
	 reflects the actual number of bytes to be downloaded.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:childAllowsParent:get"><apiName>childAllowsParent</apiName><shortdesc>
	 Expresses the trust relationship from content (child) to the Loader (parent).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Thrown if the file is not downloaded sufficiently 
	 to retrieve the requested information.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Expresses the trust relationship from content (child) to the Loader (parent). 
	 If the child has allowed the parent access, <codeph>true</codeph>; otherwise, 
	 <codeph>false</codeph>. This property is set to <codeph>true</codeph> if the child object 
	 has called the <codeph>allowDomain()</codeph> method to grant permission to the parent domain 
	 or if a URL policy is loaded at the child domain that grants permission
	 to the parent domain. If child and parent are in 
	 the same domain, this property is set to <codeph>true</codeph>.
	 
	 <p>For more information, see the "Flash Player Security" chapter
 	 in <i>Programming ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:childSandboxBridge:get"><apiName>childSandboxBridge</apiName><shortdesc>
	 A object that can be set by the loaded content's code to expose properties and methods that can be accessed 
	 by code in the Loader object's sandbox.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Only content in the loaded content's sandbox can set this property.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 A object that can be set by the loaded content's code to expose properties and methods that can be accessed 
	 by code in the Loader object's sandbox. This <i>sandbox bridge</i> lets content from a non-application domain have 
	 controlled access to scripts in the AIR application sandbox, and vice versa. The sandbox bridge serves as a gateway between 
	 the sandboxes, providing explicit interaction between application and non-application security sandboxes. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/parentSandboxBridge"><linktext>parentSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:content:get"><apiName>content</apiName><shortdesc>
	 The loaded object associated with this LoaderInfo object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>If the object accessing this API is prevented from
	 accessing the loaded object due to security restrictions. This situation can occur, 
	 for instance, when a Loader object attempts to access the <codeph>contentLoaderInfo.content</codeph> 
	 property and it is not granted security permission to access the loaded content.
	 
	 <p>For more information, see the "Flash Player Security" chapter
 	 in <i>Programming ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The loaded object associated with this LoaderInfo object. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:contentType:get"><apiName>contentType</apiName><shortdesc>
	 The MIME type of the loaded file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The MIME type of the loaded file. The value is <codeph>null</codeph> if not enough of the file has loaded 
	 in order to determine the type. The following list gives the possible values:
	 
	 <ul>
	 	
	 	<li><codeph>"application/x-shockwave-flash"</codeph></li>
	 
	 	<li><codeph>"image/jpeg"</codeph></li>
	 
	 	<li><codeph>"image/gif"</codeph></li>
	 
	 	<li><codeph>"image/png"</codeph></li>
	 
	 </ul>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 The nominal frame rate, in frames per second, of the loaded SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>If the file is not downloaded sufficiently to retrieve the requested information.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>If the file is not a SWF file. 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The nominal frame rate, in frames per second, of the loaded SWF file. This
	 number is often an integer, but need not be.
	 
	 <p>This value may differ from the actual frame rate in use.  
	 Flash Player or Adobe AIR only uses a single frame rate for all loaded SWF files at
	 any one time, and this frame rate is determined by the nominal
	 frame rate of the main SWF file. Also, the main frame rate may not be able to be achieved, depending on hardware, sound synchronization,
	 and other factors.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:height:get"><apiName>height</apiName><shortdesc>
	 The nominal height of the loaded file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>If the file is not downloaded sufficiently to retrieve the requested information.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The nominal height of the loaded file. This value might differ from the actual
	 height at which the content is displayed, since the loaded content or its parent
	 display objects might be scaled.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loader:get"><apiName>loader</apiName><shortdesc>
	 The Loader object associated with this LoaderInfo object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Loader</apiValueClassifier><apiException><apiDesc>If the object accessing this API is prevented from 
	 accessing the Loader object because of security restrictions. This can occur, 
	 for instance, when a loaded SWF file attempts to access its <codeph>loaderInfo.loader</codeph> 
	 property and it is not granted security permission to access the loading SWF file.
	 
	 <p>For more information, see the "Flash Player Security" chapter
 	 in <i>Programming ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The Loader object associated with this LoaderInfo object. If this LoaderInfo object
	 is the <codeph>loaderInfo</codeph> property of the instance of the main class of the SWF file, no  
	 Loader object is associated.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loaderURL:get"><apiName>loaderURL</apiName><shortdesc>
	 The URL of the SWF file that initiated the loading of the media
	 described by this LoaderInfo object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The URL of the SWF file that initiated the loading of the media
	 described by this LoaderInfo object.  For the instance of the main class of the SWF file, this
	 URL is the same as the SWF file's own URL.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parameters:get"><apiName>parameters</apiName><shortdesc>
	 An object that contains name-value pairs that represent the parameters provided
	 to the loaded SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 An object that contains name-value pairs that represent the parameters provided
	 to the loaded SWF file.
	 
	 <p>You can use a <codeph>for-in</codeph> loop to extract all the names and values
	 from the <codeph>parameters</codeph> object.</p>
	 
	 <p>The two sources of parameters are: the query string in the
	 URL of the main SWF file, and the value of the <codeph>FlashVars</codeph> HTML parameter (this affects
	 only the main SWF file).</p>
	 
	 <p>The <codeph>parameters</codeph> property replaces the ActionScript 1.0 and 2.0 technique of
	 providing SWF file parameters as properties of the main timeline.</p>
	 
	 <p>The value of the <codeph>parameters</codeph> property is null for Loader objects
	 that contain SWF files that use ActionScript 1.0 or 2.0. It is only
	 non-null for Loader objects that contain SWF files that use ActionScript 3.0.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentAllowsChild:get"><apiName>parentAllowsChild</apiName><shortdesc>
	 Expresses the trust relationship from Loader (parent) to the content (child).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Thrown if the file is not downloaded sufficiently 
	 to retrieve the requested information.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Expresses the trust relationship from Loader (parent) to the content (child). 
	 If the parent has allowed the child access, <codeph>true</codeph>; otherwise, 
	 <codeph>false</codeph>. This property is set to <codeph>true</codeph> if the parent object 
	 called the <codeph>allowDomain()</codeph> method to grant permission to the child domain 
	 or if a URL policy file is loaded at the parent domain granting permission
	 to the child domain. If child and parent are in 
	 the same domain, this property is set to <codeph>true</codeph>.
	 
	 <p>For more information, see the "Flash Player Security" chapter
 	 in <i>Programming ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentSandboxBridge:get"><apiName>parentSandboxBridge</apiName><shortdesc>
	 A object that can be set by code in the Loader object's sandbox to expose properties and methods that can be accessed 
	 by the loaded content's code.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Only content in the Loader object's sandbox can set this property.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 A object that can be set by code in the Loader object's sandbox to expose properties and methods that can be accessed 
	 by the loaded content's code. This <i>sandbox bridge</i> lets content from a non-application domain have controlled 
	 access to scripts in the AIR application sandbox, and vice versa. The sandbox bridge serves as a gateway between 
	 the sandboxes, providing explicit interaction between application and non-application security sandboxes. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/childSandboxBridge"><linktext>childSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:sameDomain:get"><apiName>sameDomain</apiName><shortdesc>
	 Expresses the domain relationship between the loader and the content: true if they have 
	 the same origin domain; false otherwise.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Thrown if the file is not downloaded sufficiently 
	 to retrieve the requested information.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Expresses the domain relationship between the loader and the content: <codeph>true</codeph> if they have 
	 the same origin domain; <codeph>false</codeph> otherwise.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:sharedEvents:get"><apiName>sharedEvents</apiName><shortdesc>
	 An EventDispatcher instance that can be used to exchange events across security boundaries.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.events:EventDispatcher</apiValueClassifier></apiValueDef><apiDesc>
	 An EventDispatcher instance that can be used to exchange events across security boundaries.
	 Even when the Loader object and the loaded content originate from security domains that do not trust
	 one another, both can access <codeph>sharedEvents</codeph> and send and receive events via this object.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:swfVersion:get"><apiName>swfVersion</apiName><shortdesc>
	 The file format version of the loaded SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>If the file is not downloaded sufficiently to retrieve the requested information.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>If the file is not a SWF file.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The file format version of the loaded SWF file.
	 
	 The file format is specified using the enumerations in the
	 SWFVersion class, such as <codeph>SWFVersion.FLASH7</codeph> and <codeph>SWFVersion.FLASH9</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SWFVersion"><linktext>flash.display.SWFVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:url:get"><apiName>url</apiName><shortdesc>
	 The URL of the media being loaded.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The URL of the media being loaded.
	 
	 <p>Before the first <codeph>progress</codeph> event is dispatched by this LoaderInfo 
	 object's corresponding Loader object, the value of the <codeph>url</codeph> property
	 might reflect only the initial URL specified in the call to the <codeph>load()</codeph> 
	 method  of the Loader object.  After the first <codeph>progress</codeph> event, the 
	 <codeph>url</codeph> property reflects the media's final URL, after any redirects and relative 
	 URLs are resolved.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:width:get"><apiName>width</apiName><shortdesc>
	 The nominal width of the loaded content.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>If the file is not downloaded sufficiently to retrieve the requested information.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 The nominal width of the loaded content. This value might differ from the actual
	 width at which the content is displayed, since the loaded content or its parent
	 display objects might be scaled.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageQuality"><apiName>StageQuality</apiName><shortdesc>
The StageQuality class provides values for the Stage.quality property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The StageQuality class provides values for the <codeph>Stage.quality</codeph> property. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/quality"><linktext>flash.display.Stage.quality</linktext></link></related-links><apiValue id="flash.display:StageQuality:BEST"><apiName>BEST</apiName><shortdesc>
Specifies very high rendering quality: graphics are anti-aliased using a 4 x 4 pixel 
grid and bitmaps are always smoothed.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>best</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies very high rendering quality: graphics are anti-aliased using a 4 x 4 pixel 
grid and bitmaps are always smoothed.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
Specifies high rendering quality: graphics are anti-aliased using a 4 x 4 pixel grid, 
and bitmaps are smoothed if the movie is static.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>high</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies high rendering quality: graphics are anti-aliased using a 4 x 4 pixel grid, 
and bitmaps are smoothed if the movie is static. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:LOW"><apiName>LOW</apiName><shortdesc>
Specifies low rendering quality: graphics are not anti-aliased, and bitmaps are not smoothed.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>low</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies low rendering quality: graphics are not anti-aliased, and bitmaps are not smoothed.
This setting is not supported in Adobe AIR.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
Specifies medium rendering quality: graphics are anti-aliased using a 2 x 2 pixel grid, 
but bitmaps are not smoothed.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>medium</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies medium rendering quality: graphics are anti-aliased using a 2 x 2 pixel grid, 
but bitmaps are not smoothed. This setting is suitable for movies that do not contain text.
This setting is not supported in Adobe AIR.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 The BitmapData class lets you work with the data (pixels) of a Bitmap object
 bitmap image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Lets you work with the bitmap data of a Bitmap object.
 
 </apiTipText></apiTipTexts><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The BitmapData class lets you work with the data (pixels) of a <ph platform="actionscript">Bitmap object</ph>
 <ph platform="javascript">bitmap image</ph>. You can use the methods of the BitmapData class
 to create arbitrarily sized transparent or opaque bitmap images and manipulate them in various 
 ways at runtime. <ph platform="actionscript">You can also access the BitmapData for a bitmap image
 that you load with the <codeph>flash.display.Loader</codeph> class.</ph> 
 
 <p platform="actionscript">This class lets you separate bitmap rendering operations from the  
 internal display updating routines of Flash Player.  By manipulating 
 a BitmapData object directly, you can create complex images without incurring the 
 per-frame overhead of constantly redrawing the content from vector data.</p>
 
 <p platform="actionscript">The methods of the BitmapData class support 
 effects that are not available through the filters available to non-bitmap display objects.</p>
 
 <p>A BitmapData object contains an array of pixel data. This data can represent either 
 a fully opaque bitmap or a transparent bitmap that contains alpha channel data. 
 Either type of BitmapData object is stored as a buffer of 32-bit integers. 
 Each 32-bit integer determines the properties of a single pixel in the bitmap.</p>
 
 <p>Each 32-bit integer is a combination of four 8-bit channel values (from 0 to 255) that 
 describe the alpha transparency and the red, green, and blue (ARGB) values of the pixel.
  (For ARGB values, the most significant byte represents the alpha channel value, followed by red, 
 green, and blue.)</p>
 
 <p>The four channels (alpha, red, green, and blue) are represented as numbers
 when you use them with the <codeph>BitmapData.copyChannel()</codeph> method or the 
 <codeph>DisplacementMapFilter.componentX</codeph>
 and <codeph>DisplacementMapFilter.componentY</codeph> properties, and these numbers
 are represented by the following constants in the BitmapDataChannel class:</p>
 
 <ul>
 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
  <li><codeph>BitmapDataChannel.RED</codeph></li>
 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
</ul>
 
 <p platform="actionscript">You can attach BitmapData objects to a Bitmap object by using the 
 <codeph>bitmapData</codeph> property of the Bitmap object.</p>
 
 <p platform="actionscript">You can use a BitmapData object to fill a Graphics object by using the 
 <codeph>Graphics.beginBitmapFill()</codeph> method.</p>
 
 <p>In the AIR runtime, the DockIcon, Icon, InteractiveIcon, and SystemTrayIcon classes each include 
 a <codeph>bitmaps</codeph> property that is an array of BitmapData objects that define the bitmap images 
 for an icon.</p>
 
 <p>In  AIR 1.5 and Flash Player 10, the maximum size for a BitmapData object is 8,191 pixels in width or height, 
 and the total number of pixels cannot exceed 16,777,215 pixels. (So, if a BitmapData object is 8,191 pixels 
 wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is
 2,880 pixels in height and 2,880 in width.</p>
 
 <p>Calls to any method or property of a BitmapData object throw an ArgumentError error if 
 the BitmapData object is invalid (for example, if it has <codeph>height == 0</codeph> and 
 <codeph>width == 0</codeph>) or it has been disposed of via dispose(). </p>
 
 </apiDesc><example conref="examples\BitmapDataExample.as"> The following example uses the class BitmapDataExample to load the
 image Image.gif into a DisplayObject in the default location (0, 0). A copy
 of Image.gif is then placed to the right of the original, which has new colors applied to pixels
 that pass a test using the <codeph>threshold()</codeph> method.
 The task is accomplished using the following steps:
 <ol>
     <li>A <codeph>url</codeph> property is created, which is the location and name of the image file</li>
     <li>The class constructor creates a Loader object, which then instantiates an event listener,
     which is dispatched when the <codeph>completeHandler()</codeph> method completes the image manipulation.</li>
        <li>The <codeph>request</codeph> URLRequest object is then passed to <codeph>loader.load()</codeph>, which loads the image
     into memory by using a display object.</li>
     <li>The image is then placed on the display list, which displays the image on screen at
     coordinates <i>x = 0, y = 0</i>.</li>
     <li>The <codeph>completeHandler()</codeph> method then does the following: 
     <ul>
         <li>Creates a second Loader, along with a Bitmap object, which is initialized with the
         Loader object.</li>
         <li>Creates a second Bitmap object, <codeph>duplicate</codeph>, which in turn calls the
         <codeph>duplicateImage()</codeph> method, which creates a duplicate of the original image. </li>
         <li>Creates a BitmapData object that is assigned to the <codeph>duplicate</codeph> object's
         BitmapData object.</li>
         <li>Creates a new Rectangle object initialized with the same coordinates, width, and height
         as the original image.</li>
         <li>Creates a new Point object, which defaults to <i>x = 0, y = 0</i>.</li>
         <li>Creates the following variables:
         <ul>
             <li><codeph>operation</codeph>  Applies the new color when the threshold
             value is greater than or equal to the original.</li>
             <li><codeph>threshold</codeph>  The value against which each pixel is compared (in this example,
             light gray with an alpha of 0xCC). </li>
             <li><codeph>color</codeph>  The color that the pixels are set to that pass the threshold
             test, which is solid yellow in this case.</li>
             <li><codeph>mask</codeph>  The exact opposite of color (transparent blue).</li>
             <li><codeph>copySource</codeph>  Set to <codeph>false</codeph>, indicating the pixel values are 
             not copied if the threshold value does not pass.  This value has no meaning because
             the image is duplicated and only pixels that pass the threshold test are changed.</li>
      </ul></li>
         <li>Calls the <codeph>threshold()</codeph> method using the preceding variables.  The resulting threshold
         equation is as follows: <codeph>if (current pixel Value &amp; 0x000000FF) &gt;=
         (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>. </li>
  </ul></li>
 </ol>
 <p> <b>Notes:</b>
 <ul>
     <li>You will need to compile the SWF file with Local Playback Security set to Access Local Files Only.
 </li>
     <li>This example requires that a file named Image.gif be placed in the same directory as your SWF file.
 </li>
  <li>It is recommended that you use an image of up to approximately 80 pixels in width. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example><example conref="examples\BitmapDataExample2.as"/></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/bitmapData"><linktext>flash.display.Bitmap.bitmapData</linktext></link><link href="flash.desktop.xml#DockIcon/bitmaps"><linktext>flash.desktop.DockIcon.bitmaps</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.desktop.xml#Icon/bitmaps"><linktext>flash.desktop.Icon.bitmaps</linktext></link><link href="flash.desktop.xml#InteractiveIcon/bitmaps"><linktext>flash.desktop.InteractiveIcon.bitmaps</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.desktop.xml#SystemTrayIcon/bitmaps"><linktext>flash.desktop.SystemTrayIcon.bitmaps</linktext></link></related-links><apiConstructor id="flash.display:BitmapData:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 	 Creates a  BitmapData object with a specified width and height.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>width and/or height exceed the maximum dimensions.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The width of the bitmap image in pixels.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The height of the bitmap image in pixels.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>transparent</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Specifies whether the bitmap image  supports per-pixel transparency.
	 The default value is <codeph>true</codeph> (transparent). To create a fully transparent bitmap, set the value 
	 of the <codeph>transparent</codeph> parameter to <codeph>true</codeph> and the value of the <codeph>fillColor</codeph> 
	 parameter to 0x00000000 (or to 0). Setting the <codeph>transparent</codeph> property to <codeph>false</codeph>
	 can result in minor improvements in rendering performance. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>A 32-bit ARGB color value that you use to fill the bitmap image area. 
	 The default value is 0xFFFFFFFF (solid white).
	 
 	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Creates a  BitmapData object with a specified width and height. 
	 If you specify a value for the  <codeph>fillColor</codeph> parameter, every pixel in the bitmap is set 
   	 to that color.
	 
	 <p>By default, the bitmap is created as transparent, unless you pass the value <codeph>false</codeph> 
	 for the <codeph>transparent</codeph> parameter. After you create an opaque bitmap, you cannot change it to 
	 a transparent bitmap. Every pixel in an opaque bitmap uses only 24 bits of color channel information. 
	 If you define the bitmap as transparent, every pixel uses 32 bits of color channel information,
	 including an alpha transparency channel.</p>
	 
	 <p>In  AIR 1.5 and Flash Player 10, the maximum size for a BitmapData object is 8,191 pixels in width or height, 
	 and the total number of pixels cannot exceed 16,777,215 pixels. (So, if a BitmapData object is 8,191 pixels 
	 wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is
	 2,880 pixels in height and 2,880 pixels in width.
	 If you specify a width or height value that is greater than 2880, a new instance is not created.</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:BitmapData:applyFilter"><apiName>applyFilter</apiName><shortdesc>
	 Takes a source image and a filter object and generates the 
	 filtered image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceBitmapData, sourceRect, destPoint or filter are null.
 	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>The transparency of the BitmapData objects are not
	 compatible with the filter operation.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>A number that indicates whether the filter was applied successfully. 
	 If 0 is returned, the filter was applied successfully. 
	 If a negative number is returned, an error occurred during the application of the filter.
	 
	 </apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The input bitmap image to use. The source image can be a different 
	 BitmapData object or it can refer to the current BitmapData instance.

	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle that defines the area of the source image to use as input.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point within the destination image (the current BitmapData 
	 instance) that corresponds to the upper-left corner of the source rectangle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>The filter object that you use to perform the filtering operation. Each type 
	 of filter has certain requirements, as follows:
	 
	 <ul><li><b>BlurFilter</b> — 
	 This filter can use source and destination images
	 that are either opaque or transparent. If the formats of the images do
	 not match, the copy of the source image that is made during the
	 filtering matches the format of the destination image.</li>
	 
	 <li><b>BevelFilter, DropShadowFilter, GlowFilter, ChromeFilter</b> — 
	 The destination image of these filters must be a transparent
	 image. Calling DropShadowFilter or GlowFilter creates an image that
	 contains the alpha channel data of the drop shadow or glow. It does not
	 create the drop shadow onto the destination image. If you use any of these
	 filters with an opaque destination image, an exception
	 is thrown.</li>
	 
	 <li><b>ConvolutionFilter</b> — This filter can use source and
	 destination images that are either opaque or transparent.</li>
	 
	 <li><b>ColorMatrixFilter</b> — This filter can use source and
	 destination images that are either opaque or transparent.</li>
	 
	 <li><b>DisplacementMapFilter</b> — This filter can use source and
	 destination images that are either opaque or transparent, but the
	 source and destination image formats must be the same.</li></ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Takes a source image and a filter object and generates the 
	 filtered image.
	 
	 <p>This method relies on the behavior of built-in filter
	 objects, which determine the destination
	 rectangle that is affected by an input source rectangle.</p>
	 
	 <p>After a filter is applied, the resulting image can be larger than the input image. 
	 For example, if you use a BlurFilter class 
	 to blur a source rectangle of (50,50,100,100) and a
	 destination point of (10,10), the area that changes in the
	 destination image is larger than (10,10,60,60) because of
	 the blurring. This happens internally during the <codeph>applyFilter()</codeph>
	 call.</p>
	 
	 <p>If the <codeph>sourceRect</codeph> parameter of the <codeph>sourceBitmapData</codeph> parameter is 
	 an interior region, such as (50,50,100,100) in a 200 x 200 image, the filter uses the source 
	 pixels outside the <codeph>sourceRect</codeph> parameter to generate
	 the destination rectangle.</p>
	 
	 <p>If the BitmapData object and the object specified as the <codeph>sourceBitmapData</codeph>
	 parameter are the same object, the application uses a temporary copy of the object to 
	 perform the filter. For best performance, avoid this situation.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.applyFilter.1.as"> The following example shows how to apply a blur filter to a BitmapData instance:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>flash.filters.BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>flash.filters.BlurFilter</linktext></link><link href="flash.filters.xml#ColorMatrixFilter"><linktext>flash.filters.ColorMatrixFilter</linktext></link><link href="flash.filters.xml#ConvolutionFilter"><linktext>flash.filters.ConvolutionFilter</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>flash.filters.DropShadowFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>flash.filters.GlowFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:clone"><apiName>clone</apiName><shortdesc>
	 Returns a new BitmapData object that is a clone of the original instance
	 with an exact copy of the contained bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new BitmapData object that is identical to the original.
	 
	 </apiDesc><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Returns a new BitmapData object with an exact copy of the original bitmap.

	  

	  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Returns a new BitmapData object that is a clone of the original instance
	 with an exact copy of the contained bitmap.
	 
	 </apiDesc><example conref="examples\BitmapData.clone.1.as"> The following example shows how to clone a BitmapData instance, and it shows that when you modify the 
 cloned BitmapData instance, the original remains unmodified:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:colorTransform"><apiName>colorTransform</apiName><shortdesc>
	 Adjusts the color values in a specified area of a bitmap image by using a 
	 ColorTransform object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The rect or colorTransform are null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A Rectangle object that defines the area of the image in which the 
	 ColorTransform object is applied.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>A ColorTransform object that describes the color transformation 
	 values to apply.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Adjusts the color values in a specified area of a bitmap image by using a 
	 <codeph>ColorTransform</codeph> object. If the rectangle 
	 matches the boundaries of the bitmap image, this method transforms the color values of  
	 the entire image.
	 
	 </apiDesc><example conref="examples\BitmapData.colorTransform.1.as"> The following example shows how to apply a color transform to the left half (rectangle) of a 
 BitmapData object:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:compare"><apiName>compare</apiName><shortdesc>
	 
	 Compares two BitmapData objects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The otherBitmapData is null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>If the two BitmapData objects have the same dimensions (width and height), the 
	 method returns a new BitmapData object that has the difference between the two objects (see the
	 main discussion). If the BitmapData objects are equivalent, the method returns the number 0. 
	 If the widths of the BitmapData objects are not equal, the method returns the number -3. 
	 If the heights of the BitmapData objects are not equal, the method returns the number -4. 
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>otherBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The BitmapData object to compare with the source BitmapData object.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Compares two BitmapData objects. If the two BitmapData objects have the same dimensions 
	 (width and height), the method returns a new BitmapData object, in which each pixel is 
	 the "difference" between the pixels in the two source objects:
	 
	 <ul>
	 
	 	<li>If two pixels are equal, the difference pixel is 0x00000000. </li>
	 
	 	<li>If two pixels have different RGB values (ignoring the alpha value), the difference 
	 pixel is 0xRRGGBB where RR/GG/BB are the individual difference values between red, green, 
	 and blue channels (the pixel value in the source object minus the pixel value in the 
	 <codeph>otherBitmapData</codeph> object). Alpha channel differences are ignored in this case. </li> 
	 
	 	<li>If only the alpha channel value is different, the pixel value is 0x<i>ZZ</i>FFFFFF, 
	 where <i>ZZ</i> is the difference in the alpha values (the alpha value in the source object 
	 minus the alpha value in the <codeph>otherBitmapData</codeph> object).</li>
	 
	 </ul>
	 
	 <p>For example, consider the following two BitmapData objects:</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
     </codeblock>
	 
	 <p><b>Note:</b> The colors used to fill the two BitmapData objects have slightly different RGB values
	 (0xFF0000 and 0xFFAA00). The result of the <codeph>compare()</codeph> method is a new BitmapData
	 object with each pixel showing the difference in the RGB values between the two bitmaps.</p>
	 
	 <p>Consider the following two BitmapData objects, in which the RGB colors are the same,
	 but the alpha values are different:</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
	 </codeblock>
	 
	 <p>The result of the <codeph>compare()</codeph> method is a new BitmapData
	 object with each pixel showing the difference in the alpha values between the two bitmaps.</p>
	 
	 <p>If the BitmapData objects are equivalent (with the same width, height, and identical pixel values), 
	 the method returns the number 0.</p>
	 
	 <p>If the widths of the BitmapData objects are not equal, the method returns the number -3. </p>
	 
	 <p>If the heights of the BitmapData objects are not equal, but the widths are the same, 
	 the method returns the number -4.</p>
	 
	 <p>The following example compares two Bitmap objects with different widths (50 and 60):</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 </apiDesc><example conref="examples\BitmapData.compare.1.as"> The following example shows the value of a pixel in the BitmapData object that results from 
 comparing two BitmapData objects of the same dimensions:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:copyChannel"><apiName>copyChannel</apiName><shortdesc>
	 Transfers data from one channel of another BitmapData object or the current 
	 BitmapData object into a channel of the current BitmapData object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceBitmapData, sourceRect or destPoint are null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The input bitmap image to use. The source image can be a different BitmapData object 
	 					or it can refer to the current BitmapData object.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>The source Rectangle object. To copy only channel data from a smaller area 
	 within the bitmap, specify a source rectangle that is smaller than the overall size of the
	 BitmapData object. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The destination Point object that represents the upper-left corner of the rectangular area 
	 where the new channel data is placed. 
 	 To copy only channel data
 	 from one area to a different area in the destination image, specify a point other than (0,0).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The source channel. Use a value from the BitmapDataChannel class
	 (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, 
	 <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The destination channel. Use a value from the BitmapDataChannel class
	 (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, 
	 <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Transfers data from one channel of another BitmapData object or the current 
	 BitmapData object into a channel of the current BitmapData object. 
	 All of the data in the other channels in the destination BitmapData object are 
	 preserved.
	 
	 <p>The source channel value and destination channel value can be
	 one of following values: </p>
	 <ul>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 </ul>

	 
	 </apiDesc><example conref="examples\BitmapData.copyChannel.1.as"> The following example shows how to copy the red channel in a BitmapData object to its own
 blue channel in a 20 x 20 pixel region:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:copyPixels"><apiName>copyPixels</apiName><shortdesc>
	 Provides a fast routine to perform pixel manipulation
	 between images with no stretching, rotation, or color effects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceBitmapData, sourceRect, destPoint are null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The input bitmap image from which to copy pixels. The source image can be a 
	 different BitmapData instance, or it can refer to the current BitmapData 
	 instance.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle that defines the area of the source image to use as input.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The destination point that represents the upper-left corner of the rectangular 
	 area where the new pixels are placed.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>A secondary, alpha BitmapData object source.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>The point in the alpha BitmapData object source that corresponds to 
	 the upper-left corner of the <codeph>sourceRect</codeph> parameter.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mergeAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>To use the alpha channel, set the value to 
	 <codeph>true</codeph>. To copy pixels with no alpha channel, set the value to 
	 <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Provides a fast routine to perform pixel manipulation
	 between images with no stretching, rotation, or color effects. This method copies a
	 rectangular area of a source image to a
	 rectangular area of the same size at the destination point of the destination 
	 BitmapData object.
	 
	 <p>If you include the <codeph>alphaBitmap</codeph> and <codeph>alphaPoint</codeph> parameters, you can use a secondary 
	 image as an alpha source for the source image. If the source
	 image has alpha data, both sets of alpha data are used to
	 composite pixels from the source image to the destination image. The
	 <codeph>alphaPoint</codeph> parameter is the point in the alpha image that
	 corresponds to the upper-left corner of the source
	 rectangle. Any pixels outside the intersection of the source
	 image and alpha image are not copied to the destination image.</p>
	 
	 <p>The <codeph>mergeAlpha</codeph> property controls whether or not the alpha
	 channel is used when a transparent image is copied onto
	 another transparent image. To copy
	 pixels with the alpha channel data, set the <codeph>mergeAlpha</codeph>
	 property to <codeph>true</codeph>. By default, the <codeph>mergeAlpha</codeph> property is
	 <codeph>false</codeph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.copyPixels.1.as"> The following example shows how to copy pixels from a 20 x 20 pixel region in one BitmapData object
 to another BitmapData object:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:dispose"><apiName>dispose</apiName><shortdesc>
	 Frees memory that is used to store the BitmapData object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Frees memory that is used to store the BitmapData object. 
	 
	 <p>When the <codeph>dispose()</codeph> method is called on an image, the width and height of the image are set to 0. 
	 All subsequent calls to methods or properties of this BitmapData instance fail, and an  
	 exception is thrown. </p>
	 <p><codeph>BitmapData.dispose()</codeph> releases the memory occupied by the actual bitmap data, immediately (a bitmap can consume up to 64 MB of memory). 
	 After using <codeph>BitmapData.dispose()</codeph>, the BitmapData object is no longer usable and the Flash runtime throws an exception if you call 
	 functions on the BitmapData object.
	 However, <codeph>BitmapData.dispose()</codeph> does not garbage collect the BitmapData object (approximately 128 bytes); the memory occupied by the actual
	 BitmapData object is released at the time the BitmapData object is collected by the garbage collector.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.dispose.1.as"> The following example shows the effect of calling a method of a BitmapData object after a call to the 
 <codeph>dispose()</codeph> method (an exception is thrown):
<codeblock>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.system.xml#System/gc()"><linktext>flash.system.System.gc()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:draw"><apiName>draw</apiName><shortdesc>
	 Draws the source display object onto the bitmap image, using the
	 Flash Player or  AIR vector renderer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The <codeph>source</codeph> parameter is not a BitmapData
	 or DisplayObject object.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>The <codeph>source</codeph> object and (in the case of
	 a Sprite or MovieClip object) all of its child objects do not come from the same domain as 
	 the caller, or are not in a content that is accessible to the caller by having called the 
	 <codeph>Security.allowDomain()</codeph> method. This restriction does not apply
	 to AIR content in the application security sandbox.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>The source is null or not a valid IBitmapDrawable object.
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>flash.display:IBitmapDrawable</apiOperationClassifier><apiDesc>The display object or BitmapData object to draw to the BitmapData object.
	 (The DisplayObject and BitmapData classes implement the IBitmapDrawable interface.)
	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>A Matrix object used to scale, rotate, or translate the coordinates 
	 of the bitmap. If you do not want to apply a matrix transformation to the image, 
	 set this parameter to an identity matrix, created with the default 
	 <codeph>new Matrix()</codeph> constructor, or pass a <codeph>null</codeph> value.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>A ColorTransform object that you use to adjust the color values of 
	 the bitmap. If no object is supplied, the bitmap image's colors are not transformed.
	 If you must pass this parameter but you do not want to transform the image, set this 
	 parameter to a ColorTransform object created with the default <codeph>new ColorTransform()</codeph> 
	 constructor.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>blendMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>A string value, from the flash.display.BlendMode class, specifying the 
	 blend mode to be applied to the resulting bitmap. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>A Rectangle object that defines the area of the source object to draw. 
	 If you do not supply this value, no clipping occurs and the entire source object is drawn.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>A Boolean value that determines whether a BitmapData object is 
	 smoothed when scaled or rotated, due to a scaling or rotation in the <codeph>matrix</codeph>
	 parameter. The <codeph>smoothing</codeph> parameter only applies if the <codeph>source</codeph>
	 parameter is a BitmapData object. With <codeph>smoothing</codeph> set to <codeph>false</codeph>,
	 the rotated or scaled BitmapData image can appear pixelated or jagged. For example, the following
	 two images use the same BitmapData object for the <codeph>source</codeph> parameter, but the
	 <codeph>smoothing</codeph> parameter is set to <codeph>true</codeph> on the left and <codeph>false</codeph>
	 on the right:
	 
	 <p><adobeimage alt="Two images: the left one with smoothing and the right one without smoothing." href="../../images/bitmapData_draw_smoothing.jpg"/></p>
	 
	 <p>Drawing a bitmap with <codeph>smoothing</codeph> set to <codeph>true</codeph> takes longer 
	 than doing so with <codeph>smoothing</codeph> set to <codeph>false</codeph>.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Draws the <codeph>source</codeph> display object onto the bitmap image, using the
	 <ph platform="actionscript">Flash Player or </ph> AIR vector renderer. 
	 You can specify <codeph>matrix</codeph>, <codeph>colorTransform</codeph>, 
	 <codeph>blendMode</codeph>, and a destination <codeph>clipRect</codeph> parameter to control
	 how the rendering performs. Optionally, you can specify whether the bitmap
	 should be smoothed when scaled (this works only if the source object
 	 is a BitmapData object).
	  
	 <p>This method directly corresponds to how objects are drawn
	 with the standard vector renderer for objects in the authoring tool
	 interface.</p>
	 
	 <p>The source display object does not use any of its applied transformations
	 for this call. It is treated as it exists in the library or
	 file, with no matrix transform, no color transform, and no blend
	 mode. To draw a display object (such as a movie clip) by using its own transform properties, 
	 you can copy its <codeph>transform</codeph> property object to the <codeph>transform</codeph> property 
	 of the Bitmap object that uses the BitmapData object.</p>
	 
     <p>This method is supported over RTMP in <ph platform="actionscript">Flash Player 9.0.115.0
	 and later and in</ph> Adobe AIR. You can control access to streams on 
     Flash Media Server in a server-side script. For more information, see the <codeph>Client.audioSampleAccess</codeph>
     and <codeph>Client.videoSampleAccess</codeph> properties in <xref href="http://www.adobe.com/go/documentation" scope="external">
     <i>Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></xref>.</p>
	 
	 <p platform="actionscript">If the source object and (in the case of a Sprite or MovieClip object) all 
	 of its child objects do not come from the same domain as the caller, or are not in a content that is 
	 accessible to the caller by having called the <codeph>Security.allowDomain()</codeph> method, a call to
	 the <codeph>draw()</codeph> throws a SecurityError exception. This restriction does not apply
	 to AIR content in the application security sandbox.</p>
	 
	 <p platform="actionscript">There are also restrictions on using a loaded bitmap image as the <codeph>source</codeph>.
	 A call to the <codeph>draw()</codeph> method is successful if the loaded image comes from the same domain as the caller. 
	 Also, a cross-domain policy file on the image's server can grant permission to the domain of the SWF content
	 calling the <codeph>draw()</codeph> method. In this case, you must set the <codeph>checkPolicyFile</codeph> property 
	 of a LoaderContext object, and use this object as the <codeph>context</codeph> parameter when calling the <codeph>load()</codeph> 
	 method of the Loader object used to load the image. These restrictions do not apply to AIR content in the 
	 application security sandbox.</p>
	 
	 <p>On Windows, the <codeph>draw()</codeph> method cannot capture SWF content embedded in an HTML 
	 page<ph platform="actionscript"> in an HTMLLoader object in Adobe AIR</ph>.</p>
	 
	 <p>The <codeph>draw()</codeph> method cannot capture PDF content<ph platform="actionscript"> in Adobe AIR</ph>.
	 Nor can it capture  or SWF content embedded in HTML in which the <codeph>wmode</codeph> attribute is set
	 to <codeph>"window"</codeph><ph platform="actionscript"> in Adobe AIR</ph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.draw.1.as"> The following example shows how to draw a TextField object to a BitmapData object:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:fillRect"><apiName>fillRect</apiName><shortdesc>
	 Fills a rectangular area of pixels with a specified ARGB color.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The rect is null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>The rectangular area to fill.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The ARGB color value that fills the area. ARGB colors are often 
	 specified in hexadecimal format; for example, 0xFF336699.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Fills a rectangular area of pixels with a specified ARGB color.
	 
	 </apiDesc><example conref="examples\BitmapData.fillRect.1.as"> The following example shows how to fill a rectangular region of a BitmapData object with blue:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:floodFill"><apiName>floodFill</apiName><shortdesc>
	 Performs a flood fill operation on an image starting
	 at an (x, y) coordinate and filling with a certain color.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>x</i> coordinate of the image.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>y</i> coordinate of the image.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The ARGB color to use as a fill.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Performs a flood fill operation on an image starting
	 at a (x, y) coordinate.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Performs a flood fill operation on an image starting
	 at an (<i>x</i>, <i>y</i>) coordinate and filling with a certain color. The 
	 <codeph>floodFill()</codeph> method is similar to the paint bucket tool in various paint 
	 programs. The color is an ARGB color that contains alpha information and
   	 color information.
	 
	 </apiDesc><example conref="examples\BitmapData.floodFill.1.as"> The following example shows how to fill a region of a BitmapData object  that is, the region 
 surrounding the pixel defined by the point <codeph>(10, 10)</codeph> iin which all colors march the color at that 
 point  with red
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:generateFilterRect"><apiName>generateFilterRect</apiName><shortdesc>
	 Determines the destination rectangle that the applyFilter() method call affects, given a 
	 BitmapData object, a source rectangle, and a filter object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceRect or filter are null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>A destination rectangle computed by using an image, the <codeph>sourceRect</codeph> parameter, 
	 and a filter.
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle defining the area of the source image to use as input.
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>A filter object that you use to calculate the destination rectangle.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Determines the destination rectangle that will be affected by the applyFilter() call.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Determines the destination rectangle that the <codeph>applyFilter()</codeph> method call affects, given a 
	 BitmapData object, a source rectangle, and a filter object.
	 
	 <p>For example, a blur filter normally affects an area larger than the size of the original 
	 image. A 100 x 200 pixel image that is being filtered by a default BlurFilter 
	 instance, where <codeph>blurX = blurY = 4</codeph> generates a destination rectangle of 
	 <codeph>(-2,-2,104,204)</codeph>.
	 The <codeph>generateFilterRect()</codeph> method lets you find out the size of this destination 
	 rectangle in advance so that you can size the destination image appropriately before you perform a filter 
	 operation.</p>
	 
	 <p>Some filters clip their destination rectangle based on the source image size. 
	 For example, an inner <codeph>DropShadow</codeph> does not generate a larger result than its source
	 image. In this API, the BitmapData object is used as the source bounds and not the 
	 source <codeph>rect</codeph> parameter.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.generateFilterRect.1.as"> The following example shows how you can use the <codeph>generateFilterRect()</codeph> method to 
 determine the rectangular area that the result of a blur filter will occupy. The results of the 
 <codeph>generateFilterRect()</codeph> method are output by the <codeph>trace()</codeph> function:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock> Note that the <codeph>generateFilterRect()</codeph> method does not apply the filter. Call the <codeph>applyFilter()</codeph> method 
 to apply the filter. 
</example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getColorBoundsRect"><apiName>getColorBoundsRect</apiName><shortdesc>
	 Determines a rectangular region that either fully encloses all pixels of a specified color within the 
	 bitmap image (if the findColor parameter is set to true) or fully encloses
	 all pixels that do not include the specified color (if the findColor parameter is set 
	 to false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The region of the image that is the specified color. 
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>A hexadecimal value, specifying the bits of the ARGB color to consider. The color 
	 value is combined with this hexadecimal value, by using the <codeph>&amp;</codeph> (bitwise AND) operator.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>A hexadecimal value, specifying the ARGB color to match (if <codeph>findColor</codeph>
	 is set to <codeph>true</codeph>) or <i>not</i> to match (if <codeph>findColor</codeph>
	 is set to <codeph>false</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>findColor</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>If the value is set to <codeph>true</codeph>, returns the bounds of a color value in an image. 
	 If the value is set to <codeph>false</codeph>, returns the bounds of where this color doesn't exist in an image. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Determines a rectangular region that either fully encloses all pixels of a specified color within the 
	 bitmap image (if the <codeph>findColor</codeph> parameter is set to <codeph>true</codeph>) or fully encloses
	 all pixels that do not include the specified color (if the <codeph>findColor</codeph> parameter is set 
	 to <codeph>false</codeph>). 
	 
	 <p>For example, if you have a source image and you want to determine the rectangle of
	 the image that contains a nonzero alpha channel, pass
	 <codeph>{mask: 0xFF000000, color: 0x00000000}</codeph> as parameters. If the <codeph>findColor</codeph>
	 parameter is set to <codeph>true</codeph>, the entire image is searched for the bounds of pixels 
	 for which <codeph>(value &amp; mask) == color</codeph> (where <codeph>value</codeph> is the color value
	 of the pixel). If the <codeph>findColor</codeph> parameter is set to <codeph>false</codeph>, the entire 
	 image is searched for the bounds of pixels for which <codeph>(value &amp; mask) != color</codeph> 
	 (where <codeph>value</codeph> is the color value of the pixel). To determine white space around an
	 image, pass <codeph>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</codeph>
	 to find the bounds of nonwhite pixels.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getColorBoundsRect.1.as"> The following example creates a BitmapData object with red in the top half of its pixels. It then calls
 the <codeph>getColorBoundsRect()</codeph> method to determine the rectangle in which pixels are red (0xFF0000), and 
 then it calls the same method to determine the rectangle in which pixels are not red (by setting the 
 <codeph>findColor</codeph> parameter to <codeph>false</codeph>:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getPixel"><apiName>getPixel</apiName><shortdesc>
	 Returns an integer that represents  an RGB pixel value from a BitmapData object at
	 a specific point (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A number that represents an RGB pixel value. If the (<i>x</i>, <i>y</i>) coordinates are 
	 outside the bounds of the image, the method returns 0. 
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>x</i> position of the pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>y</i> position of the pixel.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Returns an integer representing a RGB pixel value from a BitmapData object at
	 a specific point.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Returns an integer that represents  an RGB pixel value from a BitmapData object at
	 a specific point (<i>x</i>, <i>y</i>). The <codeph>getPixel()</codeph> method returns an
	 unmultiplied pixel value. No alpha information is returned.
	 
	 <p>All pixels in a BitmapData object are stored as premultiplied color values. 
	 A premultiplied image pixel has the red, green, and blue 
	 color channel values already multiplied by the alpha data. For example, if the 
	 alpha value is 0, the values for the RGB channels are also 0, independent of their unmultiplied 
	 values. This loss of data can cause some problems when you perform operations. All BitmapData 
	 methods take and return unmultiplied values. The internal pixel representation is converted 
	 from premultiplied to unmultiplied before it is returned as a value. During a set operation, 
	 the pixel value is premultiplied before the raw image pixel is set.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel.1.as"> The following example creates a BitmapData object filled with red, then uses the 
 <codeph>getPixel()</codeph> method to determine the color value in the upper-left pixel:
<codeblock>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(1, 1);
trace(pixelValue.toString(16)); // ff0000;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixel32"><apiName>getPixel32</apiName><shortdesc>
	 Returns an ARGB color value that contains alpha channel data and RGB
	 data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A number representing an ARGB pixel value. If the (<i>x</i>, <i>y</i>) coordinates are 
   	 outside the bounds of the image, 0 is returned.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>x</i> position of the pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>y</i> position of the pixel.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Returns an ARGB color value that contains alpha channel data and RGB
	 data. This method is similar to the <codeph>getPixel()</codeph> method, which returns an
	 RGB color without alpha channel data.
	 
	 <p>All pixels in a BitmapData object are stored as premultiplied color values. 
	 A premultiplied image pixel has the red, green, and blue 
	 color channel values already multiplied by the alpha data. For example, if the 
	 alpha value is 0, the values for the RGB channels are also 0, independent of their unmultiplied 
	 values. This loss of data can cause some problems when you perform operations. All BitmapData 
	 methods take and return unmultiplied values. The internal pixel representation is converted 
	 from premultiplied to unmultiplied before it is returned as a value. During a set operation, 
	 the pixel value is premultiplied before the raw image pixel is set.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel32.1.as"> The following example creates a BitmapData object filled with a color, then uses the 
 <codeph>getPixel32()</codeph> method to determine the color value in the upper-left pixel, and then
 determines the hexidecimal values for each color component (alpha, red, green, and blue):
<codeblock>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(1, 1);
var alphaValue:uint = pixelValue &gt;&gt; 24 &amp; 0xFF;
var red:uint = pixelValue &gt;&gt; 16 &amp; 0xFF;
var green:uint = pixelValue &gt;&gt; 8 &amp; 0xFF;
var blue:uint = pixelValue &amp; 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixels"><apiName>getPixels</apiName><shortdesc>
	 Generates a byte array from a rectangular region of pixel data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The rect is null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>A ByteArray representing the pixels in the given Rectangle.
	 
	 </apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangular area in the current BitmapData object.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Generates a byte array from a rectangular region of pixel data. 
	 Writes an unsigned integer (a 32-bit unmultiplied pixel value)
	 for each pixel into the byte array.
	 
	 </apiDesc><example conref="examples\BitmapData.getPixels.1.as"> The following example creates a BitmapData object filled with random noise pixels, then uses the 
 <codeph>getPixels()</codeph> method to fill a ByteArray object with the pixel values of the BitmapData object
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getVector"><apiName>getVector</apiName><shortdesc>
	 Generates a vector array from a rectangular region of pixel data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The rect is null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>A Vector representing the given Rectangle.
	 </apiDesc><apiType value="Vector$uint"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangular area in the current BitmapData object.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Generates a vector array from a rectangular region of pixel data. 
	 Returns a Vector object of unsigned integers (a 32-bit unmultiplied pixel value)
	 for the specified rectangle.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:histogram"><apiName>histogram</apiName><shortdesc>
	 Computes a 256-value binary number histogram of a BitmapData object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Vector$Vector$Number"/></apiReturn><apiParam><apiItemName>hRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>The area of the BitmapData object to use.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Computes a 256-value binary number histogram of a BitmapData object. This method returns a Vector object 
	 containing four Vector.&lt;Number&gt; instances (four Vector objects that contain Number objects). 
	 The four Vector instances represent the red, green, blue and alpha components 
	 in order. Each Vector instance contains 256 values that represent the population 
	 count of an individual component value, from 0 to 255.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:hitTest"><apiName>hitTest</apiName><shortdesc>
	 Performs pixel-level hit detection between one bitmap image
	 and a point, rectangle, or other bitmap image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The <codeph>secondObject</codeph> parameter is not a Point, Rectangle, 
	 Bitmap, or BitmapData object.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>The firstPoint is null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>A value of <codeph>true</codeph> if a hit occurs; otherwise, <codeph>false</codeph>.
	    
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>firstPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc> A position of the upper-left corner of the BitmapData image in an arbitrary coordinate space.
	 The same coordinate space is used in defining the <codeph>secondBitmapPoint</codeph> parameter.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>firstAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The smallest alpha channel value that is considered opaque for this hit test.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>A  Rectangle, Point, Bitmap, or BitmapData object.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondBitmapDataPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>A point that defines a pixel location in the second BitmapData object. 
	                           Use this parameter only when the value of <codeph>secondObject</codeph> is a 
	                           BitmapData object.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>1</apiData><apiDesc>The smallest alpha channel value that is considered opaque in the second BitmapData object.
	                           Use this parameter only when the value of <codeph>secondObject</codeph> is a 
	                           BitmapData object and both BitmapData objects are transparent.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Performs pixel-level hit detection between one bitmap image
	 and a point, rectangle, or other bitmap image. A hit is defined as 
	 an overlap of a point or rectangle over an opaque pixel, or two 
	 overlapping opaque pixels. No stretching,
	 rotation, or other transformation of either object is considered when 
	 the hit test is performed. 
	 
	 <p>If an image is an opaque image, it is considered a fully opaque rectangle for this 
	 method. Both images must be transparent images to perform pixel-level hit testing that 
	 considers transparency. When you are testing two transparent images, the alpha threshold 
	 parameters control what alpha channel values, from 0 to 255, are considered opaque.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.hitTest.1.as"> The following example creates a BitmapData object that is only opaque in a rectangular region
 (20, 20, 40, 40) and calls the <codeph>hitTest()</codeph> method with a Point object as the <codeph>secondObject</codeph>.
 In the first call, the Point object defines the upper-left corner of the BitmapData object, which is not opaque, and
 in the second call, the Point object defines the center of the BitmapData object, which is opaque.
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:lock"><apiName>lock</apiName><shortdesc>
	 Locks an image so that any objects that reference the BitmapData object, such as Bitmap objects, 
	 are not updated when this BitmapData object changes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Locks an image so that any objects that reference the BitmapData object, such as Bitmap objects, 
	 are not updated when this BitmapData object changes. To improve performance, use this method  
	 along with the <codeph>unlock()</codeph> method before and after numerous calls to the 
	 <codeph>setPixel()</codeph> or <codeph>setPixel32()</codeph> method.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> The following example creates a BitmapData object based on the
 <codeph>bitmapData</codeph> property of a Bitmap object, <codeph>picture</codeph>.
 It then calls the <codeph>lock()</codeph> method before calling a complicated custom function, 
 <codeph>complexTransformation()</codeph>, that modifies the BitmapData object. (The <codeph>picture</codeph> object
 and the <codeph>complexTransformation()</codeph> function are not defined in this example.) Even if the
 <codeph>complexTransformation()</codeph> function updates the <codeph>bitmapData</codeph> property of 
 the <codeph>picture</codeph> object, changes are not reflected until the code calls the 
 <codeph>unlock()</codeph> method on the <codeph>bitmapData</codeph> object:
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:merge"><apiName>merge</apiName><shortdesc>
     Performs per-channel blending from a source image to a destination image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceBitmapData, sourceRect or destPoint are null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The input bitmap image to use. The source image can be a different 
	 BitmapData object, or it can refer to the current BitmapData object.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle that defines the area of the source image to use as input.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point within the destination image (the current BitmapData 
	 instance) that corresponds to the upper-left corner of the source rectangle.
     </apiDesc></apiParam><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>A hexadecimal uint value by which to multiply the red channel value. 
     </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>A hexadecimal uint value by which to multiply the green channel value. 
     </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>A hexadecimal uint value by which to multiply the blue channel value.
     </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>A hexadecimal uint value by which to multiply the alpha transparency value.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Performs per-channel blending from a source image to a destination image. For each channel 
     and each pixel, a new value is computed based on the channel values of the source and destination 
     pixels. For example, in the red channel, the new value is computed as follows (where <codeph>redSrc</codeph>
     is the red channel value for a pixel in the source image and <codeph>redDest</codeph> is the red channel 
     value at the corresponding pixel of the destination image): 
	 <p>
	 <codeph>
	 new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256;
	 </codeph>
	 </p>
	 
	 <p>The <codeph>redMultiplier</codeph>, <codeph>greenMultiplier</codeph>, <codeph>blueMultiplier</codeph>, and 
     <codeph>alphaMultiplier</codeph> values are the multipliers used for each color channel. Use a hexadecimal
     value ranging from <codeph>0</codeph> to <codeph>0x100</codeph> (256) where <codeph>0</codeph> specifies the full
     value from the destination is used in the result, <codeph>0x100</codeph> specifies the full value from the
     source is used, and numbers in between specify a blend is used (such as <codeph>0x80</codeph> for 50%).</p>
	 
	 </apiDesc><example conref="examples\BitmapData.merge.1.as"> The following example creates two BitmapData objects. Both are 100 x 80 pixels in size. The first
 is filled with green and the second is filled with red. The code calls the <codeph>merge()</codeph> method, merging
 the second BitmapData pixels into the first BitmapData object, but only on a specified rectangular area:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:noise"><apiName>noise</apiName><shortdesc>
	 Fills an image with pixels representing random noise.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The random seed number to use. If you keep all other parameters 
	 the same, you can generate different pseudo-random results by varying the random seed value. The noise 
	 function is a mapping function, not a true random-number generation function, so it creates the same 
	 results each time from the same random seed.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>low</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>The lowest value to generate for each channel (0 to 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>high</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>255</apiData><apiDesc>The highest value to generate for each channel (0 to 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc>A number that can be a combination of any of
	 the four color channel values (<codeph>BitmapDataChannel.RED</codeph>, 
	 <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, and 
	 <codeph>BitmapDataChannel.ALPHA</codeph>). You can use the logical OR 
	 operator (<codeph>|</codeph>) to combine channel values. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>A Boolean value. If the value is <codeph>true</codeph>, a grayscale image is created by setting
	 all of the color channels to the same value. 
	 The alpha channel selection is not affected by
	 setting this parameter to <codeph>true</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Fills an image with pixels representing random noise.
	 
	 </apiDesc><example conref="examples\BitmapData.noise.1.as"> The following example creates two BitmapData objects and calls the <codeph>noise()</codeph>
 method on both. However, the <codeph>grayscale</codeph> parameter is set to <codeph>false</codeph> for the 
 call to the <codeph>noise()</codeph> method of the first object, and it is set to <codeph>true</codeph> for the 
 call to the <codeph>noise()</codeph> method of the second object:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapDataChannel/RED"><linktext>flash.display.BitmapDataChannel.RED</linktext></link><link href="flash.display.xml#BitmapDataChannel/BLUE"><linktext>flash.display.BitmapDataChannel.BLUE</linktext></link><link href="flash.display.xml#BitmapDataChannel/GREEN"><linktext>flash.display.BitmapDataChannel.GREEN</linktext></link><link href="flash.display.xml#BitmapDataChannel/ALPHA"><linktext>flash.display.BitmapDataChannel.ALPHA</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:paletteMap"><apiName>paletteMap</apiName><shortdesc>
	 Remaps the color channel values in an image that has up to four arrays of color palette data, one 
	 for each channel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceBitmapData, sourceRect or destPoint are null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The input bitmap image to use. The source image can be a different 
	                     BitmapData object, or it can refer to the current BitmapData instance.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle that defines the area of the source image to use as input.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point within the destination image (the current BitmapData 
	                   object) that corresponds to the upper-left corner of the source rectangle.
	 </apiDesc></apiParam><apiParam><apiItemName>redArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>If <codeph>redArray</codeph> is not <codeph>null</codeph>, <codeph>red = redArray[source red value]
	                  else red = source rect value</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>greenArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>If <codeph>greenArray</codeph> is not <codeph>null</codeph>, <codeph>green = greenArray[source 
	                    green value] else green = source green value.</codeph>
	 </apiDesc></apiParam><apiParam><apiItemName>blueArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>If <codeph>blueArray</codeph> is not <codeph>null</codeph>, <codeph>blue = blueArray[source blue 
	                   value] else blue = source blue value</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>If <codeph>alphaArray</codeph> is not <codeph>null</codeph>, <codeph>alpha = alphaArray[source 
	                    alpha value] else alpha = source alpha value</codeph>.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Remaps the color channel values in an image that has up to four arrays of color palette data, one 
	 for each channel. 
	 
	 <p><ph platform="actionscript">Flash Player or</ph> AIR uses the following steps to 
	 generate the resulting image:</p>
	 
	 <ol>
	 
	 <li>After the red, green, blue, and alpha 
	 values are computed, they are added together using standard 32-bit-integer arithmetic. </li>
	 
	 <li>The red, green, blue, and alpha channel values of each pixel are extracted into separate 0 to 255 values. 
	 These values are used to look up new color values in the appropriate array: <codeph>redArray</codeph>, 
	 <codeph>greenArray</codeph>, <codeph>blueArray</codeph>, and <codeph>alphaArray</codeph>.
	 Each of these four arrays should contain 256 values. </li>
	 
	 <li>After all four of the new channel values are retrieved, they are combined into a standard 
	 ARGB value that is applied to the pixel.</li>
	 
	 </ol>
	 
	 <p>Cross-channel effects can be supported with this method. 
	 Each input array can contain full 32-bit values, and no shifting occurs when the 
	 values are added together. This routine does not support per-channel 
	 clamping. </p>
	 
	 <p>If no array is specified for a channel,
	 the color channel is copied from the source image to the
	 destination image.</p>
	 
	 <p>You can use this method for a variety of effects such as 
	 general palette mapping (taking one channel and converting it
	 to a false color image). You can also use this method for a variety of advanced color 
	 manipulation algorithms, such as gamma, curves, levels, and quantizing.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.paletteMap.1.as"> The following example creates a green BitmapData object with a red center square, and then
 uses the <codeph>paletteMap()</codeph> method to swap red with green in the bottom rectangular half of the 
 BitmapData object:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:perlinNoise"><apiName>perlinNoise</apiName><shortdesc>
	 Generates a Perlin noise image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>baseX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Frequency to use in the <i>x</i> direction. For example, to generate a noise that 
	 is sized for a 64 x 128 image, pass 64 for the <codeph>baseX</codeph> value. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>baseY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Frequency to use in the <i>y</i> direction. For example, to generate a noise that 
	 is sized for a 64 x 128 image, pass 128 for the <codeph>baseY</codeph> value. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numOctaves</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Number of octaves or individual noise functions to combine to create this noise. Larger numbers of octaves create 
	 images with greater detail. Larger numbers of octaves also require more processing time.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The random seed number to use. If you keep all other parameters the same, you can generate different
	 pseudo-random results by varying the random seed value. The Perlin noise function is a mapping function, not a 
	 true random-number generation function, so it creates the same results each time from the same random seed.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>stitch</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>A Boolean value. If the value is <codeph>true</codeph>, the method attempts to smooth the transition edges of the image to create seamless textures for 
	 tiling as a bitmap fill.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fractalNoise</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>A Boolean value. If the value is <codeph>true</codeph>, the method generates fractal noise; otherwise,
	 it generates turbulence. An image with turbulence has visible discontinuities in the gradient
	 that can make it better approximate sharper visual effects like flames and ocean waves.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc> A number that can be a combination of any of
	 the four color channel values (<codeph>BitmapDataChannel.RED</codeph>, 
	 <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, and 
	 <codeph>BitmapDataChannel.ALPHA</codeph>). You can use the logical OR 
	 operator (<codeph>|</codeph>) to combine channel values.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>A Boolean value. If the value is <codeph>true</codeph>, a grayscale image is created by setting
	 each of the red, green, and blue color channels to 
	 identical values. The alpha channel value is not affected if this value is 
	 set to <codeph>true</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>offsets</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>An array of points that correspond to <i>x</i> and <i>y</i> offsets for each octave. 
	 By manipulating the offset values you can smoothly scroll the layers of a perlinNoise image. 
	 Each point in the offset array affects a specific octave noise function.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Generates a Perlin noise image.
	 
	 <p>The Perlin noise generation algorithm interpolates and combines individual random noise functions (called octaves)
	 into a single function that generates more natural-seeming random noise. Like musical octaves, each octave function is twice the 
	 frequency of the one before it. Perlin noise has been described as a "fractal sum of noise" because it combines multiple sets of noise data
	 with different levels of detail.</p>
	 
	 <p>You can use Perlin noise functions to simulate natural 
	 phenomena and landscapes, such as wood grain, clouds, and mountain ranges. In most cases, the output of a Perlin noise function 
	 is not displayed directly but is used to enhance other images and give them pseudo-random variations.</p>
	 
	 <p>Simple digital random noise functions often produce images with harsh, contrasting points. This kind of harsh contrast 
	 is not often found in nature. The Perlin noise algorithm blends multiple noise functions that operate at different levels of detail. 
 	 This algorithm results in smaller variations among neighboring pixel values.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.perlinNoise.1.as"> The following example creates a 200 x 200 pixel BitmapData object that calls the 
 <codeph>perlinNoise()</codeph> method to generate a red and blue watercolor effect:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:pixelDissolve"><apiName>pixelDissolve</apiName><shortdesc>
	 Performs a pixel dissolve either from a source image to a destination image or by using the same image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceBitmapData, sourceRect or destPoint are null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>The numPixels value is negative
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>The new random seed value to use for subsequent calls.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The input bitmap image to use. The source image can be a different 
	 BitmapData object, or it can refer to the current BitmapData instance.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle that defines the area of the source image to use as input.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point within the destination image (the current BitmapData 
	 instance) that corresponds to the upper-left corner of the source rectangle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>The random seed to use to start the pixel dissolve. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numPixels</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>The default is 1/30 of the source area (width x height).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>An ARGB color value that you use to fill pixels whose
	 source value equals its destination value. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Performs a pixel dissolve either from a source image to a destination image or by using the same image. 
	 <ph platform="actionscript">Flash Player or</ph> AIR uses a <codeph>randomSeed</codeph> value
	 to generate a random pixel dissolve. The return value
	 of the function must be passed in on subsequent calls to
	 continue the pixel dissolve until it is finished.
	 
	 <p>If the source image does not equal the destination image,
	 pixels are copied from the source to the destination by using all of the
	 properties. This process allows dissolving from a blank image into a
	 fully populated image.</p>
	 
	 <p>If the source and destination images are equal, pixels are
	 filled with the <codeph>color</codeph> parameter. This process allows dissolving away
	 from a fully populated image. In this mode, the destination
	 <codeph>point</codeph> parameter is ignored.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.pixelDissolve.1.as"> The following example uses the <codeph>pixelDissolve()</codeph> 
 method to convert a grey BitmapData object to a red one by dissolving 
 40 pixels at a time until all pixels have changed colors:
<codeblock>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 &amp;&amp; grayRegion.height == 0 ) {
        tim.stop();
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:scroll"><apiName>scroll</apiName><shortdesc>
	 Scrolls an image by a certain (x, y) pixel amount.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The amount by which to scroll horizontally.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The amount by which to scroll vertically.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Scrolls an image by a certain (<i>x</i>, <i>y</i>) pixel amount. Edge
	 regions outside the scrolling area are left unchanged.
	 
	 </apiDesc><example conref="examples\BitmapData.scroll.1.as"> The following example shows the effect of scrolling a Bitmap data object 40 pixels to the right:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:setPixel"><apiName>setPixel</apiName><shortdesc>
	 Sets a single pixel of a BitmapData object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>x</i> position of the pixel whose value changes.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>y</i> position of the pixel whose value changes.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The resulting RGB color for the pixel. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sets a single pixel of a BitmapData object. The current
	 alpha channel value of the image pixel is preserved during this
	 operation. The value of the RGB color parameter is treated as an unmultiplied color value.
	 
	 <p><b>Note:</b> To increase performance, when you use the <codeph>setPixel()</codeph> or 
	 <codeph>setPixel32()</codeph> method repeatedly, call the <codeph>lock()</codeph> method before
	 you call the <codeph>setPixel()</codeph> or <codeph>setPixel32()</codeph> method, and then call 
	 the <codeph>unlock()</codeph> method when you have made all pixel changes. This process prevents objects
	 that reference this BitmapData instance from updating until you finish making 
	 the pixel changes.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel.1.as"> The following example uses the <codeph>setPixel()</codeph>
 method to draw a red line in a BitmapData object:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixel32"><apiName>setPixel32</apiName><shortdesc>
	 Sets the color and alpha transparency values of a single pixel of a BitmapData 
	 object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>x</i> position of the pixel whose value changes.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The <i>y</i> position of the pixel whose value changes.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The resulting ARGB color for the pixel. If the bitmap is opaque 
	 (not transparent), the alpha transparency portion of this color value is ignored.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sets the color and alpha transparency values of a single pixel of a BitmapData 
	 object. This method is similar to the <codeph>setPixel()</codeph> method; the main difference is 
	 that the <codeph>setPixel32()</codeph> method takes an
	 ARGB color value that contains alpha channel information.
	 
	 <p>All pixels in a BitmapData object are stored as premultiplied color values. 
	 A premultiplied image pixel has the red, green, and blue 
	 color channel values already multiplied by the alpha data. For example, if the 
	 alpha value is 0, the values for the RGB channels are also 0, independent of their unmultiplied 
	 values. This loss of data can cause some problems when you perform operations. All BitmapData 
	 methods take and return unmultiplied values. The internal pixel representation is converted 
	 from premultiplied to unmultiplied before it is returned as a value. During a set operation, 
	 the pixel value is premultiplied before the raw image pixel is set.</p>
	 
	 <p><b>Note:</b> To increase performance, when you use the <codeph>setPixel()</codeph> or 
	 <codeph>setPixel32()</codeph> method repeatedly, call the <codeph>lock()</codeph> method before
	 you call the <codeph>setPixel()</codeph> or <codeph>setPixel32()</codeph> method, and then call 
	 the <codeph>unlock()</codeph> method when you have made all pixel changes. This process prevents objects
	 that reference this BitmapData instance from updating until you finish making 
	 the pixel changes.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel32.1.as"> The following example uses the <codeph>setPixel32()</codeph>
 method to draw a transparent (alpha == 0x60) red line in a BitmapData object:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixels"><apiName>setPixels</apiName><shortdesc>
	 Converts a byte array into a rectangular region of pixel data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The <codeph>inputByteArray</codeph> object does not include enough data
	 to fill the area of the <codeph>rect</codeph> rectangle. The method fills as many pixels as 
	 possible before throwing the exception.
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>The rect or inputByteArray are null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Specifies the rectangular region of the BitmapData object.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputByteArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>A ByteArray object that consists of 32-bit unmultiplied pixel values
	 to be used in the rectangular region.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Converts a byte array into a rectangular region of pixel data. For each
	 pixel, the <codeph>ByteArray.readUnsignedInt()</codeph> method is called and the return value is 
	 written into the pixel.  If the byte array ends before the full rectangle
	 is written, the function returns.  The data in the byte array is
	 expected to be 32-bit ARGB pixel values. No seeking is performed
	 on the byte array before or after the pixels are read.  
	 
	 </apiDesc><example conref="examples\BitmapData.setPixels.1.as"> The following example uses the <codeph>getPixels()</codeph> and 
 <codeph>setPixels()</codeph> methods to copy pixels from one BitmapData object to another:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/readUnsignedInt()"><linktext>flash.utils.ByteArray.readUnsignedInt()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setVector"><apiName>setVector</apiName><shortdesc>
	 Converts a Vector into a rectangular region of pixel data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The vector array is not large enough to read all the pixel data.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Specifies the rectangular region of the BitmapData object.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputVector</apiItemName><apiType value="Vector$uint"/><apiDesc>A Vector object that consists of 32-bit unmultiplied pixel values to be used
	 in the rectangular region.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Converts a Vector into a rectangular region of pixel data. For each pixel, a Vector element is read 
	 and written into the BitmapData pixel. The data in the Vector is expected to be 32-bit ARGB pixel values. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:threshold"><apiName>threshold</apiName><shortdesc>
	 Tests pixel values in an image against a specified threshold and sets pixels that pass the test to new color values.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The sourceBitmapData, sourceRect destPoint or operation are null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>The operation string is not a valid operation 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>The number of pixels that were changed.
 	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>The input bitmap image to use. The source image can be a different 
	 BitmapData object or it can refer to the current BitmapData instance.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A rectangle that defines the area of the source image to use as input.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point within the destination image (the current BitmapData 
	 instance) that corresponds to the upper-left corner of the source rectangle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>One of the following comparison operators, passed as a String: "&lt;", "&lt;=", "&gt;", "&gt;=", "==", "!="
	 
	 </apiDesc></apiParam><apiParam><apiItemName>threshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>The value that each pixel is tested against to see if it meets or exceeds the threshhold.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>The color value that a pixel is set to if the threshold test succeeds. The default value is 0x00000000.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>The mask to use to isolate a color component. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>copySource</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>If the value is <codeph>true</codeph>, pixel values from the source image are copied to the destination  
	 when the threshold test fails. If the value is <codeph>false</codeph>, the source image is not copied when the 
	 threshold test fails. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Tests pixel values in an image against a specified threshold and sets pixels that pass the test to new color values.
	 Using the <codeph>threshold()</codeph> method, you can isolate and replace color ranges in an image and perform other 
	 logical operations on image pixels. 
	 
	 <p>The <codeph>threshold()</codeph> method's test logic is as follows:</p> 
	 
	 <ol> 
	 
	 	<li>If <codeph>((pixelValue &amp; mask) operation (threshold &amp; mask))</codeph>, then
	 	set the pixel to <codeph>color</codeph>;</li>
	 
	 	<li>Otherwise, if <codeph>copySource == true</codeph>, then
	 	set the pixel to corresponding pixel value from <codeph>sourceBitmap</codeph>.</li>
	 </ol>
	 
	 <p>The <codeph>operation</codeph> parameter specifies the comparison operator to use for the threshold test.
	 For example, by using "==" as the <codeph>operation</codeph> parameter, you
	 can isolate a specific color value in an image. Or by using <codeph>{operation:
	 "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color:
	 0x00000000}</codeph>, you can set all destination pixels to be fully transparent
	 when the source image pixel's alpha is less than 0x7F. You can use this technique
	 for animated transitions and other effects.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.threshold.1.as"> The following example uses the <codeph>perlinNoise()</codeph> method to 
 add a blue and red pattern to one BitmapData object, and then uses the <codeph>threshold()</codeph>
 method to copy those pixels from the first BitmapData object to a second one, replacing those pixels 
 in which the red value is greater than 0x80 (50%) with a pixel set to transparent red (0x20FF0000):
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, "&gt;", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:unlock"><apiName>unlock</apiName><shortdesc>
	 Unlocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, 
	 are updated when this BitmapData object changes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>changeRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>The area of the BitmapData object that has changed. If you do not specify a value for 
	 this parameter, the entire area of the BitmapData object is considered
     changed. This parameter requires Flash Player version 9.0.115.0 or later.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Unlocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, 
	 are updated when this BitmapData object changes. To improve performance, use this method  
	 along with the <codeph>lock()</codeph> method before and after numerous calls to the 
	 <codeph>setPixel()</codeph> or <codeph>setPixel32()</codeph> method.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> The following example creates a BitmapData object based on the
 <codeph>bitmapData</codeph> property of a Bitmap object, <codeph>picture</codeph>.
 It then calls the <codeph>lock()</codeph> method before calling a complicated custom function, 
 <codeph>complexTransformation()</codeph>, that modifies the BitmapData object. (The <codeph>picture</codeph> object
 and the <codeph>complexTransformation()</codeph> function are not defined in this example.) Even if the
 <codeph>complexTransformation()</codeph> function updates the <codeph>bitmapData</codeph> property of 
 the <codeph>picture</codeph> object, changes are not reflected until the code calls the 
 <codeph>unlock()</codeph> method on the <codeph>bitmapData</codeph> object:
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiValue id="flash.display:BitmapData:height:get"><apiName>height</apiName><shortdesc>
	 The height of the bitmap image in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The height of the bitmap image in pixels.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:rect:get"><apiName>rect</apiName><shortdesc>
	 The rectangle that defines the size and location of the bitmap image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
	 The rectangle that defines the size and location of the bitmap image. The top and left of the 
	 rectangle are 0; the width and height are equal to the width and height in pixels of the 
 	 BitmapData object.
   	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Defines whether the bitmap image supports per-pixel transparency.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Defines whether the bitmap image supports per-pixel transparency. You can set this value only when you construct 
	 a BitmapData object by passing in <codeph>true</codeph> for the <codeph>transparent</codeph> parameter of the constructor. Then, after you create
	 a BitmapData object, you can check whether it supports per-pixel transparency by determining if the value of the 
	 <codeph>transparent</codeph> property is <codeph>true</codeph>.
   	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:width:get"><apiName>width</apiName><shortdesc>
	 The width of the bitmap image in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The width of the bitmap image in pixels.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:JointStyle"><apiName>JointStyle</apiName><shortdesc>
The JointStyle class is an enumeration of constant values that specify the joint style to use in drawing lines.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The JointStyle class is an enumeration of constant values that specify the joint style to use in drawing lines.
These constants are provided for use as values in the <codeph>joints</codeph> parameter of the
<codeph>flash.display.Graphics.lineStyle()</codeph> method. The method supports three types of joints: 
miter, round, and bevel, as the following example shows: 

<p><adobeimage alt="MITER, ROUND, and BEVEL" href="../../images/linejoin.jpg"/></p> 

 
</apiDesc><example conref="examples\JointStyleExample.as"> The following example uses the JointStyleExample class to show the result
 of three different joint styles applied to three sets of joined lines. This task is accomplished by performing
 the following steps:
 <ol>
  <li>The properties of each line are set as follows:
  <ul>
      <li>The line length is set to 80 pixels.</li>
      <li>The border color is set to orange.</li>
      <li>The border size is set to 30 pixels.</li>
      <li>The highlight color is set to gray.</li>
      <li>The highlight size is set to zero pixels.</li>
      <li>The alpha is set to 1, making it solid.</li>
      <li>The pixel hinting is set to false (strokes not hinted to full pixels).</li>
      <li>The line scale mode is set to normal, which scales the thickness.</li>
      <li>The border caps and miter limit are declared but not set, so the default values are used.</li>
  </ul></li>
  <li>The class constructor creates three sets of two connected line segments. The segments start at x = 0, y = 0
  by calling the <codeph>doDrawCorner()</codeph> method three times using the three joint styles (miter,
  round, and bevel).  Each of the three calls to <codeph>doDrawCorner()</codeph> uses the joint style and
  properties previously listed to draw two connected line segments and associated line highlights. This is done by
  first creating a new Shape object <codeph>child</codeph> and then using methods of the Graphics
  class to set the line style and draw the lines and highlights.  Each instance of <codeph>child</codeph>
  is added to the display list and promptly drawn on the stage.</li>
  <li>The connected line segments are then redrawn by using the <codeph>refreshLayout()</codeph> method 
  at y = 80 pixels and starting at x = 80 pixels, with a 25-pixel separation between the line segments.</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class JointStyleExample extends Sprite {
        private var size:uint                  = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderCaps:String;
        private var borderMiterLimit:uint;

        public function JointStyleExample() {
            doDrawCorner(JointStyle.MITER);
            doDrawCorner(JointStyle.ROUND);
            doDrawCorner(JointStyle.BEVEL);
            refreshLayout();
        }

        private function doDrawCorner(jointStyle:String):void {
            var halfSize:uint = Math.round(size / 2);
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     borderCaps,
                                     jointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = size;
            lastChild.y = size;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = size;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:JointStyle:BEVEL"><apiName>BEVEL</apiName><shortdesc>
	
	Specifies beveled joints in the joints parameter of the
	flash.display.Graphics.lineStyle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bevel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Specifies beveled joints in the <codeph>joints</codeph> parameter of the
	<codeph>flash.display.Graphics.lineStyle()</codeph> method.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:MITER"><apiName>MITER</apiName><shortdesc>
	
	Specifies mitered joints in the joints parameter of the
	flash.display.Graphics.lineStyle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>miter</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Specifies mitered joints in the <codeph>joints</codeph> parameter of the
	<codeph>flash.display.Graphics.lineStyle()</codeph> method.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	
	Specifies round joints in the joints parameter of the
	flash.display.Graphics.lineStyle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Specifies round joints in the <codeph>joints</codeph> parameter of the
	<codeph>flash.display.Graphics.lineStyle()</codeph> method.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:AVM1Movie"><apiName>AVM1Movie</apiName><shortdesc>
	AVM1Movie is a simple class that represents AVM1 movie clips, which use ActionScript 1.0 or 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
	AVM1Movie is a simple class that represents AVM1 movie clips, which use ActionScript 1.0 or 2.0.  
	(AVM1 is the ActionScript virtual machine used to run ActionScript 1.0 and 2.0. 
	AVM2 is the ActionScript virtual machine used to run ActionScript 3.0.)
	When a Flash Player 8, or older, SWF file is loaded by a Loader object, an AVM1Movie 
	object is created. The AVM1Movie object can use methods and properties inherited from the 
	DisplayObject class (such as <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, and so on). 
	However, no interoperability (such as calling methods or using parameters) between the AVM1Movie object 
	and AVM2 objects is allowed.
	
	<p>There are several restrictions on an AVM1 SWF file loaded by an AVM2 SWF file:</p>
	
	<ul>
	
	<li>The loaded AVM1Movie object operates as a psuedo-root object for the AVM1 SWF file and all AVM1 SWF files 
	loaded by it (as if the ActionScript 1.0 <codeph>lockroot</codeph> property were set to <codeph>true</codeph>).  
	  The AVM1 movie is always the top of any ActionScript 1.0 or 2.0 code execution in any children.
	The <codeph>_root</codeph> property for loaded children is always this AVM1 SWF file, unless the 
	  <codeph>lockroot</codeph> property is set in a loaded AVM1 SWF file.</li>
	
	<li>The AVM1 content cannot load files into levels. For example, it cannot load files by calling
	<codeph>loadMovieNum("url", levelNum)</codeph>.</li>
	
	<li>The AVM1 SWF file that is loaded by an AVM2 SWF file cannot load another SWF file into <codeph>this</codeph>.  
	That is, it cannot load another SWF file over itself.  However, child Sprite objects, MovieClip objects, or other AVM1 
	  SWF files loaded by this SWF file can load into <codeph>this</codeph>.</li>
	
	</ul>
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>DisplayObject</linktext></link><link href="flash.display.xml#Loader"><linktext>Loader</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
	 A ShaderInput instance represents a single input image for
	 a shader kernel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A ShaderInput instance represents a single input image for
	 a shader kernel. A kernel can be defined to accept zero, one, or more 
	 source images that are used in the kernel execution. A ShaderInput 
	 instance provides a mechanism for specifying the input image 
	 that is used when the shader executes. To specify a value for the input,
	 create a BitmapData, ByteArray, or Vector.&lt;Number&gt; instance containing the image data 
	 and assign it to the <codeph>input</codeph> property.
	 
	 <p>The ShaderInput instance representing a Shader instance's input image 
	 is accessed as a property of the Shader instance's 
	 <codeph>data</codeph> property. The ShaderInput property has the same name 
	 as the input's name in the shader code. 
	 For example, if a shader defines an input named <codeph>src</codeph>, 
	 the ShaderInput instance representing the <codeph>src</codeph> input 
	 is available as the <codeph>src</codeph> property, as this example shows:</p>
	 
	 <codeblock>myShader.data.src.image = new BitmapData(50, 50, true, 0xFF990000);</codeblock>
	 
	 <p>For some uses of a Shader instance, you do not 
	 need to specify an input image, because it is automatically specified by the 
	 operation. You only need to specify an input when a Shader is used for the following:</p>
	 
	 <ul>
	   <li>Shader fill</li>
	   <li>ShaderFilter, only for the second or additional inputs 
	       if the shader is defined to use more than one input. (The object to which the 
	       filter is applied is automatically used as the first input.)</li>
	   <li>Shader blend mode, only for the third or additional inputs if the shader is 
	       defined to use more than two inputs. (The objects being blended 
	       are automatically used as the first and second inputs.)</li>
	   <li>ShaderJob background execution</li>
	 </ul>
	 
	 <p>If the shader is being executed using a ShaderJob instance to process a 
	 ByteArray containing a linear array of data, set the ShaderInput instance's 
	 <codeph>height</codeph> to 1 and <codeph>width</codeph> to the number of 32-bit floating 
	 point values in the ByteArray. In that case, the input in the shader must be defined with 
	 the <codeph>image1</codeph> data type.</p>
	 
	 <p>Generally, developer code does not create a ShaderInput instance 
	 directly. A ShaderInput instance is created for each of a shader's inputs 
	 when the Shader instance is created.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link></related-links><apiConstructor id="flash.display:ShaderInput:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
		 Creates a ShaderInput instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Creates a ShaderInput instance. Developer code does 
		 not call the ShaderInput constructor 
		 directly. A ShaderInput instance is created for each of a shader's inputs 
		 when the Shader instance is created.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderInput:channels:get"><apiName>channels</apiName><shortdesc>
         The number of channels that a shader input expects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         The number of channels that a shader input expects. This property must be 
		 accounted for when the input data is a ByteArray or 
		 Vector.&lt;Number&gt; instance.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:height:get"><apiName>height</apiName><shortdesc>
		 The height of the shader input.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 The height of the shader input. This property is only used when the input data 
		 is a ByteArray or Vector.&lt;Number&gt; instance. When the input is a BitmapData 
		 instance the height is automatically determined.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:index:get"><apiName>index</apiName><shortdesc>
         The zero-based index of the input in the shader, indicating the order 
		 of the input definitions in the shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         The zero-based index of the input in the shader, indicating the order 
		 of the input definitions in the shader.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:input:get"><apiName>input</apiName><shortdesc>
		 
		 The input data that is used when the shader executes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 
		 The input data that is used when the shader executes. This property can be  
		 a BitmapData instance, a ByteArray instance, or a Vector.&lt;Number&gt; instance.
		 
		 <p>If a ByteArray value is assigned to the <codeph>input</codeph> property, the following 
		 conditions must be met:</p>
		 
		 <ul>
		   <li>The <codeph>height</codeph> and <codeph>width</codeph> properties must be set.</li>
		   <li>The byte array's contents must only consist of 32-bit floating-point values. 
		       These values can be written using the <codeph>ByteArray.writeFloat()</codeph> method.</li>
		   <li>The total length in bytes of the ByteArray must be exactly <codeph>width</codeph> times 
		       <codeph>height</codeph> times <codeph>channels</codeph> times 4.</li>
		   <li>The byte array's <codeph>endian</codeph> property must be <codeph>Endian.LITTLE_ENDIAN</codeph>.</li>
		 </ul>
		 
		 <p>If a Vector.&lt;Number&gt; instance is assigned to the <codeph>input</codeph> property, the
		 length of the Vector must be equal to <codeph>width</codeph> times <codeph>height</codeph> times 
		 <codeph>channels</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:width:get"><apiName>width</apiName><shortdesc>
		 The width of the shader input.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 The width of the shader input. This property is only used when the input data 
		 is a ByteArray or Vector.&lt;Number&gt; instance. When the input is a BitmapData 
		 instance the width is automatically determined.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrection"><apiName>ColorCorrection</apiName><shortdesc>
The ColorCorrection class provides values for the flash.display.Stage.colorCorrection property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The ColorCorrection class provides values for the <codeph>flash.display.Stage.colorCorrection</codeph> property. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrection"><linktext>flash.display.Stage.colorCorrection</linktext></link></related-links><apiValue id="flash.display:ColorCorrection:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
Uses the host's default color correction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Uses the host's default color correction. For the web player the host is usually a browser, and Flash Player
tries to use the same color correction as the web page hosting the SWF file. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:OFF"><apiName>OFF</apiName><shortdesc>
Turns off color correction regardless of the player host environment.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>off</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Turns off color correction regardless of the player host environment.
This setting provides faster performance. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:ON"><apiName>ON</apiName><shortdesc>
Turns on color correction regardless of the player host environment, if available.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>on</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Turns on color correction regardless of the player host environment, if available. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:LineScaleMode"><apiName>LineScaleMode</apiName><shortdesc>
The LineScaleMode class provides values for the scaleMode 
parameter in the Graphics.lineStyle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The LineScaleMode class provides values for the <codeph>scaleMode</codeph> 
parameter in the <codeph>Graphics.lineStyle()</codeph> method.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:LineScaleMode:HORIZONTAL"><apiName>HORIZONTAL</apiName><shortdesc>
	With this setting used as the scaleMode parameter of the lineStyle()
	method, the thickness of the line scales only vertically.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>horizontal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	With this setting used as the <codeph>scaleMode</codeph> parameter of the <codeph>lineStyle()</codeph>
	method, the thickness of the line scales <i>only</i> vertically. For example, 
	consider the following circles, drawn with a one-pixel line, and each with the 
	<codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.VERTICAL</codeph>. The circle on the left 
	is scaled only vertically, and the circle on the right is scaled both vertically and horizontally.
	
    <p><adobeimage alt="A circle scaled vertically, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NONE"><apiName>NONE</apiName><shortdesc>
	With this setting used as the scaleMode parameter of the lineStyle()
	method, the thickness of the line never scales.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	With this setting used as the <codeph>scaleMode</codeph> parameter of the <codeph>lineStyle()</codeph>
	method, the thickness of the line never scales.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	With this setting used as the scaleMode parameter of the lineStyle()
	method, the thickness of the line always scales when the object is scaled (the default).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	With this setting used as the <codeph>scaleMode</codeph> parameter of the <codeph>lineStyle()</codeph>
	method, the thickness of the line always scales when the object is scaled (the default).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:VERTICAL"><apiName>VERTICAL</apiName><shortdesc>
	With this setting used as the scaleMode parameter of the lineStyle()
	method, the thickness of the line scales only horizontally.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>vertical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	With this setting used as the <codeph>scaleMode</codeph> parameter of the <codeph>lineStyle()</codeph>
	method, the thickness of the line scales <i>only</i> horizontally. For example, 
	consider the following circles, drawn with a one-pixel line, and each with the 
	<codeph>scaleMode</codeph> parameter set to <codeph>LineScaleMode.HORIZONTAL</codeph>. The circle on the left 
	is scaled only horizontally, and the circle on the right is scaled both vertically and horizontally.
	
    <p><adobeimage alt="A circle scaled horizontally, and a circle scaled both vertically and horizontally." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Shader"><apiName>Shader</apiName><shortdesc>
	 A Shader instance represents a Pixel Bender shader kernel in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Shader instance represents a Pixel Bender shader kernel in ActionScript. To use 
	 a shader in your application, you create a Shader instance for it. You 
	 then use that Shader instance in the appropriate way according to the effect 
	 you want to create. For example, to use the shader as a filter, you 
	 assign the Shader instance to the <codeph>shader</codeph> property of a 
	 ShaderFilter object.
	 
	 <p>A shader defines a function that executes on all the pixels in an image, 
	 one pixel at a time. The result of each call to the function is the output 
	 color at that pixel coordinate in the image. A shader can specify one or more 
	 input images, which are images whose content can be used in determining the 
	 output of the function. A shader can also specify one or more parameters, 
	 which are input values that can be used in calculating the function output. In 
	 a single shader execution, the input and parameter values are constant. The only 
	 thing that varies is the coordinate of the pixel whose color is the function result. 
	 Shader function calls for multiple output 
	 pixel coordinates execute in parallel to improve shader execution performance.</p>
	 
	 <p>The shader bytecode can be loaded at run time using a URLLoader instance. 
	 The following example demonstrates loading a shader bytecode file at run time 
	 and linking it to a Shader instance.</p>
	 
	 <codeblock>
	 var loader:URLLoader = new URLLoader();
	 loader.dataFormat = URLLoaderDataFormat.BINARY;
	 loader.addEventListener(Event.COMPLETE, onLoadComplete);
	 loader.load(new URLRequest("myShader.pbj"));
	  
	 var shader:Shader;
	  
	 function onLoadComplete(event:Event):void {
	     // Create a new shader and set the loaded data as its bytecode
	     shader = new Shader();
	     shader.byteCode = loader.data;
	     
	     // You can also pass the bytecode to the Shader() constructor like this:
	     // shader = new Shader(loader.data);
	     
	     // do something with the shader
	 }
	 </codeblock>
	 
	 <p>You can also embed the shader into the SWF at compile time using the 
	 <codeph>[Embed]</codeph> metadata tag. The <codeph>[Embed]</codeph> metadata tag 
	 is only available if you use the Flex SDK to compile the SWF. The 
	 <codeph>[Embed]</codeph> tag's <codeph>source</codeph> parameter points to  
	 the shader file, and its <codeph>mimeType</codeph> parameter is  
	 <codeph>"application/octet-stream"</codeph>, as in this example:</p>
	 
	 <codeblock>
	 [Embed(source="myShader.pbj", mimeType="application/octet-stream)]
	 var MyShaderClass:Class;
	  
	 // ...
	 
	 // create a new shader and set the embedded shader as its bytecode
	 var shaderShader = new Shader();
	 shader.byteCode = new MyShaderClass();
	  
	 // You can also pass the bytecode to the Shader() constructor like this:
	 // var shader:Shader = new Shader(new MyShaderClass());
	  
	 // do something with the shader
	 </codeblock>
	 
	 <p>In either case, you link the raw shader (the <codeph>URLLoader.data</codeph> property 
	 or an instance of the <codeph>[Embed]</codeph> data class) to the Shader instance. As 
	 the previous examples demonstrate, you can do this in two ways. You can  
	 pass the shader bytecode as an argument 
	 to the <codeph>Shader()</codeph> constructor. Alternatively, you can set it as the Shader 
	 instance's <codeph>byteCode</codeph> property.</p>
	 
	 <p>Once a Shader instance is created, it can be used in one of several 
	 ways:</p>
	 
	 <ul>
	   <li>A shader fill: The output of the shader is used as a fill for 
	       content drawn with the drawing API. Pass the Shader instance as 
	       an argument to the <codeph>Graphics.beginShaderFill()</codeph> method.</li>
	   <li>A shader filter: The output of the shader is used as a graphic filter
	       applied to a display object. Assign the Shader instance to the 
	       <codeph>shader</codeph> property of a ShaderFilter instance.</li>
	   <li>A blend mode: The output of the shader is rendered as the blending 
	       between two overlapping display objects. Assign the Shader instance 
	       to the <codeph>blendShader</codeph> property of the upper of the 
	       two display objects.</li>
	   <li>Background shader processing: The shader executes in the background, 
	       avoiding the possibility of freezing the display, and dispatches an 
	       event when processing is complete. Assign the Shader instance to 
	       the <codeph>shader</codeph> property of a ShaderJob instance.</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\ShaderExample.1.as"> The following example loads a shader bytecode file at run time and creates 
 a Shader instance linked to it.
 
 <p>Note that this example assumes there's a shader bytecode file named "donothing.pbj" in the same 
 directory as the output directory for the application. The Pixel Bender source code for the DoNothing shader
 is available in the <xref href="ShaderData.html#includeExamplesSummary">ShaderData class example</xref>.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class LoadedShaderExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function LoadedShaderExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example><example conref="examples\ShaderExample.2.as"> The following example embeds a shader bytecode file by compiling it 
 into the SWF, and creates a Shader instance linked to it.
 
 <p>Note that this example assumes there's a shader bytecode file named "donothing.pbj" in the same 
 directory as the source code for the application, and that the Flex SDK is used to compile the SWF.
 The Pixel Bender source code for the DoNothing shader
 is available in the <xref href="ShaderData.html#includeExamplesSummary">ShaderData class example</xref>.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;

    public class EmbeddedShaderExample extends Sprite {
        
        [Embed(source="donothing.pbj", mimeType="application/octet-stream")]
        private static var DoNothingShader:Class;
        
        public function EmbeddedShaderExample() {
            var shader:Shader = new Shader();
            shader.byteCode = new DoNothingShader();
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link><link href="flash.filters.xml#ShaderFilter"><linktext>flash.filters.ShaderFilter</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><apiConstructor id="flash.display:Shader:flash.display:Shader"><apiName>Shader</apiName><shortdesc>
		 Creates a new Shader instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>The raw shader bytecode to link to the Shader.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Creates a new Shader instance.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shader:data:set"><apiName>data</apiName><shortdesc>
		 Provides access to parameters, input images, and metadata for the Shader instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:ShaderData</apiValueClassifier></apiValueDef><apiDesc>
		 Provides access to parameters, input images, and metadata for the Shader instance.
		 ShaderParameter objects representing parameters for the shader, ShaderInput objects 
		 representing the input images for the shader, and other values representing the 
		 shader's metadata are dynamically added as properties of the <codeph>data</codeph> 
		 property object when the Shader instance is created. Those properties can be 
		 used to introspect the shader and to set parameter and input values.
		 
		 <p>For information about accessing and manipulating the dynamic properties of 
		 the <codeph>data</codeph> object, see the ShaderData class description.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:precisionHint:set"><apiName>precisionHint</apiName><shortdesc>
		 The precision of math operations performed by the shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 The precision of math operations performed by the shader.
		 
		 <p>The set of possible values for the <codeph>precisionHint</codeph> property is defined 
		 by the constants in the ShaderPrecision class.</p>
		 
		 <p>The default value is <codeph>ShaderPrecision.FULL</codeph>. Setting the precision
		 to <codeph>ShaderPrecision.FAST</codeph> can speed up math operations at the expense 
		 of precision.</p>
		 
		 <p>Full precision mode (<codeph>ShaderPrecision.FULL</codeph>) computes all math 
		 operations to the full width of the IEEE 32-bit floating standard and provides 
		 consistent behavior on all platforms. In this mode, some math operations such 
		 as trigonometric and exponential functions can be slow.</p>
		 
		 <p>Fast precision mode (<codeph>ShaderPrecision.FAST</codeph>) is designed for 
		 maximum performance but does not work consistently on different platforms 
		 and individual CPU configurations. In many cases, this level of precision
		 is sufficient to create graphic effects without visible artifacts.</p>
		 
		 <p>The precision mode selection affects the following shader operations. 
		 These operations are faster on an Intel processor 
		 with the SSE instruction set:</p>
		 
		 <ul>
		   <li><codeph>sin(x)</codeph></li>
		   <li><codeph>cos(x)</codeph></li>
		   <li><codeph>tan(x)</codeph></li>
		   <li><codeph>asin(x)</codeph></li>
		   <li><codeph>acos(x)</codeph></li>
		   <li><codeph>atan(x)</codeph></li>
		   <li><codeph>atan(x, y)</codeph></li>
		   <li><codeph>exp(x)</codeph></li>
		   <li><codeph>exp2(x)</codeph></li>
		   <li><codeph>log(x)</codeph></li>
		   <li><codeph>log2(x)</codeph></li>
		   <li><codeph>pow(x, y)</codeph></li>
		   <li><codeph>reciprocal(x)</codeph></li>
		   <li><codeph>sqrt(x)</codeph></li>
		 </ul>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderPrecision"><linktext>flash.display.ShaderPrecision</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:byteCode:set"><apiName>byteCode</apiName><shortdesc>
		 The raw shader bytecode for this Shader instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier></apiValueDef><apiDesc>
		 The raw shader bytecode for this Shader instance.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsData"><apiName>IGraphicsData</apiName><shortdesc>
	This interface is used to define objects that can be used as parameters in the flash.display.Graphics
	methods, including fills, strokes, and paths.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier></apiBaseClassifier></apiClassifierDef><apiDesc>
	This interface is used to define objects that can be used as parameters in the flash.display.Graphics
	methods, including fills, strokes, and paths. Use the implementor classes of this interface to
	create and manage drawing property data, and to reuse the same data for different instances.
	Then, use the methods of the Graphics class to render the drawing
	objects.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:MovieClip"><apiName>MovieClip</apiName><shortdesc>
 The MovieClip class inherits from the following classes: Sprite, DisplayObjectContainer, 
 InteractiveObject, DisplayObject, and EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>The basic display object for ActionScript created objects.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:Sprite</apiBaseClassifier></apiClassifierDef><apiDesc>
 The MovieClip class inherits from the following classes: Sprite, DisplayObjectContainer, 
 InteractiveObject, DisplayObject, and EventDispatcher.
 
 <p>Unlike the Sprite object, a MovieClip object has a timeline.</p>
 
 <p product="flash">The methods for the MovieClip class provide the same functionality 
 as actions that target movie clips. Some additional methods do not have equivalent 
 actions in the Actions toolbox in the Actions panel in the Flash authoring tool. </p>
 
 <p>Children instances placed on the Stage in the Flash authoring tool cannot be accessed by code from within the
 constructor of a parent instance since they have not been created at that point in code execution.
 Before accessing the child, the parent must instead either create the child instance
 by code or delay access to a callback function that listens for the child to dispatch
 its <codeph>Event.ADDED_TO_STAGE</codeph> event.</p>
 
 <p>If you modify any of the following properties of a MovieClip object that contains a motion tween,
 the playhead is stopped in that MovieClip object: <codeph>alpha</codeph>, <codeph>blendMode</codeph>, 
 <codeph>filters</codeph>, <codeph>height</codeph>, <codeph>opaqueBackground</codeph>, <codeph>rotation</codeph>, 
 <codeph>scaleX</codeph>, <codeph>scaleY</codeph>, <codeph>scale9Grid</codeph>, <codeph>scrollRect</codeph>, 
 <codeph>transform</codeph>, <codeph>visible</codeph>, <codeph>width</codeph>, <codeph>x</codeph>, 
 or <codeph>y</codeph>. However, it does not stop the playhead in any child MovieClip objects of that 
 MovieClip object.</p>
 
 </apiDesc><example conref="examples\MovieClipExample.as"> The following example uses the MovieClipExample class to illustrate how
 to monitor various properties of a MovieClip.  This task is accomplished by performing the following steps:
 
 <ol>
 
  <li>The constructor function defines a text field, which is used to display values of properties
  of the MovieClipExample object (which extends MovieClip).</li>
 
  <li>The return value of the <codeph>getPropertiesString()</codeph> method is used as text for the 
  <codeph>outputText</codeph> text field. The <codeph>getPropertiesString()</codeph> method returns
  a string that is populated with values of the following properties of the movie clip: 
  <codeph>currentFrame</codeph>, <codeph>currentLabel</codeph>, <codeph>currentScene</codeph>, 
  <codeph>framesLoaded</codeph>, <codeph>totalFrames</codeph>, and <codeph>trackAsMenu</codeph>.</li>
 
  <li>Two lines of code in the constructor function adjust the <codeph>width</codeph> and
  <codeph>height</codeph> properties of the <codeph>outputText</codeph> text field.</li>
 
  <li>The last line of the constructor function adds the <codeph>outputText</codeph> text field
  to the display list.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.MovieClip;
    import flash.text.TextField;

    public class MovieClipExample extends MovieClip {

        public function MovieClipExample() {
            var outputText:TextField = new TextField();
            outputText.text = getPropertiesString();
            outputText.width = stage.stageWidth;
            outputText.height = outputText.textHeight;
            addChild(outputText);
        }

        private function getPropertiesString():String {
            var str:String = ""
                + "currentFrame: " + currentFrame + "\n"
                + "currentLabel: " + currentLabel + "\n"
                + "currentScene: " + currentScene + "\n"
                + "framesLoaded: " + framesLoaded + "\n"
                + "totalFrames: " + totalFrames + "\n"
                + "trackAsMenu: " + trackAsMenu + "\n";
            return str;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:MovieClip:MovieClip"><apiName>MovieClip</apiName><shortdesc>
	Creates a new MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Creates a new MovieClip instance. After creating the MovieClip, call the 
	<codeph>addChild()</codeph> or <codeph>addChildAt()</codeph> method of a
	display object container that is onstage.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:MovieClip:gotoAndPlay"><apiName>gotoAndPlay</apiName><shortdesc>
	 Starts playing the SWF file at the specified frame.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandplay, gotoandplay
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>A number representing the frame number, or a string representing the label of the 
	 frame, to which the playhead is sent. If you specify a number, it is relative to the 
     scene you specify. If you do not specify a scene, the current scene determines the global frame number to play. If you do specify a scene, the playhead
	 jumps to the frame number in the specified scene.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>The name of the scene to play. This parameter is optional.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Starts playing the SWF file at the specified frame.  This happens after all 
	 remaining actions in the frame have finished executing.  To specify a scene 
	 as well as a frame, specify a value for the <codeph>scene</codeph> parameter.
	 
	 </apiDesc><example conref="examples\MovieClip.gotoAndPlay.1.as"> The following code uses the <codeph>gotoAndPlay()</codeph> method to direct the playhead of 
 the <codeph>mc1</codeph> movie clip to advance five frames ahead of its current location:
<codeblock>
mc1.gotoAndPlay(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndPlay.2.as"> The following code uses the <codeph>gotoAndPlay()</codeph> method to direct the playhead of 
 the <codeph>mc1</codeph> movie clip to the frame labeled <codeph>"intro"</codeph> in the scene named 
 <codeph>"Scene 12"</codeph>:
<codeblock>
mc1.gotoAndPlay("intro", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:gotoAndStop"><apiName>gotoAndStop</apiName><shortdesc>
	  Brings the playhead to the specified frame of the movie clip and stops it there.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandstop, gotoandstop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>If the <codeph>scene</codeph> or <codeph>frame</codeph> specified are
	 not found in this movie clip.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>A number representing the frame number, or a string representing the label of the 
	 frame, to which the playhead is sent. If you specify a number, it is relative to the 
     scene you specify. If you do not specify a scene, the current scene determines the global frame number at which to go to and stop. If you do specify a scene, 
	 the playhead goes to the frame number in the specified scene and stops.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>The name of the scene. This parameter is optional.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Brings the playhead to the specified frame of the movie clip and stops it there.  This happens after all 
	 remaining actions in the frame have finished executing.  If you want to specify a scene in addition to a frame, 
	 specify a <codeph>scene</codeph> parameter.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> The following code uses the <codeph>gotoAndStop()</codeph> method and the 
 <codeph>currentFrame</codeph> property to direct the playhead of the <codeph>mc1</codeph> movie clip to 
 advance five frames ahead of its current location and stop:
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndStop.1.as"> The following code uses the <codeph>gotoAndStop()</codeph> to direct the playhead of 
 the <codeph>mc1</codeph> movie clip to the frame labeled <codeph>"finale"</codeph> in the scene named 
 <codeph>"Scene 12"</codeph> and stop the playhead:
<codeblock>
mc1.gotoAndStop("finale", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:nextFrame"><apiName>nextFrame</apiName><shortdesc>
	 Sends the playhead to the next frame and stops it.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.nextframe, nextframe
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Sends the playhead to the next frame and stops it.  This happens after all 
	 remaining actions in the frame have finished executing.
	 
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> In the following example, two SimpleButton objects control the timeline. The <codeph>prev</codeph> 
 button moves the playhead to the previous frame, and the <codeph>nextBtn</codeph> button moves the playhead 
 to the next frame:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/prevFrame()"><linktext>prevFrame()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:nextScene"><apiName>nextScene</apiName><shortdesc>
	 Moves the playhead to the next scene of the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Moves the playhead to the next scene of the MovieClip instance.  This happens after all 
	 remaining actions in the frame have finished executing.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> In the following example, two SimpleButton objects control the timeline. The <codeph>prevBtn</codeph> 
 button moves the playhead to the previous scene, and the <codeph>nextBtn</codeph> button moves the playhead 
 to the next scene:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:play"><apiName>play</apiName><shortdesc>
	 Moves the playhead in the timeline of the movie clip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.play, play
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Moves the playhead in the timeline of the movie clip.
	 
	 </apiDesc><example conref="examples\MovieClip.play.1.as"> The following code uses the <codeph>stop()</codeph> method to stop a movie clip
 named <codeph>mc1</codeph> and to resume playing when the user clicks the text field named 
 <codeph>continueText</codeph>:
<codeblock>

import flash.text.TextField;
import flash.events.MouseEvent;

var continueText:TextField = new TextField();
continueText.text = "Play movie...";
addChild(continueText);

mc1.stop();
continueText.addEventListener(MouseEvent.CLICK, resumeMovie);

function resumeMovie(event:MouseEvent):void {
    mc1.play();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>gotoAndPlay()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:prevFrame"><apiName>prevFrame</apiName><shortdesc>
	 Sends the playhead to the previous frame and stops it.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.prevframe, prevframe, previous frame
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Sends the playhead to the previous frame and stops it.  This happens after all 
	 remaining actions in the frame have finished executing.
	  
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> In the following example, two SimpleButton objects control the timeline. The <codeph>prev</codeph> 
 button moves the playhead to the previous frame, and the <codeph>nextBtn</codeph> button moves the playhead 
 to the next frame:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:prevScene"><apiName>prevScene</apiName><shortdesc>
	 Moves the playhead to the previous scene of the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Moves the playhead to the previous scene of the MovieClip instance.  This happens after all 
	 remaining actions in the frame have finished executing.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> In the following example, two SimpleButton objects control the timeline. The <codeph>prevBtn</codeph> 
 button moves the playhead to the previous scene, and the <codeph>nextBtn</codeph> button moves the playhead 
 to the next scene:
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:stop"><apiName>stop</apiName><shortdesc>
	 Stops the playhead in the movie clip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.stop, stop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Stops the playhead in the movie clip.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:MovieClip:currentFrame:get"><apiName>currentFrame</apiName><shortdesc>
	 Specifies the number of the frame in which the playhead is located in the timeline of 
	 the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.currentFrame, currentFrame, currentFrame
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Specifies the number of the frame in which the playhead is located in the timeline of 
	 the MovieClip instance. If the movie clip has multiple scenes, this value is the 
	 frame number in the current scene.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> The following code uses the <codeph>gotoAndStop()</codeph> method and the 
 <codeph>currentFrame</codeph> property to direct the playhead of the <codeph>mc1</codeph> movie clip to 
 advance five frames ahead of its current location and stop:
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentFrameLabel:get"><apiName>currentFrameLabel</apiName><shortdesc>
	 The label at the current frame in the timeline of the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The label at the current frame in the timeline of the MovieClip instance.
     If the current frame has no label, <codeph>currentLabel</codeph> is <codeph>null</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrameLabel.1.as"/></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabel:get"><apiName>currentLabel</apiName><shortdesc>
	 The current label in which the playhead is located in the timeline of the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The current label in which the playhead is located in the timeline of the MovieClip instance.
     If the current frame has no label, <codeph>currentLabel</codeph> is set to the name of the previous frame 
     that includes a label. If the current frame and previous frames do not include a label,
     <codeph>currentLabel</codeph> returns <codeph>null</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabel.1.as"> The following code illustrates how to access the <codeph>currentLabel</codeph> 
 property of a MovieClip object named <codeph>mc1</codeph>:
<codeblock>
trace(mc1.currentLabel);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabels:get"><apiName>currentLabels</apiName><shortdesc>
	 Returns an array of FrameLabel objects from the current scene.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Returns an array of FrameLabel objects from the current scene. If the MovieClip instance does
	 not use scenes, the array includes all frame labels from the entire MovieClip instance.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabels.1.as"> The following code illustrates how to use the <codeph>currentLabels</codeph> 
 property of a MovieClip object named <codeph>mc1</codeph>:
<codeblock>
import flash.display.FrameLabel;
 
var labels:Array = mc1.currentLabels;

for (var i:uint = 0; i &lt; labels.length; i++) {
    var label:FrameLabel = labels[i];
    trace("frame " + label.frame + ": " + label.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>flash.display.FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:currentScene:get"><apiName>currentScene</apiName><shortdesc>
	 The current scene in which the playhead is located in the timeline of the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Scene</apiValueClassifier></apiValueDef><apiDesc>
	 The current scene in which the playhead is located in the timeline of the MovieClip instance.
	 
	 </apiDesc><example conref="examples\MovieClip.currentScene.1.as"> The following code illustrates how to use the <codeph>currentScene</codeph> 
 property of a MovieClip object named <codeph>mc1</codeph>:
<codeblock>
import flash.display.Scene;
 
var scene:Scene = mc1.currentScene;
trace(scene.name + ": " + scene.numFrames + " frames");
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:enabled:get"><apiName>enabled</apiName><shortdesc>
	 A Boolean value that indicates whether a movie clip is enabled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 A Boolean value that indicates whether a movie clip is enabled. The default value of <codeph>enabled</codeph>
	 is <codeph>true</codeph>. If <codeph>enabled</codeph> is set to <codeph>false</codeph>, the movie clip's
	 Over, Down, and Up frames are disabled. The movie clip
	 continues to receive events (for example, <codeph>mouseDown</codeph>,
	 <codeph>mouseUp</codeph>, <codeph>keyDown</codeph>, and <codeph>keyUp</codeph>).
	 
	 <p>The <codeph>enabled</codeph> property governs only the button-like properties of a movie clip. You
	 can change the <codeph>enabled</codeph> property at any time; the modified movie clip is immediately
	 enabled or disabled. If <codeph>enabled</codeph> is set to <codeph>false</codeph>, the object is not 
	 included in automatic tab ordering.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.enabled.1.as"> The following code illustrates how to use the <codeph>enabled</codeph> property
 to disable the button-like properties of a MovieClip object named <codeph>mc1</codeph>:
<codeblock>
mc1.enabled = false;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:framesLoaded:get"><apiName>framesLoaded</apiName><shortdesc>
	 The number of frames that are loaded from a streaming SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.framesLoaded, framesLoaded, framesloaded
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The number of frames that are loaded from a streaming SWF file. You can use the <codeph>framesLoaded</codeph> 
	 property to determine whether the contents of a specific frame and all the frames before it
	 loaded and are available locally in the browser. You can also use it to monitor the downloading 
	 of large SWF files. For example, you might want to display a message to users indicating that 
	 the SWF file is loading until a specified frame in the SWF file finishes loading.
	 
	 <p>If the movie clip contains multiple scenes, the <codeph>framesLoaded</codeph> property returns the number 
	 of frames loaded for <i>all</i> scenes in the movie clip.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.framesLoaded.1.as"> The following code illustrates how to use the <codeph>framesLoaded</codeph> 
 property and the <codeph>totalFrames</codeph> property to determine if a streaming MovieClip 
 object named <codeph>mc1</codeph> is fully loaded:
<codeblock>
if (mc1.framesLoaded == mc1.totalFrames) {
    trace("OK.");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>Loader class</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:scenes:get"><apiName>scenes</apiName><shortdesc>
	 An array of Scene objects, each listing the name, the number of frames,
	 and the frame labels for a scene in the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 An array of Scene objects, each listing the name, the number of frames,
	 and the frame labels for a scene in the MovieClip instance.
	 
	 </apiDesc><example conref="examples\MovieClip.scenes.1.as"> The following code illustrates how to use the <codeph>scenes</codeph> 
 property of a MovieClip object named <codeph>mc1</codeph>:
<codeblock>
import flash.display.Scene;
 
for (var i:uint = 0; i &lt; mc1.scenes.length; i++) {
    var scene:Scene = mc1.scenes[i];
    trace("scene " + scene.name + ": " + scene.numFrames + " frames");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:totalFrames:get"><apiName>totalFrames</apiName><shortdesc>
	 The total number of frames in the MovieClip instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.totalFrames, totalFrames, totalFrames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The total number of frames in the MovieClip instance.
	 
	 <p>If the movie clip contains multiple frames, the <codeph>totalFrames</codeph> property returns 
	 the total number of frames in <i>all</i> scenes in the movie clip.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.totalFrames.1.as"> The following code illustrates the use of the <codeph>totalFrames</codeph> 
 property of a MovieClip object named <codeph>mc1</codeph>:
<codeblock>
 trace(mc1.totalFrames);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Indicates whether other display objects that are SimpleButton or MovieClip objects can receive 
	 mouse release events.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates whether other display objects that are SimpleButton or MovieClip objects can receive 
	 mouse release events. The <codeph>trackAsMenu</codeph> property lets you create menus. You 
	 can set the <codeph>trackAsMenu</codeph> property on any SimpleButton or MovieClip object.
	 The default value of the <codeph>trackAsMenu</codeph> property is <codeph>false</codeph>. 
	 
	 <p>You can change the <codeph>trackAsMenu</codeph> property at any time; the modified movie 
	 clip immediately uses the new behavior.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.trackAsMenu.1.as"> The following code illustrates how to use the <codeph>trackAsMenu</codeph> 
 property to enable mouse release events for a MovieClip object named <codeph>mc1</codeph>:
<codeblock>
 mc1.trackAsMenu = true;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SWFVersion"><apiName>SWFVersion</apiName><shortdesc>
	The SWFVersion class is an enumeration of constant values that indicate the 
	file format version of a loaded SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	The SWFVersion class is an enumeration of constant values that indicate the 
	file format version of a loaded SWF file.
	
	The SWFVersion constants are provided for use in checking the 
	<codeph>swfVersion</codeph> property of a flash.display.LoaderInfo object.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/swfVersion"><linktext>flash.display.LoaderInfo.swfVersion</linktext></link></related-links><apiValue id="flash.display:SWFVersion:FLASH1"><apiName>FLASH1</apiName><shortdesc>
		SWF file format version 1.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 1.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH10"><apiName>FLASH10</apiName><shortdesc>
		SWF file format version 10.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>10</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 10.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH2"><apiName>FLASH2</apiName><shortdesc>
		SWF file format version 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 2.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH3"><apiName>FLASH3</apiName><shortdesc>
		SWF file format version 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 3.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH4"><apiName>FLASH4</apiName><shortdesc>
		SWF file format version 4.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 4.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH5"><apiName>FLASH5</apiName><shortdesc>
		SWF file format version 5.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 5.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH6"><apiName>FLASH6</apiName><shortdesc>
		SWF file format version 6.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>6</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 6.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH7"><apiName>FLASH7</apiName><shortdesc>
		SWF file format version 7.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>7</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 7.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH8"><apiName>FLASH8</apiName><shortdesc>
		SWF file format version 8.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 8.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH9"><apiName>FLASH9</apiName><shortdesc>
		SWF file format version 9.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>9</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF file format version 9.0. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowResize"><apiName>NativeWindowResize</apiName><shortdesc>
The NativeWindowResize class defines constants for the possible values 
 of the edgeOrCorner parameter of the NativeWindow 
 startResize() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The NativeWindowResize class defines constants for the possible values 
 of the <codeph>edgeOrCorner</codeph> parameter of the NativeWindow 
 <codeph>startResize()</codeph> method. 
<p>A constant is defined to name each edge and corner of a window.</p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow/startResize()"><linktext>flash.display.NativeWindow.startResize()</linktext></link></related-links><apiValue id="flash.display:NativeWindowResize:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
The bottom edge of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The bottom edge of the window. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
The bottom-left corner of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The bottom-left corner of the window. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
The bottom-right corner of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The bottom-right corner of the window. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:LEFT"><apiName>LEFT</apiName><shortdesc>
The left edge of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The left edge of the window.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:NONE"><apiName>NONE</apiName><shortdesc>
Provides no hint to the system about which edge or corner to 
resize from, allowing for default behavior.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Provides no hint to the system about which edge or corner to 
resize from, allowing for default behavior.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:RIGHT"><apiName>RIGHT</apiName><shortdesc>
The right edge of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The right edge of the window. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP"><apiName>TOP</apiName><shortdesc>
The top edge of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The top edge of the window. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
The top-left corner of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The top-left corner of the window. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
The top-right corner of the window.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
The top-right corner of the window. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapDataChannel"><apiName>BitmapDataChannel</apiName><shortdesc>
The BitmapDataChannel class is an enumeration of constant values that indicate which channel to 
use: red, blue, green, or alpha transparency.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The BitmapDataChannel class is an enumeration of constant values that indicate which channel to 
use: red, blue, green, or alpha transparency. 

<p>When you call some methods, you can use the bitwise OR operator (<codeph>|</codeph>) 
to combine BitmapDataChannel constants to indicate multiple color channels.</p>

<p>The BitmapDataChannel constants are provided for use as values in the following:</p>

<ul>

	<li>The <codeph>sourceChannel</codeph> and <codeph>destChannel</codeph> parameters of the 
	<codeph>flash.display.BitmapData.copyChannel()</codeph> method</li>

	<li>The <codeph>channelOptions</codeph> parameter of the 
	<codeph>flash.display.BitmapData.noise()</codeph> method</li>

	<li>The <codeph>flash.filters.DisplacementMapFilter.componentX</codeph> and 
	<codeph>flash.filters.DisplacementMapFilter.componentY</codeph> properties</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/copyChannel()"><linktext>flash.display.BitmapData.copyChannel()</linktext></link><link href="flash.display.xml#BitmapData/noise()"><linktext>flash.display.BitmapData.noise()</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentX"><linktext>flash.filters.DisplacementMapFilter.componentX</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentY"><linktext>flash.filters.DisplacementMapFilter.componentY</linktext></link></related-links><apiValue id="flash.display:BitmapDataChannel:ALPHA"><apiName>ALPHA</apiName><shortdesc>
		The alpha channel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		The alpha channel. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:BLUE"><apiName>BLUE</apiName><shortdesc> 
		The blue channel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		The blue channel. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:GREEN"><apiName>GREEN</apiName><shortdesc>
		The green channel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		The green channel.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:RED"><apiName>RED</apiName><shortdesc>
		The red channel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		The red channel. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Defines a solid fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines a solid fill. 
 
 <p>
 Use a GraphicsSolidFill object with the <codeph>Graphics.drawGraphicsData()</codeph> method.
 Drawing a GraphicsSolidFill object is the equivalent of calling the <codeph>Graphics.beginFill()</codeph> method.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>flash.display.Graphics.beginFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsSolidFill:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Creates a new GraphicsSolidFill object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>The color value. Valid values are in the hexadecimal format 0xRRGGBB.  
 </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>The alpha transparency value. Valid values are 0 (fully transparent) to 1 (fully opaque).
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Creates a new GraphicsSolidFill object. 
 
 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:GraphicsSolidFill:alpha"><apiName>alpha</apiName><shortdesc>
 Indicates the alpha transparency value of the fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Indicates the alpha transparency value of the fill. Valid values are 0 (fully transparent) to 1 (fully opaque). 
 The default value is 1. Display objects with alpha set to 0 are active, even though they are invisible. 
 
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsSolidFill:color"><apiName>color</apiName><shortdesc>
 The color of the fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
 The color of the fill. Valid values are in the hexadecimal format 0xRRGGBB. The default value is 0xFF0000 (or the uint 0). 
 
 
 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IBitmapDrawable"><apiName>IBitmapDrawable</apiName><shortdesc>
	The IBitmapDrawable interface is implemented by objects that can be passed as the source
	parameter of the draw() method of the BitmapData class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier></apiBaseClassifier></apiClassifierDef><apiDesc>
	The IBitmapDrawable interface is implemented by objects that can be passed as the <codeph>source</codeph>
	parameter of the <codeph>draw()</codeph> method of the BitmapData class. These objects are of type BitmapData
	or DisplayObject. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:CapsStyle"><apiName>CapsStyle</apiName><shortdesc>
 The CapsStyle class is an enumeration of constant values that specify the caps style to use in drawing lines.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The CapsStyle class is an enumeration of constant values that specify the caps style to use in drawing lines.
 The constants are provided for use as values in the <codeph>caps</codeph> parameter of the
 <codeph>flash.display.Graphics.lineStyle()</codeph> method. You can specify the following three types of caps:
 
 <p><adobeimage alt="The three types of caps: NONE, ROUND, and SQUARE." href="../../images/linecap.jpg"/></p> 
 
 </apiDesc><example conref="examples\CapsStyleExample.as"> The following example uses the <codeph>CapsStyleExample</codeph> class to draw three
 parallel lines, each with a different line cap style.
 <ol>
     <li>The properties of each line are set as follows:
     <ul>
         <li>The line length is set to 80 pixels.</li>
         <li>The border color is set to orange.</li>
         <li>The border size is set to 30 pixels. </li>
         <li>The highlight color is set to gray. </li>
         <li>The highlight size is set to 0 pixels.</li>
         <li>The alpha is set to 1, making it solid.</li>
         <li>The pixel hinting is set to false (strokes not hinted to full pixels).</li>
         <li>The line scale mode is set to normal, which scales the thickness. </li>
         <li>The joint style of the border caps are set to <codeph>MITER</codeph>.</li>
         <li>The miter limit is set to 1, indicating that the miter is cut off close to the line.</li>
     </ul></li>
    <li>The class constructor creates three vertical lines, starting at <i>x = 0, y = 0</i> by calling 
     the <codeph>drawLine()</codeph> method three times using the three different line cap styles (none,
     round, and square).  Each of the three calls to the <codeph>drawLine()</codeph> method uses the cap style and
     properties listed previously to draw a vertical line and associated line highlight. The calls
     first create a new <codeph>child</codeph> Shape object and then use methods of the Graphics
     class to set the line style and draw the lines and highlights. Each instance of <codeph>child</codeph>
     is added to the display list and drawn on the stage.</li>
     <li>The connected line segments are redrawn by using the <codeph>refreshLayout()</codeph> method at <i>y = 80</i>
     pixels and starting at <i>x = 80</i> pixels, with a 25-pixel separation between the line segments.</li>
 </ol>
<codeblock>
package {
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class CapsStyleExample extends Sprite {
        private var lineLength:uint            = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderJointStyle:String    = JointStyle.MITER;
        private var borderMiterLimit:uint      = 1;

        public function CapsStyleExample() {
            drawLine(CapsStyle.NONE);
            drawLine(CapsStyle.ROUND);
            drawLine(CapsStyle.SQUARE);
            refreshLayout();
        }

        private function drawLine(capsStyle:String):void {
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     capsStyle,
                                     borderJointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = lineLength;
            lastChild.y = lineLength;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = lineLength;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:CapsStyle:NONE"><apiName>NONE</apiName><shortdesc>
	 
	 Used to specify no caps in the caps parameter of the
	 flash.display.Graphics.lineStyle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Used to specify no caps in the <codeph>caps</codeph> parameter of the
	 <codeph>flash.display.Graphics.lineStyle()</codeph> method.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	 
	 Used to specify round caps in the caps parameter of the
	 flash.display.Graphics.lineStyle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Used to specify round caps in the <codeph>caps</codeph> parameter of the
	 <codeph>flash.display.Graphics.lineStyle()</codeph> method.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:SQUARE"><apiName>SQUARE</apiName><shortdesc>
	 
	 Used to specify square caps in the caps parameter of the
	 flash.display.Graphics.lineStyle() method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>square</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Used to specify square caps in the <codeph>caps</codeph> parameter of the
	 <codeph>flash.display.Graphics.lineStyle()</codeph> method.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageScaleMode"><apiName>StageScaleMode</apiName><shortdesc>
The StageScaleMode class provides values for the Stage.scaleMode property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The StageScaleMode class provides values for the <codeph>Stage.scaleMode</codeph> property. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/scaleMode"><linktext>flash.display.Stage.scaleMode</linktext></link></related-links><apiValue id="flash.display:StageScaleMode:EXACT_FIT"><apiName>EXACT_FIT</apiName><shortdesc>
Specifies that the entire application be visible in the specified area without trying to preserve 
the original aspect ratio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exactFit</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the entire application be visible in the specified area without trying to preserve 
the original aspect ratio. Distortion can occur.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_BORDER"><apiName>NO_BORDER</apiName><shortdesc>
Specifies that the entire application fill the specified area, without distortion but possibly with 
some cropping, while maintaining the original aspect ratio of the application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noBorder</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the entire application fill the specified area, without distortion but possibly with 
some cropping, while maintaining the original aspect ratio of the application.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_SCALE"><apiName>NO_SCALE</apiName><shortdesc>
Specifies that the size of the application be fixed, so that it remains unchanged even as the size 
of the player window changes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noScale</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the size of the application be fixed, so that it remains unchanged even as the size 
of the player window changes. Cropping might occur if the player window is smaller than the content.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:SHOW_ALL"><apiName>SHOW_ALL</apiName><shortdesc>
Specifies that the entire application be visible in the specified area without distortion while 
maintaining the original aspect ratio of the application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>showAll</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the entire application be visible in the specified area without distortion while 
maintaining the original aspect ratio of the application. Borders can appear on two sides of the application.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SpreadMethod"><apiName>SpreadMethod</apiName><shortdesc>
The SpreadMethod class provides values for the spreadMethod parameter 
in the beginGradientFill() and lineGradientStyle() methods of the Graphics class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The SpreadMethod class provides values for the <codeph>spreadMethod</codeph> parameter 
in the <codeph>beginGradientFill()</codeph> and <codeph>lineGradientStyle()</codeph> methods of the Graphics class.

<p>The following example shows the same gradient fill using various spread methods:</p>

<adobetable>





<tgroup cols="3"><tbody><row>

	<entry align="center"><adobeimage alt="linear gradient with SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>

  <entry align="center"><adobeimage alt="linear gradient with SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>

  <entry align="center"><adobeimage alt="linear gradient with SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>

</row><row>

	 <entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>


</row></tbody></tgroup></adobetable>


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:SpreadMethod:PAD"><apiName>PAD</apiName><shortdesc>
Specifies that the gradient use the pad spread method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pad</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the gradient use the <i>pad</i> spread method.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REFLECT"><apiName>REFLECT</apiName><shortdesc>
Specifies that the gradient use the reflect spread method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reflect</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the gradient use the <i>reflect</i> spread method.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REPEAT"><apiName>REPEAT</apiName><shortdesc>
Specifies that the gradient use the repeat spread method.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>repeat</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the gradient use the <i>repeat</i> spread method.
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:FocusDirection"><apiName>FocusDirection</apiName><shortdesc>
 The FocusDirection class enumerates values to be used for the 
 direction parameter of the assignFocus() method
 of a Stage object and for the direction property of a FocusEvent object.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The FocusDirection class enumerates values to be used for the 
 <codeph>direction</codeph> parameter of the <codeph>assignFocus()</codeph> method
 of a Stage object and for the <codeph>direction</codeph> property of a FocusEvent object.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#FocusEvent/direction"><linktext>flash.events.FocusEvent.direction</linktext></link><link href="flash.display.xml#Stage/assignFocus()"><linktext>flash.display.Stage.assignFocus()</linktext></link></related-links><apiValue id="flash.display:FocusDirection:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
		Indicates that focus should be given to the object at the end of the reading order.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bottom</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Indicates that focus should be given to the object at the end of the reading order.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:NONE"><apiName>NONE</apiName><shortdesc>
		Indicates that focus object within the interactive object should not change.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Indicates that focus object within the interactive object should not change.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:TOP"><apiName>TOP</apiName><shortdesc>
		Indicates that focus should be given to the object at the beginning of the reading order.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>top</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Indicates that focus should be given to the object at the beginning of the reading order.
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageAlign"><apiName>StageAlign</apiName><shortdesc>
The StageAlign class provides constant values to use for the Stage.align property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The StageAlign class provides constant values to use for the <codeph>Stage.align</codeph> property. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/align"><linktext>flash.display.Stage.align</linktext></link></related-links><apiValue id="flash.display:StageAlign:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
Specifies that the Stage is aligned at the bottom.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned at the bottom. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
Specifies that the Stage is aligned in the bottom-left corner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned in the bottom-left corner. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
Specifies that the Stage is aligned in the bottom-right corner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned in the bottom-right corner. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
Specifies that the Stage is aligned on the left.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned on the left. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
Specifies that the Stage is aligned to the right.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned to the right. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP"><apiName>TOP</apiName><shortdesc>
Specifies that the Stage is aligned at the top.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned at the top. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
Specifies that the Stage is aligned in the top-left corner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned in the top-left corner. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
Specifies that the Stage is aligned in the top-right corner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Specifies that the Stage is aligned in the top-right corner. 
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrectionSupport"><apiName>ColorCorrectionSupport</apiName><shortdesc>
The ColorCorrectionSupport class provides values for the flash.display.Stage.colorCorrectionSupport property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The ColorCorrectionSupport class provides values for the <codeph>flash.display.Stage.colorCorrectionSupport</codeph> property. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>flash.display.Stage.colorCorrectionSupport</linktext></link></related-links><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_OFF"><apiName>DEFAULT_OFF</apiName><shortdesc>
Color correction is supported, but off by default.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOff</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Color correction is supported, but off by default. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_ON"><apiName>DEFAULT_ON</apiName><shortdesc>
Color correction is supported, and on by default.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOn</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Color correction is supported, and on by default. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:UNSUPPORTED"><apiName>UNSUPPORTED</apiName><shortdesc>
Color correction is not supported by the host environment.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>unsupported</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Color correction is not supported by the host environment. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
 Defines a shader fill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines a shader fill. 
 
 <p>
 Use a GraphicsShaderFill object with the <codeph>Graphics.drawGraphicsData()</codeph> method.
 Drawing a GraphicsShaderFill object is the equivalent of calling the <codeph>Graphics.beginShaderFill()</codeph> method.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsShaderFill:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
     Creates a new GraphicsShaderFill object.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>The shader to use for the fill. This Shader instance is not required to 
     specify an image input. However, if an image input is specified in the shader, the input 
     must be provided manually by setting the <codeph>input</codeph> property of the corresponding ShaderInput 
     property of the <codeph>Shader.data</codeph> property.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>A matrix object (of the flash.geom.Matrix class), which you can use to
     define transformations on the shader. 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new GraphicsShaderFill object.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsShaderFill:matrix"><apiName>matrix</apiName><shortdesc>
     A matrix object (of the flash.geom.Matrix class), which you can use to
     define transformations on the shader.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     A matrix object (of the flash.geom.Matrix class), which you can use to
     define transformations on the shader. For example, you can use the following matrix
     to rotate a shader by 45 degrees (pi/4 radians):
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     <p>The coordinates received in the shader are based on the matrix that is specified
     for the <codeph>matrix</codeph> parameter. For a default (<codeph>null</codeph>) matrix, the 
     coordinates in the shader are local pixel coordinates which can be used to sample an 
     input.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsShaderFill:shader"><apiName>shader</apiName><shortdesc>
     The shader to use for the fill.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
     The shader to use for the fill. This Shader instance is not required to 
     specify an image input. However, if an image input is specified in the shader, the input 
     must be provided manually by setting the <codeph>input</codeph> property of the corresponding ShaderInput 
     property of the <codeph>Shader.data</codeph> property.
     
     <p>When you pass a Shader instance as an argument the shader is copied internally and the 
     drawing fill operation uses that internal copy, not a reference to the original shader. Any changes 
     made to the shader, such as changing a parameter value, input, or bytecode, are not applied 
     to the copied shader that's used for the fill.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Shape"><apiName>Shape</apiName><shortdesc>
 This class is used to create lightweight shapes using the ActionScript drawing application program interface (API).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>A display object used for shapes.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 This class is used to create lightweight shapes using the ActionScript drawing application program interface (API).
 The Shape class includes a <codeph>graphics</codeph> property, which lets you access methods from the Graphics class.
 
 <p>The Sprite class also includes a <codeph>graphics</codeph>property, and it includes other features not available to the 
 Shape class. For example, a Sprite object is a display object container, whereas a Shape object is not (and cannot contain 
 child display objects). For this reason, Shape objects consume less memory than Sprite objects that contain the 
 same graphics. However, a Sprite object supports mouse click events, while a Shape object does not.</p>
 
 </apiDesc><example conref="examples\ShapeExample.as"> The following example uses the <codeph>ShapeExample</codeph> class to draw a circle,
 a rounded rectangle, and a square.  This task is accomplished by performing the following steps:
 
 <ol>
    <li>Declare a <codeph>size</codeph> property for later use in determining the size of each shape.</li>
 
     <li>Declare properties that set the background color to orange, the border color to
     dark gray, the border size to 0 pixels, the corner radius to 9 pixels, and set the space
     between the stage edge and the other objects to be 5 pixels.</li>
 
    <li>Use the properties declared in the preceding steps along with the built-in methods of the
     Graphics class to draw the circle, rounded rectangle, and square at coordinates x = 0, y = 0.</li>
 
    <li>Redraw each of the shapes along the top of the stage, starting at x = 5, y = 5, with
     a 5-pixel spacing between shapes by using the <codeph>refreshLayout()</codeph> method.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class ShapeExample extends Sprite {
        private var size:uint           = 80;
        private var bgColor:uint       = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function ShapeExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size/2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#Sprite"><linktext>flash.display.Sprite</linktext></link></related-links><apiConstructor id="flash.display:Shape:Shape"><apiName>Shape</apiName><shortdesc>
     Creates a new Shape object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Creates a new Shape object.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shape:graphics:get"><apiName>graphics</apiName><shortdesc>
     Specifies the Graphics object belonging to this Shape object, where vector
     drawing commands can occur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Specifies the Graphics object for the Shape object.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Specifies the Graphics object belonging to this Shape object, where vector
     drawing commands can occur.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameterType"><apiName>ShaderParameterType</apiName><shortdesc>
	 This class defines the constants that represent the possible values for 
	 the ShaderParameter class's type property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 This class defines the constants that represent the possible values for 
	 the ShaderParameter class's <codeph>type</codeph> property. Each constant 
	 represents one of the data types available in Flash Player for 
	 parameters in the Pixel Bender shader language.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links><apiValue id="flash.display:ShaderParameterType:BOOL"><apiName>BOOL</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 bool value, equivalent to a single Boolean instance 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>bool</codeph> value, equivalent to a single Boolean instance 
		 in ActionScript.
		 
		 <p>Note that even though the parameter only expects a single value, 
		 the <codeph>ShaderParameter.value</codeph> property is an Array, so the single value 
		 must be the only element of an Array assigned to the 
		 <codeph>value</codeph> property, like this:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is bool
		 myShader.data.param.value = [true];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL2"><apiName>BOOL2</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 bool2 value, equivalent to an Array of two Boolean instances 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>bool2</codeph> value, equivalent to an Array of two Boolean instances 
		 in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL3"><apiName>BOOL3</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 bool3 value, equivalent to an Array of three Boolean instances 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>bool3</codeph> value, equivalent to an Array of three Boolean instances 
		 in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL4"><apiName>BOOL4</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 bool4 value, equivalent to an Array of four Boolean instances 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>bool4</codeph> value, equivalent to an Array of four Boolean instances 
		 in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT"><apiName>FLOAT</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a  
		 float value, equivalent to a single Number instance 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a  
		 <codeph>float</codeph> value, equivalent to a single Number instance 
		 in ActionScript.
		 
		 <p>Note that even though the parameter only expects a single value, 
		 the <codeph>ShaderParameter.value</codeph> property is an Array, so the single value 
		 must be the only element of an Array assigned to the 
		 <codeph>value</codeph> property, like this:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is float
		 myShader.data.param.value = [22.5];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT2"><apiName>FLOAT2</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 float2 value, equivalent to an Array of two Number instances 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>float2</codeph> value, equivalent to an Array of two Number instances 
		 in ActionScript.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT3"><apiName>FLOAT3</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 float3 value, equivalent to an Array of three Number instances 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>float3</codeph> value, equivalent to an Array of three Number instances 
		 in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT4"><apiName>FLOAT4</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 float4 value, equivalent to an Array of four Number instances 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>float4</codeph> value, equivalent to an Array of four Number instances 
		 in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT"><apiName>INT</apiName><shortdesc>
		 Indicates that the shader parameter is defined as an 
		 int value, equivalent to a single int or uint instance 
		 in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as an 
		 <codeph>int</codeph> value, equivalent to a single int or uint instance 
		 in ActionScript.
		 
		 <p>Note that even though the parameter only expects a single value, 
		 the <codeph>ShaderParameter.value</codeph> property is an Array, so the single value 
		 must be the only element of an Array assigned to the 
		 <codeph>value</codeph> property, like this:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is int
		 myShader.data.param.value = [275];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT2"><apiName>INT2</apiName><shortdesc>
		 Indicates that the shader parameter is defined as an 
		 int2 value, equivalent to an Array of two int or uint 
		 instances in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as an 
		 <codeph>int2</codeph> value, equivalent to an Array of two int or uint 
		 instances in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT3"><apiName>INT3</apiName><shortdesc>
		 Indicates that the shader parameter is defined as an 
		 int3 value, equivalent to an Array of three int or uint 
		 instances in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as an 
		 <codeph>int3</codeph> value, equivalent to an Array of three int or uint 
		 instances in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT4"><apiName>INT4</apiName><shortdesc>
		 Indicates that the shader parameter is defined as an  
		 int4 value, equivalent to an Array of four int or uint 
		 instances in ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as an  
		 <codeph>int4</codeph> value, equivalent to an Array of four int or uint 
		 instances in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX2X2"><apiName>MATRIX2X2</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 float2x2 value, equivalent to a 2-by-2 matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix2x2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>float2x2</codeph> value, equivalent to a 2-by-2 matrix. This matrix is represented as an 
		 Array of four Number instances in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX3X3"><apiName>MATRIX3X3</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 float3x3 value, equivalent to a 3-by-3 matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix3x3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>float3x3</codeph> value, equivalent to a 3-by-3 matrix. This matrix is represented as an 
		 Array of nine Number instances in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX4X4"><apiName>MATRIX4X4</apiName><shortdesc>
		 Indicates that the shader parameter is defined as a 
		 float4x4 value, equivalent to a 4-by-4 matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix4x4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indicates that the shader parameter is defined as a 
		 <codeph>float4x4</codeph> value, equivalent to a 4-by-4 matrix. This matrix is represented as an 
		 Array of 16 Number instances in ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathWinding"><apiName>GraphicsPathWinding</apiName><shortdesc>
The GraphicsPathWinding class provides values for the flash.display.GraphicsPath.winding property 
and the flash.display.Graphics.drawPath() method
to determine the direction to draw a path.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The GraphicsPathWinding class provides values for the <codeph>flash.display.GraphicsPath.winding</codeph> property 
and the <codeph>flash.display.Graphics.drawPath()</codeph> method
to determine the direction to draw a path.
A clockwise path is positively wound, and 
a counter-clockwise path is negatively wound:
<p><adobeimage alt="positive and negative winding directions" href="../../images/winding_positive_negative.gif"/></p>
<p> When paths intersect or overlap, the winding
direction determines the rules for filling the areas created by the intersection or overlap:</p>
<p><adobeimage alt="a comparison of even-odd and non-zero winding rules" href="../../images/winding_rules_evenodd_nonzero.gif"/></p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#GraphicsPath/winding"><linktext>flash.display.GraphicsPath.winding</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiValue id="flash.display:GraphicsPathWinding:EVEN_ODD"><apiName>EVEN_ODD</apiName><shortdesc>
Establishes the even-odd winding type.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>evenOdd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Establishes the even-odd winding type. The even-odd winding type is the rule used by all of the 
original drawing API and is the default type for the <codeph>flash.display.Graphics.drawPath()</codeph> method. 
Any overlapping paths will alternate between open and closed fills. If two squares drawn with the same fill 
intersect, the area of the intersection is not filled. Adjacent areas are not the same (neither both filled nor both unfilled). 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathWinding:NON_ZERO"><apiName>NON_ZERO</apiName><shortdesc>
Establishes the non-zero winding type.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>nonZero</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Establishes the non-zero winding type. The non-zero winding type determines that
when paths of opposite winding intersect, the intersection area is unfilled (as with the even-odd winding type). 
For paths of the same winding, the intersection area is filled.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ActionScriptVersion"><apiName>ActionScriptVersion</apiName><shortdesc>
	The ActionScriptVersion class is an enumeration of constant values that
	indicate the language version of a loaded SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	The ActionScriptVersion class is an enumeration of constant values that
	indicate the language version of a loaded SWF file.
	
	The language version constants are provided for use in checking the 
	<codeph>actionScriptVersion</codeph> property of a flash.display.LoaderInfo object.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/actionScriptVersion"><linktext>flash.display.LoaderInfo.actionScriptVersion</linktext></link></related-links><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT2"><apiName>ACTIONSCRIPT2</apiName><shortdesc>
		ActionScript language version 2.0 and earlier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript language version 2.0 and earlier. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT3"><apiName>ACTIONSCRIPT3</apiName><shortdesc>
		ActionScript language version 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript language version 3.0. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
 A collection of drawing commands and the coordinate parameters for those commands.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 A collection of drawing commands and the coordinate parameters for those commands.
 <p>
 Use a GraphicsPath object with the <codeph>Graphics.drawGraphicsData()</codeph> method.
 Drawing a GraphicsPath object is the equivalent of calling the <codeph>Graphics.drawPath()</codeph> method.
 </p>
 <p>The GraphicsPath class also has its own set of methods (<codeph>curveTo()</codeph>, <codeph>lineTo()</codeph>, <codeph>moveTo()</codeph>
 <codeph>wideLineTo()</codeph> and <codeph>wideMoveTo()</codeph>) similar to those in the Graphics class
 for making adjustments to the <codeph>GraphicsPath.commands</codeph> and <codeph>GraphicsPath.data</codeph> vector arrays.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsPath:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
     Creates a new GraphicsPath object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>A Vector of integers representing commands defined by the GraphicsPathCommand class.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>A Vector of Numbers where each pair of numbers is treated as a point (an x, y pair).
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Specifies the winding rule using a value defined in the GraphicsPathWinding class.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new GraphicsPath object.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:GraphicsPath:curveTo"><apiName>curveTo</apiName><shortdesc>
     Adds a new "curveTo" command to the commands vector and 
     new coordinates to the data vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the horizontal position of the control 
     point relative to the registration point of the parent display object.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the vertical position of the control 
     point relative to the registration point of the parent display object.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the horizontal position of the next anchor 
     point relative to the registration point of the parent display object.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number that specifies the vertical position of the next anchor 
     point relative to the registration point of the parent display object.
     
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Adds a new "curveTo" command to the <codeph>commands</codeph> vector and 
     new coordinates to the <codeph>data</codeph> vector.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/CURVE_TO"><linktext>flash.display.GraphicsPathCommand.CURVE_TO</linktext></link><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:lineTo"><apiName>lineTo</apiName><shortdesc>
     Adds a new "lineTo" command to the commands vector and 
     new coordinates to the data vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The x coordinate of the destination point for the line.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The y coordinate of the destination point for the line.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Adds a new "lineTo" command to the <codeph>commands</codeph> vector and 
     new coordinates to the <codeph>data</codeph> vector.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>flash.display.GraphicsPathCommand.LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:moveTo"><apiName>moveTo</apiName><shortdesc>
     Adds a new "moveTo" command to the commands vector and 
     new coordinates to the data vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The x coordinate of the destination point.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The y coordinate of the destination point.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Adds a new "moveTo" command to the <codeph>commands</codeph> vector and 
     new coordinates to the <codeph>data</codeph> vector.
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>flash.display.GraphicsPathCommand.MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideLineTo"><apiName>wideLineTo</apiName><shortdesc>
     Adds a new "wideLineTo" command to the commands vector and 
     new coordinates to the data vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The x-coordinate of the destination point for the line.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The y-coordinate of the destination point for the line.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Adds a new "wideLineTo" command to the <codeph>commands</codeph> vector and 
     new coordinates to the <codeph>data</codeph> vector.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_LINE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_LINE_TO</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideMoveTo"><apiName>wideMoveTo</apiName><shortdesc>
     Adds a new "wideMoveTo" command to the commands vector and 
     new coordinates to the data vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The x-coordinate of the destination point.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The y-coordinate of the destination point.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Adds a new "wideMoveTo" command to the <codeph>commands</codeph> vector and 
     new coordinates to the <codeph>data</codeph> vector.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_MOVE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_MOVE_TO</linktext></link></related-links></apiOperation><apiValue id="flash.display:GraphicsPath:commands"><apiName>commands</apiName><shortdesc>
     The Vector of drawing commands as integers representing the path.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     The Vector of drawing commands as integers representing the path. Each command can be one of the values defined
     by the GraphicsPathCommand class.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPath:data"><apiName>data</apiName><shortdesc>
     The Vector of Numbers containing the parameters used with the drawing commands.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     The Vector of Numbers containing the parameters used with the drawing commands.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPath:winding:get"><apiName>winding</apiName><shortdesc>
     Specifies the winding rule using a value defined in the GraphicsPathWinding class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Specifies the winding rule using a value defined in the GraphicsPathWinding class.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:MorphShape"><apiName>MorphShape</apiName><shortdesc>
 The MorphShape class represents MorphShape objects on the display list.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 The MorphShape class represents MorphShape objects on the display list.
 You cannot create MorphShape objects directly in ActionScript; they are created when you create a shape tween 
 in the Flash authoring tool.
 
 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="flash.display:PixelSnapping"><apiName>PixelSnapping</apiName><shortdesc>

The PixelSnapping class is an enumeration of constant values for setting the pixel snapping options 
by using the pixelSnapping property of a Bitmap object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

The PixelSnapping class is an enumeration of constant values for setting the pixel snapping options 
by using the <codeph>pixelSnapping</codeph> property of a Bitmap object.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/pixelSnapping"><linktext>flash.display.Bitmap.pixelSnapping</linktext></link></related-links><apiValue id="flash.display:PixelSnapping:ALWAYS"><apiName>ALWAYS</apiName><shortdesc>
	A constant value used in the pixelSnapping property of a Bitmap object 
	to specify that the bitmap image is always snapped to the nearest 
	pixel, independent of any transformation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>always</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	A constant value used in the <codeph>pixelSnapping</codeph> property of a Bitmap object 
	to specify that the bitmap image is always snapped to the nearest 
	pixel, independent of any transformation.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:AUTO"><apiName>AUTO</apiName><shortdesc>
	A constant value used in the pixelSnapping property of a Bitmap object 
	to specify that the bitmap image is snapped to the nearest pixel if it is drawn with no rotation
	or skew and it is drawn at a scale factor of 99.9% to 100.1%.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>auto</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	A constant value used in the <codeph>pixelSnapping</codeph> property of a Bitmap object 
	to specify that the bitmap image is snapped to the nearest pixel if it is drawn with no rotation
	or skew and it is drawn at a scale factor of 99.9% to 100.1%. If these conditions are satisfied,
	the image is drawn at 100% scale, snapped to the nearest pixel. Internally, this setting allows the image
	to be drawn as fast as possible by using the vector renderer.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:NEVER"><apiName>NEVER</apiName><shortdesc>
	A constant value used in the pixelSnapping property of a Bitmap object 
	to specify that no pixel snapping occurs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	A constant value used in the <codeph>pixelSnapping</codeph> property of a Bitmap object 
	to specify that no pixel snapping occurs.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathCommand"><apiName>GraphicsPathCommand</apiName><shortdesc>
 Defines the values to use for specifying path-drawing commands.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Defines the values to use for specifying path-drawing commands. 
 
 <p>The values in this class are used by the <codeph>Graphics.drawPath()</codeph> method,
 or stored in the <codeph>commands</codeph> vector of a GraphicsPath object.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link><link href="flash.display.xml#GraphicsPath/commands"><linktext>flash.display.GraphicsPath.commands</linktext></link></related-links><apiValue id="flash.display:GraphicsPathCommand:CURVE_TO"><apiName>CURVE_TO</apiName><shortdesc>
     Specifies a drawing command that draws a curve from the current drawing position to the x- and y-coordinates 
     specified in the data vector, using a control point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Specifies a drawing command that draws a curve from the current drawing position to the x- and y-coordinates 
     specified in the data vector, using a control point.
     This command produces the same effect as the <codeph>Graphics.lineTo()</codeph> method, and 
     uses two points in the data vector control and anchor: (cx, cy, ax, ay ).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:LINE_TO"><apiName>LINE_TO</apiName><shortdesc>
     Specifies a drawing command that draws a line from the current drawing position to the x- and y-coordinates 
     specified in the data vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Specifies a drawing command that draws a line from the current drawing position to the x- and y-coordinates 
     specified in the data vector.
     This command produces the same effect as the <codeph>Graphics.lineTo()</codeph> method, and 
     uses one point in the data vector: (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:MOVE_TO"><apiName>MOVE_TO</apiName><shortdesc>
     Specifies a drawing command that moves the current drawing position to the x- and y-coordinates specified in the data vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Specifies a drawing command that moves the current drawing position to the x- and y-coordinates specified in the data vector.
     This command produces the same effect as the <codeph>Graphics.moveTo()</codeph> method, and 
     uses one point in the data vector: (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:NO_OP"><apiName>NO_OP</apiName><shortdesc>
     Represents the default "do nothing" command.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Represents the default "do nothing" command.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_LINE_TO"><apiName>WIDE_LINE_TO</apiName><shortdesc>
     Specifies a "line to" drawing command, but uses two sets of coordinates (four values) instead of one set.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Specifies a "line to" drawing command, but uses two sets of coordinates (four values) instead of one set.
     This command allows you to switch between "line to" and "curve to" commands without changing the number of data values used per command.
     This command uses two sets in the data vector: one dummy location and one (x,y) location.
     
     <p>The <codeph>WIDE_LINE_TO</codeph> and <codeph>WIDE_MOVE_TO</codeph> command variants consume the same number of parameters 
     as does the <codeph>CURVE_TO</codeph> command.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_MOVE_TO"><apiName>WIDE_MOVE_TO</apiName><shortdesc>
     Specifies a "move to" drawing command, but uses two sets of coordinates (four values) instead of one set.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Specifies a "move to" drawing command, but uses two sets of coordinates (four values) instead of one set. 
     This command allows you to switch between "move to" and "curve to" commands without changing the number of data values used per command.
     This command uses two sets in the data vector: one dummy location and one (x,y) location.
     
     <p>The <codeph>WIDE_LINE_TO</codeph> and <codeph>WIDE_MOVE_TO</codeph> command variants consume the same number of parameters 
     as does the <codeph>CURVE_TO</codeph> command.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>