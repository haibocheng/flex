 
<apiPackage id="flash.geom"><apiName>flash.geom</apiName><apiDetail/><apiClassifier id="flash.geom:Utils3D"><apiName>Utils3D</apiName><shortdesc> 
 The Utils3D class contains static methods that simplify the implementation of certain three-dimensional 
 matrix operations.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>A utility class with static methods that simplify the implementation of certain three-dimensional operation. 
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 The Utils3D class contains static methods that simplify the implementation of certain three-dimensional 
 matrix operations.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiOperation id="flash.geom:Utils3D:pointTowards"><apiName>pointTowards</apiName><shortdesc>
    Interpolates the orientation of an object toward a position.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A modified version of the Matrix3D object specified in the second parameter. To 
    transform the display object using the <codeph>pointTowards()</codeph> method, set the Matrix3D property 
    of the display object to the returned Matrix3D object.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A Number between 0 and 1 that incrementally turns the object toward the target.
    
    </apiDesc></apiParam><apiParam><apiItemName>mat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>The Matrix3D property of the object that is transformed. 
    
    </apiDesc></apiParam><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The world-relative position of the target object. World-relative defines 
    the transformation of the object relative to the world space and coordinates, 
    where all objects are positioned.  
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>The object-relative vector that defines where the display object is pointing. 
    Object-relative defines the transformation of the object relative to the object space, 
    the object's own frame of reference and coordinate system. Default value is (0,0,-1).
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>The object-relative vector that defines "up" for the display object. If the object
    is drawn looking down from the above, the <i>+z</i> axis is its "up" vector.
    Object-relative defines the transformation of the object relative to the object space, the object's 
    own frame of reference and coordinate system. Default value is (0,-1,0).
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Interpolates the orientation of an object toward a position. The <codeph>pointTowards()</codeph> 
    method combines the functionality of the <codeph>Matrix3D.pointAt()</codeph> and 
    <codeph>Matrix3D.interpolateTo()</codeph> methods.  
    
    <p>The <codeph>pointTowards()</codeph> method allows for in-place modification to the orientation.
    It decomposes the Matrix3D of the display object and replaces the rotation elements 
    by ones that make a percent turn toward the position of the target. The object 
    can make an incremental turn toward the target while still moving in its own direction. 
    The consecutive calls to the <codeph>pointTowards()</codeph> followed by a translation method 
    can produce the animation of an object chasing or following a moving target. 
    First point the object a percent point toward the target, then incrementally move the
    object along an axis.</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/pointAt()"><linktext>flash.geom.Matrix3D.pointAt()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>flash.geom.Matrix3D.interpolateTo()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>flash.geom.Matrix3D.interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVector"><apiName>projectVector</apiName><shortdesc>
    Using a projection Matrix3D object, projects a Vector3D object from one space coordinate to another.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A new Vector3D with a transformed space coordinate.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>A projection Matrix3D object that implements the projection transformation. If a display object
    has a PerspectiveProjection object, you can use the <codeph>perspectiveProjection.toMatrix()</codeph> method 
    to produce a projection Matrix3D object that applies to the children of the display object. For more advance 
    projections, use the <codeph>matrix3D.rawData</codeph> property to create a custom projection matrix. 
    There is no built-in Matrix3D method for creating a projection Matrix3D object.
    
    </apiDesc></apiParam><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The Vector3D object that is projected to a new space coordinate.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Using a projection Matrix3D object, projects a Vector3D object from one space coordinate to another. 
    The <codeph>projectVector()</codeph> method is like the <codeph>Matrix3D.transformVector()</codeph> 
    method except that the <codeph>projectVector()</codeph> method divides the <i>x</i>, <i>y</i>, and <i>z</i> 
    elements of the original Vector3D object by the projection depth value. The depth value is the distance 
    from the eye to the Vector3D object in view or eye space. The default value for this distance is the 
    value of the <i>z</i> element.
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>flash.geom.Matrix3D.transformVector()</linktext></link><link href="flash.geom.xml#Utils3D/projectVectors()"><linktext>projectVectors()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVectors"><apiName>projectVectors</apiName><shortdesc>
    Using a projection Matrix3D object, projects a Vector of three-dimensional space coordinates (verts) 
    to a Vector of two-dimensional space coordinates (projectedVerts).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>A projection Matrix3D object that implements the projection transformation. You can produce a 
    projection Matrix3D object using the <codeph>Matrix3D.rawData</codeph> property.
    </apiDesc></apiParam><apiParam><apiItemName>verts</apiItemName><apiType value="Vector$Number"/><apiDesc>A Vector of Numbers, where every three Numbers represent the <i>x</i>, <i>y</i>, 
    and <i>z</i> coordinates of a three-dimensional space, like <codeph>Vector3D(x,y,z)</codeph>. 
    
    </apiDesc></apiParam><apiParam><apiItemName>projectedVerts</apiItemName><apiType value="Vector$Number"/><apiDesc>A vector of Numbers, where every two Numbers represent a projected two-dimensional
    coordinate, like <codeph>Point(x,y)</codeph>. You should pre-allocate the Vector. The <codeph>projectVectors()</codeph> 
    method fills the values for each projected point.
    
    </apiDesc></apiParam><apiParam><apiItemName>uvts</apiItemName><apiType value="Vector$Number"/><apiDesc>A vector of Numbers, where every three Numbers represent the <i>u</i>, <i>v</i>, and <i>t</i> 
    elements of the <codeph>uvt</codeph> data. The <i>u</i> and <i>v</i> are the texture coordinate for each projected 
    point. The <i>t</i> value is the projection depth value, the distance from the eye to the Vector3D object in the 
    view or eye space. You should pre-allocate the Vector and specify the <i>u</i> and <i>v</i> values.
    The <codeph>projectVectors</codeph> method fills the <i>t</i> value for each projected point.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Projects a Vector of three-dimensional space coordinates to a Vector of two-dimensional 
    space coordinates.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Using a projection Matrix3D object, projects a Vector of three-dimensional space coordinates (<i>verts</i>) 
    to a Vector of two-dimensional space coordinates (<codeph>projectedVerts</codeph>). The projected Vector 
    object should be pre-allocated before it is used as a parameter. 
    
    <p>The <codeph>projectVectors()</codeph> method also sets the <i>t</i> value of the <i>uvt</i> data. 
    You should pre-allocate a Vector that can hold the <i>uvts</i> data for each projected
    Vector set of coordinates. Also specify the <i>u</i> and <i>v</i> values of the 
    <i>uvt</i> data. The <i>uvt</i> data is a Vector of normalized coordinates used for texture 
    mapping. In UV coordinates, (0,0) is the upper left of the bitmap, and (1,1) is the lower right of the bitmap.</p>
    
    <p>This method can be used in conjunction with the  <codeph>Graphics.drawTriangles()</codeph> method
    and the <codeph>GraphicsTrianglePath</codeph> class.</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D/projectVector()"><linktext>projectVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.geom:Vector3D"><apiName>Vector3D</apiName><shortdesc> 
 The Vector3D class represents a point or a location in the three-dimensional space using the 
 Cartesian coordinates x, y, and z.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 The Vector3D class represents a point or a location in the three-dimensional space using the 
 Cartesian coordinates x, y, and z. As in a two-dimensional space, the <codeph>x</codeph> property represents the 
 horizontal axis and the <codeph>y</codeph> property represents the vertical axis. In three-dimensional space, the
 <codeph>z</codeph> property represents depth. The value of the <codeph>x</codeph> property increases as the object moves to the right.
 The value of the <codeph>y</codeph> property increases as the object moves down. The <codeph>z</codeph> property increases as the object
 moves farther from the point of view. Using perspective projection and scaling, the object is seen 
 to be bigger when near and smaller when farther away from the screen. As in a right-handed three-dimensional
 coordinate system, the positive z-axis points away from the viewer and the value of the <codeph>z</codeph> property 
 increases as the object moves away from the viewer's eye. The origin point (0,0,0) of the global space
 is the upper-left corner of the stage. 
   
 <p><adobeimage alt="X, Y, Z Axes" href="../../images/xyzAxes.jpg"/></p>
 
 <p>The Vector3D class can also represent a direction, an arrow pointing from the origin of the coordinates, such as 
 (0,0,0), to an endpoint; or a floating-point component of an RGB (Red, Green, Blue) color model.</p> 
 
 <p>Quaternion notation introduces a fourth element, the <codeph>w</codeph> property, which provides additional orientation
 information. For example, the <codeph>w</codeph> property can define an angle of rotation of a Vector3D object. The 
 combination of the angle of rotation and the coordinates x, y, and z can determine the display object's
 orientation. Here is a representation of Vector3D elements in matrix notation:</p>
 
 <p><adobeimage alt="Vector3D elements" href="../../images/Vector3Delements.jpg"/></p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiConstructor id="flash.geom:Vector3D:Vector3D"><apiName>Vector3D</apiName><shortdesc>
     Creates an instance of a Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>The first element, such as the x coordinate. 
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>The second element, such as the y coordinate. 
     </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>The third element, such as the z coordinate. 
     </apiDesc></apiParam><apiParam><apiItemName>w</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>An optional element for additional data such as the angle of rotation. 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates an instance of a Vector3D object. If you do not specify a parameter for the constructor, 
     a Vector3D object is created with the elements (0,0,0,0).
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Vector3D:add"><apiName>add</apiName><shortdesc>
    Adds the value of the x, y, and z elements of the current Vector3D object 
    to the values of the x, y, and z elements of another Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Vector3D object that is the result of adding the current Vector3D object 
    to another Vector3D object.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>A Vector3D object to be added to the current Vector3D object.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Adds the current Vector3D object to another in order to create a new Vector3D object. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Adds the value of the x, y, and z elements of the current Vector3D object 
    to the values of the x, y, and z elements of another Vector3D object. 
    The <codeph>add()</codeph> method does not change the current Vector3D object. Instead, it returns
    a new Vector3D object with the new values.
    
    <p>The result of adding two vectors together is a resultant vector. One way to visualize
    the result is by drawing a vector from the origin or tail of the first vector
    to the end or head of the second vector. The resultant vector is the distance 
    between the origin point of the first vector and the end point of the second vector.</p>   
    
    <p><adobeimage alt="Resultant Vector3D" href="../../images/resultantVector3D.jpg"/></p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/incrementBy()"><linktext>incrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:angleBetween"><apiName>angleBetween</apiName><shortdesc>
    Returns the angle in radians between two vectors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>The angle between two Vector3D objects.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The first Vector3D object.
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The second Vector3D object.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Returns the angle in radians between two vectors. The returned angle is the smallest radian 
    the first Vector3D object rotates until it aligns with the second Vector3D object. 
    
    <p>The <codeph>angleBetween()</codeph> method is a static method. You can use it directly as 
    a method of the Vector3D class.</p>
    
    <p>To convert a degree to a radian, you can use the following formula:</p> 
    
    <p><codeph>radian = Math.PI/180 ~~ degree</codeph></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:clone"><apiName>clone</apiName><shortdesc>
    Returns a new Vector3D object that is an exact copy of the current Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new Vector3D object that is a copy of the current Vector3D object.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Returns a new Vector3D object that is an exact copy of the current Vector3D object.
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:crossProduct"><apiName>crossProduct</apiName><shortdesc>
    Returns a new Vector3D object that is perpendicular (at a right angle) to the current 
    Vector3D and another Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new Vector3D object that is perpendicular to the current Vector3D object and the Vector3D 
    object specified as the parameter.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>A second Vector3D object. 
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Returns a new Vector3D object that is perpendicular (at a right angle) to the current 
    Vector3D and another Vector3D object. If the returned Vector3D object's coordinates are 
    (0,0,0), then the two Vector3D objects are perpendicular to each other.
    
    <p><adobeimage alt="Cross Product" href="../../images/crossproduct.jpg"/></p>
    
    <p>You can use the normalized cross product of two vertices of a polygon surface with the 
    normalized vector of the camera or eye viewpoint to get a dot product. The value of
    the dot product can identify whether a surface of a three-dimensional object is hidden 
    from the viewpoint.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/dotProduct()"><linktext>dotProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:decrementBy"><apiName>decrementBy</apiName><shortdesc>
    Decrements the value of the x, y, and z elements of the current Vector3D object 
    by the values of the x, y, and z elements of specified Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The Vector3D object containing the values to subtract from the current Vector3D object.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Decrements the current Vector3D object by another Vector3D object.  
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Decrements the value of the x, y, and z elements of the current Vector3D object 
    by the values of the x, y, and z elements of specified Vector3D object. Unlike the
    <codeph>Vector3D.subtract()</codeph> method, the <codeph>decrementBy()</codeph> method changes the current 
    Vector3D object and does not return a new Vector3D object.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/subtract()"><linktext>subtract()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:distance"><apiName>distance</apiName><shortdesc>
    Returns the distance between two Vector3D objects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>The distance between two Vector3D objects.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>A Vector3D object as the first three-dimensional point. 
    </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>A Vector3D object as the second three-dimensional point.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Returns the distance between two Vector3D objects. The <codeph>distance()</codeph> method 
    is a static method. You can use it directly as a method of the Vector3D class to get 
    the Euclidean distance between two three-dimensional points.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:dotProduct"><apiName>dotProduct</apiName><shortdesc>
    If the current Vector3D object and the one specified as the parameter are unit vertices, this
    method returns the cosine of the angle between the two vertices.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A scalar which is the dot product of the current Vector3D object and the specified Vector3D object.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The second Vector3D object. 
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Returns the dot product of current and another Vector3D object.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    If the current Vector3D object and the one specified as the parameter are unit vertices, this
    method returns the cosine of the angle between the two vertices. Unit vertices are vertices that 
    point to the same direction but their length is one. They remove the length of the vector 
    as a factor in the result. You can use the <codeph>normalize()</codeph> method to convert a vector to a unit vector. 
    
    <p>The <codeph>dotProduct()</codeph> method finds the angle between two vertices. It is also 
    used in backface culling or lighting calculations. Backface culling is a procedure for determining 
    which surfaces are hidden from the viewpoint. You can use the normalized vertices from the camera, 
    or eye, viewpoint and the cross product of the vertices of a polygon surface to get the dot product. 
    If the dot product is less than zero, then the surface is facing the camera or the viewer. If the 
    two unit vertices are perpendicular to each other, they are orthogonal and the dot product is zero.
    If the two vertices are parallel to each other, the dot product is one.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/crossProduct()"><linktext>crossProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:equals"><apiName>equals</apiName><shortdesc>
    Determines whether two Vector3D objects are equal by comparing the x, y, and z 
    elements of the current Vector3D object with a specified Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the specified Vector3D object is equal to the current 
    Vector3D object; <codeph>false</codeph> if it is not equal.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The Vector3D object to be compared with the current Vector3D object.
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>An optional parameter that specifies whether the <codeph>w</codeph> property of
    the Vector3D objects is used in the comparison.  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Determines whether two Vector3D objects are equal by comparing the x, y, and z 
    elements of the current Vector3D object with a specified Vector3D object. If the values of
    these elements are the same, the two Vector3D objects are equal. If the second
    optional parameter is set to <codeph>true</codeph>, all four elements of the Vector3D objects, 
    including the <codeph>w</codeph> property, are compared. 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/nearEquals()"><linktext>nearEquals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:incrementBy"><apiName>incrementBy</apiName><shortdesc>
    Increments the value of the x, y, and z elements of the current Vector3D object 
    by the values of the x, y, and z elements of a specified Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The Vector3D object to be added to the current Vector3D object.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Increments the current Vector3D object by another Vector3D object. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Increments the value of the x, y, and z elements of the current Vector3D object 
    by the values of the x, y, and z elements of a specified Vector3D object. Unlike the
    <codeph>Vector3D.add()</codeph> method, the <codeph>incrementBy()</codeph> method changes the current 
    Vector3D object and does not return a new Vector3D object.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/add()"><linktext>add()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:nearEquals"><apiName>nearEquals</apiName><shortdesc>
    Compares the elements of the current Vector3D object with the elements of a specified
    Vector3D object to determine whether they are nearly equal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the specified Vector3D object is nearly equal to the current
    Vector3D object; <codeph>false</codeph> if it is not equal.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The Vector3D object to be compared with the current Vector3D object. 
    </apiDesc></apiParam><apiParam><apiItemName>tolerance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A number determining the tolerance factor. If the difference between the values
    of the Vector3D element specified in the <codeph>toCompare</codeph> parameter and the current Vector3D element
    is less than the tolerance number, the two values are considered nearly equal.  
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>An optional parameter that specifies whether the <codeph>w</codeph> property of
    the Vector3D objects is used in the comparison.  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Compares the elements of the current Vector3D object with the elements of a specified
    Vector3D object to determine whether they are nearly equal. The two Vector3D objects are nearly equal 
    if the value of all the elements of the two vertices are equal, or the result of the comparison
    is within the tolerance range. The difference between two elements must be less than the number 
    specified as the <codeph>tolerance</codeph> parameter. If the third optional parameter is set to 
    <codeph>true</codeph>, all four elements of the Vector3D objects, including the <codeph>w</codeph> property, 
    are compared. Otherwise, only the x, y, and z elements are included in the comparison.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/equals()"><linktext>equals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:negate"><apiName>negate</apiName><shortdesc>
    Sets the current Vector3D object to its inverse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Sets the current Vector3D object to its inverse. The inverse object is also considered the
    opposite of the original object. The value of 
    the <codeph>x</codeph>, <codeph>y</codeph>, and <codeph>z</codeph> properties of the current Vector3D object 
    is changed to <codeph>-x</codeph>, <codeph>-y</codeph>, and <codeph>-z</codeph>. 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:normalize"><apiName>normalize</apiName><shortdesc>
    Converts a Vector3D object to a unit vector by dividing the first three elements 
    (x, y, z) by the length of the vector.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The length of the current Vector3D object.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Converts a Vector3D object to a unit vector by dividing the first three elements 
    (x, y, z) by the length of the vector. Unit vertices are 
    vertices that have a direction but their length is one. They simplify
    vector calculations by removing length as a factor.
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:project"><apiName>project</apiName><shortdesc>
     Divides the value of the x, y, and z properties of the 
     current Vector3D object by the value of its w property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Divides the value of the <codeph>x</codeph>, <codeph>y</codeph>, and <codeph>z</codeph> properties of the 
     current Vector3D object by the value of its <codeph>w</codeph> property. 
     
     <p>If the current Vector3D object is the result of multiplying a Vector3D object by a projection Matrix3D object,
     the <codeph>w</codeph> property can hold the transform value. The <codeph>project()</codeph> method then can 
     complete the projection by dividing the elements by the <codeph>w</codeph> property. Use the
     <codeph>Matrix3D.rawData</codeph> property to create a projection Matrix3D object.</p>
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:scaleBy"><apiName>scaleBy</apiName><shortdesc>
    Scales the current Vector3D object by a scalar, a magnitude.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier (scalar) used to scale a Vector3D object.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Scales the current Vector3D object by a scalar, a magnitude. The Vector3D object's
    x, y, and z elements are multiplied by the scalar number  
    specified in the parameter. For example, if the vector is scaled by ten, 
    the result is a vector that is ten times longer. The scalar can also
    change the direction of the vector. Multiplying the vector by a negative
    number reverses its direction.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:subtract"><apiName>subtract</apiName><shortdesc>
    Subtracts the value of the x, y, and z elements of the current Vector3D object 
    from the values of the x, y, and z elements of another Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new Vector3D object that is the difference between the current Vector3D 
    and the specified Vector3D object.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The Vector3D object to be subtracted from the current Vector3D object.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Subtracts the current Vector3D from another Vector3D object in order 
    to create a new Vector3D object. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Subtracts the value of the x, y, and z elements of the current Vector3D object 
    from the values of the x, y, and z elements of another Vector3D object. 
    The <codeph>subtract()</codeph> method does not change the current Vector3D object. Instead, 
    this method returns a new Vector3D object with the new values.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/decrementBy()"><linktext>decrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:toString"><apiName>toString</apiName><shortdesc>
     Returns a string representation of the current Vector3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A string containing the values of the <codeph>x</codeph>, <codeph>y</codeph>, and 
     <codeph>z</codeph> properties.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Returns a string representation of the current Vector3D object. The string  
     contains the values of the <codeph>x</codeph>, <codeph>y</codeph>, and <codeph>z</codeph> properties.
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Vector3D:X_AXIS"><apiName>X_AXIS</apiName><shortdesc>
    The x axis defined as a Vector3D object with coordinates (1,0,0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    The x axis defined as a Vector3D object with coordinates (1,0,0).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Y_AXIS"><apiName>Y_AXIS</apiName><shortdesc>
    The y axis defined as a Vector3D object with coordinates (0,1,0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    The y axis defined as a Vector3D object with coordinates (0,1,0).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Z_AXIS"><apiName>Z_AXIS</apiName><shortdesc>
    The z axis defined as a Vector3D object with coordinates (0,0,1).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    The z axis defined as a Vector3D object with coordinates (0,0,1).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:w"><apiName>w</apiName><shortdesc>
     The fourth element of a Vector3D object (in addition to the x, y, 
     and z properties) can hold 
     data such as the angle of rotation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The fourth element of a Vector3D object (in addition to the <codeph>x</codeph>, <codeph>y</codeph>, 
     and <codeph>z</codeph> properties) can hold 
     data such as the angle of rotation. The default value is 0.
     
     <p>Quaternion notation employs an angle as the fourth element in its calculation of
     three-dimensional rotation. The <codeph>w</codeph> property can be used to define the angle of rotation 
     about the Vector3D object. The combination of the rotation angle and the coordinates (x,y,z) 
     determines the display object's orientation. </p>
     <p>In addition, the <codeph>w</codeph> property can be used as a perspective 
     warp factor for a projected three-dimensional position or as a projection transform value in 
     representing a three-dimensional coordinate projected into the two-dimensional space. For example, 
     you can create a projection matrix using the <codeph>Matrix3D.rawData</codeph> property, that, when 
     applied to a Vector3D object, produces a transform value in the Vector3D object's fourth element (the 
     <codeph>w</codeph> property). Dividing the Vector3D object's other elements by the transform value 
     then produces a projected Vector3D object. You can use the <codeph>Vector3D.project()</codeph> method 
     to divide the first three elements of a Vector3D object by its fourth element.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/project()"><linktext>project()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:x"><apiName>x</apiName><shortdesc>
     The first element of a Vector3D object, such as
     the x coordinate of a point in the three-dimensional space.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The first element of a Vector3D object, such as
     the x coordinate of a point in the three-dimensional space. The default value is 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:y"><apiName>y</apiName><shortdesc>
     The second element of a Vector3D object, such as
     the y coordinate of a point in the three-dimensional space.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The second element of a Vector3D object, such as
     the y coordinate of a point in the three-dimensional space. The default value is 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:z"><apiName>z</apiName><shortdesc>
     The third element of a Vector3D object, such as
     the z coordinate of a point in three-dimensional space.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The third element of a Vector3D object, such as
     the z coordinate of a point in three-dimensional space. The default value is 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:length:get"><apiName>length</apiName><shortdesc>
    The length, magnitude, of the current Vector3D object from the origin (0,0,0) to 
    the object's x, y, and z coordinates.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The length of the current Vector3D object. 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    The length, magnitude, of the current Vector3D object from the origin (0,0,0) to 
    the object's x, y, and z coordinates. The <codeph>w</codeph>
    property is ignored. A unit vector has a length or magnitude of one.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/lengthSquared"><linktext>lengthSquared</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:lengthSquared:get"><apiName>lengthSquared</apiName><shortdesc>
    The square of the length of the current Vector3D object, calculated using the x, 
    y, and z properties.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The square of the length of the current Vector3D object. 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    The square of the length of the current Vector3D object, calculated using the <codeph>x</codeph>, 
    <codeph>y</codeph>, and <codeph>z</codeph> properties. The <codeph>w</codeph> property is ignored. 
    Use the <codeph>lengthSquared()</codeph> method whenever possible instead of the slower 
    <codeph>Math.sqrt()</codeph> method call of the <codeph>Vector3D.length()</codeph> method.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/length"><linktext>length</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
 The Matrix3D class represents a transformation matrix that determines the position and orientation of
 a three-dimensional (3D) display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><internal>Removed the following since it was very unclear. It could be used for a future example however:
 <p>To support a camera viewpoint and motion, create a camera class that keeps a Matrix3D object for 
 handling the movement of the display objects relative to the camera. In the camera space, the display objects 
 move in the opposite direction of the camera movement. For example, when the camera moves closer, the objects 
 become bigger. In other words, if the camera moves down the world z axis, the objects moves up 
 the z axis. One way to produce this effect is by setting the Matrix3D object of the camera class 
 to the inverse of the display objects' transformation. If the display objects are children of the <code>root</code> 
 display object, the Matrix3D object of the camera class can be set to the inverse of the <code>root</code> 
 display object. Another option is to have the display objects as children of a camera object.</p>
 
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Matrix3D class represents a transformation matrix that determines the position and orientation of
 a three-dimensional (3D) display object. The matrix can perform transformation functions including 
 translation (repositioning along the x, y, and z axes), rotation, and scaling (resizing). 
 The Matrix3D class can also perform perspective projection, which maps points from the 3D coordinate space
 to a two-dimensional (2D) view. 
 
 <p>A single matrix can combine multiple transformations and apply them at once to a 3D display object. 
 For example, a matrix can be applied to 3D coordinates to perform a rotation followed by a translation. </p> 
 
 <p>When you explicitly set the <codeph>z</codeph> property or any of the rotation or scaling
 properties of a display object, a corresponding Matrix3D object is automatically created.</p>
 
 <p>You can access a 3D display object's Matrix3D object through the <codeph>transform.matrix3d</codeph> 
 property. 2D objects do not have a Matrix3D object. </p>
 
 <p>The value of the <codeph>z</codeph> property of a 2D object is zero and the value of its 
 <codeph>matrix3D</codeph> property is <codeph>null</codeph>.</p> 
 
 <p><b>Note:</b> If the same Matrix3D object is assigned to two different display objects,
 a runtime error is thrown.</p>
 
 <p>The Matrix3D class uses a 4x4 square matrix: a table of four rows and columns of numbers that hold 
 the data for the transformation. The first three rows of the matrix hold data for each 3D 
 axis (x,y,z). The translation information is in the last column. The orientation 
 and scaling data are in the first three columns. The scaling factors are the diagonal numbers in 
 the first three columns. Here is a representation of Matrix3D elements:</p>  
 
 <p><adobeimage alt="Matrix3D elements" href="../../images/Matrix3Delements.jpg"/></p>
 
 <p>You don't need to understand matrix mathematics to use the Matrix3D class. 
 It offers specific methods that simplify the task of transformation and projection, such as the 
 <codeph>appendTranslation()</codeph>, <codeph>appendRotation()</codeph>, or <codeph>interpolateTo()</codeph> methods. 
 You also can use the <codeph>decompose()</codeph> and <codeph>recompose()</codeph> methods or the <codeph>rawData</codeph>
 property to access the underlying matrix elements.</p>
 
 <p>Display objects cache their axis rotation properties to have separate rotation for each axis
 and to manage the different combinations of rotations. When a method of a Matrix3D object is called 
 to transform a display object, the rotation cache of the object is invalidated.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links><apiConstructor id="flash.geom:Matrix3D:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
    Creates a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>v</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>A Vector of 16 Numbers, where each four elements can be a row or a column
    of a 4x4 matrix.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Creates a Matrix3D object. Matrix3D objects can be initialized with a Vector of 16 Numbers,
    where every four elements can be a row or a column. Once the Matrix3D object is created,
    you can access its matrix elements with the <codeph>rawData</codeph> property. 
    
    <p>If no parameter is defined, the constructor produces an identity or unit Matrix3D object. 
    In matrix notation, an identity matrix has a value of one for all elements on the main diagonal 
    position and a value of zero for all other elements. The value of the <codeph>rawData</codeph> property
    of an identity matrix is: <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph>. The position or translation 
    value of the identity matrix is <codeph>Vector3D(0,0,0)</codeph>, the rotation setting is 
    <codeph>Vector3D(0,0,0)</codeph>, and the scale value is <codeph>Vector3D(1,1,1)</codeph>.</p> 
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix3D/identity()"><linktext>identity()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Matrix3D:append"><apiName>append</apiName><shortdesc>
    Appends the matrix by multiplying another Matrix3D object by the current Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>A left-hand-side matrix that is multiplied by the current Matrix3D object.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Appends the matrix by multiplying another Matrix3D object by the current Matrix3D object.
    The result combines both matrix transformations. You can multiply a Matrix3D object
    by many matrixes. The final Matrix3D object contains the result of all the
    transformations.
    
    <p>Matrix multiplication is different from matrix addition. Matrix multiplication is not commutative. 
    In other words, A times B is not equal to B times A. With the <codeph>append()</codeph> method, 
    the multiplication happens from the left side, meaning the <codeph>lhs</codeph> Matrix3D object is 
    on the left side of the multiplication operator.</p>
    
    <codeph>thisMatrix = lhs ~~ thisMatrix;</codeph>
      
    <p>The first time the <codeph>append()</codeph> method is called, it makes a modification relative 
    to the parent space. Subsequent calls are relative to the frame of reference of the appended 
    Matrix3D object.</p>
    
    <p>The <codeph>append()</codeph> method replaces the current matrix with the appended matrix. 
    If you want to append two matrixes without altering the current matrix, copy the 
    current matrix by using the <codeph>clone()</codeph> method and then apply the <codeph>append()</codeph> 
    method to the copy.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prepend()"><linktext>flash.geom.Matrix3D.prepend()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendRotation"><apiName>appendRotation</apiName><shortdesc>
    Appends an incremental rotation to a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The degree of the rotation.
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The axis or direction of rotation. The usual axes are the <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), 
    <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>), and <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>A point that determines the center of an object's rotation. The default pivot point
    for an object is its registration point.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Appends an incremental rotation to a Matrix3D object. When the Matrix3D object is applied
    to a display object, the matrix performs the rotation after other transformations in the Matrix3D 
    object. 
    
    <p>The display object's rotation is defined by an axis, an incremental degree 
    of rotation around the axis, and an optional pivot point for the center of the object's rotation. 
    The axis can be any general direction. The common axes are the <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), 
    <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>), and <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    In aviation terminology, the rotation about the y axis is called yaw. The rotation about the x axis is 
    called pitch. The rotation about the z axis is called roll.</p> 
    
    <p>The order of transformation matters. A rotation followed by a translation transformation 
    produces a different effect than a translation followed by a rotation transformation.</p>
    
    <p>The rotation effect is not absolute. It is relative to the current position and orientation. 
    To make an absolute change to the transformation matrix, use the <codeph>recompose()</codeph> method. 
    The <codeph>appendRotation()</codeph> method is also different from the axis rotation property of
    the display object, such as <codeph>rotationX</codeph> property. The rotation property is always
    performed before any translation, whereas the <codeph>appendRotation()</codeph> method is performed
    relative to what is already in the matrix. To make sure that you get a similar effect as the display
    object's axis rotation property, use the <codeph>prependRotation()</codeph> method, which performs
    the rotation before other transformations in the matrix.</p>
    
    <p>When the <codeph>appendRotation()</codeph> method's transformation is applied to a Matrix3D object 
    of a display object, the cached rotation property values of the display object are invalidated.</p> 
    
    <p>One way to have a display object rotate around a specific point relative to its location is 
    to set the translation of the object to the specified point, rotate the object using the <codeph>appendRotation()</codeph> 
    method, and translate the object back to the original position. In the following example, the
    <codeph>myObject</codeph> 3D display object makes a y-axis rotation around 
    the coordinate (10,10,0).</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.appendTranslation(10,10,0);
    myObject.transform.matrix3D.appendRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.appendTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependRotation()"><linktext>prependRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendScale"><apiName>appendScale</apiName><shortdesc>
    Appends an incremental scale change along the x, y, and z axes 
    to a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the x axis.
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the y axis.
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the z axis.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Appends an incremental scale change along the x, y, and z axes 
    to a Matrix3D object. When the Matrix3D object is applied to a display object, the matrix performs 
    the scale changes after other transformations in the Matrix3D object. The default scale 
    factor is (1.0, 1.0, 1.0).
    
    <p>The scale is defined as a set of three incremental changes along the three axes (x,y,z).
    You can multiply each axis with a different number. When the scale changes are applied to
    a display object, the object's size increases or decreases. For example, setting
    the x, y, and z axes to two doubles the size of the object, while
    setting the axes to <codeph>0.5</codeph> halves the size. To make sure that
    the scale transformation only affects a specific axis, set the other parameters to one. 
    A parameter of one means no scale change along the specific axis.</p>
    
    <p>The <codeph>appendScale()</codeph> method can be used for resizing as well as 
    for managing distortions, such as stretch or contract of a display object, or for zooming in 
    and out on a location. Scale transformations are automatically performed during a display 
    object's rotation and translation.</p>
    
    <p>The order of transformation matters. A resizing followed by a translation transformation 
    produces a different effect than a translation followed by a resizing transformation.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependScale()"><linktext>prependScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendTranslation"><apiName>appendTranslation</apiName><shortdesc>
    Appends an incremental translation, a repositioning along the x, y, and z axes, 
    to a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>An incremental translation along the x axis.
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>An incremental translation along the y axis.
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>An incremental translation along the z axis.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Appends an incremental translation, a repositioning along the x, y, and z axes, 
    to a Matrix3D object. When the Matrix3D object is applied to a display object, the matrix performs 
    the translation changes after other transformations in the Matrix3D object.
    
    <p>The translation is defined as a set of three incremental changes along the three axes (x,y,z). 
    When the transformation is applied to a display object, the display object moves from it current 
    location along the x, y, and z axes as specified by the parameters.
    To make sure that the translation only affects a specific axis, set the other parameters to zero. 
    A zero parameter means no change along the specific axis.</p> 
    
    <p>The translation changes are not absolute. They are relative to the current 
    position and orientation of the matrix. To make an absolute change to the transformation matrix, 
    use the <codeph>recompose()</codeph> method. The order of transformation also matters. A translation 
    followed by a rotation transformation produces a different effect than a rotation followed 
    by a translation.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependTranslation()"><linktext>prependTranslation()</linktext></link><link href="flash.geom.xml#Matrix3D/position"><linktext>position</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:clone"><apiName>clone</apiName><shortdesc>
    Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new Matrix3D object that is an exact copy of the current Matrix3D object.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.      
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:decompose"><apiName>decompose</apiName><shortdesc>
    Returns the transformation matrix's translation, rotation, and scale settings as 
    a Vector of three Vector3D objects.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Vector of three Vector3D objects, each holding the translation, rotation, and scale
    settings, respectively. 
    
    </apiDesc><apiType value="Vector$flash.geom:Vector3D"/></apiReturn><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>An optional parameter that determines the orientation style 
    used for the matrix transformation. The three types of orientation style are 
    <codeph>eulerAngles</codeph> (constant <codeph>EULER_ANGLES</codeph>), <codeph>axisAngle</codeph> 
    (constant <codeph>AXIS_ANGLE</codeph>), and <codeph>quaternion</codeph> (constant <codeph>QUATERNION</codeph>). 
    For additional information on the different orientation style, see the <codeph>geom.Orientation3D</codeph> class.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Returns the transformation matrix's translation, rotation, and scale settings as 
    a Vector of three Vector3D objects. The first Vector3D object holds the translation 
    elements. The second Vector3D object holds the rotation elements. The third Vector3D object
    holds the scale elements. 
    
    <p>Some Matrix3D methods, such as the <codeph>interpolateTo()</codeph> method, automatically 
    decompose and recompose the matrix to perform their transformation.</p> 
       
    <p>To modify the matrix's transformation with an absolute parent frame of reference, 
    retrieve the settings with the <codeph>decompose()</codeph> method and make the appropriate changes. 
    You can then set the Matrix3D object to the modified transformation using the <codeph>recompose()</codeph> 
    method.</p>
    
    <p>The <codeph>decompose()</codeph> method's parameter specifies the orientation style that 
    is meant to be used for the transformation. The default orientation is <codeph>eulerAngles</codeph>,
    which defines the orientation with three separate angles of rotation for each axis. 
    The rotations occur consecutively and do not change the axis of each other. The 
    display object's axis rotation properties perform Euler Angles orientation style transformation. 
    The other orientation style options are <codeph>axisAngle</codeph> and <codeph>quaternion</codeph>. 
    The Axis Angle orientation uses a combination of an axis and an angle to determine the orientation. 
    The axis around which the object is rotated is a unit vector that represents a direction. 
    The angle represents the magnitude of the rotation about the vector. The direction also 
    determines where a display object is facing and the angle determines which way is up. 
    The <codeph>appendRotation()</codeph> and <codeph>prependRotation()</codeph> methods use the Axis Angle orientation.
    The quaternion orientation uses complex numbers and the fourth element of a vector. 
    The three axes of rotation (x,y,z) and an angle of rotation (w) represent the orientation. 
    The <codeph>interpolate()</codeph> method uses quaternion.</p> 
    
    </apiDesc><example conref="examples\Matrix3DdecomposeExample.as"> This example uses the <codeph>decompose()</codeph> 
 and <codeph>recompose()</codeph> methods to have an ellipse stretch horizontally
 while moving toward the vanishing point. The first Vector3D object returned 
 by the <codeph>decompose()</codeph> method holds the translation coordinates. The
 third Vector3D object holds the scale settings. The Vector3D object's 
 <codeph>incrementBy()</codeph> method increments the matrix's absolute translation 
 and scale settings.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.Event;
    
    public class Matrix3DdecomposeExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DdecomposeExample():void {
            
            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight - 40);
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 50, 40);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function enterFrameHandler(e:Event):void {  

            var v3:Vector.&lt;Vector3D&gt; = new Vector.&lt;Vector3D&gt;(3);
            v3 = ellipse.transform.matrix3D.decompose();
            v3[0].incrementBy(new Vector3D(0,0,1));
            v3[2].incrementBy(new Vector3D(0.01,0,0));
            ellipse.transform.matrix3D.recompose(v3);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>recompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:deltaTransformVector"><apiName>deltaTransformVector</apiName><shortdesc>
    Uses the transformation matrix without its translation elements
    to transform a Vector3D object from one space coordinate to another.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Vector3D object with the transformed coordinates.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>A Vector3D object holding the coordinates that are going to be transformed.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Uses the transformation matrix without its translation elements
    to transform a Vector3D object from one space coordinate to another. 
    The returned Vector3D object holds the new coordinates after the rotation
    and scaling transformations have been applied. If the <codeph>deltaTransformVector()</codeph> 
    method applies a matrix that only contains a translation transformation, 
    the returned Vector3D is the same as the original Vector3D object.
    
    <p>You can use the <codeph>deltaTransformVector()</codeph> method to have a 
    display object in one coordinate space respond to the rotation transformation 
    of a second display object. The object does not copy the rotation; 
    it only changes its position to reflect the changes in the rotation.
    For example, to use the <codeph>display.Graphics</codeph> API for drawing a rotating 
    3D display object, you must map the object's rotating coordinates
    to a 2D point. First, retrieve the object's 3D 
    coordinates after each rotation, using the <codeph>deltaTransformVector()</codeph> method. 
    Next, apply the display object's <codeph>local3DToGlobal()</codeph> method to translate the
    3D coordinates to 2D points. You can then use 
    the 2D points to draw the rotating 3D object.</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:identity"><apiName>identity</apiName><shortdesc>
    Converts the current matrix to an identity or unit matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Converts the current matrix to an identity or unit matrix. An identity matrix has a value 
    of one for the elements on the main diagonal and a value of zero for all 
    other elements. The result is a matrix where the <codeph>rawData</codeph> value is
    <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph> and the rotation setting is set to 
    <codeph>Vector3D(0,0,0)</codeph>, the position or translation setting is set to 
    <codeph>Vector3D(0,0,0)</codeph>, and the scale is set to <codeph>Vector3D(1,1,1)</codeph>.
    Here is a representation of an identity matrix.
    
    <p><adobeimage alt="Identity Matrix" href="../../images/identityMatrix.jpg"/></p>
    
    <p>An object transformed by applying an identity matrix performs no transformation. 
    In other words, if a matrix is multiplied by an identity matrix, the result is 
    a matrix that is the same as (identical to) the original matrix.</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolate"><apiName>interpolate</apiName><shortdesc>
    Simplifies the interpolation from one frame of reference to another by interpolating a display object  
    a percent point closer to a target display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A Matrix3D object with elements that place the values of the matrix between the original matrix 
    and the target matrix. When the returned matrix is applied to the <codeph>this</codeph> display object, the 
    object moves the specified percent closer to the target object.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>thisMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>The Matrix3D object that is to be interpolated.
    </apiDesc></apiParam><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>The target Matrix3D object.
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A value between <codeph>0</codeph> and <codeph>1</codeph> that determines the percent 
    the <codeph>thisMat</codeph> Matrix3D object is interpolated toward the target Matrix3D object.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Interpolates a display object a percent point closer to a target display object.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Simplifies the interpolation from one frame of reference to another by interpolating a display object  
    a percent point closer to a target display object. The result is a new Matrix3D object
    where all the elements for the translation, rotation, and scale are interpolated to values
    between the current display object and the target display object.
    
    <p>The <codeph>interpolate()</codeph> method avoids some of the unwanted results that can occur when
    using methods such as the display object's axis rotation properties. The <codeph>interpolate()</codeph> 
    method invalidates the cached value of the rotation property of the display
    object and converts the orientation elements of the display object's matrix to a quaternion 
    before interpolation. This method guarantees the shortest, most efficient path for the rotation. 
    It also produces a smooth, gimbal-lock-free rotation. A gimbal lock can occur when using Euler Angles, 
    where each axis is handled independently. During the rotation around two or more axes, the axes can 
    become aligned, leading to unexpected results. Quaternion rotation avoids the gimbal lock.</p> 
    
    <p>Consecutive calls to the <codeph>interpolate()</codeph> method can produce the effect of a display 
    object starting quickly and then slowly approaching another display object. For example, if you set 
    the <codeph>thisMat</codeph> parameter to the returned Matrix3D object, the <codeph>toMat</codeph> parameter 
    to the target display object's
    associated Matrix3D object, and the <codeph>percent</codeph> parameter to <codeph>0.1</codeph>, 
    the display object moves ten percent toward the target object. On subsequent calls or in subsequent 
    frames, the object moves ten percent of the remaining 90 percent, then ten percent of the remaining
    80 percent, until it reaches the target.</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>interpolateTo()</linktext></link><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolateTo"><apiName>interpolateTo</apiName><shortdesc>
    Interpolates the display object's matrix a percent closer to a target's matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>The target Matrix3D object.  
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A value between <codeph>0</codeph> and <codeph>1</codeph> that determines the location of the display object 
    relative to the target. The closer the value is to <codeph>1.0</codeph>, the closer the display object 
    is to its current position. The closer the value is to <codeph>0</codeph>, the closer the display object is
    to the target.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Interpolates the display object's matrix a percent closer to a target's matrix. All the elements for 
    translation, rotation, and scale of the display object are interpolated to values  
    between the current and target display object's matrix. 
    
    <p>The <codeph>interpolateTo()</codeph> method avoids the unwanted results that can occur when
    using methods such as the display object's axis rotation properties. The <codeph>interpolateTo()</codeph> 
    method invalidates the cached value of the rotation property of the display
    object and converts the orientation elements of the display object's matrix to a quaternion 
    before interpolation. This method guarantees the shortest, most efficient path for the rotation. 
    It also produces a smooth, gimbal-lock-free rotation. A gimbal lock can occur when using Euler Angles, 
    where each axis is handled independently. During the rotation around two or more axes, the axes can 
    become aligned, leading to unexpected results. Quaternion rotation avoids the gimbal lock.</p> 
    
    <p>Consecutive calls to the <codeph>interpolateTo()</codeph> method can produce the effect of a display 
    object starting quickly and then slowly approaching another display object. For example, if the percent 
    parameter is set to <codeph>0.1</codeph>, the display object moves ten percent toward the target object
    specified by the <codeph>toMat</codeph> parameter. On subsequent calls or in subsequent 
    frames, the object moves ten percent of the remaining 90 percent, then ten percent of the
    remaining 80 percent, until it reaches the target.</p>  
    
    </apiDesc><example conref="examples\InterpolateToExample.as"> In this example, <codeph>ellipse2</codeph>, a three-dimensional display object, goes 
 toward <codeph>ellipse1</codeph>, another three-dimensional display object. 
 <codeph>ellipse2</codeph> follows <codeph>ellipse1</codeph> around trying to catch it. 
 If <codeph>ellipse1</codeph> does not rotate around its y axis, <codeph>ellipse2</codeph> 
 will reach and land on top of <codeph>ellipse1</codeph>.  The two ellipses are 
 drawn in the same way but are placed in different three-dimensional world-space locations. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class InterpolateToExample extends MovieClip {
        private var ellipse1:Shape = new Shape();
        private var ellipse2:Shape = new Shape();

        public function InterpolateToExample():void {

            ellipse1 = myEllipses(250, 100, 500, 0xFF0000);
            addChild(ellipse1);
            
            ellipse2 = myEllipses(-30, 120, 1, 0x00FF00);
            addChild(ellipse2);

            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function myEllipses(x:Number, y:Number, z:Number, c:Number):Shape {
            var s:Shape = new Shape();                            
            s.x = x;
            s.y = y;
            s.z = z;
            s.graphics.beginFill(c);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(100, 50, 100, 80);
            s.graphics.endFill();
            return s;
        }

        private function enterFrameHandler(e:Event) {
            ellipse1.rotationY += 1;

            ellipse2.transform.matrix3D.interpolateTo(ellipse1.transform.matrix3D, 0.1);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:invert"><apiName>invert</apiName><shortdesc>
    Inverts the current matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Returns <codeph>true</codeph> if the matrix was successfully inverted. 
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Inverts the current matrix. An inverted matrix is the same size as the original 
    but performs the opposite transformation of the original matrix. For example,
    if the original matrix has an object rotate around the x axis in one direction,
    the inverse of the matrix will have the object rotate around the axis in 
    the opposite direction. Applying an inverted matrix to an object undoes the 
    transformation performed by the original matrix. If a matrix is multiplied by its 
    inverse matrix, the result is an identity matrix. 
    
    <p>An inverse of a matrix can be used to divide one matrix by another. The way to divide 
    matrix A by matrix B is to multiply matrix A by the inverse of matrix B. The inverse matrix can also be used
    with a camera space. When the camera moves in the world space, the object in the world needs to 
    move in the opposite direction to transform from the world view to the camera or
    view space. For example, if the camera moves closer, the objects becomes bigger. 
    In other words, if the camera moves down the world z axis, the object moves up 
    world z axis.</p> 
    
    <p>The <codeph>invert()</codeph> method replaces the current matrix with an inverted matrix. 
    If you want to invert a matrix without altering the current matrix, first copy the 
    current matrix by using the <codeph>clone()</codeph> method and then apply the <codeph>invert()</codeph> 
    method to the copy.</p>
    
    <p>The Matrix3D object must be invertible.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/determinant"><linktext>determinant</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:pointAt"><apiName>pointAt</apiName><shortdesc>
    Rotates the display object so that it faces a specified position.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The world-relative position of the target object. World-relative defines 
    the object's transformation relative to the world space and coordinates, where all objects are positioned.
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>The object-relative vector that defines where the display object is pointing. 
    Object-relative defines the object's transformation relative to the object space, the object's own 
    frame of reference and coordinate system. Default value is the <i>-z</i> axis (0,0,-1).
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>The object-relative vector that defines "up" for the display object. If the object
    is drawn looking down from above, the <i>+z</i> axis is its "up" vector.
    Object-relative defines the object's transformation relative to the object space, the object's own 
    frame of reference and coordinate system. Default value is the <i>-y</i>-axis (0,-1,0).
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Rotates the display object so that it faces a specified position. This method allows for an 
    in-place modification to the orientation. The forward direction vector of the display object 
    (the <codeph>at</codeph> Vector3D object) points at the specified world-relative position. 
    The display object's up direction     is specified with the <codeph>up</codeph>
    Vector3D object. 
    
    <p>The <codeph>pointAt()</codeph> method invalidates the cached rotation property 
    value of the display object. The method decomposes the display object's matrix and modifies 
    the rotation elements to have the object turn to the specified position. It 
    then recomposes (updates) the display object's matrix, which performs the transformation. 
    If the object is pointing at a moving target, such as a moving object's position, 
    then with each subsequent call, the method has the object rotate toward the moving target.</p>
    
    </apiDesc><example conref="examples\PointAtExample.as"> In this example, a triangle points and follows the path of the ellipse's 
 movement. The ellipse and triangle are set to different locations. 
 The ellipse then moves up toward the corner of the stage. The triangle 
 follows the ellipse's translation changes. You can change the triangle's
 shape and the "at" and "up" parameters of the <codeph>pointAt()</codeph> 
 to see their impacts on the triangle's movement.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class PointAtExample extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var triangle:Shape = new Shape();

        public function PointAtExample():void {
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(30, 40, 50, 40);
            ellipse.graphics.endFill();
            ellipse.x = 100;
            ellipse.y = 150;
            ellipse.z = 1;

            triangle.graphics.beginFill(0x0000FF);
            triangle.graphics.moveTo(0, 0);
            triangle.graphics.lineTo(40, 40);
            triangle.graphics.lineTo(80, 0);
            triangle.graphics.lineTo(0, 0);
            triangle.graphics.endFill();
            triangle.x = 200;
            triangle.y = 50;
            triangle.z = 1;

            addChild(ellipse);
            addChild(triangle);

            ellipse.addEventListener(Event.ENTER_FRAME, ellipseEnterFrameHandler);
            triangle.addEventListener(Event.ENTER_FRAME, triangleEnterFrameHandler);
        }

        private function ellipseEnterFrameHandler(e:Event) {
            if(e.target.y &gt; 0) {
                e.target.y -= 1;
                e.target.x -= 1;
            }
        }
        
        private function triangleEnterFrameHandler(e:Event) {
            e.target.transform.matrix3D.pointAt(ellipse.transform.matrix3D.position,
                                                Vector3D.X_AXIS, Vector3D.Y_AXIS);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prepend"><apiName>prepend</apiName><shortdesc>
    Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>A right-hand-side of the matrix by which the current Matrix3D is multiplied.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D object.
    The result combines both matrix transformations. 
    
    <p>Matrix multiplication is different from matrix addition. Matrix multiplication is not commutative. 
    In other words, A times B is not equal to B times A. With the <codeph>prepend()</codeph> method, 
    the multiplication happens from the right side, meaning the <codeph>rhs</codeph> Matrix3D object is 
    on the right side of the multiplication operator.</p>
    
    <codeph>thisMatrix = thisMatrix ~~ rhs</codeph>
      
    <p>The modifications made by <codeph>prepend()</codeph> method are object-space-relative. In other words, 
    they are always relative to the object's initial frame of reference.</p>
    
    <p>The <codeph>prepend()</codeph> method replaces the current matrix with the prepended matrix. 
    If you want to prepend two matrixes without altering the current matrix, first copy the 
    current matrix by using the <codeph>clone()</codeph> method and then apply the <codeph>prepend()</codeph> 
    method to the copy.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/append()"><linktext>append()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependRotation"><apiName>prependRotation</apiName><shortdesc>
    Prepends an incremental rotation to a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The degree of rotation.
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>The axis or direction of rotation. The usual axes are the <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), 
    <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>), and <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>A point that determines the center of rotation. The default pivot point
    for an object is its registration point.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Prepends an incremental rotation to a Matrix3D object. When the Matrix3D object is applied
    to a display object, the matrix performs the rotation before other transformations in the Matrix3D 
    object. 
    
    <p>The display object's rotation is defined by an axis, an incremental degree 
    of rotation around the axis, and an optional pivot point for the center of the object's rotation. 
    The axis can be any general direction. The common axes are the <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), 
    <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>), and <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    In aviation terminology, the rotation about the y axis is called yaw. 
    The rotation about the x axis is called pitch. 
    The rotation about the z axis is called roll.</p> 
    
    <p>The order of transformation matters. A rotation followed by a translation transformation 
    produces a different effect than a translation followed by a rotation.</p>
    
    <p>The rotation effect is not absolute. The effect is object-relative, relative to the frame 
    of reference of the original position and orientation. To make an absolute change to the transformation,
    use the <codeph>recompose()</codeph> method.</p>
    
    <p>When the <codeph>prependRotation()</codeph> method's transformation is applied to a Matrix3D object 
    of a display object, the cached rotation property values of the display object are invalidated.</p> 
    
    <p>One way to have a display object rotate around a specific point relative to its location is 
    to set the translation of the object to the specified point, rotate the object using 
    the <codeph>prependRotation()</codeph> method, and translate the object back to the original position. 
    In the following example, the <codeph>myObject</codeph> 3D display object makes a y-axis rotation around 
    the coordinate (10,10,0).</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.prependTranslation(10,10,0);
    myObject.transform.matrix3D.prependRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.prependTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc><example conref="examples\Matrix3DprependRotationExample.as"> In this example, the user can move a mouse to rotate an ellipse
 around its <i>x</i> and <i>y</i> axes. The ellipse is drawn
 with its registration point in its center. The ellipse rotates
 around its <i>y</i> axis using the mouse's <i>x</i> coordinate.
 It rotates around its <i>x</i> axis using the mouse's <i>y</i> coordinate.
 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.MouseEvent;
    
    public class Matrix3DprependRotationExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DprependRotationExample():void {

            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(-50, -40, 100, 80);
            ellipse.graphics.endFill();

            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight / 2);
            ellipse.z = 1;
            
            addChild(ellipse);

            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function mouseMoveHandler(e:MouseEvent):void {
            var y:int;
            var x:int;
            
            if(e.localX &gt; ellipse.x) {
                y = (Math.round(e.localX) / 100);   
            } else {
                y = -(Math.round(e.localX) / 10);   
            }
            
            if(e.localY &gt; ellipse.y) {
                x = (Math.round(e.localY) / 100);
            } else {
                x = -(Math.round(e.localY) / 100);
            }
            
            ellipse.transform.matrix3D.prependRotation(y, Vector3D.Y_AXIS);
            ellipse.transform.matrix3D.prependRotation(x, Vector3D.X_AXIS);
        }
        
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendRotation()"><linktext>appendRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependScale"><apiName>prependScale</apiName><shortdesc>
    Prepends an incremental scale change along the x, y, and z axes to a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the x axis.
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the y axis.
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the z axis.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Prepends an incremental scale change along the x, y, and z axes to a Matrix3D object.
    When the Matrix3D object is applied to a display object, the matrix performs 
    the scale changes before other transformations in the Matrix3D object. The changes are 
    object-relative, relative to the frame of reference of the original position and orientation. 
    The default scale factor is (1.0, 1.0, 1.0).
    
    <p>The scale is defined as a set of three incremental changes along the three axes (x,y,z).
    You can multiply each axis with a different number. When the scale changes are applied to
    a display object, the object's size increases or decreases. For example, setting
    the x, y, and z axes to two doubles the size of the object, while
    setting the axes to <codeph>0.5</codeph> halves the size. To make sure that
    the scale transformation only affects a specific axis, set the other parameters to one. 
    A parameter of one means no scale change along the specific axis.</p>
    
    <p>The <codeph>prependScale()</codeph> method can be used for resizing as well as 
    for managing distortions, such as stretch or contract of a display object. It can also be
    used for zooming in and out on a location. Scale transformations are automatically 
    performed during a display object's rotation and translation.</p>
    
    <p>The order of transformation matters. A resizing followed by a translation transformation 
    produces a different effect than a translation followed by a resizing transformation.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendScale()"><linktext>appendScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependTranslation"><apiName>prependTranslation</apiName><shortdesc>
    Prepends an incremental translation, a repositioning along the x, y, 
    and z axes, to a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>An incremental translation along the x axis.
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>An incremental translation along the y axis.
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>An incremental translation along the z axis.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Prepends an incremental translation, a repositioning along the x, y, 
    and z axes, to a Matrix3D object. When the Matrix3D object is applied to a 
    display object, the matrix performs the translation changes before other transformations 
    in the Matrix3D object. 
       
    <p>Translation specifies the distance the display object moves from its current location along 
    the x, y, and z axes. The <codeph>prependTranslation()</codeph> method 
    sets the translation as a set of three incremental changes along the three axes (x,y,z). 
    To have a translation change only a specific axis, set the other parameters to zero. 
    A zero parameter means no change along the specific axis.</p>
    
    <p>The translation changes are not absolute. The effect is object-relative, relative to the frame 
    of reference of the original position and orientation. To make an absolute change to the transformation 
    matrix, use the <codeph>recompose()</codeph> method. The order of transformation also matters. A translation 
    followed by a rotation transformation produces a different effect than a rotation followed by a translation 
    transformation. When <codeph>prependTranslation()</codeph> is used, the display object continues to move 
    in the direction it is facing, regardless of the other transformations. For example, if a display object 
    was facing toward a positive x axis, it continues to move in the direction specified 
    by the <codeph>prependTranslation()</codeph> method, regardless of how the object has been rotated. To make
    translation changes occur after other transformations, use the <codeph>appendTranslation()</codeph> method.</p> 
    
    
    </apiDesc><example conref="examples\Matrix3DprependTranslationExample.as"> In this example, the user can push an ellipse up the stage's <i>y</i> axis 
 using a mouse. When the user moves the mouse over the ellipse, the ellipse 
 jumps ten coordinates up the <i>y</i> axis. When the mouse moves off of
 the ellipse, if the ellipse has not reached the top, the ellipse again jumps 
 ten coordinates up the <i>y</i> axis. Once the ellipse reaches the top, 
 it is moved back to the bottom of the stage.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.geom.*;
    import flash.events.MouseEvent;

    public class Matrix3DprependTranslationExample extends MovieClip {
        private var ellipse:Sprite = new Sprite();

        public function Matrix3DprependTranslationExample():void {
            ellipse.x = this.stage.stageWidth / 2;
            ellipse.y = this.stage.stageHeight - 100;
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 60, 50);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
            ellipse.addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        }

        private function mouseOverHandler(e:MouseEvent):void {
            if(ellipse.y &gt; 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } 
        }
        
        private function mouseOutHandler(e:MouseEvent):void {
            if(ellipse.y &gt; 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } else {
                ellipse.transform.matrix3D.prependTranslation(0, 
                                     (this.stage.stageHeight - 100), 0);
            }   
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendTranslation()"><linktext>appendTranslation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:recompose"><apiName>recompose</apiName><shortdesc>
    Sets the transformation matrix's translation, rotation, and scale settings.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Returns <codeph>false</codeph> if any of the scale elements are zero.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>components</apiItemName><apiType value="Vector$flash.geom:Vector3D"/><apiDesc>A Vector of three Vector3D objects that replace the Matrix3D
    object's translation, rotation, and scale elements. 
    
    </apiDesc></apiParam><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>An optional parameter that determines the orientation style 
    used for the matrix transformation. The three types of orientation styles are
    <codeph>eulerAngles</codeph> (constant <codeph>EULER_ANGLES</codeph>), <codeph>axisAngle</codeph> 
    (constant <codeph>AXIS_ANGLE</codeph>), and <codeph>quaternion</codeph> (constant <codeph>QUATERNION</codeph>). 
    For additional information on the different orientation style, see the <codeph>geom.Orientation3D</codeph> class.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Sets the transformation matrix's translation, rotation, and scale settings. 
    Unlike the incremental changes made by the display object's rotation properties or 
    Matrix3D object's rotation methods, the changes made by <codeph>recompose()</codeph> method 
    are absolute changes. The <codeph>recompose()</codeph> method overwrites the matrix's transformation.
    
    <p>To modify the matrix's transformation with an absolute parent frame of reference, retrieve 
    the settings with the <codeph>decompose()</codeph> method and make the appropriate changes. You can then 
    set the Matrix3D object to the modified transformation using the <codeph>recompose()</codeph> method.</p>
    
    <p>The <codeph>recompose()</codeph> method's parameter specifies the orientation style that was used
    for the transformation. The default orientation is <codeph>eulerAngles</codeph>,
    which defines the orientation with three separate angles of rotation for each axis. 
    The rotations occur consecutively and do not change the axis of each other. The 
    display object's axis rotation properties perform Euler Angles orientation style transformation. 
    The other orientation style options are <codeph>axisAngle</codeph> and <codeph>quaternion</codeph>. 
    The Axis Angle orientation uses the combination of an axis and an angle to determine the orientation. 
    The axis around which the object is rotated is a unit vector that represents a direction. 
    The angle represents the magnitude of the rotation about the vector. The direction also 
    determines where a display object is facing and the angle determines which way is up. 
    The <codeph>appendRotation()</codeph> and <codeph>prependRotation()</codeph> methods use the Axis Angle orientation.
    The quaternion orientation uses complex numbers and the fourth element of a vector. 
    An orientation is represented by the three axes of rotation (x,y,z) and an angle of 
    rotation (w). The <codeph>interpolate()</codeph> method uses quaternion.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>decompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVector"><apiName>transformVector</apiName><shortdesc>
    Uses the transformation matrix to transform a Vector3D object from one space coordinate 
    to another.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Vector3D object with the transformed coordinates.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>A Vector3D object holding the coordinates that are going to be transformed.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Uses the transformation matrix to transform a Vector3D object from one space coordinate 
    to another. The returned Vector3D object holds the new coordinates after the transformation. 
    All the matrix transformations including translation are applied to the Vector3D object.
    
    <p>If the result of the <codeph>transformVector()</codeph> method was applied to the position 
    of a display object, only the display object's position changes. 
    The display object's rotation and scale elements remain the same.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVectors"><apiName>transformVectors</apiName><shortdesc>
    Uses the transformation matrix to transform a Vector of Numbers from one
    coordinate space to another.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vin</apiItemName><apiType value="Vector$Number"/><apiDesc>A Vector of Numbers, where every three Numbers are a 3D coordinate 
    (x,y,z) that is going to be transformed.
    </apiDesc></apiParam><apiParam><apiItemName>vout</apiItemName><apiType value="Vector$Number"/><apiDesc>A Vector of Numbers, where every three Numbers are a 3D
    transformed coordinate (x,y,z).
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Uses the transformation matrix to transform a Vector of Numbers from one
    coordinate space to another. The <codeph>tranformVectors()</codeph> method reads every
    three Numbers in the <codeph>vin</codeph> Vector object as a 3D coordinate
    (x,y,z) and places a transformed 3D coordinate in the <codeph>vout</codeph>
    Vector object. All the matrix transformations including translation are applied to the
    <codeph>vin</codeph> Vector object. You can use the <codeph>transformVectors()</codeph> method 
    to render and transform a 3D object as a mesh. A mesh is a collection of 
    vertices that defines the shape of the object.
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transpose"><apiName>transpose</apiName><shortdesc>
    Converts the current Matrix3D object to a matrix where the rows and columns 
    are swapped.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Converts the current Matrix3D object to a matrix where the rows and columns 
    are swapped. For example, if the current Matrix3D object's <codeph>rawData</codeph> contains 
    the following 16 numbers, <codeph>1,2,3,4,11,12,13,14,21,22,23,24,31,32,33,34</codeph>,
    the <codeph>transpose()</codeph> method reads every four elements as a row and turns the rows
    into columns. The result is a matrix with the <codeph>rawData</codeph> of: 
    <codeph>1,11,21,31,2,12,22,32,3,13,23,33,4,14,24,34</codeph>. 
    
    <p>The <codeph>transpose()</codeph> method replaces the current matrix with a transposed matrix. 
    If you want to transpose a matrix without altering the current matrix, first copy the 
    current matrix by using the <codeph>clone()</codeph> method and then apply the <codeph>transpose()</codeph> 
    method to the copy.</p>
    
    <p>An orthogonal matrix is a square matrix whose transpose is equal to its inverse.</p> 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix3D:determinant:get"><apiName>determinant</apiName><shortdesc>
    A Number that determines whether a matrix is invertible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
    A Number that determines whether a matrix is invertible. 
    
    <p>A Matrix3D object must be invertible. You can use the <codeph>determinant</codeph> 
    property to make sure that a Matrix3D object is invertible. If determinant is zero, 
    an inverse of the matrix does not exist. For example, if an entire row or column 
    of a matrix is zero or if two rows or columns are equal, the determinant is zero. 
    Determinant is also used to solve a series of equations.</p> 
    
    <p>Only a square matrix, like the Matrix3D class, has a determinant.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/invert()"><linktext>invert()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:position:set"><apiName>position</apiName><shortdesc>
    A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display object
    within the transformation's frame of reference.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display object
    within the transformation's frame of reference. The <codeph>position</codeph> property provides immediate 
    access to the translation vector of the display object's matrix without needing to decompose and 
    recompose the matrix. 
    
    <p>With the <codeph>position</codeph> property, you can get and set the translation elements 
    of the transformation matrix.</p>
    
    
    </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.geom.xml#position/appendTranslation()"><linktext>appendTranslation()</linktext></link><link href="" invalidHref="flash.geom.xml#position/prependTranslation()"><linktext>prependTranslation()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:rawData:get"><apiName>rawData</apiName><shortdesc>
    A Vector of 16 Numbers, where every four elements can be a row or
    a column of a 4x4 matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
    A Vector of 16 Numbers, where every four elements can be a row or
    a column of a 4x4 matrix. 
    
    <p>An exception is thrown if the <codeph>rawData</codeph> property is set to a matrix 
    that is not invertible. The Matrix3D object must be invertible. If a non-invertible matrix 
    is needed, create a subclass of the Matrix3D object.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Transform"><apiName>Transform</apiName><shortdesc>
 The Transform class provides access to color adjustment properties and two- or three-dimensional 
 transformation objects that can be applied to a display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Provides access to color as well as two and three-dimensional transformation objects 
 and matrices that can be applied to a display object.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Transform class provides access to color adjustment properties and two- or three-dimensional 
 transformation objects that can be applied to a display object. During the transformation, 
 the color or the orientation and position of a display object is adjusted (offset) from 
 the current values or coordinates to new values or coordinates. 
 The Transform class also collects data about color and two-dimensional matrix transformations
 that are applied to a display object and all of its parent objects. You can access 
 these combined transformations through the <codeph>concatenatedColorTransform</codeph> 
 and <codeph>concatenatedMatrix</codeph> properties.
 
 <p>To apply color transformations: create a ColorTransform object,
 set the color adjustments using the object's methods and properties, and then assign the 
 <codeph>colorTransformation</codeph> property of the <codeph>transform</codeph> property of the 
 display object to the new ColorTransformation object.</p>
 
 <p>To apply two-dimensional transformations: create a Matrix object,
 set the matrix's two-dimensional transformation, and then assign the <codeph>transform.matrix</codeph> 
 property of the display object to the new Matrix object.</p>
 
 <p>To apply three-dimensional transformations: start with a three-dimensional display object. 
 A three-dimensional display object has a <codeph>z</codeph> property value other than zero. 
 You do not need to create the Matrix3D object. For all three-dimensional objects, a Matrix3D object 
 is created automatically when you assign a <codeph>z</codeph> value to a display object. You can 
 access the display object's Matrix3D object through the display object's <codeph>transform</codeph> property.
 Using the methods of the Matrix3D class, you can add to or modify the existing transformation settings. Also, you can 
 create a custom Matrix3D object, set the custom Matrix3D object's transformation elements,
 and then assign the new Matrix3D object to the display object using the <codeph>transform.matrix</codeph> 
 property.</p>
 
 <p>To modify a perspective projection of the stage or root object: 
 use the <codeph>transform.matrix</codeph> property of the root display object to gain access to the
 PerspectiveProjection object. Or, apply different perspective projection 
 properties to a display object by setting the perspective projection properties of the display
 object's parent. The child display object inherits the new properties. Specifically, create a 
 PerspectiveProjection object and set its properties, then assign the PerspectiveProjection 
 object to the <codeph>perspectiveProjection</codeph> property of the parent display object's 
 <codeph>transform</codeph> property. The specified projection transformation then applies 
 to all the display object's three-dimensional children.</p>
 
 <p>Since both PerspectiveProjection and Matrix3D objects perform perspective transformations,
 do not assign both to a display object at the same time. Use the PerspectiveProjection object 
 for focal length and projection center changes. For more control over the perspective transformation,
 create a perspective projection Matrix3D object.</p>
 
 
 </apiDesc><example conref="examples\TransformExample.as"> The following example uses the TransformExample class to skew the bottom side
 of a square sprite filled with a gradient pattern. Each time the user clicks the square, the 
 application transforms the sprite by skewing it with the following steps:
 
 <ol>
  <li>The <codeph>TransformExample()</codeph> constructor creates a new sprite object <codeph>target</codeph>.</li>
 
  <li>The <codeph>TransformExample()</codeph> constructor calls the <codeph>draw()</codeph> method, 
         which draws a gradient square in the sprite.</li>
 
  <li>The <codeph>TransformExample()</codeph> constructor adds a click event listener for the sprite, 
         which is handled by the <codeph>clickHandler()</codeph> method. </li>
 
     <li>The <codeph>clickHandler()</codeph> method creates a new Matrix object, <codeph>skewMatrix</codeph>,
         which is set to apply a skew effect. Another matrix, <codeph>tempMatrix</codeph>, is assigned to the 
         current transformation matrix of the sprite, and then is combined with <codeph>skewMatrix</codeph>
         using the <codeph>concat()</codeph> method. This matrix is assigned to the  
         <codeph>transform.matrix</codeph> property of the square sprite. Each time the user clicks the square,
          the call to the <codeph>clickHandler()</codeph> modifies the shape of the square by skewing it.  </li>
  <li>Additionally, the <codeph>clickHandler()</codeph> method creates a new ColorTransform object. The
        <codeph>redOffset</codeph> property of the new ColorTransform is set to the current value of redOffset and 
         increased by 25. Likewise, the <codeph>blueOffset</codeph> property is reduced by 25. With each click,
        the colors of the sprite change. </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.Matrix;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class TransformExample extends Sprite {
        public function TransformExample() { 
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var skewMatrix:Matrix = new Matrix();
            skewMatrix.c = 0.25;
            var tempMatrix:Matrix = this.transform.matrix;
            tempMatrix.concat(skewMatrix);
            this.transform.matrix = tempMatrix;
            
            var rOffset:Number = this.transform.colorTransform.redOffset + 25;
            var bOffset:Number = this.transform.colorTransform.blueOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiOperation id="flash.geom:Transform:getRelativeMatrix3D"><apiName>getRelativeMatrix3D</apiName><shortdesc>
     Returns a Matrix3D object, which can transform the space of a specified
     display object in relation to the current display object's space.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Matrix3D object that can be used to transform the space from the <codeph>relativeTo</codeph>
     display object to the current display object space.
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>relativeTo</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>The display object relative to which the transformation occurs.
     To get a Matrix3D object relative to the stage, set the parameter to the <codeph>root</codeph> 
     or <codeph>stage</codeph> object. To get the world-relative matrix of the display object,
     set the parameter to a display object that has a perspective transformation applied to it.
         
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Returns a Matrix3D object, which can transform the space of a specified
     display object in relation to the current display object's space. You can use the
     <codeph>getRelativeMatrix3D()</codeph> method to move one three-dimensional display 
     object relative to another three-dimensional display object. 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:Transform:colorTransform:get"><apiName>colorTransform</apiName><shortdesc>
     A ColorTransform object containing values that universally adjust the colors in 
     the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the ColorTransform object <code>blueColorTransform</code> to 
    the Transform object <code>trans</code>.  This ColorTransform converts the color of the MovieClip 
    <code>rect</code> from red to blue.
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    
    var trans:Transform = new Transform(rect);
    trace(trans.colorTransform);          
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    trace(trans.colorTransform);          
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier><apiException><apiDesc>The colorTransform is null when being set
     
    </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     A ColorTransform object containing values that universally adjust the colors in 
     the display object.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedColorTransform:get"><apiName>concatenatedColorTransform</apiName><shortdesc>
     A ColorTransform object representing the combined color transformations applied to the display object 
     and all of its parent objects, back to the root level.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to both a parent and child MovieClip.
    A <code>blueColorTransform</code> is then applied to the Transform object <code>parentTrans</code> which
    adjusts the color of both parent and child MovieClips towards blue.  Notice how <code>child.concatenatedColorTransform</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    
    trace(childTrans.concatenatedColorTransform);     
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    trace(childTrans.colorTransform);                 
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    trace(parentTrans.concatenatedColorTransform);    
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier></apiValueDef><apiDesc>
     A ColorTransform object representing the combined color transformations applied to the display object 
     and all of its parent objects, back to the root level.
     If different color transformations have been applied at different levels, all of those transformations are 
     concatenated into one ColorTransform object 
     for this property.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedMatrix:get"><apiName>concatenatedMatrix</apiName><shortdesc>
     A Matrix object representing the combined transformation matrixes of the 
     display object and all of its parent objects, back to the root level.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to a parent movie clip and to a child movie clip.
    A <code>scaleMatrix</code> is then applied to the Transform object <code>parentTrans</code> which
    scales both parent and child MovieClips.  Notice how <code>child.concatenatedMatrix</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.Matrix;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var scaleMatrix:Matrix = new Matrix();
    scaleMatrix.scale(2, 2);
    
    parentTrans.matrix = scaleMatrix;
    
    trace(childTrans.concatenatedMatrix);     // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(childTrans.matrix);                 // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(parentTrans.concatenatedMatrix);    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     A Matrix object representing the combined transformation matrixes of the 
     display object and all of its parent objects, back to the root level.
     If different transformation matrixes have been applied at different levels, 
     all of those matrixes are concatenated into one matrix 
     for this property. Also, for resizeable SWF content running in the browser, 
     this property factors in the difference between stage coordinates and window 
     coordinates due to window resizing. Thus, the property converts local coordinates 
     to window coordinates, which may not be the same coordinate space as that of 
     the Stage.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Transform:matrix:get"><apiName>matrix</apiName><shortdesc>
     A Matrix object containing values that alter the scaling, rotation, 
     and translation of the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the Matrix object <code>scaleMatrix</code> to the Transform
     object <code>trans</code>.  This Matrix scales the MovieClip <code>rect</code> by a factor of two.
     <listing version="2.0">
     import flash.geom.Transform;
     import flash.geom.Matrix;
     
     var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
     
     var trans:Transform = new Transform(rect);
     trace(trans.matrix);         // (a=1, b=0, c=0, d=1, tx=0, ty=0)
          
     var scaleMatrix:Matrix = new Matrix();
     scaleMatrix.scale(2, 2);
     
     trans.matrix = scaleMatrix;
     trace(trans.matrix);         // (a=2, b=0, c=0, d=2, tx=0, ty=0)
     
     function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
     }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier><apiException><apiDesc>The matrix is null when being set
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     A Matrix object containing values that alter the scaling, rotation, 
     and translation of the display object.
     
     <p>If the <codeph>matrix</codeph> property is set to a value (not <codeph>null</codeph>), the
     <codeph>matrix3D</codeph> property is <codeph>null</codeph>. And if the <codeph>matrix3D</codeph> property
     is set to a value (not <codeph>null</codeph>), the <codeph>matrix</codeph> property is <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:matrix3D:get"><apiName>matrix3D</apiName><shortdesc>
     Provides access to the Matrix3D object of a three-dimensional display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix3D</apiValueClassifier></apiValueDef><apiDesc>
     Provides access to the Matrix3D object of a three-dimensional display object.
     The Matrix3D object represents a transformation matrix that determines the 
     display object's position and orientation. A Matrix3D object can also
     perform perspective projection.
     
     <p>If the <codeph>matrix</codeph> property is set to a value (not <codeph>null</codeph>), the
     <codeph>matrix3D</codeph> property is <codeph>null</codeph>. And if the <codeph>matrix3D</codeph> property
     is set to a value (not <codeph>null</codeph>), the <codeph>matrix</codeph> property is <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:perspectiveProjection:get"><apiName>perspectiveProjection</apiName><shortdesc>
     Provides access to the PerspectiveProjection object of a three-dimensional display 
     object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:PerspectiveProjection</apiValueClassifier></apiValueDef><apiDesc>
     Provides access to the PerspectiveProjection object of a three-dimensional display 
     object. The PerspectiveProjection object can be used to modify the perspective 
     transformation of the stage or to assign a perspective transformation to all the 
     three-dimensional children of a display object.
     
     <p>Based on the field of view and aspect ratio (dimensions) of the stage, a 
     default PerspectiveProjection object is assigned to the root object.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:pixelBounds:get"><apiName>pixelBounds</apiName><shortdesc>
     A Rectangle object that defines the bounding rectangle of the display object on the stage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Transform object <code>trans</code> and traces out
    its <code>pixelBounds</code>.  Notice that pixel bounds returns a bounding box with values 
    equal to MovieClip's <code>getBounds()</code> and <code>getRect()</code> methods.
    <listing version="2.0">
    import flash.geom.Transform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var trans:Transform = new Transform(rect);
    trace(trans.pixelBounds);         // (x=0, y=0, w=20, h=80)
    
    var boundsObj:Object = rect.getBounds();
    trace(boundsObj.xMin);            // 0
    trace(boundsObj.yMin);            // 0
    trace(boundsObj.xMax);            // 20
    trace(boundsObj.yMax);            // 80
    
    var rectObj:Object = rect.getRect();
    trace(rectObj.xMin);              // 0
    trace(rectObj.yMin);              // 0
    trace(rectObj.xMax);              // 20
    trace(rectObj.yMax);              // 80
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     A Rectangle object that defines the bounding rectangle of the display object on the stage.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix"><apiName>Matrix</apiName><shortdesc>
 The Matrix class represents a transformation matrix that determines how to map points from one
 coordinate space to another.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>A standard two-dimensional homogeneous Matrix class.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Matrix class represents a transformation matrix that determines how to map points from one
 coordinate space to another.  You can perform various graphical
 transformations on a display object by setting the properties of a Matrix object,
 applying that Matrix object to the <codeph>matrix</codeph> property of a Transform object, 
 and then applying that Transform object as the <codeph>transform</codeph> property of the display object. 
 These transformation functions include translation
 (<i>x</i> and <i>y</i> repositioning), rotation, scaling, and skewing. 
 
 <p>Together these types of transformations are known as <i>affine transformations</i>. 
 Affine transformations preserve the straightness of lines while transforming, so that
 parallel lines stay parallel.</p>
 
 <p>To apply a transformation matrix to a display object, you create a Transform
 object, set its <codeph>matrix</codeph> property to the transformation matrix, and then set the <codeph>transform</codeph>
 property of the display object to the Transform object.
 Matrix objects are also used as parameters of some methods, such as the following:</p>
 
 <ul>
 
 <li>The <codeph>draw()</codeph> method of a BitmapData object</li>
 
 <li>The <codeph>beginBitmapFill()</codeph> method, <codeph>beginGradientFill()</codeph> method, 
 or <codeph>lineGradientStyle()</codeph> method of a Graphics object</li>
 
 </ul>
 
 <p>A transformation matrix object is a 3 x 3 matrix with the following contents:</p>
 
 <p><adobeimage alt="Matrix class properties in matrix notation" href="../../images/matrix_props1.jpg"/></p>
 
 <p>In traditional transformation matrixes, the <codeph>u</codeph>, <codeph>v</codeph>, and <codeph>w</codeph> 
 properties provide extra capabilities.
 The Matrix class can only operate in two-dimensional space, so it always
 assumes that the property values <codeph>u</codeph> and <codeph>v</codeph> are 0.0, and that the property value
 <codeph>w</codeph> is 1.0. The effective values of the matrix are as follows:</p>
 
 <p><adobeimage alt="Matrix class properties in matrix notation showing    assumed values for u, v, and w" href="../../images/matrix_props2.jpg"/></p>
 
 <p>You can get and set the values of all six of the other properties in a Matrix
 object: <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph>, 
 <codeph>d</codeph>, <codeph>tx</codeph>, and <codeph>ty</codeph>.</p>
 
 <p>The Matrix class supports the four major types of transformations:
 translation, scaling, rotation, and skewing. You can set three of these transformations by using 
 specialized methods, as described in the following table: </p>
 
 <adobetable class="innertable">
   
   
   
   
   
 <tgroup cols="5"><thead><row><entry>Transformation</entry><entry>Method</entry><entry>Matrix values</entry><entry>Display result</entry><entry>Description</entry></row></thead><tbody><row valign="top">
  <entry>Translation (displacement)</entry>
  <entry outputclass="nowrap"><codeph>translate(tx, ty)</codeph> </entry>
  <entry><adobeimage alt="Matrix notation of translate method parameters" height="104" href="../../images/matrix_translate.jpg" width="150"/></entry>
  <entry><adobeimage alt="Illustration of translate method effects" height="91" href="../../images/matrix_translate_image.jpg" width="111"/></entry>
  <entry>Moves the image <codeph>tx</codeph> pixels to the right and <codeph>ty</codeph> pixels
    down.</entry>
   </row><row valign="top">
  <entry>Scaling</entry>
  <entry><codeph>scale(sx, sy)</codeph></entry>
  <entry><adobeimage alt="Matrix notation of scale method parameters" height="105" href="../../images/matrix_scale.jpg" width="140"/></entry>
  <entry><adobeimage alt="Illustration of scale method effects" height="84" href="../../images/matrix_scale_image.jpg" width="111"/></entry>
  <entry>Resizes the image, multiplying the location of each pixel by <codeph>sx</codeph> on the
  <i>x</i> axis and <codeph>sy</codeph> on the <i>y</i> axis.</entry>
   </row><row valign="top">
  <entry>Rotation</entry>
  <entry><codeph>rotate(q)</codeph></entry>
  <entry><adobeimage alt="Matrix notation of rotate method properties" height="105" href="../../images/matrix_rotate.jpg" width="219"/></entry>
  <entry><adobeimage alt="Illustration of rotate method effects" height="91" href="../../images/matrix_rotate_image.jpg" width="111"/></entry>
  <entry>Rotates the image by an angle <codeph>q</codeph>, which is measured in radians.</entry>
   </row><row valign="top">
  <entry>Skewing or shearing </entry>
  <entry>None; must set the properties <codeph>b</codeph> and <codeph>c</codeph></entry>
  <entry><adobeimage alt="Matrix notation of skew function properties" href="../../images/matrix_skew.jpg"/></entry>
  <entry><adobeimage alt="Illustration of skew function effects" height="77" href="../../images/matrix_skew_image.jpg" width="111"/></entry>
  <entry>Progressively slides the image in a direction parallel to the <i>x</i> or <i>y</i>  axis. The <codeph>b</codeph> 
    property of the Matrix object represents the tangent of the skew angle along the <i>y</i> axis; 
    the <codeph>c</codeph> property of the Matrix object represents the tangent of the skew angle along the
    <i>x</i> axis.</entry>
   </row></tbody></tgroup></adobetable>
 <p>Each transformation function alters the current matrix properties so that
   you can effectively combine multiple transformations. To do this, you call more than one
   transformation function before applying the matrix to its display object target (by using the 
   <codeph>transform</codeph> property of that display object).</p>
 
 <p>Use the <codeph>new Matrix()</codeph> constructor to create a 
 Matrix object before you can call the methods of the Matrix object.</p>
 
 </apiDesc><example conref="examples\MatrixExample.as"> The following example uses the <codeph>MatrixExample</codeph> class to show 
 how a large gradient-filled square can be created.  This is accomplished with the following 
 steps:
 <ol>
     <li>The application creates a new Matrix object <codeph>myMatrix</codeph>, and it uses the 
          <codeph>trace()</codeph> method to output
         the default property values for the <codeph>myMatrix</codeph> object.</li>
     <li>The application calls the <codeph>createGradientBox()</codeph> with the <codeph>width</codeph>
     and <codeph>height</codeph> parameters set to 200 pixels, no rotation, and the distance to translate along
     the <i>x</i> and <i>y</i> axes set to 50 pixels.</li>
     <li>The application prints the <codeph>myMatrix</codeph> object again to show the change after calling
     <codeph>createGradientBox()</codeph>.</li>
     <li>The application sets up three variables to control how the gradient box is filled:
     <ul>
         <li><codeph>colors</codeph>: Sets the gradient colors to range between solid red and solid blue.</li>
         <li><codeph>alphas</codeph>: Sets the opacity to solid.</li>
         <li><codeph>ratios</codeph>: Sets the distribution of the colors to be equal for both red and blue.</li>
  </ul></li>
     <li>The application calls the graphics method <codeph>beginGradientFill()</codeph>, which operates on the <codeph>myMatrix</codeph>
     object, and it calls the <codeph>lineTo()</codeph> method, resulting in the gradient-filled box.</li>
 </ol>
<codeblock>
package {
    import flash.geom.Matrix;
    import flash.display.Sprite;
    import flash.display.GradientType;

    public class MatrixExample extends Sprite {

        public function MatrixExample() {
            var myMatrix:Matrix = new Matrix();
            trace(myMatrix.toString());    // (a=1, b=0, c=0, d=1, tx=0, ty=0)

            myMatrix.createGradientBox(200, 200, 0, 50, 50);
            trace(myMatrix.toString());    // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)

            var colors:Array = [0xFF0000, 0x0000FF];
            var alphas:Array = [1, 1];
            var ratios:Array = [0, 0xFF];
            graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
            graphics.lineTo(0, 300);
            graphics.lineTo(300, 300);
            graphics.lineTo(300, 0);
            graphics.lineTo(0, 0);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiConstructor id="flash.geom:Matrix:Matrix"><apiName>Matrix</apiName><shortdesc>
    Creates a new Matrix object with the specified parameters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
    
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>The value that affects the positioning of pixels
             along the <i>x</i> axis when scaling or rotating an image.
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The value that affects the positioning of pixels
             along the <i>y</i> axis when rotating or skewing an image.
    </apiDesc></apiParam><apiParam><apiItemName>c</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The value that affects the positioning of pixels
             along the <i>x</i> axis when rotating or skewing an image.
    </apiDesc></apiParam><apiParam><apiItemName>d</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>The value that affects the positioning of pixels
             along the <i>y</i> axis when scaling or rotating an image..
    </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The distance by which to translate each point along the <i>x</i> axis.
    </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The distance by which to translate each point along the <i>y</i> axis.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Creates a new two-dimensional Matrix object.
    
    </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
    Creates a new Matrix object with the specified parameters. In matrix notation, the properties
    are organized like this:
    
    <p><adobeimage alt="Matrix class properties in matrix notation showing assumed values for u, v, and w" href="../../images/matrix_props2.jpg"/></p>
    
    <p>If you do not provide any parameters to the <codeph>new Matrix()</codeph> constructor, it creates an
    <i>identity matrix</i> with the following values:</p>
    <adobetable class="innertable">
    
    
    
    <tgroup cols="2"><tbody><row>
      <entry><pre>a = 1</pre></entry>
      <entry><pre>b = 0</pre></entry>
    </row><row>
      <entry><pre>c = 0</pre></entry>
      <entry><pre>d = 1</pre></entry>
    </row><row>
      <entry><pre>tx = 0</pre></entry>
      <entry><pre>ty = 0</pre></entry>
    </row></tbody></tgroup></adobetable>
    <p>In matrix notation, the identity matrix looks like this:</p>
    
    <p><adobeimage alt="Matrix class properties in matrix notation" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc><example conref="examples\Matrix.1.as"> The following example creates <codeph>matrix_1</codeph> by sending no parameters to the
 <codeph>Matrix()</codeph> constructor and <codeph>matrix_2</codeph> by sending parameters to it.  Notice that
 <codeph>matrix_1</codeph>, which was created with no parameters, results in an identity matrix with the values
 <codeph>a</codeph>=1, <codeph>b</codeph>=0, <codeph>c</codeph>=0, <codeph>d</codeph>=1, <codeph>tx</codeph>=0, 
 <codeph>ty</codeph>=0.
<codeblock>
import flash.geom.Matrix;

var matrix_1:Matrix = new Matrix();
trace(matrix_1);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)

var matrix_2:Matrix = new Matrix(1, 2, 3, 4, 5, 6);
trace(matrix_2);  // (a=1, b=2, c=3, d=4, tx=5, ty=6)
</codeblock></example></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Matrix:clone"><apiName>clone</apiName><shortdesc>
    Returns a new Matrix object that is a clone of this
    matrix, with an exact copy of the contained object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>clonedMatrix</code> from <code>myMatrix</code>.
    Notice that the Matrix class does not have an equals method, so the following example
    uses a custom written function to test the equality of two Matricies.
    
    <listing version="2.0">
    import flash.geom.Matrix;
       
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
    var clonedMatrix:Matrix = new Matrix();
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // false
    
    clonedMatrix = myMatrix.clone(); 
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // true
    
    function equals(m1:Matrix, m2:Matrix):Boolean {
        return m1.toString() == m2.toString();
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Matrix object.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Returns a new Matrix object that is a copy of the current matrix.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Returns a new Matrix object that is a clone of this
    matrix, with an exact copy of the contained object.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:concat"><apiName>concat</apiName><shortdesc>
    Concatenates a matrix with the current matrix, effectively combining the 
    geometric effects of the two.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three Matricies that define transformations for
    three rectangle MovieClips.  The first two Matricies <code>rotate45Matrix</code>
    and <code>doubleScaleMatrix</code> are applied to the two rectangles 
    <code>rectangleMc_1</code> and <code>rectangleMc_2</code>.  Then, the third
    Matrix is created using the <code>concat()</code> method on <code>rotate45Matrix</code> and 
    <code>doubleScaleMatrix</code> to create <code>scaleAndRotateMatrix</code>. 
    This Matrix is then applied to <code>rectangleMc_3</code> to scale and rotate it.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var rectangleMc_0:MovieClip = createRectangle(20, 80, 0x000000);
    var rectangleMc_1:MovieClip = createRectangle(20, 80, 0xFF0000);   
    var rectangleMc_2:MovieClip = createRectangle(20, 80, 0x00FF00);   
    var rectangleMc_3:MovieClip = createRectangle(20, 80, 0x0000FF);
    
    var rectangleTrans_1:Transform = new Transform(rectangleMc_1);
    var rectangleTrans_2:Transform = new Transform(rectangleMc_2);
    var rectangleTrans_3:Transform = new Transform(rectangleMc_3);
    
    var rotate45Matrix:Matrix = new Matrix();
    rotate45Matrix.rotate(Math.PI/4);
    rectangleTrans_1.matrix = rotate45Matrix;
    rectangleMc_1._x = 100;
    trace(rotate45Matrix.toString());    // (a=0.707106781186548, b=0.707106781186547, c=-0.707106781186547, d=0.707106781186548, tx=0, ty=0)
    
    var doubleScaleMatrix:Matrix = new Matrix();
    doubleScaleMatrix.scale(2, 2);
    rectangleTrans_2.matrix = doubleScaleMatrix;
    rectangleMc_2._x = 200;
    trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    var scaleAndRotateMatrix:Matrix = doubleScaleMatrix.clone();
    scaleAndRotateMatrix.concat(rotate45Matrix);
    rectangleTrans_3.matrix = scaleAndRotateMatrix;
    rectangleMc_3._x = 300;
    trace(scaleAndRotateMatrix.toString());   // (a=1.4142135623731, b=1.41421356237309, c=-1.41421356237309, d=1.4142135623731, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
        var depth:Number = this.getNextHighestDepth();
        var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
        mc.beginFill(color);
        mc.lineTo(0, height);
        mc.lineTo(width, height);
        mc.lineTo(width, 0);
        mc.lineTo(0, 0);
        return mc;
    }
    
    </listing>
    
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiDesc>The matrix to be concatenated to the source matrix.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Concatenates a matrix with the current matrix, effectively combining the 
    geometric effects of the two. In mathematical terms, concatenating two matrixes 
    is the same as combining them using matrix multiplication.
    
    <p>For example, if matrix <codeph>m1</codeph> scales an object by a factor of four, and 
    matrix <codeph>m2</codeph> rotates an object by 1.5707963267949 radians 
    (<codeph>Math.PI/2</codeph>), then <codeph>m1.concat(m2)</codeph> transforms <codeph>m1</codeph>
    into a matrix that scales an object by a factor of four and rotates the object by 
    <codeph>Math.PI/2</codeph> radians. </p>
    
    <p>This method replaces the source matrix with the concatenated matrix. If you 
    want to concatenate two matrixes without altering either of the two source matrixes, 
    first copy the source matrix by using the <codeph>clone()</codeph> method, as shown in the Class Examples section.</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:createBox"><apiName>createBox</apiName><shortdesc>
     Includes parameters for scaling,
     rotation, and translation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The factor by which to scale horizontally. 
     
     </apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The factor by which scale vertically. 
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The amount to rotate, in radians. 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The number of pixels to translate (move) to the right along the <i>x</i> axis. 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The number of pixels to translate (move) down along the <i>y</i> axis.  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Creates a Matrix with scaling, rotation, and translation values.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Includes parameters for scaling,
     rotation, and translation. When applied to a matrix it sets the matrix's values
     based on those parameters.
     
     <p>Using the <codeph>createBox()</codeph> method lets you obtain the same matrix as you would if 
     you applied the <codeph>identity()</codeph>, <codeph>rotate()</codeph>, <codeph>scale()</codeph>, and <codeph>translate()</codeph> methods
     in succession. For example, <codeph>mat1.createBox(2,2,Math.PI/4, 100, 100)</codeph> has the
     same effect as the following:</p>
     
     <codeblock platform="actionscript">
     import flash.geom.Matrix;
     
     var mat1:Matrix = new Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2,2);
     mat1.translate(10,20);
     </codeblock>
     
     <codeblock platform="javascript">
     var mat1 = new air.Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2, 2);
     mat1.translate(10, 20);
     </codeblock>
     
     </apiDesc><example conref="examples\Matrix_createBox.as"> The following example sets the x scale, y scale, rotation, x location, 
 and y location of <codeph>myMatrix</codeph> by calling its <codeph>createBox()</codeph> method.
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_createBox extends Sprite
    {
        public function Matrix_createBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createBox(1, 2, Math.PI/4, 50, 100);
             trace(myMatrix.toString());  
             // (a=0.7071067811865476, b=1.414213562373095, c=-0.7071067811865475, 
             //  d=1.4142135623730951, tx=100, ty=200)
             
             var rectangleShape:Shape = createRectangle(20, 80, 0xFF0000);   
             addChild(rectangleShape);
              
             var rectangleTrans:Transform = new Transform(rectangleShape);
             rectangleTrans.matrix = myMatrix;
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:createGradientBox"><apiName>createGradientBox</apiName><shortdesc>
     Creates the specific style of matrix expected by the beginGradientFill() and 
     lineGradientStyle() methods of the Graphics class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
     
     </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The width of the gradient box.
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The height of the gradient box.
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The amount to rotate, in radians. 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The distance, in pixels, to translate to the right along the <i>x</i> axis. 
     This value is offset by half of the <codeph>width</codeph> parameter. 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The distance, in pixels, to translate down along the <i>y</i> axis.
     
     This value is offset by half of the <codeph>height</codeph> parameter. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Creates the specific style of matrix expected by the beginGradientFill() method of the Graphics class.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Creates the specific style of matrix expected by the <codeph>beginGradientFill()</codeph> and 
     <codeph>lineGradientStyle()</codeph> methods of the Graphics class. Width and height are scaled to 
     a <codeph>scaleX</codeph>/<codeph>scaleY</codeph> pair and the <codeph>tx</codeph>/<codeph>ty</codeph> 
     values are offset by half the width and height.
     
     <p>For example, consider a gradient with the following characteristics:</p>
     
     <ul>
     
     <li><codeph>GradientType.LINEAR</codeph></li>
     <li>Two colors, green and blue, with the ratios array set to <codeph>[0, 255]</codeph></li>
     <li><codeph>SpreadMethod.PAD</codeph></li>
     <li><codeph>InterpolationMethod.LINEAR_RGB</codeph></li>
     
     </ul>
     
     <p>The following illustrations show gradients in which the matrix was defined using the 
     <codeph>createGradientBox()</codeph> method with different parameter settings:</p>
     
     <adobetable class="innertable">
     
      
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>createGradientBox()</codeph> settings</entry><entry>Resulting gradient</entry></row></thead><tbody><row>
     
      <entry><pre>width = 25;
     height = 25; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="resulting linear gradient" href="../../images/createGradientBox-1.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 25; 
     height = 25; 
     rotation = 0; 
     tx = 25; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="resulting linear gradient" href="../../images/createGradientBox-2.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50; 
     height = 50; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="resulting linear gradient" href="../../images/createGradientBox-3.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50;
     height = 50; 
     rotation = Math.PI / 4; // 45 degrees
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="resulting linear gradient" href="../../images/createGradientBox-4.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\Matrix_createGradientBox.as"> The following example sets the x scale, y scale, rotation, x location, 
 and y location of <codeph>myMatrix</codeph> by calling its <codeph>createBox()</codeph> method.
<codeblock>

package
{
    import flash.display.GradientType;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    
    public class Matrix_createGradientBox extends Sprite
    {
        public function Matrix_createGradientBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());          // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createGradientBox(200, 200, 0, 50, 50);
             trace(myMatrix.toString());          // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)
             
             var colors:Array = [0xFF0000, 0x0000FF];
             var alphas:Array = [100, 100];
             var ratios:Array = [0, 0xFF];
             
             this.graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
             this.graphics.drawRect(0, 0, 300, 200);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:deltaTransformPoint"><apiName>deltaTransformPoint</apiName><shortdesc>
    Given a point in the pretransform coordinate space, returns the coordinates of 
    that point after the transformation occurs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>deltaTransformPoint()</code> method 
    to create <code>deltaTransformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method has no affect on the position of <code>deltaTransformedPoint</code>.
    In the example, however, <code>scale()</code> does affect the position.  It
    increases the original <code>x</code> value by a factor of three from 50 to 150.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);   // (50, 0)              
    
    var deltaTransformedPoint:Point = myMatrix.deltaTransformPoint(myPoint);
    trace(deltaTransformedPoint); // (150, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = deltaTransformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The point resulting from applying the matrix transformation.
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point for which you want to get the result of the matrix transformation.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Given a point in the pretransform coordinate space, returns the coordinates of 
    that point after the transformation occurs. Unlike the standard transformation applied using 
    the <codeph>transformPoint()</codeph> method, the <codeph>deltaTransformPoint()</codeph> method's  
    transformation does not consider the translation parameters <codeph>tx</codeph> and <codeph>ty</codeph>.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:identity"><apiName>identity</apiName><shortdesc>
    Sets each matrix property to a value that causes a null transformation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
    </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Sets each matrix property to a value that causes a null transformation. An object transformed 
    by applying an identity matrix will be identical to the original.
    
    <p>After calling the <codeph>identity()</codeph> method, the resulting matrix has the following properties: 
    <codeph>a</codeph>=1, <codeph>b</codeph>=0, <codeph>c</codeph>=0, <codeph>d</codeph>=1, <codeph>tx</codeph>=0, <codeph>ty</codeph>=0.</p>
    
    <p>In matrix notation, the identity matrix looks like this:</p>
    
    <p><adobeimage alt="Matrix class properties in matrix notation" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:invert"><apiName>invert</apiName><shortdesc>
     Performs the opposite transformation
     of the original matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Performs the opposite transformation
     of the original matrix. You can apply an inverted matrix to an object to undo the transformation
     performed when applying the original matrix.
     
     </apiDesc><example conref="examples\Matrix_invert.as"> The following example creates a <codeph>halfScaleMatrix</codeph> by calling the
 <codeph>invert()</codeph> method of <codeph>doubleScaleMatrix</codeph>.  It then demonstrates that
 the two are Matrix inverses of one another -- matrices that undo any 
 transformations performed by the other -- by creating <codeph>originalAndInverseMatrix</codeph>
 which is equal to <codeph>noScaleMatrix</codeph>.
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_invert extends Sprite
    {
        public function Matrix_invert()
        {
            var rect0:Shape = createRectangle(20, 80, 0xFF0000);   
            var rect1:Shape = createRectangle(20, 80, 0x00FF00);   
            var rect2:Shape = createRectangle(20, 80, 0x0000FF);
            var rect3:Shape = createRectangle(20, 80, 0x000000);
            
            var trans0:Transform = new Transform(rect0);
            var trans1:Transform = new Transform(rect1);
            var trans2:Transform = new Transform(rect2);
            var trans3:Transform = new Transform(rect3);
             
            var doubleScaleMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
            trans0.matrix = doubleScaleMatrix;
            trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
             
            var noScaleMatrix:Matrix = new Matrix(1, 0, 0, 1, 0, 0);
            trans1.matrix = noScaleMatrix;
            rect1.x = 50;
            trace(noScaleMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
            var halfScaleMatrix:Matrix = doubleScaleMatrix.clone();
            halfScaleMatrix.invert();
            trans2.matrix = halfScaleMatrix;
            rect2.x = 100;
            trace(halfScaleMatrix.toString());  // (a=0.5, b=0, c=0, d=0.5, tx=0, ty=0)
             
            var originalAndInverseMatrix:Matrix = doubleScaleMatrix.clone();
            originalAndInverseMatrix.concat(halfScaleMatrix);
            trans3.matrix = originalAndInverseMatrix;
            rect3.x = 150;
            trace(originalAndInverseMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)            
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:rotate"><apiName>rotate</apiName><shortdesc>
     Applies a rotation transformation to the Matrix object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example the <code>rotate()</code> method rotates <code>rectangleMc</code>
    30 degrees clockwise.  Notice that applying <code>myMatrix</code> to <code>rectangleMc</code>
    resets its <i>_x</i> value leaving us to reset it to 100 manually.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());           // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());           // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    The above example uses the <code>_x</code> property of the MovieClip object 
    to position <code>rectangleMc</code>.  Generally, when dealing with Matrix
    positioning, mixing positioning techniques is considered bad style.  The  
    example above written in good style would concatenate a translation Matrix to
    <code>myMatrix</code> to change the horizontal location of <code>rectangleMc</code>. 
    The following example demonstrates this. 
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());   // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var translateMatrix:Matrix = new Matrix();
    translateMatrix.translate(100, 0);
    myMatrix.concat(translateMatrix);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=100, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);        // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);        // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);        // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The rotation angle in radians.
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Applies a rotation transformation to the Matrix object. 
     
     <p>The <codeph>rotate()</codeph> method alters the <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph>, 
     and <codeph>d</codeph> properties of the Matrix object. 
     In matrix notation, this is the same as concatenating the current matrix with the following:</p>
     
     <p><adobeimage alt="Matrix notation of scale method parameters" height="105" href="../../images/matrix_rotate.jpg" width="219"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:scale"><apiName>scale</apiName><shortdesc>
     Applies a scaling transformation to the matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>scale()</code> method to
    scale <code>myMatrix</code> by a factor of 3 horizontally and a factor of 4 
    vertically.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.scale(3, 4);
    trace(myMatrix.toString());   // (a=6, b=0, c=0, d=8, tx=300, ty=400)
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the <i>x</i> axis.
     </apiDesc></apiParam><apiParam><apiItemName>sy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>A multiplier used to scale the object along the <i>y</i> axis.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Applies a scaling transformation to the matrix. The <i>x</i> axis is multiplied 
     by <codeph>sx</codeph>, and the <i>y</i> axis it is multiplied by <codeph>sy</codeph>.
     
     <p>The <codeph>scale()</codeph> method alters the <codeph>a</codeph> and <codeph>d</codeph> properties of 
     the Matrix object. 
     In matrix notation, this is the same as concatenating the current matrix with the following matrix:</p>
     <p><adobeimage alt="Matrix notation of scale method parameters" height="105" href="../../images/matrix_scale.jpg" width="140"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:toString"><apiName>toString</apiName><shortdesc>
     Returns a text value listing the properties of the Matrix object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>myMatrix</code> and converts its values 
     to a String in the format of (a=A, b=B, c=C, d=D, tx=TX, ty=TY).
     
     <listing version="2.0">
     import flash.geom.Matrix;
     
     var myMatrix:Matrix = new Matrix();
     trace("myMatrix: " + myMatrix.toString()); // (a=1, b=0, c=0, d=1, tx=0, ty=0)
     </listing>
      
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A string containing the values of the properties of the Matrix object: <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph>,
     <codeph>d</codeph>, <codeph>tx</codeph>, and <codeph>ty</codeph>.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Returns a text value listing the properties of this Matrix object.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Returns a text value listing the properties of the Matrix object.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:transformPoint"><apiName>transformPoint</apiName><shortdesc>
     Returns the result of applying the geometric transformation represented by the Matrix object to the 
     specified point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>transformPoint()</code> method 
    to create <code>transformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method does have an affect on the position of <code>transformedPoint</code>.
    In the example, <code>scale()</code> increases the original <code>x</code> 
    value by a factor of three from 50 to 150, and <code>translate()</code> increases 
    <code>x</code> by 300 for a total value of 450.
    
    <listing version="2.0">
    import flash.geom.Matrix;     
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);                   // (50, 0)
          
    var transformedPoint:Point = myMatrix.transformPoint(myPoint);
    trace(transformedPoint);  // (450, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = transformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The point resulting from applying the Matrix transformation.
    
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point for which you want to get the result of the Matrix transformation.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Returns the result of a geometric transformation to a Point object.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Returns the result of applying the geometric transformation represented by the Matrix object to the 
     specified point. 
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:translate"><apiName>translate</apiName><shortdesc>
    Translates the matrix along the x and y axes, as specified by the dx
    and dy parameters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>translate()</code> method to position 
    <code>rectangleMc</code> x:100 and y:50. Notice that <code>translate()</code> affects 
    the translate values <code>tx</code> and <code>ty</code> but not <code>a</code>, <code>b</code>,
    <code>c</code>, or <code>d</code>.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.translate(100, 50);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=200, ty=150)
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The amount of movement along the <i>x</i> axis to the right, in pixels.
    
    </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The amount of movement down along the <i>y</i> axis, in pixels.
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Translates the matrix along the x and y axes.
    
    <p>The <codeph>translate()</codeph> method alters the <codeph>tx</codeph> and <codeph>ty</codeph> properties of 
    the matrix object. 
    
    In matrix notation, this is the same as concatenating the current matrix with the following:</p>
    
    <p><adobeimage alt="Matrix notation of scale method parameters" height="105" href="../../images/matrix_translate.jpg" width="150"/></p>
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Translates the matrix along the <i>x</i> and <i>y</i> axes, as specified by the <codeph>dx</codeph>
    and <codeph>dy</codeph> parameters.
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix:a"><apiName>a</apiName><shortdesc>
     The value that affects the positioning of pixels
     along the x axis when scaling or rotating an image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The value that affects the positioning of pixels
     along the x axis when scaling or rotating an image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     The value that affects the positioning of pixels
     along the <i>x</i> axis when scaling or rotating an image.
     
     </apiDesc><example conref="examples\Matrix.a.1.as"> The following example creates the Matrix object <codeph>myMatrix</codeph> and sets its 
 <codeph>a</codeph> value.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.a);  // 1

myMatrix.a = 2;
trace(myMatrix.a);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:b"><apiName>b</apiName><shortdesc>
     The value that affects the positioning of pixels
     along the y axis when rotating or skewing an image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The value that affects the positioning of pixels
     along the y axis when rotating or skewing an image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     The value that affects the positioning of pixels
     along the <i>y</i> axis when rotating or skewing an image.
     
     </apiDesc><example conref="examples\Matrix.b.1.as"> The following example creates the Matrix object <codeph>myMatrix</codeph> and sets its 
 <codeph>b</codeph> value.
<codeblock>
import flash.geom.Matrix;
 
var myMatrix:Matrix = new Matrix();
trace(myMatrix.b);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.b = Math.tan(radians);
trace(myMatrix.b);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:c"><apiName>c</apiName><shortdesc>
     The value that affects the positioning of pixels
     along the x axis when rotating or skewing an image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The value that affects the positioning of pixels
     along the x axis when rotating or skewing an image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     The value that affects the positioning of pixels
     along the <i>x</i> axis when rotating or skewing an image.
     
     </apiDesc><example conref="examples\Matrix.c.1.as"> The following example creates the Matrix object <codeph>myMatrix</codeph> and sets its 
 <codeph>c</codeph> value.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.c);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.c = Math.tan(radians);
trace(myMatrix.c);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:d"><apiName>d</apiName><shortdesc>
     The value that affects the positioning of pixels
     along the y axis when scaling or rotating an image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The value that affects the positioning of pixels
     along the y axis when scaling or rotating an image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     The value that affects the positioning of pixels
     along the <i>y</i> axis when scaling or rotating an image.
     
     </apiDesc><example conref="examples\Matrix.d.1.as"> The following example creates the Matrix object <codeph>myMatrix</codeph> and sets its 
 <codeph>d</codeph> value.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.d);  // 1

myMatrix.d = 2;
trace(myMatrix.d);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:tx"><apiName>tx</apiName><shortdesc>
     The distance by which to translate each point along the x axis.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The distance by which to translate each point along the x axis.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     The distance by which to translate each point along the <i>x</i> axis.
     
     </apiDesc><example conref="examples\Matrix.tx.1.as"> The following example creates the Matrix object <codeph>myMatrix</codeph> and sets its 
 <codeph>tx</codeph> value.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.tx);  // 0

myMatrix.tx = 50;  // 50
trace(myMatrix.tx);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:ty"><apiName>ty</apiName><shortdesc>
     The distance by which to translate each point along the y axis.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The distance by which to translate each point along the y axis.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     The distance by which to translate each point along the <i>y</i> axis.
     
     </apiDesc><example conref="examples\Matrix.ty.1.as"> The following example creates the Matrix object <codeph>myMatrix</codeph> and sets its 
 <codeph>ty</codeph> value.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.ty);  // 0

myMatrix.ty = 50;
trace(myMatrix.ty);  // 50
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Rectangle"><apiName>Rectangle</apiName><shortdesc>
 A Rectangle object is an area defined by its position, as
 indicated by its top-left corner point (x, y) and by its width
 and its height.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>A Rectangle object is an area defined by its position, as
 indicated by its top-left corner point (x, y), and by its width
 and its height.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 A Rectangle object is an area defined by its position, as
 indicated by its top-left corner point (<i>x</i>, <i>y</i>) and by its width
 and its height. 
 
 <p>The <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, and
 <codeph>height</codeph> properties of the Rectangle class are
 independent of each other; changing the value of one property has
 no effect on the others. However, the <codeph>right</codeph> and <codeph>bottom</codeph> 
 properties are integrally related to those four properties. For example, if you change 
 the value of the <codeph>right</codeph> property, the value of the <codeph>width</codeph> property 
 changes; if you change the <codeph>bottom</codeph> property, the value of the <codeph>height</codeph> 
 property changes. </p>
 
 <p platform="actionscript">The following methods and properties use Rectangle objects:</p>
 
 <ul platform="actionscript">
 
 	<li>The <codeph>applyFilter()</codeph>, <codeph>colorTransform()</codeph>, 
 <codeph>copyChannel()</codeph>, <codeph>copyPixels()</codeph>, <codeph>draw()</codeph>, <codeph>fillRect()</codeph>, 
 <codeph>generateFilterRect()</codeph>, <codeph>getColorBoundsRect()</codeph>, <codeph>getPixels()</codeph>, 
 <codeph>merge()</codeph>, <codeph>paletteMap()</codeph>, <codeph>pixelDisolve()</codeph>, <codeph>setPixels()</codeph>, and
 <codeph>threshold()</codeph> methods, and the <codeph>rect</codeph> property of the BitmapData class</li>
 
 	<li>The <codeph>getBounds()</codeph> and <codeph>getRect()</codeph> methods, and the <codeph>scrollRect</codeph>
 and <codeph>scale9Grid</codeph> properties of the DisplayObject class</li>
 
 	<li>The <codeph>getCharBoundaries()</codeph> method of the TextField class</li>
 
 	<li>The <codeph>pixelBounds</codeph> property of the Transform class</li>
 
 	<li>The <codeph>bounds</codeph> parameter for the <codeph>startDrag()</codeph> method of the Sprite class</li>
 
 	<li>The <codeph>printArea</codeph> parameter of the <codeph>addPage()</codeph> method of the PrintJob class</li>
 
 </ul>
 
 <p>You can use the <codeph>new Rectangle()</codeph> constructor to create a 
 Rectangle object.</p>
 
 <p platform="actionscript"><b>Note:</b> The Rectangle class does not define a rectangular Shape display object. To draw
 a rectangular Shape object onscreen, use the <codeph>drawRect()</codeph> method of the Graphics
 class.</p>
 
 </apiDesc><example conref="examples\RectangleExample.as"> The following example uses the RectangleExample class to create three new Rectangle
 objects at various <i>x</i>,<i>y</i> coordinates and with various heights and widths and then uses the
 <codeph>trace()</codeph> method to confirm that the Rectangle instances were successfully created.  Then a Boolean
 variable <codeph>isContained</codeph> is assigned to the result of the call to 
 the <codeph>containsRect()</codeph> method,
 which determines that the second rectangle does not fully enclose the third rectangle.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Rectangle;

    public class RectangleExample extends Sprite {

        public function RectangleExample() {
            var firstRect:Rectangle = new Rectangle();
            trace(firstRect);  // (x=0, y=0, w=0, h=0)
            var secondRect:Rectangle = new Rectangle(1, 3, 11, 13);
            trace(secondRect); // (x=1, y=3, w=11, h=13)
            var thirdRect:Rectangle = new Rectangle(5, 8, 17, 19);
            trace(thirdRect);  // (x=5, y=8, w=17, h=19)
            var isContained:Boolean = secondRect.containsRect(thirdRect);
            trace(isContained); // false
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/scrollRect"><linktext>flash.display.DisplayObject.scrollRect</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.text.xml#TextField/getCharBoundaries()"><linktext>flash.text.TextField.getCharBoundaries()</linktext></link><link href="flash.geom.xml#Transform/pixelBounds"><linktext>flash.geom.Transform.pixelBounds</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>flash.display.Sprite.startDrag()</linktext></link><link href="flash.printing.xml#PrintJob/addPage()"><linktext>flash.printing.PrintJob.addPage()</linktext></link></related-links><apiConstructor id="flash.geom:Rectangle:Rectangle"><apiName>Rectangle</apiName><shortdesc>
	Creates a new Rectangle object with the top-left corner specified by the x 
	and y parameters and with the specified width and height 
	parameters.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle with with specific parameters.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.toString()); // (x=5, y=10, w=50, h=100)
	</listing>
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The <i>x</i> coordinate of the top-left corner of the rectangle.
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The <i>y</i> coordinate of the top-left corner of the rectangle.
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The width of the rectangle, in pixels.
	</apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The height of the rectangle, in pixels.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Creates a new Rectangle object with the top-left corner specified by the 
	x and y parameters and with the specified width and height.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Creates a new Rectangle object with the top-left corner specified by the <codeph>x</codeph> 
	and <codeph>y</codeph> parameters and with the specified <codeph>width</codeph> and <codeph>height</codeph> 
	parameters. If you call this function without parameters, 
	a rectangle with <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, and <codeph>height</codeph> 
	properties set to 0 is created.
	
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Rectangle:clone"><apiName>clone</apiName><shortdesc>
	Returns a new Rectangle object with the same values for the x, y, 
	width, and height properties as the original Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the <code>clone</code> member.
	<listing version="2.0">
	import flash.geom.Rectangle;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var shadow:Rectangle = rect.clone();
	shadow.offset(5, 5);
	trace(rect); // (x=1, y=2, w=4, h=8)
	trace(shadow); // (x=6, y=7, w=4, h=8)
	</listing>

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new Rectangle object with the same values for the <codeph>x</codeph>, <codeph>y</codeph>, 
	<codeph>width</codeph>, and <codeph>height</codeph> properties as the original Rectangle object.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Returns a copy of this Rectangle object.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Returns a new Rectangle object with the same values for the <codeph>x</codeph>, <codeph>y</codeph>, 
	<codeph>width</codeph>, and <codeph>height</codeph> properties as the original Rectangle object.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:contains"><apiName>contains</apiName><shortdesc>
	Determines whether the specified point is contained within the rectangular region defined 
	by this Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the coordinates fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var doesContain_1:Boolean = rect.contains(59, 59);
	trace(doesContain_1); // true
	var doesContain_2:Boolean = rect.contains(10, 10);
	trace(doesContain_2); // true
	var doesContain_3:Boolean = rect.contains(60, 60);
	trace(doesContain_3); // false
	</listing>

	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the Rectangle object contains the specified point; 
	otherwise <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>x</i> coordinate (horizontal position) of the point.  
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The <i>y</i> coordinate (vertical position) of the point.
	</apiDesc></apiParam><apiTipTexts><apiTipText>Determines if the specified point is contained within the rectangular region.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Determines whether the specified point is contained within the rectangular region defined 
	by this Rectangle object.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsPoint"><apiName>containsPoint</apiName><shortdesc>
	Determines whether the specified point is contained within the rectangular region defined 
	by this Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the specified Points fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var containsPoint_1:Boolean = rect.containsPoint(new Point(10, 10));
	trace(containsPoint_1); // true
	var containsPoint_2:Boolean = rect.containsPoint(new Point(59, 59));
	trace(containsPoint_2); // true
	var containsPoint_3:Boolean = rect.containsPoint(new Point(60, 60));
	trace(containsPoint_3); // false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the Rectangle object contains the specified point; 
	otherwise <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point, as represented by its <i>x</i> and <i>y</i> coordinates.  
	</apiDesc></apiParam><apiTipTexts><apiTipText>Determines if the specified point is contained within the rectangular region defined 
	by this Rectangle object using a Point object as a parameter.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Determines whether the specified point is contained within the rectangular region defined 
	by this Rectangle object. This method is similar to the <codeph>Rectangle.contains()</codeph> method, 
	except that it takes a Point object as a parameter.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/contains()"><linktext>contains()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsRect"><apiName>containsRect</apiName><shortdesc>
	Determines whether the Rectangle object specified by the rect parameter is contained
	within this Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>A Rectangle is said to contain another if that second 
	Rectangle falls entirely within the boundaries of the first.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectC:Rectangle = new Rectangle(10, 10, 51, 51);
	var rectD:Rectangle = new Rectangle(15, 15, 45, 45);
	var rectAContainsB:Boolean = rectA.containsRect(rectB); // true
	var rectAContainsC:Boolean = rectA.containsRect(rectC); // false
	var rectAContainsD:Boolean = rectA.containsRect(rectD); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the Rectangle object that you specify is 
	contained by this Rectangle object; otherwise <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>The Rectangle object being checked.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Determines if the Rectangle object specified by the rect parameter is contained
	within this Rectangle object.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Determines whether the Rectangle object specified by the <codeph>rect</codeph> parameter is contained
	within this Rectangle object. A Rectangle object is said to contain another if the second 
	Rectangle object falls entirely within the boundaries of the first.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:equals"><apiName>equals</apiName><shortdesc>
	Determines whether the object specified in the toCompare parameter is
	equal to this Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Even though the method signature only expects an abstract Object
	only other Rectangle instances will ever be treated as equal.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	var nonRect:Object = new Object();
	nonRect.x = 0;
	nonRect.y = 0;
	nonRect.width = 50;
	nonRect.height = 100;
	trace(rect_1.equals(nonRect));
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the object has exactly the same values for the 
	<codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, and <codeph>height</codeph> properties 
	as this Rectangle object; otherwise <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>The rectangle to compare to this Rectangle object.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Determines if the object specified in the toCompare parameter is equal to this 
	Rectangle object.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Determines whether the object specified in the <codeph>toCompare</codeph> parameter is
	equal to this Rectangle object. This method compares the <codeph>x</codeph>, <codeph>y</codeph>,
	<codeph>width</codeph>, and <codeph>height</codeph> properties of an object against the same properties 
	of this Rectangle object.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflate"><apiName>inflate</apiName><shortdesc>
	Increases the size of the Rectangle object by the specified amounts, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and increase its <code>width</code> by 16 ~~ 2 (32) and it's <code>height</code> by 32 ~~ 2 (64)
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.toString()); // (x=1, y=2, w=4, h=8)
	rect.inflate(16, 32);
	trace(rect.toString()); // (x=-15, y=-30, w=36, h=72)	
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The value to be added to the left and the right of the Rectangle object. The following
	equation is used to calculate the new width and position of the rectangle:
	
	<codeblock>
	x -= dx;
	width += 2 ~~ dx;
	</codeblock>
	
	</apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The value to be added to the top and the bottom of the Rectangle. The
	following equation is used to calculate the new height and position of the rectangle:
	
	<codeblock>
	y -= dy;
	height += 2 ~~ dy;
	</codeblock>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Increases the size of the Rectangle object by the specified amounts, in pixels. The center point of the 
	Rectangle object stays the same, and its size increases to the left and right by the 
	<codeph>dx</codeph> value, and to the top and the bottom by the <codeph>dy</codeph> value.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflatePoint"><apiName>inflatePoint</apiName><shortdesc>
	 Increases the size of the Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and inflate it by the <i>x</i> <i>horizontal</i> and <i>y</i> <i>vertical</i> amounts found in Point
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(0, 0, 2, 5);
	 var myPoint:Point = new Point(2, 2);
	 rect.inflatePoint(myPoint);
	 trace(rect.toString()); // (x=-2, y=-2, w=6, h=9)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The <codeph>x</codeph> property of this Point object is used to increase the 
	 horizontal dimension of the Rectangle object. The <codeph>y</codeph> property 
	 is used to increase the vertical dimension of the Rectangle object.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Increases the size of the Rectangle object using a Point object as a parameter.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Increases the size of the Rectangle object. 
	 This method is similar to the <codeph>Rectangle.inflate()</codeph> method
	 except it takes a Point object as a parameter.
	 
	  <p>The following two code examples give the same result:</p>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 var pt1:Point = new Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 var pt1 = new air.Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:intersection"><apiName>intersection</apiName><shortdesc>
	If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle 
	object, returns the area of intersection as a Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>What area overlaps <code>rect_1</code> between <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 50);
	var rect_2:Rectangle = new Rectangle(25, 25, 100, 100);
	var intersectingArea:Rectangle = rect_1.intersection(rect_2);
	trace(intersectingArea.toString()); // (x=25, y=25, w=25, h=25)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Rectangle object that equals the area of intersection. If the rectangles do not 
	intersect, this method returns an empty Rectangle object; that is, a rectangle with its <codeph>x</codeph>,
	<codeph>y</codeph>, <codeph>width</codeph>, and <codeph>height</codeph> properties set to 0.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>The Rectangle object to compare against to see if it intersects with
	this Rectangle object.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Returns the area of intersection.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	If the Rectangle object specified in the <codeph>toIntersect</codeph> parameter intersects with this Rectangle 
	object, returns the area of intersection as a Rectangle object. 
	If the rectangles do not intersect, this method returns an empty Rectangle object with its properties 
	set to 0.
	
    <p><adobeimage alt="The resulting intersection rectangle." href="../../images/rectangle_intersect.jpg"/></p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:intersects"><apiName>intersects</apiName><shortdesc>
	Determines whether the object specified in the toIntersect parameter intersects
	with this Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Does <code>rect_1</code> intersect with <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(59, 59, 50, 50);
	var rectC:Rectangle = new Rectangle(60, 60, 50, 50);
	var rectAIntersectsB:Boolean = rectA.intersects(rectB);
	var rectAIntersectsC:Boolean = rectA.intersects(rectC);
	trace(rectAIntersectsB); // true
	trace(rectAIntersectsC); // false
	
	var firstPixel:Rectangle = new Rectangle(0, 0, 1, 1);
	var adjacentPixel:Rectangle = new Rectangle(1, 1, 1, 1);
	var pixelsIntersect:Boolean = firstPixel.intersects(adjacentPixel);
	trace(pixelsIntersect); // false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the specified object intersects with this Rectangle object; 
	otherwise <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>The Rectangle object to compare against this Rectangle object. 
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Determines if the object specified in the toIntersect parameter intersects
	with this Rectangle object.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Determines whether the object specified in the <codeph>toIntersect</codeph> parameter intersects
	with this Rectangle object. This method checks the <codeph>x</codeph>, <codeph>y</codeph>,
	<codeph>width</codeph>, and <codeph>height</codeph> properties of the specified Rectangle object to see 
	if it intersects with this Rectangle object.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:isEmpty"><apiName>isEmpty</apiName><shortdesc>
	Determines whether or not this Rectangle object is empty.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it become empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.isEmpty()); // false
	rect.width = 0;
	trace(rect.isEmpty()); // true
	rect.width = 4;
	trace(rect.isEmpty()); // false
	rect.height = 0;
	trace(rect.isEmpty()); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the Rectangle object's width or height is less than
	or equal to 0; otherwise <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Determines whether or not this Rectangle object is empty. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offset"><apiName>offset</apiName><shortdesc>
	 Adjusts the location of the Rectangle object, as determined by its top-left corner,
	 by the specified amounts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and offset it's <i>x</i> and <i>y</i> values by 5 and 10 respectively
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	 rect.offset(16, 32);
	 trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Moves the <i>x</i> value of the Rectangle object by this amount.
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Moves the <i>y</i> value of the Rectangle object by this amount.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Adjusts the location of the Rectangle object.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Adjusts the location of the Rectangle object, as determined by its top-left corner,
	 by the specified amounts.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offsetPoint"><apiName>offsetPoint</apiName><shortdesc>
	 Adjusts the location of the Rectangle object using a Point object as a parameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Offset a Rectangle by using the values found in a Point
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var myPoint:Point = new Point(16, 32);
	rect.offsetPoint(myPoint);
	trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>A Point object to use to offset this Rectangle object.
	 
	</apiDesc></apiParam><apiTipTexts><apiTipText>Adjusts the location of the Rectangle object using a Point object as a parameter.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Adjusts the location of the Rectangle object using a Point object as a parameter. 
	 This method is similar to the <codeph>Rectangle.offset()</codeph> method, except that it takes a Point 
	 object as a parameter.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:setEmpty"><apiName>setEmpty</apiName><shortdesc>
	Sets all of the Rectangle object's properties to 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.isEmpty()); // false
	rect.setEmpty();
	trace(rect.isEmpty()); // true
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Sets all properties to 0.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Sets all of the Rectangle object's properties to 0. A Rectangle object is empty if its width or 
	height is less than or equal to 0.
	
	<p> This method sets the values of the <codeph>x</codeph>, <codeph>y</codeph>, 
	<codeph>width</codeph>, and <codeph>height</codeph> properties to 0.</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:toString"><apiName>toString</apiName><shortdesc>
	Builds and returns a string that lists the horizontal and vertical positions
	and the width and height of the Rectangle object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Concatenate a String representation of <code>rect_1</code> with some helpful 
	debugging text.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	trace("Rectangle 1 : " + rect_1.toString()); // Rectangle 1 : (x=0, y=0, w=50, h=100)
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A string listing the value of each of the following properties of the Rectangle object: 
	<codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, and <codeph>height</codeph>.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Builds and returns a string that lists the horizontal and vertical positions
	and the width and height of the Rectangle object.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:union"><apiName>union</apiName><shortdesc> 
	 Adds two rectangles together to create a new Rectangle object, by 
	 filling in the horizontal and vertical space between the two rectangles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle out of the Union of two others.
	<p>For example, consider a rectangle with properties <code>x=20</code>, <code>y=50</code>, <code>width=60</code>, and 
	<code>height=30</code> (20, 50, 60, 30) and a second rectangle with properties (150, 130, 50, 30). 
	The union of these two rectangles would be a larger rectangle encompassing the two rectangles 
	with the properties (20, 50, 180, 110).</p>
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(20, 50, 60, 30);
	var rect_2:Rectangle = new Rectangle(150, 130, 50, 30);
	var combined:Rectangle = rect_1.union(rect_2);
	trace(combined.toString()); // (x=20, y=50, w=180, h=110)
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new Rectangle object that is the union of the two rectangles.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toUnion</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>A Rectangle object to add to this Rectangle object.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Adds two rectangles together to create a new Rectangle object.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc> 
	 Adds two rectangles together to create a new Rectangle object, by 
	 filling in the horizontal and vertical space between the two rectangles.
	 
    <p><adobeimage alt="The resulting union rectangle." href="../../images/rectangle_union.jpg"/></p>
	<p><b>Note:</b> The <codeph>union()</codeph> method ignores rectangles with <codeph>0</codeph> 
	as the height or width value, such as: <codeph>var rect2:Rectangle = new Rectangle(300,300,50,0);</codeph></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Rectangle:height"><apiName>height</apiName><shortdesc>
	The height of the rectangle, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>width</i> property 
	from 10 to 20. Notice that <code>rect.right</code> is also
	changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The height of the rectangle in pixels.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The height of the rectangle, in pixels. Changing the <codeph>height</codeph> value of a Rectangle
	object has no effect on the <codeph>x</codeph>, <codeph>y</codeph>, and
	<codeph>width</codeph> properties.
	
    <p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:width"><apiName>width</apiName><shortdesc>
	The width of the rectangle, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Rectangle object and change its <code>width</code> property 
	from 10 to 20. Notice that <code>rect.right</code> also
	changes.

	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The width of the rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The width of the rectangle, in pixels. Changing the <codeph>width</codeph> value of a Rectangle object
	has no effect on the <codeph>x</codeph>, <codeph>y</codeph>, and <codeph>height</codeph> 
	properties.
	
	<p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:x"><apiName>x</apiName><shortdesc>
	The x coordinate of the top-left corner of the rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>x</i> property 
	to 10. Notice that <code>rect.left</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.x); // 0
	trace(rect.left); // 0
	rect.x = 10;
	trace(rect.x); // 10
	trace(rect.left); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The x coordinate of the top-left corner of the rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
	the value of the <codeph>x</codeph> property of a Rectangle object has no effect on the 
	<codeph>y</codeph>, 
	<codeph>width</codeph>, and <codeph>height</codeph> properties. 
	
	<p>The value of the <codeph>x</codeph> property is equal to the value of the 
	<codeph>left</codeph> property.</p>
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/left"><linktext>left</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:y"><apiName>y</apiName><shortdesc>
	The y coordinate of the top-left corner of the rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>y</i> property
	to 10. Notice that <code>rect.top</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.y); // 0
	trace(rect.top); // 0
	rect.y = 10;
	trace(rect.y); // 10
	trace(rect.top); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The y coordinate of the top-left corner.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
	the value of the <codeph>y</codeph> property of a Rectangle object has no effect on the  
	<codeph>x</codeph>, <codeph>width</codeph>, and <codeph>height</codeph> properties.
	
	<p>The value of the <codeph>y</codeph> property is equal to the value of 
	the <codeph>top</codeph> property.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link><link href="flash.geom.xml#Rectangle/top"><linktext>top</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottom:get"><apiName>bottom</apiName><shortdesc>
	The sum of the y and 
	height properties.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>bottom</i> property 
	from 15 to 30. Notice that <code>rect.height</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.height); // 10
	trace(rect.bottom); // 15
	rect.bottom = 30;
	trace(rect.height); // 25
	trace(rect.bottom); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The sum of the y and height properties.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The sum of the <codeph>y</codeph> and 
	<codeph>height</codeph> properties.
	
    <p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottomRight:get"><apiName>bottomRight</apiName><shortdesc>
	The location of the Rectangle object's bottom-right corner, determined by the values of the right and 
	bottom properties.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>bottomRight</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.bottom); // 5
	trace(rect.right); // 10
	var myBottomRight:Point = rect.bottomRight;
	trace(myBottomRight.x); // 5
	trace(myBottomRight.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>The location of the Rectangle object's bottom-right corner determined by the right 
	and bottom properties.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The location of the Rectangle object's bottom-right corner, determined by the values of the <codeph>right</codeph> and 
	<codeph>bottom</codeph> properties.
	
    <p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:left:get"><apiName>left</apiName><shortdesc>
	The x coordinate of the top-left corner of the rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>left</i> property and notice that 
	<code>rect.x</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.left); // 0
	trace(rect.x); // 0
	rect.left = 10;
	trace(rect.left); // 10
	trace(rect.x); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The x coordinate of the top-left corner of the rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
	the <codeph>left</codeph> property of a Rectangle object has no effect on the <codeph>y</codeph> 
	and <codeph>height</codeph> properties. However it does affect the <codeph>width</codeph> 
	property, whereas changing the <codeph>x</codeph> value does <i>not</i> affect the 
	<codeph>width</codeph> property.
	
	<p>The value of the <codeph>left</codeph> property is equal to the value of the 
	<codeph>x</codeph> property.</p>
	
	
    <p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:right:get"><apiName>right</apiName><shortdesc>
	The sum of the x and 
	width properties.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>right</i> property 
	from 15 to 30. Notice that <code>rect.width</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.right = 30;
	trace(rect.width); // 25
	trace(rect.right); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The sum of the x and width properties.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The sum of the <codeph>x</codeph> and 
	<codeph>width</codeph> properties.
	
    <p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:size:get"><apiName>size</apiName><shortdesc>
	The size of the Rectangle object, expressed as a Point object with the values 
	of the width and height properties.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Rectangle, retrieves it's <code>size</code>,
	changes the <code>size</code> and sets the new values on the Rectangle instance.
	It is critical to remember that the <code>Point</code> object used by <code>size</code>
	uses x and y values to represent the <code>width</code> and <code>height</code> properties
	of the Rectangle.
	<listing version="2.0">
	import flash.geom.Rectangle;
	import flash.geom.Point;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	
	var size:Point = rect.size;
	trace(size.x); // 4;
	trace(size.y); // 8;
	
	size.x = 16;
	size.y = 32;
	rect.size = size;
	trace(rect.x); // 1
	trace(rect.y); // 2
	trace(rect.width); // 16
	trace(rect.height); // 32
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>The size of the Rectangle object, expressed as a Point object with values 
	width, height.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The size of the Rectangle object, expressed as a Point object with the values 
	of the <codeph>width</codeph> and <codeph>height</codeph> properties.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:top:get"><apiName>top</apiName><shortdesc>
	The y coordinate of the top-left corner of the rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>top</i> property and notice that 
	<code>rect.y</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.top); // 0
	trace(rect.y); // 0
	rect.top = 10;
	trace(rect.top); // 10
	trace(rect.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>The y coordinate of the top-left corner of the rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
	the <codeph>top</codeph> property of a Rectangle object has no effect on the <codeph>x</codeph> 
	and <codeph>width</codeph> properties. However it does affect the <codeph>height</codeph> 
	property, whereas changing the <codeph>y</codeph> value does <i>not</i> affect the 
	<codeph>height</codeph> property.
	
	<p>The value of the <codeph>top</codeph> property is equal to the value of the <codeph>y</codeph> property.</p>
	
    <p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:topLeft:get"><apiName>topLeft</apiName><shortdesc>
	The location of the Rectangle object's top-left corner, determined by the x and 
	y coordinates of the point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>topLeft</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(5, 15);
	var myTopLeft:Point = rect.topLeft;
	trace(myTopLeft.x); // 5;
	trace(myTopLeft.y); // 15;
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>The location of the Rectangle object's top-left corner determined by the x and 
	y values of the point.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	The location of the Rectangle object's top-left corner, determined by the <i>x</i> and 
	<i>y</i> coordinates of the point.
	
    <p><adobeimage alt="A rectangle image showing location and measurement properties." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
 The ColorTransform class lets you adjust the color values in a display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The ColorTransform class lets you adjust the color values in a display object. 
 The color adjustment or <i>color transformation</i> can be applied to all four channels: 
 red, green, blue, and alpha transparency.
 
 <p>When a ColorTransform object is applied to a display object, a new value for each color 
 channel is calculated like this:</p>
 
 <ul>
 <li>New red value = (old red value * <codeph>redMultiplier</codeph>) + <codeph>redOffset</codeph></li>
 <li>New green value = (old green value * <codeph>greenMultiplier</codeph>) + 
 <codeph>greenOffset</codeph></li>
 <li>New blue value = (old blue value * <codeph>blueMultiplier</codeph>) + <codeph>blueOffset</codeph></li>
 <li>New alpha value = (old alpha value * <codeph>alphaMultiplier</codeph>) + 
 <codeph>alphaOffset</codeph></li>
 </ul>
 
 <p>If any of the color channel values is greater than 255 after the calculation, it is set to 255.
 If it is less than 0, it is set to 0.</p>
 
 <p>You can use ColorTransform objects in the following ways:</p>
 
 <ul>
 
 	<li>In the <codeph>colorTransform</codeph> parameter of the <codeph>colorTransform()</codeph> method
 of the BitmapData class</li>
 
 	<li>As the <codeph>colorTransform</codeph> property of a Transform object (which can be
 used as the <codeph>transform</codeph> property of a display object)</li>
 
 </ul>
 
 <p>You must use the <codeph>new ColorTransform()</codeph> constructor to create a 
 ColorTransform object before you can call the methods of the 
 ColorTransform object.</p>
 
 <p>Color transformations do not apply to the background color of a movie clip (such as a loaded SWF 
 object). They apply only to graphics and symbols that are attached to the movie clip.</p>
 
 </apiDesc><example conref="examples\ColorTransformExample.as"> The following example uses the TransformExample class to create a simple sprite
 in the shape of a square filled with a gradient pattern. Each time the user clicks the square, the 
 application transforms the colors of the square sprite, adding to the red color channel and 
 lightening the blue color channel. This is accomplished with the following steps:
 
 <ol>
     <li>The constructor creates a new sprite object <codeph>target</codeph>.</li>
 
     <li>The <codeph>CustomButton()</codeph> constructor calls the <codeph>draw()</codeph> method, which draws a gradient
         square in the sprite.</li>
 
     <li>The <codeph>CustomButton()</codeph> constructor adds a click event listener for the sprite, which is handled by the 
             <codeph>clickHandler()</codeph> method.  </li>
 
     <li>In the <codeph>clickHandler()</codeph> method, two properties are set to the  
         <codeph>redOffset</codeph> and <codeph>blueOffset</codeph> properties of the current 
         color transformation. Each is adjusted by 25. Then the <codeph>transform.colorTransform</codeph> 
         property of the square sprite is modified to use the new offset values.
         Each time the user clicks the square, the call to the <codeph>clickHandler()</codeph> method modifies 
         the color of the square, by augmenting its red color value and diminishing its blue color value.  </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class ColorTransformExample extends Sprite {
        public function ColorTransformExample() {
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var rOffset:Number = transform.colorTransform.redOffset + 25;
            var bOffset:Number = transform.colorTransform.redOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);
        }
    }
}    
</codeblock></example></apiClassifierDetail><related-links><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.display.xml#BitmapData/colorTransform()"><linktext>flash.display.BitmapData.colorTransform()</linktext></link></related-links><apiConstructor id="flash.geom:ColorTransform:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
	 Creates a ColorTransform object for a display object with the specified 
	 color channel values and alpha values.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new ColorTransform, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>The value for the red multiplier, in the range from 0 to 1.
	 </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>The value for the green multiplier, in the range from 0 to 1.
	 </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>The value for the blue multiplier, in the range from 0 to 1.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>The value for the alpha transparency multiplier, in the range from 0 to 1.
	 </apiDesc></apiParam><apiParam><apiItemName>redOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The offset value for the red color channel, in the range from -255 to 255.
	 </apiDesc></apiParam><apiParam><apiItemName>greenOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The offset value for the green color channel, in the range from -255 to 255.
	 </apiDesc></apiParam><apiParam><apiItemName>blueOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The offset for the blue color channel value, in the range from -255 to 255.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The offset for alpha transparency channel value, in the range from -255 to 255.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Creates a ColorTransform object for a display object.
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Creates a ColorTransform object for a display object with the specified 
	 color channel values and alpha values. 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:ColorTransform:concat"><apiName>concat</apiName><shortdesc>
	 Concatenates the ColorTranform object specified by the second parameter
	 with the current ColorTransform object and sets the
	 current object as the result, which is an additive combination of the two color transformations.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example concatenates the ColorTransform object <code>colorTrans_2</code>
	to <code>colorTrans_1</code> resulting in a full red offset combined with a .5 alpha multiplier.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans_1:ColorTransform = new ColorTransform(1, 1, 1, 1, 255, 0, 0, 0);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var colorTrans_2:ColorTransform = new ColorTransform(1, 1, 1, .5, 0, 0, 0, 0);
	trace(colorTrans_2);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	colorTrans_1.concat(colorTrans_2);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans_1;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>The ColorTransform object to be combined with the current ColorTransform object.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Concatenates the ColorTranform object specified by the <codeph>second</codeph> parameter
	 with the current ColorTransform object and sets the
	 current object as the result, which is an additive combination of the two color transformations. 
	 When you apply the concatenated ColorTransform object, the effect is the same as applying the 
	 <codeph>second</codeph> color transformation after the <i>original</i> color transformation.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:ColorTransform:toString"><apiName>toString</apiName><shortdesc>
	 Formats and returns a string that describes all of the properties of the 
	 ColorTransform object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and calls its <code>toSting()</code> method.  This method results in a string with the format
	(redMultiplier=RM, greenMultiplier=GM, blueMultiplier=BM, alphaMultiplier=AM, redOffset=RO, greenOffset=GO, blueOffset=BO, alphaOffset=AO).
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform(1, 2, 3, 4, -255, -128, 128, 255);
 	trace(colorTrans.toString());		// (redMultiplier=1, greenMultiplier=2, blueMultiplier=3, alphaMultiplier=4, redOffset=-255, greenOffset=-128, blueOffset=128, alphaOffset=255)
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A string that lists all of the properties of the ColorTransform object.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Formats and returns a string that describes all of the properties of the 
	 ColorTransform object.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:ColorTransform:alphaMultiplier"><apiName>alphaMultiplier</apiName><shortdesc>
	 A decimal value that is multiplied with the alpha transparency channel value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	import flash.geom.Transform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaMultiplier);		// 1
	
	colorTrans.alphaMultiplier = .5;	
	trace(colorTrans.alphaMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A decimal value that is multiplied with the alpha transparency channel value.
	 
	 <p>If you set the alpha transparency value of a display object directly by using the 
	 <codeph>alpha</codeph> property of the DisplayObject instance, it affects the value of the 
	 <codeph>alphaMultiplier</codeph> property of that display object's <codeph>transform.colorTransform</codeph> 
	 property.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/alpha"><linktext>flash.display.DisplayObject.alpha</linktext></link></related-links></apiValue><apiValue id="flash.geom:ColorTransform:alphaOffset"><apiName>alphaOffset</apiName><shortdesc>
	 A number from -255 to 255 that is added to the alpha transparency channel value after it has 
	 been multiplied by the alphaMultiplier value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaOffset</code> from 0 to -128.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaOffset);			// 0
	
	colorTrans.alphaOffset = -128;
	trace(colorTrans.alphaOffset);			// -128
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>A number from -255 to 255 that is added to the alpha transparency channel value after it has been 
	 multiplied by the alphaMultiplier value.
   	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 A number from -255 to 255 that is added to the alpha transparency channel value after it has 
	 been multiplied by the <codeph>alphaMultiplier</codeph> value.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueMultiplier"><apiName>blueMultiplier</apiName><shortdesc>
	 A decimal value that is multiplied with the blue channel value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueMultiplier);		// 1
	
	colorTrans.blueMultiplier = .5;
	trace(colorTrans.blueMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x0000FF);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A decimal value that is multiplied with the blue channel value.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueOffset"><apiName>blueOffset</apiName><shortdesc>
	 A number from -255 to 255 that is added to the blue channel value after it has 
	 been multiplied by the blueMultiplier value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueOffset);			// 0
	
	colorTrans.blueOffset = 255;
	trace(colorTrans.blueOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>A number from -255 to 255 that is added to the blue channel value after it has 
	 been multiplied by the blueMultiplier value.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 A number from -255 to 255 that is added to the blue channel value after it has 
	 been multiplied by the <codeph>blueMultiplier</codeph> value.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenMultiplier"><apiName>greenMultiplier</apiName><shortdesc>
	 A decimal value that is multiplied with the green channel value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenMultiplier);		// 1
	
	colorTrans.greenMultiplier = .5;
	trace(colorTrans.greenMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x00FF00);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A decimal value that is multiplied with the green channel value.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenOffset"><apiName>greenOffset</apiName><shortdesc>
	 A number from -255 to 255 that is added to the green channel value after it has 
	 been multiplied by the greenMultiplier value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.greenOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>A number from -255 to 255 that is added to the green channel value after it has 
	 been multiplied by the greenMultiplier value.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 A number from -255 to 255 that is added to the green channel value after it has 
	 been multiplied by the <codeph>greenMultiplier</codeph> value.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redMultiplier"><apiName>redMultiplier</apiName><shortdesc>
	 A decimal value that is multiplied with the red channel value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform();
 	trace(colorTrans.redMultiplier);		// 1
 	
 	colorTrans.redMultiplier = .5;
 	trace(colorTrans.redMultiplier);		// .5
 	
 	var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
 	var trans:Transform = new Transform(rect);
 	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A decimal value that is multiplied with the red channel value. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redOffset"><apiName>redOffset</apiName><shortdesc>
	 A number from -255 to 255 that is added to the red channel value after it has been 
	 multiplied by the redMultiplier value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.redOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.redOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>A number from -255 to 255 that is added to the red channel value after it 
	 has been multiplied by the redMultiplier value.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 A number from -255 to 255 that is added to the red channel value after it has been 
	 multiplied by the <codeph>redMultiplier</codeph> value.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:color:get"><apiName>color</apiName><shortdesc>
	 The RGB color value for a ColorTransform object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>This example sets the RGB color value for the movie clip <code>my_mc</code>.<span class="flashonly"> To see this code work, place a movie clip on the Stage with the instance name <code>my_mc</code>. Then place the following code on Frame 1 in the main Timeline and select Control &gt; Test Movie:</span>
	 <pre>
	 <code>var my_color:Color = new Color(my_mc);</code>
	 <code>my_color.setRGB(0xFF0000); // my_mc turns red</code>
	 </pre>
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 The RGB color value for a ColorTransform object.
	 
	 <p>When you set this property, it changes the three color offset values (<codeph>redOffset</codeph>, 
	 <codeph>greenOffset</codeph>, and <codeph>blueOffset</codeph>)
	 accordingly, and it sets the three color multiplier values (<codeph>redMultiplier</codeph>, 
	 <codeph>greenMultiplier</codeph>, and <codeph>blueMultiplier</codeph>) to 0. 
	 The alpha transparency multiplier and offset values do not change.</p>
	 
	 <p>When you pass a value for this property, use the format 0x<i>RRGGBB</i>.  
	 <i>RR</i>, <i>GG</i>, and <i>BB</i> each consist 
	 of two hexadecimal digits that specify the offset of each color component. The 0x 
	 tells the ActionScript compiler that the number is a hexadecimal value.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Point"><apiName>Point</apiName><shortdesc>
 The Point object represents a location in a two-dimensional coordinate system, where x
 represents the horizontal axis and y represents the vertical axis.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>The Point class represents a location in a two-dimensional coordinate system.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The Point object represents a location in a two-dimensional coordinate system, where <i>x</i>
 represents the horizontal axis and <i>y</i> represents the vertical axis. 
 
 <p>The following code creates a point at (0,0):</p>
 
 <codeblock platform="actionscript">var myPoint:Point = new Point();</codeblock>
 
 <codeblock platform="javascript">var myPoint = new Point();</codeblock>
 
 <p>Methods and properties of the following classes use Point objects:</p>
 
 <ul>
 
 <li platform="actionscript">BitmapData</li>
 
 <li platform="actionscript">DisplayObject</li>
 
 <li platform="actionscript">DisplayObjectContainer</li>
 
 <li platform="actionscript">DisplacementMapFilter</li>
 
 <li>NativeWindow</li>
 
 <li platform="actionscript">Matrix</li>
 
 <li>Rectangle</li>
 
 </ul>
 
 <p>You can use the <codeph>new Point()</codeph> constructor to create a 
 Point object.</p>
 
 </apiDesc><example conref="examples\PointExample.as"> The following example uses the PointExample class to create a number of new Point
 objects at various <i>x,y</i> coordinates and then uses the <codeph>trace()</codeph> method to output the  
 results of various class methods.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Point;

    public class PointExample extends Sprite {

        public function PointExample() {
        var point1:Point = new Point();
        trace(point1);  // (x=0, y=0)
        
        var point2:Point = new Point(6, 8);
        trace(point2); // (x=6, y=8)
        
        trace(Point.interpolate(point1, point2, 0.5)); // (x=3, y=4)
        
        trace(Point.distance(point1, point2)); // 10
        
        trace(point1.add(point2)); // (x=6, y=8)
        
        var point3:Point = point2.clone();
        trace(point2.equals(point3)); // true
        
        point3.normalize(2.5);
        trace(point3); // (x=1.5, y=2)
        
        trace(point2.subtract(point3)); // (x=4.5, y=6)
        
        trace(point1.offset(2, 3)); // 
        
        var angle:Number = Math.PI * 2 * (30 / 360); // 30Â°
        trace(Point.polar(4, angle)) // (x=3.464101615137755, y=1.9999999999999998)   
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links><apiConstructor id="flash.geom:Point:Point"><apiName>Point</apiName><shortdesc>
	 Creates a new point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The first example creates <code>point_1</code> with the default constructor.
	 <listing version="2.0">
	 import flash.geom.Point;
	 var point_1:Point = new Point();
	 trace(point_1.x); // 0
	 trace(point_1.y); // 0
	 </listing>
	 The second example creates <code>point_2</code> with the coordinates x = 1 and y = 2.
     <listing version="2.0">
	 import flash.geom.Point;
	 var point_2:Point = new Point(1, 2);
	 trace(point_2.x); // 1
	 trace(point_2.y); // 2
	 </listing>
	 
	  
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The horizontal coordinate. 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The vertical coordinate. 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Creates a new point. If you pass no parameters to this method, a point is created at (0,0).
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Point:add"><apiName>add</apiName><shortdesc>
      	 Adds the coordinates of another point to the coordinates of this point to create a new point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>resultPoint</code> by adding <code>point_2</code> to 
	 <code>point_1</code>.
   	 
   	 <listing version="2.0">
   	 import flash.geom.Point;
   	 var point_1:Point = new Point(4, 8);
   	 var point_2:Point = new Point(1, 2);
   	 var resultPoint:Point = point_1.add(point_2);
   	 trace(resultPoint.toString()); // (x=5, y=10)
   	 </listing>
	 
   	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The new point.
   	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point to be added.
	 
      	 </apiDesc></apiParam></apiOperationDef><apiDesc>
      	 Adds the coordinates of another point to the coordinates of this point to create a new point.
	 
      	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:clone"><apiName>clone</apiName><shortdesc>
	 Creates a copy of this Point object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a <code>clonedPoint</code> from the values found in 
 	 <code>myPoint</code>.  The <code>clonedPoint</code> contains all the
	 the values from <code>myPoint</code> but is not the same object.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(1, 2);
	 var clonedPoint:Point = myPoint.clone();
	 trace(clonedPoint.x); // 1
	 trace(clonedPoint.y); // 2
	 trace(myPoint.equals(clonedPoint)); // true
	 trace(myPoint === clonedPoint); // false
	 </listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The new Point object.
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Creates a copy of the Point object.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Creates a copy of this Point object.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:distance"><apiName>distance</apiName><shortdesc>
	 Returns the distance between pt1 and pt2.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>The distance between the first and second points.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The first point.
	 </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The second point.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Returns the distance between <codeph>pt1</codeph> and <codeph>pt2</codeph>.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:equals"><apiName>equals</apiName><shortdesc>
	 Determines whether two points are equal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A value of <codeph>true</codeph> if the object is equal to this Point object; <codeph>false</codeph> if it is not equal.
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point to be compared.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Determines whether two points are equal. Two points are equal if they have the same <i>x</i> and
	 <i>y</i> values.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:interpolate"><apiName>interpolate</apiName><shortdesc>
    Determines a point between two specified points.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example locates the interpolated point (<code>interpolatedPoint</code>) half way (50%) between <code>point_1</code> and <code>point_2</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(-100, -100);
   	var point_2:Point = new Point(50, 50);
   	var interpolatedPoint:Point = Point.interpolate(point_1, point_2, .5);
   	trace(interpolatedPoint.toString()); // (x=-25, y=-25)
   	</listing> 
	
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>The new, interpolated point. 
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The first point.
	</apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The second point.
	</apiDesc></apiParam><apiParam><apiItemName>f</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The level of interpolation between the two points. Indicates where the new point will be, along the line 
	between <codeph>pt1</codeph> and <codeph>pt2</codeph>. If <codeph>f</codeph>=1, <codeph>pt1</codeph> is returned; if 
	<codeph>f</codeph>=0, <codeph>pt2</codeph> is returned.
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    Determines a point between two specified points. The parameter <codeph>f</codeph> 
	determines where the new interpolated point is located relative to the two end points 
	specified by parameters <codeph>pt1</codeph> and <codeph>pt2</codeph>. The closer the value of the parameter
	<codeph>f</codeph> is to <codeph>1.0</codeph>, the closer the interpolated point is to the
	first point (parameter <codeph>pt1</codeph>). The closer the value of the parameter <codeph>f</codeph> is
	to 0, the closer the interpolated point is to the second point (parameter <codeph>pt2</codeph>).
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:normalize"><apiName>normalize</apiName><shortdesc>
	Scales the line segment between (0,0) and the current point to a set length.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example extends the length of the <code>normalizedPoint</code> object from 5 to 10.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var normalizedPoint:Point = new Point(3, 4);
   	trace(normalizedPoint.length); // 5
   	trace(normalizedPoint.toString()); // (x=3, y=4)
   	normalizedPoint.normalize(10);
   	trace(normalizedPoint.length); // 10
   	trace(normalizedPoint.toString()); // (x=6, y=8)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The normalized point.
	
   	</apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The scaling value. For example, if the current point is (0,5), 
	and you normalize it to 1, the point returned is at (0,1).
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Scales the line segment between (0,0) and the current point to a set length. 
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:offset"><apiName>offset</apiName><shortdesc>
	 Offsets the Point object by the specified amount.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The amount by which to offset the horizontal coordinate, <i>x</i>.
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The amount by which to offset the vertical coordinate, <i>y</i>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Offsets the Point object by the specified amount. The value of <codeph>dx</codeph> is added
	 to the original value of <i>x</i> to create the new <i>x</i> value. The value
	 of <codeph>dy</codeph> is added to the original value of <i>y</i> to create the new <i>y</i> value.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:polar"><apiName>polar</apiName><shortdesc>
	Converts a pair of polar coordinates to a Cartesian point coordinate.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>cartesianPoint</code> from the value of <code>angleInRadians</code>
	and a line length of 5.  The <code>angleInRadians</code> value equal to Math.atan(3/4)
   	is used because of the characteristics of right triangles with sides that 
   	have ratios of 3:4:5.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 5;
   	var angleInRadians:Number = Math.atan(3/4);
   	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // (x=4, y=3)
   	</listing>
	
	When computers work with transcendental numbers such as pi, some round-off
	error occurs because floating-point arithmetic has only finite precision.
	When you use <code>Math.PI</code>, consider using the <code>Math.round()</code> function, as shown 
	in the following example.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 10;
   	var angleInRadians:Number = Math.PI;
    	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // should be (x=-10, y=0), but is (x=-10, y=1.22460635382238e-15)
   	trace(Math.round(cartesianPoint.y)); // 0
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>The Cartesian point.
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The length coordinate of the polar pair.
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The angle, in radians, of the polar pair.
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Converts a pair of polar coordinates to a Cartesian point coordinate.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:subtract"><apiName>subtract</apiName><shortdesc>
	Subtracts the coordinates of another point from the coordinates of this point to create a new 
   	point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>point_3</code> by subtracting <code>point_2</code> from <code>point_1</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(4, 8);
   	var point_2:Point = new Point(1, 2);
   	var resultPoint:Point = point_1.subtract(point_2);
   	trace(resultPoint.toString()); // (x=3, y=6)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The new point.
   	
     	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>The point to be subtracted.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Subtracts the coordinates of another point from the coordinates of this point to create a new 
   	point.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:toString"><apiName>toString</apiName><shortdesc>
	 Returns a string that contains the values of the x and y coordinates.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The string representation of the coordinates.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Returns a string that contains the values of the x and y coordinates. 

	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Returns a string that contains the values of the <i>x</i> and <i>y</i> coordinates.
	 
	 The string has the form <codeph>"(x=<i>x</i>, y=<i>y</i>)"</codeph>, so calling the <codeph>toString()</codeph>
	 method for a point at 23,17 would return <codeph>"(x=23, y=17)"</codeph>.
   	 
   	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Point:x"><apiName>x</apiName><shortdesc>
	 The horizontal coordinate of the point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>x</i> (horizontal) coordinate of <code>myPoint</code> and gets <code>myX</code> from <code>myPoint.x</code>.
	 
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.x); // 0
	 myPoint.x = 5;
	 trace(myPoint.x); // 5
	 var myX:Number = myPoint.x;
	 trace(myX); // 5
     </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The horizontal coordinate of the point. The default value is 0.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:y"><apiName>y</apiName><shortdesc>
	 The vertical coordinate of the point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>y</i> (vertical) coordinate of <code>myPoint</code> and gets <code>myY</code> from <code>myPoint.y</code>.
     
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.y); // 0
	 myPoint.y = 5;
	 trace(myPoint.y); // 5
	 var myY:Number = myPoint.y;
	 trace(myY); // 5
  	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The vertical coordinate of the point. The default value is 0.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:length:get"><apiName>length</apiName><shortdesc>
	 The length of the line segment from (0,0) to this point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Point, <code>myPoint</code>, and determines the length of a line from (0, 0) to that Point.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(3,4);
	 trace(myPoint.length); // 5
	 </listing>
	 
   	  
   	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The length of the line segment from (0,0) to this point. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point/polar()"><linktext>Point.polar()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc> 
 The PerspectiveProjection class provides an easy way to assign or modify the perspective 
 transformations of a display object and all of its children.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 The PerspectiveProjection class provides an easy way to assign or modify the perspective 
 transformations of a display object and all of its children. For more complex or 
 custom perspective transformations, use the Matrix3D class. While the PerspectiveProjection
 class provides basic three-dimensional presentation properties, the Matrix3D class
 provides more detailed control over the three-dimensional presentation of display objects.
 
 <p>Projection is a way of representing a three-dimensional object in a 
 two-dimensional space, like a cube projected onto a computer screen. Perspective projection uses a viewing 
 frustum (a rectangular pyramid) to model and project a three-dimensional world and its objects 
 on the screen. The viewing frustum becomes increasingly wider as it moves further from the origin 
 of the viewpoint. The origin of the viewpoint could be a camera or the eyes of an observer facing the screen. 
 The projected perspective produces the illusion of three dimensions with depth and distance, 
 where the objects closer to the screen appear larger than the objects farther from the screen.</p>
 
 <p><adobeimage alt="Frustum viewing area" href="../../images/frustum.jpg"/></p>
 
 <p>A default PerspectiveProjection object is a framework defined for perspective transformation 
 of the root object, based on the field of view and aspect ratio (dimensions) of the stage. 
 The projection center, the vanishing point, is set to the center of the stage, which means the 
 three-dimensional display objects disappear toward the center of the stage as they move 
 back in the z axis. The default viewpoint is at point (0,0) looking down the positive 
 z axis. The y-axis points down toward the bottom of the screen. You can
 gain access to the <codeph>root</codeph> display object's perspective projection settings 
 and change the field of view and projection center properties of the <codeph>perspectiveProjection</codeph>
 property through the <codeph>root</codeph> object's <codeph>DisplayObject.transform</codeph> property.</p> 
 
 <p>You can also set a different perspective projection setting for a display object through
 the parent's perspective projection. First, create a PerspectiveProjection object and set 
 its <codeph>fieldOfView</codeph> and <codeph>projectionCenter</codeph> properties. Next, assign the
 PerspectiveProjection object to the parent display object using 
 the <codeph>DisplayObject.transform</codeph> property. The specified projection matrix and transformation
 will then apply to all the display object's three-dimensional children.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link></related-links><apiConstructor id="flash.geom:PerspectiveProjection:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc>
     Creates an instance of a PerspectiveProjection object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
     </helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Creates an instance of a PerspectiveProjection object. 
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:PerspectiveProjection:toMatrix3D"><apiName>toMatrix3D</apiName><shortdesc>
     Returns the underlying Matrix3D object of the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The underlying Matrix3D object. 
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Returns the underlying Matrix3D object of the display object.  
     
     <p>A display object, like the root object, can have a PerspectiveProjection object without 
     needing a Matrix3D property defined for its transformations. In fact, use either 
     a PerspectiveProjection or a Matrix3D object to specify the perspective transformation.
     If when using the PerspectiveProjection object, a Matrix3D object was needed, the <codeph>toMatrix3D()</codeph> 
     method can retrieve the underlying Matrix3D object of the display object. For example, the 
     <codeph>toMatrix3D()</codeph> method can be used with the <codeph>Utils3D.projectVectors()</codeph> 
     method.</p> 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:PerspectiveProjection:fieldOfView:set"><apiName>fieldOfView</apiName><shortdesc>
     Specifies an angle, as a degree between 0 and 180, for the field of view in three 
     dimensions.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Specifies an angle, as a degree between 0 and 180, for the field of view in three dimensions.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Specifies an angle, as a degree between <codeph>0</codeph> and <codeph>180</codeph>, for the field of view in three 
     dimensions. This value determines how strong the perspective transformation and distortion apply to
     a three-dimensional display object with a non-zero z-coordinate.
     
     <p>A degree close to <codeph>0</codeph> means that the screen's two-dimensional x- and y-coordinates are 
     roughly the same as the three-dimensional x-, y-, and z-coordinates with little or 
     no distortion. In other words, for a small angle, a display object moving down the z axis appears
     to stay near the same size and moves little. </p>
     
     <p>A value close to <codeph>180</codeph> degrees results in a fisheye lens effect: positions 
     with a <codeph>z</codeph> value smaller than <codeph>0</codeph> are magnified, while positions with a 
     <codeph>z</codeph> value larger than <codeph>0</codeph> are minimized. With a large angle, a display object
     moving down the z axis appears to change size quickly and moves a great distance. If the field of view
     is set to <codeph>0</codeph> or <codeph>180</codeph>, nothing is seen on the screen.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:PerspectiveProjection:focalLength:get"><apiName>focalLength</apiName><shortdesc>
     The distance between the eye or the viewpoint's origin (0,0,0) and the display object located 
     in the z axis.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The distance between the eye or the viewpoint's origin (0,0,0) and the display object located 
     in the z axis. During the perspective transformation, the <codeph>focalLength</codeph> is calculated dynamically 
     using the angle of the field of view and the stage's aspect ratio (stage width divided by 
     stage height).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection/fieldOfView"><linktext>fieldOfView</linktext></link></related-links></apiValue><apiValue id="flash.geom:PerspectiveProjection:projectionCenter:set"><apiName>projectionCenter</apiName><shortdesc>
     A two-dimensional point representing the center of the projection, the vanishing point for the display object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
     A two-dimensional point representing the center of the projection, the vanishing point for the display object. 
     
     <p>The <codeph>projectionCenter</codeph> property is an offset to the default registration point that is the 
     upper left of the stage, point (0,0). The default projection transformation center is in the middle of 
     the stage, which means the three-dimensional display objects disappear toward the center of the stage 
     as they move backwards in the z axis.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Orientation3D"><apiName>Orientation3D</apiName><shortdesc>
The Orientation3D class is an enumeration of constant values for representing the orientation style
of a Matrix3D object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The Orientation3D class is an enumeration of constant values for representing the orientation style
of a Matrix3D object. The three types of orientation are Euler angles, axis angle, and quaternion. 
The <codeph>decompose</codeph> and <codeph>recompose</codeph> methods of the Matrix3D object take one of these 
enumerated types to identify the rotational components of the Matrix.

</apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiValue id="flash.geom:Orientation3D:AXIS_ANGLE"><apiName>AXIS_ANGLE</apiName><shortdesc>
    The axis angle orientation uses a combination of an axis and an angle to determine the orientation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>axisAngle</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    The axis angle orientation uses a combination of an axis and an angle to determine the orientation. 
    A line or vector from the center of a three-dimensional globe to the surface is an example of an axis.
    The axis around which the object is rotated is a unit vector that represents any possible direction
    in the three-dimensional space.  The angle represents the magnitude of the rotation 
    about the vector. The direction determines where a display object is facing and the roll angle determines 
    which way is up. You can use Vector3D and the Matrix3D objects to determine 
    the various matrix transformations as well as to determine important three-dimensional programming 
    values such as the distance to the intersection of two objects that can be used to detect simple 
    collision between three-dimensional objects.
    
    <p>The <codeph>Matrix3D.appendRotation()</codeph> and <codeph>Matrix3D.prependRotation()</codeph> methods 
    use the axis angle orientation.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:EULER_ANGLES"><apiName>EULER_ANGLES</apiName><shortdesc> 
    Euler angles, the default orientation for decompose() and recompose() methods, 
    defines the orientation with three separate angles of rotation for each axis.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>eulerAngles</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Defines the orientation with three separate angles of rotation for each axis.
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
    Euler angles, the default orientation for <codeph>decompose()</codeph> and <codeph>recompose()</codeph> methods, 
    defines the orientation with three separate angles of rotation for each axis. Usually,
    a rotation around the x axis is followed by a rotation around the y axis, which is followed by a 
    rotation around the z axis. 
    
    <p>Euler angles can sometimes lead to animation errors because of problems such as singularities when
    rotating around the x axis or gimbal lock. For example, since with Euler angles each axis is handled 
    independently, gimbal lock can occur during the rotation around two or more axes. The axes 
    can become aligned, leading to unexpected results.</p>
    
    <p>The axis rotation properties of the display object perform Euler angles rotation.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:QUATERNION"><apiName>QUATERNION</apiName><shortdesc>
    The quaternion orientation uses complex numbers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>quaternion</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>An orientation in quaternion uses the three axes (x,y,z) and an angle of rotation (w).
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    The quaternion orientation uses complex numbers. An orientation in quaternion is by the three axes of 
    rotation (x,y,z) and an angle of rotation (w).  Quaternion guarantees the shortest, most efficient 
    path for the rotation. It also produces a smooth, gimbal-lock-free rotation. A gimbal lock can occur 
    when during the rotation around two or more axes the axes are aligned, leading to unexpected results. 
    
    <p>The <codeph>Matrix3D.interpolate()</codeph> method uses quaternion.</p> 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>