 
<apiPackage id="flash.media"><apiName>flash.media</apiName><apiDetail/><apiClassifier id="flash.media:SoundCodec"><apiName>SoundCodec</apiName><shortdesc>
The SoundCodec class is an enumeration of constant values used in setting the codec property
of the Microphone class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The SoundCodec class is an enumeration of constant values used in setting the <codeph>codec</codeph> property
of the <codeph>Microphone</codeph> class.

</apiDesc></apiClassifierDetail><apiValue id="flash.media:SoundCodec:NELLYMOSER"><apiName>NELLYMOSER</apiName><shortdesc> 
	Specifies that the Nellymoser codec be used for compressing audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>NellyMoser</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Specifies that the Nellymoser codec be used for compressing audio.
	This constant is the default value of the <codeph>Microphone.codec</codeph> property.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundCodec:SPEEX"><apiName>SPEEX</apiName><shortdesc> 
	Specifies that the Speex codec be used for compressing audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>Speex</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Specifies that the Speex codec be used for compressing audio.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:ID3Info"><apiName>ID3Info</apiName><shortdesc>
	 The ID3Info class contains properties that reflect ID3 metadata.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 The ID3Info class contains properties that reflect ID3 metadata. You can get additional
	 metadata for MP3 files by accessing the <codeph>id3</codeph>
	 property of the Sound class; for example, <codeph>mySound.id3.TIME</codeph>.
	 For more information, see the entry for <codeph>Sound.id3</codeph> and
	 the ID3 tag definitions at <xref href="http://www.id3.org">http://www.id3.org</xref>.
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links><apiValue id="flash.media:ID3Info:album"><apiName>album</apiName><shortdesc>
		 The name of the album; corresponds to the ID3 2.0 tag TALB.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 The name of the album; corresponds to the ID3 2.0 tag TALB.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:artist"><apiName>artist</apiName><shortdesc>
		 The name of the artist; corresponds to the ID3 2.0 tag TPE1.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 The name of the artist; corresponds to the ID3 2.0 tag TPE1.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:comment"><apiName>comment</apiName><shortdesc>
		 A comment about the recording; corresponds to the ID3 2.0 tag COMM.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 A comment about the recording; corresponds to the ID3 2.0 tag COMM.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:genre"><apiName>genre</apiName><shortdesc>
		 The genre of the song; corresponds to the ID3 2.0 tag TCON.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 The genre of the song; corresponds to the ID3 2.0 tag TCON.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:songName"><apiName>songName</apiName><shortdesc>
		 The name of the song; corresponds to the ID3 2.0 tag TIT2.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 The name of the song; corresponds to the ID3 2.0 tag TIT2.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:track"><apiName>track</apiName><shortdesc>
		 The track number; corresponds to the ID3 2.0 tag TRCK.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 The track number; corresponds to the ID3 2.0 tag TRCK.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:year"><apiName>year</apiName><shortdesc>
		 The year of the recording; corresponds to the ID3 2.0 tag TYER.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 The year of the recording; corresponds to the ID3 2.0 tag TYER.
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Microphone"><apiName>Microphone</apiName><shortdesc>
 Use the Microphone class to capture audio from a microphone attached to a computer running 
 Flash Player or Adobe AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Use the Microphone class to capture audio from a microphone attached to a computer running 
 <ph platform="actionScript">Flash Player or</ph> Adobe AIR.
 Use the Microphone class to monitor the audio locally. Use the NetConnection and NetStream classes to transmit the audio 
 to Flash Media Server. Flash Media Server can send the audio to other servers and broadcast it to other clients 
 running <ph platform="actionScript">Flash Player or</ph> Adobe AIR.
 
 <p>
 For information about capturing video, see the Camera class.
 </p>
 
 <p>
 <b>Important: </b>Flash Player displays a Privacy dialog
 box that lets the user choose whether to allow or deny access to
 the microphone. Make sure that your application window size is at least 215 x 138
 pixels, which is the minimum size required to display the
 dialog box.
 </p>
 
 <p>
 To create or reference a Microphone object, use the <codeph>Microphone.getMicrophone()</codeph> method.
 </p>
 
 <p platform="actionscript"><b>Caution: </b>For content outside of the application sandbox, a Privacy dialog
 box is displayed that lets the user choose whether to allow or deny access to
 the microphone. This dialog box requires a minimum application window size of at least 215 x 138
 pixels. For Adobe AIR content inside the application sandbox, access is allowed and the dialog box will not be displayed.</p>
 
 </apiDesc><example conref="examples\MicrophoneExample.as"> The following example captures sound using echo suppression from a microphone after the 
 user allows access to their computer's microphone. 
 The <codeph>Security.showSettings()</codeph> method displays the Flash Player dialog box, which requests
 permission to access the user's microphone. The call to <codeph>setLoopBack(true)</codeph> reroutes
 input to the local speaker, so you can hear the sound while you run the example.
 
 <p>Two listeners listen for <codeph>activity</codeph> and 
 <codeph>status</codeph> events.  The <codeph>activity</codeph> event is dispatched at the
 start and end (if any) of the session and is captured by the <codeph>activityHandler()</codeph>
 method, which traces information on the event.  The <codeph>status</codeph> event is dispatched if
 the attached microphone object reports any status information; it is captured and traced using
 the <codeph>statusHandler()</codeph> method.</p>
 
 <p><b>Note:</b> A microphone must be attached to your computer for this example
 to work correctly.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Microphone;
    import flash.system.Security;

    public class MicrophoneExample extends Sprite {
        public function MicrophoneExample() {
            var mic:Microphone = Microphone.getMicrophone();
            Security.showSettings("2");
            mic.setLoopBack(true);
                    
            if (mic != null) {
                mic.setUseEchoSuppression(true);
                mic.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                mic.addEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }

        private function statusHandler(event:StatusEvent):void {
            trace("statusHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Dispatched when a microphone reports its status.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a microphone reports its status. 
 If the value of the <codeph>code</codeph> property is <codeph>"Microphone.Muted"</codeph>,
 the user has refused to allow the SWF file access to the microphone.
 If the value of the <codeph>code</codeph> property is <codeph>"Microphone.Unmuted"</codeph>,
 the user has allowed the SWF file access to the microphone.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>Microphone.getMicrophone()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Microphone_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Dispatched when a microphone begins or ends a session.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a microphone begins or ends a session. 
 
 <p>
 To specify the amount of sound required to trigger this event
 with an <codeph>activating</codeph> property of <codeph>true</codeph>,
 or the amount of time that must elapse without sound to
 trigger this event with an <codeph>activating</codeph> property of
 <codeph>false</codeph>, use <codeph>Microphone.setSilenceLevel()</codeph>.
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>setSilenceLevel()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.media:Microphone:getMicrophone"><apiName>getMicrophone</apiName><shortdesc>
	 
	 Returns a reference to a Microphone object for capturing audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, Microphone.getMicropone, getMicrophone
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A reference to a Microphone object for capturing audio.
	 
 	 </apiDesc><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>The index value of the microphone.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Returns a reference to a Microphone object for capturing audio.
	 To begin capturing the audio, you must attach the Microphone
	 object to a NetStream object (see <codeph>NetStream.attachAudio()</codeph>).
	 
	 <p>
	 Multiple calls to <codeph>Microphone.get()</codeph> reference the same microphone. 
	 Thus, if your code contains the lines <codeph>mic1 = Microphone.get()</codeph> and 
	 <codeph>mic2 = Microphone.get()</codeph>, both <codeph>mic1</codeph> and <codeph>mic2</codeph> 
	 reference the same (default) microphone.</p>
	 <p>
	 If you want to get the default microphone, you need to call <codeph>getMicrophone()</codeph> with -1. 
	 If you call it without parameters, it will return the first microphone in the list.
	 </p>
	 
	 <p>
	 Use the <codeph>index</codeph> property to get the index value of the current
	 Microphone object. You can then pass this value to other methods of the
	 Microphone class.
	 </p>
	 
	 <p>
	 In general, you should not pass a value for <codeph>index</codeph>. Simply use the 
	 <codeph>Microphone.getMicrophone()</codeph> method to return a reference to the default microphone. 
	 By using the Microphone Settings panel, the user can specify the default 
	 microphone the application should use. If you pass a value for <codeph>index</codeph>, you might 
	 reference a microphone other than the one the user chooses. You can use <codeph>index</codeph> in 
     rare cases—for example, if your application is capturing audio from two microphones 
	 at the same time.
	 </p>
	 
	 <p>
	 When a SWF file tries to access the object returned by <codeph>Microphone.getMicrophone()</codeph>
     —for example, when you call <codeph>NetStream.attachAudio()</codeph>—
	 Flash Player displays a Privacy dialog box that lets the user choose whether to 
	 allow or deny access to the microphone. (Make sure your Stage size is at least 
	 215 x 138 pixels; this is the minimum size Flash Player requires to display the dialog box.)
	 </p>
	 
	 <p>
     When the user responds to this dialog box, a <codeph>status</codeph> event is dispatched
     that indicates the user's response. You can also check the <codeph>Microphone.muted</codeph>
     property to determine if the user has allowed or denied access to the microphone. 
	 </p>
	 
	 <p>
	 If <codeph>Microphone.getMicrophone()</codeph> returns <codeph>null</codeph>, either the microphone is in use 
	 by another application, or there are no microphones installed on the system. To determine 
	 whether any microphones are installed, use <codeph>Microphones.names.length</codeph>. To display 
	 the Flash Player Microphone Settings panel, which lets the user choose the microphone to be 
	 referenced by <codeph>Microphone.getMicrophone</codeph>, use <codeph>Security.showSettings()</codeph>. 
	 
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/event:status"><linktext>Microphone.status</linktext></link><link href="flash.net.xml#NetStream/attachAudio()"><linktext>flash.net.NetStream.attachAudio()</linktext></link><link href="flash.system.xml#Security/showSettings()"><linktext>flash.system.Security.showSettings()</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone:getMicrophone_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when a microphone reports its status. 
	 If the value of the <codeph>code</codeph> property is <codeph>"Microphone.Muted"</codeph>,
	 the user has refused to allow the SWF file access to the user's microphone.
	 If the value of the <codeph>code</codeph> property is <codeph>"Microphone.Unmuted"</codeph>,
	 the user has allowed the SWF file access to the user's microphone.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when a microphone reports its status.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Microphone:setLoopBack"><apiName>setLoopBack</apiName><shortdesc>
	 Routes audio captured by a microphone to the local speakers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>state</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData></apiParam></apiOperationDef><apiDesc>
	 Routes audio captured by a microphone to the local speakers.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.media:Microphone:setSilenceLevel"><apiName>setSilenceLevel</apiName><shortdesc>
	 Sets the minimum input level that should be considered sound and (optionally) the amount
	 of silent time signifying that silence has actually begun.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setSilenceLevel, setSilenceLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>silenceLevel</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The amount of sound required to activate the microphone
	 and dispatch the <codeph>activity</codeph> event. Acceptable values range from 0 to 100. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>The number of milliseconds that must elapse without
	 activity before Flash Player or Adobe AIR considers sound to have stopped and dispatches the 
	 <codeph>dispatch</codeph> event. The default value is 2000 (2 seconds). 
	 (<b>Note</b>: The default value shown 
	 in the signature, -1, is an internal value that indicates to Flash Player or Adobe AIR to use 2000.)
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sets the minimum input level that should be considered sound and (optionally) the amount
	 of silent time signifying that silence has actually begun.
	 <ul>
	   <li>To prevent the microphone from detecting sound at all, pass a value of 100 for 
	     <codeph>silenceLevel</codeph>; the <codeph>activity</codeph> event is never dispatched. </li>
	   <li>To determine the amount of sound the microphone is currently detecting, use <codeph>Microphone.activityLevel</codeph>. </li>
	 </ul>
	 
	 <p>Activity detection is the ability to detect when audio levels suggest that a person is talking. 
	 When someone is not talking, bandwidth can be saved because there is no need to send the associated
	 audio stream. This information can also be used for visual feedback so that users know 
	 they (or others) are silent.</p>
	 
	 <p>Silence values correspond directly to activity values. Complete silence is an activity value of 0. 
	 Constant loud noise (as loud as can be registered based on the current gain setting) is an activity value 
	 of 100. After gain is appropriately adjusted, your activity value is less than your silence value when
	 you're not talking; when you are talking, the activity value exceeds your silence value.</p>
	 
	 <p>This method is similar to <codeph>Camera.setMotionLevel()</codeph>; both methods are used to
	 specify when the <codeph>activity</codeph> event is dispatched. However, these methods have 
	 a significantly different impact on publishing streams:</p>
	 
	 <ul>
	   <li><codeph>Camera.setMotionLevel()</codeph> is designed to detect motion and does not affect bandwidth
	     usage. Even if a video stream does not detect motion, video is still sent.</li>
	 
	   <li><codeph>Microphone.setSilenceLevel()</codeph> is designed to optimize bandwidth. When an audio
	     stream is considered silent, no audio data is sent. Instead, a single message is sent, indicating 
	     that silence has started. </li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>flash.media.Camera.setMotionLevel()</linktext></link><link href="flash.media.xml#Microphone/activityLevel"><linktext>flash.media.Microphone.activityLevel</linktext></link><link href="flash.media.xml#Microphone/event:activity"><linktext>flash.media.Microphone.activity</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/silenceLevel"><linktext>flash.media.Microphone.silenceLevel</linktext></link><link href="flash.media.xml#Microphone/silenceTimeout"><linktext>flash.media.Microphone.silenceTimeout</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Microphone:setUseEchoSuppression"><apiName>setUseEchoSuppression</apiName><shortdesc>
	 Specifies whether to use the echo suppression feature of the audio codec.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setUseEchoSuppression, setUseEchoSuppression
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>useEchoSuppression</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>A Boolean value indicating whether echo suppression should be used 
	 (<codeph>true</codeph>) or not (<codeph>false</codeph>). 	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Specifies whether to use the echo suppression feature of the audio codec. The default value is 
	 <codeph>false</codeph> unless the user has selected Reduce Echo in the Flash Player Microphone 
	 Settings panel.
	 
	 <p>Echo suppression is an effort to reduce the effects of audio feedback, which is caused when
	 sound going out the speaker is picked up by the microphone on the same computer. (This is different
	 from echo cancellation, which completely removes the feedback.)</p>
	 
	 <p>Generally, echo suppression is advisable when the sound being captured is played through 
	 speakers — instead of a headset — on the same computer. If your SWF file allows users to specify the
	 sound output device, you may want to call <codeph>Microphone.setUseEchoSuppression(true)</codeph> 
	 if they indicate they are using speakers and will be using the microphone as well. </p>
	 
	 <p>Users can also adjust these settings in the Flash Player Microphone Settings panel.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link><link href="flash.media.xml#Microphone/useEchoSuppression"><linktext>flash.media.Microphone.useEchoSuppression</linktext></link></related-links></apiOperation><apiValue id="flash.media:Microphone:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 The amount of sound the microphone is detecting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.activityLevel, activityLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The amount of sound the microphone is detecting. Values range from 
	 0 (no sound is detected) to 100 (very loud sound is detected). The value of this property can 
	 help you determine a good value to pass to the <codeph>Microphone.setSilenceLevel()</codeph> method.
	 
	 <p>If the microphone is available but is not yet being used because <codeph>Microphone.getMicrophone()</codeph> 
	 has not been called, this property is set to -1.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:codec:get"><apiName>codec</apiName><shortdesc>
	 The codec to use for compessing audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.getCodec, getCodec
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The codec to use for compessing audio. Available codecs are Nellymoser (the default) and Speex. The enumeration class <codeph>SoundCodec</codeph> contains
	 the various values that are valid for the <codeph>codec</codeph> property.
	 
	 <p>If you use the Nellymoser codec, you can set the sample rate using <codeph>Microphone.rate()</codeph>. 
	 If you use the Speex codec, the sample rate is set to 16 kHz.</p>
	 
	 <p>Speex includes voice activity detection (VAD) and automatically reduces bandwidth when no voice is detected. 
	 When using the Speex codec, Adobe recommends that you set the silence level to 0. To set the silence level, use the
	 <codeph>Microphone.setSilenceLevel()</codeph> method.</p>
	 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()s"><linktext>setSilenceLevel()s</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:encodeQuality:get"><apiName>encodeQuality</apiName><shortdesc>
	 The encoded speech quality when using the Speex codec.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The encoded speech quality when using the Speex codec. Possible values are from 0 to 10. The default value is 6. 
	 Higher numbers represent higher quality but require more bandwidth, as shown in the following table. The bit rate values that are listed 
	 represent net bit rates and do not include packetization overhead.
	 <p>
	  <adobetable class="innertable">
	 
	    
	    
	    
	    
	    
	    
	    
	    
	 
	    
	    
	  <tgroup cols="2"><thead><row><entry>Quality value</entry><entry>Required bit rate (kilobits per second)</entry></row></thead><tbody><row>
	      <entry>0</entry>
	      <entry> 3.95</entry>
	    </row><row>
	      <entry>1</entry>
	      <entry>5.75</entry>
	    </row><row>
	      <entry>2</entry>
	      <entry>7.75</entry>
	    </row><row>
	      <entry>3</entry>
	      <entry>9.80</entry>
	    </row><row>
	      <entry>4</entry>
	      <entry>12.8</entry>
	    </row><row>
	      <entry>5</entry>
	      <entry>16.8</entry>
	    </row><row>
	      <entry>6</entry>
	      <entry>20.6</entry>
	    </row><row>
	      <entry>7</entry>
	      <entry>23.8</entry>
	    </row><row>
	 <entry>8</entry>
	 <entry>27.8</entry>
	    </row><row>
	      <entry>9</entry>
	      <entry>34.2</entry>
	    </row><row>
	      <entry>10</entry>
	      <entry>42.2</entry>
	    </row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>codec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:framesPerPacket:get"><apiName>framesPerPacket</apiName><shortdesc>
	 Number of Speex speech frames transmitted in a packet (message).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Number of Speex speech frames transmitted in a packet (message). 
	 Each frame is 20 ms long. The default value is two frames per packet.
	 
	 <p>The more Speex frames in a message, the lower the bandwidth required but the longer the delay in sending the
	 message. Fewer Speex frames increases bandwidth required but reduces delay.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:gain:get"><apiName>gain</apiName><shortdesc>
	 The amount by which the microphone boosts the signal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.gain, gain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The amount by which the microphone boosts the signal. Valid values are 0 to 100. The default value is 50.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:index:get"><apiName>index</apiName><shortdesc>
	 The index of the microphone, as reflected in the array returned by 
	 Microphone.names.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.index, index
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The index of the microphone, as reflected in the array returned by 
	 <codeph>Microphone.names</codeph>.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:muted:get"><apiName>muted</apiName><shortdesc>
	 Specifies whether the user has denied access to the microphone (true) 
	 or allowed access (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.muted, muted
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Specifies whether the user has denied access to the microphone (<codeph>true</codeph>) 
	 or allowed access (<codeph>false</codeph>). When this value changes, 
	 a <codeph>status</codeph> event is dispatched.
	 For more information, see <codeph>Microphone.getMicrophone()</codeph>. 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/event:status"><linktext>flash.media.Microphone.status</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:name:get"><apiName>name</apiName><shortdesc>
	 The name of the current sound capture device, as returned by the sound capture hardware.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.name, name
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The name of the current sound capture device, as returned by the sound capture hardware.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:names:get"><apiName>names</apiName><shortdesc>
	 An array of strings containing the names of all available sound capture devices.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.names, names
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 An array of strings containing the names of all available sound capture devices. 
	 The names are returned without 
	 having to display the Flash Player Privacy Settings panel to the user. This array 
	 provides the zero-based index of each sound capture device and the 
	 number of sound capture devices on the system, through the <codeph>Microphone.names.length</codeph> property. 
	 For more information, see the Array class entry.
	 
	 <p>Calling <codeph>Microphone.names</codeph> requires an extensive examination of the hardware, and it
	 may take several seconds to build the array. In most cases, you can just use the default microphone.</p>
	 
	 <p><b>Note:</b> To determine the name of the current microphone, 
	 use the <codeph>name</codeph> property.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Array"><linktext>Array</linktext></link><link href="flash.media.xml#Microphone/name"><linktext>flash.media.Microphone.name</linktext></link><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:rate:get"><apiName>rate</apiName><shortdesc>
	 The rate at which the microphone is capturing sound, in kHz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.rate, rate
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The rate at which the microphone is capturing sound, in kHz. Acceptable values are 5, 8, 11, 22, and 44. The default value is 8 
	 kHz if your sound capture device supports this value. Otherwise, the default value is the next available capture level above 8 kHz
	 that your sound capture device supports, usually 11 kHz. Flash Player 10 and AIR 1.5 or later support a 16kHz rate value.
	 
	 <p><b>Note:</b> If you are using the Speex codec (<codeph>Microphone.codec = SoundCodec.SPEEX</codeph>) for Flash Player 10 and AIR 1.5
	 or later, the default rate value is 16kHz. If you use the Speex codec and then change the codec value to Nellymoser 
	 (<codeph>Microphone.codec = SoundCodec.NELLYMOSER</codeph>), the rate continues to be set to 16kHz until you explicitly set the rate to a new value.
	 To receive audio using Flash Player releases before Flash Player 10 and AIR releases before AIR 1.5, change both the codec and the rate values 
	 when you publish the audio.</p>
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>flash.media.Microphone.codec</linktext></link><link href="flash.media.xml#SoundCodec"><linktext>flash.media.SoundCodec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceLevel:get"><apiName>silenceLevel</apiName><shortdesc>
	 The amount of sound required to activate the microphone and dispatch 
	 the activity event.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceLevel, silenceLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The amount of sound required to activate the microphone and dispatch 
	 the <codeph>activity</codeph> event. The default value is 10.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceTimeout:get"><apiName>silenceTimeout</apiName><shortdesc>
	 The number of milliseconds between the time the microphone stops 
	 detecting sound and the time the activity event is dispatched.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceTimeout, silenceTimeout
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The number of milliseconds between the time the microphone stops 
	 detecting sound and the time the <codeph>activity</codeph> event is dispatched. The default 
	 value is 2000 (2 seconds).
	 
	 <p>To set this value, use the <codeph>Microphone.setSilenceLevel()</codeph> method.</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Controls the sound of this microphone object when it is in loopback mode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Controls the sound of this microphone object when it is in loopback mode.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:useEchoSuppression:get"><apiName>useEchoSuppression</apiName><shortdesc>
	 Set to true if echo suppression is enabled; false otherwise.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.useEchoSuppression, useEchoSuppression
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Set to <codeph>true</codeph> if echo suppression is enabled; <codeph>false</codeph> otherwise. The default value is 
	 <codeph>false</codeph> unless the user has selected Reduce Echo in the Flash Player Microphone Settings panel.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.media:scanHardware"><apiName>scanHardware</apiName><shortdesc>
	 Forces a rescan of the microphones and cameras on the system.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Forces a rescan of the microphones and cameras on the system.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiClassifier id="flash.media:Camera"><apiName>Camera</apiName><shortdesc>
 Use the Camera class to capture video from a camera attached to a computer running Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Use the Camera class to capture video from a camera attached to a computer running Flash Player. 
 Use the Video class to monitor the video locally.  
 Use the NetConnection and NetStream classes to transmit the video to Flash Media Server.
 Flash Media Server can send the video stream to other servers and broadcast it to other clients running Flash Player.
 
 <p>
 For information about capturing audio, see the Microphone class.
 </p>
 
 <p>
 <b>Important: </b>Flash Player displays a Privacy dialog box that lets the user choose whether 
 to allow or deny access to the camera. Make sure your application window size is at least 215 x 138 pixels; 
 this is the minimum size required to display the dialog box.
 </p>
 
 <p>To create or reference a Camera object, use the <codeph>getCamera()</codeph> method.</p>
 
 </apiDesc><example conref="examples\CameraExample.as"> The following example shows the image from a camera after acknowledging the
 security warning.  The Stage is set such that it cannot be scaled and is aligned to the
 top-left of the player window.  The <codeph>activity</codeph> event is dispatched at the
 start and end (if any) of the session and is captured by the <codeph>activityHandler()</codeph>
 method, which prints out information about the event.
 
 <p><b>Note:</b> A camera must be attached to your computer for this example
 to work correctly.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Camera;
    import flash.media.Video;

    public class CameraExample extends Sprite {
        private var video:Video;
        
        public function CameraExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            
            var camera:Camera = Camera.getCamera();
            
            if (camera != null) {
                camera.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                video = new Video(camera.width * 2, camera.height * 2);
                video.attachCamera(camera);
                addChild(video);
            } else {
                trace("You need a camera.");
            }
        }
        
        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links><adobeApiEvent id="flash.media:Camera_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Dispatched when a camera reports its status.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a camera reports its status. 
 If the value of the <codeph>code</codeph> property is <codeph>"Camera.Muted"</codeph>,
 the user has refused to allow the SWF file access to the user's camera.
 If the value of the <codeph>code</codeph> property is <codeph>"Camera.Unmuted"</codeph>,
 the user has allowed the SWF file access to the user's camera.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>Camera.getCamera()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Camera_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Dispatched when a camera begins or ends a session.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a camera begins or ends a session. 
 Call <codeph>Camera.setMotionLevel()</codeph> to specify the amount of motion
 required to trigger an <codeph>activity</codeph> event with an <codeph>activating</codeph>
 value of <codeph>true</codeph>, or the time without activity
 that must elapse before triggering an <codeph>activity</codeph> event with an <codeph>activating</codeph>
 value of <codeph>false</codeph>.
 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:Camera:getCamera"><apiName>getCamera</apiName><shortdesc>
	 Returns a reference to a Camera object for capturing video.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, constructor, Camera.getCamera, getCamera
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>If the <codeph>name</codeph> parameter is not specified, this method returns a reference
 	 to the default camera or, if it is in use by another application, to the first
 	 available camera. (If there is more than one camera installed, the user may specify
 	 the default camera in the Flash Player Camera Settings panel.) If no cameras are available
 	 or installed, the method returns <codeph>null</codeph>. 
 	  
 	 </apiDesc><apiOperationClassifier>flash.media:Camera</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Specifies which camera to get, as determined from the array
 	 returned by the <codeph>names</codeph> property. For most applications, get the default camera 
 	 by omitting this parameter. To specify a value for this parameter, use the string representation
     of the zero-based index position within the Camera.names array. For example, to specify the third
     camera in the array, use <codeph>Camera.getCamera("2")</codeph>. 
 	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Returns a reference to a Camera object for capturing video. To begin capturing
	 the video, you must attach the Camera object to a Video object (see <codeph>Video.attachCamera()
     </codeph>). To transmit video to Flash Media Server, call <codeph>NetStream.attachCamera()</codeph>
     to attach the Camera object to a NetStream object.
	 
	 <p>Multiple calls to the <codeph>getCamera()</codeph> method reference the same camera driver.
	 Thus, if your code contains code like <codeph>firstCam:Camera = getCamera()</codeph> 
	 and <codeph>secondCam:Camera = getCamera()</codeph>,
	 both <codeph>firstCam</codeph> and <codeph>secondCam</codeph> reference the same camera,
	 which is the user's default camera.</p>
	 
	 <p>In general, you shouldn't pass a value for the <codeph>name</codeph> parameter; simply use
	 <codeph>getCamera()</codeph> to return a reference to the default camera. By means of the Camera
	 settings panel (discussed later in this section), the user can specify the default camera
	 Flash Player should use. </p>
	 
  	 <p>You can't use ActionScript to set a user's Allow or Deny permission setting
     for access to the camera, but you can display the Adobe Flash Player Settings camera 
     setting dialog box where the user can set the camera permission. When a SWF file using 
     the <codeph>attachCamera()</codeph> method tries to 
  	 attach the camera returned by the <codeph>getCamera()</codeph> method to a Video or 
  	 NetStream object, Flash Player displays a dialog box that lets the user choose  
  	 to allow or deny access to the camera. (Make sure your application window size is at least 
  	 215 x 138 pixels; this is the minimum size Flash Player requires to display the dialog box.) 
  	 When the user responds to the camera setting dialog box, Flash Player returns an 
     information object in the <codeph>status</codeph> event that indicates the user's response: 
     <codeph>Camera.muted</codeph> indicates 
  	 the user denied access to a camera; <codeph>Camera.Unmuted</codeph> indicates the user allowed access 
  	 to a camera. To determine whether the user has denied or allowed access to the camera without 
  	 handling the <codeph>status</codeph> event, use the <codeph>muted</codeph> property.</p>
  	 
 	 <p>The user can specify permanent privacy settings for a particular domain by right-clicking
	 (Windows and Linux) or Control-clicking (Macintosh) while a SWF file is playing, selecting Settings, 
  	 opening the Privacy dialog, and selecting Remember. If the user selects Remember, Flash Player no longer 
  	 asks the user whether to allow or deny SWF files from this domain access to your camera.</p>
  	 
  	 <p><b>Note:</b> The <codeph>attachCamera()</codeph> method will not invoke the dialog box
     to Allow or Deny access to the camera if the user has denied access by selecting Remember 
     in the Flash Player Settings dialog box. In this case, you can prompt the user to change the
     Allow or Deny setting by displaying the Flash Player Privacy panel for the user 
     using <codeph>Security.showSettings(SecurityPanel.PRIVACY)</codeph>.</p>
 	 
 	 <p>If <codeph>getCamera()</codeph> returns <codeph>null</codeph>, either the camera is in use by another
 	 application, or there are no cameras installed on the system. To determine whether any cameras
 	 are installed, use the <codeph>names.length</codeph> property. To display the Flash Player Camera Settings panel,
 	 which lets the user choose the camera to be referenced by <codeph>getCamera()</codeph>, use 
 	 <codeph>Security.showSettings(SecurityPanel.CAMERA)</codeph>. </p>
 	 
	 <p>Scanning the hardware for cameras takes time. When Flash Player finds at least one camera, 
	 the hardware is not scanned again for the lifetime of the player instance. However, if
	 Flash Player doesn't find any cameras, it will scan each time <codeph>getCamera</codeph> is called.
	 This is helpful if a user has forgotten to connect the camera; if your SWF file provides a
	 Try Again button that calls <codeph>getCamera</codeph>, Flash Player can find the camera without the
	 user having to restart the SWF file.</p>
 	 
	 </apiDesc><example conref="examples\Camera_getCameraExample.as"> In the following example, after the user allows access to the camera, the attached 
 camera is used to capture video images. Information about the video stream, such as 
 the current frames per second, is also displayed.
 
 <p>The <codeph>Camera.getCamera()</codeph> method returns a reference to a camera object, or returns null if 
 no camera is available or installed. The if statement checks whether the camera was found and whether 
 the user allowed access to the camera. If the user denied access, the <codeph>muted</codeph> 
 property is set to <codeph>true</codeph>.</p> 
 
 <p>Usually, when the <codeph>attachCamera()</codeph> method is invoked, a dialog box appears and prompts the 
 user to allow or deny Flash Player access to the camera. However, if the user denied access 
 and selected the <codeph>Remember</codeph> option, the dialog box does not appear and nothing displays. 
 To make sure the user has the option to allow access to the camera, the <codeph>myTextField</codeph> text field 
 instructs the user to click the text field to invoke the Flash Player Settings dialog box.</p>
 
 <p>The <codeph>clickHandler()</codeph> method calls <codeph>Security.showSettings()</codeph> method, which 
 displays the <codeph>PRIVACY</codeph> panel of the Settings dialog box. If the user allows access, 
 the <codeph>StatusEvent.STATUS</codeph> event is dispatched and the value of the event's <codeph>code</codeph> 
 property is set to <codeph>Camera.Unmuted</codeph>. (The camera object's <codeph>mute</codeph> property is also 
 set to <codeph>false</codeph>.)</p>
 
 <p>The <codeph>statusHandler()</codeph> method, added to listen to the status change of the user's setting, 
 invokes the <codeph>connectCamera()</codeph> method, if the user allows access. The <codeph>connectCamera()</codeph> 
 method instantiates a video object with the captured stream's width and height. To display the 
 camera's captured video, the reference to the video stream is attached to the video object, and the video 
 object is added to the display list.</p>
 
 <p>A Timer object also is started. Every second, a Timer object's timer event is dispatched and the 
 <codeph>timerHandler()</codeph> method is invoked. The <codeph>timerHandler()</codeph> method is displayed and updates 
 a number of properties of the Camera object. </p> 
 <p><b>Note:</b> For this example, the only property that changes 
 is the <codeph>currentFPS</codeph> property.</p>    
    
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.StatusEvent;
    import flash.events.MouseEvent;
    import flash.system.SecurityPanel;
    import flash.system.Security;

    public class Camera_getCameraExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);
        
        public function Camera_getCameraExample() {
            myTextField = new TextField();
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";
                
            } else if (cam.muted) {
                myTextField.text = "To enable the use of the camera,\n"
                                 + "please click on this text field.\n" 
                                 + "When the Flash Player Settings dialog appears,\n"
                                 + "make sure to select the Allow radio button\n" 
                                 + "to grant access to your camera.";

                myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            }else {
                myTextField.text = "Connecting";
                connectCamera(); 
            }
   
            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            Security.showSettings(SecurityPanel.PRIVACY);

            cam.addEventListener(StatusEvent.STATUS, statusHandler);

            myTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function statusHandler(event:StatusEvent):void {

            if (event.code == "Camera.Unmuted") {
                connectCamera(); 
                cam.removeEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                t.start();
        }

        private function timerHandler(event:TimerEvent):void {
            myTextField.y = cam.height + 20;
            myTextField.text = "";
            myTextField.appendText("bandwidth: " + cam.bandwidth + "\n");
            myTextField.appendText("currentFPS: " + Math.round(cam.currentFPS) + "\n");
            myTextField.appendText("fps: " + cam.fps + "\n");
            myTextField.appendText("keyFrameInterval: " + cam.keyFrameInterval + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/muted"><linktext>muted</linktext></link><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links><adobeApiEvent id="flash.media:Camera:getCamera_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Dispatched when a camera reports its status. 
	 If the value of the <codeph>code</codeph> property is <codeph>"Camera.muted"</codeph>,
	 the user has refused to allow the SWF file access to the user's camera.
	 If the value of the <codeph>code</codeph> property is <codeph>"Camera.Unmuted"</codeph>,
	 the user has allowed the SWF file access to the user's camera.
 	 </apiDesc></adobeApiEventDetail><shortdesc>Dispatched when a camera reports its status.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Camera:setKeyFrameInterval"><apiName>setKeyFrameInterval</apiName><shortdesc>
	 Specifies which video frames are transmitted in full (called keyframes)
	 instead of being interpolated by the video compression algorithm.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>keyFrameInterval</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>A value that specifies which video frames are transmitted in full
	 (as keyframes) instead of being interpolated by the video compression algorithm. 
	 A value of 1 means that every frame is a keyframe, a value of 3 means that every third frame
	 is a keyframe, and so on. Acceptable values are 1 through 48.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Specifies which video frames are transmitted in full (called <i>keyframes</i>)
	 instead of being interpolated by the video compression algorithm. This method
	 is applicable only if you are transmitting video using Flash Media Server.
	 
	 <p>The Flash Video compression algorithm compresses video by transmitting
	 only what has changed since the last frame of the video; these portions are 
	 considered to be interpolated frames. Frames of a video can be interpolated according
	 to the contents of the previous frame. A keyframe, however, is a video frame that
	 is complete; it is not interpolated from prior frames.</p> 
	 
	 <p>To determine how to set a value for the <codeph>keyFrameInterval</codeph> parameter,
	 consider both bandwidth use and video playback accessibility. For example, 
	 specifying a higher value for <codeph>keyFrameInterval</codeph> (sending keyframes less frequently)
	 reduces bandwidth use. 
	 However, this may increase the amount of time required to position the playhead
	 at a particular point in the video; more prior video frames may have to be interpolated
	 before the video can resume.</p> 
	 
	 <p>Conversely, specifying a lower value for <codeph>keyFrameInterval</codeph> 
	 (sending keyframes more frequently) increases bandwidth use because entire video frames
	 are transmitted more often, but may decrease the amount of time required to seek a 
	 particular video frame within a recorded video.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/keyFrameInterval"><linktext>keyFrameInterval</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setLoopback"><apiName>setLoopback</apiName><shortdesc>
	 Specifies whether to use a compressed video stream for a local view of the camera.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>compress</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Specifies whether to use a compressed video stream (<codeph>true</codeph>) 
	 or an uncompressed stream (<codeph>false</codeph>) for a local view of what the camera
	 is receiving.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Specifies whether to use a compressed video stream for a local view of the camera.
	 This method is applicable only if you are transmitting video using Flash Media Server;
	 setting <codeph>compress</codeph> to <codeph>true</codeph> lets you see more precisely how the video
	 will appear to users when they view it in real time.
	 
	 <p>Although a compressed stream is useful for testing purposes, such as previewing video
	 quality settings, it has a significant processing cost, because the local view is not 
	 simply compressed; it is compressed, edited for transmission as it would be over a live
	 connection, and then decompressed for local viewing.</p>
	 
	 <p>To set the amount of compression used when you set <codeph>compress</codeph> to <codeph>true</codeph>,
	 use <codeph>Camera.setQuality()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMode"><apiName>setMode</apiName><shortdesc>
	 Sets the camera capture mode to the native mode that best meets the specified requirements.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMode, setMode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The requested capture width, in pixels. The default value is 160.	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>The requested capture height, in pixels. The default value is 120.	 
	 </apiDesc></apiParam><apiParam><apiItemName>fps</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The requested rate at which the camera should capture data, in frames per second.
	 The default value is 15.	 
	 </apiDesc></apiParam><apiParam><apiItemName>favorArea</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Specifies whether to manipulate the width, height, and frame rate if 
	 the camera does not have a native mode that meets the specified requirements. 
	 The default value is <codeph>true</codeph>, which means that maintaining capture size
	 is favored; using this parameter selects the mode that most closely matches 
	 <codeph>width</codeph> and <codeph>height</codeph> values, even if doing so adversely affects 
	 performance by reducing the frame rate. To maximize frame rate at the expense 
	 of camera height and width, pass <codeph>false</codeph> for the <codeph>favorArea</codeph> parameter.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sets the camera capture mode to the native mode that best meets the specified requirements.
	 If the camera does not have a native mode that matches all the parameters you pass, 
	 Flash Player selects a capture mode that most closely synthesizes the requested mode. 
	 This manipulation may involve cropping the image and dropping frames. 
	 
	 <p>By default, Flash Player drops frames as needed to maintain image size. To minimize the number
	 of dropped frames, even if this means reducing the size of the image, pass <codeph>false</codeph>
	 for the <codeph>favorArea</codeph> parameter.</p>
	 
	 <p>When choosing a native mode, Flash Player tries to maintain the requested aspect ratio
	 whenever possible. For example, if you issue the command <codeph>myCam.setMode(400, 400, 30)</codeph>,
	 and the maximum width and height values available on the camera are 320 and 288, Flash Player sets
	 both the width and height at 288; by setting these properties to the same value, Flash Player 
	 maintains the 1:1 aspect ratio you requested.</p>
	 
	 <p>To determine the values assigned to these properties after Flash Player selects the mode
	 that most closely matches your requested values, use the <codeph>width</codeph>, <codeph>height</codeph>,
	 and <codeph>fps</codeph> properties.</p>
	 
	 <p>
	 If you are using Flash Media Server, you can also capture single frames or create time-lapse
	 photography. For more information, see <codeph>NetStream.attachCamera()</codeph>.
	 </p>
	 
	 </apiDesc><example conref="examples\Camera_setModeExample.as"> In the following example, when a user clicks on the Stage, the video
 is resized and the frames per second capture rate is set to a new value.  
 
 <p>The Stage is set so it does not scale. The <codeph>Camera.getCamera()</codeph> method 
 returns a reference to a camera object, or returns null if no camera is available or installed. 
 If a camera exists, the <codeph>connectCamera()</codeph> method is called.
 The <codeph>connectCamera()</codeph> method instantiates a video object. To 
 display the camera's captured video, the reference to the video stream is attached 
 to the video object, and the video object is added to the display list. An event listener 
 also is set for a <codeph>MouseEvent.CLICK</codeph> event. After the user clicks on the Stage, 
 the <codeph>clickHandler()</codeph> method is invoked. The method checks the width of the 
 captured video and sets the camera capture mode's width, height, and the frame per second 
 request rate. In order for these setting to take effect, the video object must be removed 
 and re-created. The video's width and height also must be set to the camera object's width 
 and height.</p>      
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.events.MouseEvent;
    import flash.display.StageScaleMode;

    public class Camera_setModeExample extends Sprite {
        private var cam:Camera;
        private var vid:Video;

        public function Camera_setModeExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;

            cam = Camera.getCamera();
            
            if (!cam) {
                trace("No camera is installed.");
            }else {
                connectCamera();
            }
        }

        private function connectCamera():void {
            vid = new Video();
            vid.width = cam.width;
            vid.height = cam.height; 
            vid.attachCamera(cam);
            addChild(vid);    

            stage.addEventListener(MouseEvent.CLICK, clickHandler);
        }
    
        private function clickHandler(e:MouseEvent):void {

            switch (cam.width) {
                case 160:
                cam.setMode(320, 240, 10); 
                break;
                case 320:
                cam.setMode(640, 480, 5); 
                break;
                default:
                cam.setMode(160, 120, 15); 
                break;
            } 

            removeChild(vid);           
            connectCamera();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/fps"><linktext>fps</linktext></link><link href="flash.media.xml#Camera/height"><linktext>height</linktext></link><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.net.xml#NetStream/attachCamera()"><linktext>flash.net.NetStream.attachCamera()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMotionLevel"><apiName>setMotionLevel</apiName><shortdesc>
	 Specifies how much motion is required to dispatch the activity event.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMotionLevel, setMotionLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>motionLevel</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Specifies the amount of motion required to dispatch the
	 <codeph>activity</codeph> event. Acceptable values range from 0 to 100. The default value is 50.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>2000</apiData><apiDesc>Specifies how many milliseconds must elapse without activity 
	 before Flash Player considers activity to have stopped and dispatches the <codeph>activity</codeph> event.
	 The default value is 2000 milliseconds (2 seconds).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Specifies how much motion is required to dispatch the <codeph>activity</codeph> event. 
	 Optionally sets the number of milliseconds that must elapse without activity before 
	 Flash Player considers motion to have stopped and dispatches the event. 
	 <p><b>Note: </b>Video can be displayed regardless of the value of the
	 <codeph>motionLevel</codeph> parameter. This parameter determines only when and under
	 what circumstances the event is dispatched—not whether video is actually being 
	 captured or displayed.</p>
	 <p>
	 To prevent the camera from detecting motion at all, pass a value of 100 for the
	 <codeph>motionLevel</codeph> parameter; the <codeph>activity</codeph> event is never dispatched. 
	 (You would probably use this value only for testing purposes—for example, to 
	 temporarily disable any handlers that would normally be triggered when the event is dispatched.)
	 </p>
	 <p>
	 To determine the amount of motion the camera is currently detecting, use the
	 <codeph>activityLevel</codeph> property. 
	 Motion sensitivity values correspond directly to activity values.
	 Complete lack of motion is an activity value of 0. Constant motion is an activity value of 100.
	 Your activity value is less than your motion sensitivity value when you're not moving; 
	 when you are moving, activity values frequently exceed your motion sensitivity value.
	 </p>
	 <p>
	 This method is similar in purpose to the <codeph>Microphone.setSilenceLevel()</codeph> method; 
	 both methods are used to specify when the <codeph>activity</codeph> event
	 should be dispatched. However, these methods have a significantly different impact
	 on publishing streams:
	 </p>
	 
	 <ul>
	   <li><codeph>Microphone.setSilenceLevel()</codeph> is designed to optimize bandwidth. 
	 When an audio stream is considered silent, no audio data is sent. Instead, a single message
	 is sent, indicating that silence has started. </li>
	   <li><codeph>Camera.setMotionLevel()</codeph> is designed to detect motion and does not affect
	 bandwidth usage. Even if a video stream does not detect motion, video is still sent.</li>
	 </ul>
	   
	 
	 
	 </apiDesc><example conref="examples\Camera_setMotionLevelExample.as"> In the following example, the user's camera is used as a monitor or 
 a surveillance camera. The camera detects motion and a text field shows 
 the activity level. (The example can be extended to sound an alarm or 
 send a message through a web service to other applications.)
 
 <p>The <codeph>Camera.getCamera()</codeph> method returns a reference to a camera object,  
 or returns null if no camera is available or installed. The if statement checks whether a camera 
 is available, and invokes the <codeph>connectCamera()</codeph> method when it is available. 
 The <codeph>connectCamera()</codeph> method instantiates a video object with the captured stream's 
 width and height. To display the camera's captured video, the reference to the 
 video stream is attached to the video object, and the video object is added to the display list.
 (Usually, when the <codeph>attachCamera()</codeph> method is invoked, a dialog box appears and 
 prompts the user to allow or deny Flash Player access to the camera. However, if the 
 user denied access and selected the <codeph>Remember</codeph> option, the dialog box does not appear 
 and nothing is displayed. To make sure the user has the option to allow access to the camera, use the 
 <codeph>system.Security.showSettings()</codeph> method to invoke the Flash Player 
 Settings dialog box.)</p>
 
 <p>The <codeph>setMotionLevel()</codeph> method sets the level of activity (amount of motion), before 
 the activity event is invoked, to five, for minimal motion. The time between when the camera stops 
 detecting motion and when the activity event is invoked, is set to 1 second (1000 millisecond). After 1  second 
 passes without activity or the level of activity reaches five, the <codeph>ActivityEvent.ACTIVITY</codeph> 
 event is dispatched and the <codeph>activityHandler()</codeph> method is invoked. If the event
 was triggered by the level of activity, the <codeph>activating</codeph> property is set to 
 <codeph>true</codeph> and a Timer object is started. Every second, a Timer objectâ€™s timer event 
 is dispatched and the <codeph>timerHandler()</codeph> method is invoked, which displays the current 
 level of activity. (Although a level of five or larger triggers the timer, the displayed
 current level of activity might be a smaller number.)</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.ActivityEvent;

    public class Camera_setMotionLevelExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);

        public function Camera_setMotionLevelExample() {
            myTextField = new TextField();
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";

            }else {
                myTextField.text = "Waiting to connect.";
                connectCamera(); 
            }

            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                cam.setMotionLevel(5, 1000);
                cam.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
        }

        private function activityHandler(e:ActivityEvent):void {
            if (e.activating == true) {
                t.start();    
            } else {
                myTextField.text = "Everything is quiet.";
                t.stop();
            }    
        }

        private function timerHandler(event:TimerEvent):void {
             myTextField.x = 10;
             myTextField.y = cam.height + 20;
             myTextField.text = "There is some activity. Level: " + cam.activityLevel;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/motionTimeout"><linktext>motionTimeout</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>Microphone.setSilenceLevel()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setQuality"><apiName>setQuality</apiName><shortdesc>
	 Sets the maximum amount of bandwidth per second or the required picture quality
	 of the current outgoing video feed.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera.setQuality, setQuality
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bandwidth</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Specifies the maximum amount of bandwidth that the current outgoing video
	 feed can use, in bytes per second. To specify that Flash Player video can use as much bandwidth
	 as needed to maintain the value of <codeph>quality</codeph>, pass 0 for 
	 <codeph>bandwidth</codeph>. The default value is 16384.	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>An integer that specifies the required level of picture quality,
	 as determined by the amount of compression being applied to each video frame. 
	 Acceptable values range from 1 (lowest quality, maximum compression) to 100 (highest 
	 quality, no compression). To specify that picture quality can vary as needed to avoid 
	 exceeding bandwidth, pass 0 for <codeph>quality</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Sets the maximum amount of bandwidth per second or the required picture quality
	 of the current outgoing video feed. This method is generally applicable only if
	 you are transmitting video using Flash Media Server.
	 
	 <p>Use this method to specify which element of the outgoing video feed is more
	 important to your application—bandwidth use or picture quality.</p>
	 
	 <ul>
	   <li>To indicate that bandwidth use takes precedence, pass a value for <codeph>bandwidth</codeph>
	 and 0 for <codeph>quality</codeph>. Flash Player transmits video at the highest quality
	 possible within the specified bandwidth. If necessary, Flash Player reduces picture
	 quality to avoid exceeding the specified bandwidth. In general, as motion increases,
	 quality decreases.</li>
	   <li>To indicate that quality takes precedence, pass 0 for <codeph>bandwidth</codeph> 
	 and a numeric value for <codeph>quality</codeph>. Flash Player uses as much bandwidth
	 as required to maintain the specified quality. If necessary, Flash Player reduces the frame
	 rate to maintain picture quality. In general, as motion increases, bandwidth use also
	 increases.</li>
	   <li>To specify that both bandwidth and quality are equally important, pass numeric 
	 values for both parameters. Flash Player transmits video that achieves the specified quality
	 and that doesn't exceed the specified bandwidth. If necessary, Flash Player reduces the 
	 frame rate to maintain picture quality without exceeding the specified bandwidth.</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/quality"><linktext>quality</linktext></link></related-links></apiOperation><apiValue id="flash.media:Camera:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 The amount of motion the camera is detecting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The amount of motion the camera is detecting. Values range from 0 (no motion is being detected) to 
	 100 (a large amount of motion is being detected). The value of this property can help you determine if you need to pass a setting 
	 to the <codeph>setMotionLevel()</codeph> method.
	 <p>If the camera is available but is not yet being used because the
	 <codeph>Video.attachCamera()</codeph> method has not been called, this property
	 is set to -1.</p>
	 <p>If you are streaming only uncompressed local video, this property is set only if you have assigned a function to the  event 
	 handler. Otherwise, it is undefined.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:bandwidth:get"><apiName>bandwidth</apiName><shortdesc>
	 The maximum amount of bandwidth the current outgoing video feed can use, in bytes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.bandwidth, bandwidth
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The maximum amount of bandwidth the current outgoing video feed can use, in bytes. 
	 A value of 0 means the feed can use as much bandwidth as needed to maintain the desired frame quality.
	 <p>To set this property, use the <codeph>setQuality()</codeph> method.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>	
	 The rate at which the camera is capturing data, in frames per second.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.currentFPS, currentFPS
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>	
	 The rate at which the camera is capturing data, in frames per second. 
	 This property cannot be set; however, you can use the <codeph>setMode()</codeph> method
	 to set a related property—<codeph>fps</codeph>—which specifies the maximum
	 frame rate at which you would like the camera to capture data. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:fps:get"><apiName>fps</apiName><shortdesc>
	 The maximum rate at which the camera can capture data, in frames per second.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.fps, fps
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The maximum rate at which the camera can capture data, in frames per second. 
	 The maximum rate possible depends on the capabilities of the camera; this frame rate may not be achieved.
	 <ul>
	   <li>To set a desired value for this property, use the <codeph>setMode()</codeph> method.</li>
	   <li>To determine the rate at which the camera is currently capturing data, use the <codeph>currentFPS</codeph> property.</li>
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/currentFPS"><linktext>currentFPS</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:height:get"><apiName>height</apiName><shortdesc>
	 The current capture height, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.height, height
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The current capture height, in pixels. To set a value for this property, 
	 use the <codeph>setMode()</codeph> method. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:index:get"><apiName>index</apiName><shortdesc>
	 A zero-based integer that specifies the index of the camera, as reflected in
	 the array returned by the names property.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.index, index
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 A zero-based integer that specifies the index of the camera, as reflected in
	 the array returned by the <codeph>names</codeph> property.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:keyFrameInterval:get"><apiName>keyFrameInterval</apiName><shortdesc>
	 The number of video frames transmitted in full (called keyframes) 
	 instead of being interpolated by the video compression algorithm.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The number of video frames transmitted in full (called <i>keyframes</i>) 
	 instead of being interpolated by the video compression algorithm. 
	 The default value is 15, which means that every 15th frame is a keyframe.
	 A value of 1 means that every frame is a keyframe. The allowed values are
	 1 through 48.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setKeyFrameInterval()"><linktext>setKeyFrameInterval()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:loopback:get"><apiName>loopback</apiName><shortdesc>
	 Indicates whether a local view of what the camera is capturing is compressed
	 and decompressed (true), as it would be for live transmission using
	 Flash Media Server, or uncompressed (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indicates whether a local view of what the camera is capturing is compressed
	 and decompressed (<codeph>true</codeph>), as it would be for live transmission using
	 Flash Media Server, or uncompressed (<codeph>false</codeph>). The default value is
	 <codeph>false</codeph>. 
	 
	 <p>
	 Although a compressed stream is useful for testing, such as when previewing
	 video quality settings, it has a significant processing cost. The local view
	 is compressed, edited for transmission as it would be over a live connection,
	 and then decompressed for local viewing.
	 </p>
	 
	 <p>To set this value, use <codeph>Camera.setLoopback()</codeph>. To set the amount of 
	 compression used when this property is true, use <codeph>Camera.setQuality()</codeph>.</p>
	  
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setLoopback()"><linktext>setLoopback()</linktext></link><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionLevel:get"><apiName>motionLevel</apiName><shortdesc>
	 The amount of motion required to invoke the activity event.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionLevel, motionLevel
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The amount of motion required to invoke the <codeph>activity</codeph> event. Acceptable values range from 0 to 100. 
	 The default value is 50.
	 <p>Video can be displayed regardless of the value of the <codeph>motionLevel</codeph> property. For more information, see <codeph>
	 setMotionLevel()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionTimeout:get"><apiName>motionTimeout</apiName><shortdesc>
	 The number of milliseconds between the time the camera stops detecting motion and the time the activity event is invoked.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionTimeout, motionTimeout
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The number of milliseconds between the time the camera stops detecting motion and the time the <codeph>activity</codeph> event is invoked. The 
	 default value is 2000 (2 seconds). 
	 <p>To set this value, use <codeph>setMotionLevel()</codeph>. </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:muted:get"><apiName>muted</apiName><shortdesc>
	 A Boolean value indicating whether the user has denied access to the camera
	 (true) or allowed access (false) in the Flash Player Privacy dialog box.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.muted, muted
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 A Boolean value indicating whether the user has denied access to the camera
	 (<codeph>true</codeph>) or allowed access (<codeph>false</codeph>) in the Flash Player Privacy dialog box. 
	 
	 When this value changes, the <codeph>status</codeph>event is dispatched.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:name:get"><apiName>name</apiName><shortdesc>
	 The name of the current camera, as returned by the camera hardware.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 The name of the current camera, as returned by the camera hardware.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:names:get"><apiName>names</apiName><shortdesc>
	 An array of strings indicating the names of all available cameras
	 without displaying the Flash Player Privacy dialog box.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.names, names
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 An array of strings indicating the names of all available cameras
	 without displaying the Flash Player Privacy dialog box. This array behaves in the
	 same way as any other ActionScript array, implicitly providing the zero-based
	 index of each camera and the number of cameras on the system (by means of 
	 <codeph>names.length</codeph>). For more information, see the <codeph>names</codeph> Array class entry.
	 
	 <p>Calling the <codeph>names</codeph> property requires an extensive examination of the hardware,
	 and it may take several seconds to build the array. In most cases, you can just use the 
	 default camera.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/name"><linktext>name</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:quality:get"><apiName>quality</apiName><shortdesc>
	 The required level of picture quality, as determined by the amount of compression being applied to each video
	 frame.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.quality, quality
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The required level of picture quality, as determined by the amount of compression being applied to each video
	 frame. Acceptable quality values range from 1 (lowest quality, maximum compression) to 100 (highest quality, no compression). The 
	 default value is 0, which means that picture quality can vary as needed to avoid exceeding available bandwidth.
	 
	 <p>To set this property, use the <codeph>setQuality()</codeph> method.</p>
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:width:get"><apiName>width</apiName><shortdesc>
	 The current capture width, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.width, width
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 The current capture width, in pixels. To set a desired value for this property, 
	 use the <codeph>setMode()</codeph> method.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
 The SoundTransform class contains properties for volume and panning.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The SoundTransform class contains properties for volume and panning. 
 
 </apiDesc><example conref="examples\SoundTransformExample.as"> The following example loads and plays an MP3 file. As the MP3 file plays, 
 move the mouse; the 
 volume and panning change as you move the mouse over the Stage. 
 To run this example, place a file named MySound.mp3 in the same directory as your SWF file.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundTransformExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundTransformExample() {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.load(request);
            channel = soundFactory.play();
            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function setPan(pan:Number):void {
            trace("setPan: " + pan.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.pan = pan;
            channel.soundTransform = transform;
        }

        private function setVolume(volume:Number):void {
            trace("setVolume: " + volume.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.volume = volume;
            channel.soundTransform = transform;
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            var halfStage:uint = Math.floor(stage.stageWidth / 2);
            var xPos:uint = event.stageX;
            var yPos:uint = event.stageY;
            var value:Number;
            var pan:Number;

            if (xPos &gt; halfStage) {
                value = xPos / halfStage;
                pan = value - 1;
            } else if (xPos &lt; halfStage) {
                value = (xPos - halfStage) / halfStage;
                pan = value;
            } else {
                pan = 0;
            }

            var volume:Number = 1 - (yPos / stage.stageHeight);

            setVolume(volume);
            setPan(pan);
            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#SimpleButton/soundTransform"><linktext>flash.display.SimpleButton.soundTransform</linktext></link><link href="flash.display.xml#Sprite/soundTransform"><linktext>flash.display.Sprite.soundTransform</linktext></link><link href="flash.media.xml#Microphone/soundTransform"><linktext>flash.media.Microphone.soundTransform</linktext></link><link href="flash.media.xml#SoundChannel/soundTransform"><linktext>flash.media.SoundChannel.soundTransform</linktext></link><link href="flash.media.xml#SoundMixer/soundTransform"><linktext>flash.media.SoundMixer.soundTransform</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link></related-links><apiConstructor id="flash.media:SoundTransform:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
	 Creates a SoundTransform object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vol</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>The volume, ranging from 0 (silent) to 1 (full volume).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>panning</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The left-to-right panning of the sound, ranging from -1 (full pan left)
	 to 1 (full pan right). A value of 0 represents no panning (center). 
	 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Creates a SoundTransform object. 
	 
	 </apiDesc><example conref="examples\SoundTransform_constructorExample.as"> In the following example, the sound plays only from the
 right channel, and the volume is set to 50 percent.
 
 <p>In the constructor, the sound is loaded and is assigned to a sound channel 
 (<codeph>channel</codeph>). A SoundTranform object (<codeph>transform</codeph>) is also 
 created. Its first argument sets the volume at 50 percent (the range is 0.0 
 to 1.0). Its second argument sets the panning. In this example, panning is set to 1.0, which means 
 the sound comes from the right speaker only. In order for these settings to 
 take effect, the <codeph>transform</codeph> SoundTranform object is
 assigned to the sound channel's <codeph>souundTransform</codeph> property.</p> 
<p> <b>Note:</b> There is 
 limited error handling written for this example.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.events.IOErrorEvent;

    public class SoundTransform_constructorExample extends Sprite
    {
        public function SoundTransform_constructorExample() {
            var mySound:Sound = new Sound();
            var url:URLRequest = new URLRequest("mySound.mp3");
            var channel:SoundChannel;
            var transform:SoundTransform = new SoundTransform(0.5, 1.0);

            mySound.load(url);    
            channel = mySound.play();
            channel.soundTransform = transform;

            mySound.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundTransform:leftToLeft:set"><apiName>leftToLeft</apiName><shortdesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the left input is played in the 
	 left speaker.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the left input is played in the 
	 left speaker.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:leftToRight:set"><apiName>leftToRight</apiName><shortdesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the left input is played in the 
	 right speaker.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the left input is played in the 
	 right speaker.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:pan:set"><apiName>pan</apiName><shortdesc>
	 The left-to-right panning of the sound, ranging from -1 (full pan left)
	 to 1 (full pan right).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The left-to-right panning of the sound, ranging from -1 (full pan left)
	 to 1 (full pan right). A value of 0 represents no panning (balanced center between
	 right and left).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToLeft:set"><apiName>rightToLeft</apiName><shortdesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the right input is played in the 
	 left speaker.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the right input is played in the 
	 left speaker.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToRight:set"><apiName>rightToRight</apiName><shortdesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the right input is played in the 
	 right speaker.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 A value, from 0 (none) to 1 (all), specifying how much of the right input is played in the 
	 right speaker.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:volume:set"><apiName>volume</apiName><shortdesc>
	 The volume, ranging from 0 (silent) to 1 (full volume).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The volume, ranging from 0 (silent) to 1 (full volume).
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Sound"><apiName>Sound</apiName><shortdesc>
  The Sound class lets you work with sound in an application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  The Sound class lets you work with sound in an application. The Sound class
  lets you create a Sound object, load and play an external MP3 file into that object, 
  close the sound stream, and access
  data about the sound, such as information about the number of bytes in the stream and
  ID3 metadata. More detailed control of the sound is performed through the sound source — 
  the SoundChannel or Microphone object for the sound — and through the properties
  in the SoundTransform class that control the output of the sound to the computer's speakers. 
  
  <p>In Flash Player 10 and later and AIR 1.5 and later, you can also use this 
  class to work with sound that is generated dynamically. 
  In this case, the Sound object uses the function you assign to a <codeph>sampleData</codeph> event handler to
  poll for sound data. The sound is played as it is retrieved from a ByteArray object that
  you populate with sound data. You can use <codeph>Sound.extract()</codeph> to extract sound data from a 
  Sound object,
  after which you can manipulate it before writing it back to the stream for playback.</p>
  
  <p>To control sounds that are embedded in a SWF file, use the properties in the SoundMixer class.</p>
  
  <p platform="actionscript"><b>Note</b>: The ActionScript 3.0 Sound API differs from ActionScript 2.0.
  In ActionScript 3.0, you cannot take sound objects and arrange them in a hierarchy
  to control their properties.</p>
  
  <p>When you use this class, consider the following security model: </p>
  
  <ul>
  
      <li>Loading and playing a sound is not allowed if the calling file is in a network sandbox
  and the sound file to be loaded is local.</li>
  
      <li>By default, loading and playing a sound is not allowed if the calling file is local and 
  tries to load and play a remote sound. A user must grant explicit permission to allow this type of access.</li>
  
      <li>Certain operations dealing with sound are restricted. The data in a loaded sound cannot
  be accessed by a file in a different domain unless you implement a cross-domain policy file.
  Sound-related APIs that fall under this restriction are <codeph>Sound.id3</codeph>, 
  <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph>, 
  and the <codeph>SoundTransform</codeph> class.</li>
  
  </ul>
  
  <p>However, in Adobe AIR, content in the <codeph>application</codeph> security sandbox (content
  installed with the AIR application) are not restricted by these security limitations.</p>
  
  <p>For more information related to security, see the following:</p>
  
  <ul>
  
  <li product="flex">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
  in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
  <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
  in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
  
    <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
  
  </ul>
  
  </apiDesc><example conref="examples\SoundExample.as"> The following example displays 
 information about sound events that take place as an MP3 file is opened and played. To run this example, 
 place a file named MySound.mp3 in the same directory as your SWF file.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;

    public class SoundExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var song:SoundChannel;

        public function SoundExample() {
            var request:URLRequest = new URLRequest(url);
            var soundFactory:Sound = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);
            song = soundFactory.play();
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.media.xml#Microphone"><linktext>Microphone</linktext></link><link href="flash.media.xml#SoundChannel"><linktext>SoundChannel</linktext></link><link href="flash.media.xml#SoundMixer"><linktext>SoundMixer</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:Sound_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Dispatched when data is received as a load operation progresses.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when data is received as a load operation progresses.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Dispatched when a load operation starts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a load operation starts.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Dispatched when an input/output error occurs that causes a load operation to fail.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when an input/output error occurs that causes a load operation to fail. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.ID3_id3"><apiName>id3</apiName><shortdesc>
 Dispatched by a Sound object when ID3 data is available for an MP3 sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ID3</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched by a Sound object when ID3 data is available for an MP3 sound. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Dispatched when data has loaded successfully.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when data has loaded successfully. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.SAMPLE_DATA_sampleData"><apiName>sampleData</apiName><shortdesc>
  Dispatched when the player requests new audio data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SAMPLE_DATA</apiEventType><adobeApiEventClassifier>flash.events.SampleDataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  Dispatched when the player requests new audio data. 
 
 </apiDesc><example conref="examples\Sound_SampleDataExample.as"> The following example plays a simple sine wave.
 
<codeblock>
var mySound:Sound = new Sound();
function sineWaveGenerator(event:SampleDataEvent):void {
    for ( var c:int=0; c&lt;8192; c++ ) {
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
    }
}

mySound.addEventListener(Event.SAMPLE_DATA,sineWaveGenerator);
mySound.play();
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/extract()"><linktext>extract()</linktext></link><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.events.xml#SampleDataEvent"><linktext>flash.events.SampleDataEvent</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.media:Sound:Sound"><apiName>Sound</apiName><shortdesc>
     Creates a new Sound object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc> The URL that points to an external MP3 file.
     
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> An optional SoundLoader context object, which can define the buffer time 
	 (the minimum number of milliseconds of MP3 data to hold in the Sound object's 
	 buffer) and can specify whether the application should check for a cross-domain
	 policy file prior to loading the sound.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new Sound object. If you pass a valid URLRequest object to the 
     Sound constructor, the constructor automatically calls the <codeph>load()</codeph> function 
     for the Sound object. 
     If you do not pass a valid URLRequest object to the Sound constructor,
     you must call the <codeph>load()</codeph> function for the Sound object yourself, 
     or the stream will not load.
     
     <p>Once <codeph>load()</codeph> is called on a Sound object, you can't later load 
     a different sound file into that Sound object. To load a different sound file,
     create a new Sound object.</p>
     
     In Flash Player 10 and later and AIR 1.5 and later, instead of using <codeph>load()</codeph>, 
     you can use the <codeph>sampleData</codeph> event handler to load sound dynamically into the Sound object.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Sound:close"><apiName>close</apiName><shortdesc>
     Closes the stream, causing any download of data to cease.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>The stream could not be closed, or
     the stream was not open.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Closes the stream, causing any download of data to cease.
     No data may be read from the stream after the <codeph>close()</codeph>
     method is called.
     
     </apiDesc><example conref="examples\Sound_closeExample.as"> In the following example, when the user clicks on the Stop button,
 the <codeph>Sound.close()</codeph> method will be called and the sound will stop streaming.
 
 <p>In the constructor, a text field is created for the Start and Stop button. 
 When the user clicks on the text field, the <codeph>clickHandler()</codeph> method is invoked.
 It handles the starting and stopping of the sound file. Note that depending on 
 the network connection or when the user clicks the Stop button, much of the file could 
 already have been loaded and it may take a while for the sound file to stop playing. 
 A <codeph>try...catch</codeph> block is used to catch any IO error that may occur while 
 closing the stream. For example, if the sound is loaded from a local directory and 
 not streamed, error 2029 is caught, stating, "This URLStream object does not have an open stream."</p> 
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;    
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;

    public class Sound_closeExample extends Sprite {
        private var snd:Sound = new Sound();
        private var button:TextField = new TextField();
        private var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
        
        public function Sound_closeExample() {
            button.x = 10;
            button.y = 10;
            button.text = "START";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.LEFT;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {

            if(button.text == "START") {

                snd.load(req);
                snd.play();        

                snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);

                button.text = "STOP";
            }
            else if(button.text == "STOP") {
                    
                try {
                    snd.close();
                    button.text = "Wait for loaded stream to finish.";
                }
                catch (error:IOError) {
                    button.text = "Couldn't close stream " + error.message;    
                }
            }
        }
        
        private function errorHandler(event:IOErrorEvent):void {
                button.text = "Couldn't load the file " + event.text;
        }
    }
}


</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:extract"><apiName>extract</apiName><shortdesc>
      Extracts raw sound data from a Sound object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The number of samples that are available in the Sound object.
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>A ByteArray object in which the extracted sound samples are placed.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>The number of sound samples to extract. 
      A sample contains both the left and right channels — that is, two 32-bit floating-point values.
          
     </apiDesc></apiParam><apiParam><apiItemName>startPosition</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>-1</apiData><apiDesc>The sample at which extraction begins.
          If you don't specify a value, the first call to <codeph>Sound.extract()</codeph> starts at the beginning
          of the sound; subsequent calls without a value for <codeph>startPosition</codeph>
          progress sequentially through the file.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
      Extracts raw sound data from a Sound object.
     
      <p>This method is designed to be used when you are working 
      with dynamically generated audio, using a function you assign
      to the <codeph>sampleData</codeph> event for a different Sound object. 
      That is, you can use this method to extract sound data from a Sound object.
      Then you can write the data to the byte array that another Sound object is using
      to stream dynamic audio.</p>
     
      <p>The audio data is placed in the target byte array starting from the current position of the byte array.
      The audio data is always exposed as 44100 Hz Stereo. The sample type is a 32-bit floating-point value,
      which can be converted to a Number using <codeph>ByteArray.readFloat()</codeph>. </p>
     
     </apiDesc><example conref="examples\Sound_extractExample.as"> The following example loads an mp3 file and uses the 
 <codeph>extract()</codeph> method of the Sound class to access the audio data.
 <p>The mp3 data is loaded into the <codeph>sourceSnd</codeph> Sound object. When the
 application loads the mp3 data, it calls the <codeph>loaded()</codeph> function
 (the event handler for the <codeph>complete</codeph> event of the <codeph>sourceSnd</codeph>
 object). A second Sound object, <codeph>outputSound</codeph>, is used to play the 
 modified audio. The <codeph>outputSound</codeph> object has a <codeph>sampleData</codeph>
 event listener; so the object dispatches periodical <codeph>sampleData</codeph> events
 once you call the <codeph>play()</codeph> method of the object. 
 The <codeph>upOctave()</codeph> method returns a byte array of modified audio data
 based on the source audio data. It returns audio that is one octave higher by 
 skipping over every other audio sample in the source data. The event handler for 
 the <codeph>sampleData</codeph> event writes the returned byte array to the <codeph>data</codeph> 
 property of the <codeph>outputSound</codeph> object. The <codeph>data</codeph> byte array is 
 appended to the output audio data for the <codeph>outputSound</codeph> object.</p>
 <p>To test this example, add a test.mp3 file to the same directory as the SWF file.</p>
<codeblock>

var sourceSnd:Sound = new Sound();
var outputSnd:Sound = new Sound();
var urlReq:URLRequest = new URLRequest("test.mp3");

sourceSnd.load(urlReq);
sourceSnd.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void
{
    outputSnd.addEventListener(SampleDataEvent.SAMPLE_DATA, processSound);
    outputSnd.play();
}

function processSound(event:SampleDataEvent):void
{
    var bytes:ByteArray = new ByteArray();
    sourceSnd.extract(bytes, 4096);
    event.data.writeBytes(upOctave(bytes));
}

function upOctave(bytes:ByteArray):ByteArray
{
    var returnBytes:ByteArray = new ByteArray();
    bytes.position = 0;
    while(bytes.bytesAvailable &gt; 0)
    {
        returnBytes.writeFloat(bytes.readFloat());
        returnBytes.writeFloat(bytes.readFloat());
        if (bytes.bytesAvailable &gt; 0)
        {
            bytes.position += 8;
        }
    }
    return returnBytes;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Sound/event:sampleData"><linktext>sampleData</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Sound:load"><apiName>load</apiName><shortdesc>
     Initiates loading of an external MP3 file from the specified URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>A network error caused the load to fail.
	 
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Local untrusted files may not communicate with
     the Internet. You can work around this by reclassifying this file
     as <ph platform="actionscript">local-with-networking or</ph> trusted.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>If you are trying to connect to a commonly reserved port. 
      For a complete list of blocked ports, see "Restricting Networking APIs" in the 
      security chapter of the <i>Programming ActionScript 3.0</i> book.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>The <codeph>digest</codeph> property of the <codeph>stream</codeph> object is not 
     <codeph>null</codeph>. You should only set the <codeph>digest</codeph> property of a URLRequest object
     when calling the <codeph>URLLoader.load()</codeph> method when loading a SWZ file (an Adobe 
     platform component).
     
      </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>If you are trying to connect to a commonly reserved port. 
      For a complete list of blocked ports, see "Restricting Networking APIs" in the 
      security chapter of the <i>Programming ActionScript 3.0</i> book.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> A URL that points to an external MP3 file.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> An optional SoundLoader context object, which can define the buffer time 
	 (the minimum number of milliseconds of MP3 data to hold in the Sound object's 
	 buffer) and can specify whether the application should check for a cross-domain
	 policy file prior to loading the sound.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Initiates loading of an external MP3 file from the specified URL. If you provide
     a valid URLRequest object to the Sound constructor, the constructor calls
     <codeph>Sound.load()</codeph> for you. You only need to call <codeph>Sound.load()</codeph>
     yourself if you
     don't pass a valid URLRequest object to the Sound constructor or you pass a <codeph>null</codeph>
     value.
     
     <p>Once <codeph>load()</codeph> is called on a Sound object, you can't later load 
     a different sound file into that Sound object. To load a different sound file,
     create a new Sound object.</p>
     
	 <p platform="actionscript">When using this method, consider the following security model:</p>
     
     <ul platform="actionscript">
     
     <li>Calling <codeph>Sound.load()</codeph> is not allowed if the calling file is in the 
     local-with-file-system sandbox and the sound is in a network sandbox.</li>
     
     <li>Access from the local-trusted or local-with-networking sandbox requires permission 
     from a website through a URL policy file.</li>
     
      <li>You cannot connect to commonly reserved ports. For a complete list of blocked
     ports, see "Restricting Networking APIs" in the 
     <ph product="flex">
     <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
     </ph>
     <ph product="flash">
     <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
     </ph>
      of the <i>Programming ActionScript 3.0</i> book. </li>
     
     <li>You can prevent a SWF file from using this method by setting the 
     <codeph>allowNetworking</codeph> parameter of the <codeph>object</codeph> and <codeph>embed</codeph> 
     tags in the HTML page that contains the SWF content.</li>
     
     </ul>
     
     <p platform="actionscript"> In Flash Player 10 and later, if you use a multipart Content-Type (for example "multipart/form-data") 
	 that contains an upload (indicated by a "filename" parameter in a "content-disposition" header within the POST body),
	 the POST operation is subject to the security rules applied to uploads:</p>
	 <ul platform="actionscript">
	 <li>The POST operation must be performed in response to a user-initiated action, such as a mouse click or key press.</li>
	 <li>If the POST operation is cross-domain (the POST target is not on the same server as the SWF file 
	 that is sending the POST request),
	 the target server must provide a URL policy file that permits cross-domain access.</li>
	 </ul>
     <p platform="actionscript">Also, for any multipart Content-Type, the syntax must be valid (according to the RFC2046 standards).
     If the syntax appears to be invalid, the POST operation is subject to the security rules applied to uploads.</p>
     <p platform="actionscript">In Adobe AIR, content in the <codeph>application</codeph> security sandbox (content
     installed with the AIR application) are not restricted by these security limitations.</p>
     
     <p platform="actionscript">For more security-related information, see the following:</p>
     
     <ul platform="actionscript">
     
     <li class="flexonly">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     <li>The "Understanding AIR Security" section of the "Getting started with Adobe AIR" chapter in the 
     <i>Developing AIR Applications</i> book.</li>
       <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\Sound_loadExample.as"> The following example displays the loading progress of a sound file.
 
 <p>In the constructor a <codeph>URLRequest</codeph> object is created to identify the location 
 of the sound file, which is a podcast from Adobe. The file is loaded in a <codeph>try...catch</codeph> 
 block in order to catch any error that may occur while loading the file. If an IO error 
 occurred, the <codeph>errorHandler()</codeph> method also is invoked and the error message 
 is written in the text field intended for the progress report. While a load operation is in 
 progress, a <codeph>ProgressEvent.PROGRESS</codeph> event is dispatched and the <codeph>progressHandler()</codeph> 
 method is called. Here, <codeph>ProgressEvent.PROGRESS</codeph> event is used as a timer for 
 calculating the load progress.</p> 
  
 <p>The <codeph>progressHandler()</codeph> method divides the <codeph>bytesLoaded</codeph> value 
 passed with the <codeph>ProgressEvent</codeph> object by the <codeph>bytesTotal</codeph> value to 
 arrive at a percentage of the sound data that is being loaded. It then displays these values 
 in the text field. (Note that if the file is small, cached, or the file is in the local directory, 
 the progress may not be noticeable.)</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.ProgressEvent;
    import flash.events.IOErrorEvent;
    
    public class Sound_loadExample extends Sprite {
        private var snd:Sound = new Sound();
        private var statusTextField:TextField  = new TextField();

        public function Sound_loadExample(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
            snd.load(req);
            
            snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(ProgressEvent.PROGRESS, progressHandler);
                     
            this.addChild(statusTextField);
        }
    
        private function progressHandler(event:ProgressEvent):void {
            var loadTime:Number = event.bytesLoaded / event.bytesTotal;
            var LoadPercent:uint = Math.round(100 * loadTime);
              
            statusTextField.text = "Sound file's size in bytes: " + event.bytesTotal + "\n" 
                                 + "Bytes being loaded: " + event.bytesLoaded + "\n" 
                                 + "Percentage of sound file that is loaded " + LoadPercent + "%.\n";
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:play"><apiName>play</apiName><shortdesc>
     Generates a new SoundChannel object to play back the sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A SoundChannel object, which you use to control the sound. 
     This method returns <codeph>null</codeph> if you have no sound card 
     or if you run out of available sound channels. The maximum number of 
     sound channels available at once is 32.
     
     </apiDesc><apiOperationClassifier>flash.media:SoundChannel</apiOperationClassifier></apiReturn><apiParam><apiItemName>startTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>The initial position in milliseconds at which playback should 
     start.
     </apiDesc></apiParam><apiParam><apiItemName>loops</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Defines the number of times a sound loops back to the <codeph>startTime</codeph> value
     before the sound channel stops playback. 
     </apiDesc></apiParam><apiParam><apiItemName>sndTransform</apiItemName><apiOperationClassifier>flash.media:SoundTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>The initial SoundTransform object assigned to the sound channel.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Generates a new SoundChannel object to play back the sound. This method
     returns a SoundChannel object, which you access to stop the sound and to monitor volume. 
     (To control the volume, panning, and balance, access the SoundTransform object assigned
     to the sound channel.)
     
     </apiDesc><example conref="examples\Sound_playExample1.as"> In the following example, once the file is loaded, the user using a
 graphic bar can select the starting position (starting time) of the sound file.
 
 <p>The constructor calls the <codeph>Sound.load()</codeph> method to start loading the sound data. 
 Next it calls the <codeph>Sound.play()</codeph> method which will start playing the sound as soon 
 as enough data has loaded. The <codeph>Sound.play()</codeph> method returns a SoundChannel object 
 that can be used to control the playback of the sound. The text field displays the instructions. 
 To make sure the content of where the user wants the sound to start, has already been loaded, 
 the <codeph>bar</codeph> Sprite object is created and displayed after the file has finished loading. 
 An <codeph>Event.COMPLETE</codeph> event is dispatched when the file is successfully loaded, which 
 triggers the <codeph>completeHandler()</codeph> method. The <codeph>completeHandler()</codeph> method 
 then creates the bar and adds it to the display list. (A sprite object is used instead of a shape 
 object to support interactivity.) When the user clicks on the bar, the <codeph>clickHandler()</codeph> 
 method is triggered.</p> 
 
 <p>In the <codeph>clickHandler()</codeph> method, the position of x coordinate of the user's click, 
 <codeph>event.localX</codeph>, is used to determine where the user wants the file to start. 
 Since the bar is 100 pixels and it starts at x coordinate 100 pixels, it is easy to determine 
 the percentage of the position. Also, since the file is loaded, the <codeph>length</codeph> 
 property of the sound file will have the length of the complete file in milliseconds. 
 Using the length of the sound file and the position in the line, a starting position 
 for the sound file is determined. After stopping the sound from playing, the sound file 
 restarts at the selected starting position, which is past as the <codeph>startTime</codeph> 
 parameter to the <codeph>play()</codeph> method.</p>
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.MouseEvent;
    import flash.media.Sound;;
    import flash.net.URLRequest;
    import flash.media.SoundChannel;
    import flash.events.ProgressEvent;
    import flash.events.Event;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample1 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var infoTextField:TextField = new TextField();
    
        public function Sound_playExample1() {

            var req:URLRequest = new URLRequest("MySound.mp3");
            
            infoTextField.autoSize = TextFieldAutoSize.LEFT;
            infoTextField.text = "Please wait for the file to be loaded.\n" 
                                + "Then select from the bar to decide where the file should start.";
            
            snd.load(req);               
            channel = snd.play();

            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(Event.COMPLETE, completeHandler);


            this.addChild(infoTextField);
        }

        private function completeHandler(event:Event):void {                
            infoTextField.text = "File is ready.";

            var bar:Sprite = new Sprite();

            bar.graphics.lineStyle(5, 0xFF0000);
            bar.graphics.moveTo(100, 100);
            bar.graphics.lineTo(200, 100);

            bar.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(bar);
        }
    
        private function clickHandler(event:MouseEvent):void {
            
                var position:uint = event.localX;
                var percent:uint = Math.round(position) - 100;   
                var cue:uint = (percent / 100) * snd.length;

                channel.stop();
                channel = snd.play(cue);    
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            infoTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample2.as"> In the following example, depending on whether the user single or double clicks on
 a button the sound will play once or twice.
 
 <p>In the constructor, the sound is loaded and a simple rectangle <codeph>button</codeph> sprite object 
 is created. (A sprite object is used instead of a shape object to support interactivity.)
 Here, it is assumed that the sound file is in the same directory as the SWF file. (There 
 is no error handling code for this example.)</p>
 
 <p>Two event listeners are set up to respond to single mouse clicks and double clicks.
 If the user clicks once, the <codeph>clickHandler()</codeph> method is invoked, which plays the sound. 
 If the user double clicks on the button, the <codeph>doubleClickHandler()</codeph> method is invoked, 
 which will play the sound file twice. The second argument of the <codeph>play()</codeph> method is set 
 to <codeph>1</codeph>, which means the sound will loop back once to the starting time of the 
 sound and play again. The starting time, first argument, is set to <codeph>0</codeph>, meaning 
 the file will play from the beginning.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.media.Sound;
    import flash.net.URLRequest;

    public class Sound_playExample2 extends Sprite {
        private var button:Sprite = new Sprite(); 
        private var snd:Sound = new Sound();
            
        public function Sound_playExample2() {

            var req:URLRequest = new URLRequest("click.mp3");
            snd.load(req);               
     
            button.graphics.beginFill(0x00FF00);
            button.graphics.drawRect(10, 10, 50, 30);
            button.graphics.endFill();
     
            button.addEventListener(MouseEvent.CLICK, clickHandler);
            button.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClickHandler);
     
            this.addChild(button);
        }

        private function clickHandler(event:MouseEvent):void {
            snd.play();            
        }

        private function doubleClickHandler(event:MouseEvent):void {
            snd.play(0, 2);        
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample3.as"> The following example displays the loading and playing progress of a sound file.
 
 <p>In the constructor, the file is loaded in a <codeph>try...catch</codeph> block in order to catch 
 any error that may occur while loading the file. A listener is added to the sound object that 
 will respond to an <codeph>IOErrorEvent</codeph> event by calling the <codeph>errorHandler()</codeph> method. 
 Another listener is added for the main application that will respond to an <codeph>Event.ENTER_FRAME</codeph> 
 event, which is used as the timing mechanism for showing playback progress. Finally, a third listener
 is added for the sound channel that will respond to an <codeph>Event.SOUND_COMPLETE</codeph> event (when
 the sound has finished playing), by calling the <codeph>soundCompleteHandler()</codeph> method.
 The <codeph>soundCompleteHandler()</codeph> method also removes the event listener for the 
 <codeph>Event.ENTER_FRAME</codeph> event.</p>
 
 <p>The <codeph>enterFrameHandler()</codeph> method divides the <codeph>bytesLoaded</codeph> value 
 passed with the <codeph>ProgressEvent</codeph> object by the <codeph>bytesTotal</codeph> value to 
 arrive at a percentage of the sound data that is being loaded. The percentage of sound data that is 
 being played could be determined by dividing the value of sound channel's <codeph>position</codeph> property
 by the length of the sound data. However, if the sound data is not fully loaded, the <codeph>length</codeph>
 property of the sound object shows only the size of the sound data that is currently loaded.
 An estimate of the eventual size of the full sound file is calculated by dividing the value 
 of the current sound object's <codeph>length</codeph> by the value of the <codeph>bytesLoaded</codeph>
 property divided by the value of the <codeph>bytesTotal</codeph> property.</p>
 
 <p>Note that if the file is small, cached, or the file is in the local directory, the load progress 
 may not be noticeable. Also the lag time between when the sound data starts loading and the loaded 
 data starts playing is determined by the value of the <codeph>SoundLoaderContext.buffertime</codeph> 
 property, which is by default 1000 milliseconds and can be reset.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample3 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel;
        private var statusTextField:TextField  = new TextField();

        public function Sound_playExample3(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;

           var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
                snd.load(req);
            
                channel = snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
                    
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                    
            this.addChild(statusTextField);
        }
    
        private function enterFrameHandler(event:Event):void {    
            var loadTime:Number = snd.bytesLoaded / snd.bytesTotal;
            var loadPercent:uint = Math.round(100 * loadTime);
            var estimatedLength:int = Math.ceil(snd.length / (loadTime));
            var playbackPercent:uint = Math.round(100 * (channel.position / estimatedLength));
      
            statusTextField.text = "Sound file's size is " + snd.bytesTotal + " bytes.\n" 
                                   + "Bytes being loaded: " + snd.bytesLoaded + "\n" 
                                   + "Percentage of sound file that is loaded " + loadPercent + "%.\n"
                                   + "Sound playback is " + playbackPercent + "% complete.";     
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }

        private function soundCompleteHandler(event:Event):void {
            statusTextField.text = "The sound has finished playing.";
            removeEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundChannel/stop()"><linktext>SoundChannel.stop()</linktext></link><link href="flash.media.xml#SoundMixer/stopAll()"><linktext>SoundMixer.stopAll()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Sound:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
     Returns the currently available number of bytes in this sound object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Returns the currently available number of bytes in this sound object. This property is 
     usually useful only for externally loaded files.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
     Returns the total number of bytes in this sound object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Returns the total number of bytes in this sound object. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:id3:get"><apiName>id3</apiName><shortdesc>
     Provides access to the metadata that is part of an MP3 file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sound, Sound.id3, id3, mp3
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.media:ID3Info</apiValueClassifier></apiValueDef><apiDesc>
     Provides access to the metadata that is part of an MP3 file.
     
     <p>MP3 sound files can contain ID3 tags, which provide metadata about the 
     file. If an MP3 sound that you load using the <codeph>Sound.load()</codeph> 
     method contains ID3 tags, you can query these properties. Only ID3 tags 
     that use the UTF-8 character set are supported.</p>
     
	 <p><ph outputclass="actionscript">Flash Player 9 and later and the AIR runtime support</ph> 
	 <ph platform="javascript">The AIR runtime supports</ph> ID3 2.0 tags, 
     specifically 2.3 and 2.4. The following tables list the standard ID3 2.0 tags 
     and the type of content the tags represent. The <codeph>Sound.id3</codeph> property provides
     access to these tags through the format 
     <codeph>my_sound.id3.COMM</codeph>, <codeph>my_sound.id3.TIME</codeph>, and so on. The first
     table describes tags that can be accessed either through the ID3 2.0 property name or
     the ActionScript property name. The second table describes ID3 tags that are supported but do not have
     predefined properties in ActionScript. </p>
     
     <adobetable class="innertable">
       
      
      
      
     
     
     
     
     <tgroup cols="2"><tbody><row>
         <entry><b>ID3 2.0 tag</b></entry>
	    <entry><b>Corresponding Sound class property</b></entry>
      </row><row>
        <entry>COMM</entry>
        <entry>Sound.id3.comment</entry>
      </row><row>
        <entry>TALB</entry>
        <entry>Sound.id3.album </entry>
      </row><row>
     
       <entry>TCON</entry>
       <entry>Sound.id3.genre</entry>
      </row><row>
       <entry>TIT2</entry>
       <entry>Sound.id3.songName </entry>
     </row><row>
       <entry>TPE1</entry>
       <entry>Sound.id3.artist</entry>
     </row><row>
       <entry>TRCK</entry>
       <entry>Sound.id3.track </entry>
     </row><row>
       <entry>TYER</entry>
       <entry>Sound.id3.year </entry>
     </row></tbody></tgroup></adobetable>
     
     <p>The following table describes ID3 tags that are supported but do not have
	 predefined properties in the Sound class. You access them by calling 
     <codeph>mySound.id3.TFLT</codeph>, <codeph>mySound.id3.TIME</codeph>, and so on.</p>  
      <adobetable class="innertable">
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      <tgroup cols="2"><tbody><row>
          <entry><b>Property</b></entry>
          <entry><b>Description</b></entry>
        </row><row>
          <entry>TFLT</entry>
          <entry>File type</entry>
        </row><row>
          <entry>TIME</entry>
          <entry>Time</entry>
        </row><row>
          <entry>TIT1</entry>
          <entry>Content group description</entry>
        </row><row>
          <entry>TIT2</entry>
          <entry>Title/song name/content description</entry>
        </row><row>
          <entry>TIT3</entry>
          <entry>Subtitle/description refinement</entry>
        </row><row>
          <entry>TKEY</entry>
          <entry>Initial key</entry>
        </row><row>
          <entry>TLAN</entry>
          <entry>Languages</entry>
        </row><row>
          <entry>TLEN</entry>
          <entry>Length</entry>
        </row><row>
          <entry>TMED</entry>
          <entry>Media type</entry>
        </row><row>
          <entry>TOAL</entry>
          <entry>Original album/movie/show title</entry>
        </row><row>
          <entry>TOFN</entry>
          <entry>Original filename</entry>
        </row><row>
          <entry>TOLY</entry>
          <entry>Original lyricists/text writers</entry>
        </row><row>
          <entry>TOPE</entry>
          <entry>Original artists/performers</entry>
        </row><row>
          <entry>TORY</entry>
          <entry>Original release year</entry>
        </row><row>
          <entry>TOWN</entry>
          <entry>File owner/licensee</entry>
        </row><row>
          <entry>TPE1</entry>
          <entry>Lead performers/soloists</entry>
        </row><row>
          <entry>TPE2</entry>
          <entry>Band/orchestra/accompaniment</entry>
        </row><row>
          <entry>TPE3</entry>
          <entry>Conductor/performer refinement</entry>
        </row><row>
          <entry>TPE4</entry>
          <entry>Interpreted, remixed, or otherwise modified by</entry>
        </row><row>
          <entry>TPOS</entry>
          <entry>Part of a set</entry>
        </row><row>
          <entry>TPUB</entry>
          <entry>Publisher</entry>
        </row><row>
          <entry>TRCK</entry>
          <entry>Track number/position in set</entry>
        </row><row>
          <entry>TRDA</entry>
          <entry>Recording dates</entry>
        </row><row>
          <entry>TRSN</entry>
          <entry>Internet radio station name</entry>
        </row><row>
          <entry>TRSO</entry>
          <entry>Internet radio station owner</entry>
        </row><row>
          <entry>TSIZ</entry>
          <entry>Size</entry>
        </row><row>
          <entry>TSRC</entry>
          <entry>ISRC (international standard recording code)</entry>
        </row><row>
          <entry>TSSE</entry>
          <entry>Software/hardware and settings used for encoding</entry>
        </row><row>
          <entry>TYER</entry>
          <entry>Year</entry>
        </row><row>
          <entry>WXXX</entry>
          <entry>URL link frame</entry>
        </row></tbody></tgroup></adobetable>
     
     
     <p>When using this property, consider the Flash Player security model:</p>
     
     <ul>
     
     <li>The <codeph>id3</codeph> property of a Sound object is always permitted for SWF files 
     that are in the same security sandbox as the sound file. For files in other sandboxes, there 
     are security checks.</li>
     
     <li>When you load the sound, using the <codeph>load()</codeph> method of the Sound class, you can  
     specify a <codeph>context</codeph> parameter, which is a SoundLoaderContext object. If you set the 
     <codeph>checkPolicyFile</codeph>  property of the SoundLoaderContext object to <codeph>true</codeph>, Flash Player 
     checks for a URL policy file on the server from which the sound is loaded. If a 
     policy file exists and permits access from the domain of the loading SWF file, then the file is allowed 
     to access the <codeph>id3</codeph> property of the Sound object; otherwise it is not.</li>
     
     </ul>
     
     <p>However, in Adobe AIR, content in the <codeph>application</codeph> security sandbox (content
     installed with the AIR application) are not restricted by these security limitations.</p>
     
     <p>For more information related to security, see the following:</p>
     
     <ul>
     
     <li product="flex">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     
       <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
     
     </ul>
     
     

     
     </apiDesc><example conref="examples\Sound_id3Example.as"> The following example reads the ID3 information from a sound file and displays
 it in a text field.
 
 <p>In the constructor, the sound file is loaded but it is not set to play. Here, it is 
 assumed that the file is in the SWF directory. The system must have permission 
 in order to read the ID3 tags of a loaded sound file. If there is ID3 information in 
 the file and the program is permitted to read it, an <codeph>Event.ID3</codeph> event will 
 be fired and the <codeph>id3</codeph> property of the sound file will be populated. 
 The <codeph>id3</codeph> property contains an <codeph>ID3Info</codeph> object with all 
 of the ID3 information.</p>
 
 <p>In the <codeph>id3Handler()</codeph> method, the file's ID3 tags
 are stored in <codeph>id3</codeph>, an ID3Info class object. A text field is 
 instantiated to display the list of the ID3 tags. The for loop iterates 
 through all the ID3 2.0 tags and appends the name and value to the content of 
 the text field. Using ID3 info (<codeph>ID3Info</codeph>) properties, the artist, 
 song name, and album are also appended. ActionScript 3.0 
 and Flash Player 9 and later support ID3 2.0 tags, specifically 2.3 and 2.4.
 If you iterate through properties like in the for loop, only ID3 2.0 tags will appear. 
 However, the data from the earlier versions are also stored in the song's <codeph>id3</codeph> 
 property and can be accessed using ID3 info class properties. 
 The tags for the ID3 1.0 are at the end of the file while the ID3 2.0 tags are in 
 the beginning of the file. (Sometimes, the files may have both earlier and later version 
 tags in the same place.) If a file encoded with both version 1.0 and 2.0 tags at the 
 beginning and the end of the file, the method <codeph>id3Handler()</codeph> will be invoked twice. 
 It first reads the 2.0 version and then the version 1.0. If only ID3 1.0 tag is available, 
 then the information is accessible via the ID3 info properties, like <codeph>id3.songname</codeph>. 
 For ID3 2.0, <codeph>id3.TITS</codeph> property will retrieve the song name using the new tag (TITS).</p>
 
 <p>Note that no error handling is written for this example and if the ID3 content is long,
 the result may go beyond the viewable area.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.net.URLRequest;
    import flash.media.ID3Info;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;

    public class Sound_id3Example extends Sprite {
        private var snd:Sound = new Sound();       
        private var myTextField:TextField = new TextField();

        public function Sound_id3Example() {
            snd.addEventListener(Event.ID3, id3Handler);
            snd.load(new URLRequest("mySound.mp3"));
        }
    
        private function id3Handler(event:Event):void {
            var id3:ID3Info = snd.id3;

            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.border = true;

            myTextField.appendText("Received ID3 Info: \n");
              
            for (var propName:String in id3) {
                myTextField.appendText(propName + " = " + id3[propName] + "\n");
            }
 
            myTextField.appendText("\n" + "Artist: " + id3.artist + "\n");
            myTextField.appendText("Song name: " + id3.songName + "\n");
            myTextField.appendText("Album: " + id3.album + "\n\n"); 
 
            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiValue><apiValue id="flash.media:Sound:isBuffering:get"><apiName>isBuffering</apiName><shortdesc>
     Returns the buffering state of external MP3 files.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Returns the buffering state of external MP3 files. If the value is <codeph>true</codeph>, 
     any playback is 
     currently suspended while the object waits for more data.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:length:get"><apiName>length</apiName><shortdesc>
     The length of the current sound in milliseconds.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     The length of the current sound in milliseconds.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:url:get"><apiName>url</apiName><shortdesc>
     The URL from which this sound was loaded.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     The URL from which this sound was loaded. This property is applicable only to Sound 
     objects that were loaded using the <codeph>Sound.load()</codeph> method. For
     Sound objects that are associated with a sound asset from a SWF file's library, the
     value of the <codeph>url</codeph> property is <codeph>null</codeph>.
     
     <p>When you first call <codeph>Sound.load()</codeph>, the <codeph>url</codeph> property 
     initially has a value of <codeph>null</codeph>, because the final URL is not yet known.
     The <codeph>url</codeph> property will have a non-null value as soon as an
     <codeph>open</codeph> event is dispatched from the Sound object.</p>
     
     <p>The <codeph>url</codeph> property contains the final, absolute URL from which a sound was
     loaded. The value of <codeph>url</codeph> is usually the same as the value passed to the 
     <codeph>stream</codeph> parameter of <codeph>Sound.load()</codeph>. 
     However, if you passed a relative URL to <codeph>Sound.load()</codeph>
     the value of the <codeph>url</codeph> property represents the absolute URL.
     Additionally, if the original URL request is redirected by an HTTP server, the value
     of the <codeph>url</codeph> property reflects the final URL from which the sound file was actually
     downloaded.  This reporting of an absolute, final URL is equivalent to the behavior of
     <codeph>LoaderInfo.url</codeph>.</p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
 The SoundLoaderContext class provides security checks for files that load sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 The SoundLoaderContext class provides security checks for files that load sound.
 SoundLoaderContext objects are passed as an argument to the constructor and the
 <codeph>load()</codeph> method of the Sound class.
 
 <p>When you use this class, consider the following security model: </p>
 
 <ul>
 <li>Loading and playing a sound is not allowed if the calling file is in a network sandbox
 and the sound file to be loaded is local.</li>
 
 	<li>By default, loading and playing a sound is not allowed if the calling is local and 
 tries to load and play a remote sound. A user must grant explicit permission to allow this.</li>
 
 	<li>Certain operations dealing with sound are restricted. The data in a loaded sound cannot
 be accessed by a file in a different domain unless you implement a URL policy file.
 Sound-related APIs that fall under this restriction are the <codeph>Sound.id3</codeph> property and the 
 <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph>, 
 and <codeph>SoundTransform()</codeph> methods.</li>
 
 </ul>
 
 <p>However, in Adobe AIR, content in the <codeph>application</codeph> security sandbox (content
 installed with the AIR application) are not restricted by these security limitations.</p>
 
 <p>For more information related to security, see the following:</p>
 
 <ul>
 
 <li class="flexonly">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
 in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
 <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
 in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
 
 <li>The "Understanding AIR Security" section of the "Getting started with Adobe AIR" chapter in the 
 <i>Developing AIR Applications</i> book.</li>
 
   <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/devnet/flashplayer/security.html" scope="external">Security</xref></li>
 
 </ul>
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.media:SoundLoaderContext:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
     Creates a new sound loader context object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bufferTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1000</apiData><apiDesc>The number of seconds to preload a streaming sound into a buffer
     before the sound starts to stream.
     
     </apiDesc></apiParam><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Specifies whether the existence of a URL policy file 
	 should be checked upon loading the object (<codeph>true</codeph>) or not.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new sound loader context object.  
     
     </apiDesc><example conref="examples\SoundLoaderContextExample.as"> In the following example, the buffer for the sound that will be loaded 
 is set to three seconds.
 
 <p>The first parameter of a SoundLoaderContext object (<codeph>context</codeph>) is used to increase 
 the default buffer value of one second to three seconds. (The value is in milliseconds.) 
 If the second parameter of the SoundLoaderContext object is set to <codeph>true</codeph>, 
 Flash Player will check for a cross-domain policy file upon loading the object. Here it is 
 set to the default value <codeph>false</codeph>, so no policy file will be checked. 
 The <codeph>load()</codeph> method of the sound object will use the context setting to make sure 
 it will take three seconds to preload the streaming sound into a buffer before the sound starts 
 to stream. The <codeph>URLRequest</codeph> object determines the location of the file, which is a 
 podcast from Adobe. If an <codeph>IOErrorEvent.IO_ERROR</codeph> error occurs during the loading 
 of the sound file, the <codeph>errorHandler()</codeph> method is invoked.</p> 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.events.IOErrorEvent;
    
    public class SoundLoaderContextExample extends Sprite {

        public function SoundLoaderContextExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            var context:SoundLoaderContext = new SoundLoaderContext(3000, false);

            snd.load(req, context);
            snd.play();      
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }

    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundLoaderContext:bufferTime"><apiName>bufferTime</apiName><shortdesc>
	 The number of milliseconds to preload a streaming sound into a buffer
	 before the sound starts to stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1000</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 The number of milliseconds to preload a streaming sound into a buffer
	 before the sound starts to stream.
	 
	 <p>Note that you cannot override the value of <codeph>SoundLoaderContext.bufferTime</codeph>
	 by setting the global <codeph>SoundMixer.bufferTime</codeph> property. 
	 <ph platform="actionscript">The <codeph>SoundMixer.bufferTime</codeph> property affects the buffer time 
	 for embedded streaming sounds in a SWF file and is independent of dynamically created 
	 Sound objects (that is, Sound objects created in ActionScript).</ph></p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundLoaderContext:checkPolicyFile"><apiName>checkPolicyFile</apiName><shortdesc>
	 Specifies whether the application should try to download a URL policy file from the
	 loaded sound's server before beginning to load the sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext, NetStream
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Specifies whether the application should try to download a URL policy file from the
	 loaded sound's server before beginning to load the sound. This property applies to
	 sound that is loaded from outside
	 the calling file's own domain using the <codeph>Sound.load()</codeph> method.
	 
	 <p platform="javascript">This property only applies to SWF content running outside
	 of the AIR application sandbox. </p>
	 
	 <p platform="actionscript">Set this property to <codeph>true</codeph> when you load a sound from outside the  
	 calling file's own domain and code in the calling file needs low-level access to 
	 the sound's data. Examples of low-level access to a sound's data 
	 include referencing the <codeph>Sound.id3</codeph> property to get an
	 ID3Info object or calling the <codeph>SoundMixer.computeSpectrum()</codeph> method to get
	 sound samples from the loaded sound. If you try to access sound data without
	 setting the <codeph>checkPolicyFile</codeph> property to <codeph>true</codeph> at loading time,
	 you may get a SecurityError exception because the required policy file has not been downloaded.</p>
	 
	 <p platform="actionscript">If you don't need low-level access to the sound data that you are loading, avoid setting
	 <codeph>checkPolicyFile</codeph> to <codeph>true</codeph>. Checking for a policy file consumes 
	 network bandwidth 
	 and might delay the start of your download, so it should only be done when necessary.</p>
	 
	 <p platform="actionscript">When you call <codeph>Sound.load()</codeph> with <codeph>SoundLoaderContext.checkPolicyFile</codeph> set
	 to <codeph>true</codeph>, Flash Player or AIR  must 
	 either successfully download a relevant URL policy file or determine that no such policy file 
	 exists before it begins downloading the specified sound. 
	 <ph platform="actionscript">Flash Player or</ph> AIR performs the following
	 actions, in this order, to verify the existence of a policy file:</p>
	 
	 <ul platform="actionscript">
	 
	 <li>Flash Player or AIR considers policy files that have already been downloaded.</li>
	 
	 <li>Flash Player or AIR tries to download any pending policy files specified in calls to 
	 <codeph>Security.loadPolicyFile()</codeph>.</li>
	 
	 <li>Flash Player or AIR tries to download a 
	 policy file from the default location that corresponds to the sound's URL, which is
	 <codeph>/crossdomain.xml</codeph> on the same server as <codeph>URLRequest.url</codeph>.
	 (The sound's URL is specified in the <codeph>url</codeph> property of the URLRequest object
	 passed to <codeph>Sound.load()</codeph> or the Sound() constructor function.)</li>
	 </ul>
	 
	 <p platform="actionscript">In all cases, Flash Player or AIR
	 requires that an appropriate policy file exist on the sound's server, that it provide access
	 to the sound file at <codeph>URLRequest.url</codeph> by virtue of the policy file's location, and
	 that it allow the domain of the calling file to access the sound, through one or more
	 <codeph>&lt;allow-access-from&gt;</codeph> tags.
	 </p>
	 
	 <p platform="actionscript">If you set <codeph>checkPolicyFile</codeph> to <codeph>true</codeph>, 
	 Flash Player or AIR waits until the policy file is verified
	 before loading the sound. You should wait to perform
	 any low-level operations on the sound data, such as calling <codeph>Sound.id3</codeph> or 
	 <codeph>SoundMixer.computeSpectrum()</codeph>, until <codeph>progress</codeph> and <codeph>complete</codeph>
	 events are dispatched from the Sound object.
	 </p>
	 
	 <p platform="actionscript">If you set <codeph>checkPolicyFile</codeph> to <codeph>true</codeph> but no appropriate policy file is found,
	 you will not receive an error until you perform an operation that requires 
	 a policy file, and then Flash Player or AIR throws a
	 <codeph>SecurityError</codeph> exception. After you receive a <codeph>complete</codeph>
	 event, you can test whether a relevant policy file was found by getting the value
	 of <codeph>Sound.id3</codeph> within a <codeph>try</codeph> block and seeing if a
	 <codeph>SecurityError</codeph> is thrown.</p>
	 
	 
	 <p platform="actionscript">Be careful with <codeph>checkPolicyFile</codeph> if you are downloading sound from a URL that 
	 uses server-side HTTP redirects. Flash Player or AIR tries to retrieve policy files that
	 correspond to the <codeph>url</codeph> property of the URLRequest object
	 passed to <codeph>Sound.load()</codeph>. If the final
	 sound file comes from a different URL because of HTTP redirects, then the initially downloaded
	 policy files might not be applicable to the sound's final URL, which is the URL that matters
	 in security decisions.</p>
	 
	 <p platform="actionscript">If you find yourself in this situation, here is one possible solution. 
	 After you receive a <codeph>progress</codeph> or <codeph>complete</codeph> event, you can examine the value of
	 the <codeph>Sound.url</codeph> property, which contains the sound's final URL. 
	 Then call the <codeph>Security.loadPolicyFile()</codeph> method 
	 with a policy file URL that you calculate based on the sound's final URL. Finally, poll the value
	 of <codeph>Sound.id3</codeph> until no exception is thrown.</p>
	 
	 <p platform="actionscript">This does not apply to content in the AIR application sandbox. 
	 Content in the application sandbox always has programatic access to sound content, regardless
	 of its origin.</p>
	 
	 <p platform="actionscript">For more information on policy files, see the "Flash Player Security" 
	 chapter in <i>Programming ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>flash.media.Sound.load()</linktext></link><link href="flash.media.xml#Sound/id3"><linktext>flash.media.Sound.id3</linktext></link><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>flash.media.SoundMixer.computeSpectrum()</linktext></link><link href="flash.media.xml#Sound/url"><linktext>flash.media.Sound.url</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundChannel"><apiName>SoundChannel</apiName><shortdesc>
 The SoundChannel class controls a sound in an application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 The SoundChannel class controls a sound in an application. Every sound 
 is assigned to a sound channel, and the application can have multiple
 sound channels that are mixed together. The SoundChannel class contains a <codeph>stop()</codeph> method, 
 properties for monitoring the amplitude (volume) of the channel, and a property for assigning a 
 SoundTransform object to the channel.
 
 </apiDesc><example conref="examples\SoundChannelExample.as"> The following example loads an MP3 file, plays it, and displays 
 information about sound events that take place as the MP3 file is loaded and played.  A Timer
 object provides updated information about the position of the playhead every 50 milliseconds. 
 To run this example, place a file named MySound.mp3 in the same directory as your SWF file.

<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundChannelExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundChannelExample() {
            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);

            channel = soundFactory.play();
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);

            positionTimer = new Timer(50);
            positionTimer.addEventListener(TimerEvent.TIMER, positionTimerHandler);
            positionTimer.start();
        }
        

        private function positionTimerHandler(event:TimerEvent):void {
            trace("positionTimerHandler: " + channel.position.toFixed(2));
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
            positionTimer.stop();       
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }

        private function soundCompleteHandler(event:Event):void {
            trace("soundCompleteHandler: " + event);
            positionTimer.stop();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:SoundChannel_flash.events.Event.SOUND_COMPLETE_soundComplete"><apiName>soundComplete</apiName><shortdesc>
 Dispatched when a sound has finished playing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SOUND_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Dispatched when a sound has finished playing. 
 </apiDesc><example conref="examples\SoundChannel_event_soundCompleteExample.as"> In the following example, the user selects songs from a playlist, 
 and then clicks Play to play the song in the order selected.
 
 <p>In the constructor, a text field is defined that holds the song list
 and a line for the selection to play. (Usually, buttons are
 used for play and list boxes for a song list.) A text format object is
 defined that changes the format of the song lines to italic after they are 
 selected. When a user clicks the text field, the <codeph>clickHandler()</codeph> 
 method is invoked.</p> 
 
<p>In the <codeph>clickHandler()</codeph> method, the <codeph>getLineIndexAtPoint()</codeph> 
 method of the text field object returns the index of the line where the user clicked. Using 
 the line index, the <codeph>getLineText()</codeph> method gets the content of the text. 
 The if statement checks whether the user selected to play a song or add a song to the 
 play list. If a user has selected to play and a song has been selected, then the event 
 listener for mouse click is removed and the <codeph>playNext()</codeph> method is called to 
 begin playing the songs. If the user selected a song title, the content of the 
 line is added to the <codeph>songList</codeph> array and the format of the line is set to italic.</p>
 
 <p>The <codeph>playNext()</codeph> method iterates through the array list to load
 and play each song. The song is also assigned to a sound channel. An event listener 
 for the sound channel is added to respond when the song finishes playing and the
 <codeph>Event.SOUND_COMPLETE</codeph> event is dispatched. The <codeph>soundCompleteHandler()</codeph>
 method then invokes the <codeph>playNext()</codeph> method to play the next song. This process 
 continues until all the songs listed in the array finish playing.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;

    public class SoundChannel_event_soundCompleteExample extends Sprite {
        private var channel:SoundChannel = new SoundChannel();
        private var songList:Array = new Array();
        private var listTextField:TextField = new TextField();
        private var songFormat:TextFormat = new TextFormat();
        private var arrayIndex:int = 0;
        private var songSelected:Boolean = false;
        
        public function SoundChannel_event_soundCompleteExample() {
            
            listTextField.autoSize = TextFieldAutoSize.LEFT;
            listTextField.border = true
            listTextField.background = true;
            listTextField.text = "Song1.mp3\n" + "Song2.mp3\n" 
                                + "Song3.mp3\n" + "Song4.mp3\n" + "PLAY";
        
            songFormat.italic = true;
 
            listTextField.addEventListener(MouseEvent.CLICK, clickHandler);
                        
            addChild(listTextField);
        }
        
        private function clickHandler(e:MouseEvent):void {
            var index:int = listTextField.getLineIndexAtPoint(e.localX, e.localY);
            var line:String = listTextField.getLineText(index);
            var firstIndex:uint = listTextField.getLineOffset(index);
            var playLine:uint = listTextField.numLines - 1;

                if((index == playLine) &amp;&amp; (songSelected == true)) {
                    listTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
                    playNext();       

                } else if (index != playLine) {
                     songList.push(line.substr(0, (line.length - 1)));
                     listTextField.setTextFormat(songFormat, firstIndex, 
                                (firstIndex + listTextField.getLineLength(index)));     
                    songSelected = true;
                 }
        }

        private function playNext():void {
 
             if(arrayIndex &lt; songList.length) {
                var snd:Sound = new Sound();
                snd.load(new URLRequest(songList[arrayIndex]));
                channel = snd.play();
                
                channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                arrayIndex++;
 
            } else {
                songSelected = false;
                    
                while(arrayIndex &gt; 0) {
                    songList.pop();
                    arrayIndex--;
                }
            }
        }    

        private function soundCompleteHandler(e:Event):void {
            playNext();
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:SoundChannel:stop"><apiName>stop</apiName><shortdesc> 
	 Stops the sound playing in the channel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 Stops the sound playing in the channel.
	 
	 </apiDesc><example conref="examples\SoundChannel_stopExample.as"> In the following example, the user can click a button to pause and replay
 a sound file.
 
 <p>In the constructor, the sound file is loaded. (This example assumes that the file is 
 in the same directory as the SWF file.) A text field is used as a button for the user 
 to play or pause the sound. When the user clicks the <codeph>button</codeph>
 text field, the <codeph>clickHandler()</codeph> method is invoked.</p>
 
 <p>In the <codeph>clickHandler()</codeph> method, the first time the user clicks
 the text field, the sound is set to play and is assigned to a sound channel. Next, when
 the user clicks the text field to pause, the sound stops playing. The sound channel's 
 <codeph>position</codeph> property records the position of the sound at the 
 time it was stopped. This property is used to resume the sound starting at that position, after 
 the user clicks the text field to start playing again. Each time the 
 <codeph>Sound.play()</codeph> method is called, a new SoundChannel object is created and 
 assigned to the <codeph>channel</codeph> variable. The Sound object must be
 assigned to a SoundChannel object in order to use the sound channel's  
 <codeph>stop()</codeph> method to pause the sound.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
            
    public class SoundChannel_stopExample extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var button:TextField = new TextField();

        public function SoundChannel_stopExample() {
            var req:URLRequest = new URLRequest("MySound.mp3");
            snd.load(req);
            
            button.x = 10;
            button.y = 10;
            button.text = "PLAY";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.CENTER;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {
            var pausePosition:int = channel.position;

            if(button.text == "PLAY") {
                channel = snd.play(pausePosition);
                button.text = "PAUSE";
            } 
            else {
                channel.stop();
                button.text = "PLAY";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundChannel:leftPeak:get"><apiName>leftPeak</apiName><shortdesc> 
	 The current amplitude (volume) of the left channel, from 0 (silent) to 1 (full amplitude).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 The current amplitude (volume) of the left channel, from 0 (silent) to 1 (full amplitude).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:position:get"><apiName>position</apiName><shortdesc>
	 When the sound is playing, the position property indicates in milliseconds the current point
	 that is being played in the sound file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 When the sound is playing, the <codeph>position</codeph> property indicates in milliseconds the current point
	 that is being played in the sound file. When the sound is stopped or paused, the 
	 <codeph>position</codeph> property indicates the last point that was played in the sound file.
	 
	 <p>A common use case is to save the value of the <codeph>position</codeph> property when the
	 sound is stopped. You can resume the sound later by restarting it from that saved position.
	 </p>
	 
	 <p>If the sound is looped, <codeph>position</codeph> is reset to 0 at the beginning of each loop.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:rightPeak:get"><apiName>rightPeak</apiName><shortdesc> 
	 The current amplitude (volume) of the right channel, from 0 (silent) to 1 (full amplitude).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 The current amplitude (volume) of the right channel, from 0 (silent) to 1 (full amplitude).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 The SoundTransform object assigned to the sound channel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 The SoundTransform object assigned to the sound channel. A SoundTransform object
	 includes properties for setting volume, panning, left speaker assignment, and right
	 speaker assignment.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:Video"><apiName>Video</apiName><shortdesc>
 
 The Video class displays live or recorded video in an application 
 without embedding the video in your SWF file.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 The Video class displays live or recorded video in an application 
 without embedding the video in your SWF file.  
 This class creates a Video object in an Adobe Flash or Adobe Flex interface that plays 
 either of the following kinds of video: recorded FLV files stored on a server or locally,
 or live video captured from a user's computer.
 A Video object is a display object on the application's display list and represents
 the visual space in which the video runs in a user interface.
 
 <p>
 When used with Flash Media Server, the Video object allows you to
 send live video from a user's computer to the server and then
 broadcast it from the server to other users.
 Using these features, you can develop media applications such as
 a simple video player, a video player with multipoint publishing from
 one server to another, or a video sharing application for a user community.
 </p>
 
 <p>
 Flash Player 9 supports publishing and playback of FLV files encoded 
 with either the Sorenson Spark or On2 VP6 codec and also supports an alpha channel. The On2 
 VP6 video codec uses less bandwidth than older technologies and offers additional deblocking 
 and deringing filters. See the flash.net.NetStream class for more information about video playback.</p>
 
 
 <p>
 Flash Player 9.0.115.0 and later versions support mipmapping to optimize runtime rendering quality and performance. 
 For video playback, Flash Player uses mipmapping optimization if you set the Video object's <codeph>smoothing</codeph>
 property to <codeph>true</codeph>. 
 </p> 
 
 <p>
 As with other display objects on the display list,
 you can control various properties of Video objects. For example,
 you can move the Video object around on the Stage by using its <codeph>x</codeph> and
 <codeph>y</codeph> properties, you can change its size using its <codeph>height</codeph>
 and <codeph>width</codeph> properties, and so on. 
 </p>
 
 <p>
 To play a video stream, use <codeph>attachCamera()</codeph> or <codeph>attachNetStream()</codeph>
 to attach the video to the Video object. Then, add the Video object
 to the display list using <codeph>addChild()</codeph>.
 </p>
 
 <p product="flash">
 If you are using the Flash authoring tool, you can also place the Video object on the Stage
 rather than adding it with <codeph>addChild()</codeph>, like this:
 </p>
 
 <ol product="flash">
   <li>If the Library panel isn't visible, select Window &gt; Library to display it.</li>
   <li>Add an embedded Video object to the library by clicking the Options menu on
       the right side of the Library panel title bar and selecting New Video.</li>
   <li>In the Video Properties dialog box, name the embedded Video object for use in the library
       and click OK.</li>
   <li>Drag the Video object to the Stage and use the Property Inspector to give it
       a unique instance name, such as <codeph>my_video</codeph>. (Do not name it Video.)</li>
 </ol>
 
 <p><b>Note:</b> 
 The Video class is not a subclass of the InteractiveObject class, so
 it cannot dispatch mouse events. However, you can call the <codeph>addEventListener()</codeph> method
 on the display object container that contains the Video object.
 </p>
 
 </apiDesc><example conref="examples\VideoExample.as"> The following example uses a Video object with the NetConnection and 
 NetStream classes to load and play an FLV file. To run this example, you need an FLV file 
 whose name and location match the variable passed to <codeph>videoURL</codeph>, 
 in this case, an FLV file called Video.flv that is in the same directory as the SWF file.
 <p>In this example, the code that creates the Video and NetStream objects and calls
 <codeph>Video.attachNetStream()</codeph> and <codeph>NetStream.play()</codeph> is placed 
 in a handler function. The handler is called only if the
 attempt to connect to the NetConnection object is successful, which is 
 when the <codeph>netStatus</codeph> event returns an info object with a <codeph>code</codeph>
 property that indicates success. 
 It is recommended that you wait for a successful connection before calling 
 <codeph>NetStream.play()</codeph>. </p>
 <codeblock>

 package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;

    public class VideoExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function VideoExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }

        private function connectStream():void {
            stream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }
    }
 }
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>attachCamera()</linktext></link><link href="flash.media.xml#Video/attachNetStream()"><linktext>attachNetStream()</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>flash.media.Camera.getCamera()</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#Stage/addChild()"><linktext>flash.display.Stage.addChild()</linktext></link></related-links><apiConstructor id="flash.media:Video:Video"><apiName>Video</apiName><shortdesc>
     Creates a new Video instance.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
     </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>320</apiData><apiDesc>The width of the video, in pixels.
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>240</apiData><apiDesc>The height of the video, in pixels.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Creates a new Video instance. If no values for the <codeph>width</codeph> and
     <codeph>height</codeph> parameters are supplied, 
     the default values are used. You can also set the width and height properties of the
     Video object after the initial construction, using <codeph>Video.width</codeph> and
     <codeph>Video.height</codeph>.
     When a new Video object is created, values of zero for width or height are not allowed; 
     if you pass zero, the defaults will be applied.
     
     <p>After creating the Video, call the
     <codeph>DisplayObjectContainer.addChild()</codeph> or <codeph>DisplayObjectContainer.addChildAt()</codeph>
     method to add the Video object to a parent DisplayObjectContainer object.</p>
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Video:attachCamera"><apiName>attachCamera</apiName><shortdesc>
     Specifies a video stream from a camera to be displayed
     within the boundaries of the Video object in the application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.attachCamera, attachCamera()
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>camera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>A Camera object that is capturing video data. 
     To drop the connection to the Video object, pass <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Specifies a video stream from a camera to be displayed
     within the boundaries of the Video object in the application.
     
     <p>
     Use this method to attach live video from a user's computer
     to the Video object. You can play the live video locally on the same computer
     on which it is being captured, or you can send it to Flash Media Server and
     use the server to stream it to other users.
     </p>
     
     </apiDesc><example>Please see the <xref href="Camera.html#getCamera()">Camera.getCamera()</xref> method example for an 
     illustration of how to use this method. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachNetStream()"><linktext>Video.attachNetStream()</linktext></link><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:attachNetStream"><apiName>attachNetStream</apiName><shortdesc>
     Specifies a video stream to be displayed within the boundaries of the Video object 
     in the application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, video, Video.attachNetStream, attachNetStream()
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>netStream</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier><apiDesc>A NetStream object. To drop the connection to the Video object, pass
     <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Specifies a video stream to be displayed within the boundaries of the Video object 
     in the application.
     The video stream is either an FLV file played 
     with <codeph>NetStream.play()</codeph>, a Camera object, or <codeph>null</codeph>. 
     If you use an FLV file, it can be stored on the local file system or on
     Flash Media Server.
     If the value of the <codeph>netStream</codeph> argument is 
     <codeph>null</codeph>, the video is no longer played in the Video object.
     
     <p>
     You do not need to use this method if the FLV file contains only audio; the audio
     portion of FLV files is played automatically
     when you call <codeph>NetStream.play()</codeph>. To control the audio 
     associated with an FLV file, use the <codeph>soundTransform</codeph> property 
     of the NetStream object that plays the FLV file.
     </p>
     
     </apiDesc><example>Please see the example at the end of this 
     class for an illustration of how to use this method. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>flash.net.NetStream.play()</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:clear"><apiName>clear</apiName><shortdesc>
     Clears the image currently displayed in the Video object (not the video stream).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.clear, clear
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Clears the image currently displayed in the Video object (not the video stream). This method is useful for 
     handling the current image. For example, you can clear the last image or display standby information 
     without hiding the Video object.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Video:deblocking:get"><apiName>deblocking</apiName><shortdesc>
     Indicates the type of filter applied to decoded video as part of post-processing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.deblocking, deblocking
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Indicates the type of filter applied to decoded video as part of post-processing.
     The default value is 0, which lets the video compressor apply a deblocking filter as needed.
     
     <p>Compression of video can result in undesired artifacts. You can use the 
     <codeph>deblocking</codeph> property to set filters that reduce blocking and,
     for video compressed using the On2 codec, ringing.</p>
     
     <p><i>Blocking</i> refers to visible imperfections between the boundaries
     of the blocks that compose each video frame. <i>Ringing</i> refers to distorted
     edges around elements within a video image.</p>
     
     <p>Two deblocking filters are available: one in the Sorenson codec and one in the On2 VP6 codec.
     In addition, a deringing filter is available when you use the On2 VP6 codec. 
     To set a filter, use one of the following values:</p>
     
     <ul>
       <li>0—Lets the video compressor apply the deblocking filter as needed.</li>
       <li>1—Does not use a deblocking filter.</li>
       <li>2—Uses the Sorenson deblocking filter.</li>
       <li>3—For On2 video only, uses the On2 deblocking filter but no deringing filter.</li>
       <li>4—For On2 video only, uses the On2 deblocking and deringing filter.</li>
       <li>5—For On2 video only, uses the On2 deblocking and a higher-performance
     On2 deringing filter.</li>
     </ul>
     
     <p>If a value greater than 2 is selected for video when you are using
     the Sorenson codec, the Sorenson decoder defaults to 2.</p>
     
     <p>Using a deblocking filter has an effect on overall playback performance, and it is usually
     not necessary for high-bandwidth video. If a user's system is not powerful enough, 
     the user may experience difficulties playing back video with a deblocking filter enabled.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:smoothing:get"><apiName>smoothing</apiName><shortdesc>
     Specifies whether the video should be smoothed (interpolated) when it is scaled.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.smoothing, smoothing
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Specifies whether the video should be smoothed (interpolated) when it is scaled. For
     smoothing to work, the player must be in high-quality mode. The default value
     is <codeph>false</codeph> (no smoothing).
     <p>For video playback using Flash Player 9.0.115.0 and later versions, set this property to
     <codeph>true</codeph> to take advantage of mipmapping image optimization.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:videoHeight:get"><apiName>videoHeight</apiName><shortdesc>
      An integer specifying the height of the video stream, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.height, height
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      An integer specifying the height of the video stream, in pixels. For live streams, this
     value is the same as the <codeph>Camera.height</codeph>
     property of the Camera object that is capturing the video stream. For FLV files, this
     value is the height of the file that was exported as FLV.
     <p>You may want to use this property, for example, to ensure that the user is seeing the
     video at the same size at which it was captured,
     regardless of the actual size of the Video object on the Stage.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/height"><linktext>flash.media.Camera.height</linktext></link></related-links></apiValue><apiValue id="flash.media:Video:videoWidth:get"><apiName>videoWidth</apiName><shortdesc>
      An integer specifying the width of the video stream, in pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.width, width
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      An integer specifying the width of the video stream, in pixels. For live streams, this
     value is the same as the <codeph>Camera.width</codeph>
     property of the Camera object that is capturing the video stream. For FLV files, this
     value is the width of the file that was exported as
     an FLV file.
     <p>You may want to use this property, for example, to ensure that the user is seeing the
     video at the same size at which it was captured,
     regardless of the actual size of the Video object on the Stage.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>flash.media.Camera.width</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundMixer"><apiName>SoundMixer</apiName><shortdesc>
The SoundMixer class contains static properties and methods for global sound control
in the application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
The SoundMixer class contains static properties and methods for global sound control
in the application. The SoundMixer class controls embedded and streaming sounds in the application. 
it does not control dynamically created sounds (that is, sounds generated in response 
to a Sound object dispatching a <codeph>sampleData</codeph> event).

</apiDesc></apiClassifierDetail><apiOperation id="flash.media:SoundMixer:areSoundsInaccessible"><apiName>areSoundsInaccessible</apiName><shortdesc> 
     Determines whether any sounds are not accessible due to security restrictions.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>The string representation of the boolean.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc> 
     Determines whether any sounds are not accessible due to security restrictions. For example, 
     a sound loaded from a domain other than that of the content calling this method is not accessible if 
     the server for the sound has no URL policy file that grants access to
     the domain of that domain. The sound can still be loaded and played, but low-level
     operations, such as getting ID3 metadata for the sound, cannot be performed on 
     inaccessible sounds.
     
     <p>For AIR application content in the application security sandbox, calling this method always
     returns <codeph>false</codeph>. All sounds, including those loaded from other domains, are accessible
     to content in the application security sandbox.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>computeSpectrum()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:computeSpectrum"><apiName>computeSpectrum</apiName><shortdesc>
     Takes a snapshot of the current sound wave and places it into the specified ByteArray object.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should confirm if the floating point numbers are single- or double-precision.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>outputArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>A ByteArray object that holds the values associated with the sound.
     If any sounds are not available due to security restrictions 
     (<codeph>areSoundsInaccessible == true</codeph>), the <codeph>outputArray</codeph> object 
     is left unchanged. If all sounds are stopped, the <codeph>outputArray</codeph> object is 
     filled with zeros.
     
     </apiDesc></apiParam><apiParam><apiItemName>FFTMode</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>A Boolean value indicating whether a Fourier transformation is performed 
     on the sound data first. Setting this parameter to <codeph>true</codeph> causes the method to return a 
     frequency spectrum instead of the raw sound wave. In the frequency spectrum, low frequencies 
     are represented on the left and high frequencies are on the right.
     
     </apiDesc></apiParam><apiParam><apiItemName>stretchFactor</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>The resolution of the sound samples. 
     If you set the <codeph>stretchFactor</codeph> value to 0, data is sampled at 44.1 KHz; 
     with a value of 1, data is sampled at 22.05 KHz; with a value of 2, data is sampled 11.025 KHz;
     and so on.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Takes a snapshot of the current sound wave and places it into the specified ByteArray object. 
     The values are formatted as normalized floating-point values, in the range -1.0 to 1.0. 
     The ByteArray object passed to the <codeph>outputArray</codeph> parameter is overwritten with the new values.
     The size of the ByteArray object created is fixed to 512 floating-point values, where the
     first 256 values represent the left channel, and the second 256 values represent 
     the right channel.
     
     <p><b>Note:</b> This method is subject to local file security restrictions and
     restrictions on cross-domain loading. If you are working with local files or sounds loaded from a server in a 
     different domain than the calling content, you might need to address sandbox restrictions
	 through a cross-domain policy file. For more information, see the Sound class description.
	 In addition, this method cannot be used to extract data from RTMP streams, even when 
     it is called by content that reside in the same domain as the RTMP server.</p>
     
     
     <p>This method is supported over RTMP in Flash Player 9.0.115.0
	 and later and in Adobe AIR. You can control access to streams on 
     Flash Media Server in a server-side script. For more information, see the <codeph>Client.audioSampleAccess</codeph>
     and <codeph>Client.videoSampleAccess</codeph> properties in <xref href="http://www.adobe.com/go/documentation" scope="external"><i>
     Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></xref>.</p>
     
     </apiDesc><example conref="examples\SoundMixer_computeSpectrumExample.as"> In the following example, the <codeph>computeSpectrum()</codeph> method is 
 used to produce a graphic representation of the sound wave data. 
 
 <p>In the constructor, a sound file is loaded and set to play. (There is no error handling 
 in this example and it is assumed that the sound file is in the same directory as the SWF file.) 
 The example listens for the <codeph>Event.ENTER_FRAME</codeph> event while the sound plays, repeatedly 
 triggering the <codeph>onEnterFrame()</codeph> method to draw a graph of the sound data values.
 When the sound finishes playing the <codeph>onPlaybackComplete()</codeph> method stops the drawing process 
 by removing the listener for the <codeph>Event.ENTER_FRAME</codeph> event.</p>
 
 <p>In the <codeph>onEnterFrame()</codeph> method, the <codeph>computeSpectrum()</codeph> method stores the raw 
 sound in the <codeph>bytes</codeph> byte array object. The data is sampled at 44.1 KHz. 
 The byte array containing 512 bytes of data, each of which contains a floating-point value 
 between -1 and 1. The first 256 values represent the left channel, and the second 256 values 
 represent the right channel. The first for loop, reads the first 256 data values (the left stereo channel) 
 and draws a line from each point to the next using the <codeph>Graphics.lineTo()</codeph> method. (The vector 
 graphic display of the sound wave is written directly on to the class's sprite object.) The sound bytes 
 are read as 32-bit floating-point number from the byte stream and multiplied by the plot height to allow 
 for the vertical range of the graph. The width is set to twice the width of the channel length. The 
 second for loop reads the next set of 256 values (the right stereo channel), and plots the lines in 
 reverse order. The <codeph>g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);</codeph> and <codeph>g.lineTo(0, PLOT_HEIGHT);</codeph> 
 methods draw the baseline for the waves. The resulting waveform plot produces a mirror-image effect.</p>  

<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.net.URLRequest;
    import flash.utils.ByteArray;
    import flash.text.TextField;

    public class SoundMixer_computeSpectrumExample extends Sprite {

        public function SoundMixer_computeSpectrumExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("Song1.mp3");
            snd.load(req);
            
            var channel:SoundChannel;
            channel = snd.play();
            addEventListener(Event.ENTER_FRAME, onEnterFrame);
            channel.addEventListener(Event.SOUND_COMPLETE, onPlaybackComplete);
        }

        private function onEnterFrame(event:Event):void {
            var bytes:ByteArray = new ByteArray();
            const PLOT_HEIGHT:int = 200;
            const CHANNEL_LENGTH:int = 256;

            SoundMixer.computeSpectrum(bytes, false, 0);
            
            var g:Graphics = this.graphics;
            
            g.clear();
       
            g.lineStyle(0, 0x6600CC);
            g.beginFill(0x6600CC);
            g.moveTo(0, PLOT_HEIGHT);
            
            var n:Number = 0;
            
            for (var i:int = 0; i &lt; CHANNEL_LENGTH; i++) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }

            g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            g.endFill();
 
            g.lineStyle(0, 0xCC0066);
            g.beginFill(0xCC0066, 0.5);
            g.moveTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            
            for (i = CHANNEL_LENGTH; i &gt; 0; i--) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }
  
            g.lineTo(0, PLOT_HEIGHT);
            g.endFill();
        }
        
        private function onPlaybackComplete(event:Event):void {
            removeEventListener(Event.ENTER_FRAME, onEnterFrame);
        }
    }
}

</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/areSoundsInaccessible()"><linktext>areSoundsInaccessible()</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.media.xml#Sound"><linktext>flash.media.Sound</linktext></link><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>flash.media.SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:stopAll"><apiName>stopAll</apiName><shortdesc>
     Stops all sounds currently playing.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Stops all sounds currently playing. 
     
     <p product="flash">This method does not stop the playhead. 
     Sounds set to stream will resume playing as the playhead moves over the frames in which they 
     are located.</p>
     
     <p platform="actionscript">When using this property, consider the following security model:</p>
     
     <ul platform="actionscript">
     
     <li> By default, calling the <codeph>SoundMixer.stopAll()</codeph> method stops 
     only sounds in the same security sandbox as the object that is calling the method. 
     Any sounds whose playback was not started from the same sandbox as the calling object 
     are not stopped.</li>
     
     <li>When you load the sound, using the <codeph>load()</codeph> method of the Sound class, you can  
     specify a <codeph>context</codeph> parameter, which is a SoundLoaderContext object. If you set the 
     <codeph>checkPolicyFile</codeph>  property of the SoundLoaderContext object to <codeph>true</codeph>, 
     <ph platform="actionscript">Flash Player or</ph> Adobe AIR
	 checks for a cross-domain policy file on the server from which the sound is loaded. If the server has a 
     cross-domain policy file, and the file permits the domain of the calling content, then the file can stop the loaded 
     sound by using the <codeph>SoundMixer.stopAll()</codeph> method; otherwise it cannot.</li>
     
     </ul>
     
     <p platform="actionscript">However, in Adobe AIR, content in the <codeph>application</codeph> security sandbox (content
     installed with the AIR application) are not restricted by these security limitations.</p>
     
     <p platform="actionscript">For more information, see the following:</p>
     
     <ul platform="actionscript">
     
     <li product="flex">The <xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     <li class="flashonly">The <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">security chapter</xref>
     in the <i>Programming ActionScript 3.0</i> book and the latest comments on LiveDocs</li>
     
     <li>The Flash Player Developer Center Topic: <xref href="http://www.adobe.com/go/devnet_security_en" scope="external">Security</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\SoundMixer_stopAllExample.as"> In the following example, the <codeph>stopAll()</codeph> method is used to mute two
 sounds that are playing at the same time. 
 
 <p>In the constructor, two different sound files are loaded and set to play. The first sound is 
 loaded locally and is assigned to a sound channel. (It is assumed that the file is 
 in the same directory as the SWF file.) The second file is loaded and streamed from the Adobe 
 site. In order to use the <codeph>SoundMixer.stopAll()</codeph> method, all sound must be accessible.
 (A SoundLoaderContext object can be used to check for the cross-domain policy file.) Each sound 
 also has an event listener that is invoked if an IO error occurred while loading the sound file. 
 A <codeph>muteButton</codeph> text field is also created. It listens for a mouse click, which 
 will invoke the <codeph>muteButtonClickHandler()</codeph> method.</p>
 
 <p>In the <codeph>muteButtonClickHandler()</codeph> method, if the text field content is "MUTE," 
 the <codeph>areSoundsInaccessible()</codeph> method checks if the sound mixer has access to the files.
 If the files are accessible, the <codeph>stopAll()</codeph> method stops the sounds. By clicking on the 
 text field again, the first sound begins playing and the text field's content changes to 
 "MUTE" again. This time, the <codeph>stopAll()</codeph> method mutes the one sound that is running.
 Note that sound channel <codeph>stop()</codeph> method can also be used to stop a specific sound 
 assigned to the channel. (To use the channel functionally, the sound needs to be reassigned 
 to the channel each time the <codeph>play()</codeph> method is invoked.)</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.events.IOErrorEvent;

    public class SoundMixer_stopAllExample extends Sprite  {
        private var firstSound:Sound = new Sound();
        private var secondSound:Sound = new Sound();
        private var muteButton:TextField = new TextField();
        private var channel1:SoundChannel = new SoundChannel();
        
        public function SoundMixer_stopAllExample() {
            firstSound.load(new URLRequest("mySound.mp3"));
            secondSound.load(new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3"));

            firstSound.addEventListener(IOErrorEvent.IO_ERROR, firstSoundErrorHandler);
            secondSound.addEventListener(IOErrorEvent.IO_ERROR, secondSoundErrorHandler);
            
            channel1 = firstSound.play();
            secondSound.play();
            
            muteButton.autoSize = TextFieldAutoSize.LEFT;
            muteButton.border = true;
            muteButton.background = true;
            muteButton.text = "MUTE";
        
            muteButton.addEventListener(MouseEvent.CLICK, muteButtonClickHandler);         
        
            this.addChild(muteButton);
        }

        private function muteButtonClickHandler(event:MouseEvent):void {

            if(muteButton.text == "MUTE") {        
  
                if(SoundMixer.areSoundsInaccessible() == false) {
                    SoundMixer.stopAll();
                    muteButton.text = "click to play only one of sound.";
                }
                else {
                    muteButton.text = "The sounds are not accessible.";
                }
            }
           else {
                firstSound.play();        
                muteButton.text = "MUTE";
           }
        } 

        private function firstSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }

        private function secondSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundMixer:bufferTime:get"><apiName>bufferTime</apiName><shortdesc>
     The number of seconds to preload an embedded streaming sound into a buffer before it starts 
     to stream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     The number of seconds to preload an embedded streaming sound into a buffer before it starts 
     to stream. The data in a loaded sound, including its buffer time,
     cannot be accessed by a SWF file that is in a different domain 
	 unless you implement a cross-domain policy file. 
     For more information about security and sound, see the Sound class description.
	 to stream. <ph platform="actionscript">The data in a loaded sound, including its buffer time,
	 cannot be accessed by code in a file that is in a different domain 
	 unless you implement a cross-domain policy file. However, in the application sandbox
	 in an AIR application, code can access data in sound files from any source. 
	 For more information about security and sound, see the Sound class description.</ph> 
     
     <p>The <codeph>SoundMixer.bufferTime</codeph> property only affects the buffer time 
     for embedded streaming sounds in a SWF and is independent of dynamically created 
     Sound objects (that is, Sound objects created in ActionScript). 
     The value of <codeph>SoundMixer.bufferTime</codeph> cannot override 
     or set the default of the buffer time specified in the SoundLoaderContext object 
     that is passed to the <codeph>Sound.load()</codeph> method.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link></related-links></apiValue><apiValue id="flash.media:SoundMixer:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
     The SoundTransform object that controls global sound properties.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
     The SoundTransform object that controls global sound properties. A SoundTransform object
     includes properties for setting volume, panning, left speaker assignment, and right
     speaker assignment. The SoundTransform object used in this property provides final sound settings
     that are applied to all sounds after any individual sound settings are applied.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier></apiPackage>