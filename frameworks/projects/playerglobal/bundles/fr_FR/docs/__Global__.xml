<?xml version="1.0"?>
<apiPackage id="__Global__"><apiName>__Global__</apiName><apiDetail/><apiClassifier id="globalClassifier:VerifyError"><apiName>VerifyError</apiName><shortdesc>
 La classe VerifyError représente une erreur qui se produit lorsqu’un fichier SWF incorrectement formé ou altéré est détecté.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Une erreur VerifyError est renvoyée lorsqu’un fichier SWF incorrect ou altéré est détecté.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe VerifyError représente une erreur qui se produit lorsqu’un fichier SWF incorrectement formé ou altéré est détecté. 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>Classe Loader</linktext></link></related-links><apiConstructor id="VerifyError:VerifyError"><apiName>VerifyError</apiName><shortdesc>
	 Crée un objet VerifyError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Contient le message associé à l’objet VerifyError.      
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet VerifyError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
 La classe ArgumentError représente une erreur qui se produit lorsque les arguments spécifiés dans une fonction ne correspondent pas aux arguments définis pour celle-ci.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Une erreur ArgumentError est renvoyée lorsque les valeurs de paramètre spécifiées lors d’un appel de fonction ne correspondent pas aux paramètres définis pour celle-ci.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe ArgumentError représente une erreur qui se produit lorsque les arguments spécifiés dans une fonction ne correspondent pas aux arguments définis pour celle-ci. Cette erreur se produit par exemple si vous appelez une fonction en spécifiant un nombre incorrect d’arguments, un argument de type incorrect ou un argument non valide.
 
 </apiDesc><example conref="examples\ArgumentErrorExample.as"> L’exemple suivant indique comment générer une erreur <codeph>ArgumentError</codeph> et la traiter avec une instruction <codeph>try..catch</codeph>. La fonction <codeph>println()</codeph> ne prend qu’un seul argument, une chaîne unique. Dans la mesure où deux chaînes sont fournies, l’erreur est renvoyée. De manière générale, le compilateur peut intercepter une erreur, mais la syntaxe <codeph>this[]</codeph> de cette instruction <codeph>try</codeph> contourne la vérification de la syntaxe du compilateur pour la fonction.
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentErrorExample extends Sprite {
        public function ArgumentErrorExample() {
                println("Hello World");
                
                try {
                    this["println"]("Hello", "World");
                }
                catch(e:ArgumentError) {
                    trace(e);
                }
        }
        
        public function println(str:String):void {
            trace(str);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="ArgumentError:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
	 Crée un objet ArgumentError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Chaîne associée à l’erreur.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet ArgumentError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:QName"><apiName>QName</apiName><shortdesc>

Les objets QName représentent les noms complets des éléments et attributs XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>QName
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

Les objets QName représentent les noms complets des éléments et attributs XML. Chaque objet QName possède un nom local et un URI (Uniform Resource Identifier) d’espace de nom. Si la valeur de l’URI de l’espace de nom est <codeph>null</codeph>, l’objet QName correspond à tout espace de nom. Utilisez le constructeur QName pour créer un objet QName correspondant soit à une copie d’un autre objet QName, soit à un nouvel objet QName dont le paramètre <codeph>uri</codeph> est extrait d’un objet Namespace et le paramètre <codeph>localName</codeph> est extrait d’un objet QName. 
 

<p>Les méthodes spécifiques à E4X peuvent utiliser les objets QName, quels qu’ils soient, à l’aide de chaînes. Les méthodes E4X figurent dans les classes QName, Namespace, XML et XMLList. Parce qu’elles extraient une chaîne, elles peuvent également extraire un objet QName. Cette interchangeabilité explique comment une méthode telle que <codeph>XML.child()</codeph> gère la prise en charge des espaces de nom. </p>

<p>A l’instar des classes XML, XMLList et Namespace, la classe QName implémente des normes de gestion XML performantes définies dans la spécification ECMAScript pour XML (E4X) (ECMA-357, édition 2).</p>

<p>Un identificateur complet renvoie un objet QName. Si l’objet QName d’un élément XML est spécifié sans identifier d’espace de nom, la propriété <codeph>uri</codeph> de l’objet QName associé est définie sur l’espace de nom global par défaut. Si l’objet QName d’un attribut XML est spécifié sans identifier d’espace de nom, la propriété <codeph>uri</codeph> est définie sur une chaîne vide.</p>

</apiDesc><example conref="examples\QNameExample.as"> L’exemple suivant indique comment créer une occurrence de QName et l’utiliser pour sélectionner des éléments XML. Deux méthodes de création de QName sont indiquées :
 <ol>
    <li>Création d’une occurrence d’espace de nom, puis utilisation de cette dernière en tant qu’entrée pour le constructeur QName. Cette approche est préférable lorsque vous utilisez ultérieurement la propriété <codeph>Namespace.prefix</codeph> à d’autres fins.</li>
  <li>Création d’une occurrence de QName utilisant une valeur de chaîne pour le paramètre <codeph>uri</codeph> dans le constructeur QName.</li>
 </ol>
 <p>
 Ce code produit les résultats suivants :
 </p>
 <ol>
  <li>Définit une variable XML appelée <codeph>rssXML</codeph>.</li>
    <li>Crée un nouvel objet Namespace avec le préfixe <codeph>dc</codeph>.</li>
  <li>Crée un objet QName qui utilise l’objet Namespace et le <codeph>créateur</codeph> de nom local.</li>
  <li>Appelle la méthode <codeph>showDescendants()</codeph>, qui utilise la méthode <codeph>XML.descendants()</codeph> pour obtenir une occurrence XMLList contenant tous les éléments descendants dont le nom qualifié correspond à l’occurrence QName donnée.</li>
    <li>Affiche le nom qualifié et la valeur de texte des éléments de la liste à l’aide d’une boucle <codeph>for each</codeph>.</li>
  <li>Crée un autre objet QName qui utilise une valeur de chaîne pour le paramètre <codeph>uri</codeph> et la <codeph>date</codeph> du nom local.</li>
  <li>Appelle à nouveau la méthode <codeph>showDescendants()</codeph> pour afficher le nom et la valeur de texte des éléments descendants.</li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    
    public class QNameExample extends Sprite
    {
        public function QNameExample()
        {
            var rssXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/">
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            var dcNamespace:Namespace = new Namespace("dc", "http://purl.org/dc/elements/1.1/");
            var creatorQName:QName = new QName(dcNamespace, "creator");
            trace(creatorQName.uri); // http://purl.org/dc/elements/1.1/
            trace(creatorQName.localName); // creator
            
            showDescendants(rssXML, creatorQName);
            
            var dateQName:QName = new QName("http://purl.org/dc/elements/1.1/", "date");
            trace(dateQName.uri); // http://purl.org/dc/elements/1.1/
            trace(dateQName.localName); // date
            
            showDescendants(rssXML, dateQName);
        }
        
        public function showDescendants(xmlData:XML, qualifiedName:QName):void
        {
            var decendantList:XMLList = xmlData.descendants(qualifiedName);
            
            for each (var element:XML in decendantList)
            {
                trace(element.name()); // the fully qualified name, 
                                       // like "http://purl.org/dc/elements/1.1/::creator"
                trace(element); // the simple text value of each element, like "Adobe"
            }                
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#Namespace"><linktext>Espace de nom </linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>ECMAScript pour la spécification XML (E4X) (ECMA-357 edition 2)</linktext></link></related-links><apiConstructor id="QName:QName_0"><apiName>QName</apiName><shortdesc> 
    Crée un objet QName associé à un objet URI à partir d’un objet Namespace et une valeur localName extraite d’un objet QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName
    </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Objet Namespace d’où sera copiée la valeur <codeph>uri</codeph>. Un paramètre de tout autre type est converti en chaîne.
    </apiDesc></apiParam><apiParam><apiItemName>localName</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>Objet QName d’où sera copiée la valeur <codeph>localName</codeph>. Un paramètre de tout autre type est converti en chaîne.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    Crée un objet QName associé à un objet URI à partir d’un objet Namespace et une valeur <codeph>localName</codeph> extraite d’un objet QName. Si l’un des paramètres ne correspond pas au type de données attendu, le paramètre est converti en chaîne et est affecté à la propriété correspondante du nouvel objet QName. Si, par exemple, les deux paramètres sont des chaînes, un nouvel objet QName est renvoyé. La propriété <codeph>uri</codeph> est définie sur le premier paramètre et la propriété <codeph>localName</codeph> est définie sur le second paramètre. En d’autres termes, les permutations suivantes (qui ne constituent que quelques exemples) représentent des formes valides du constructeur :
<pre>
QName (uri:Namespace, localName:String);
QName (uri:String, localName: QName);
QName (uri:String, localName: String);
</pre>
    <p>Si vous transmettez <codeph>null</codeph> pour le paramètre <codeph>uri</codeph>, la propriété <codeph>uri</codeph> du nouvel objet QName est définie sur <codeph>null</codeph>.
    </p>
    <p><b>Remarque :</b> cette classe utilise deux entrées de constructeur, car chaque forme accepte des paramètres différents. Le constructeur se comporte différemment selon le type et le nombre de paramètres transmis, comme indiqué dans chaque entrée. ActionScript 3.0 ne prend pas en charge la surcharge d’une méthode ou d’un constructeur.</p>
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="QName:QName_1"><apiName>QName</apiName><shortdesc> 
    Crée un objet QName qui est une copie d’un autre objet QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>(pdehaan) i changed first param from "name" to "uri" as the previous naming was very confusing
    </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>qname</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>Objet QName à copier. Les objets de tout autre type sont convertis en chaîne, qui est affectée à la propriété <codeph>localName</codeph> du nouvel objet QName.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    Crée un objet QName qui est une copie d’un autre objet QName. Si le paramètre transmis au constructeur est un objet QName, une copie de ce dernier est créée. Si le paramètre n’est pas un objet QName, le paramètre est converti en chaîne et affecté à la propriété <codeph>localName</codeph> de la nouvelle occurrence de QName. Si le paramètre est réglé sur <codeph>undefined</codeph> ou n’est pas spécifié, un nouvel objet est créé et sa propriété <codeph>localName</codeph> est définie sur la chaîne vide.
    <p><b>Remarque :</b> cette classe utilise deux entrées de constructeur, car chaque forme accepte des paramètres différents. Le constructeur se comporte différemment selon le type et le nombre de paramètres transmis, comme indiqué dans chaque entrée. ActionScript 3.0 ne prend pas en charge la surcharge d’une méthode ou d’un constructeur.</p>
    
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="QName:AS3:toString"><apiName>toString</apiName><shortdesc>
	Renvoie une chaîne composée de l’URI et le nom local de l’objet QName, séparés par « :: ».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nom complet, exprimé sous forme de chaîne.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une chaîne composée de l’URI et le nom local de l’objet QName, séparés par « :: ».
	
	<p>Le format varie selon la propriété <codeph>uri</codeph> de l’objet QName :</p>
	<pre>If <codeph>uri</codeph> == "" 
		<codeph>toString</codeph> returns <codeph>localName</codeph>
	else if <codeph>uri</codeph> == null
		<codeph>toString</codeph> returns ~~::<codeph>localName</codeph> 
	else
		<codeph>toString</codeph> returns <codeph>uri</codeph>::<codeph>localName</codeph></pre>
	
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="QName:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    Renvoie l’objet QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur primitive d’une occurrence de QName.
    
    </apiDesc><apiOperationClassifier>QName</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Renvoie l’objet QName.
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="QName:localName:get"><apiName>localName</apiName><shortdesc>
	Nom local de l’objet QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.localName, localName
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Nom local de l’objet QName.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="QName:uri:get"><apiName>uri</apiName><shortdesc>
	URI (Uniform Resource Identifier) de l’objet QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	URI (Uniform Resource Identifier) de l’objet QName.
 	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:EvalError"><apiName>EvalError</apiName><shortdesc>
 La classe EvalError représente une erreur qui se produit lorsque le code utilisateur appelle la fonction eval() ou tente d’utiliser l’opérateur new avec l’objet Function.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Une erreur EvalError est renvoyée lorsque le code tente d’appeler eval() ou d’utiliser new avec l’objet Function.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe EvalError représente une erreur qui se produit lorsque le code utilisateur appelle la fonction <codeph>eval()</codeph> ou tente d’utiliser l’opérateur <codeph>new</codeph> avec l’objet Function. Les appels de <codeph>eval()</codeph> et <codeph>new</codeph> avec l’objet Function ne sont pas pris en charge.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="EvalError:EvalError"><apiName>EvalError</apiName><shortdesc>
	 Crée un objet EvalError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Chaîne associée à l’erreur.     
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet EvalError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Math"><apiName>Math</apiName><shortdesc>
 La classe Math contient des méthodes et des constantes qui représentent les fonctions et valeurs mathématiques courantes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math, math object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Math est une classe de niveau supérieur composée de propriétés et méthodes statiques qui définissent les constantes et fonctions mathématiques courantes.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Math contient des méthodes et des constantes qui représentent les fonctions et valeurs mathématiques courantes. 
 <p>Utilisez les méthodes et les propriétés de cette classe pour accéder aux constantes et fonctions mathématiques et les manipuler. Toutes les propriétés et les méthodes de la classe Math sont statiques et doivent être appelées à l’aide de la syntaxe <codeph>Math.method(</codeph><codeph><i>parameter</i></codeph><codeph>)</codeph> ou <codeph>Math.constant</codeph>. Dans ActionScript, les constantes sont définies selon la précision maximale des nombres à virgule flottante comportant deux décimales conformément à IEEE-754.</p>
 <p>Plusieurs méthodes de la classe Math utilisent la mesure d’un angle en radians en tant que paramètre. Vous pouvez utiliser l’équation suivante pour calculer les valeurs en radian avant d’appeler la méthode, puis exprimer la valeur calculée en tant que paramètre. Vous pouvez également utiliser toutes les valeurs situées à droite de l’équation (l’angle étant exprimé en radians plutôt qu’en <codeph>degrees</codeph>) en tant que paramètre radian.</p>
 <p>Pour calculer une valeur radian, utilisez la formule suivante :</p>
 <pre>
 radians = degrees ~~ Math.PI/180
 </pre>
 <p>Pour convertir les radians en degrés, utilisez la formule suivante :</p>
 <pre>
 degrees = radians ~~ 180/Math.PI
 </pre>
 <p>Dans l’exemple suivant, l’équation est utilisée en tant que paramètre pour calculer le sinus d’un angle de 45° :</p>
 <p><codeph>Math.sin(45 ~~ Math.PI/180)</codeph> est identique à <codeph>Math.sin(.7854)</codeph></p>
 <p><b>Remarque :</b> les fonctions Math acos, asin, atan, atan2, cos, exp, log, pow, sin et sqrt risquent de produire un résultat légèrement différent selon les algorithmes utilisés par le processeur ou le système d’exploitation. Flash Player fait appel au processeur (ou au système d’exploitation si le processeur ne prend pas en charge les calculs en virgule flottante) lorsqu’il effectue des calculs pour les fonctions indiquées et que les résultats sont légèrement différents selon le processeur ou le système d’exploitation utilisé.
 </p>
 
 
 </apiDesc></apiClassifierDetail><apiOperation id="Math:abs"><apiName>abs</apiName><shortdesc>
  Calcule et renvoie la valeur absolue du nombre spécifié par le paramètre val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.abs, abs, absolute
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Valeur absolue du paramètre spécifié.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre dont la valeur absolue est renvoyée.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la valeur absolue du paramètre Number spécifié.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie la valeur absolue du nombre spécifié par le paramètre <codeph>val</codeph>.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:acos"><apiName>acos</apiName><shortdesc>
  Calcule et renvoie l’arc cosinus du nombre spécifié dans le paramètre val, en radians.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.acos, acos, arc cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Arc cosinus du paramètre <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre compris entre -1,0 et 1,0.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie l’arc cosinus, en radians, du paramètre Number. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie l’arc cosinus du nombre spécifié dans le paramètre <codeph>val</codeph>, en radians.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:asin"><apiName>asin</apiName><shortdesc>
  Calcule et renvoie l’arc sinus du nombre spécifié dans le paramètre val, en radians.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.asin, asin, arc sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nombre compris entre pi négatif divisé par 2 et pi positif divisé par 2.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre compris entre -1,0 et 1,0.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la valeur, en radians, de l’arc sinus du paramètre Number spécifié.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie l’arc sinus du nombre spécifié dans le paramètre <codeph>val</codeph>, en radians.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan"><apiName>atan</apiName><shortdesc>
  Calcule et renvoie la valeur, en radians, de l’angle dont la tangente est spécifiée dans le paramètre val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan, atan, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nombre compris entre pi négatif divisé par 2 et pi positif divisé par 2.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre représentant la tangente d’un angle.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie l’angle, en radians, dont la tangente est spécifiée par le paramètre val.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie la valeur, en radians, de l’angle dont la tangente est spécifiée dans le paramètre <codeph>val</codeph>. La valeur renvoyée est comprise entre pi négatif divisé par 2 et pi positif divisé par 2.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan2"><apiName>atan2</apiName><shortdesc>
  Calcule et renvoie l’angle du point y/x en radians, lorsqu’il est mesuré dans le sens anti-horaire à partir de l’axe x d’un cercle (où 0,0 représente le centre du cercle).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan2, atan2, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Un nombre.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> du point.
  </apiDesc></apiParam><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> du point.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie l’angle du point y/x en radians, lorsqu’il est mesuré dans le sens anti-horaire à partir de l’axe x d’un cercle.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie l’angle du point <codeph>y</codeph>/<codeph>x</codeph> en radians, lorsqu’il est mesuré dans le sens anti-horaire à partir de l’axe <i>x</i> d’un cercle (où 0,0 représente le centre du cercle). La valeur renvoyée est comprise entre pi positif et pi négatif. Notez que le premier paramètre attribué à atan2 correspond toujours à la coordonnée <i>y</i>.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:ceil"><apiName>ceil</apiName><shortdesc>
  Renvoie la valeur maximale du nombre ou de l’expression spécifié(e).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ceil, ceil, ceiling
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Entier le plus proche et supérieur ou égal au paramètre <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la valeur maximale du nombre ou de l’expression spécifié(e).
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Renvoie la valeur maximale du nombre ou de l’expression spécifié(e). La valeur maximale d’un nombre est l’entier le plus proche supérieur ou égal au nombre.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/floor()"><linktext>Math.floor()</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="Math:cos"><apiName>cos</apiName><shortdesc>
  Calcule et renvoie le cosinus de l’angle spécifié en radians.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.cos, cos, cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nombre compris entre -1,0 et 1,0.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre représentant un angle mesuré en radians. 
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie le cosinus de l’angle spécifié.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie le cosinus de l’angle spécifié en radians. Pour calculer un radian, voir la présentation de la classe Math.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:exp"><apiName>exp</apiName><shortdesc>
  Renvoie la valeur de la base du logarithme népérien (e), à la puissance de l’exposant spécifié dans le paramètre x.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.exp, exp, exponent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc><i>e</i> à la puissance du paramètre <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Exposant ; un nombre ou une expression.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la valeur de la base du logarithme népérien (e), à la puissance de l’exposant spécifié dans le paramètre val.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Renvoie la valeur de la base du logarithme népérien (<i>e</i>), à la puissance de l’exposant spécifié dans le paramètre <codeph>x</codeph>. La constante <codeph>Math.E</codeph> peut renvoyer la valeur <i>e</i>.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/E"><linktext>Math.E</linktext></link></related-links></apiOperation><apiOperation id="Math:floor"><apiName>floor</apiName><shortdesc>
  Renvoie la valeur minimale du nombre ou de l’expression spécifié(e) dans le paramètre val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.floor, floor
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Entier le plus proche et inférieur ou égal au paramètre <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la valeur minimale du nombre ou de l’expression spécifié(e) dans le paramètre val.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Renvoie la valeur minimale du nombre ou de l’expression spécifié(e) dans le paramètre <codeph>val</codeph>. La valeur minimale est l’entier le plus proche inférieur ou égal au nombre ou à l’expression spécifié(e).
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:log"><apiName>log</apiName><shortdesc>
  Renvoie le logarithme népérien du paramètre val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log, log, logarithm
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Logarithme népérien du paramètre <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression d’une valeur supérieure à 0.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie le logarithme népérien du paramètre val. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Renvoie le logarithme népérien du paramètre <codeph>val</codeph>.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:max"><apiName>max</apiName><shortdesc>
  Evalue val1 et val2 (ou plusieurs valeurs) et renvoie la valeur la plus grande.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.max, max, maximum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Renvoie la valeur la plus élevée des paramètres <codeph>val1</codeph> et <codeph>val2</codeph> (ou un nombre supérieur de paramètres).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression.
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression.
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Nombre ou expression. <codeph>Math.max()</codeph> peut accepter plusieurs arguments.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Evalue les paramètres val1 et val2 et renvoie la valeur la plus élevée.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Evalue <codeph>val1</codeph> et <codeph>val2</codeph> (ou un nombre supérieur de valeurs), puis renvoie la valeur supérieure.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/min()"><linktext>Math.min()</linktext></link></related-links></apiOperation><apiOperation id="Math:min"><apiName>min</apiName><shortdesc>
  Evalue val1 et val2 (ou plusieurs valeurs) et renvoie la valeur inférieure.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.min, min, minimum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Renvoie la valeur inférieure des paramètres <codeph>val1</codeph> et <codeph>val2</codeph> (ou un nombre supérieur de paramètres).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression.
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression.
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Nombre ou expression. <codeph>Math.min()</codeph> peut accepter plusieurs arguments.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Evalue les paramètres val1 et val2 et renvoie la valeur la plus faible.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Evalue <codeph>val1</codeph> et <codeph>val2</codeph> (ou un nombre supérieur de valeurs), puis renvoie la valeur inférieure.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/max()"><linktext>Math.max()</linktext></link></related-links></apiOperation><apiOperation id="Math:pow"><apiName>pow</apiName><shortdesc>
  Calcule et renvoie base à la puissance de pow.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pow, pow, power
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Valeur de <codeph>base</codeph> à la puissance de <codeph>pow</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>base</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à élever à la puissance du paramètre <codeph>pow</codeph>.
  </apiDesc></apiParam><apiParam><apiItemName>pow</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre spécifiant la puissance à laquelle le paramètre <codeph>base</codeph> est élevé.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie val1 élevé à la puissance de val2.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie <codeph>base</codeph> à la puissance de <codeph>pow</codeph>.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:random"><apiName>random</apiName><shortdesc>
  Renvoie un nombre pseudo-aléatoire n, où 0 &amp;lt;= n &amp;lt; 1.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.random, random
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nombre pseudo-aléatoire.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie un nombre pseudo-aléatoire n, où 0 &lt;= n &lt; 1.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Renvoie un nombre pseudo-aléatoire n, où 0 &lt;= n &lt; 1. Le nombre renvoyé est calculé de façon confidentielle et pseudo-aléatoire, dans la mesure où le calcul contient inévitablement certains éléments non aléatoires.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:round"><apiName>round</apiName><shortdesc>
  Arrondit la valeur du paramètre val à l’entier immédiatement supérieur ou inférieur et la renvoie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.round, round
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Paramètre <codeph>val</codeph> arrondi à l’entier le plus proche.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à arrondir.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la valeur du paramètre val arrondi à l’entier (inférieur ou supérieur) le plus proche.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Arrondit la valeur du paramètre <codeph>val</codeph> à l’entier immédiatement supérieur ou inférieur et la renvoie. Si <codeph>val</codeph> est équidistant par rapport aux deux entiers les plus proches (si le nombre se termine par ,5), la valeur est arrondie à l’entier immédiatement supérieur.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/ceil()"><linktext>Math.ceil()</linktext></link><link href="#Math/floor()"><linktext>Math.floor()</linktext></link></related-links></apiOperation><apiOperation id="Math:sin"><apiName>sin</apiName><shortdesc>
  Calcule et renvoie le sinus de l’angle spécifié en radians.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sin, sin, sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nombre ; le sinus de l’angle spécifié (compris entre -1,0 et 1,0).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre représentant un angle mesuré en radians.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie le sinus de l’angle spécifié.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie le sinus de l’angle spécifié en radians. Pour calculer un radian, voir la présentation de la classe Math.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:sqrt"><apiName>sqrt</apiName><shortdesc>
  Calcule et renvoie la racine carrée du nombre spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt, sqrt, square root 
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Si le paramètre <codeph>val</codeph> est supérieur ou égal à zéro, un nombre. Dans le cas contraire, <codeph>NaN</codeph> (n’est pas un nombre).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ou expression supérieur ou égal à 0. 
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la racine carrée du nombre spécifié.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie la racine carrée du nombre spécifié.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:tan"><apiName>tan</apiName><shortdesc>
  Calcule et renvoie la tangente de l’angle spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.tan, tan, tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Tangente du paramètre <codeph>angleRadians</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre représentant un angle mesuré en radians.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la tangente de l’angle spécifié.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Calcule et renvoie la tangente de l’angle spécifié. Pour calculer un radian, voir la présentation de la classe Math.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link></related-links></apiOperation><apiValue id="Math:E"><apiName>E</apiName><shortdesc>
  Constante mathématique pour la base des logarithmes népériens, exprimée en e.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.e, e
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.71828182845905</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour la base des logarithmes népériens, exprimée en e.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Constante mathématique pour la base des logarithmes népériens, exprimée en <i>e</i>. La valeur approximative de <i>e</i><codeph> </codeph> est 2,71828182845905.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN10"><apiName>LN10</apiName><shortdesc>
  Constante mathématique pour le logarithme népérien de 10, exprimée sous la forme de loge10, d’une valeur approximative de 2,302585092994046.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln10, ln10, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.302585092994046</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour le logarithme népérien de 10, exprimée sous la forme de loge10, d’une valeur approximative de 2,302585092994046.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Constante mathématique pour le logarithme népérien de 10, exprimée sous la forme de log<sub>e</sub> 10, d’une valeur approximative de 2,302585092994046.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN2"><apiName>LN2</apiName><shortdesc>
  Constante mathématique pour le logarithme népérien de 2, exprimée sous la forme de loge2, d’une valeur approximative de 0,6931471805599453.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln2, ln2, natural logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.6931471805599453</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour le logarithme népérien de 2, exprimée sous la forme de loge2, d’une valeur approximative de 0,6931471805599453.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Constante mathématique pour le logarithme népérien de 2, exprimée sous la forme de log<sub>e</sub> 2, d’une valeur approximative de 0.6931471805599453.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG10E"><apiName>LOG10E</apiName><shortdesc>
  Constante mathématique pour le logarithme en base 10 de la constante e (Math.E), exprimée sous la forme de log10e, d’une valeur approximative de 0,4342944819032518.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log10e, log10e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.4342944819032518</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour le logarithme en base 10 de la constante e, exprimée sous la forme de log10e, d’une valeur approximative de 0,4342944819032518.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Constante mathématique pour le logarithme en base 10 de la constante <i>e</i> (<codeph>Math.E</codeph>), exprimée sous la forme de log<sub>10</sub>e, d’une valeur approximative de 0,4342944819032518. 
  <p>La méthode <codeph>Math.log()</codeph> calcule le logarithme népérien d’un nombre. Multipliez le résultat de <codeph>Math.log()</codeph> par <codeph>Math.LOG10E</codeph> pour obtenir le logarithme en base 10.</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG2E"><apiName>LOG2E</apiName><shortdesc>
  Constante mathématique pour le logarithme en base 2 de la constante e, exprimée sous la forme de log2e, d’une valeur approximative de 1,442695040888963387.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log2e, log2e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.442695040888963387</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour le logarithme en base 2 de la constante e, exprimée sous la forme de log2e, d’une valeur approximative de 1,442695040888963387.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Constante mathématique pour le logarithme en base 2 de la constante <i>e</i>, exprimée sous la forme de log2e, d’une valeur approximative de 1,442695040888963387.
  
  <p>La méthode <codeph>Math.log</codeph> calcule le logarithme népérien d’un nombre. Multipliez le résultat de <codeph>Math.log()</codeph> par <codeph>Math.LOG2E</codeph> pour obtenir le logarithme en base 2.</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:PI"><apiName>PI</apiName><shortdesc>
  Constante mathématique pour le ratio de la circonférence d’un cercle par rapport à son diamètre, exprimée sous la forme de pi, d’une valeur de 3,141592653589793.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pi, pi
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3.141592653589793</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour le ratio de la circonférence d’un cercle par rapport à son diamètre, exprimée sous la forme de pi, d’une valeur de 3,141592653589793.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Constante mathématique pour le ratio de la circonférence d’un cercle par rapport à son diamètre, exprimée sous la forme de pi, d’une valeur de 3,141592653589793.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT1_2"><apiName>SQRT1_2</apiName><shortdesc> 
  Constante mathématique pour la racine carrée de un demi, d’une valeur approximative de 0,7071067811865476.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt1_2, sqrt1_2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.7071067811865476</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour la racine carrée de un demi, d’une valeur approximative de 0,7071067811865476.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
  Constante mathématique pour la racine carrée de un demi, d’une valeur approximative de 0,7071067811865476.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT2"><apiName>SQRT2</apiName><shortdesc>
  Constante mathématique pour la racine carrée de 2, d’une valeur approximative de 1,4142135623730951.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt2, sqrt2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.4142135623730951</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Constante mathématique pour la racine carrée de 2, d’une valeur approximative de 1,4142135623730951.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Constante mathématique pour la racine carrée de 2, d’une valeur approximative de 1,4142135623730951.
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Array"><apiName>Array</apiName><shortdesc>
 La classe Array vous permet d’accéder aux tableaux et de les manipuler.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Array, Array object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Vous permet d’accéder aux tableaux indexés et de les manipuler.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Array vous permet d’accéder aux tableaux et de les manipuler. Tous les index de tableaux commencent à zéro, ce qui signifie que le premier élément du tableau est <codeph>[0]</codeph>, le deuxième est <codeph>[1]</codeph>, etc. Pour créer un objet Array, utilisez le constructeur <codeph>new Array()</codeph>. <codeph>Array()</codeph> peut également être appelé en tant que fonction. Vous pouvez en outre utiliser l’opérateur d’accès aux tableaux (<codeph>[]</codeph>) pour initialiser un tableau ou accéder aux éléments qu’il contient. 
 <p>Vous pouvez stocker divers types de données dans un élément de tableau, y compris les nombres, les chaînes, les objets et même d’autres tableaux. Vous pouvez créer un tableau <i>multidimensionnel</i> en concevant un tableau indexé et en affectant à chacun de ses éléments un tableau indexé différent. Ce type de tableau est considéré comme étant multidimensionnel car il peut être utilisé pour représenter des données dans un tableau.</p>
 <p> Les tableaux sont <i>sparse arrays</i>, ce qui signifie qu’un élément peut occuper la position d’index 0 et un autre la position d’index 5, mais qu’aucun autre élément n’occupe une position comprise entre 0 et 5. Dans ce cas, les éléments compris entre la position 1 et la position 4 ne sont pas définis. Ce terme indique généralement l’absence d’un élément, plutôt que la présence d’un élément doté de la valeur <codeph>undefined</codeph>.</p>
 
 <p>L’affectation au tableau s’effectue par référence plutôt que par valeur. lorsque vous affectez une variable de tableau à une autre variable de tableau, elles renvoient toutes deux au même tableau :</p>
 <codeblock>
 var oneArray:Array = new Array("a", "b", "c");
 var twoArray:Array = oneArray; // Both array variables refer to the same array.
 twoArray[0] = "z";             
 trace(oneArray);               // Output: z,b,c.
 </codeblock>
 <p>N’utilisez pas la classe Array pour créer des <i>associative arrays</i> (également appelés <i>hashes</i>), qui sont des structures de données qui contiennent des éléments nommés et non pas des éléments chiffrés. Pour créer des tableaux associatifs, utilisez la classe Object. Bien que ActionScript vous permette de créer des tableaux associatifs à l’aide de la classe Array, vous ne pouvez pas associer les méthodes ou les propriétés de cette dernière à un tableau associatif. </p>
 <p>Vous pouvez étendre la classe Array et bloquer ou ajouter des méthodes. Vous devez cependant affecter à la sous-classe la propriété <codeph>dynamic</codeph>, sous peine de ne plus pouvoir stocker des données dans un tableau.</p>
 
 </apiDesc><example conref="examples\ArrayExample.as"> L’exemple suivant crée un nouvel objet Array, <codeph>myArr</codeph>, sans argument et avec une longueur initiale de 0 :
<codeblock>
package {
    import flash.display.Sprite;

    public class ArrayExample extends Sprite {
        public function ArrayExample() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[] (accès au tableau)</linktext></link><link href="#Object"><linktext>Object, classe</linktext></link></related-links><apiConstructor id="Array:Array_0"><apiName>Array</apiName><shortdesc>
	 Vous permet de créer un tableau contenant le nombre spécifié d’éléments.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>L’argument est un nombre autre qu’un entier supérieur ou égal à 0.	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>numElements</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Un entier spécifiant le nombre d’éléments contenus dans le tableau.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Vous permet de créer un tableau contenant le nombre spécifié d’éléments. Si vous ne spécifiez aucun paramètre, un tableau contenant 0 élément est créé. Si vous spécifiez un nombre d’éléments, le tableau créé contient le nombre d’éléments indiqué par <codeph>numElements</codeph>. 
     <p><b>Remarque :</b> cette classe contient deux entrées de méthode de constructeur, car le constructeur gère les types variables d’arguments. Le constructeur se comporte différemment selon le type et le nombre d’arguments transmis, comme indiqué dans chaque entrée. ActionScript 3.0 ne prend pas en charge la surcharge d’une méthode ou d’un constructeur.</p>
     
	 
	 </apiDesc><example conref="examples\Array_Array.as"> L’exemple suivant crée un objet Array, <codeph>myArr</codeph>, sans argument et avec une longueur initiale de 0 :
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array extends Sprite {

        public function Array_Array() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example><example conref="examples\Array_Array_2.as"> L’exemple suivant crée un objet Array avec 5 éléments initiaux, d’une longueur de 5, et remplit le premier élément avec la chaîne <codeph>"one"</codeph>, puis ajoute l’élément de chaîne <codeph>"six"</codeph> à la fin du tableau en employant la méthode <codeph>push()</codeph> :
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_2 extends Sprite {

        public function Array_Array_2() {
            var myArr:Array = new Array(5);
            trace(myArr.length); // 5
            myArr[0] = "one";
            myArr.push("six");
            trace(myArr);         // one,,,,,six
            trace(myArr.length); // 6
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[], accès au tableau</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiConstructor id="Array:Array_1"><apiName>Array</apiName><shortdesc>
	 Permet de créer un tableau contenant le nombre spécifié d’éléments.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>L’argument est un nombre autre qu’un entier supérieur ou égal à 0.	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Liste de deux valeurs arbitraires ou plus séparées par une virgule. 
	 <p><b>Remarque : </b>si vous transmettez un paramètre numérique unique au constructeur Array, il est implicitement interprété comme la propriété <codeph>length</codeph> du tableau.</p>
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Vous permet de créer un tableau contenant le nombre spécifié d’éléments. Tous les types de valeurs sont pris en charge. La valeur de l’index (ou de la position) du premier élément d’un tableau est toujours 0.
     <p><b>Remarque :</b> cette classe contient deux entrées de constructeur, car celui-ci gère les types variables d’arguments. Le constructeur se comporte différemment selon le type et le nombre d’arguments transmis, comme indiqué dans chaque entrée. ActionScript 3.0 ne prend pas en charge la surcharge d’une méthode ou d’un constructeur.</p>
	 </apiDesc><example conref="examples\Array_Array_3.as"> L’exemple suivant crée un nouvel objet Array avec une longueur initiale de 3, remplit le tableau avec les éléments de type chaîne <codeph>one</codeph>, <codeph>two</codeph> et <codeph>three</codeph>, puis convertit ces éléments en une chaîne unique.
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_3 extends Sprite {

        public function Array_Array_3() {
            var myArr:Array = new Array("one", "two", "three");
            trace(myArr.length); // 3
            trace(myArr);          // one,two,three
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[], accès au tableau</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiOperation id="Array:AS3:concat"><apiName>concat</apiName><shortdesc>
	 Concatène les éléments spécifiés dans les paramètres avec ceux contenus dans un tableau et crée un nouveau tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Tableau qui contient les éléments de ce tableau, suivis des éléments des paramètres.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Valeur de tout type (nombre, élément ou chaîne) à concaténer dans un nouveau tableau. Si vous ne transmettez aucune valeur, le nouveau tableau est une duplication du tableau d’origine.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Concatène les éléments spécifiés par les paramètres.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Concatène les éléments spécifiés dans les paramètres avec ceux contenus dans un tableau et crée un nouveau tableau. Si les paramètres spécifient un tableau, les éléments correspondants sont concaténés. 
 	 
 	 </apiDesc><example conref="examples\Array.concat.1.as"> Le code suivant crée quatre objets Array :
 <ul>
   <li>Le tableau <codeph>numbers</codeph>, qui contient les nombres <codeph>1</codeph>, <codeph>2</codeph> et <codeph>3</codeph>. </li>
   <li>Le tableau <codeph>letters</codeph>, qui contient les nombres <codeph>a</codeph>, <codeph>b</codeph> et <codeph>c</codeph>. </li>
   <li>Le tableau <codeph>numbersAndLetters</codeph>, qui appelle la méthode <codeph>concat()</codeph> pour produire le tableau <codeph>[1,2,3,a,b,c]</codeph>. </li>
   <li>Le tableau <codeph>lettersAndNumbers</codeph>, qui appelle la méthode <codeph>concat()</codeph> pour produire le tableau <codeph>[a,b,c,1,2,3]</codeph>. </li>
 </ul>
<codeblock>

var numbers:Array = new Array(1, 2, 3);
var letters:Array = new Array("a", "b", "c");
var numbersAndLetters:Array = numbers.concat(letters);
var lettersAndNumbers:Array = letters.concat(numbers);

trace(numbers);       // 1,2,3
trace(letters);       // a,b,c
trace(numbersAndLetters); // 1,2,3,a,b,c
trace(lettersAndNumbers); // a,b,c,1,2,3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:every"><apiName>every</apiName><shortdesc>
	 Exécute une fonction de test sur chaque élément du tableau jusqu’à ce que l’un d’eux renvoie false pour la fonction spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur booléenne <codeph>true</codeph> si tous les éléments du tableau renvoient <codeph>true</codeph> pour la fonction spécifiée, <codeph>false</codeph> dans tous les autres cas.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du tableau. Cette fonction peut contenir une comparaison simple (<codeph>item &lt; 20</codeph>, par exemple) ou une opération plus complexe et est appelée avec trois arguments, la valeur d’un élément, l’index de ce dernier et l’objet Array :
     <pre>function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Objet à utiliser comme mot-clé <codeph>this</codeph> pour la fonction.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Exécute une fonction de test sur chaque élément du tableau jusqu’à ce que l’un d’eux renvoie <codeph>false</codeph> pour la fonction spécifiée. Cette méthode vous permet de déterminer si tous les éléments d’un tableau répondent à un critère défini, tel que des valeurs inférieures à un nombre spécifique.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. Supposons que vous créez une fonction dans un clip appelé <codeph>me</codeph> :</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>every()</codeph> sur un tableau appelé <codeph>myArray</codeph> :</p>
     <pre product="flash">
     myArray.every(myFunction, me);
     </pre>
     <p product="flash"><codeph>myFunction</codeph> appartenant à la classe Timeline qui ne peut pas être bloquée par <codeph>me</codeph>, Flash Player renvoie une exception. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
     };
     myArray.every(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array_every.as"> L’exemple suivant teste deux tableaux pour déterminer si tous les éléments de tous les tableaux sont numériques. Il renvoie également les résultats du test, qui indique que <codeph>isNumeric</codeph> est <codeph>true</codeph> pour le premier tableau et <codeph>false</codeph> pour le deuxième :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_every extends Sprite {
        public function Array_every() {
            var arr1:Array = new Array(1, 2, 4);
            var res1:Boolean = arr1.every(isNumeric);
            trace("isNumeric:", res1); // true
 
            var arr2:Array = new Array(1, 2, "ham");
            var res2:Boolean = arr2.every(isNumeric);
            trace("isNumeric:", res2); // false
        }
        private function isNumeric(element:*, index:int, arr:Array):Boolean {
            return (element is Number);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/some()"><linktext>Array.some()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:filter"><apiName>filter</apiName><shortdesc>
	 Exécute une fonction de test sur chaque élément du tableau et construit un nouveau tableau contenant tous les éléments qui renvoient true pour la fonction spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouveau tableau contenant tous les éléments du tableau d’origine qui ont renvoyé <codeph>true</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du tableau. Cette fonction peut contenir une comparaison simple (<codeph>item &lt; 20</codeph>, par exemple) ou une opération plus complexe et est appelée avec trois arguments, la valeur d’un élément, l’index de ce dernier et l’objet Array :
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Objet à utiliser comme mot-clé <codeph>this</codeph> pour la fonction.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Exécute une fonction de test sur chaque élément du tableau et construit un nouveau tableau contenant tous les éléments qui renvoient <codeph>true</codeph> pour la fonction spécifiée. Si un élément renvoie <codeph>false</codeph>, il ne figure pas dans le nouveau tableau.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. Supposons que vous créez une fonction dans un clip appelé <codeph>me</codeph> :</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Supposons que vous utilisez ensuite la méthode <codeph>filter()</codeph> sur un tableau appelé <codeph>myArray</codeph> :</p>
     <pre product="flash"> 
     myArray.filter(myFunction, me);
     </pre>
     <p product="flash"><codeph>myFunction</codeph> appartenant à la classe Timeline qui ne peut pas être bloquée par <codeph>me</codeph>, Flash Player renvoie une exception. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.filter(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array.filter.as"> L’exemple suivant crée un tableau de tous les employés qui sont des responsables :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_filter extends Sprite {
        public function Array_filter() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace("Employees:");
            employees.forEach(traceEmployee);
            
            var managers:Array = employees.filter(isManager);
            trace("Managers:");
            managers.forEach(traceEmployee);
        }
        private function isManager(element:*, index:int, arr:Array):Boolean {
            return (element.manager == true);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace("\t" + element.name + ((element.manager) ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/map()"><linktext>Array.map()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:forEach"><apiName>forEach</apiName><shortdesc>
	 Exécute une fonction sur chaque élément du tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du tableau. Cette fonction peut contenir une commande simple (une instruction <codeph>trace()</codeph>, par exemple) ou une opération plus complexe et est appelée avec trois arguments, la valeur d’un élément, l’index de ce dernier et l’objet Array :
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Objet à utiliser comme mot-clé <codeph>this</codeph> pour la fonction.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Exécute une fonction sur chaque élément du tableau.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. Supposons que vous créez une fonction dans un clip appelé <codeph>me</codeph> :</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>forEach()</codeph> sur un tableau appelé <codeph>myArray</codeph> :</p>
     <pre product="flash">
     myArray.forEach(myFunction, me);
     </pre>
     <p product="flash"><codeph>myFunction</codeph> appartenant à la classe Timeline qui ne peut pas être bloquée par <codeph>me</codeph>, Flash Player renvoie une exception. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.forEach(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_forEach.as"> L’exemple suivant exécute l’instruction <codeph>trace()</codeph> de la fonction <codeph>traceEmployee()</codeph> pour tous les éléments du tableau :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach extends Sprite {
        public function Array_forEach() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace(employees);
            employees.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace(element.name + " (" + element.manager + ")");
        }
    }
}
</codeblock></example><example conref="examples\Array_forEach_2.as"> L’exemple suivant exécute également l’instruction <codeph>trace()</codeph> à l’aide d’une fonction <codeph>traceEmployee()</codeph> légèrement modifiée pour tous les éléments du tableau :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach_2 extends Sprite {
        public function Array_forEach_2() {
            var employeeXML:XML = &lt;employees>
                    &lt;employee name="Steven" manager="false" />
                    &lt;employee name="Bruce" manager="true" />
                    &lt;employee name="Rob" manager="false" />
                &lt;/employees>;
            var employeesList:XMLList = employeeXML.employee;
            var employeesArray:Array = new Array();
            for each (var tempXML:XML in employeesList) {
                employeesArray.push(tempXML);
            }
            employeesArray.sortOn("@name");
            employeesArray.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:Number, arr:Array):void {
            trace(element.@name + ((element.@manager == "true") ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 Recherche un élément dans un tableau en utilisant l’opérateur d’égalité stricte (===) et renvoie la position d’index de l’élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Position d’index commençant à zéro de l’élément du tableau. Si l’argument <codeph>searchElement</codeph> n’est pas détecté, la valeur renvoyée est -1.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>Elément à trouver dans le tableau.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Emplacement à partir duquel débuter la recherche d’élément.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Recherche un élément dans un tableau en utilisant l’opérateur d’égalité stricte (<codeph>===</codeph>) et renvoie la position d’index de l’élément.
	 </apiDesc><example conref="examples\Array_indexOf.as"> L’exemple suivant affiche la position du tableau spécifié :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_indexOf extends Sprite {
        public function Array_indexOf() {
            var arr:Array = new Array(123,45,6789);
            arr.push("123-45-6789");
            arr.push("987-65-4321");
            
            var index:int = arr.indexOf("123");
            trace(index); // -1
            
            var index2:int = arr.indexOf(123);
            trace(index2); // 0
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/lastIndexOf()"><linktext>Array.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (égalité stricte)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:join"><apiName>join</apiName><shortdesc>
	 Convertit les éléments d’un tableau en chaînes, insère le séparateur spécifié entre les éléments, les concatène, puis renvoie la chaîne obtenue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.join, join
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Chaîne composée des éléments d’un tableau convertis en chaînes et séparés par le paramètre spécifié.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Caractère ou chaîne séparant les éléments du tableau dans la chaîne renvoyée. Si vous omettez ce paramètre, une virgule est utilisée en tant que séparateur par défaut. 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Convertit les éléments d’un tableau en chaînes.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Convertit les éléments d’un tableau en chaînes, insère le séparateur spécifié entre les éléments, les concatène, puis renvoie la chaîne obtenue. Un tableau imbriqué est toujours séparé par une virgule (,) et non par le séparateur transmis à la méthode <codeph>join()</codeph>.
	 
	 </apiDesc><example conref="examples\Array.join.1.as"> Le code suivant crée un objet Array <codeph>myArr</codeph> avec les éléments <codeph>one</codeph>, <codeph>two</codeph> et <codeph>three</codeph>, puis une chaîne contenant <codeph>one and two and three</codeph> à l’aide de la méthode <codeph>join()</codeph>.
<codeblock>

var myArr:Array = new Array("one", "two", "three");
var myStr:String = myArr.join(" and ");
trace(myArr); // one,two,three
trace(myStr); // one and two and three
</codeblock></example><example conref="examples\Array.join.2.as"> Le code suivant crée un objet Array, <codeph>specialChars</codeph>, avec des éléments <codeph>(</codeph>, <codeph>)</codeph>, <codeph>-</codeph> et un espace blanc, puis crée une chaîne contenant <codeph>(888) 867-5309</codeph>. Ensuite, à l’aide d’une boucle <codeph>for</codeph>, il supprime tous les types de caractères spéciaux qui figurent dans la liste <codeph>specialChars</codeph> pour produire une chaîne (<codeph>myStr</codeph>) qui contient uniquement le numéro de téléphone restant : <codeph>888675309</codeph> . De plus, il est possible d’ajouter des caractères, tels que <codeph>+</codeph>, à la liste <codeph>specialChars</codeph> pour que la routine fonctionne avec les formats internationaux de numéro de téléphone.
<codeblock>

var phoneString:String = "(888) 867-5309";

var specialChars:Array = new Array("(", ")", "-", " ");
var myStr:String = phoneString;

var ln:uint = specialChars.length;
for(var i:uint; i &lt; ln; i++) {
    myStr = myStr.split(specialChars[i]).join("");
}

var phoneNumber:Number = new Number(myStr);

trace(phoneString); // (888) 867-5309
trace(phoneNumber); // 8888675309
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 Recherche un élément dans un tableau en travaillant à rebours à partir du dernier élément et renvoie la position d’index de l’élément correspondant en utilisant l’opérateur d’égalité stricte (===).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Position d’index commençant à zéro de l’élément du tableau. Si l’argument <codeph>searchElement</codeph> n’est pas détecté, la valeur renvoyée est -1.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>Elément à trouver dans le tableau.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Emplacement à partir duquel débuter la recherche d’élément. La valeur par défaut correspond à la valeur maximale autorisée d’un index. Si vous ne spécifiez pas <codeph>fromIndex</codeph>, la recherche débute par le dernier élément du tableau.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Recherche un élément dans un tableau en travaillant à rebours à partir du dernier élément et renvoie la position d’index de l’élément correspondant en utilisant l’opérateur d’égalité stricte (<codeph>===</codeph>).
	 </apiDesc><example conref="examples\Array_lastIndexOf.as"> L’exemple suivant affiche la position du tableau spécifié :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_lastIndexOf extends Sprite {
        public function Array_lastIndexOf() {
            var arr:Array = new Array(123,45,6789,123,984,323,123,32);
            
            var index:int = arr.indexOf(123);
            trace(index); // 0
            
            var index2:int = arr.lastIndexOf(123);
            trace(index2); // 6
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/indexOf()"><linktext>Array.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (égalité stricte)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:map"><apiName>map</apiName><shortdesc>
     Exécute une fonction sur les éléments d’un tableau et construit un nouveau tableau en fonction des résultats de la fonction appliquée à chaque élément du tableau d’origine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouveau tableau composé des résultats de la fonction appliquée à chaque élément du tableau d’origine.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du tableau. Cette fonction peut contenir une commande simple (la modification de la casse des chaînes d’un tableau, par exemple) ou une opération plus complexe et est appelée avec trois arguments, la valeur d’un élément, l’index de ce dernier et l’objet Array :
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Objet à utiliser comme mot-clé <codeph>this</codeph> pour la fonction.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Exécute une fonction sur les éléments d’un tableau et construit un nouveau tableau en fonction des résultats de la fonction appliquée à chaque élément du tableau d’origine.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. Supposons que vous créez une fonction dans un clip appelé <codeph>me</codeph> :</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>map()</codeph> sur un tableau appelé <codeph>myArray</codeph> :</p>
     <pre product="flash">
     myArray.map(myFunction, me);
     </pre>
     <p product="flash"><codeph>myFunction</codeph> appartenant à la classe Timeline qui ne peut pas être bloquée par <codeph>me</codeph>, Flash Player renvoie une exception. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.map(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_map.as"> L’exemple suivant modifie tous les éléments du tableau pour obtenir des lettres en majuscules :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_map extends Sprite {
        public function Array_map() {
            var arr:Array = new Array("one", "two", "Three");
            trace(arr); // one,two,Three

            var upperArr:Array = arr.map(toUpper);
            trace(upperArr); // ONE,TWO,THREE
        }
        private function toUpper(element:*, index:int, arr:Array):String {
            return String(element).toUpperCase();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/filter()"><linktext>Array.filter()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:pop"><apiName>pop</apiName><shortdesc>
	  Supprime le dernier élément d’un tableau et renvoie la valeur de cet élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.pop, pop
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur du dernier élément (de tout type de données) dans le tableau spécifié.
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	  Supprime le dernier élément d’un tableau et renvoie la valeur de cet élément.
	 
	 </apiDesc><example conref="examples\Array.pop.1.as"> Le code suivant crée un objet Array, <codeph>letters</codeph>, avec les éléments <codeph>a</codeph>, <codeph>b</codeph> et <codeph>c</codeph>. Le dernier élément (<codeph>c</codeph>) est ensuite supprimé du tableau à l’aide de la méthode <codeph>pop()</codeph> et affecté ensuite à l’objet String, <codeph>letter</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
var letter:String = letters.pop();
trace(letters); // a,b
trace(letter);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:push"><apiName>push</apiName><shortdesc>
	 Ajoute un ou plusieurs éléments à la fin d’un tableau et renvoie la nouvelle longueur du tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.push, push
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Entier représentant la longueur du nouveau tableau.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs valeurs à ajouter au tableau.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ajoute un ou plusieurs éléments à la fin d’un tableau et renvoie la nouvelle longueur du tableau.
	 
	 </apiDesc><example conref="examples\Array.push.1.as"> Le code suivant crée un objet Array vide, <codeph>letters</codeph>, puis le remplit avec les éléments <codeph>a</codeph>, <codeph>b</codeph> et <codeph>c</codeph> à l’aide de la méthode <codeph>push()</codeph>.
<codeblock>

var letters:Array = new Array();

letters.push("a");
letters.push("b");
letters.push("c");

trace(letters.toString()); // a,b,c
</codeblock></example><example conref="examples\Array.push.2.as"> Le code suivant crée un objet Array, <codeph>letters</codeph>, qui est rempli en premier lieu avec l’élément <codeph>a</codeph>. La méthode <codeph>push()</codeph> est ensuite utilisée une fois pour ajouter les éléments <codeph>b</codeph> et <codeph>c</codeph> à la fin du tableau, soit trois éléments après l’application de la fonction push.
<codeblock>

var letters:Array = new Array("a");
var count:uint = letters.push("b", "c");

trace(letters); // a,b,c
trace(count);   // 3
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:reverse"><apiName>reverse</apiName><shortdesc>
	  Inverse le tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.reverse, reverse
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouveau tableau.
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Inverse le tableau.
	 
	 </apiDesc><example conref="examples\Array.reverse.1.as"> Le code suivant crée un objet Array, <codeph>letters</codeph>, avec les éléments <codeph>a</codeph>, <codeph>b</codeph> et <codeph>c</codeph>. L’ordre des éléments du tableau est ensuite inversé à l’aide de la méthode <codeph>reverse()</codeph> pour produire le tableau <codeph>[c,b,a]</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
letters.reverse();
trace(letters); // c,b,a
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:shift"><apiName>shift</apiName><shortdesc>
	 Supprime le premier élément d’un tableau et renvoie cet élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.shift, shift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Premier élément (de tout type de données) d’un tableau.
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 Supprime le premier élément d’un tableau et renvoie cet élément. Les éléments restants du tableau sont décalés de leur position d’origine, i, vers i-1.
	 
	 </apiDesc><example conref="examples\Array.shift.1.as"> Le code suivant crée un objet Array, <codeph>letters</codeph>, avec les éléments <codeph>a</codeph>, <codeph>b</codeph> et <codeph>c</codeph>. La méthode <codeph>shift()</codeph> est ensuite utilisée pour supprimer le premier élément (<codeph>a</codeph>) dans <codeph>letters</codeph> et l’affecte ensuite à la chaîne <codeph>firstLetter</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c");
var firstLetter:String = letters.shift();
trace(letters);     // b,c
trace(firstLetter); // a
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:slice"><apiName>slice</apiName><shortdesc>
	 Renvoie un nouveau tableau constitué d’un éventail d’éléments issus du tableau d’origine, sans modifier ce dernier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Tableau constitué d’un éventail d’éléments issus du tableau d’origine.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre spécifiant l’index du point de départ pour la découpe. Si <codeph>startIndex</codeph> est un nombre négatif, le point de départ se trouve à la fin du tableau, où la valeur -1 est le dernier élément.	
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>Nombre spécifiant l’index du point d’arrivée pour la découpe. Si vous omettez ce paramètre, la découpe inclut tous les éléments du point de départ à la fin du tableau. Si <codeph>endIndex</codeph> est un nombre négatif, le point d’arrivée spécifié se trouve à la fin du tableau, où la valeur -1 est le dernier élément.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie un nouveau tableau constitué d’un éventail d’éléments issus du tableau d’origine.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie un nouveau tableau constitué d’un éventail d’éléments issus du tableau d’origine, sans modifier ce dernier. Le tableau renvoyé inclut l’élément <codeph>startIndex</codeph> et tous les éléments, excepté l’élément <codeph>endIndex</codeph>. 
	 <p>Si vous ne transmettez aucun paramètre, une duplication du tableau d’origine est créée.</p>
	 
	 </apiDesc><example conref="examples\Array.slice.1.as"> Le code suivant crée un objet Array, <codeph>letters</codeph>, avec les éléments <codeph>[a,b,c,d,e,f]</codeph>. Le tableau <codeph>someLetters</codeph> est ensuite créé en appelant la méthode <codeph>slice()</codeph> sur les éléments un (<codeph>b</codeph>) à trois (<codeph>d</codeph>), ce qui résulte en un tableau avec les éléments <codeph>b</codeph> et <codeph>c</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(1,3);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // b,c
</codeblock></example><example conref="examples\Array.slice.2.as"> Le code suivant crée un objet Array <codeph>letters</codeph> avec les éléments <codeph>[a,b,c,d,e,f]</codeph>. Le tableau <codeph>someLetters</codeph> est ensuite créé en appelant la méthode <codeph>slice()</codeph> sur l’élément deux (<codeph>c</codeph>), ce qui résulte en un tableau avec des éléments <codeph>[c,d,e,f]</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // c,d,e,f
</codeblock></example><example conref="examples\Array.slice.3.as"> Le code suivant crée un objet Array, <codeph>letters</codeph>, avec les éléments <codeph>[a,b,c,d,e,f]</codeph>. Le tableau <codeph>someLetters</codeph> est ensuite créé en appelant la méthode <codeph>slice()</codeph> du deuxième au dernier élément à partir de la fin (<codeph>e</codeph>), ce qui résulte en un tableau avec les éléments <codeph>e</codeph> et <codeph>f</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(-2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // e,f
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:some"><apiName>some</apiName><shortdesc>
     Exécute une fonction de test sur chaque élément du tableau jusqu’à ce que l’un d’eux renvoie true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur booléenne <codeph>true</codeph> si un élément du tableau renvoie <codeph>true</codeph> pour la fonction spécifiée, <codeph>false</codeph> dans tous les autres cas.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du tableau. Cette fonction peut contenir une comparaison simple (<codeph>item &lt; 20</codeph>, par exemple) ou une opération plus complexe et est appelée avec trois arguments, la valeur d’un élément, l’index de ce dernier et l’objet Array :
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Objet à utiliser comme mot-clé <codeph>this</codeph> pour la fonction.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Exécute une fonction de test sur chaque élément du tableau jusqu’à ce que l’un d’eux renvoie <codeph>true</codeph>. Cette méthode vous permet de déterminer si un élément de tableau répond au critère défini, tel qu’une valeur inférieure à un nombre spécifique.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. Supposons que vous créez une fonction dans un clip appelé <codeph>me</codeph> :</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>some()</codeph> sur un tableau appelé <codeph>myArray</codeph> :</p>
     <pre product="flash">
     myArray.some(myFunction, me);
     </pre>
     <p product="flash"><codeph>myFunction</codeph> appartenant à la classe Timeline qui ne peut pas être bloquée par <codeph>me</codeph>, Flash Player renvoie une exception. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.some(myFunction, me);
     </pre>   
	 </apiDesc><example conref="examples\Array_some.as"> L’exemple suivant affiche les valeurs qui ne sont pas définies :
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_some extends Sprite {
        public function Array_some() {
            var arr:Array = new Array();
            arr[0] = "one";
            arr[1] = "two";
            arr[3] = "four";
            var isUndef:Boolean = arr.some(isUndefined);
            if (isUndef) {
                trace("array contains undefined values: " + arr);
            } else {
                trace("array contains no undefined values.");
            }
        }
        private function isUndefined(element:*, index:int, arr:Array):Boolean {
            return (element == undefined);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sort"><apiName>sort</apiName><shortdesc>
	 Trie les éléments d’un tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sort, sort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>La valeur renvoyée varie selon que vous transmettez ou non des arguments, comme décrit dans la liste suivante :
	 <ul>
	   <li>Si vous spécifiez la valeur 4 ou <codeph>Array.UNIQUESORT</codeph> pour l’argument <codeph>sortOptions</codeph> du paramètre <codeph>...args</codeph> et si au moins deux éléments triés possèdent des champs de tri identiques, Flash renvoie la valeur 0 et ne modifie pas le tableau. </li>
  	   <li>Si vous spécifiez la valeur 8 ou <codeph>Array.RETURNINDEXEDARRAY</codeph> pour l’argument <codeph>sortOptions</codeph> du paramètre <codeph>...args</codeph>, Flash renvoie un tableau numérique trié des index qui reflète les résultats du tri et ne modifie pas le tableau. </li>
	   <li>Dans le cas contraire, Flash ne renvoie rien et modifie le tableau pour refléter l’ordre de tri.</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Les arguments spécifiant une fonction de comparaison et une ou plusieurs valeurs qui déterminent le comportement du tri.
	 <p>Cette méthode utilise la syntaxe et l’ordre des arguments de <codeph>Array.sort(compareFunction, sortOptions)</codeph>, ces derniers étant définis comme suit :</p>
     <ul><li><codeph>compareFunction</codeph> - Fonction de comparaison utilisée pour déterminer l’ordre de tri des éléments d’un tableau. Cet argument est facultatif. Une fonction de comparaison gère deux arguments utilisés pour la comparaison. Etant donné les éléments A et B, le résultat de <codeph>compareFunction</codeph> peut être l’une des trois valeurs suivantes : négative, 0 ou positive.
	 <ul>
	   <li>Une valeur renvoyée négative indique que A apparaît avant B dans la séquence triée.</li>
	   <li>Une valeur renvoyée de 0 indique que A et B possèdent le même ordre de tri.</li>
	   <li>Une valeur renvoyée positive indique que A apparaît après B dans la séquence triée.</li>
	 </ul>
	 </li>
	 <li><codeph>sortOptions</codeph> - Un ou plusieurs nombres ou constantes définies, séparés par l’opérateur OR <codeph>|</codeph> au niveau du bit, qui modifient le comportement de tri par défaut. Cet argument est facultatif. Les valeurs suivantes sont valides pour <codeph>sortOptions</codeph> : 
	  <ul>
	   <li>1 ou <codeph>Array.CASEINSENSITIVE</codeph></li>
	   <li>2 ou <codeph>Array.DESCENDING</codeph></li>
	   <li>4 ou <codeph>Array.UNIQUESORT</codeph></li>
	   <li>8 ou <codeph>Array.RETURNINDEXEDARRAY</codeph> </li>
	   <li>16 ou <codeph>Array.NUMERIC</codeph></li>
	 </ul>
	 Pour plus d’informations, voir la méthode <codeph>Array.sortOn()</codeph>.</li>
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Trie les éléments d’un tableau. Cette méthode trie selon les valeurs Unicode (ASCII est un sous-ensemble de Unicode).
	 <p>Par défaut, <codeph>Array</codeph>.<codeph>sort()</codeph> fonctionne de la façon suivante :</p>
	 <ul>
	   <li>Le tri tient compte de la casse (<i>Z</i> précède <i>a</i>).</li>
	   <li>Le tri est ascendant (<i>a</i> précède <i>b</i>). </li>
	   <li>Le tableau est modifié afin de refléter l’ordre de tri ; les éléments multiples dont les champs de tri sont identiques sont placés consécutivement dans le tableau trié dans un ordre quelconque.</li>
	   <li>Tous les éléments, quel que soit leur type de données, sont triés comme s’il s’agissait de chaînes : ainsi, 100 précède 99 car « 1 » est une valeur de chaîne inférieure à « 9 ».</li>
	 </ul>
	 <p>
	 Pour trier un tableau à l’aide de réglages autres que les réglages par défaut, vous pouvez utiliser l’une des options de tri décrites dans la section <codeph>sortOptions</codeph> de la description du paramètre <codeph>...args</codeph> ou vous pouvez créer une fonction personnalisée. Si vous créez une fonction personnalisée, vous pouvez appeler la méthode <codeph>sort()</codeph> et utiliser le nom de votre fonction personnalisée en tant que premier argument (<codeph>compareFunction</codeph>). 
	 </p>
	 
	 </apiDesc><example conref="examples\Array.sort.1.as"> Le code suivant crée un objet Array, <codeph>vegetables</codeph>, avec les éléments suivants <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph>. Le tableau est ensuite trié en fonction de la méthode <codeph>sort()</codeph>, qui est appelée sans paramètres. Le résultat est que <codeph>vegetables</codeph> est trié par ordre alphabétique (<codeph>[avocado, cilantro, green pepper, onion, spinach]</codeph>).
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

trace(vegetables); // spinach,green pepper,cilantro,onion,avocado
vegetables.sort();
trace(vegetables); // avocado,cilantro,green pepper,onion,spinach
</codeblock></example><example conref="examples\Array.sort.2.as"> Le code suivant crée un objet Array, <codeph>vegetables</codeph>, avec les éléments suivants <codeph>[spinach, green pepper, Cilantro, Onion et Avocado]</codeph>. Le tableau est ensuite trié avec la méthode <codeph>sort()</codeph>, qui est appelée sans paramètres pour la première fois. Le résultat en est <codeph>[Avocado,Cilantro,Onion,green pepper,spinach]</codeph>. La fonction <codeph>sort()</codeph> est ensuite appelée à nouveau sur <codeph>vegetables</codeph> et utilise la constante <codeph>CASEINSENSITIVE</codeph> en tant que paramètre. Le résultat est que <codeph>vegetables</codeph> est trié par ordre alphabétique (<codeph>[Avocado, Cilantro, green pepper, Onion, spinach]</codeph>).
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "Cilantro",
                 "Onion",
                 "Avocado");

vegetables.sort();
trace(vegetables); // Avocado,Cilantro,Onion,green pepper,spinach
vegetables.sort(Array.CASEINSENSITIVE);
trace(vegetables); // Avocado,Cilantro,green pepper,Onion,spinach
</codeblock></example><example conref="examples\Array.sort.3.as"> Le code suivant crée un objet Array vide, <codeph>vegetables</codeph>, qui est ensuite rempli par cinq appels à la fonction <codeph>push()</codeph>. A chaque fois que <codeph>push()</codeph> est appelé, un nouvel objet <codeph>Vegetable</codeph> est créé par un appel au constructeur <codeph>Vegetable()</codeph>, qui accepte un objet de type chaîne (<codeph>name</codeph>) et un autre de type numérique (<codeph>price</codeph>). Cinq appels consécutifs de la fonction <codeph>push()</codeph> avec les valeurs indiquées produisent le tableau suivant : <codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>. La méthode <codeph>sort()</codeph> est ensuite utilisée pour trier le tableau, ce qui produit le tableau <codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>.
<codeblock>
var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort();

trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

//The following code defines the Vegetable class
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.4.as"> L’exemple suivant est rigoureusement identique au précédent, à la différence que la méthode <codeph>sort()</codeph> est utilisée avec une fonction de tri personnalisée (<codeph>sortOnPrice</codeph>), qui effectue le tri en fonction du prix et non pas par ordre alphabétique. Vous pouvez constater que la nouvelle fonction, <codeph>getPrice()</codeph>, extrait le prix.
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort(sortOnPrice);

trace(vegetables);
// celery:1.29, squash:1.44, lettuce:1.49, spinach:1.89, asparagus:3.99

function sortOnPrice(a:Vegetable, b:Vegetable):Number {
    var aPrice:Number = a.getPrice();
    var bPrice:Number = b.getPrice();

    if(aPrice > bPrice) {
        return 1;
    } else if(aPrice &lt; bPrice) {
        return -1;
    } else  {
        //aPrice == bPrice
        return 0;
    }
}

// The following code defines the Vegetable class and should be in a separate package.
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function getPrice():Number {
        return price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.5.as"> Le code suivant crée un objet Array, <codeph>numbers</codeph>, avec les éléments <codeph>[3,5,100,34,10]</codeph>. Tout appel sans paramètre à la fonction <codeph>sort()</codeph> produirait un résultat indésirable <codeph>[10,100,3,34,5]</codeph>. Afin de trier correctement les valeurs numériques, vous devez transmettre la constante <codeph>NUMERIC</codeph> à la méthode <codeph>sort()</codeph>, qui trie <codeph>numbers</codeph> de la façon suivante : <codeph>[3,5,10,34,100]</codeph> .
 <p><b>Remarque :</b> Le comportement par défaut de la fonction <codeph>sort()</codeph> traite chaque entité comme une chaîne. L’argument <codeph>Array.NUMERIC</codeph> ne convertit pas réellement d’autres types de données au format Number ; il permet simplement à l’algorithme de tri d’identifier des nombres.</p>
<codeblock>

var numbers:Array = new Array(3,5,100,34,10);

trace(numbers); // 3,5,100,34,10
numbers.sort();
trace(numbers); // 10,100,3,34,5
numbers.sort(Array.NUMERIC);
trace(numbers); // 3,5,10,34,100
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (OR au niveau du bit)</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sortOn"><apiName>sortOn</apiName><shortdesc>
	 Trie les éléments d’un tableau selon un ou plusieurs champs du tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sortOn, sortOn
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>La valeur renvoyée varie selon que vous transmettez ou non des paramètres :
	 <ul>
	   <li>Si vous spécifiez une valeur de 4 ou <codeph>Array.UNIQUESORT</codeph> pour le paramètre <codeph>options</codeph> et si au moins deux éléments triés ont des champs de tri identiques, la valeur 0 est renvoyée et le tableau n’est pas modifié. </li>
  	   <li>Si vous spécifiez une valeur de 8 ou <codeph>Array.RETURNINDEXEDARRAY</codeph> pour le paramètre <codeph>options</codeph>, un tableau qui reflète les résultats du tri est renvoyé et le tableau n’est pas modifié.</li>
  	   <li>Dans le cas contraire, Flash ne renvoie rien et modifie le tableau pour refléter l’ordre de tri.</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>fieldName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Chaîne identifiant un champ à utiliser en tant que valeur de tri ou un tableau dans lequel le premier élément représente le champ de tri principal, le deuxième le champ de tri secondaire, etc.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>options</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Un ou plusieurs nombres ou noms de constantes définies, séparés par l’opérateur <codeph>bitwise OR (|)</codeph>, qui modifient le comportement de tri. Les valeurs suivantes sont valides pour le paramètre <codeph>options</codeph> :
	 <ul>
	   <li><codeph>Array.CASEINSENSITIVE</codeph> ou 1</li>
	   <li><codeph>Array.DESCENDING</codeph> ou 2</li>
	   <li><codeph>Array.UNIQUESORT</codeph> ou 4</li>
	   <li><codeph>Array.RETURNINDEXEDARRAY</codeph> ou 8</li>
	   <li><codeph>Array.NUMERIC</codeph> ou 16.</li>
	 </ul>
     <p product="flash">Les conseils de code sont activés si vous utilisez le format chaîne de l’indicateur (par exemple, <codeph>DESCENDING</codeph>) au lieu du format numérique (2).</p>
   	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Trie les éléments d’un tableau selon un ou plusieurs champs du tableau. Le tableau doit être doté des caractéristiques suivantes :
	 <ul>
	   <li>Le tableau est indexé et non associatif.</li>
 	   <li>Chaque élément du tableau contient un objet doté d’une ou de plusieurs propriétés.</li>
	   <li>Tous les objets ont au moins une propriété en commun dont les valeurs peuvent être utilisées pour trier le tableau. Ce type de propriété est connu sous le nom de <i>field</i>.</li>
	 </ul>
	 <p>Si vous transmettez plusieurs paramètres <codeph>fieldName</codeph>, le premier champ représente le champ de tri principal, le deuxième représente le champ de tri suivant, etc. Flash trie selon les valeurs Unicode (ASCII est un sous-ensemble de Unicode). Si l’un des éléments comparés ne contient pas le champ spécifié dans le paramètre <codeph>fieldName</codeph>, le champ est considéré comme étant réglé sur <codeph>undefined</codeph> et les éléments sont placés de manière consécutive dans le tableau trié dans un ordre quelconque.</p>
 	 <p>Par défaut, <codeph>Array</codeph>.<codeph>sortOn()</codeph> fonctionne de la façon suivante :</p>
	 <ul>
	   <li>Le tri tient compte de la casse (<i>Z</i> précède <i>a</i>).</li>
	   <li>Le tri est ascendant (<i>a</i> précède <i>b</i>). </li>
	   <li>Le tableau est modifié afin de refléter l’ordre de tri ; les éléments multiples dont les champs de tri sont identiques sont placés consécutivement dans le tableau trié dans un ordre quelconque.</li>
	   <li>Les champs numériques sont triés comme s’il s’agissait de chaînes : ainsi, 100 précède 99 car « 1 » est une valeur de chaîne inférieure à « 9 ».</li>
	 </ul>
	 <p>Flash Player 7 a ajouté le paramètre <codeph>options</codeph>, que vous pouvez utiliser pour annuler le comportement de tri par défaut. Pour trier un tableau simple (par exemple, un tableau contenant un seul champ) ou pour spécifier un ordre de tri non pris en charge par le paramètre <codeph>options</codeph>, utilisez <codeph>Array.sort()</codeph>.</p>
 	 <p>Pour définir plusieurs indicateurs, séparez-les à l’aide de l’opérateur OR (<codeph>|</codeph>) au niveau du bit :</p>
	 <codeblock>
	 my_array.sortOn(someFieldName, Array.DESCENDING | Array.NUMERIC);
	 </codeblock>
	 <p>La fonctionnalité ajoutée à Flash Player 8 permet de spécifier une option de tri différente pour chaque champ lors d’un tri selon plusieurs champs. Dans Flash Player 8 et les versions ultérieures, le paramètre <codeph>options</codeph> accepte un tableau d’options de tri de telle sorte que chaque option de tri correspond à un champ de tri dans le paramètre <codeph>fieldName</codeph>. L’exemple suivant trie le champ de tri principal, <codeph>a</codeph>, selon un tri décroissant, le deuxième champ de tri, <codeph>b</codeph>, selon un tri numérique et le troisième champ de tri, <codeph>c</codeph>, selon un tri non sensible à la casse :</p>
	 <codeblock>
	 Array.sortOn (["a", "b", "c"], [Array.DESCENDING, Array.NUMERIC, Array.CASEINSENSITIVE]);
	 </codeblock>
	 <p><b>Remarque : </b>les tableaux <codeph>fieldName</codeph> et <codeph>options</codeph> doivent contenir le même nombre d’éléments ; sinon, le tableau <codeph>options</codeph> est ignoré. En outre, les options <codeph>Array.UNIQUESORT</codeph> et <codeph>Array.RETURNINDEXEDARRAY</codeph> ne peuvent être utilisées qu’en tant que premier élément du tableau, sinon elles sont ignorées.</p>
	 
	 </apiDesc><example conref="examples\Array.sortOn.1.as"> Le code suivant crée un objet Array vide, <codeph>vegetables</codeph>. Le tableau est ensuite rempli par cinq appels à la fonction <codeph>push()</codeph>. A chaque fois que <codeph>push()</codeph> est appelé, un nouvel objet <codeph>Vegetable</codeph> est créé par un appel au constructeur <codeph>Vegetable()</codeph>, qui accepte un objet de type chaîne (<codeph>name</codeph>) et un autre de type numérique (<codeph>price</codeph>). Cinq appels consécutifs de la fonction <codeph>push()</codeph> avec les valeurs indiquées produisent le tableau suivant : <codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>. La méthode <codeph>sortOn()</codeph> est ensuite utilisée avec le paramètre <codeph>name</codeph> pour produire le tableau suivant : <codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>. La méthode <codeph>sortOn()</codeph> est ensuite appelée à nouveau avec le paramètre price et les constantes NUMERIC et DESCENDING pour produire un tableau trié de façon numérique en ordre décroissant : <codeph>[asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29]</codeph>.
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sortOn("name");
trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

vegetables.sortOn("price", Array.NUMERIC | Array.DESCENDING);
trace(vegetables);
// asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29

class Vegetable {
    public var name:String;
    public var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sortOn.2.as"> Le code suivant crée un objet Array vide, <codeph>records</codeph>. Le tableau est ensuite rempli par trois appels à la fonction <codeph>push()</codeph>. Lorsque <codeph>push()</codeph> est appelé, les chaînes <codeph>name</codeph> et <codeph>city</codeph>, ainsi que le numéro <codeph>zip</codeph> sont ajoutés à <codeph>records</codeph>. Trois boucles <codeph>for</codeph> sont utilisées pour imprimer les éléments du tableau. La première boucle <codeph>for</codeph> imprime les éléments dans leur ordre d’insertion. La deuxième boucle <codeph>for</codeph> s’exécute après le tri de <codeph>records</codeph> en fonction de « name », puis de « city » à l’aide de la méthode <codeph>sortOn()</codeph>. La troisième boucle <codeph>for</codeph> a un résultat différent dans la mesure où <codeph>records</codeph> est trié de nouveau en fonction « city », puis « name ».
<codeblock>


var records:Array = new Array();
records.push({name:"john", city:"omaha", zip:68144});
records.push({name:"john", city:"kansas city", zip:72345});
records.push({name:"bob", city:"omaha", zip:94010});

for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, omaha
// john, kansas city
// bob, omaha

trace("records.sortOn('name', 'city');");
records.sortOn(["name", "city"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// bob, omaha
// john, kansas city
// john, omaha

trace("records.sortOn('city', 'name');");
records.sortOn(["city", "name"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, kansas city
// bob, omaha
// john, omaha
</codeblock></example><example conref="examples\Array.sortOn.3.as"> Le code suivant crée un objet Array vide, <codeph>users</codeph>. Le tableau est ensuite rempli par quatre appels à la fonction <codeph>push()</codeph>. Lorsque <codeph>push()</codeph> est appelée, un objet User est créé à l’aide du constructeur <codeph>User()</codeph>, puis la chaîne <codeph>name</codeph> et l’uint <codeph>age</codeph> sont ajoutés aux utilisateurs. Le tableau suivant en résulte <codeph>[Bob:3,barb:35,abcd:3,catchy:4]</codeph>.
 <p>Ce tableau est ensuite trié des façons suivantes :
 <ol>
   <li>Par nom uniquement, pour obtenir <codeph>[Bob:3,barb:35,abcd:3,catchy:4]</codeph>.</li>
   <li>Par nom uniquement et avec la constante <codeph>CASEINSENSITIVE</codeph>, pour obtenir le tableau <codeph>[abcd:3,barb:35,Bob:3,catchy:4]</codeph>.</li>
   <li>Par nom uniquement et avec les constantes <codeph>CASEINSENSITIVE</codeph> et <codeph>DESCENDING</codeph>, pour obtenir le tableau <codeph>[catchy:4,Bob:3,barb:35,abcd:3]</codeph>.</li>
   <li>Par nom uniquement, pour obtenir le tableau <codeph>[abcd:3,Bob:3,barb:35,catchy:4]</codeph>.</li>
   <li>Par nom uniquement et avec la constante <codeph>NUMERIC</codeph>, pour obtenir le tableau <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph>.</li>
   <li>Par nom uniquement et avec les constantes <codeph>CASEINSENSITIVE</codeph> et <codeph>NUMERIC</codeph>, pour obtenir le tableau <codeph>[barb:35,catchy:4,Bob:3,abcd:3]</codeph>.</li>
 </ol>
 </p>
 <p>Un tableau appelé <codeph>indices</codeph> est ensuite créé et reçoit les résultats du tri en fonction de l’âge et avec les constantes <codeph>NUMERIC</codeph> et <codeph>RETURNINDEXEDARRAY</codeph>, ce qui produit le tableau <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph>, qui est ensuite imprimé avec une boucle <codeph>for</codeph>.</p>
<codeblock>

class User {
    public var name:String;
    public var age:Number;
    public function User(name:String, age:uint) {
        this.name = name;
        this.age = age;
    }

    public function toString():String {
        return this.name + ":" + this.age;
    }
}

var users:Array = new Array();
users.push(new User("Bob", 3));
users.push(new User("barb", 35));
users.push(new User("abcd", 3));
users.push(new User("catchy", 4));

trace(users); // Bob:3,barb:35,abcd:3,catchy:4

users.sortOn("name");
trace(users); // Bob:3,abcd:3,barb:35,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE);
trace(users); // abcd:3,barb:35,Bob:3,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE | Array.DESCENDING);
trace(users); // catchy:4,Bob:3,barb:35,abcd:3

users.sortOn("age");
trace(users); // abcd:3,Bob:3,barb:35,catchy:4

users.sortOn("age", Array.NUMERIC);
trace(users); // Bob:3,abcd:3,catchy:4,barb:35

users.sortOn("age", Array.DESCENDING | Array.NUMERIC);
trace(users); // barb:35,catchy:4,Bob:3,abcd:3

var indices:Array = users.sortOn("age", Array.NUMERIC | Array.RETURNINDEXEDARRAY);
var index:uint;
for(var i:uint = 0; i &lt; indices.length; i++) {
    index = indices[i];
    trace(users[index].name, ": " + users[index].age);
}

// Results:
// Bob : 3
// abcd : 3
// catchy : 4
// barb : 35
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (OR au niveau du bit)</linktext></link><link href="#Array/sort()"><linktext>Array.sort()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:splice"><apiName>splice</apiName><shortdesc>
	 Ajoute et supprime des éléments dans un tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.splice, splice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Tableau contenant les éléments supprimés du tableau d’origine.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Entier spécifiant l’index de la position d’insertion ou de suppression de l’élément dans le tableau. Vous pouvez utiliser un entier négatif pour définir une position par rapport à la fin du tableau (par exemple, la valeur -1 représente le dernier élément du tableau).
	 </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier spécifiant le nombre d’éléments à supprimer. Ce nombre inclut l’élément spécifié dans le paramètre <codeph>startIndex</codeph>. Si vous ne spécifiez pas de valeur pour le paramètre <codeph>deleteCount</codeph>, la méthode supprime toutes les valeurs comprises entre l’élément <codeph>startIndex</codeph> et le dernier élément du tableau. Si la valeur est 0, aucun élément n’est supprimé. 	 
	 </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Liste facultative d’une ou de plusieurs valeurs séparées par une virgule à insérer dans le tableau à la position spécifiée par le paramètre <codeph>startIndex</codeph>. Si une valeur insérée est de type Array, le tableau est maintenu intact et inséré comme élément unique. Par exemple, si vous joignez un tableau de longueur trois à un autre tableau de longueur trois, le tableau qui en résulte ne comporte que quatre éléments. l’un des éléments est toutefois un tableau de longueur trois. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ajoute et supprime des éléments dans un tableau. Cette méthode modifie le tableau sans faire de copie.
	 <p><b>Remarque :</b> pour annuler cette méthode dans une sous-classe de Array, utilisez <codeph>...args</codeph> pour les paramètres, comme indiqué dans l’exemple ci-dessous :</p>
	 <pre>
	 public override function splice(...args) {
	   // your statements here
	 }
	 </pre>
	 </apiDesc><example conref="examples\Array.splice.1.as"> Le code suivant crée un objet Array, <codeph>vegetables</codeph>, avec les éléments suivants <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph>. La méthode <codeph>splice()</codeph> est ensuite appelée avec les paramètres 2 et 2, qui affecte <codeph>cilantro</codeph> et <codeph>onion</codeph> au tableau <codeph>spliced</codeph>. Le tableau <codeph>vegetables</codeph> contient ensuite <codeph>[spinach,green pepper,avocado]</codeph>. La méthode <codeph>splice()</codeph> est appelée une deuxième fois avec les paramètres 1, 0 et le tableau <codeph>spliced</codeph> pour affecter <codeph>[cilantro,onion]</codeph> en tant que deuxième élément dans <codeph>vegetables</codeph>.
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

var spliced:Array = vegetables.splice(2, 2);
trace(vegetables); // spinach,green pepper,avocado
trace(spliced);    // cilantro,onion

vegetables.splice(1, 0, spliced);
trace(vegetables); // spinach,cilantro,onion,green pepper,avocado

</codeblock></example><example conref="examples\Array.splice.2.as"> Vous pouvez alors constater que <codeph>cilantro</codeph> et <codeph>onion</codeph> renvoient des résultats qui laissent entendre que <codeph>vegetables</codeph> comporte 5 éléments, alors que cet objet n’en comporte que quatre (et le deuxième élément est en fait un tableau qui contient deux éléments). Pour ajouter <codeph>cilantro</codeph> et <codeph>onion</codeph> de façon individuelle, utilisez :
<codeblock>
 
var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");
 
 var spliced:Array = vegetables.splice(2, 2);
 trace(vegetables); // spinach,green pepper,avocado
 trace(spliced);    // cilantro,onion
 
 vegetables.splice(1, 0, "cilantro", "onion");
 trace(vegetables); // spinach,cilantro,onion,green pepper,avocado
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     Renvoie une chaîne représentant les éléments du tableau spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne d’éléments de tableau.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Renvoie une chaîne représentant les éléments du tableau spécifié. Chaque élément du tableau, de la position d’index 0 à la position d’index la plus élevée, est converti en chaîne concaténée et séparé par des virgules. Dans l’implémentation d’ActionScript 3.0, cette méthode renvoie la même valeur que la méthode <codeph>Array.toString()</codeph>.
   	 
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/toString()"><linktext>Array.toString()</linktext></link></related-links></apiOperation><apiOperation id="Array:toString"><apiName>toString</apiName><shortdesc>
	 Renvoie une chaîne représentant les éléments du tableau spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne d’éléments de tableau.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une chaîne représentant les éléments du tableau spécifié. Chaque élément du tableau, de la position d’index 0 à la position d’index la plus élevée, est converti en chaîne concaténée et séparé par des virgules. Pour spécifier un séparateur personnalisé, utilisez la méthode <codeph>Array.join()</codeph>.
   	 
	 
	 </apiDesc><example conref="examples\Array.toString.1.as"> Le code suivant crée un tableau, convertit les valeurs en chaînes, puis les stocke dans la variable <codeph>vegnums</codeph> du type de données String.

<codeblock>

var vegetables:Array = new Array();
vegetables.push(1);
vegetables.push(2);
vegetables.push(3);
vegetables.push(4);
vegetables.push(5);
var vegnums:String = vegetables.toString();
trace(vegnums+",6");
// 1,2,3,4,5,6
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Array/join()"><linktext>Array.join()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     Ajoute un ou plusieurs éléments au début d’un tableau et renvoie la nouvelle longueur du tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.unshift, unshift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Entier représentant la nouvelle longueur du tableau.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Un ou plusieurs nombres, éléments ou variables à insérer au début du tableau.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute un ou plusieurs éléments au début d’un tableau et renvoie la nouvelle longueur du tableau. Les autres éléments du tableau sont décalés de leur position d’origine, i, vers i+1.
	 
	 </apiDesc><example conref="examples\Array.unshift.1.as"> Le code suivant crée un objet Array vide, <codeph>names</codeph>. Les chaînes <codeph>Bill</codeph> et <codeph>Jeff</codeph> sont ajoutées à la méthode <codeph>push()</codeph>, puis les chaînes <codeph>Alfred</codeph> et <codeph>Kyle</codeph> sont ajoutées au début de ces <codeph>noms</codeph> au moyen de deux appels à la méthode <codeph>unshift()</codeph>.
<codeblock>

var names:Array = new Array();
names.push("Bill");
names.push("Jeff");

trace(names); // Bill,Jeff

names.unshift("Alfred");
names.unshift("Kyle");

trace(names); // Kyle,Alfred,Bill,Jeff
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link></related-links></apiOperation><apiValue id="Array:CASEINSENSITIVE"><apiName>CASEINSENSITIVE</apiName><shortdesc>
     Spécifie un tri sans respect de la casse pour les méthodes de tri de la classe Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F6
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie un tri sans respect de la casse pour les méthodes de tri de la classe Array. Vous pouvez utiliser cette constante pour le paramètre <codeph>options</codeph> de la méthode <codeph>sort()</codeph> ou <codeph>sortOn()</codeph>. 
	 <p>La valeur de cette constante est 1.</p>
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:DESCENDING"><apiName>DESCENDING</apiName><shortdesc>
     Spécifie un tri par ordre décroissant pour les méthodes de tri de la classe Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F7
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie un tri par ordre décroissant pour les méthodes de tri de la classe Array. Vous pouvez utiliser cette constante pour le paramètre <codeph>options</codeph> de la méthode <codeph>sort()</codeph> ou <codeph>sortOn()</codeph>. 
 	 <p>La valeur de cette constante est 2.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:NUMERIC"><apiName>NUMERIC</apiName><shortdesc>
     Spécifie un tri numérique (et non de type chaîne de caractères) pour les méthodes de tri de la classe Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F8
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>16</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie un tri numérique (et non de type chaîne de caractères) pour les méthodes de tri de la classe Array. Si vous incluez cette constante au paramètre <codeph>options</codeph>, les méthodes <codeph>sort()</codeph> et <codeph>sortOn()</codeph> sont obligées de trier les nombres en tant que valeurs numériques, et non en tant que chaînes de caractères numériques. Si vous ne spécifiez pas la constante <codeph>NUMERIC</codeph>, le tri traite chaque élément de tableau en tant que chaîne de caractères et donne les résultats selon l’ordre Unicode. 
 	 
     <p>Supposons par exemple que vous disposez du tableau de valeurs <codeph>[2005, 7, 35]</codeph>. Si la constante <codeph>NUMERIC</codeph> n’est <b>pas</b> incluse dans le paramètre <codeph>options</codeph>, le tableau trié correspond à <codeph>[2005, 35, 7]</codeph>, mais si la constante <codeph>NUMERIC</codeph> <b>est</b> incluse, le tableau trié correspond à <codeph>[7, 35, 2005]</codeph>. </p>
 	 
 	 <p>Cette constante s’applique uniquement aux nombres contenus dans le tableau ; elle ne s’applique pas aux chaînes qui contiennent des données numériques telles que <codeph>["23", "5"]</codeph>.</p>
 	 
 	 <p>La valeur de cette constante est 16.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:RETURNINDEXEDARRAY"><apiName>RETURNINDEXEDARRAY</apiName><shortdesc>
	 Spécifie que le tri renvoie un tableau composé d’index de tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F9
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie que le tri renvoie un tableau composé d’index de tableau. Vous pouvez utiliser cette constante dans le paramètre <codeph>options</codeph> de la méthode <codeph>sort()</codeph> ou <codeph>sortOn()</codeph>, afin de disposer de plusieurs vues des éléments du tableau sans modifier le tableau d’origine. 
 	 <p>La valeur de cette constante est 8.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:UNIQUESORT"><apiName>UNIQUESORT</apiName><shortdesc>
     Spécifie le critère de tri unique pour les méthodes de tri de la classe Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217FA
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie le critère de tri unique pour les méthodes de tri de la classe Array. Vous pouvez utiliser cette constante pour le paramètre <codeph>options</codeph> de la méthode <codeph>sort()</codeph> ou <codeph>sortOn()</codeph>. L’option de tri unique met fin au tri si deux éléments ou champs triés ont des valeurs identiques. 
	 <p>La valeur de cette constante est 4.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:length:get"><apiName>length</apiName><shortdesc>
	 Entier non négatif spécifiant le nombre d’éléments contenus dans le tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Entier non négatif spécifiant le nombre d’éléments contenus dans le tableau. Cette propriété est automatiquement mise à jour lorsque vous ajoutez de nouveaux éléments dans le tableau. Lorsque vous affectez une valeur à un élément de tableau (par exemple, <codeph>my_array[index] = value</codeph>), si <codeph>index</codeph> est un nombre et si <codeph>index+1</codeph> est supérieur à la propriété <codeph>length</codeph>, la propriété <codeph>length</codeph> est mise à jour et définie sur la valeur <codeph>index+1</codeph>.
   	 <p><b>Remarque : </b>si vous affectez une valeur plus courte que la valeur existante à la propriété <codeph>length</codeph>, le tableau sera tronqué.</p>
   	 
	 </apiDesc><example conref="examples\Array.length.1.as"> Le code suivant crée un objet Array, <codeph>names</codeph>, avec l’élément de chaîne <codeph>Bill</codeph>. Il utilise ensuite la méthode <codeph>push()</codeph> pour ajouter un autre élément de chaîne, <codeph>Kyle</codeph>. La longueur de la chaîne, telle que déterminée par la propriété <codeph>length</codeph>, était d’un élément avant l’utilisation de <codeph>push()</codeph> et de deux éléments après l’appel de <codeph>push()</codeph>. Une autre chaîne, <codeph>Jeff</codeph>, est ensuite ajoutée pour porter la longueur de <codeph>names</codeph> à trois éléments. La méthode <codeph>shift()</codeph> est alors appelée deux fois pour supprimer <codeph>Bill</codeph> et <codeph>Kyle</codeph> et ne conserver ainsi que le dernier élément <codeph>length</codeph>.
<codeblock>

var names:Array = new Array("Bill");
names.push("Kyle");
trace(names.length); // 2

names.push("Jeff");
trace(names.length); // 3

names.shift();
names.shift();
trace(names.length); // 1
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:RegExp"><apiName>RegExp</apiName><shortdesc>
     
     La classe RegExp vous permet d’utiliser des expressions régulières, à savoir des modèles destinés à effectuer des recherches dans les chaînes et à remplacer du texte dans ces dernières.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp
     </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     
     La classe RegExp vous permet d’utiliser des expressions régulières, à savoir des modèles destinés à effectuer des recherches dans les chaînes et à remplacer du texte dans ces dernières.
     
     <p>Pour créer un objet RegExp, utilisez le constructeur <codeph>new RegExp()</codeph> ou affectez un littéral RegExp à une variable :</p>
     
     <codeblock> var pattern1:RegExp = new RegExp("test-\\d", "i");
     var pattern2:RegExp = /test-\d/i;
     </codeblock>
     
     <p>Pour plus d’informations, voir le chapitre « Utilisation d’expressions régulières » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
     </apiDesc><example conref="examples\RegExpExample.as"> L’exemple suivant indique comment utiliser des expressions régulières pour analyser des chaînes et renvoyer une nouvelle chaîne ou une valeur booléenne, en fonction de la chaîne transmise. La méthode <codeph>informalizeGreeting()</codeph> remplace simplement le mot <codeph>Hello</codeph> par <codeph>Hi</codeph>, quelle qu’en soit la casse. Elle sépare également le nom du prénom dans la chaîne (en supposant que le nom corresponde au modèle spécifié). Dans les méthodes <codeph>validateEmail()</codeph> et <codeph>validatePhoneNumber()</codeph>, la chaîne transmise est vérifiée pour vérifier si son modèle correspond bien à celui d’une adresse électronique valide ou celui d’un numéro de téléphone, puis les méthodes renvoient des valeurs booléennes en fonction des résultats. 
<codeblock>
package {
    import flash.display.Sprite;

    public class RegExpExample extends Sprite {        
        public function RegExpExample() {            
            var formalGreeting:String = "Hello, John Smith.";
            trace(informalizeGreeting(formalGreeting));    // Hi, John.

            var validEmail:String = "name@domain.com";
            trace(validateEmail(validEmail));        // true
            
            var invalidEmail:String = "foo";
            trace(validateEmail(invalidEmail));  // false
            
            var validPhoneNumber:String = "415-555-1212";
            trace(validatePhoneNumber(validPhoneNumber));    // true
            
            var invalidPhoneNumber:String = "312-867-530999";
            trace(validatePhoneNumber(invalidPhoneNumber));  // false
        }
        private function informalizeGreeting(str:String):String {
            var pattern:RegExp = new RegExp("hello, (\\w+) \\w+", "i");
            return str.replace(pattern, "Hi, $1");
        }
        private function validateEmail(str:String):Boolean {
            var pattern:RegExp = /(\w|[_.\-])+@((\w|-)+\.)+\w{2,4}+/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
        private function validatePhoneNumber(str:String):Boolean {
            var pattern:RegExp = /^\d{3}-\d{3}-\d{4}$/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/replace()"><linktext>String.replace()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links><apiConstructor id="RegExp:RegExp"><apiName>RegExp</apiName><shortdesc>
        Vous permet de générer une expression régulière à partir de deux chaînes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.attribute, attribute
        </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>re</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Modèle de l’expression régulière (également appelée <i>chaîne du constructeur</i>). Il s’agit de la partie principale de l’expression régulière, à savoir la partie associée aux caractères « / »). 
        
        <p><b>Remarques :</b> </p>
        
        <ul>
        
        <li>N’incluez pas les caractères « / » de début et de fin. N’utilisez ceux-ci que lorsque vous définissez un littéral d’expression régulière sans utiliser de constructeur. Par exemple, les deux expressions régulières suivantes sont équivalentes :
        
        <codeblock> var re1:RegExp = new RegExp("bob", "i"); 
        var re2:RegExp = /bob/i;</codeblock>
        
        </li>
        
        <li>Dans une expression régulière définie à l’aide de la méthode constructeur <codeph>RegExp()</codeph>, tapez deux fois le caractère barre oblique inversée (\) pour utiliser une métaséquence débutant par le caractère barre oblique inversée, telle que <codeph>\d</codeph> (qui remplace n’importe quel chiffre). Par exemple, les deux expressions régulières suivantes sont équivalentes :
        
        <codeblock> var re1:RegExp = new RegExp("\\d+", ""); 
        var re2:RegExp = /\d/;</codeblock>
        
        <p>Dans la première expression, vous devez taper deux fois le caractère barre oblique inversée, car le premier paramètre de la méthode constructeur <codeph>RegExp() </codeph>est une chaîne. Dans un littéral de chaîne, ce caractère doit être entré deux fois pour être interprété comme une barre oblique inversée unique.</p>
        
        </li>
        
        </ul>
        
        </apiDesc></apiParam><apiParam><apiItemName>flags</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Les modificateurs de l’expression régulière, parmi lesquels figurent :
        
        <ul>
        
           <li> <codeph>g</codeph>  Lorsque la méthode <codeph>replace()</codeph> de la classe String est utilisée, spécifiez ce modificateur pour remplacer toutes les correspondances, plutôt que la première uniquement. Ce modificateur correspond à la propriété <codeph>global</codeph> de l’occurrence de RegExp.</li>
           <li> <codeph>i</codeph>  L’expression régulière est évaluée <i>sans</i> respect de la casse. Ce modificateur correspond à la propriété <codeph>ignoreCase</codeph> de l’occurrence de RegExp.</li>
           <li> <codeph>s</codeph>  Caractère point (<codeph>.</codeph>) correspond aux caractères de nouvelle ligne. Remarque : ce modificateur correspond à la propriété <codeph>dotall</codeph> de l’occurrence de RegExp.</li>
           <li> <codeph>m</codeph>  Le caractère circonflexe (<codeph>^</codeph>) et le symbole du dollar (<codeph>$</codeph>) établissent une correspondance avant <i>et</i> après les caractères de nouvelle ligne. Ce modificateur correspond à la propriété <codeph>multiline</codeph> de l’occurrence de RegExp.</li>
           <li> <codeph>x</codeph>  Les caractères d’espace blanc de la chaîne <codeph>re</codeph> sont ignorés, afin de vous permettre d’écrire des constructeurs plus lisibles. Ce modificateur correspond à la propriété <codeph>extended</codeph> de l’occurrence de RegExp.</li>
        
        </ul>
        
        <p>Aucun autre caractère de la chaîne <codeph>flags</codeph> n’est pris en compte. </p>
        
        </apiDesc></apiParam></apiConstructorDef><apiDesc>
        Vous permet de générer une expression régulière à partir de deux chaînes. La première définit le modèle de l’expression régulière, tandis que la seconde définit les indicateurs utilisés dans l’expression régulière. 
        
        </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="RegExp:AS3:exec"><apiName>exec</apiName><shortdesc>
         Recherche l’expression régulière dans la chaîne str indiquée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.exec, exec
         </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>null</codeph> si aucune correspondance n’est détectée, un objet aux propriétés suivantes dans le cas contraire : 
         
         <ul>
         
          <li>Un tableau dont l’élément 0 contient la sous-chaîne correspondante entière, et les autres éléments du tableau (compris entre 1 et <i>n</i>) contiennent des sous-chaînes correspondant aux groupes entre parenthèses de l’expression régulière. </li>
         
          <li><codeph>index</codeph>  Position des caractères de la sous-chaîne correspondante au sein de la chaîne</li>
         
          <li><codeph>input</codeph>  Chaîne (<codeph>str</codeph>)</li>
         
         </ul>
         
         
         </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à rechercher.  
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Recherche l’expression régulière dans la chaîne <codeph>str</codeph> indiquée. 
         
         <p>Si l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) n’est <i>pas</i> défini pour l’expression régulière, la recherche débute au début de la chaîne (position d’index 0) et ignore la propriété <codeph>lastIndex</codeph> de l’expression régulière.</p>
         
         <p>Si l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) <i>est</i> défini pour l’expression régulière, la recherche débute à la position d’index spécifiée par la propriété <codeph>lastIndex</codeph> de l’expression régulière. Si la recherche correspond à une sous-chaîne, la propriété <codeph>lastIndex</codeph> est modifiée pour indiquer la position de la fin de la correspondance. </p>
         
         </apiDesc><example>Lorsque l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) n’est <i>pas</i> défini dans l’expression régulière, vous pouvez utiliser <codeph>exec()</codeph> pour rechercher dans la chaîne la première correspondance : 
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;   
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         trace(result);
         </codeblock>
         
         <p> L’objet <codeph>result</codeph> est défini comme suit :</p>
         
         <ul>
         
          <li> <codeph>result[0]</codeph> est défini sur <codeph>"She"</codeph> (correspondance exacte). </li>
         
          <li> <codeph>result[1]</codeph> est défini sur une chaîne vide (premier groupe entre parenthèses correspondant). </li>
         
          <li> <codeph>result[2]</codeph> est réglé sur <codeph>"e"</codeph> (second groupe entre parenthèses correspondant). </li>
         
          <li> <codeph>result.index</codeph> est défini sur 0.</li>
         
          <li> <codeph>result.input</codeph> est défini sur la chaîne d’entrée : <codeph>"She sells seashells by the seashore"</codeph>.</li>
         
         </ul> 
         
         
         
         <p> Dans l’exemple suivant, l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) <i>étant</i> défini dans l’expression régulière, vous pouvez utiliser <codeph>exec()</codeph> à plusieurs reprises pour trouver les correspondances multiples :</p>
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;  
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         
         while (result != null) {
             trace ( result.index, "\t", result);
             result = myPattern.exec(str);
         }
         </codeblock>
         
         <p> Le résultat du code est le suivant :</p>
         
         <pre><codeph>
            0      She,,e
            10     seashells,sea,ells
            27     seashore,sea,ore
         </codeph></pre>
         
         </example></apiOperationDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links></apiOperation><apiOperation id="RegExp:AS3:test"><apiName>test</apiName><shortdesc>
         Recherche la correspondance de l’expression régulière dans la chaîne str indiquée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.test, test
          
          </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si une correspondance est détectée, <codeph>false</codeph> dans le cas contraire.
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à tester.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Recherche la correspondance de l’expression régulière dans la chaîne <codeph>str</codeph> indiquée. 
         
         <p>Si l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) n’est <i>pas</i> défini pour l’expression régulière, la recherche débute au début de la chaîne (position d’index 0) et ignore la propriété <codeph>lastIndex</codeph> de l’expression régulière.</p>
         
         <p>Si l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) <i>est</i> défini pour l’expression régulière, la recherche débute à la position d’index spécifiée par la propriété <codeph>lastIndex</codeph> de l’expression régulière. Si la recherche correspond à une sous-chaîne, la propriété <codeph>lastIndex</codeph> est modifiée pour indiquer la position de la fin de la correspondance. </p>
         
         </apiDesc><example conref="examples\RegExp.test.1.as"> L’exemple suivant indique comment utiliser la méthode <codeph>test()</codeph> sur une expression régulière où l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) est défini : 
<codeblock>
var re1:RegExp = /\w/g;
var str:String = "a b c";
trace (re1.lastIndex); // 0
trace (re1.test(str)); // true
trace (re1.lastIndex); // 1
trace (re1.test(str)); // true
trace (re1.lastIndex); // 3
trace (re1.test(str)); // true
trace (re1.lastIndex); // 5
trace (re1.test(str)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="RegExp:dotall:get"><apiName>dotall</apiName><shortdesc>
         Spécifie si le caractère point (.) d’un modèle d’expression régulière correspond à des caractères de nouvelle ligne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.dotall, dotall
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Spécifie si le caractère point (.) d’un modèle d’expression régulière correspond à des caractères de nouvelle ligne. Utilisez l’indicateur <codeph>s</codeph> lorsque vous générez une expression régulière pour définir <codeph>dotall = true</codeph>.
         
         </apiDesc><example conref="examples\RegExp.dotall.1.as"> L’exemple suivant indique l’effet de l’indicateur <codeph>s</codeph> (<codeph>dotall</codeph>) sur une expression régulière : 
<codeblock>
var str:String = "&lt;p>Hello\n"
        + "again&lt;/p>"
        + "&lt;p>Hello&lt;/p>";

var pattern:RegExp = /&lt;p>.*?&lt;\/p>/;
trace(pattern.dotall) // false
trace(pattern.exec(str)); // &lt;p>Hello&lt;/p>

pattern = /&lt;p>.*?&lt;\/p>/s;
trace(pattern.dotall) // true
trace(pattern.exec(str)); 
   </codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:extended:get"><apiName>extended</apiName><shortdesc>
         Indique si le mode étendu est activé pour l’expression régulière.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.extended, extended
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Indique si le mode étendu est activé pour l’expression régulière. Si un objet RegExp est en mode étendu, les caractères d’espace blanc que contient la chaîne du constructeur sont ignorés. Les constructeurs sont ainsi plus lisibles.
         
         <p>Utilisez l’indicateur <codeph>x</codeph> lorsque vous générez une expression régulière pour définir <codeph>extended = true</codeph>. </p>
         
         </apiDesc><example conref="examples\RegExp.extended.1.as"> L’exemple suivant présente différentes façons de construire la même expression régulière. Pour chaque façon, l’expression régulière doit correspondre au modèle de numéro de téléphone xxx-xxx-xxxx ou (xxx) xxx-xxxx ou (xxx)xxx-xxxx. La deuxième expression régulière utilise l’indicateur <codeph>x</codeph>, ce qui permet d’ignorer les espaces blancs de la chaîne. 
<codeblock>
var rePhonePattern1:RegExp = /\d{3}-\d{3}-\d{4}|\(\d{3}\)\s?\d{3}-\d{4}/; 
var str:String = "The phone number is (415)555-1212.";

trace(rePhonePattern1.extended) // false
trace(rePhonePattern1.exec(str)); // (415)555-1212

var rePhonePattern2:RegExp = / \d{3}-\d{3}-\d{4}  |   \( \d{3} \) \ ? \d{3}-\d{4}  /x; 
trace(rePhonePattern2.extended) // true
trace(rePhonePattern2.exec(str)); // (415)555-1212
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:global:get"><apiName>global</apiName><shortdesc>
         Indique si la mise en correspondance globale est activée pour l’expression régulière.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.global, global
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Indique si la mise en correspondance globale est activée pour l’expression régulière. Lorsque <codeph>global == true</codeph>, la propriété <codeph>lastIndex</codeph> est définie après détection d’une correspondance. Lors de la demande suivante de correspondance, le moteur de l’expression régulière démarre à partir de la position <codeph>lastIndex</codeph> dans la chaîne. Utilisez l’indicateur <codeph>g</codeph> lorsque vous générez une expression régulière pour régler <codeph>global</codeph> sur <codeph>true</codeph>. 
         
         </apiDesc><example conref="examples\RegExp.global.1.as"> L’exemple suivant indique l’effet de l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) sur la méthode <codeph>exec()</codeph> :
<codeblock>
var pattern:RegExp = /foo\d/; 
var str:String = "foo1 foo2";
trace(pattern.global); // false
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 0
trace(pattern.exec(str)); // foo1

pattern = /foo\d/g;
trace(pattern.global); // true
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 4
trace(pattern.exec(str)); // foo2
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:ignoreCase:get"><apiName>ignoreCase</apiName><shortdesc>
         Indique si l’expression régulière prend ou non en charge la casse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.ignoreCase, ignoreCase
         </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Indique si l’expression régulière prend ou non en charge la casse. Utilisez l’indicateur <codeph>i</codeph> lorsque vous générez une expression régulière pour définir <codeph>ignoreCase = true</codeph>. 
         
         </apiDesc><example conref="examples\RegExp.ignoreCase.1.as"> L’exemple suivant indique l’effet de la définition de l’indicateur <codeph>i</codeph> (<codeph>ignoreCase</codeph>) :
<codeblock>
var pattern:RegExp = /bob/; 
var str:String = "Bob bob";
trace(pattern.ignoreCase); // false
trace(pattern.exec(str)); // bob

pattern = /bob/i;
trace(pattern.ignoreCase); // true
trace(pattern.exec(str)); // Bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:lastIndex:get"><apiName>lastIndex</apiName><shortdesc>
         Spécifie la position d’index où démarrer la recherche suivante dans la chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.lastIndex, lastIndex
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
         Spécifie la position d’index où démarrer la recherche suivante dans la chaîne. Cette propriété affecte les méthodes <codeph>exec()</codeph> et <codeph>test()</codeph> de la classe RegExp. Toutefois, les méthodes <codeph>match()</codeph>, <codeph>replace()</codeph> et <codeph>search()</codeph> de la classe String ignorent la propriété <codeph>lastIndex</codeph> et démarrent toutes les recherches au début de la chaîne.
         
         <p>Si la méthode <codeph>exec()</codeph> ou <codeph>test()</codeph> trouve une correspondance et que l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) est réglé sur <codeph>true</codeph> pour l’expression régulière, elle règle automatiquement la propriété <codeph>lastIndex</codeph> sur la position d’index du caractère qui <i>after</i> le dernier caractère de la sous-chaîne correspondante de la dernière correspondance. Si l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) est réglé sur <codeph>false</codeph>, la méthode ne définit pas la propriété <codeph>lastIndex</codeph>.</p>
         
         <p>Vous pouvez définir la propriété <codeph>lastIndex</codeph> de sorte à ajuster la position de début dans la chaîne pour la mise en correspondance des expressions régulières. </p>
         
         </apiDesc><example conref="examples\RegExp.lastIndex.1.as"> L’exemple suivant indique l’effet de la définition de la propriété <codeph>lastIndex</codeph> et indique comment elle est mise à jour après un appel à la méthode <codeph>exec()</codeph> sur une expression régulière où l’indicateur <codeph>g</codeph> (<codeph>global</codeph>) est défini :
<codeblock>
var pattern:RegExp = /\w\d/g; 
var str:String = "a1 b2 c3 d4";
pattern.lastIndex = 2; 
trace(pattern.exec(str)); // b2
trace(pattern.lastIndex); // 5
trace(pattern.exec(str)); // c3
trace(pattern.lastIndex); // 8
trace(pattern.exec(str)); // d4
trace(pattern.lastIndex); // 11
trace(pattern.exec(str)); // null
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:multiline:get"><apiName>multiline</apiName><shortdesc>
         Spécifie si l’indicateur m (multiline) est défini.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.multiline, multiline
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Spécifie si l’indicateur <codeph>m</codeph> (<codeph>multiline</codeph>) est défini. S’il est défini, le caractère circonflexe (<codeph>^</codeph>) et le symbole du dollar (<codeph>$</codeph>) établissent une correspondance avant et après les caractères de nouvelle ligne dans une expression régulière. Utilisez l’indicateur <codeph>m</codeph> lorsque vous générez une expression régulière pour définir <codeph>multiline = true</codeph>.
         
         </apiDesc><example conref="examples\RegExp.multiline.1.as"> L’exemple suivant indique l’effet de la définition de l’indicateur <codeph>m</codeph> (<codeph>multiline</codeph>) :
<codeblock>
var pattern:RegExp = /^bob/; 
var str:String = "foo\n"
                + "bob";
trace(pattern.multiline); // false
trace(pattern.exec(str)); // null

pattern = /^bob/m;
trace(pattern.multiline); // true
trace(pattern.exec(str)); // bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:source:get"><apiName>source</apiName><shortdesc>
         Spécifie la partie modèle de l’expression régulière.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.source, source
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Spécifie la partie modèle de l’expression régulière.
         
         </apiDesc><example conref="examples\RegExp.source.1.as"> Le code suivant renvoie le paramètre <codeph>source</codeph> de deux expressions régulières :
<codeblock>
var re1:RegExp = /aabb/gi;
trace (re1.source); // aabb

var re2:RegExp = new RegExp("x+y*", "i");
trace(re2.source); // x+y*
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Date"><apiName>Date</apiName><shortdesc>
 La classe Date représente des informations relatives à la date et à l’heure.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Date object, built-in class, date 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Date représente des informations relatives à la date et à l’heure. Une occurrence de la classe Date représente un moment spécifique par rapport auquel vous pouvez interroger ou modifier des propriétés telles que le mois, le jour, l’heure et les secondes. La classe Date vous permet d’extraire des valeurs de date et d’heure relatives à l’heure universelle (GMT, désormais appelée heure universelle ou UTC) ou à l’heure locale, déterminée par le paramètre de fuseau horaire activé dans le système d’exploitation sur lequel Flash Player s’exécute. Les méthodes de la classe Date ne sont pas statiques mais s’appliquent uniquement au seul objet Date spécifié lorsque la méthode est appelée. Les méthodes <codeph>Date.UTC()</codeph> et <codeph>Date.parse()</codeph> font exception à la règle et sont statiques.
 <p product="flash">La classe Date gère l’heure d’été différemment, en fonction du système d’exploitation et de la version de Flash Player. Flash Player 6 et les versions ultérieures gèrent l’heure d’été sur les systèmes d’exploitation suivants comme suit :</p>
 <ul product="flash">
 <li>Windows : l’objet Date ajuste automatiquement sa sortie pour l’heure d’été. L’objet Date détecte si l’heure d’été est définie selon les paramètres régionaux actuels, et si tel est le cas, détecte la date et les heures de transition de l’heure d’été standard. Toutefois, les dates de transition actuellement en vigueur sont appliquées aux dates passées et à venir : par conséquent, le décalage de l’heure d’été peut être calculé de manière incorrecte pour les dates passées lorsque les paramètres régionaux étaient définis sur différentes dates de transition.</li>
 <li>Mac OS X : l’objet Date ajuste automatiquement sa sortie pour l’heure d’été. La base de données d’informations sur le fuseau horaire dans Mac OS X est utilisée pour déterminer si un décalage d’heure d’été doit être appliqué à une date ou heure actuelle ou passée.</li>
 <li>Mac OS 9 : le système d’exploitation fournit uniquement les informations suffisantes pour déterminer s’il convient d’appliquer un décalage d’heure d’été à la date et l’heure actuelles. En conséquence, l’objet de date suppose que le décalage d’heure d’été actuel s’applique à toutes les dates et heures passées ou à venir.</li>
 </ul>
 <p product="flash">Flash Player 5 gère l’heure d’été sur les systèmes d’exploitation suivants comme suit :</p>
 <ul product="flash">
 <li>Windows : les règles en vigueur aux Etats-Unis concernant l’heure d’été sont toujours appliquées, ce qui entraîne des transitions incorrectes en Europe et dans les autres zones qui adoptent l’heure d’été, mais ayant des heures de transition différentes de celles en vigueur aux Etats-Unis. Flash détecte correctement si l’heure d’été est utilisée dans les paramètres régionaux actuels.</li>
 </ul>
 <p>Pour utiliser la classe Date, construisez une occurrence de Date à l’aide de l’opérateur <codeph>new</codeph>.</p>
 <p>ActionScript 3.0 intègre plusieurs nouvelles propriétés accesseur que vous pouvez substituer à de nombreuses méthodes de la classe Date qui accèdent à des occurrences de Date ou les modifient. ActionScript 3.0 inclut également plusieurs nouvelles variations de la méthode <codeph>toString()</codeph> qui sont incluses pour des raisons de conformité avec la troisième édition de ECMA-262, ce qui inclut : <codeph>Date.toLocaleString()</codeph>, <codeph>Date.toTimeString()</codeph>, <codeph>Date.toLocaleTimeString()</codeph>, <codeph>Date.toDateString()</codeph> et <codeph>Date.toLocaleDateString()</codeph>.</p>
 <p>Pour calculer l’heure relative ou le temps écoulé, voir la méthode <codeph>getTimer()</codeph>, qui figure dans le package flash.utils.</p>
 
 </apiDesc><example conref="examples\DateExample.as"> L’exemple suivant présente différentes utilisations du constructeur <codeph>Date()</codeph> pour affecter les variables suivantes :
 <ul>
   <li><codeph>myDate1</codeph> appelle <codeph>Date()</codeph> sans paramètres, ce qui définit <codeph>myDate1</codeph> sur la date et l’heure actuelle (en fonction de la date et de l’heure de votre système). </li>
   <li><codeph>myDate2</codeph> appelle <codeph>Date()</codeph> avec les paramètres <codeph>year</codeph> (<codeph>2000</codeph>), month (<codeph>0</codeph> = January) et <codeph>day</codeph> (<codeph>1</codeph>) transmis à cette fonction.</li>
   <li><codeph>myDate3</codeph> appelle <codeph>Date()</codeph> avec <codeph>year</codeph> (<codeph>65</codeph> = 1965), <codeph>month</codeph> (<codeph>2</codeph> = March), <codeph>day</codeph> (<codeph>6</codeph>), <codeph>hour</codeph> (<codeph>9</codeph>), <codeph>minute</codeph> (<codeph>30</codeph>), <codeph>second</codeph> (<codeph>15</codeph>) et <codeph>millisecond</codeph>-+ (<codeph>0</codeph>) transmis en tant que paramètres.</li>
   <li><codeph>myDate4</codeph> appelle <codeph>Date()</codeph> où la valeur horaire représente le nombre de millisecondes <b>avant</b> (dans la mesure où la valeur est négative) 0:00:00 GMT 1 janvier 1970.</li>
 </ul>
<codeblock>

package {
    import flash.display.Sprite;
    
    public class DateExample extends Sprite{
        public function DateExample() {
            var myDate1:Date = new Date();
            trace(myDate1); // [NOW]

            var myDate2:Date = new Date(2000, 0, 1);
            trace(myDate2); // Sat Jan 1 00:00:00 GMT-0800 2000

            var myDate3:Date = new Date(65, 2, 6, 9, 30, 15, 0);
            trace(myDate3); // Sat Mar 6 09:30:15 GMT-0800 1965

            var myDate4:Date = new Date(-14159025000);
            trace(myDate4); // Sun Jul 20 19:56:15 GMT-0700 1969
        }        
    }    
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#/getTimer()"><linktext>flash.utils.getTimer()</linktext></link></related-links><apiConstructor id="Date:Date"><apiName>Date</apiName><shortdesc>
	 Construit un nouvel objet Date qui contient la date et l’heure spécifiées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new Date, constructor, date
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>yearOrTimevalue</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Si d’autres paramètres sont spécifiés, ce nombre représente une année (telle que 1965) ; sinon, il représente une valeur horaire. Si le nombre représente une année, une valeur comprise entre 0 et 99 renvoie à une année comprise entre 1900 et 1999 ; sinon les quatre chiffres de l’année doivent être spécifiés. Si le nombre représente une valeur horaire (aucun autre paramètre n’est spécifié), il s’agit du nombre de millisecondes écoulées avant ou après le premier janvier 1970 à minuit GMT ; une valeur négative représente une heure <i>antérieure</i> au premier janvier 1970 à minuit GMT ; une valeur positive représente une heure postérieure à cette date.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (janvier) et 11 (décembre).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Entier compris entre 1 et 31. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 (minuit) et 23 (23h00).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 et 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 et 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 et 999 millisecondes. 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Construit un nouvel objet Date qui contient la date et l’heure spécifiées.  
	 
	 <p>Le constructeur <codeph>Date()</codeph> accepte jusqu’à sept paramètres (year, month,..., millisecond) pour spécifier une date et une heure en millisecondes. La date indiquée dans le nouvel objet Date varie selon le nombre et le type des arguments transmis. </p>
	 <ul>
	   <li>Si vous ne transmettez pas d’argument, la date et l’heure en cours sont affectées à l’objet Date.</li>
	   <li>Si vous transmettez un seul argument dont le type de données correspond à Number, l’objet Date utilise une valeur horaire basée sur le nombre de millisecondes depuis le premier janvier 1970 0:00:000 GMT, comme spécifié par l’argument.</li>
	   <li>Si vous transmettez un seul argument dont le type de données correspond à Number et que la chaîne comporte une date valide, l’objet Date contient une valeur horaire basée sur cette date.</li>
	   <li>Si vous transmettez au moins deux arguments, l’objet Date utilise une valeur horaire basée sur les valeurs d’argument transmises, qui représentent l’année, le mois, la date, l’heure, la minute, la seconde et les millisecondes.</li>
	 </ul>
	 <p>Si vous transmettez une chaîne au constructeur de la classe Date, la date peut être exprimée dans divers formats, mais doit inclure au moins le mois, la date et l’année. Par exemple, <codeph>Fév 1 2005</codeph> est valide, mais <codeph>Fév 2005</codeph> ne l’est pas. La liste suivante indique quelques formats valides :</p>
	 <ul>
	   <li>Jour Mois Date Heures:Minutes:Secondes GMT Année (exemple : « Mar Fév 1 00:00:00 GMT-0800 2005 », qui correspond à <codeph>toString()</codeph>),</li>
	   <li>Jour Mois Date Année Heures:Minutes:Secondes AM/PM (exemple, « Mar Fév 1 2005 12:00:00 AM », qui correspond à <codeph>toLocaleString()</codeph>),</li>
	   <li>Jour Mois Date Année (exemple : « Mar Fév 1 2005 », qui correspond à <codeph>toDateString()</codeph>),</li>
	   <li>Mois/Jour/Année (exemple : « 02/01/2005 »),</li>
	   <li>Mois/Année (exemple : « 02/2005 »).</li>
	 </ul>
	 </apiDesc></apiConstructorDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiConstructor><apiOperation id="Date:UTC"><apiName>UTC</apiName><shortdesc>
	 Renvoie le nombre de millisecondes écoulées entre le premier janvier 1970 à minuit, heure universelle, et l’heure spécifiée dans les paramètres.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.utc, utc, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nombre de millisecondes écoulées entre le premier janvier 1970 et la date et heure spécifiées.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier à quatre chiffres qui représente l’année (par exemple, 2000).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (janvier) et 11 (décembre).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Entier compris entre 1 et 31. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 (minuit) et 23 (23h00).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 et 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 et 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier compris entre 0 et 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie le nombre de millisecondes écoulées entre le premier janvier 1970 à minuit, heure universelle, et l’heure spécifiée dans les paramètres. Cette méthode utilise l’heure universelle, tandis que le constructeur <codeph>Date</codeph> utilise l’heure locale.
	 <p>Elle s’avère utile si vous voulez transmettre une date UTC au constructeur de la classe Date. Le constructeur de la classe Date acceptant l’intervalle exprimé en millisecondes en tant qu’argument, vous pouvez utiliser la méthode Date.UTC() pour convertir une date UTC en intervalle correspondant et transmettre cette valeur en tant qu’argument au constructeur de la classe Date :</p>
	 
	 </apiDesc><example conref="examples\Date.UTC.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>) à l’aide de l’heure locale. Ensuite, un appel à <codeph>UTC()</codeph> au sein d’une méthode <codeph>setTime()</codeph> réinitialise les mêmes paramètres sur le temps universel.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);
trace(someBirthday.toString());

someBirthday.setTime(Date.UTC(1974, 10, 30, 15, 20));
trace(someBirthday.toString());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getDate"><apiName>getDate</apiName><shortdesc>
	 Renvoie le jour du mois (entier compris entre 1 et 31) spécifié par un objet Date conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getdate, getdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Jour du mois (1 - 31) représenté par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie le jour du mois (entier compris entre 1 et 31) spécifié par un objet <codeph>Date</codeph> conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
 	 </apiDesc><example conref="examples\Date.getDate.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getDate()</codeph> est ensuite appelée afin d’extraire le jour du mois.
<codeblock>
package {
    import flash.display.Sprite;

    public class DateExample extends Sprite {

        public function DateExample() {
            var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
            trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
            trace(someBirthday.getDate()); // 30
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getDay"><apiName>getDay</apiName><shortdesc>
	 Renvoie le jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) spécifié par l’objet Date conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getday, getday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Version numérique du jour de la semaine (0 - 6) représenté par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie le jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) spécifié par l’objet <codeph>Date</codeph> conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
 	 </apiDesc><example conref="examples\Date.getDay.1.as"> L’exemple suivant crée un nouvel objet Array <codeph>weekDayLabels</codeph>, avec les éléments <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph> et un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getDay()</codeph> est ensuite appelée deux fois pour afficher le jour du mois dans un premier temps, 6, puis affiche le jour de la semaine à l’aide de <codeph>weekDayLabels</codeph>.
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                       // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDay());            // 6
trace(weekDayLabels[someBirthday.getDay()]); // Saturday
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getFullYear"><apiName>getFullYear</apiName><shortdesc>
	 Renvoie l’année entière (un nombre à quatre chiffres, tel que 2000) d’un objet Date conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getfullyear, getfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Année entière représentée par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie l’année entière (un nombre à quatre chiffres, tel que 2000) d’un objet <codeph>Date</codeph> conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.getFullYear.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getFullYear()</codeph> est ensuite appelée, afin d’extraire l’année au format à quatre chiffres.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getHours"><apiName>getHours</apiName><shortdesc>
	 Renvoie l’heure (entier compris entre 0 et 23) de la partie jour d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gethours, gethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Heure (0 -23) du jour représentée par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie l’heure (entier compris entre 0 et 23) de la partie jour d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute. 
	 
	 </apiDesc><example conref="examples\Date.getHours.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). Les méthodes <codeph>getHours()</codeph> et <codeph>getMinutes()</codeph> sont ensuite appelées, ce qui extrait les heures et les minutes au format à 24 heures. Enfin, la chaîne <codeph>localTime</codeph> est créée et est affectée au résultat d’un appel à la fonction <codeph>getUSClockTime()</codeph>, qui en retour appelle de nouveau <codeph>getHours()</codeph> et <codeph>getMinutes()</codeph>, ce qui donne l’heure <codeph>03:05 PM</codeph>.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMilliseconds"><apiName>getMilliseconds</apiName><shortdesc>
	 Renvoie la partie millisecondes (entier compris entre 0 et 999) d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmilliseconds, getmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie millisecondes d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la partie millisecondes (entier compris entre 0 et 999) d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.getMilliseconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getMilliseconds()</codeph> est ensuite appelée, ce qui extrait les millisecondes de l’objet Date à partir de l’heure de création de <codeph>now</codeph>.
<codeblock>

var now:Date = new Date();
trace(now.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMinutes"><apiName>getMinutes</apiName><shortdesc>
	 Renvoie la partie minutes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getminutes, getminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie minutes d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la partie minutes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.getMinutes.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getMinutes()</codeph> est ensuite appelée, ce qui extrait les minutes de l’objet Date à partir de l’heure de création de <codeph>now</codeph>.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMonth"><apiName>getMonth</apiName><shortdesc>
	 Renvoie la partie mois (0 pour janvier, 1 pour février, etc.) de l’objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmonth, getmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie mois (0 – 11) d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la partie mois (0 pour janvier, 1 pour février, etc.) de l’objet <codeph> Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.getMonth.1.as"> L’exemple suivant crée un nouvel objet Array, <codeph>monthLabels</codeph>, avec les éléments <codeph>January</codeph> à <codeph>December</codeph> et un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getMonth()</codeph> est ensuite appelée deux fois, ce qui renvoie le numéro du mois dans un premier temps, suivi par le nom du mois pendant lequel l’objet Date, <codeph>now</codeph>, a été créé.
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getSeconds"><apiName>getSeconds</apiName><shortdesc>
	 Renvoie la partie secondes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getseconds, getseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie secondes (0 – 59) d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la partie secondes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.getSeconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getSeconds()</codeph> est ensuite appelée, ce qui extrait les secondes à partir de l’heure de création de l’objet Date, <codeph>now</codeph>.
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTime"><apiName>getTime</apiName><shortdesc>
	 Renvoie le nombre de millisecondes écoulées depuis le premier janvier 1970 à minuit, heure universelle, pour un objet Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettime, gettime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nombre de millisecondes écoulées depuis le premier janvier 1970 représenté par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie le nombre de millisecondes écoulées depuis le premier janvier 1970 à minuit, heure universelle, pour un objet <codeph>Date</codeph>. Cette méthode permet de représenter un instant spécifique dans le temps lorsque vous comparez au moins deux objets <codeph>Date</codeph>.
	 
	 </apiDesc><example conref="examples\Date.getTime.1.as"> L’exemple suivant crée un objet Date, <codeph>mlk</codeph>, avec les paramètres <codeph>year</codeph> (<codeph>1929</codeph>), <codeph>month</codeph> (<codeph>0</codeph> = January) et <codeph>day</codeph> (<codeph>15</codeph>). La méthode <codeph>getTime()</codeph> est ensuite appelée, ce qui extrait les millisecondes à compter de minuit le premier janvier 1970, ce qui donne une valeur négative dans la mesure où l’année est définie sur 1929.
<codeblock>

var mlk:Date = new Date(1929, 0, 15);
trace(mlk);           // Tue Jan 15 00:00:00 GMT-0800 1929
trace(mlk.getTime()); // -1292601600000
</codeblock></example><example conref="examples\Date.getTime.2.as"> L’exemple suivant crée un objet Date, <codeph>now</codeph>, sans paramètres, puis utilise les méthodes de la classe DateMath suivante (créée ci-dessous) pour ajouter du temps à l’objet Date d’origine, <codeph>now</codeph>, à compter de son heure de création :
 <ul>
   <li><codeph>addSeconds()</codeph> : ajoute 30 secondes à <codeph>now</codeph>.</li>
   <li><codeph>addMinutes()</codeph> : ajoute 30 minutes à <codeph>now</codeph>.</li>
   <li><codeph>addHours()</codeph> : ajoute 6 heures à l’objet Date <codeph>now</codeph>.</li>
   <li><codeph>addDays()</codeph> : ajoute 30 jours à l’objet Date <codeph>now</codeph>.</li>
   <li><codeph>addWeeks()</codeph> : ajoute 4 semaines à <codeph>now</codeph>.</li>
 </ul>

<codeblock>

var now:Date = new Date();
trace(now);
trace(DateMath.addSeconds(now, 30));
trace(DateMath.addMinutes(now, 30));
trace(DateMath.addHours(now, 6));
trace(DateMath.addDays(now, 30));
trace(DateMath.addWeeks(now, 4));

class DateMath {
    public static function addWeeks(date:Date, weeks:Number):Date {
        return addDays(date, weeks*7);
    }

    public static function addDays(date:Date, days:Number):Date {
        return addHours(date, days*24);
    }

    public static function addHours(date:Date, hrs:Number):Date {
        return addMinutes(date, hrs*60);
    }

    public static function addMinutes(date:Date, mins:Number):Date {
        return addSeconds(date, mins*60);
    }

    public static function addSeconds(date:Date, secs:Number):Date {
        var mSecs:Number = secs * 1000;
        var sum:Number = mSecs + date.getTime();
        return new Date(sum);
    }
}
</codeblock> <b>Remarque</b> : il est important d’utiliser la méthode getTime lors des opérations arithmétiques sur les dates dans la mesure où cette fonction tient compte des années bissextiles et nécessite beaucoup moins de code que l’exemple suivant :
 <pre>
 function addMonths(num:Number):void {
     currentMonth = currentMonth + num;
     if(currentMonth > 12) {
         currentYear++;
         currentMonth = currentMonth - 12;
     }
 }
 </pre>
</example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTimezoneOffset"><apiName>getTimezoneOffset</apiName><shortdesc>
     Renvoie la différence, en minutes, entre le temps universel (UTC) et l’heure locale de l’ordinateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettimezoneoffset, gettimezoneoffset, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Les minutes que vous devez ajouter à l’heure locale de l’ordinateur pour obtenir l’heure UTC. Si votre ordinateur est en avance sur l’heure UTC, la valeur renvoyée est négative.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Renvoie la différence, en minutes, entre le temps universel (UTC) et l’heure locale de l’ordinateur. 
	 
	 </apiDesc><example conref="examples\Date.getTimezoneOffset.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getTimezoneOffset()</codeph> est ensuite appelée, qui extrait les différences (en minutes) entre l’heure de création de <codeph>now</codeph> et l’heure UTC. Le décalage horaire est ensuite converti en heures en divisant le résultat par 60.
<codeblock>

var date:Date = new Date();
trace(date.getTimezoneOffset() / 60);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCDate"><apiName>getUTCDate</apiName><shortdesc>
	 Renvoie le jour du mois (entier compris entre 1 et 31) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcdate, getutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Jour UTC du mois (compris entre 1 et 31) représenté par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie le jour du mois (entier compris entre 1 et 31) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCDate.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getUTCDate()</codeph> est ensuite appelée afin d’extraire le jour du mois, au format UTC.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);             // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCDay"><apiName>getUTCDay</apiName><shortdesc>
	 Renvoie le jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) de l’objet Date conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcday, getutcday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Jour UTC de la semaine (compris entre 0 et 6) représenté par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie le jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) de l’objet <codeph>Date </codeph> conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCDay.1.as"> L’exemple suivant crée un nouvel objet Array <codeph>weekDayLabels</codeph>, avec les éléments <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph> et un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getUTCDay()</codeph> est ensuite appelée deux fois pour afficher le jour du mois dans un premier temps, 6, puis affiche le jour de la semaine à l’aide de <codeph>weekDayLabels</codeph>.
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDay()); // 6
trace(weekDayLabels[someBirthday.getUTCDay()]); // Saturday
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCFullYear"><apiName>getUTCFullYear</apiName><shortdesc>
	 Renvoie l’année à quatre chiffres d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcfullyear, getutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Année UTC à quatre chiffres représentée par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie l’année à quatre chiffres d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCFullYear.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getUTCFullYear()</codeph> est ensuite appelée, afin d’extraire l’année au format à quatre chiffres, conformément au format UTC.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                 // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCHours"><apiName>getUTCHours</apiName><shortdesc>
	 Renvoie l’heure (entier compris entre 0 et 23) du jour d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutchours, getutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Heure UTC du jour (comprise entre 0 et 23) représentée par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie l’heure (entier compris entre 0 et 23) du jour d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCHours.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). Les méthodes <codeph>getHours()</codeph> et <codeph>getMinutes()</codeph> sont ensuite appelées, ce qui extrait les heures et les minutes au format à 24 heures. Enfin, la chaîne <codeph>localTime</codeph> est créée et est affectée au résultat d’un appel à la fonction <codeph>getUSClockTime()</codeph>, qui en retour appelle de nouveau <codeph>getHours()</codeph> et <codeph>getMinutes()</codeph>, ce qui donne l’heure <codeph>03:05 PM</codeph>. Enfin, la variable String <codeph>utcTime</codeph> est créée de la même manière que <codeph>localTime</codeph> et, dans ce cas, le résultat est identique.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

var utcTime:String = getUSClockTime(someBirthday.getUTCHours(), someBirthday.getUTCMinutes());
trace(utcTime);      // 11:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCMilliseconds"><apiName>getUTCMilliseconds</apiName><shortdesc>
	  Renvoie la partie millisecondes (entier compris entre 0 et 999) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmilliseconds, getutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie millisecondes UTC d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Renvoie la partie millisecondes (entier compris entre 0 et 999) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCMilliseconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCMilliseconds()</codeph> est ensuite appelée, ce qui extrait les millisecondes de l’heure de création de l’objet Date, <codeph>now</codeph>, conformément au format UTC.
<codeblock>

var now:Date = new Date();
trace(now.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMinutes"><apiName>getUTCMinutes</apiName><shortdesc>
	 Renvoie la partie minutes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcminutes, getutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie minutes UTC d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la partie minutes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCMinutes.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCMinutes()</codeph> est ensuite appelée, ce qui extrait les minutes de l’heure de création de l’objet Date, <codeph>now</codeph>, conformément au format UTC.
<codeblock>

var now:Date = new Date();
trace(now.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMonth"><apiName>getUTCMonth</apiName><shortdesc>
	 Renvoie la partie mois (0 [janvier] à 11 [décembre]) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmonth, getutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie mois UTC d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la partie mois (0 [janvier] à 11 [décembre]) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCMonth.1.as"> L’exemple suivant crée un nouvel objet Array, <codeph>monthLabels</codeph>, avec les éléments <codeph>January</codeph> à <codeph>December</codeph> et un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCMonth()</codeph> est ensuite appelée deux fois, ce qui renvoie le numéro du mois dans un premier temps, suivi par le nom du mois de création de l’objet Date, <codeph>now</codeph>, conformément au format UTC.
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(now.getUTCMonth());
trace(monthLabels[now.getUTCMonth()]);
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCSeconds"><apiName>getUTCSeconds</apiName><shortdesc>
	 Renvoie la partie secondes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcseconds, getutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Partie secondes UTC d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la partie secondes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCSeconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCSeconds()</codeph> est ensuite appelée, ce qui extrait les secondes de l’heure de création de l’objet Date, <codeph>now</codeph>, conformément au format UTC.
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:parse"><apiName>parse</apiName><shortdesc>
	 Convertit une chaîne qui représente une date en valeur numérique correspondant au nombre de millisecondes écoulées depuis le premier janvier 1970 (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Valeur numérique représentant le nombre de millisecondes écoulées depuis le premier janvier 1970 (UTC).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Représentation sous forme de chaîne d’une date, conformément au format de sortie de <codeph>Date.toString()</codeph>. Le format de date utilisé pour la sortie de <codeph>Date.toString()</codeph> est le suivant : 
     <pre>
     Day Mon DD HH:MM:SS TZD YYYY
     </pre>
     <p>Exemple : </p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
     <p>La désignation TZD (Time Zone Designation) prend toujours la forme <codeph>GMT-HHMM</codeph> ou <codeph>UTC-HHMM</codeph> et indique l’intervalle en heures et minutes relativement à Greenwich Mean Time (GMT), également appelé heure universelle (UTC). Les termes année, mois et jour peuvent être séparés par une barre oblique (<codeph>/</codeph>) ou un espace, mais jamais par un tiret (<codeph>-</codeph>). Les autres formats gérés sont indiqués ci-dessous. Vous pouvez utiliser des représentations partielles de ces formats (mois, jour et année uniquement) :</p>
     <pre>
     MM/DD/YYYY HH:MM:SS TZD
     HH:MM:SS TZD Day Mon/DD/YYYY 
     Mon DD YYYY HH:MM:SS TZD
     Day Mon DD HH:MM:SS TZD YYYY
     Day DD Mon HH:MM:SS TZD YYYY
     Mon/DD/YYYY HH:MM:SS TZD
     YYYY/MM/DD HH:MM:SS TZD
     </pre>
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit une chaîne qui représente une date en valeur numérique correspondant au nombre de millisecondes écoulées depuis le premier janvier 1970 (UTC).
	 
     </apiDesc><example conref="examples\Date.parse.1.as"> L’exemple suivant affecte une chaîne de date à <codeph>dateParsed</codeph> pour le 30 novembre 1974. La méthode <codeph>Date.parse()</codeph> est ensuite appelée, ce qui convertit la date en millisecondes depuis le premier janvier 1970.
<codeblock>
var dateParsed:String = "Sat Nov 30 1974";

var milliseconds:Number = Date.parse(dateParsed);
trace(milliseconds); // 155030400000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>Date.toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setDate"><apiName>setDate</apiName><shortdesc>
	 Définit le jour du mois, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setdate, setdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 1 et 31.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit le jour du mois, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.setDate.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getDate()</codeph> est ensuite appelée afin d’extraire le jour du mois. Ensuite la méthode <codeph>setDate()</codeph> est appelée avec le paramètre <codeph>day</codeph> défini sur <codeph>20</codeph>, puis la méthode <codeph>getDate()</codeph> est appelée de nouveau, ce qui extrait le jour du mois qui vient d’être défini.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDate()); // 30

someBirthday.setDate(20);
trace(someBirthday.getDate()); // 20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setFullYear"><apiName>setFullYear</apiName><shortdesc>
	 Définit l’année, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setfullyear, setfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à quatre chiffres spécifiant une année. Les nombres à deux chiffres ne représentent pas les années à quatre chiffres ; par exemple, 99 ne correspond pas à l’année 1999, mais à l’année 99.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (janvier) et 11 (décembre). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre compris entre 1 et 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit l’année, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes. Si les paramètres <codeph>month</codeph> et <codeph>date</codeph> sont spécifiés, ils sont définis sur l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 <p>
	 L’appel de cette méthode ne modifie pas les autres champs de l’objet <codeph>Date</codeph>, mais <codeph>Date.getUTCDay()</codeph> et <codeph>Date.getDay()</codeph> peuvent signaler une nouvelle valeur si le jour de la semaine change suite à l’appel de cette méthode.
	 </p>
	 
	 </apiDesc><example conref="examples\Date.setFullYear.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getFullYear()</codeph> est ensuite appelée, afin d’extraire l’année au format à quatre chiffres. Ensuite la méthode <codeph>setFullYear()</codeph> est appelée avec le paramètre <codeph>year</codeph> défini sur <codeph>2000</codeph>, puis la méthode <codeph>getFullYear()</codeph> est appelée de nouveau, ce qui extrait l’année qui vient d’être définie.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974

someBirthday.setFullYear(2000);
trace(someBirthday.getFullYear()); // 2000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setHours"><apiName>setHours</apiName><shortdesc>
	 Définit l’heure, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.sethours, sethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (minuit) et 23 (23h00).
     </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59. 
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59. 
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit l’heure, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.setHours.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). Les méthodes <codeph>getHours()</codeph> et <codeph>getMinutes()</codeph> sont ensuite appelées, ce qui extrait les heures et les minutes. Ensuite la méthode <codeph>setHours()</codeph> est appelée avec le paramètre <codeph>hour</codeph> défini sur <codeph>12</codeph>, puis les méthodes <codeph>getHours()</codeph> et <codeph>getMinutes()</codeph> sont appelées de nouveau, ce qui extrait les heures et les minutes qui viennent d’être définies.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:20

someBirthday.setHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMilliseconds"><apiName>setMilliseconds</apiName><shortdesc>
	 Définit les millisecondes, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmilliseconds, setmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les millisecondes, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.setMilliseconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getMilliseconds()</codeph> est ensuite appelée, ce qui extrait les millisecondes de l’heure de création de <codeph>now</codeph>. Ensuite, un autre nouvel objet Date, <codeph>before</codeph>, accompagné d’un appel supplémentaire à <codeph>setMilliseconds()</codeph> avec le paramètre <codeph>millisecond</codeph> défini sur <codeph>4</codeph>. La méthode <codeph>getMilliseconds()</codeph> est ensuite appelée de nouveau, ce qui extrait les millisecondes qui viennent d’être définies.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMilliseconds());

var before:Date = new Date(now.setMilliseconds(4));
trace(before);
trace(before.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMinutes"><apiName>setMinutes</apiName><shortdesc>
	 Définit les minutes, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setminutes, setminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59.
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59.
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les minutes, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.setMinutes.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getMinutes()</codeph> est ensuite appelée, ce qui extrait les minutes de l’heure de création de <codeph>now</codeph>. Ensuite, un autre nouvel objet Date, <codeph>before</codeph>, accompagné d’un appel supplémentaire à <codeph>setMinutes()</codeph> avec le paramètre <codeph>minute</codeph> défini sur <codeph>0</codeph>. La méthode <codeph>getMinutes()</codeph> est ensuite appelée de nouveau, ce qui extrait les minutes qui viennent d’être définies.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());

var before:Date = new Date(now.setMinutes(0));
trace(before);
trace(before.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMonth"><apiName>setMonth</apiName><shortdesc>
	 Définit le mois et éventuellement le jour du mois, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmonth, setmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (janvier) et 11 (décembre).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 1 et 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit le mois et éventuellement le jour du mois, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.setMonth.1.as"> L’exemple suivant crée un nouvel objet Array, <codeph>monthLabels</codeph>, avec les éléments <codeph>January</codeph> à <codeph>December</codeph> et un nouvel objet Month, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getMonth()</codeph> est ensuite appelée, ce qui extrait le mois pendant lequel <codeph>now</codeph> a été créé. Ensuite la méthode <codeph>setMonth()</codeph> est appelée avec le paramètre <codeph>month</codeph> défini sur <codeph>0</codeph>, puis la méthode <codeph>getMonth()</codeph> est appelée de nouveau, ce qui extrait le mois qui vient d’être défini..
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);

now.setMonth(0);
trace(now.getMonth());             // 0
trace(monthLabels[now.getMonth()]); // January
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setSeconds"><apiName>setSeconds</apiName><shortdesc>
	 Définit les secondes, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setseconds, setseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59.
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les secondes, conformément à l’heure locale, et renvoie la nouvelle heure en millisecondes. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc><example conref="examples\Date.setSeconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getseconds()</codeph> est ensuite appelée, ce qui extrait les secondes de l’heure de création de <codeph>now</codeph>. Ensuite la méthode <codeph>setSeconds()</codeph> est appelée avec le paramètre <codeph>second</codeph> défini sur <codeph>0</codeph>, puis la méthode <codeph>getSeconds()</codeph> est appelée de nouveau, ce qui extrait le mois qui vient d’être défini.
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());

now.setSeconds(0);
trace(now.getSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setTime"><apiName>setTime</apiName><shortdesc>
	 Définit la date en millisecondes écoulées depuis le premier janvier 1970 à minuit et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.settime, settime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier, 0 représentant minuit le premier janvier en heure universelle (UTC).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit la date en millisecondes écoulées depuis le premier janvier 1970 à minuit et renvoie la nouvelle heure en millisecondes. 
	 
	 </apiDesc><example conref="examples\Date.setTime.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>setTime()</codeph> est ensuite appelée, avec le paramètre <codeph>millisecond</codeph> défini sur <codeph>-1292601600000</codeph>, ce qui renvoie <codeph>Tue Jan 15 00:00:00 GMT-0800 1929</codeph>.
<codeblock>

var now:Date = new Date();
trace(now);

now.setTime(-1292601600000);
trace(now); // Tue Jan 15 00:00:00 GMT-0800 1929
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCDate"><apiName>setUTCDate</apiName><shortdesc>
	 Définit le jour du mois, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcdate, setutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre ; entier compris entre 1 et 31.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit le jour du mois, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes. L’appel de cette méthode ne modifie pas les autres champs de l’objet <codeph>Date </codeph>, mais les méthodes <codeph>Date.getUTCDay()</codeph> et <codeph>Date.getDay()</codeph> peuvent signaler une nouvelle valeur si le jour de la semaine change suite à l’appel de cette méthode.
	 
	 </apiDesc><example conref="examples\Date.setUTCDate.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getUTCDate()</codeph> est appelée et renvoie correctement le jour du mois. Ensuite, <codeph>setUTCDate()</codeph> est appelé avec le paramètre <codeph>day</codeph> défini sur <codeph>1</codeph> et une instruction <codeph>trace()</codeph> confirme que la date a été correctement définie.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30

someBirthday.setUTCDate(1);
trace(someBirthday); // Fri Nov 1 01:20:00 GMT-0800 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCFullYear"><apiName>setUTCFullYear</apiName><shortdesc>
	 Définit l’année, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcfullyear, setutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Entier.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier représentant l’année spécifiée en tant qu’année entière à quatre chiffres, telle que 2000.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (janvier) et 11 (décembre). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 1 et 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit l’année, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes. 
	 <p>
	 Vous pouvez éventuellement utiliser cette méthode pour définir également le mois et le jour du mois. L’appel de cette méthode ne modifie pas les autres champs, mais les méthodes <codeph>Date.getUTCDay()</codeph> et <codeph>Date.getDay()</codeph> peuvent signaler une nouvelle valeur si le jour de la semaine change suite à l’appel de cette méthode. 
	 </p>
	 
 	 </apiDesc><example conref="examples\Date.setUTCFullYear.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). La méthode <codeph>getUTCFullYear()</codeph> est ensuite appelée et renvoie correctement l’année au format à quatre chiffres. Ensuite, <codeph>setUTCFullYear()</codeph> est appelé avec le paramètre <codeph>year</codeph> défini sur <codeph>1975</codeph> et une instruction <codeph>trace()</codeph> confirme que l’année a été correctement définie.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974

someBirthday.setUTCFullYear(1975);
trace(someBirthday); // Thu Nov 30 01:20:00 GMT-0800 1975
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCHours"><apiName>setUTCHours</apiName><shortdesc>
	 Définit l’heure, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutchours, setutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (minuit) et 23 (23h00).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit l’heure, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes. Permet éventuellement de spécifier les minutes, les secondes et les millisecondes.
	 
	 </apiDesc><example conref="examples\Date.setUTCHours.1.as"> L’exemple suivant crée un nouvel objet Date <codeph>someBirthday</codeph> avec les paramètres <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = November), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) et <codeph>minute</codeph> (<codeph>20</codeph>). Les méthodes <codeph>getHours()</codeph>, <codeph>getMinutes()</codeph>, <codeph>getUTCHours()</codeph> et <codeph>getUTCMinutes()</codeph> sont ensuite appelées, ce qui extrait les heures et les minutes. Ensuite, <codeph>setUTCHours()</codeph> est appelé avec le paramètre <codeph>hour</codeph> défini sur <codeph>12</codeph>. Enfin, les méthodes <codeph>getHours()</codeph>, <codeph>getMinutes()</codeph>, <codeph>getUTCHours()</codeph> et <codeph>getUTCMinutes()</codeph> sont rappelées et affichent l’heure mise à jour.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 15:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 23:20

someBirthday.setUTCHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 4:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMilliseconds"><apiName>setUTCMilliseconds</apiName><shortdesc>
	 Définit les millisecondes, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmilliseconds, setutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les millisecondes, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.
	 
	 </apiDesc><example conref="examples\Date.setUTCMilliseconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCMilliseconds()</codeph> est ensuite appelée, ce qui extrait les millisecondes UTC de l’heure de création de <codeph>now</codeph>. Ensuite, un autre nouvel objet Date, <codeph>before</codeph>, accompagné d’un appel supplémentaire à <codeph>setUTCMilliseconds()</codeph> avec le paramètre <codeph>millisecond</codeph> défini sur <codeph>4</codeph>. La méthode <codeph>getUTCMilliseconds()</codeph> est ensuite appelée de nouveau, ce qui extrait les millisecondes qui viennent d’être définies.
<codeblock>


var now:Date = new Date();
trace(now);
trace(now.getUTCMilliseconds());

var before:Date = new Date(now.setUTCMilliseconds(4));
trace(before);
trace(before.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMinutes"><apiName>setUTCMinutes</apiName><shortdesc>
	 Définit les minutes, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcminutes, setutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les minutes, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes. Vous pouvez éventuellement spécifier les secondes et les millisecondes.
	 
	 </apiDesc><example conref="examples\Date.setUTCMinutes.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCMinutes()</codeph> est ensuite appelée, ce qui extrait les minutes UTC de l’heure de création de <codeph>now</codeph>. Ensuite, un autre nouvel objet Date, <codeph>before</codeph>, accompagné d’un appel supplémentaire à <codeph>setUTCMinutes()</codeph> avec le paramètre <codeph>minute</codeph> défini sur <codeph>0</codeph>. La méthode <codeph>getUTCMinutes()</codeph> est ensuite appelée de nouveau, ce qui extrait les minutes qui viennent d’être définies.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getUTCMinutes());

var before:Date = new Date(now.setUTCMinutes(0));
trace(before);
trace(before.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMonth"><apiName>setUTCMonth</apiName><shortdesc>
	 Définit le mois, et éventuellement le jour, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmonth, setutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 (janvier) et 11 (décembre).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 1 et 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit le mois, et éventuellement le jour, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes. L’appel de cette méthode ne modifie pas les autres champs, mais les méthodes <codeph>Date.getUTCDay()</codeph> et <codeph>Date.getDay()</codeph> peuvent signaler une nouvelle valeur si le jour de la semaine change suite à l’appel de cette méthode.
	 
	 </apiDesc><example conref="examples\Date.setUTCMonth.1.as"> L’exemple suivant crée un nouvel objet Array, <codeph>UTCMonthLabels</codeph>, avec les éléments <codeph>January</codeph> à <codeph>December</codeph> et un nouvel objet UTCMonth, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCMonth()</codeph> est ensuite appelée, ce qui extrait le mois UTC pendant lequel <codeph>now</codeph> a été créé. Ensuite la méthode <codeph>setUTCMonth()</codeph> est appelée avec le paramètre <codeph>month</codeph> défini sur <codeph>0</codeph>, puis la méthode <codeph>getUTCMonth()</codeph> est appelée de nouveau, ce qui extrait le mois qui vient d’être défini..
<codeblock>

var UTCMonthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getUTCMonth());
trace(UTCMonthLabels[now.getUTCMonth()]);

now.setUTCUTCMonth(0);
trace(now.getUTCMonth());              // 0
trace(UTCMonthLabels[now.getUTCMonth()]); // January
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCSeconds"><apiName>setUTCSeconds</apiName><shortdesc>
	 Définit les secondes, et éventuellement les millisecondes, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcseconds, setutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle heure, en millisecondes.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 59.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Entier compris entre 0 et 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les secondes, et éventuellement les millisecondes, conformément à l’heure universelle (UTC), et renvoie la nouvelle heure en millisecondes.
	 
	 </apiDesc><example conref="examples\Date.setUTCSeconds.1.as"> L’exemple suivant crée un nouvel objet Date, <codeph>now</codeph>, sans paramètres. La méthode <codeph>getUTCSeconds()</codeph> est ensuite appelée, ce qui extrait les secondes de l’heure de création de <codeph>now</codeph>. Ensuite la méthode <codeph>setUTCSeconds()</codeph> est appelée avec le paramètre <codeph>second</codeph> défini sur <codeph>0</codeph>, puis la méthode <codeph>getUTCSeconds()</codeph> est appelée de nouveau, ce qui extrait le mois qui vient d’être défini.
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());

now.setUTCSeconds(0);
trace(now.getUTCSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toDateString"><apiName>toDateString</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne du jour et de la date uniquement et n’inclut ni l’heure, ni le fuseau horaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne du jour et de la date uniquement.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne du jour et de la date uniquement et n’inclut ni l’heure, ni le fuseau horaire. Comparez-la aux méthodes suivantes :
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph>, qui renvoie l’heure et le fuseau horaire uniquement,</li>
	   <li><codeph>Date.toString()</codeph>, qui renvoie non seulement le jour et la date, mais aussi l’heure et le fuseau horaire.</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\Date.toDateString.1.as"> L’exemple suivant crée un objet Date, <codeph>now</codeph>, sans paramètre. Ensuite les méthodes suivantes sont appelées au sein d’une instruction <codeph>trace()</codeph>.
 <ul>
   <li><codeph>toString</codeph> : affiche tous les paramètres de <codeph>now</codeph> en fonction de l’heure de création de <codeph>now</codeph>.</li>
   <li><codeph>toDateString()</codeph> : affiche les paramètres <codeph>day</codeph>, <codeph>month</codeph> et <codeph>year</codeph> correspondant à l’heure de création de <codeph>now</codeph>.</li>
 </ul>
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.toDateString());
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleDateString"><apiName>toLocaleDateString</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne du jour et de la date uniquement et n’inclut ni l’heure, ni le fuseau horaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation <codeph>String</codeph> du jour et de la date uniquement.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne du jour et de la date uniquement et n’inclut ni l’heure, ni le fuseau horaire. Cette méthode renvoie la même valeur que <codeph>Date.toDateString</codeph>. Comparez-la aux méthodes suivantes :
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph>, qui renvoie l’heure et le fuseau horaire uniquement,</li>
	   <li><codeph>Date.toString()</codeph>, qui renvoie non seulement le jour et la date, mais aussi l’heure et le fuseau horaire.</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne du jour, de la date et de l’heure en heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne d’un objet <codeph>Date</codeph> dans le fuseau horaire local.
	 
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne du jour, de la date et de l’heure en heure locale. Comparez cette méthode à la méthode <codeph>Date.toString()</codeph>, qui renvoie les mêmes informations (plus le fuseau horaire) et insère l’année en fin de chaîne.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toLocaleTimeString"><apiName>toLocaleTimeString</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne de l’heure uniquement et n’inclut ni le jour, ni la date, ni l’année, ni le fuseau horaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’heure et du fuseau horaire uniquement.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne de l’heure uniquement et n’inclut ni le jour, ni la date, ni l’année, ni le fuseau horaire. Comparez cette méthode à la méthode <codeph>Date.toTimeString()</codeph>, qui renvoie l’heure et le fuseau horaire.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne du jour, de la date, de l’heure et du fuseau horaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.tostring, tostring, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne d’un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne du jour, de la date, de l’heure et du fuseau horaire. Le format de date utilisé pour la sortie est le suivant : 
     <pre>
     Day Mon Date HH:MM:SS TZD YYYY
     </pre>
     <p>Exemple :</p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
	 
	 </apiDesc><example conref="examples\Date.toString.1.as"> L’exemple suivant crée un objet Date, <codeph>now</codeph>, sans paramètre. Ensuite, <codeph>toString</codeph> est appelé au sein d’une instruction <codeph>trace()</codeph>, qui affiche tous les paramètres de <codeph>now</codeph> en fonction de l’heure de création de <codeph>now</codeph>.
<codeblock>


var now:Date = new Date();
trace(now);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toTimeString"><apiName>toTimeString</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne de l’heure et du fuseau horaire uniquement et n’inclut ni le jour, ni la date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’heure et du fuseau horaire uniquement.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne de l’heure et du fuseau horaire uniquement et n’inclut ni le jour, ni la date. Comparez cette méthode à la méthode <codeph>Date.toDateString()</codeph>, qui ne renvoie que le jour et la date.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toUTCString"><apiName>toUTCString</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne du jour, de la date et de l’heure en heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne d’un objet <codeph>Date</codeph> en heure UTC.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne du jour, de la date et de l’heure en heure universelle (UTC). Par exemple, la date du premier février 2005 est renvoyée sous la forme <codeph>Tue Feb 1 00:00:00 2005 UTC</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Renvoie le nombre de millisecondes écoulées depuis le premier janvier 1970 à minuit, heure universelle, pour un objet Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.valueof, valueof, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nombre de millisecondes écoulées depuis le premier janvier 1970 représenté par un objet <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie le nombre de millisecondes écoulées depuis le premier janvier 1970 à minuit, heure universelle, pour un objet <codeph>Date</codeph>.
	 
	 </apiDesc><example conref="examples\Date.valueOf.1.as"> L’exemple suivant crée un objet Date, <codeph>now</codeph> sans paramètre. Ensuite, la méthode <codeph>getTime()</codeph> est appelée, ce qui extrait le nombre de millisecondes séparant l’heure de création de <codeph>now</codeph> et minuit le premier janvier 1970. Enfin, la méthode <codeph>valueOf()</codeph> est appelée, ce qui extrait la même chose.
<codeblock>


var now:Date = new Date();
trace(now.getTime());
trace(now.valueOf());
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="Date:AS3:date:get"><apiName>date</apiName><shortdesc>
	 Jour du mois (entier compris entre 1 et 31) spécifié par un objet Date conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Jour du mois (entier compris entre 1 et 31) spécifié par un objet <codeph>Date</codeph> conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/setDate()"><linktext>setDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dateUTC:get"><apiName>dateUTC</apiName><shortdesc>
	 Jour du mois (entier compris entre 1 et 31) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Jour du mois (entier compris entre 1 et 31) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDate()"><linktext>getUTCDate()</linktext></link><link href="#Date/setUTCDate()"><linktext>setUTCDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:day:get"><apiName>day</apiName><shortdesc>
	 Jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) spécifié par l’objet Date conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) spécifié par l’objet <codeph>Date</codeph> conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dayUTC:get"><apiName>dayUTC</apiName><shortdesc>
	 Jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) de l’objet Date conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Jour de la semaine (0 pour dimanche, 1 pour lundi, etc.) de l’objet <codeph>Date </codeph> conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYear:get"><apiName>fullYear</apiName><shortdesc>
	 Année entière (un nombre à quatre chiffres, tel que 2000) d’un objet Date conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Année entière (un nombre à quatre chiffres, tel que 2000) d’un objet <codeph>Date</codeph> conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link><link href="#Date/setFullYear()"><linktext>setFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYearUTC:get"><apiName>fullYearUTC</apiName><shortdesc>
	 Année à quatre chiffres d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Année à quatre chiffres d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCFullYear()"><linktext>getUTCFullYear()</linktext></link><link href="#Date/setUTCFullYear()"><linktext>setUTCFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hours:get"><apiName>hours</apiName><shortdesc>
	 Heure (entier compris entre 0 et 23) de la partie jour d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Heure (entier compris entre 0 et 23) de la partie jour d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link><link href="#Date/setHours()"><linktext>setHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hoursUTC:get"><apiName>hoursUTC</apiName><shortdesc>
	 Heure (entier compris entre 0 et 23) du jour d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Heure (entier compris entre 0 et 23) du jour d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCHours()"><linktext>getUTCHours()</linktext></link><link href="#Date/setUTCHours()"><linktext>setUTCHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:milliseconds:get"><apiName>milliseconds</apiName><shortdesc>
	 Partie millisecondes (entier compris entre 0 et 999) d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie millisecondes (entier compris entre 0 et 999) d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMilliseconds()"><linktext>getMilliseconds()</linktext></link><link href="#Date/setMilliseconds()"><linktext>setMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:millisecondsUTC:get"><apiName>millisecondsUTC</apiName><shortdesc>
	 Partie millisecondes (entier compris entre 0 et 999) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie millisecondes (entier compris entre 0 et 999) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMilliseconds()"><linktext>getUTCMilliseconds()</linktext></link><link href="#Date/setUTCMilliseconds()"><linktext>setUTCMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutes:get"><apiName>minutes</apiName><shortdesc>
	 Partie minutes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie minutes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMinutes()"><linktext>getMinutes()</linktext></link><link href="#Date/setMinutes()"><linktext>setMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutesUTC:get"><apiName>minutesUTC</apiName><shortdesc>
	 Partie minutes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie minutes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMinutes()"><linktext>getUTCMinutes()</linktext></link><link href="#Date/setUTCMinutes()"><linktext>setUTCMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:month:get"><apiName>month</apiName><shortdesc>
	 Partie mois (0 pour janvier, 1 pour février, etc.) d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie mois (0 pour janvier, 1 pour février, etc.) d’un objet <codeph> Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/setMonth()"><linktext>setMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:monthUTC:get"><apiName>monthUTC</apiName><shortdesc>
	 Le mois (0 [janvier] à 11 [décembre]) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie mois (0 [janvier] à 11 [décembre]) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMonth()"><linktext>getUTCMonth()</linktext></link><link href="#Date/setUTCMonth()"><linktext>setUTCMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:seconds:get"><apiName>seconds</apiName><shortdesc>
	 Partie secondes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure locale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie secondes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure locale. L’heure locale est déterminée par le système d’exploitation sur lequel Flash Player s’exécute.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getSeconds()"><linktext>getSeconds()</linktext></link><link href="#Date/setSeconds()"><linktext>setSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:secondsUTC:get"><apiName>secondsUTC</apiName><shortdesc>
	 Partie secondes (entier compris entre 0 et 59) d’un objet Date, conformément à l’heure universelle (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Partie secondes (entier compris entre 0 et 59) d’un objet <codeph>Date</codeph>, conformément à l’heure universelle (UTC).
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCSeconds()"><linktext>getUTCSeconds()</linktext></link><link href="#Date/setUTCSeconds()"><linktext>setUTCSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:time:get"><apiName>time</apiName><shortdesc>
	 Nombre de millisecondes écoulées depuis le premier janvier 1970 à minuit, heure universelle, pour un objet Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre de millisecondes écoulées depuis le premier janvier 1970 à minuit, heure universelle, pour un objet <codeph>Date</codeph>. Cette méthode permet de représenter un instant spécifique dans le temps lorsque vous comparez au moins deux objets <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getTime()"><linktext>getTime()</linktext></link><link href="#Date/setTime()"><linktext>setTime()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:timezoneOffset:get"><apiName>timezoneOffset</apiName><shortdesc>
     Différence, en minutes, entre le temps universel (UTC) et l’heure locale de l’ordinateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Différence, en minutes, entre le temps universel (UTC) et l’heure locale de l’ordinateur. De façon plus précise, cette valeur correspond au nombre de minutes que vous devez ajouter à l’heure locale de l’ordinateur pour obtenir l’heure UTC. Si votre ordinateur est en avance sur l’heure UTC, la valeur renvoyée est négative.
     </apiDesc></apiValueDetail><related-links><link href="#Date/getTimezoneOffset()"><linktext>getTimezoneOffset()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="globalClassifier:URIError"><apiName>URIError</apiName><shortdesc>
 Une exception URIError est renvoyée lorsque l’une des fonctions de gestion URI globales est utilisée d’une manière qui n’est pas compatible avec sa définition.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, URIError
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une exception URIError est renvoyée lorsque l’une des fonctions de gestion URI globales est utilisée d’une manière qui n’est pas compatible avec sa définition. Cette exception est renvoyée si une URI non valide est transmise à une fonction qui attend un URI valide, tel que la méthode <codeph>Socket.connect()</codeph>.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>flash.net.Socket.connect()</linktext></link></related-links><apiConstructor id="URIError:URIError"><apiName>URIError</apiName><shortdesc>
	 Crée un objet URIError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Contient le message associé à l’objet URIError.  
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet URIError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Object"><apiName>Object</apiName><shortdesc>
 La classe Object forme la racine de la hiérarchie de classes d’exécution ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/></apiClassifierDef><apiDesc>
 La classe Object forme la racine de la hiérarchie de classes d’<ph platform="actionscript">exécution</ph><ph platform="javascript">ActionScript</ph>. Les objets sont créés à l’aide de constructeurs en appliquant la syntaxe de l’opérateur <codeph>new</codeph> et vous pouvez leur affecter des propriétés de façon dynamique. <ph platform="actionscript">Vous pouvez également créer des objets en affectant un littéral d’objet, comme suit :</ph>
 
 <codeblock platform="actionscript">var obj:Object = {a:"foo", b:"bar"}</codeblock>
 
 <p platform="actionscript">Toutes les classes qui ne déclarent pas de classe de base explicite étendent la classe Object intégrée.</p>
 
 <p platform="javascript">Toutes les classes d’exécution dans Adobe Integrated Runtime étendent la classe runtime.Object.</p>
 
 <p platform="actionscript">Vous pouvez utiliser la classe Object pour créer des <i>associative arrays</i>. Sous sa forme de base, un tableau associatif est une occurrence de la classe Object et chaque paire clé/valeur est représentée par une propriété et sa valeur. Vous pouvez également déclarer un tableau associatif à l’aide du type de données Object pour la raison suivante : cela vous permet d’utiliser ensuite un littéral d’objet pour alimenter votre tableau associatif (uniquement au moment de la déclaration). L’exemple suivant crée un tableau associatif à l’aide d’un littéral d’objet, accède aux éléments à l’aide de l’opérateur point et d’accès au tableau, puis ajoute une nouvelle paire clé/valeur en créant une nouvelle propriété :</p>
 
 <codeblock platform="actionscript">
 var myAssocArray:Object = {fname:"John", lname:"Public"};
 trace(myAssocArray.fname);     // John
 trace(myAssocArray["lname"]);  // Public
 myAssocArray.initial = "Q";
 trace(myAssocArray.initial);   // Q</codeblock> 
 
 <p platform="actionscript">ActionScript 3.0 dispose de deux types d’héritage : par classe et par prototype :</p>
 <ul platform="actionscript">
 <li>L’héritage de classe est le principal mécanisme d’héritage et prend en charge l’héritage des propriétés fixes. Une propriété fixe est une variable, une constante ou une méthode déclarée dans le cadre d’une définition de classe. Chaque définition de classe est à présent représentée par un objet de classe spécial qui mémorise les informations relatives à la classe. </li>
 <li>Héritage par prototype : il s’agissait de l’unique mécanisme d’héritage des versions précédentes d’ActionScript et constitue l’une des deux solutions d’héritage d’ActionScript 3.0. Chaque classe est associée à un objet prototype et les propriétés de l’objet prototype sont partagées par tous les héritages de la classe. Lorsqu’une classe est générée, elle contient une référence à l’objet prototype correspondant, qui sert de lien entre l’occurrence et l’objet prototype de classe associé. Lors de l’exécution, si une propriété ne figure pas dans une occurrence de classe, elle est recherchée dans le délégué, à savoir l’objet prototype de la classe. Si l’objet prototype ne contient pas la propriété, le processus continue et le délégué de l’objet prototype effectue des recherches dans des niveaux de plus en plus élevés de la hiérarchie jusqu’à ce que Flash Player trouve la propriété. </li>
 </ul>
 
 <p platform="actionscript">L’héritage de classe et l’héritage de prototype peuvent coexister, comme illustré dans l’exemple suivant :</p>
 
 <codeblock platform="actionscript">
 class A {
     var x = 1
     prototype.px = 2
 }
 dynamic class B extends A {
     var y = 3
     prototype.py = 4
 }
  
 var b = new B()
 b.x // 1 via class inheritance
 b.px // 2 via prototype inheritance from A.prototype
 b.y // 3
 b.py // 4 via prototype inheritance from B.prototype
  
 B.prototype.px = 5
 b.px // now 5 because B.prototype hides A.prototype
  
 b.px = 6
 b.px // now 6 because b hides B.prototype</codeblock>
 
 <p platform="actionscript">Si vous utilisez des fonctions au lieu de classes, vous pouvez générer des arborescences d’héritage de prototype personnalisées. Avec les classes, l’arborescence d’héritage de prototype reflète à l’identique l’arborescence d’héritage de classe. Cependant, les objets prototype étant dynamiques, vous pouvez ajouter et supprimer des propriétés associées aux prototypes lors de l’exécution.</p>
 
 </apiDesc><example conref="examples\ObjectExample.as"> L’exemple suivant utilise les classes <codeph>ObjectExample</codeph> et <codeph>Circle</codeph> pour démontrer la nature dynamique de la classe Object et la façon dont les objets de valeur peuvent être transformés en objets Shape, puis ajoutés à la scène aux coordonnées x/y spécifiées.
 
 <p>L’exemple crée les objets de valeur <codeph>firstInitObj</codeph> et <codeph>secondInitObj</codeph>. La classe personnalisée <codeph>Circle</codeph> accepte l’objet valeur et exécute une boucle sur ce dernier tout en définissant ses propriétés internes correspondantes sur celles qui sont définies dans l’objet de valeur.</p>
<codeblock>
package {
    import flash.display.Sprite;

    public class ObjectExample extends Sprite {
        public function ObjectExample() {
            var firstInitObj:Object = new Object();
            firstInitObj.bgColor = 0xFF0000;
            firstInitObj.radius = 25;
            firstInitObj.xCenter = 25;
            firstInitObj.yCenter = 25;
                        
            var firstCircle:Circle = new Circle(firstInitObj);
            addChild(firstCircle);
            firstCircle.x = 50;
            firstCircle.y = 50;

            var secondInitObj:Object = {bgColor:0xCCCCCC, radius:50, xCenter:50, yCenter:50};

            var secondCircle:Circle = new Circle(secondInitObj);            
            addChild(secondCircle);
            secondCircle.x = 100;
            secondCircle.y = 100;
        }
        
    }
}

import flash.display.Shape;
    
class Circle extends Shape {
    public var bgColor:Number = 0xFFFFFF;
    public var radius:Number = 0;
    public var xCenter:Number = 0;
    public var yCenter:Number = 0;
        
    public function Circle(initObj:Object) {
        for(var i:String in initObj) {
            this[i] = initObj[i];
        }
        draw();
    }
        
    public function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawCircle(xCenter, yCenter, radius);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links><apiConstructor id="Object:Object"><apiName>Object</apiName><shortdesc>
	 Crée un objet Object et stocke une référence à la méthode constructeur de l’objet dans la propriété constructor de ce dernier.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Crée un objet Object et stocke une référence à la méthode constructeur de l’objet dans la propriété <codeph>constructor</codeph> de ce dernier.
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Object:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	 Indique si la propriété spécifiée d’un objet est définie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Method
	 </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>name</codeph> si l’objet cible comporte la propriété spécifiée par le paramètre <codeph>true</codeph>, <codeph>false</codeph> dans tous les autres cas.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Propriété de l’objet.	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique si la propriété spécifiée d’un objet est définie. Cette méthode renvoie <codeph>true</codeph> si l’objet cible comporte une propriété qui correspond à la chaîne spécifiée par le paramètre <codeph>name</codeph> et <codeph>false</codeph> dans les autres cas. Les types de propriétés suivants forcent la méthode à renvoyer la valeur <codeph>true</codeph> pour les objets qui sont des occurrences de classe, plutôt que des objets de classe :
	 <ul>
	   <li>Propriétés d’occurrence fixes : variables, constantes ou méthodes définies par la classe de l’objet qui ne sont pas statiques.</li>
	   <li>Propriétés d’occurrence fixes héritées : variables, constantes ou méthodes héritées par la classe de l’objet.</li>
	   <li>Propriétés dynamiques : propriétés ajoutées à un objet après son instanciation (hors de la définition de classe). Pour ajouter des propriétés dynamiques, la classe de définition de l’objet doit être déclarée avec le mot-clé <codeph>dynamic</codeph>.</li>
	 </ul>
	 <p>Les types de propriétés suivants forcent la méthode à renvoyer la valeur <codeph>false</codeph> pour les objets qui sont des occurrences de classe :</p>
	 <ul>
	   <li>Propriétés statiques : variables, constantes ou méthodes définies avec le mot-clé statique dans la classe de définition d’un objet ou dans l’une de ses super-classes.</li>
	   <li>Propriétés de prototype : propriétés définies pour un objet prototype appartenant à la chaîne de prototype de l’objet. Dans ActionScript 3.0, la chaîne de prototype n’est pas utilisée pour l’héritage de classe, mais demeure une autre forme d’héritage valide. Par exemple, une occurrence de la classe Array peut accéder à la méthode <codeph>valueOf()</codeph> parce qu’elle est associée à <codeph>Object.prototype</codeph>, qui fait partie de la chaîne de prototype de la classe Array. Bien que vous puissiez utiliser <codeph>valueOf()</codeph> sur une occurrence d’Array, la valeur renvoyée par <codeph>hasOwnProperty("valueOf")</codeph> pour cette occurrence correspond à <codeph>false</codeph>.</li>
	 </ul>
	 
	 <p platform="actionscript">ActionScript 3.0 gère également les objets de classe, qui sont des représentations directes des définitions de classe. Si vous l’appelez sur un objet de classe, la méthode <codeph>hasOwnProperty()</codeph> ne renvoie <codeph>true</codeph> que si une propriété fait partie des propriétés statiques associées à l’objet de classe. Par exemple, si vous créez une sous-classe d’Array appelée CustomArray et que vous définissez une propriété statique dans CustomArray appelée <codeph>foo</codeph>, tout appel de <codeph>CustomArray.hasOwnProperty("foo")</codeph> renvoie <codeph>true</codeph>. Cependant, pour la propriété statique <codeph>DESCENDING</codeph> définie dans la classe Array, un appel de <codeph>CustomArray.hasOwnProperty("DESCENDING")</codeph> renvoie <codeph>false</codeph>.</p>
	 
     <p platform="actionscript"><b>Remarque :</b> les méthodes de la classe Object sont créées dynamiquement sur le prototype correspondant. Pour redéfinir cette méthode dans une sous-classe d’Object, n’utilisez pas le mot-clé <codeph>override</codeph>. Une sous-classe d’Object implémente par exemple <codeph>function hasOwnProperty():Boolean</codeph> au lieu d’utiliser un remplacement de la classe de base.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:isPrototypeOf"><apiName>isPrototypeOf</apiName><shortdesc>
	 Indique si une occurrence de la classe Object figure dans la chaîne de prototype de l’objet spécifié en tant que paramètre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet figure dans la chaîne de prototype de l’objet spécifié par le paramètre <codeph>theClass</codeph>, <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>theClass</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Classe à laquelle risque de se référer l’objet spécifié.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique si une occurrence de la classe Object figure dans la chaîne de prototype de l’objet spécifié en tant que paramètre. Cette méthode renvoie <codeph>true</codeph> si l’objet figure dans le chaînage de prototype de l’objet spécifié par le paramètre <codeph>theClass</codeph>. La méthode renvoie <codeph>false</codeph> si l’objet cible est absent de la chaîne de prototype de l’objet <codeph>theClass</codeph> et si le paramètre <codeph>theClass</codeph> n’est pas un objet.
	 
     <p platform="actionscript"><b>Remarque :</b> les méthodes de la classe Object sont créées dynamiquement sur le prototype correspondant. Pour redéfinir cette méthode dans une sous-classe d’Object, n’utilisez pas le mot-clé <codeph>override</codeph>. Une sous-classe d’Object implémente par exemple <codeph>function isPrototypeOf():Boolean</codeph> au lieu d’utiliser un remplacement de la classe de base.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	 Indique si la propriété spécifiée existe et est énumérable.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a generic object, adds a property to the object, then checks whether the object is enumerable. By way of contrast, the example also shows that a built-in property, the <code>Array.length</code> property, is not enumerable.
	 <listing>
	 var myObj:Object = new Object();
	 myObj.prop1 = "hello";
	 trace(myObj.propertyIsEnumerable("prop1")); // true
	 
	 var myArray = new Array();
	 trace(myArray.propertyIsEnumerable("length")); // false
	 </listing> 
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si la propriété spécifiée par le paramètre <codeph>name</codeph> est énumérable, <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Propriété de l’objet.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique si la propriété spécifiée existe et est énumérable. Si la valeur est <codeph>true</codeph>, la propriété existe et peut être énumérée dans une boucle <codeph>for..in</codeph>. La propriété doit exister au niveau de l’objet cible dans la mesure où cette méthode ne vérifie pas la chaîne de prototype de l’objet cible.
	 
	 <p>Les propriétés que vous créez sont énumérables, contrairement aux propriétés intégrées qui ne le sont généralement pas.</p>
	 
     <p platform="actionscript"><b>Remarque :</b> les méthodes de la classe Object sont créées dynamiquement sur le prototype correspondant. Pour redéfinir cette méthode dans une sous-classe d’Object, n’utilisez pas le mot-clé <codeph>override</codeph>. Une sous-classe d’Object implémente par exemple <codeph>function propertyIsEnumerable():Boolean</codeph> au lieu d’utiliser un remplacement de la classe de base.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:setPropertyIsEnumerable"><apiName>setPropertyIsEnumerable</apiName><shortdesc>
     Définit la disponibilité d’une propriété dynamique pour les opérations en boucle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Propriété de l’objet.
     </apiDesc></apiParam><apiParam><apiItemName>isEnum</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc> Si défini sur <codeph>false</codeph>, la propriété dynamique est ignorée dans les boucles <codeph>for..in</codeph> et la méthode <codeph>propertyIsEnumerable()</codeph> renvoie <codeph>false</codeph>. 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Définit la disponibilité d’une propriété dynamique pour les opérations en boucle. La propriété doit exister au niveau de l’objet cible dans la mesure où cette méthode ne vérifie pas la chaîne de prototype de l’objet cible.
     </apiDesc></apiOperationDetail><related-links><link href="#Object/propertyIsEnumerable()"><linktext>propertyIsEnumerable()</linktext></link></related-links></apiOperation><apiOperation id="Object:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 Renvoie la représentation de chaîne de cet objet, formatée selon les paramètres régionaux en vigueur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tolocalestring, tolocalestring
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Une représentation de cet objet sous forme de chaîne, formatée conformément aux conventions locales.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la représentation de cet objet sous forme de chaîne, formatée selon les paramètres régionaux en vigueur.
	 
	 <p>Par défaut, l’implémentation de cette méthode n’entraîne pas le formatage selon les paramètres régionaux et renvoie la même chaîne que <codeph>toString()</codeph>. Les sous-classes doivent fournir leur propre implémentation en fonction des paramètres régionaux lorsque cela est nécessaire.</p>
	 
     <p platform="actionscript"><b>Remarque :</b> les méthodes de la classe Object sont créées dynamiquement sur le prototype correspondant. Pour redéfinir cette méthode dans une sous-classe d’Object, n’utilisez pas le mot-clé <codeph>override</codeph>. Par exemple, une sous-classe d’Object implémente la méthode <codeph>function toLocaleString():String</codeph> au lieu d’avoir recours au remplacement de la classe de base.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiOperation id="Object:toString"><apiName>toString</apiName><shortdesc>
	 Renvoie la représentation sous forme de chaîne de l’objet spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’objet.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la représentation sous forme de chaîne de l’objet spécifié.
	 
     <p platform="actionscript"><b>Remarque :</b> les méthodes de la classe Object sont créées dynamiquement sur le prototype correspondant. Pour redéfinir cette méthode dans une sous-classe d’Object, n’utilisez pas le mot-clé <codeph>override</codeph>. Par exemple, une sous-classe d’Object implémente <codeph>function toString():String</codeph> au lieu d’utiliser un remplacement de la classe de base.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Renvoie la valeur primitive de l’objet spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.valueof, valueof
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur primitive de l’objet ou l’objet lui-même.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la valeur primitive de l’objet spécifié. Si l’objet n’a pas de valeur primitive, il est lui-même renvoyé.
	 
     <p platform="actionscript"><b>Remarque :</b> les méthodes de la classe Object sont créées dynamiquement sur le prototype correspondant. Pour redéfinir cette méthode dans une sous-classe d’Object, n’utilisez pas le mot-clé <codeph>override</codeph>. Une sous-classe d’Object implémente par exemple <codeph>function valueOf():Object</codeph> au lieu d’utiliser un remplacement de la classe de base.</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiValue id="Object:constructor"><apiName>constructor</apiName><shortdesc>
	 Référence à l’objet de classe ou à la fonction constructeur d’une occurrence donnée d’un objet.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Object, Object.constructor, constructor
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Référence à l’objet de classe ou à la fonction constructeur d’une occurrence donnée d’un objet. Si un objet est une occurrence de classe, la propriété <codeph>constructor</codeph> contient une référence à l’objet de classe. Si un objet est créé par le biais d’une fonction constructeur, la propriété <codeph>constructor</codeph> contient une référence à la fonction constructeur. Ne confondez pas une fonction constructeur avec une méthode constructeur de classe. Une fonction constructeur est un objet Function permettant de créer des objets et peut être utilisée au lieu du mot-clé <codeph>class</codeph> pour définir des classes.
	 
	 <p platform="actionscript">Si vous utilisez le mot-clé <codeph>class</codeph> pour définir une classe, la propriété <codeph>constructor</codeph>, qui contient une référence à l’objet de classe, est affectée à l’objet prototype correspondant. Une occurrence de la classe hérite de cette propriété à partir de l’objet prototype. Le code suivant crée par exemple une classe, <codeph>A</codeph>, et une occurrence de classe, <codeph>myA</codeph> :</p>
	 <codeblock platform="actionscript" rev="3.0">
	 dynamic class A {}
	 trace(A.prototype.constructor);      // [class A]
	 trace(A.prototype.constructor == A); // true
	 var myA:A = new A();
	 trace(myA.constructor == A);         // true</codeblock>
	 
	 <p platform="actionscript">Les utilisateurs chevronnés peuvent opter pour le mot-clé <codeph>function</codeph> au lieu du mot-clé <codeph>class</codeph> pour définir un objet Function, qui pourra servir de modèle de création d’objet. Ce type de fonction porte le nom de fonction constructeur, car vous pouvez l’utiliser en conjonction avec l’opérateur <codeph>new</codeph> pour créer des objets. Si vous utilisez le mot-clé <codeph>function</codeph> pour créer une fonction constructeur, la propriété <codeph>constructor</codeph>, qui contient une référence à la fonction constructeur, est affectée à l’objet prototype correspondant. Si vous utilisez ensuite la fonction constructeur pour créer un objet, celui-ci hérite de la propriété <codeph>constructor</codeph> à partir de l’objet prototype de la fonction constructeur. Le code suivant crée par exemple une fonction constructeur, <codeph>f</codeph>, et un objet, <codeph>myF</codeph> :</p>
	 <codeblock platform="actionscript" rev="3.0">
	 function f() {}
	 trace(f.prototype.constructor);      // function Function() {}
	 trace(f.prototype.constructor == f); // true
	 var myF = new f();
	 trace(myF.constructor == f);         // true</codeblock>
	 
	 <p><b>Remarque </b>: la propriété <codeph>constructor</codeph> est accessible en écriture, ce qui signifie que la valeur du code utilisateur peut être modifiée par une instruction d’affectation. Il n’est pas recommandé de modifier la valeur de la propriété <codeph>constructor</codeph>, mais si vous rédigez du code affecté par la valeur de la propriété <codeph>constructor</codeph>, assurez-vous que la valeur n’est pas réinitialisée. La valeur ne peut être modifiée que lors d’un accès à la propriété par le biais de l’objet prototype (<codeph>className.prototype.constructor</codeph>, par exemple).</p>
     <p>Si vous accédez à la propriété <codeph>constructor</codeph> et compilez en mode strict, vous obtenez une erreur lors de la compilation, car la propriété constructor dépend de l’objet prototype, ce qui est une entité d’exécution. Si vous utilisez mode standard ou si la description de la classe spécifie « dynamic », le code s’exécute sans générer d’erreur. </p>     
	 </apiDesc></apiValueDetail><related-links><link href="#Class"><linktext>Classe</linktext></link><link href="#Function"><linktext>Fonction</linktext></link><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links></apiValue><apiValue id="Object:prototype"><apiName>prototype</apiName><shortdesc>
	 Référence à l’objet prototype d’un objet de classe ou fonction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a class named Shape and a subclass of Shape named Circle.
	 <listing version="2.0">
	 // Shape class defined in external file named Shape.as
	 class Shape {
	 	function Shape() {}
	 }
	 
	 // Circle class defined in external file named Circle.as
	 class Circle extends Shape{
	 	function Circle() {}
	 }
	 </listing>
	 The Circle class can be used to create two instances of Circle:
	 <listing version="2.0">
	 var oneCircle:Circle = new Circle();
	 var twoCircle:Circle = new Circle();
	 </listing>
	 The following trace statement shows that the <code>prototype</code> property of the Circle class points to its superclass Shape. The identifier <code>Shape</code> refers to the constructor function of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.constructor == Shape); // true
	 </listing>
	 The following trace statement shows how you can use the <code>prototype</code> property and the <code>__proto__</code> property together to move two levels up the inheritance hierarchy (or prototype chain). The <code>Circle.prototype.__proto__</code> property contains a reference to the superclass of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.__proto__ == Shape.prototype); // true
	 </listing>
	 
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Référence à l’objet prototype d’un objet de classe ou fonction. La propriété <codeph>prototype</codeph> est créée automatiquement et est liée à tout objet de classe ou fonction que vous créez. Cette propriété est statique dans la mesure où elle est propre à la classe ou la fonction que vous créez. Par exemple, si vous créez une classe, la valeur de la propriété <codeph>prototype</codeph> est partagée par toutes les occurrences de la classe et est accessible uniquement en tant que propriété de classe. Les occurrences de votre classe ne peuvent pas accéder directement à la propriété <codeph>prototype</codeph>. 
	 
     <p>L’objet prototype d’une classe est une occurrence spéciale de cette classe, qui propose un mécanisme de partage d’état parmi toutes les occurrences d’une classe. Lors de l’exécution, si une propriété ne figure pas dans une occurrence de classe, elle est recherchée dans le délégué, à savoir l’objet prototype de la classe. Si l’objet prototype ne contient pas la propriété, le processus continue et le délégué de l’objet prototype effectue des recherches dans des niveaux de plus en plus élevés de la hiérarchie jusqu’à ce que <ph platform="actionscript">Flash Player ou</ph> Adobe Integrated Runtime trouve la propriété. </p>
	 
     <p platform="actionscript"><i>Remarque :</i> dans ActionScript 3.0, l’héritage de prototype ne constitue pas le principal mécanisme d’héritage. Ce rôle incombe à l’héritage de classe, qui assure l’héritage des propriétés fixes dans les définitions de classe.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:SecurityError"><apiName>SecurityError</apiName><shortdesc>
 L’exception SecurityError est renvoyée lorsqu’il se produit certains types de violation de la sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SecurityError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 L’exception <codeph>SecurityError</codeph> est renvoyée lorsqu’il se produit certains types de violation de la sécurité.
 <p>
 Exemples d’erreurs liées à la sécurité :</p>
 <ul>
   <li>Un accès à une propriété ou un appel de méthode non autorisé est effectué en franchissant les limites du sandbox de sécurité.</li>
   <li>Il s’est produit une tentative d’accès à une URL non autorisée par le sandbox de sécurité.</li>
   <li>Une connexion socket a été tentée vers un numéro de port non autorisé, tel qu’un port supérieur à 65535.</li>
   <li>Il s’est produit une tentative d’accès à la caméra ou au microphone de l’utilisateur et celui-ci a refusé la demande d’accès au périphérique.</li>
 </ul>
 
 </apiDesc><example conref="examples\SecurityErrorExample.as"> L’exemple suivant indique comment une erreur <codeph>SecurityError</codeph> peut être générée et traitée au sein d’une instruction <codeph>try...catch</codeph> en tentant de se connecter à un numéro de port qui est supérieur d’une unité au maximum autorisé.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.Socket;

    public class SecurityErrorExample extends Sprite {

        public function SecurityErrorExample() {
            try {
                var host:String = "www.[yourDomain].com";
                var socket:Socket = new Socket();
                socket.connect(host, 65536);
            }
            catch(e:SecurityError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="SecurityError:SecurityError"><apiName>SecurityError</apiName><shortdesc>
	 Crée un objet SecurityError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet SecurityError.
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
 Une exception ReferenceError est renvoyée lorsque vous tentez d’utiliser une référence à une propriété non définie pour un objet scellé (non dynamique).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, ReferenceError
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une exception ReferenceError est renvoyée lorsque vous tentez d’utiliser une référence à une propriété non définie pour un objet scellé (non dynamique). Les références à des variables non définies entraînent le renvoi d’exceptions ReferenceError pour vous avertir de bogues éventuels et vous aider à dépanner le code de l’application.
 <p>Vous pouvez cependant faire référence à des propriétés non définies d’une classe dynamique sans entraîner le renvoi d’une exception ReferenceError. Pour plus d’informations, voir le mot-clé <codeph>dynamic</codeph>.</p>
 
 </apiDesc><example conref="examples\ReferenceErrorExample.as"> L’exemple suivant indique comment générer une exception <codeph>ReferenceError</codeph> et la traiter avec une instruction <codeph>try..catch</codeph>. 
<codeblock>
package {
    import flash.display.Sprite;

    public class ReferenceErrorExample extends Sprite {

        public function ReferenceErrorExample() {
            try {
                this["someMember"] = true;
            }
            catch(e:ReferenceError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#dynamic"><linktext>mot-clé dynamique</linktext></link></related-links><apiConstructor id="ReferenceError:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
	 Crée un objet ReferenceError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Contient le message associé à l’objet ReferenceError.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet ReferenceError.
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:RangeError"><apiName>RangeError</apiName><shortdesc>
 Une exception RangeError est renvoyée si une valeur numérique excède la plage gérée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, RangeError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une exception RangeError est renvoyée si une valeur numérique excède la plage gérée. Lorsque vous traitez des tableaux, toute référence à une position d’index inexistante d’un élément du tableau renvoie une exception RangeError. L’utilisation des méthodes <codeph>Number.toExponential()</codeph>, <codeph>Number.toPrecision()</codeph> et <codeph>Number.toFixed()</codeph> renvoie une exception RangeError si les arguments excèdent la plage numérique gérée. Pour éviter de renvoyer une exception RangeError, vous pouvez étendre <codeph>Number.toExponential()</codeph>, <codeph>Number.toPrecision()</codeph> et <codeph>Number.toFixed()</codeph>.
 <p product="flash">D’autres cas de figure entraînent le renvoi de cette exception, notamment :
 <ul>
   <li>Une API Flash Player qui attend un numéro de profondeur est appelée avec une valeur de profondeur non valide.</li>
   <li>Une API Flash Player qui attend un numéro d’image est appelée avec une valeur non valide.</li>
   <li>Une API Flash Player qui attend un numéro de calque est appelée avec une valeur non valide.</li>
 </ul>
 </p>
 </apiDesc><example conref="examples\RangeErrorExample.as"> L’exemple suivant indique comment générer une exception <codeph>RangeError</codeph> et la traiter avec une instruction <codeph>try..catch</codeph>. 
<codeblock>
package {
    import flash.display.Sprite;

    public class RangeErrorExample extends Sprite {

        public function RangeErrorExample() {
            var child:Sprite = new Sprite();
            try {
                addChildAt(child, 1);
            }
            catch(e:RangeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Number/toExponential()"><linktext>Number.toExponential()</linktext></link><link href="#Number/toPrecision()"><linktext>Number.toPrecision()</linktext></link><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links><apiConstructor id="RangeError:RangeError"><apiName>RangeError</apiName><shortdesc>
	 Crée un objet RangeError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Contient le message associé à l’objet RangeError.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet RangeError.
	 </apiDesc></apiConstructorDetail><related-links><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:int"><apiName>int</apiName><shortdesc>
 La classe int vous permet de manipuler les types de données représentant un entier 32 bits signé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int object, int, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe int vous permet de manipuler les types de données représentant un entier 32 bits signé. La plage de valeurs représentées par la classe int est comprise entre -2 147 483 648 (-2^31) et 2 147 483 647 (2^32-1).
 <p>Les propriétés des constantes de la classe int, <codeph>MAX_VALUE</codeph> et <codeph>MIN_VALUE</codeph> sont statiques, ce qui signifie qu’il n’est pas nécessaire de disposer d’un objet pour les utiliser ; par conséquent, il n’est pas nécessaire d’utiliser le constructeur. En revanche, les méthodes n’étant pas statiques, vous devez utiliser un objet pour y faire appel. Pour créer un objet int, utilisez le constructeur de la classe int ou déclarez une variable de type int et affectez-lui une valeur littérale.</p>
 <p>Similaire au type de données int dans Java et C++, le type de données int s’avère utile pour les compteurs de boucles et les cas où un nombre à virgule flottante n’est pas nécessaire. La valeur par défaut d’une variable de type int correspond à <codeph>0</codeph></p>
 <p>Si vous manipulez des nombres supérieurs à <codeph>int.MAX_VALUE</codeph>, envisagez l’utilisation de Number.  </p>
 <p>L’exemple suivant appelle la méthode <codeph>toString()</codeph> de la classe int, qui renvoie la chaîne <codeph>1234</codeph> : </p>
 <codeblock rev="3.0">
 var myint:int = 1234;
 myint.toString();
 </codeblock>
 <p>L’exemple suivant affecte la valeur de la propriété <codeph>MIN_VALUE</codeph> à une variable déclarée sans l’utilisation du constructeur :</p>
 <pre>
 var smallest:int = int.MIN_VALUE;
 </pre> 
 
 </apiDesc><example conref="examples\IntExample.as"> L’exemple suivant exploite la classe <codeph>IntExample</codeph> pour indiquer comment manipuler les données de type int et vérifier leur validité :
 <ol>
     <li>Deux variables int, <codeph>a</codeph> et <codeph>b</codeph>, sont déclarées dans le constructeur.</li>
     <li>Les deux ints sont ajoutés à l’aide de la méthode <codeph>addIntegers()</codeph>.</li>
     <li>Une troisième variable int, <codeph>c</codeph> reçoit la sortie de <codeph>parseInteger()</codeph>, qui vérifie la validité de la chaîne qui lui a été transmise pour s’assurer qu’il s’agit bien d’un entier avec une plage acceptable pour les types de données int. Elle renvoie ensuite une valeur int qui est égale à l’entier de la valeur de la chaîne, si cette dernière est valide.</li>
     <li>Les variables int, <codeph>a</codeph> et <codeph>c</codeph>, sont ajoutées à l’aide de <codeph>addIntegers()</codeph>.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class IntExample extends Sprite {    
        public function IntExample() {
            var a:int = 512;
            var b:int = -128;
            
            trace(addIntegers(a, b)); // 384

            var c:int = parseInteger("32");
            
            trace(addIntegers(a, c)); // 544
        }
            
        public function addIntegers(a:int, b:int):int {
            return a + b;
        }
        
        public function parseInteger(str:String):int {
            var num:Number = parseInt(str);
            if(!isNaN(num) &amp;&amp; num &lt;= int.MAX_VALUE &amp;&amp; num >= int.MIN_VALUE) {
                return int(num);
            }
            
            return 0;
        }
        
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="uint.html"><linktext>uint</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="int:int"><apiName>int</apiName><shortdesc>
	 Constructeur qui crée un nouvel objet int.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Valeur numérique de l’objet int en cours de création, ou valeur à convertir en nombre. La valeur par défaut est 0 si <codeph>value</codeph> n’est pas fourni.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Constructeur qui crée un nouvel objet int. L’utilisation du constructeur int est obligatoire si vous utilisez <codeph>int.toString()</codeph> et <codeph>int.valueOf()</codeph>. Ne faites pas appel à un constructeur si vous utilisez les propriétés d’un objet int. Le constructeur <codeph>new int</codeph> sert surtout d’espace réservé. Ne confondez pas l’objet int avec la fonction <codeph>int()</codeph>, qui convertit un paramètre en valeur primitive.
	 
 	 </apiDesc><example>Le code suivant crée de nouveaux objets int :
	 <pre>
	 var n1:int = new int(3.4);
	 var n2:int = new int(-10);
	 </pre>
	 
	 
	 </example></apiConstructorDetail><related-links><link href="#int/toString()"><linktext>int.toString()</linktext></link><link href="#int/valueOf()"><linktext>int.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="int:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>fractionDigits</codeph> n’est pas compris entre 0 et 20.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 0 et 20 inclus qui représente le nombre requis de décimales.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle. La chaîne contient un chiffre avant la virgule et jusqu’à 20 décimales, comme spécifié par le paramètre <codeph>fractionDigits</codeph>.
      </apiDesc><example conref="examples\Number.toExponential.1.as"> L’exemple suivant indique comment <codeph>toExponential(2)</codeph> renvoie une chaîne sous forme de notation exponentielle.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     Renvoie une représentation sous forme de chaîne du nombre en notation à virgule fixe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>fractionDigits</codeph> n’est pas compris entre 0 et 20.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 0 et 20 inclus qui représente le nombre requis de décimales.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie une représentation sous forme de chaîne du nombre en notation à virgule fixe. La notation à virgule fixe signifie que la chaîne contiendra un nombre spécifique de décimales, indiqué par le paramètre <codeph>fractionDigits</codeph>. Le paramètre <codeph>fractionDigits</codeph> gère une plage de valeurs comprises entre 0 et 20. Spécifier une valeur qui excède cette plage entraîne le renvoi d’une exception.
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> L’exemple suivant indique comment <codeph>toFixed(3)</codeph> renvoie une chaîne qui arrondit le résultat à trois chiffres après la virgule.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> L’exemple suivant indique comment <codeph>toFixed(2)</codeph> renvoie une chaîne qui ajoute des zéros à la fin.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle ou à virgule fixe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>precision</codeph> n’est pas compris entre 1 et 21.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 1 et 21 inclus qui indique le nombre requis de décimales dans la chaîne générée.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle ou à virgule fixe. La chaîne contiendra le nombre de décimales spécifié par le paramètre <codeph>precision</codeph>.
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> L’exemple suivant indique comment <codeph>toPrecision(3)</codeph> renvoie une chaîne limitée à trois chiffres. La chaîne recourt à la notation à point fixe, dans la mesure où la notation exponentielle n’est pas requise.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> L’exemple suivant indique comment <codeph>toPrecision(3)</codeph> renvoie une chaîne limitée à trois chiffres. La chaîne applique la notation exponentielle dans la mesure où le nombre qui en résulte ne contient pas suffisamment de chiffres pour la notation à point fixe.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Renvoie la représentation sous forme de chaîne d’un objet int.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Chaîne.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Spécifie la base numérique (de 2 à 36) à appliquer pour la conversion nombre vers chaîne. Si vous omettez le paramètre <codeph>radix</codeph>, la valeur par défaut est de 10.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie la représentation sous forme de chaîne d’un objet <codeph>int</codeph>.
	 
	 </apiDesc><example>L’exemple suivant utilise 2 et 8 pour le paramètre <codeph>radix</codeph> et renvoie une chaîne qui contient la représentation correspondante du numéro 9 :
	 <pre>
	 var myint:int = new int(9);
	 trace(myint.toString(2)); // 1001
	 trace(myint.toString(8)); // 11
	 </pre>
	 <p>L’exemple suivant renvoie une valeur hexadécimale.</p>
	 <pre>
	 var r:int = new int(250);
	 var g:int = new int(128);
	 var b:int = new int(114);
	 var rgb:String = "0x"+ r.toString(16)+g.toString(16)+b.toString(16);
	 trace(rgb); // 0xfa8072
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Renvoie la valeur primitive de l’objet int spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur int.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la valeur primitive de l’objet int spécifié.
	 
 	 </apiDesc><example>L’exemple suivant a pour résultat la valeur primitive de l’objet <codeph>numSocks</codeph>.
	 <pre>
	 var numSocks:int = new int(2);
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="int:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	Entier signé 32 bits représentable le plus élevé, soit 2 147 483 647.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2147483647</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
	Entier signé 32 bits représentable le plus élevé, soit 2 147 483 647.
	
    </apiDesc><example>Le code ActionScript suivant <ph outputclass="flashonly">affiche</ph><ph outputclass="flexonly">écrit</ph> l’objet int représentable le plus élevé et l’objet int représentable le plus faible <ph outputclass="flashonly">dans le panneau Sortie</ph><ph outputclass="flexonly">dans le fichier journal</ph> :
	<pre>
	trace("int.MIN_VALUE = "+int.MIN_VALUE);
	trace("int.MAX_VALUE = "+int.MAX_VALUE);
	</pre>
	<p>Ce code <ph outputclass="flexonly">inscrit dans le fichier journal</ph><ph outputclass="flashonly">affiche</ph> les valeurs suivantes :</p>
	<pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
	</pre>
	
	
	</example></apiValueDetail></apiValue><apiValue id="int:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 Entier signé 32 bits représentable le plus faible, soit -2 147 483 648.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>-2147483648</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Entier signé 32 bits représentable le plus faible, soit -2 147 483 648.
	 
 	 </apiDesc><example>Le code ActionScript suivant <ph outputclass="flashonly">affiche</ph><ph outputclass="flexonly">écrit</ph> les objets int représentables le plus élevé et le plus faible dans le <ph outputclass="flashonly">panneau Sortie</ph><ph outputclass="flexonly">dans le fichier journal</ph> :
     <pre>
     trace("int.MIN_VALUE = "+int.MIN_VALUE);
     trace("int.MAX_VALUE = "+int.MAX_VALUE);
     </pre>
     <p>Ce code <ph outputclass="flexonly">inscrit dans le fichier journal</ph><ph outputclass="flashonly">affiche</ph> les valeurs suivantes :</p>
     <pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
     </pre>
     
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Number"><apiName>Number</apiName><shortdesc>
 Type de données représentant un nombre à virgule flottante à deux décimales conforme à IEEE -754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number object, number, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>La classe Number est une enveloppe simple dédiée au type de données <codeph>Number</codeph>.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Type de données représentant un nombre à virgule flottante à deux décimales conforme à IEEE -754. Vous pouvez manipuler des valeurs numériques primitives à l’aide des méthodes et des propriétés associées à la classe Number. Cette classe est identique à la classe JavaScript Number.
 <p>Les propriétés de la classe Number sont statiques, ce qui signifie qu’il n’est pas nécessaire de disposer d’un objet pour les utiliser ; par conséquent, il n’est pas nécessaire d’utiliser le constructeur.</p>
 <p>Le type de données Number est conforme à la norme IEEE-754 relative aux nombres à deux décimales. </p>
 <p>Il s’avère utile lorsque vous utilisez des valeurs à virgule flottante. Flash Player gère mieux les types de données int et uint que Number, mais Number est utile lorsque la plage de valeurs requises excède la plage valide des types de données int et uint. La classe Number permet de représenter des valeurs d’entier qui dépassent nettement la plage valide des types de données int et uint. Le type de données Number utilise jusqu’à 53 bits pour représenter les valeurs d’entier, alors que int et uint sont limités à 32 bits. La valeur par défaut d’une variable de type Number est <codeph>NaN</codeph> (n’est pas un nombre).</p>
 
 </apiDesc><example conref="examples\NumberExample.as"> L’exemple suivant indique comment un nombre à six chiffres après la virgule est tronqué et arrondi pour obtenir avec un nombre à deux chiffres après la virgule.
<codeblock>

package {
    import flash.display.Sprite;

    public class NumberExample extends Sprite {
        public function NumberExample() {
            var num:Number = new Number(10.456345);
            var str:String = num.toFixed(2);
            trace(num); // 10.456345
            trace(str); // 10.46
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="uint.html"><linktext>uint</linktext></link></related-links><apiConstructor id="Number:Number"><apiName>Number</apiName><shortdesc>
  Crée un objet Number à la valeur spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>La valeur numérique de l’occurrence de Number en cours de création, ou valeur à convertir en objet Number. La valeur par défaut est de 0 si <codeph>num</codeph> n’est pas spécifié. Utiliser le constructeur sans spécifier de paramètre <codeph>num</codeph> n’est pas équivalent à la déclaration d’une variable de type Number à laquelle n’est affectée aucune valeur (telle que <codeph>var myNumber:Number</codeph>), qui correspond par défaut à <codeph>NaN</codeph>. Un nombre auquel n’est pas affectée de valeur n’est pas défini et constitue l’équivalent de <codeph>new Number(undefined)</codeph>.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Crée un objet Number à la valeur spécifiée.
  
  </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
  Crée un objet Number à la valeur spécifiée. L’effet de ce constructeur est identique à celui de la fonction native publique <codeph>Number()</codeph>, qui convertit un objet d’un autre type en valeur numérique primitive.
  
  </apiDesc></apiConstructorDetail><related-links><link href="#Number/toString()"><linktext>Number.toString()</linktext></link><link href="#Number/valueOf()"><linktext>Number.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="Number:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
	  Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>fractionDigits</codeph> n’est pas compris entre 0 et 20.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 0 et 20 inclus qui représente le nombre requis de décimales.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle. La chaîne contient un chiffre avant la virgule et jusqu’à 20 décimales, comme spécifié par le paramètre <codeph>fractionDigits</codeph>.
	  </apiDesc><example conref="examples\Number.toExponential.1.as"> L’exemple suivant indique comment <codeph>toExponential(2)</codeph> renvoie une chaîne sous forme de notation exponentielle.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
	 Renvoie une représentation sous forme de chaîne du nombre en notation à virgule fixe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>fractionDigits</codeph> n’est pas compris entre 0 et 20.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 0 et 20 inclus qui représente le nombre requis de décimales.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une représentation sous forme de chaîne du nombre en notation à virgule fixe. La notation à virgule fixe signifie que la chaîne contiendra un nombre spécifique de décimales, indiqué par le paramètre <codeph>fractionDigits</codeph>. Le paramètre <codeph>fractionDigits</codeph> gère une plage de valeurs comprises entre 0 et 20. Spécifier une valeur qui excède cette plage entraîne le renvoi d’une exception.
	 
	 </apiDesc><example conref="examples\Number.toFixed.1.as"> L’exemple suivant indique comment <codeph>toFixed(3)</codeph> renvoie une chaîne qui arrondit le résultat à trois chiffres après la virgule.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> L’exemple suivant indique comment <codeph>toFixed(2)</codeph> renvoie une chaîne qui ajoute des zéros à la fin.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
	  Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle ou à virgule fixe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>precision</codeph> n’est pas compris entre 1 et 21.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 1 et 21 inclus qui indique le nombre requis de décimales dans la chaîne générée.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle ou à virgule fixe. La chaîne contiendra le nombre de décimales spécifié par le paramètre <codeph>precision</codeph>.
	  </apiDesc><example conref="examples\Number.toPrecision.1.as"> L’exemple suivant indique comment <codeph>toPrecision(3)</codeph> renvoie une chaîne limitée à trois chiffres. La chaîne recourt à la notation à point fixe, dans la mesure où la notation exponentielle n’est pas requise.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> L’exemple suivant indique comment <codeph>toPrecision(3)</codeph> renvoie une chaîne limitée à trois chiffres. La chaîne applique la notation exponentielle dans la mesure où le nombre qui en résulte ne contient pas suffisamment de chiffres pour la notation à point fixe.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toString"><apiName>toString</apiName><shortdesc>
 Renvoie la représentation sous la forme d’une chaîne spécifiant l’objet Number spécifié (myNumber).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation numérique de l’objet Number sous forme de chaîne.
 
 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>10</apiData><apiDesc>Spécifie la base numérique (de 2 à 36) à appliquer pour la conversion nombre vers chaîne. Si vous omettez le paramètre <codeph>radix</codeph>, la valeur par défaut est de 10.
 
 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la représentation sous forme de chaîne de cet objet Number en utilisant le paramètre de base spécifié comme base numérique.
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 Renvoie la représentation sous la forme d’une chaîne spécifiant l’objet Number spécifié (<codeph><i>myNumber</i></codeph>). Si la valeur de l’objet Number est un nombre décimal sans zéro à gauche (tel que <codeph>0,4</codeph>), <codeph>Number.toString()</codeph> ajoute le zéro (<codeph>0,4</codeph>).
 
 
 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
 Renvoie le type de valeur primitive de l’objet Number spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur de type primitive de l’objet Number.
 
 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie le type de valeur primitive de l’objet Number spécifié.
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 Renvoie le type de valeur primitive de l’objet Number spécifié.
 
 </apiDesc></apiOperationDetail></apiOperation><apiValue id="Number:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc>
  Nombre représentable le plus élevé (à deux décimales conformément à IEEE-754).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.max_value, max_value, max value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Nombre représentable le plus élevé (à deux décimales conformément à IEEE-754).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Nombre représentable le plus élevé (à deux décimales conformément à IEEE-754). La valeur de ce nombre est d’environ 1,79e+308.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
  Nombre représentable le plus faible non négatif et non égal à zéro (à deux décimales conformément à IEEE-754).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.min_value, min_value, min value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Nombre représentable le plus faible (comportant deux décimales conformément à IEEE-754).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Nombre représentable le plus faible non négatif et non égal à zéro (à deux décimales conformément à IEEE-754). La valeur de ce nombre est d’environ 5e-324. Le nombre représentable le plus faible globalement est en fait <codeph>-Number.MAX_VALUE</codeph>.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NEGATIVE_INFINITY"><apiName>NEGATIVE_INFINITY</apiName><shortdesc>
  Spécifie la valeur IEEE-754 représentant l’infini négatif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.negative_infinity, negative_infinity, negative infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Spécifie la valeur IEEE-754 représentant l’infini négatif.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Spécifie la valeur IEEE-754 représentant l’infini négatif. La valeur de cette propriété est identique à celle de la constante <codeph>-Infinity</codeph>.
  <p>
  L’infini négatif est une valeur numérique spéciale renvoyée lorsqu’une opération mathématique ou une fonction renvoie une valeur négative supérieure à celle pouvant être représentée.
  </p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NaN"><apiName>NaN</apiName><shortdesc>
  Valeur IEEE-754 ne représentant pas une valeur numérique (NaN).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.nan, nan, not a number
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Valeur IEEE-754 ne représentant pas une valeur numérique (NaN).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Valeur IEEE-754 ne représentant pas une valeur numérique (<codeph>NaN</codeph>).
  
  </apiDesc></apiValueDetail><related-links><link href="package.html#isNaN()"><linktext>isNaN()</linktext></link></related-links></apiValue><apiValue id="Number:POSITIVE_INFINITY"><apiName>POSITIVE_INFINITY</apiName><shortdesc>
  Spécifie la valeur IEEE-754 représentant l’infini positif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.positive_infinity, positive_infinity, positive infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Spécifie la valeur IEEE-754 représentant l’infini positif.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Spécifie la valeur IEEE-754 représentant l’infini positif. La valeur de cette propriété est identique à celle de la constante <codeph>Infinity</codeph>.
  <p>
  L’infini positif est une valeur numérique spéciale renvoyée lorsqu’une opération mathématique ou une fonction renvoie une valeur supérieure à celle pouvant être représentée.
  </p>
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
 La classe DefinitionError représente une erreur qui se produit lorsque le code utilisateur tente de définir un identificateur qui est déjà défini.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Une erreur DefinitionError est renvoyée lorsque le code tente de redéfinir une classe, une interface ou une fonction.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe DefinitionError représente une erreur qui se produit lorsque le code utilisateur tente de définir un identificateur qui est déjà défini. Cette erreur se produit généralement lors de la redéfinition de classes, d’interfaces et de fonctions.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="DefinitionError:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
	 Crée un objet DefinitionError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet DefinitionError.
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Function"><apiName>Function</apiName><shortdesc>
 Une fonction constitue l’unité de base du code que vous pouvez appeler dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>La classe Function permet de représenter une fonction intégrée ou définie par l’utilisateur.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une fonction constitue l’unité de base du code que vous pouvez appeler dans ActionScript. Les fonctions définies par l’utilisateur et les fonctions intégrées à ActionScript sont représentées par des objets Function, qui sont des occurrences de la classe Function.
 <p>Les méthodes d’une classe sont légèrement différentes des objets Function. A l’encontre d’un objet Function standard, une méthode est étroitement liée à l’objet de classe associé. De ce fait, une méthode ou une propriété possède une définition partagée par toutes les occurrences d’une même classe. Les méthodes peuvent être extraites d’une occurrence et traitées comme si elles étaient « liées » (en d’autres termes, comme des méthodes qui conservent le lien à l’occurrence d’origine). Pour une méthode liée, le mot-clé <codeph>this</codeph> pointe vers l’objet d’origine qui a implémenté la méthode. Pour une fonction, <codeph>this</codeph> pointe vers l’objet associé lors de l’appel de la fonction.</p>
 
 
 </apiDesc><example conref="examples\FunctionExample.as"> L’exemple suivant a recours aux classes <codeph>FunctionExample</codeph>, <codeph>SimpleCollection</codeph>, <codeph>EventBroadcaster</codeph> et <codeph>EventListener</codeph> pour présenter les différentes utilisations des fonctions dans ActionScript. Cette opération se déroule selon la procédure suivante :
 <ol>
    <li>Le constructeur de <codeph>FunctionExample</codeph> crée une variable locale appelée <codeph>simpleColl</codeph>, qui est remplie par un tableau d’entiers allant de <codeph>1</codeph> à <codeph>8</codeph>. </li>
    <li>L’objet <codeph>simpleColl</codeph> est imprimé à l’aide de la méthode <codeph>trace()</codeph>.</li>
  <li>Un objet EventListener, <codeph>listener</codeph>, est ajouté à <codeph>simpleColl</codeph>.</li>
  <li>Lorsque les fonctions <codeph>insert()</codeph> et <codeph>remove()</codeph> sont appelées, l’écouteur répond à leurs événements.</li>
    <li>Un deuxième objet SimpleCollection est créé sous le nom <codeph>greaterThanFourColl</codeph>.</li>
    <li>L’objet <codeph>greaterThanFourColl</codeph> se voit affecter le résultat de <codeph>simpleColl.select()</codeph> avec l’argument <codeph>4</codeph> et une fonction anonyme. La méthode de sélection de l’objet SimpleCollection est un itérateur interne qui utilise le paramètre de fonction anonyme en tant que bloc.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class FunctionExample extends Sprite {
        public function FunctionExample() {
            var simpleColl:SimpleCollection;
            simpleColl = new SimpleCollection(0, 1, 2, 3, 4, 5, 6, 7, 8);
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 8

            var listener:EventListener = new EventListener();
            simpleColl.addListener(listener);
            simpleColl.insert(9);        // itemInsertedHandler: 9
            simpleColl.remove(8);        // itemRemovedHandler: 8
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 9

            var greaterThanFourColl:SimpleCollection;
            greaterThanFourColl = simpleColl.select(4, function(item:int, value:int){ return item > value });
            trace(greaterThanFourColl);    // 5, 6, 7, 9
        }
    }
}
    
import flash.display.Sprite;
    
class EventBroadcaster {
    private var listeners:Array;

    public function EventBroadcaster() {
        listeners = new Array();
    }
        
    public function addListener(obj:Object):void {
        removeListener(obj);
        listeners.push(obj);
    }
        
    public function removeListener(obj:Object):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            if(listeners[i] == obj) {
                listeners.splice(i, 1);
            }
        }
    }
    
    public function broadcastEvent(evnt:String, ...args):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            listeners[i][evnt].apply(listeners[i], args);
        }
    }    
}
    
class SimpleCollection extends EventBroadcaster {
    private var arr:Array;
        public function SimpleCollection(... args) {
        arr = (args.length == 1 &amp;&amp; !isNaN(args[0])) ? new Array(args[0]) : args;
    }
        
    public function insert(obj:Object):void {
        remove(obj);
        arr.push(obj);
        broadcastEvent("itemInsertedHandler", obj);
    }
        
    public function remove(obj:Object):void {
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(arr[i] == obj) {
                var obj:Object = arr.splice(i, 1)[0];
                broadcastEvent("itemRemovedHandler", obj);
            }
        }
    }

    public function select(val:int, fn:Function):SimpleCollection {
        var col:SimpleCollection = new SimpleCollection();
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(fn.call(this, arr[i], val)) {
                col.insert(arr[i]);
            }
        }
        return col;
    }
        
    public function toString():String {
        var str:String = new String();
        for(var i:uint = 0; i &lt; arr.length - 1; i++) {
            str += arr[i] + ", ";
        }
        str += arr[arr.length - 1];
        return str;
    }
}

class EventListener {
    public function EventListener() {
    }
    
    public function itemInsertedHandler(obj:Object):void {
        trace("itemInsertedHandler: " + obj);
    }
    
    public function itemRemovedHandler(obj:Object):void {
        trace("itemRemovedHandler: " + obj);        
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="Function:AS3:apply"><apiName>apply</apiName><shortdesc>
  Spécifie la valeur thisObject à utiliser dans toute fonction appelée par ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.apply, apply
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Toute valeur spécifiée par la fonction appelée.
  
  
  </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Objet auquel s’applique la fonction.
  
  </apiDesc></apiParam><apiParam><apiItemName>argArray</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Tableau dont les éléments sont transmis à la fonction en tant que paramètres.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Spécifie l’occurrence d’objet pour laquelle est appelée la fonction.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Spécifie la valeur <codeph>thisObject</codeph> à utiliser dans toute fonction appelée par ActionScript. Cette méthode spécifie également les paramètres à transmettre à toute fonction appelée. Dans la mesure où <codeph>apply()</codeph> est une méthode de la classe Function, c’est également une méthode de chaque objet Function dans ActionScript. 
  <p>Les paramètres sont spécifiés sous forme d’objet Array, contrairement à <codeph>Function.call()</codeph> qui spécifie les paramètres en tant que liste délimitée par des virgules. Ceci est souvent utile lorsque le nombre de paramètres à transmettre n’est pas connu avant l’exécution du script.</p>
  <p>Renvoie la valeur spécifiée en tant que valeur renvoyée par la fonction appelée.</p>

  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/call()"><linktext>Function.call()</linktext></link></related-links></apiOperation><apiOperation id="Function:AS3:call"><apiName>call</apiName><shortdesc>
  Appelle la fonction représentée par un objet Function.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.call, call
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Objet qui spécifie la valeur de <codeph>thisObject</codeph> dans le corps de la fonction.
  
  </apiDesc></apiParam><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Paramètre ou paramètres à transmettre à la fonction. Vous pouvez spécifier zéro ou plusieurs paramètres.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Appelle cette fonction. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Appelle la fonction représentée par un objet Function. Toutes les fonctions dans ActionScript sont représentées par un objet Function, de sorte que toutes les fonctions prennent en charge cette méthode. 
  <p>Dans presque tous les cas, l’opérateur d’appel de fonction (<codeph>()</codeph>) peut être utilisé au lieu de cette méthode. L’opérateur de la fonction call génère un code concis et lisible. Cette méthode est surtout utile lorsque le paramètre <codeph>thisObject</codeph> de l’appel de fonction doit être explicitement contrôlé. Normalement, si une fonction est appelée en tant que méthode d’un objet, dans le corps de la fonction, <codeph>thisObject</codeph> est défini sur <codeph>myObject</codeph>, comme illustré dans l’exemple suivant :</p>
  <codeblock>
  myObject.myMethod(1, 2, 3);
  </codeblock>
  <p>Dans certains cas, il peut être souhaitable que <codeph>thisObject</codeph> pointe autre part ; par exemple, si une fonction doit être appelée en tant que méthode d’un objet alors qu’elle n’est pas stockée comme méthode de cet objet :</p>
  <codeblock>
  myObject.myMethod.call(myOtherObject, 1, 2, 3); 
  </codeblock>
  <p>Vous pouvez transmettre la valeur <codeph>null</codeph> au paramètre <codeph>thisObject</codeph> pour appeler une fonction en tant que fonction ordinaire et non en tant que méthode d’un objet. Par exemple, les appels de fonction suivantes sont équivalentes :</p>
  <codeblock>
  Math.sin(Math.PI / 4)
  Math.sin.call(null, Math.PI / 4)
  </codeblock>
  
  <p>Renvoie la valeur spécifiée en tant que valeur renvoyée par la fonction appelée.</p>
  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/apply()"><linktext>Function.apply()</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="globalClassifier:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
 Une exception SyntaxError est renvoyée lorsqu’une erreur d’analyse se produit, pour l’une des raisons suivantes :</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SyntaxError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une exception SyntaxError est renvoyée lorsqu’une erreur d’analyse se produit, pour l’une des raisons suivantes : 
 <ul>
   <li>Une expression régulière non valide est analysée par la classe RegExp.</li>
   <li>Du contenu XML non valide est analysé par la classe XML.</li>
 </ul>
 
 </apiDesc></apiClassifierDetail><related-links><link href="#RegExp"><linktext>Classe RegExp</linktext></link><link href="#XML"><linktext>Classe XML</linktext></link></related-links><apiConstructor id="SyntaxError:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
	 Crée un objet SyntaxError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Contient le message associé à l’objet SyntaxError. 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet SyntaxError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Boolean"><apiName>Boolean</apiName><shortdesc>
Utilisé pour les opérations logiques, un objet Boolean est un type de données réglé soit sur true, soit sur false.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>Objects/Core/Boolean/
 
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Utilisé pour les opérations logiques, un objet Boolean est un type de données réglé soit sur <codeph>true</codeph> ou <codeph>false</codeph>. Utilisez la classe Boolean pour extraire le type de données primitive ou la représentation sous forme de chaîne d’un objet booléen. 

<p>Pour créer un objet Boolean, vous pouvez utiliser le constructeur ou la fonction globale, ou affecter une valeur littérale. Utilisez la technique de votre choix, car elles sont toutes trois équivalentes dans ActionScript 3.0 (à l’encontre de JavaScript, où un objet Boolean et le type de primitive Boolean sont deux entités distinctes).</p>

  <p>Les lignes de code suivantes sont équivalentes :</p>
<codeblock rev="3.0">
var flag:Boolean = true;
var flag:Boolean = new Boolean(true);
var flag:Boolean = Boolean(true);
</codeblock>

 </apiDesc><example conref="examples\BooleanExample.as"> L’exemple suivant permet de sélectionner tour à tour et afficher toutes les valeurs correspondant à l’objet Boolean :
<codeblock>
 package {
    import flash.display.Sprite;

    public class BooleanExample extends Sprite {
        private var flag:Boolean;

        public function BooleanExample() {
            trace(flag);    // false
            toggle();
            trace(flag);    // true
            toggle();
            trace(flag);    // false
        }
        
        private function toggle():void{
            flag = !flag;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Boolean:Boolean"><apiName>Boolean</apiName><shortdesc>
 Crée un objet Boolean à la valeur spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new boolean, constructor
  
  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>Toute expression. 
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Crée un objet Boolean à la valeur spécifiée. Si vous omettez le paramètre <codeph>expression</codeph>, l’objet Boolean est initialisé avec la valeur <codeph>false</codeph>. Si vous spécifiez une valeur pour le paramètre <codeph>expression</codeph>, la méthode l’évalue et renvoie le résultat sous forme de valeur booléenne conformément aux règles de la fonction globale <codeph>Boolean()</codeph>.
 
 </apiDesc><example>Le code suivant crée un objet Boolean, initialisé à la valeur <codeph>false</codeph> et appelé <codeph>myBoolean</codeph> :
 <codeblock rev="3.0">
 var myBoolean:Boolean = new Boolean();
 </codeblock>
 
 </example></apiConstructorDetail><related-links><link href="package.html#Boolean()"><linktext>Boolean()</linktext></link></related-links></apiConstructor><apiOperation id="Boolean:AS3:toString"><apiName>toString</apiName><shortdesc>
	  Renvoie la représentation de l’objet booléen sous forme de chaîne (« true » ou « false »).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Chaîne <codeph>"true"</codeph> ou <codeph>"false"</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Renvoie la représentation de l’objet booléen sous forme de chaîne (<codeph>"true"</codeph> ou <codeph>"false"</codeph>). La sortie n’est pas traduite et correspond à <codeph>"true"</codeph> ou <codeph>"false"</codeph> quelle que soit la langue du système en vigueur.
	 
 	 </apiDesc><example>Cet exemple crée une variable de type booléen et utilise la méthode <codeph>toString()</codeph> pour convertir la valeur en chaîne à utiliser dans un tableau de chaînes :
	 <codeblock rev="3.0">
	 var myStringArray:Array = new Array("yes", "could be");
	 var myBool:Boolean = 0;
	 myBool.toString();
	 myStringArray.push(myBool);
	 trace(myStringArray); // yes,could be,false
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="Boolean:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Renvoie true si la valeur de l’objet Boolean spécifié est true, false dans le cas contraire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.valueOf, valueOf
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur booléenne.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie <codeph>true</codeph> si la valeur de l’objet Boolean spécifié est true, <codeph>false</codeph> dans le cas contraire.  
	 
	 </apiDesc><example>L’exemple suivant indique le mode de fonctionnement de cette méthode et montre également que la valeur d’un nouvel objet Boolean est <codeph>false</codeph> :
	 <codeblock rev="3.0">
	 var myBool:Boolean = new Boolean();
	 trace(myBool.valueOf());   // false
	 myBool = (6==3+3);
	 trace(myBool.valueOf());   // true  
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:XMLList"><apiName>XMLList</apiName><shortdesc>
 La classe XMLList contient des méthodes qui permettent de traiter au moins un élément XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XMLList
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe XMLList contient des méthodes qui permettent de traiter au moins un élément XML. Un objet XMLList peut représenter au moins un objet ou un élément XML (ce qui inclut les nœuds multiples ou les attributs), de façon à pouvoir appeler des méthodes sur les éléments en tant que groupe ou sur les différents éléments de la collection.
 <p>Si un objet XMLList ne comporte qu’un seul élément XML, vous pouvez utiliser les méthodes de classe XML directement sur l’objet XMLList. Dans l’exemple suivant, <codeph>example.two</codeph> est un objet XMLList de longueur 1. Vous pouvez donc lui appliquer toute méthode XML.</p>
 <codeblock>
 var example2 = &lt;example>&lt;two>2&lt;/two>&lt;/example>;</codeblock>
 <p>Si vous tentez d’utiliser des méthodes de classe XML avec un objet XMLList contenant plusieurs objets XML, une exception est renvoyée. Vous pouvez par contre, effectuer une itération sur la collection XMLList (à l’aide d’une instruction <codeph>for each..in</codeph>, par exemple) et appliquer les méthodes aux différents objets XML de la collection.</p>
 
 </apiDesc><example conref="examples\XMLListExample.as"> L’exemple suivant crée une propriété XML appelée <codeph>books</codeph> et ajoute plusieurs éléments avec des balises <codeph>book publisher</codeph> et <codeph>name</codeph> à un nœud appelé <codeph>books</codeph>. Ensuite, la méthode <codeph>showBooksByPublisher()</codeph> est appelée, ce qui prend XMLList et renvoie tous les éléments qui correspondent à l’éditeur, « Addison-Wesley ».
<codeblock>
package {
    import flash.display.Sprite;

    public class XMLListExample extends Sprite {
        private var books:XML;

        public function XMLListExample() {
            books =    &lt;books>
                        &lt;book publisher="Addison-Wesley" name="Design Patterns" />
                        &lt;book publisher="Addison-Wesley" name="The Pragmatic Programmer" />
                        &lt;book publisher="Addison-Wesley" name="Test Driven Development" />
                        &lt;book publisher="Addison-Wesley" name="Refactoring to Patterns" />
                        &lt;book publisher="O'Reilly Media" name="The Cathedral &amp; the Bazaar" />
                        &lt;book publisher="O'Reilly Media" name="Unit Test Frameworks" />
                    &lt;/books>;

            showBooksByPublisher("Addison-Wesley");
        }

        private function showBooksByPublisher(name:String):void {
            var results:XMLList = books.book.(@publisher == name);
            showList(results);
        }

        private function showList(list:XMLList):void {
            var item:XML;
            for each(item in list) {
                trace("item: " + item.toXMLString());
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="statements.html#for_each..in"><linktext>for each..in</linktext></link><link href="#Namespace"><linktext>Espace de nom </linktext></link><link href="#QName"><linktext>QName</linktext></link></related-links><apiConstructor id="XMLList:XMLList"><apiName>XMLList</apiName><shortdesc>
	Crée un objet XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList 
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Tout objet qui peut être converti en objet XMLList à l’aide de la fonction de niveau supérieur <codeph>XMLList()</codeph>.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Crée un objet XMLList.
	
	</apiDesc></apiConstructorDetail><related-links><link href="#global/XMLList()"><linktext>top-level XMLList(), fonction</linktext></link></related-links></apiConstructor><apiOperation id="XMLList:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	Appelle la méthode attribute() de chaque objet XML et renvoie un objet XMLList contenant les résultats.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList composé d’objets XML correspondants ou vide.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>Nom de l’attribut à inclure dans un objet XMLList.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Appelle la méthode <codeph>attribute()</codeph> de chaque objet XML et renvoie un objet XMLList contenant les résultats. Les résultats correspondent au paramètre <codeph>attributeName</codeph> spécifié. Si aucune correspondance n’est détectée, la méthode <codeph>attribute()</codeph> renvoie un objet XMLList vide.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	Appelle la méthode attributes() de chaque objet XML et renvoie un objet XMLList contenant les attributs de chaque objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les attributs de chaque objet XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Appelle la méthode <codeph>attributes()</codeph> de chaque objet XML et renvoie un objet XMLList contenant les attributs de chaque objet XML. 
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:child"><apiName>child</apiName><shortdesc>
	Appelle la méthode child() de chaque objet XML et renvoie un objet XMLList contenant les résultats classés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les nœuds enfant qui correspondent au paramètre d’entrée.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Nom de l’élément ou entier de l’objet XML enfant.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Appelle la méthode <codeph>child()</codeph> de chaque objet XML et renvoie un objet XMLList contenant les résultats classés.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:children"><apiName>children</apiName><shortdesc>
	Appelle la méthode children() de chaque objet XML et renvoie un objet XMLList contenant les résultats.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les enfants des objets XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Appelle la méthode <codeph>children()</codeph> de chaque objet XML et renvoie un objet XMLList contenant les résultats.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/children()"><linktext>XML.children()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:comments"><apiName>comments</apiName><shortdesc>
	Appelle la méthode comments() de chaque objet XML et renvoie un objet XMLList contenant des commentaires.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les commentaires associés aux objets XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Appelle la méthode <codeph>comments()</codeph> de chaque objet XML et renvoie un objet XMLList contenant des commentaires.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/comments()"><linktext>XML.comments()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:contains"><apiName>contains</apiName><shortdesc>
	Vérifie si l’objet XMLList contient un objet XML égal au paramètre value spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet XMLList contient l’objet XML déclaré dans le paramètre <codeph>value</codeph>, <codeph>false</codeph> dans tous les autres cas.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Objet XML à comparer à l’objet XMLList en cours. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vérifie si l’objet XMLList contient un objet XML égal au paramètre <codeph>value</codeph> spécifié.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:copy"><apiName>copy</apiName><shortdesc>
	Renvoie une copie de l’objet XMLList spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Copie de l’objet XMLList.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de l’objet XMLList spécifié. Cette copie est une duplication de l’arborescence entière de nœuds. L’objet XML copié ne possède pas de parent et renvoie <codeph>null</codeph> si vous tentez d’appeler la méthode <codeph>parent()</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	Renvoie tous les descendants (enfants, petits-enfants, arrière-petits-enfants, etc.) de l’objet XML associés au paramètre name indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les descendants (enfants, petits-enfants, etc.) correspondants des objets XML spécifiés dans la liste d’origine. S’il n’existe pas de descendants, la méthode renvoie un objet XMLList vide.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Nom de l’élément pour lequel établir une correspondance.
	
 	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Renvoie tous les descendants (enfants, petits-enfants, arrière-petits-enfants, etc.) de l’objet XML associés au paramètre <codeph>name</codeph> indiqué. Le paramètre <codeph>name</codeph> peut être un objet QName, un type de données String ou tout autre type de données converti ensuite au type de données String.
	
	<p>Pour renvoyer tous les descendants, utilisez le paramètre astérisque (~~). Si aucun paramètre n’est transmis, la chaîne « ~~ » est transmise et renvoie tous les descendants de l’objet XML.</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/descendants()"><linktext>XML.descendants()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:elements"><apiName>elements</apiName><shortdesc>
	Appelle la méthode elements() de chaque objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.elements, elements
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les éléments enfant correspondants des objets XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Nom des éléments pour lesquels une correspondance doit être établie.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Appelle la méthode <codeph>elements()</codeph> de chaque objet XML. Le paramètre <codeph>name</codeph> est transmis à la méthode <codeph>descendants()</codeph>. Si aucun paramètre n’est transmis, la chaîne « ~~ » est transmise à la méthode <codeph>descendants()</codeph>.
	
 	</apiDesc></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	Vérifie si l’objet XMLList intègre un contenu complexe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet XMLList intègre un contenu complexe, <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Vérifie si l’objet XMLList intègre un contenu complexe. Un objet XMLList est considéré comme complexe s’il n’est pas vide et que l’une des deux conditions suivantes est remplie : 
	
	<ul>
	  <li>L’objet XMLList contient un élément XML unique au contenu complexe.</li>
	  <li>L’objet XMLList contient des éléments.</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	Recherche la propriété spécifiée par p.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si le paramètre existe, <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Propriété pour laquelle établir une correspondance.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Recherche la propriété spécifiée par <codeph>p</codeph>. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	Vérifie si l’objet XMLList intègre un contenu simple.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet XMLList intègre un contenu simple, <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Vérifie si l’objet XMLList intègre un contenu simple. Un objet XMLList est considéré comme simple si une ou plusieurs des conditions ci-dessous sont remplies :
	<ul>
	  <li>L’objet XMLList est vide.</li>
	  <li>L’objet XMLList contient un élément XML unique au contenu simple.</li>
	  <li>L’objet XMLList ne contient pas d’élément.</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:length"><apiName>length</apiName><shortdesc>
	Renvoie le nombre de propriétés de l’objet XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nombre de propriétés de l’objet XMLList. 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie le nombre de propriétés de l’objet XMLList.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	Fusionne les nœuds de texte adjacents et élimine les nœuds de texte vides pour les éléments suivants : tous les nœuds de texte XMLList, tous les objets XML contenus dans XMLList et les descendants de tous les objets XML dans XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>L’objet XMLList normalisé.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Fusionne les nœuds de texte adjacents et élimine les nœuds de texte vides pour les éléments suivants : tous les nœuds de texte XMLList, tous les objets XML contenus dans XMLList et les descendants de tous les objets XML dans XMLList. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:parent"><apiName>parent</apiName><shortdesc>
	Renvoie le parent de l’objet XMLList si tous les éléments intégrés à l’objet XMLList possèdent le même parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie l’objet XML parent.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie le parent de l’objet XMLList si tous les éléments intégrés à l’objet XMLList possèdent le même parent. Si l’objet XMLList ne possède pas de parent ou a des parents différents, la méthode renvoie <codeph>undefined</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	Si un paramètre name est spécifié, la méthode recense tous les enfants de l’objet XMLList qui contiennent des instructions de traitement portant le nom indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList qui contient les instructions de traitement de chaque objet XML.
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>Nom des instructions de traitement pour lesquelles établir une correspondance.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Si un paramètre <codeph>name</codeph> est spécifié, la méthode recense tous les enfants de l’objet XMLList qui contiennent des instructions de traitement portant le nom indiqué. Si aucun paramètre n’est spécifié, elle recense tous les enfants de l’objet XMLList qui contiennent des instructions de traitement.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/processingInstructions()"><linktext>XML.processingInstructions()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	Vérifie si la propriété p figure dans le jeu de propriétés qui peut faire l’objet d’une itération avec une instruction for..in appliquée à l’objet XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Si la propriété peut faire l’objet d’une itération dans une instruction <codeph>for..in</codeph>, <codeph>true</codeph> ; sinon <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Index d’une propriété à vérifier.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vérifie si la propriété <codeph>p</codeph> figurre dans le jeu de propriétés qui peut faire l’objet d’une itération avec une instruction <codeph>for..in</codeph> appliquée à l’objet XMLList. La valeur <codeph>true</codeph> n’est renvoyée que si <codeph>toNumber(p)</codeph> est supérieur ou égal à 0 et inférieur à la longueur de l’objet XMLList. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:text"><apiName>text</apiName><shortdesc>
	Appelle la méthode text() de chaque objet XML et renvoie un objet XMLList contenant les résultats.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant l’ensemble des propriétés XML de l’objet XMLList qui représentent les nœuds de texte XML.
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Appelle la méthode <codeph>text()</codeph> de chaque objet XML et renvoie un objet XMLList contenant les résultats.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/text()"><linktext>XML.text()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toString"><apiName>toString</apiName><shortdesc>
	Renvoie une représentation sous forme de chaîne de tous les objets XML intégrés à un objet XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’objet XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une représentation sous forme de chaîne de tous les objets XML intégrés à un objet XMLList. Les règles de cette conversion varient selon que l’objet XML intègre un contenu simple ou complexe :
	
	<ul>
		<li>Si l’objet XML comporte un contenu simple, <codeph>toString()</codeph> renvoie le contenu de la chaîne de l’objet XML en éliminant les éléments suivants : la balise initiale, les attributs, les déclarations d’espace de nom et la balise de fin.</li> 
	</ul>
	
	<ul>
		<li> Si l’objet XML intègre un contenu complexe, <codeph>toString()</codeph> renvoie une chaîne codée au format XML qui représente l’objet XML entier, y compris la balise de début, les attributs, les déclarations d’espace de nom et la balise de fin.</li>
	</ul>
	
	<p>Pour renvoyer à chaque fois l’objet XML entier, utilisez la méthode <codeph>toXMLString()</codeph>.</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> L’exemple suivant indique ce que la méthode <codeph>toString()</codeph> renvoie lorsque l’objet XML a un contenu simple :
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> L’exemple suivant indique ce que la méthode <codeph>toString()</codeph> renvoie lorsque l’objet XML a un contenu complexe :
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XMLList/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	Renvoie une représentation sous forme de chaîne de tous les objets XML intégrés à un objet XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’objet XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une représentation sous forme de chaîne de tous les objets XML intégrés à un objet XMLList. A l’encontre de la méthode <codeph>toString()</codeph>, la méthode <codeph>toXMLString()</codeph> renvoie toujours la balise de début, les attributs et la balise de fin de l’objet XML, que son contenu soit simple ou complexe (la méthode <codeph>toString()</codeph> supprime ces éléments si l’objet XML intègre un contenu simple).
	
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	Renvoie l’objet XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie l’objet XMLList en cours.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie l’objet XMLList. 
	
	</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:Error"><apiName>Error</apiName><shortdesc>
 La classe Error contient des informations sur une erreur survenue dans un script.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Un objet Error est généré s’il se produit une erreur dans un script.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Error contient des informations sur une erreur survenue dans un script. Lorsque vous développez des applications ActionScript 3.0, une boîte de dialogue indique les exceptions de type Error ou associées à une sous-classe si vous exécutez le code compilé dans la version de débogage de Flash Player, pour vous aider à corriger le code. Vous pouvez créer un objet Error à l’aide de la fonction constructeur <codeph>Error</codeph>. En général, vous générez un nouvel objet Error à partir d’un bloc de code <codeph>try</codeph>, qui est ensuite détecté par un bloc de code <codeph>catch</codeph> ou <codeph>finally</codeph>.
 <p>Vous pouvez également créer une sous-classe de la classe Error et générer des occurrences de cette sous-classe.</p>
 
 </apiDesc><example conref="examples\ErrorExample.as"> L’exemple suivant exploite la classe <codeph>ErrorExample</codeph> pour indiquer comment générer une erreur personnalisée. Cette opération s’accomplit de la façon suivante :
 <ol>
     <li>Une variable locale, <codeph>nullArray</codeph>, de type Array est déclaré. Vous remarquerez qu’aucun objet Array n’est créé.</li>
     <li>Le constructeur tente de charger une valeur dans le tableau non initialisé en utilisant la méthode <codeph>push()</codeph> au sein d ’un segment de code de traitement des erreurs qui intercepte une erreur personnalisée à l’aide de la classe <codeph>CustomError</codeph>, qui étend <codeph>Error</codeph>.</li>
     <li>Lorsque CustomError est renvoyé, le constructeur l’intercepte, puis renvoie un message d’erreur à l’aide de l’instruction <codeph>trace()</codeph>. </li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    public class ErrorExample extends Sprite 
    {
        private var nullArray:Array;
        public function ErrorExample() 
        {
            try 
            {
                nullArray.push("item");
            }
            catch(e:Error) 
            {
                throw new CustomError("nullArray is null");
            }
        }
    }
}

class CustomError extends Error 
{
    public function CustomError(message:String) 
    {
        super(message);
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Error:Error"><apiName>Error</apiName><shortdesc>
	 Crée un nouvel objet Error.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Chaîne associée à l’objet Error. Ce paramètre est facultatif. 
     </apiDesc></apiParam><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Numéro de référence à associer au message d’erreur spécifique.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Crée une nouvelle occurrence de Error associée au message d’erreur spécifié.
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Crée un nouvel objet Error. Si <codeph>message</codeph> est spécifié, sa valeur est affectée à la propriété <codeph>Error.message</codeph> de l’objet.
	 
	 
	 </apiDesc><example conref="examples\Error.1.as"> L’exemple suivant crée un nouvel objet Error, <codeph>err</codeph> puis, à l’aide du constructeur <codeph>Error()</codeph>, affecte la chaîne <codeph>"New Error Message"</codeph> à <codeph>err</codeph>.
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message
</codeblock></example></apiConstructorDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiConstructor><apiOperation id="Error:getStackTrace"><apiName>getStackTrace</apiName><shortdesc>
	 Renvoie la pile d’appels d’une erreur sous la forme d’une chaîne lors de la construction de l’erreur (version de débogage de Flash Player et application de débogage du lanceur AIR seulement) ; renvoie la valeur null lorsque ni la version de débogage de Flash Player ni l’application de débogage du lanceur AIR n’est utilisée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, call stack
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Représentation sous forme de chaîne de la pile d’appels.
	 
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie la pile d’appels pour générer une erreur lisible.
	 
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie la pile d’appels d’une erreur sous la forme d’une chaîne lors de la construction de l’erreur (version de débogage de Flash Player et application de débogage du lanceur AIR seulement) ; renvoie la valeur <codeph>null</codeph> lorsque ni la version de débogage de Flash Player ni l’application de débogage du lanceur AIR n’est utilisée. Comme indiqué dans l’exemple suivant, la première ligne de la valeur renvoyée est une chaîne qui représente l’objet d’exception, suivi par les éléments de la pile de suivi :
	 
	 <codeblock>
	 TypeError: null cannot be converted to an object
	     at com.xyz.OrderEntry.retrieveData(OrderEntry.as:995)
	     at com.xyz.OrderEntry.init(OrderEntry.as:200)
	     at com.xyz.OrderEntry.$construct(OrderEntry.as:148)
   	 </codeblock>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Error:toString"><apiName>toString</apiName><shortdesc>
	
	Renvoie la chaîne « Error » par défaut ou la valeur contenue dans la propriété Error.message, si elle est définie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.toString, toString
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Message d’erreur.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie le message d’erreur ou le terme « Error » si le message n’est pas défini.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	
	Renvoie la chaîne <codeph>"Error"</codeph> par défaut ou la valeur contenue dans la propriété <codeph>Error.message</codeph>, si elle est définie.
	
    </apiDesc><example conref="examples\Error.toString.1.as"> L’exemple suivant crée un nouvel objet Error, <codeph>err</codeph> puis, à l’aide du constructeur <codeph>Error()</codeph>, affecte la chaîne <codeph>"New Error Message"</codeph> à <codeph>err</codeph>. Enfin, la propriété <codeph>message</codeph> est définie sur <codeph>"Another New Error Message"</codeph>, qui remplace <codeph>"New Error Message"</codeph>.
 
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message

err.message = "Another New Error Message";
trace(err.toString());    // Error: Another New Error Message
</codeblock></example></apiOperationDetail><related-links><link href="#Error/message"><linktext>Error.message</linktext></link><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiOperation><apiValue id="Error:message"><apiName>message</apiName><shortdesc>
	 Contient le message associé à l’objet Error.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.message, message
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Contient le message d’erreur associé à l’occurrence de Error.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Contient le message associé à l’objet Error. Par défaut, la valeur de cette propriété est "<codeph>Error</codeph>". Vous pouvez spécifier une propriété <codeph>message</codeph> lorsque vous créez un objet Error en transmettant la chaîne d’erreur à la fonction constructeur <codeph>Error</codeph>.
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiValue><apiValue id="Error:name"><apiName>name</apiName><shortdesc>
	  Contient le nom de l’objet Error.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Nom de l’occurrence de Error.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	  Contient le nom de l’objet Error. Par défaut, la valeur de cette propriété est "<codeph>Error</codeph>".
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiValue><apiValue id="Error:errorID:get"><apiName>errorID</apiName><shortdesc>
     Contient le numéro de référence associé au message d’erreur spécifique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.errorID, errorID
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Contient le numéro de l’erreur.
     
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Contient le numéro de référence associé au message d’erreur spécifique. Pour un objet Error personnalisé, ce nombre correspond à la valeur du paramètre <codeph>id</codeph> fourni dans le constructeur.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:TypeError"><apiName>TypeError</apiName><shortdesc>
 Une exception TypeError est renvoyée lorsque le type réel d’une opérande ne correspond pas au type prévu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, TypeError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une exception TypeError est renvoyée lorsque le type réel d’une opérande ne correspond pas au type prévu. 
 <p>
 Cette exception est également renvoyée dans les cas suivants :
  <ul>
  <li>Un paramètre réel de fonction ou de méthode ne peut pas être forcé à correspondre au type de paramètre formel.</li>
  <li>Une valeur est affectée à une variable et ne peut pas être forcée à correspondre au type de la variable.</li>
  <li>Le côté droit de l’opérateur <codeph>is</codeph> ou <codeph>occurrenceof</codeph> n’est pas un type valide.</li>
  <li>L’utilisation du mot-clé <codeph>super</codeph> n’est pas valide.</li>
  <li>Une recherche de propriété donne lieu à plusieurs liaisons, soit un résultat ambigu.</li>
  <li>Une méthode est appelée pour un objet incompatible. Par exemple, une exception TypeError est renvoyée si une méthode de la classe RegExp est « greffée » sur un objet générique, puis appelée.</li>
 </ul>
 </p>
 
 </apiDesc><example conref="examples\TypeErrorExample.as"> L’exemple suivant indique comment générer une exception TypeError et la traiter avec une instruction <codeph>try..catch</codeph>. 
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class TypeErrorExample extends Sprite {
        public function TypeErrorExample() {
            try {
                var child:Object = new Object();
                addChild(DisplayObject(child));
            }
            catch(e:TypeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#is"><linktext>opérateur is</linktext></link><link href="operators.html#instanceof"><linktext>opérateur occurrenceof</linktext></link><link href="statements.html#super"><linktext>instruction super</linktext></link><link href="#RegExp"><linktext>classe RegExp</linktext></link></related-links><apiConstructor id="TypeError:TypeError"><apiName>TypeError</apiName><shortdesc>
	 Crée un objet TypeError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Contient le message associé à l’objet TypeError. 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet TypeError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:arguments"><apiName>arguments</apiName><shortdesc>
 Un objet arguments permet de stocker les arguments d’une fonction et d’y accéder.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Un objet arguments permet de stocker les arguments d’une fonction et d’y accéder.
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Un objet arguments permet de stocker les arguments d’une fonction et d’y accéder. Dans le corps d’une fonction, vous pouvez accéder à l’objet arguments par le biais de la variable arguments locale.
 <p>
 Les arguments sont stockés sous forme d’éléments de tableau : le premier est accessible sous la forme <codeph>arguments[0]</codeph>, le deuxième en tant qu’<codeph>arguments[1]</codeph>, etc. La propriété <codeph>arguments.length</codeph> indique le nombre d’arguments transmis à la fonction. Le nombre d’arguments transmis peut différer du nombre déclaré par la fonction.
 </p>
 <p>
 A l’encontre des versions précédentes d’ActionScript, ActionScript 3.0 n’intègre pas de propriété <codeph>arguments.caller</codeph>. Pour définir une référence à la fonction qui a appelé la fonction en cours, vous devez transmettre une référence à cette dernière en tant qu’argument. Cette technique est illustrée dans l’exemple associé à <codeph>arguments.callee</codeph>.
 </p>
 <p>ActionScript 3.0 intègre un nouveau mot-clé <codeph>...(rest)</codeph>, que nous vous recommandons d’utiliser de préférence à la classe arguments.</p>
 
 </apiDesc><example conref="examples\ArgumentsExample.as"> L’exemple suivant présente les différents usages pour différentes propriétés <codeph>arguments</codeph>, telles que <codeph>callee</codeph> et <codeph>length</codeph> .
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        public function ArgumentsExample() {
                println("Hello World");
        }
        
        public function println(str:String):void {
            trace(arguments.callee == this.println); // true
            trace(arguments.length);                 // 1
            trace(arguments[0]);                     // Hello World
            trace(str);                                // Hello World
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#..._(rest)_parameter"><linktext>...(rest)</linktext></link><link href="#Function"><linktext>Fonction</linktext></link></related-links><apiValue id="arguments:callee"><apiName>callee</apiName><shortdesc>
	 Référence à la fonction en cours d’exécution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Function</apiValueClassifier><apiTipTexts><apiTipText>Référence à la fonction en cours d’exécution.
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Référence à la fonction en cours d’exécution.
	 
	 </apiDesc><example conref="examples\arguments.callee.1.as"> Le code suivant indique comment obtenir une référence à la fonction qui appelle la fonction nommée <codeph>secondFunction()</codeph>. La fonction <codeph>firstFunction()</codeph> reçoit l’argument booléen <codeph>true</codeph> pour démontrer que <codeph>secondFunction()</codeph> appelle avec succès <codeph>firstFunction()</codeph> et pour empêcher une boucle infinie de fonctions qui s’appellent les unes les autres.
  
 <p>Dans la mesure où le paramètre <codeph>callSecond</codeph> est défini sur <codeph>true</codeph>, <codeph>firstFunction()</codeph> appelle <codeph>secondFunction()</codeph> et se transmet une référence à lui-même en tant que seul argument. La fonction <codeph>secondFunction()</codeph> reçoit cet argument et le stocke à l’aide d’un paramètre appelé <codeph>caller</codeph>, qui appartient au type de données Function. A partir de <codeph>secondFunction()</codeph>, le paramètre <codeph>caller</codeph> est ensuite utilisé pour appeler la fonction <codeph>firstFunction</codeph>, mais cette fois avec l’argument <codeph>callSecond</codeph> défini sur <codeph>false</codeph>.</p>
 <p>Lorsque l’exécution revient à <codeph>firstFunction()</codeph>, l’instruction <codeph>trace()</codeph> est exécutée, car <codeph>callSecond</codeph> est <codeph>false</codeph>.</p>
<codeblock>
  package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        private var count:int = 1;
        
        public function ArgumentsExample() {
            firstFunction(true);
        }

        public function firstFunction(callSecond:Boolean) {
            trace(count + ": firstFunction");
            if(callSecond) {
                secondFunction(arguments.callee);
            }
            else {
                trace("CALLS STOPPED");
            }
        }

        public function secondFunction(caller:Function) {
            trace(count + ": secondFunction\n");
            count++;
            caller(false);
        }        
    }
} 
</codeblock></example></apiValueDetail></apiValue><apiValue id="arguments:length"><apiName>length</apiName><shortdesc>
	 Nombre d’arguments transmis à la fonction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Nombre de paramètres transmis à la fonction.
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Nombre d’arguments transmis à la fonction. Ce nombre peut être supérieur ou inférieur à celui déclaré par la fonction.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:String"><apiName>String</apiName><shortdesc>
 La classe String est un type de données qui représente une chaîne de caractères.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe String est un type de données qui représente une chaîne de caractères. Elle fournit des méthodes et propriétés permettant de manipuler les types de valeur de chaîne primitive. Vous pouvez convertir la valeur d’un objet en un objet au type de données String à l’aide de la fonction <codeph>String()</codeph>. 
 <p> 
 Toutes les méthodes de la classe String, à l’exception de <codeph>concat()</codeph>, <codeph>fromCharCode()</codeph>, <codeph>slice()</codeph> et <codeph>substr()</codeph>, sont génériques, ce qui signifie que les méthodes appellent <codeph>toString()</codeph> avant d’effectuer leurs opérations, et vous pouvez utiliser ces méthodes avec d’autres objets qui ne sont pas de type String. 
 </p><p>
 Tous les index de chaîne étant basés sur zéro, l’index du dernier caractère pour une chaîne <codeph>x</codeph> est <codeph>x.length - 1</codeph>.
 </p><p>
 Vous pouvez appeler l’une des méthodes de la classe String que vous utilisiez la méthode constructeur <codeph>new String()</codeph> pour créer une variable de type chaîne ou que vous affectiez simplement une valeur de littéral de type chaîne. A l’encontre des versions précédentes d’ActionScript, l’utilisation du constructeur, de la fonction globale ou l’affectation d’une valeur de littéral de chaîne ne fait aucune différence. Les lignes de code suivantes sont équivalentes :
 </p>
 <codeblock rev="3.0">
 var str:String = new String("foo");
 var str:String = "foo";
 var str:String = String("foo");</codeblock>
 <p>Lorsqu’il règle une variable de type chaîne sur <codeph>undefined</codeph>, Adobe<sup>®</sup> Flash<sup>®</sup> Player impose le remplacement de <codeph>undefined</codeph> par <codeph>null</codeph>. De ce fait, l’instruction :</p>
 <pre>
 var s:String = undefined;</pre>
 règle la valeur sur <codeph>null</codeph> au lieu de <codeph>undefined</codeph>. Utilisez la fonction <codeph>String()</codeph> pour obtenir <codeph>undefined</codeph>.
 </apiDesc><example conref="examples\StringExample.as"> L’exemple suivant a recours aux classes StringExample et StringHelper pour indiquer la façon dont les différentes méthodes de la classe String sont utilisées. Cette opération s’accomplit de la façon suivante :
 <ol>
    <li>Le constructeur de StringExample déclare plusieurs occurrences String locales, qui sont initialisées avec différentes chaînes et un nouvel objet StringHelper.</li>
    <li>La classe StringHelper dispose des méthodes suivantes :
    <ul>
        <li><codeph>replace()</codeph> : appelle les méthodes <codeph>split()</codeph> et <codeph>join()</codeph> de String pour supprimer une sous-chaîne de la chaîne transmise avec une nouvelle sous-chaîne.</li>
        <li><codeph>trim()</codeph> : appelle <codeph>trimBack()</codeph> et <codeph>trimFront()</codeph> à l’aide des chaînes transmises et renvoie la chaîne mise à jour.</li>
        <li><codeph>trimFront()</codeph> : supprime de façon récursive tous les caractères qui correspondent au caractère <codeph>char</codeph>, en commençant par le début de la chaîne et en allant vers sa fin, jusqu’à ce que le premier caractère de la chaîne ne corresponde pas à <codeph>char</codeph> et renvoie la chaîne mise à jour.</li>
        <li><codeph>trimBack()</codeph> : supprime de façon récursive tous les caractères qui correspondent au caractère <codeph>char</codeph>, en commençant par la fin de la chaîne et en allant vers l’arrière, jusqu’à ce que le dernier caractère de la chaîne ne corresponde pas à <codeph>char</codeph> et renvoie la chaîne mise à jour.</li>
        <li><codeph>stringToCharacter()</codeph> : renvoie le premier caractère de la chaîne qui lui a été transmise.</li>
    </ul>
  </li>
    <li>Trois chaînes sont ensuite produites à l’aide des variables déclarées avec un appel à la méthode <codeph>replace()</codeph> qui est utilisée pour produire la deuxième chaîne et <codeph>trim()</codeph> pour produire la troisième chaîne.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class StringExample extends Sprite {
        public function StringExample() {
            var companyStr:String = new String("     Company X");
            var productStr:String = "Product Z Basic     ";
            var emptyStr:String = " ";
            var strHelper:StringHelper = new StringHelper();

            var companyProductStr:String = companyStr + emptyStr + productStr;
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Basic     '

            companyProductStr = strHelper.replace(companyProductStr, "Basic", "Professional");
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Professional     '

            companyProductStr = strHelper.trim(companyProductStr, emptyStr);
            trace("'" + companyProductStr + "'");    // 'Company X Product Z Professional'
        }
    }
}

class StringHelper {
    public function StringHelper() {
    }

    public function replace(str:String, oldSubStr:String, newSubStr:String):String {
        return str.split(oldSubStr).join(newSubStr);
    }

    public function trim(str:String, char:String):String {
        return trimBack(trimFront(str, char), char);
    }

    public function trimFront(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(0) == char) {
            str = trimFront(str.substring(1), char);
        }
        return str;
    }

    public function trimBack(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(str.length - 1) == char) {
            str = trimBack(str.substring(0, str.length - 1), char);
        }
        return str;
    }

    public function stringToCharacter(str:String):String {
        if (str.length == 1) {
            return str;
        }
        return str.slice(0, 1);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="package.html#String()"><linktext>Fonction String</linktext></link></related-links><apiConstructor id="String:String"><apiName>String</apiName><shortdesc>
  Crée un objet String initialisé sur la chaîne spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, new string, new, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur initiale du nouvel objet String.
  
  </apiDesc></apiParam></apiConstructorDef><apiDesc>
  Crée un objet String initialisé sur la chaîne spécifiée.
  
  <p>
  <b>Remarque : </b>les littéraux de chaîne utilisant moins de temps système que les objets String et étant généralement plus faciles à utiliser, il est recommandé de faire appel à eux plutôt qu’à la classe String, sauf si vous avez une bonne raison d’utiliser un objet String plutôt qu’un littéral de chaîne.
  </p>
  
  </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="String:AS3:charAt"><apiName>charAt</apiName><shortdesc>
     Renvoie le caractère correspondant à la position spécifiée par le paramètre index.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charat, charat, character at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Le caractère correspondant à l’index spécifié, ou une chaîne vide si l’index spécifié n’est pas compris dans la plage des index de cette chaîne.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier spécifiant la position d’un caractère dans la chaîne. Le premier caractère est indiqué par <codeph>0</codeph> et le dernier par <codeph>my_str.length - 1</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie le caractère correspondant à la position spécifiée par le paramètre <codeph>index</codeph>. Si <codeph>index</codeph> n’est pas un nombre compris entre 0 et <codeph>string.length - 1</codeph>, une chaîne vide est renvoyée.
	 <p>
	 Cette méthode est similaire à <codeph>String.charCodeAt()</codeph>, sauf que la valeur renvoyée est un caractère, plutôt qu’un code de caractère entier 16 bits.
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charCodeAt()"><linktext>charCodeAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:charCodeAt"><apiName>charCodeAt</apiName><shortdesc>
	 Renvoie le code numérique du caractère Unicode correspondant à l’index spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charcodeat, charcodeat, character code at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Le code du caractère Unicode correspondant à l’index spécifié, ou <codeph> NaN</codeph> si l’index spécifié n’est pas compris dans la plage des index de cette chaîne.
	 <p><xref href="" scope="external"/> </p>		 
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier spécifiant la position d’un caractère dans la chaîne. Le premier caractère est indiqué par <codeph>0,</codeph> et le dernier par <codeph>my_str.length - 1</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie le code numérique du caractère Unicode correspondant à l’<codeph>index</codeph> spécifié. Si <codeph>index</codeph> n’est pas un nombre compris entre 0 et <codeph> string.length - 1</codeph>, <codeph>NaN</codeph> est renvoyé.
	 <p>
	 Cette méthode est similaire à <codeph>String.charAt()</codeph>, sauf que la valeur renvoyée est un code de caractère entier 16 bits, pas le caractère en tant que tel.
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charAt()"><linktext>charAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:concat"><apiName>concat</apiName><shortdesc>
	 Ajoute les arguments fournis à la fin de l’objet String en les convertissant en chaînes si besoin est, et renvoie la chaîne obtenue.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvelle chaîne composée de cette chaîne concaténée avec les paramètres spécifiés.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Valeurs supérieures ou égales à zéro à concaténer.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ajoute les arguments fournis à la fin de l’objet String en les convertissant en chaînes si besoin est, et renvoie la chaîne obtenue. La valeur d’origine de l’objet String source n’est pas modifiée.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:fromCharCode"><apiName>fromCharCode</apiName><shortdesc>
	Renvoie une chaîne comprenant les caractères représentés par les codes de caractère Unicode dans les paramètres.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.fromcharcode, fromcharcode, from character code
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Chaîne correspondant aux codes de caractère Unicode spécifiés.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>charCodes</apiItemName><apiType value="restParam"/><apiDesc>Série d’entiers décimaux représentant les valeurs Unicode.
	<p><xref href="" scope="external"/> </p>	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Renvoie une chaîne comprenant les caractères représentés par les codes de caractère Unicode dans les paramètres.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 Recherche la chaîne et renvoie la position de la première occurrence de val détectée au niveau de ou après startIndex dans la chaîne appelante.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.indexof, indexof, index
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Index de la première occurrence de la sous-chaîne spécifiée ou <codeph>-1</codeph>.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Sous-chaîne à rechercher.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier facultatif spécifiant l’index de départ de la recherche.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Recherche la chaîne et renvoie la position de la première occurrence de <codeph>val</codeph> détectée au niveau de ou après <codeph>startIndex</codeph> dans la chaîne appelante. Cet index commence à partir de zéro, ce qui signifie que le premier caractère d’une chaîne est considéré comme étant à l’index 0, et non pas à l’index 1. Si <codeph>val</codeph> n’est pas détecté, la méthode renvoie -1.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/lastIndexOf()"><linktext>lastIndexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 Recherche la chaîne de droite à gauche et renvoie l’index de la dernière occurrence de val détectée avant startIndex.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.lastindexof, lastindexof, last index of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>La position de la dernière occurrence de la sous-chaîne spécifiée ou -1 si elle est introuvable.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à rechercher.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7FFFFFFF</apiData><apiDesc>Entier facultatif spécifiant l’index de départ de la recherche de <codeph>val</codeph>. La valeur par défaut correspond à la valeur maximale autorisée d’un index. Si vous ne spécifiez pas <codeph>startIndex</codeph>, la recherche débute par le dernier élément de la chaîne.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Recherche la chaîne de droite à gauche et renvoie l’index de la dernière occurrence de <codeph>val</codeph> détectée avant <codeph>startIndex</codeph>. L’index commence à zéro, ce qui signifie que le premier caractère occupe la position d’index 0 et le dernier, <codeph>string.length - 1</codeph>. Si <codeph>val</codeph> n’est pas détecté, la méthode renvoie <codeph>-1</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/indexOf()"><linktext>indexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:localeCompare"><apiName>localeCompare</apiName><shortdesc>
	 Compare l’ordre de tri de deux chaînes ou plus et renvoie le résultat de la comparaison sous forme d’entier.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>La valeur 0 si les chaînes sont égales. Dans le cas contraire, un entier négatif si la chaîne d’origine est inférieure à l’argument chaîne et un entier positif si l’argument chaîne est inférieur à la chaîne d’origine. Dans les deux cas, la valeur absolue du nombre représente l’écart entre les deux chaînes.
	  
	  </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de chaîne à comparer.
     </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Ensemble facultatif d’autres chaînes à comparer.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Compare l’ordre de tri de deux chaînes ou plus et renvoie le résultat de la comparaison sous forme d’entier. Bien que cette méthode soit conçue pour traiter la comparaison en fonction des paramètres régionaux en vigueur, l’implémentation d’ActionScript 3.0 ne produit pas un résultat différent des autres comparaisons de chaînes, telles que les opérateurs d’égalité (<codeph>==</codeph>) ou d’inégalité (<codeph>!=</codeph>). Si les chaînes sont équivalentes, la valeur renvoyée est 0. Si la valeur de la chaîne d’origine est inférieure à la valeur de la chaîne spécifiée par <codeph>other</codeph>, la valeur renvoyée est un entier négatif, dont la valeur absolue représente le nombre de caractères qui séparent les deux valeurs de chaîne. Si la valeur de la chaîne d’origine est supérieure à <codeph>other</codeph>, la valeur renvoyée est un entier positif, dont la valeur absolue représente le nombre de caractères qui séparent les deux valeurs de chaîne.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:match"><apiName>match</apiName><shortdesc>
	Met en correspondance le paramètre pattern spécifié et la chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
		 var myPattern:RegExp = /sh./g;  
			// The dot (.) matches any character.
	 var str:String = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: she,sho
	
		 myPattern = /sh./gi;  
			// This time, make it case insensitive (with the i flag).
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: She,she,sho	
	
		 myPattern = RegExp = new RegExp("sh(.)", "gi")  
			// Note the grouping parentheses.
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
		// Output: She,e,she,e,sho,o
		 	// Note that the result array is 
			// [[She,e],[she,e],[sho,o]] 
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Tableau de chaînes contenant toutes les sous-chaînes de la chaîne qui correspondent au paramètre <codeph>pattern</codeph> spécifié.
	
	<p>Si <codeph>pattern</codeph> est une expression régulière, l’indicateur <codeph>g</codeph> (global) doit être défini dans celle-ci pour renvoyer un tableau contenant plus d’une sous-chaîne correspondante : </p>
	
	<ul>
	
		<li>Si l’indicateur <codeph>g</codeph> (global) n’est <i>pas</i> défini, le tableau renvoyé ne contient qu’une seule correspondance, et la propriété <codeph>lastIndex</codeph> de l’expression régulière n’est pas modifiée.</li> 
	
		<li>Si l’indicateur <codeph>g</codeph> (global) <i>est</i> défini, la méthode démarre la recherche au début de la chaîne (position d’index 0). Si une sous-chaîne correspondante est une chaîne vide (ce qui risque de se produire avec une expression régulière telle que <codeph>/x~~/</codeph>), la méthode ajoute cette chaîne vide au tableau des correspondances, puis poursuit la recherche à la position d’index suivante. La propriété <codeph>lastIndex</codeph> de l’expression régulière est définie sur 0 une fois la méthode terminée. </li>
	
	</ul>
	
	<p>Si aucune correspondance n’est détectée, la méthode renvoie <codeph>null</codeph>. Si vous ne transmettez pas de valeur (ou si vous transmettez une valeur non définie) en tant que paramètre <codeph>pattern</codeph>, la méthode renvoie <codeph>null</codeph>.</p>
	
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Les critères à rechercher, susceptibles de correspondre à n’importe quel type d’objet, mais généralement réglés sur une chaîne ou une expression régulière. Si le paramètre <codeph>pattern</codeph> n’est ni une expression régulière, ni une chaîne, la méthode le convertit en chaîne avant de s’exécuter. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Met en correspondance le paramètre <codeph>pattern</codeph> spécifié et la chaîne.
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:replace"><apiName>replace</apiName><shortdesc>
	Compare les critères (pattern) spécifiés à la chaîne et renvoie une nouvelle chaîne dans laquelle la première correspondance de pattern est remplacée par le contenu spécifié par repl.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>La chaîne obtenue. Notez que la chaîne source n’est pas modifiée.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Les critères à rechercher, susceptibles de correspondre à n’importe quel type d’objet, mais généralement réglés sur une chaîne ou une expression régulière. Si vous spécifiez un paramètre <codeph>pattern</codeph> correspondant à tout objet autre qu’une chaîne ou une expression régulière, la méthode <codeph>toString()</codeph> est appliquée au paramètre et la méthode <codeph>replace()</codeph> s’exécute en utilisant la chaîne obtenue en tant que critère (<codeph>pattern</codeph>). 
	
	</apiDesc></apiParam><apiParam><apiItemName>repl</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>En règle générale, la chaîne qui remplace le contenu correspondant. Vous pouvez également utiliser une fonction en tant que paramètre. Dans ce cas, la chaîne renvoyée par la fonction remplace le contenu correspondant.
	
	<p>Si vous spécifiez une chaîne en tant que paramètre <codeph>repl</codeph> et que vous définissez une expression régulière en tant que paramètre <codeph>pattern</codeph>, vous pouvez utiliser les <i>codes de remplacement $</i> spéciaux suivants dans la chaîne <codeph>repl</codeph> :</p>
	
	<adobetable class="innertable">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<tgroup cols="2"><thead><row><entry NOWRAP="true">$ Code
		</entry><entry>Texte de remplacement
		</entry></row></thead><tbody><row>
	
		<entry><codeph>$$</codeph>
		</entry>
	
		<entry><codeph>$</codeph>
		</entry>
	
	</row><row>
	
		<entry><codeph>$&amp;</codeph>
		</entry>
	
		<entry>Sous-chaîne correspondante.
		</entry>
	
	</row><row>
	
		<entry><codeph>$`</codeph>	
		</entry>
	
		<entry>Partie de la chaîne qui précède la sous-chaîne correspondante. Notez que ce code utilise le guillemet droit simple de gauche (`) plutôt que le guillemet droit simple (') ou le guillemet courbe simple de gauche ().
		</entry>
	
	</row><row>
	
		<entry><codeph>$'</codeph>
		</entry>
	
		<entry>Partie de la chaîne qui suit la sous-chaîne correspondante. Notez que ce code utilise le guillemet droit simple (’).
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>n</i>
		</entry>
	
		<entry><i>N</i>ième groupe entre parenthèses correspondant capturé, où <i>n</i> est un chiffre compris entre 1 et 9 et <codeph>$</codeph><i>n</i> n’est pas suivi d’une décimale. 
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>nn</i>
		</entry>
	
		<entry><i>Nn</i>ième groupe entre parenthèses correspondant capturé, où <i>nn</i> est un nombre décimal à deux chiffres compris entre 01 et 99. Si la <i>nn</i>ième capture n’est pas définie, le texte de remplacement est une chaîne vide. 
		</entry>
	
	</row></tbody></tgroup></adobetable>
	
	<p>L’exemple suivant illustre l’utilisation des codes de remplacement <codeph>$2</codeph> et <codeph>$1</codeph>, qui représentent le premier et le deuxième groupes capturés correspondants :</p>
	
	<codeblock>var str:String = "flip-flop";
	var pattern:RegExp = /(\w+)-(\w+)/g;
	trace(str.replace(pattern, "$2-$1")); // flop-flip</codeblock>
	
	<p>Si vous spécifiez une fonction en tant que paramètre <codeph>repl</codeph>, la méthode <codeph>replace()</codeph> transmet les paramètres suivants à la fonction :
	</p>
	
	<ul>
	
		<li>
		La partie correspondante de la chaîne.
		</li>
	
		<li>
		Tout groupe entre parenthèses capturé correspondant est spécifié en tant qu’arguments suivants. Le nombre d’arguments transmis de cette façon varie selon le nombre de correspondances entre parenthèses. Pour déterminer le nombre de correspondances entre parenthèses, vérifiez <codeph>arguments.length - 3</codeph> dans le code de la fonction.
		</li>
	
		<li>
		La position d’index dans la chaîne où débute la correspondance.
		</li>
	
		<li>
		La chaîne complète.
		</li>
	
	</ul>
	
	<p>Considérons par exemple ce qui suit :</p>
	
	<codeblock>
	var str1:String = "abc12 def34";
	var pattern:RegExp = /([a-z]+)([0-9]+)/;
	var str2:String = str1.replace(pattern, replFN);
	trace (str2);   // 12abc 34def
	
	function replFN():String {
		return arguments[2] + arguments[1];
	}</codeblock>
	
	
	<p>L’appel de la méthode <codeph>replace()</codeph> utilise une fonction en tant que paramètre <codeph>repl</codeph>. Deux correspondances sont détectées pour l’expression régulière (<codeph>/([a-z]([0-9]/g</codeph>). La première fois, les critères correspondent à la sous-chaîne <codeph>"abc12"</codeph> et la liste suivante d’arguments est transmise à la fonction :
	</p>
	
	<codeblock>
	{"abc12", "abc", "12", 0, "abc12 def34"}</codeblock>
	
	
	<p>La seconde fois, les critères correspondent à la sous-chaîne <codeph>"def23"</codeph> et la liste suivante d’arguments est transmise à la fonction :
	</p>
	
	<codeblock>
	{"def34", "def", "34", 6, "abc123 def34"}</codeblock>
	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Compare les critères (<codeph>pattern</codeph>) spécifiés à la chaîne et renvoie une nouvelle chaîne dans laquelle la première correspondance de <codeph>pattern</codeph> est remplacée par le contenu spécifié par <codeph>repl</codeph>. Le paramètre <codeph>pattern</codeph> peut être une chaîne ou une expression régulière. Le paramètre <codeph>repl</codeph> peut être une chaîne ou une fonction. S’il s’agit d’une fonction, la chaîne renvoyée par la fonction est insérée à la place de la correspondance. La chaîne d’origine n’est pas modifiée.
	
	<p>Dans l’exemple suivant, seule la première occurrence de « sh » (le respect de la casse étant activé) est remplacée : </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seashore.</codeblock>
	
	<p>Dans l’exemple suivant, toutes les occurrences de « sh » (le respect de la casse étant activé) sont remplacées, car l’indicateur <codeph>g</codeph> (global) est défini dans l’expression régulière : </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/g;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seaschore.</codeblock>
	
	<p>Dans l’exemple suivant, toutes les occurrences de « sh » sont remplacées, car l’indicateur <codeph>g</codeph> (global) est défini dans l’expression régulière et les correspondances ne respectent <i>pas</i> la casse, car l’indicateur <codeph>i</codeph> (ignoreCase) est défini :</p>
	
	<codeblock>
	var myPattern:RegExp = /sh/gi;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // sche sells seaschells by the seaschore.</codeblock>
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:search"><apiName>search</apiName><shortdesc>
	Recherche le paramètre pattern spécifié et renvoie l’index de la première sous-chaîne correspondante.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
	 var str:String = "She sells seashells by the seashore.";
		 var myPattern:RegExp = /sh/;  
			// This time, make it case insensitive (with the i flag).
	 trace(str.match(myPattern));  
	
		// Output: 13
		// (The substring match starts at character position 13.)
	
		 var myPattern:RegExp = /sh/i;
	 trace(str.match(myPattern));  
	
		// Output: 0
		// (The substring match starts at character position 0 
			//   -- the first character of the source string.)
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>L’index de la première sous-chaîne correspondante ou <codeph>-1</codeph> si aucune correspondance n’est détectée. Notez que la chaîne est associée à l’index zéro. Le premier caractère de la chaîne occupe la position d’index 0 et le dernier caractère, <codeph>string.length - 1</codeph>. 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Les critères à rechercher, susceptibles de correspondre à n’importe quel type d’objet, mais généralement réglés sur une chaîne ou une expression régulière. Si le paramètre <codeph>pattern</codeph> n’est ni une expression régulière, ni une chaîne, la méthode le convertit en chaîne avant de s’exécuter. Notez que si vous spécifiez une expression régulière, la méthode ignore l’indicateur global (« g ») de cette dernière, ainsi que sa propriété <codeph>lastIndex</codeph> (et ne modifie pas l’expression régulière). Si vous transmettez une valeur non définie (ou si vous ne transmettez pas de valeur), la méthode renvoie <codeph>-1</codeph>.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Recherche le paramètre <codeph>pattern</codeph> spécifié et renvoie l’index de la première sous-chaîne correspondante. Si aucune sous-chaîne correspondante n’est détectée, la méthode renvoie <codeph>-1</codeph>.
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:slice"><apiName>slice</apiName><shortdesc>
	 Renvoie une chaîne qui contient le caractère startIndex et tous les autres caractères jusqu’au caractère endIndex, ce dernier n’étant pas inclus.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Sous-chaîne basée sur les index spécifiés.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Index commençant à zéro du point de départ de la découpe. Si <codeph>startIndex</codeph> est un nombre négatif, la découpe est créée de droite à gauche, -1 représentant le dernier caractère.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Entier correspondant à 1+ l’index du point de terminaison de la découpe. Le caractère indexé par le paramètre <codeph>endIndex</codeph> n’est pas inclus dans la chaîne extraite. Si <codeph>endIndex</codeph> correspond à un nombre négatif, le point de terminaison est calculé à partir de la fin de la chaîne, -1 représentant le dernier caractère. La valeur par défaut correspond à la valeur maximale autorisée d’un index. Si ce paramètre est omis, <codeph>String.length</codeph> est utilisé.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une chaîne qui contient le caractère <codeph>startIndex</codeph> et tous les autres caractères jusqu’au caractère <codeph>endIndex</codeph>, ce dernier n’étant pas inclus. L’objet String d’origine n’est pas modifié. Si le paramètre <codeph>endIndex</codeph> n’est pas spécifié, la fin de la sous-chaîne correspond à la fin de la chaîne. Si le caractère indexé par <codeph>startIndex</codeph> est identique au caractère indexé par <codeph>endIndex</codeph> ou s’il se trouve à droite de ce caractère, la méthode renvoie une chaîne vide.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/substr()"><linktext>substr()</linktext></link><link href="#String/substring()"><linktext>substring()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:split"><apiName>split</apiName><shortdesc>
	 Divise un objet String en un tableau de sous-chaînes en le divisant à chaque occurrence du paramètre delimiter spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.split, split
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Tableau de sous-chaînes.
	 
	 
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>delimiter</apiItemName><apiType value=""/><apiDesc>Critères qui spécifient l’endroit où diviser cette chaîne. Cet objet peut être de tout type, mais correspond généralement à une chaîne ou à une expression régulière. Si le paramètre <codeph>delimiter</codeph> n’est ni une expression régulière, ni une chaîne, la méthode le convertit en chaîne avant de s’exécuter. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>limit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Nombre maximal d’éléments à placer dans le tableau. La valeur par défaut correspond à la valeur maximale autorisée. 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Divise un objet String en un tableau de sous-chaînes en le divisant à chaque occurrence du paramètre <codeph>delimiter</codeph> spécifié. 
	 
	 <p>Si le paramètre <codeph>delimiter</codeph> est une expression régulière, seule la première correspondance à une position donnée de la chaîne est prise en compte, même si un retour en arrière est susceptible de détecter une sous-chaîne non vide à cette position. Exemple :</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "ab";
	 var results:Array = str.split(/a~~?/); // results == ["","b"]
	 
	 results = str.split(/a~~/); // results == ["","b"].)</codeblock>
	 
	 
	 <p>Si le paramètre <codeph>delimiter</codeph> est une expression régulière contenant des parenthèses de regroupement, à chaque détection d’une correspondance de <codeph>delimiter</codeph>, les résultats, y compris tout résultat non défini, des parenthèses de regroupement sont rassemblés dans le tableau de sortie. Par exemple :</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "Thi5 is a tricky-66 example.";
	 var re:RegExp = /(\d+)/;
	 var results:Array = str.split(re);
	     // results == ["Thi","5"," is a tricky-","66"," example."]</codeblock>
	 
	 
	 <p>Si le paramètre <codeph>limit</codeph> est spécifié, le nombre d’éléments du tableau renvoyé ne dépasse pas le nombre spécifié.</p>
     <p>Si le paramètre <codeph>delimiter</codeph> est une chaîne vide, une expression régulière vide ou une expression régulière qui peut correspondre à une chaîne vide, chaque caractère de la chaîne est renvoyé en tant qu’élément du tableau.</p>
     
     <p>Si le paramètre <codeph>delimiter</codeph> n’est pas défini, l’ensemble de la chaîne est placé dans le premier élément du tableau renvoyé. </p>     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/join()"><linktext>Array.join()</linktext></link><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:substr"><apiName>substr</apiName><shortdesc>
	 Renvoie une sous-chaîne dont le premier caractère correspond à la position startIndex indiquée et dont la longueur est spécifiée par len.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substr, substr, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Sous-chaîne basée sur les paramètres spécifiés.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier qui indique l’index du premier caractère à utiliser pour créer la sous-chaîne. Si <codeph>startIndex</codeph> correspond à un nombre négatif, le point de départ est déterminé à partir de la fin de la chaîne, <codeph>-1</codeph> représentant le dernier caractère.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Nombre de caractères de la sous-chaîne en cours de création. La valeur par défaut correspond à la valeur maximale autorisée. Si le paramètre <codeph>len</codeph> n’est pas spécifié, la sous-chaîne contient tous les caractères, de <codeph>startIndex</codeph> à la fin de la chaîne.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une sous-chaîne dont le premier caractère correspond à la position <codeph> startIndex</codeph> indiquée et dont la longueur est spécifiée par <codeph>len</codeph>. La chaîne d’origine n’est pas modifiée.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:substring"><apiName>substring</apiName><shortdesc>
	 Renvoie une chaîne composée du caractère spécifié par startIndex et de tous les caractères suivants jusqu’à endIndex - 1.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substring, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Sous-chaîne basée sur les paramètres spécifiés.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier qui indique l’index du premier caractère utilisé pour créer la sous-chaîne. Les valeurs valides de <codeph>startIndex</codeph> sont comprises entre <codeph>0</codeph> et <codeph>String.length</codeph>. Si <codeph>startIndex</codeph> est une valeur négative, <codeph>0 </codeph> est utilisé.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Entier correspondant à 1 + l’index du dernier caractère de la sous-chaîne extraite. Les valeurs valides de <codeph>endIndex</codeph> sont comprises entre <codeph>0</codeph> et <codeph>String.length</codeph>. Le caractère représenté par <codeph>endIndex</codeph> est exclu de la sous-chaîne. La valeur par défaut correspond à la valeur maximale autorisée d’un index. Si ce paramètre est omis, <codeph>String.length</codeph> est utilisé. Si ce paramètre correspond à une valeur négative, <codeph>0</codeph> est utilisé.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une chaîne composée du caractère spécifié par <codeph>startIndex</codeph> et de tous les caractères suivants jusqu’à <codeph>endIndex - 1</codeph>. Si <codeph>endIndex</codeph> n’est pas spécifié, <codeph>String.length</codeph> est utilisé. Si la valeur de <codeph>startIndex</codeph> est égale à la valeur <codeph>endIndex</codeph>, la méthode renvoie une chaîne vide. Si la valeur de <codeph>startIndex</codeph> est supérieure à la valeur de <codeph> endIndex</codeph>, les paramètres sont automatiquement permutés avant que la fonction ne s’exécute. La chaîne d’origine n’est pas modifiée.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:toLocaleLowerCase"><apiName>toLocaleLowerCase</apiName><shortdesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères majuscules ont été convertis en minuscules.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Copie de cette chaîne dans laquelle tous les caractères majuscules ont été convertis en minuscules.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères majuscules ont été convertis en minuscules. La chaîne d’origine n’est pas modifiée. Bien que cette méthode soit conçue pour traiter la conversion en fonction des paramètres régionaux en vigueur, l’implémentation d’ActionScript 3.0 ne produit pas un résultat différent de la méthode <codeph>toLowerCase()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLocaleUpperCase"><apiName>toLocaleUpperCase</apiName><shortdesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères minuscules ont été convertis en majuscules.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Copie de cette chaîne dans laquelle tous les caractères minuscules ont été convertis en majuscules.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères minuscules ont été convertis en majuscules. La chaîne d’origine n’est pas modifiée. Bien que cette méthode soit conçue pour traiter la conversion en fonction des paramètres régionaux en vigueur, l’implémentation d’ActionScript 3.0 ne produit pas un résultat différent de la méthode <codeph>toUpperCase()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLowerCase"><apiName>toLowerCase</apiName><shortdesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères majuscules ont été convertis en minuscules.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.tolowercase, tolowercase, to lowercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Copie de cette chaîne dans laquelle tous les caractères majuscules ont été convertis en minuscules.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères majuscules ont été convertis en minuscules. La chaîne d’origine n’est pas modifiée.
	 
	 <p>Cette méthode convertit tous les caractères (pas seulement A-Z) pour lesquels il existe des équivalents minuscules Unicode :</p>
	 
	 <codeblock>
	 var str:String = " JOSÉ BARÇA";
	 trace(str.toLowerCase()); // josé barça</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toUpperCase"><apiName>toUpperCase</apiName><shortdesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères minuscules ont été convertis en majuscules.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.touppercase, touppercase, to uppercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Copie de cette chaîne dans laquelle tous les caractères minuscules ont été convertis en majuscules.
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une copie de cette chaîne, dont tous les caractères minuscules ont été convertis en majuscules. La chaîne d’origine n’est pas modifiée.
	 
	 <p>Cette méthode convertit tous les caractères (pas seulement a-z) pour lesquels il existe des équivalents majuscules Unicode :</p>
	 
	 <codeblock>
	 var str:String = "José Barça";
	 trace(str.toUpperCase()); // JOSÉ BARÇA</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Valeur primitive d’une occurrence de String.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new instance of the String class
	 and then shows that the <code>valueOf</code> method returns 
	 the <i>primitive</i> value, rather than a reference to the new instance.
	 
	 <listing version="2.0">
	 var str:String = new String("Hello World");
	 var value:String = str.valueOf();
	 trace(str instanceof String); // true
	 trace(value instanceof String); // false
	 trace(str === value); // false</listing>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur de la chaîne.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Valeur primitive d’une occurrence de String. Cette méthode est conçue pour convertir un objet String en une valeur de chaîne primitive. Flash Player appelant automatiquement <codeph>valueOf()</codeph> si besoin est, il est rarement nécessaire d’y faire explicitement appel.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="String:length:get"><apiName>length</apiName><shortdesc>
	 Entier indiquant le nombre de caractères dans l’objet String spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Entier indiquant le nombre de caractères dans l’objet String spécifié.
	 <p>
	 Tous les index de chaîne étant basés sur zéro, l’index du dernier caractère pour une chaîne <codeph>x</codeph> est <codeph>x.length - 1</codeph>.
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Class"><apiName>Class</apiName><shortdesc>
 Un objet Class est créé pour chaque définition de classe d’un programme.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Un objet Class est créé pour chaque définition de classe d’un programme. Chaque objet Class est une occurrence de la classe Class. L’objet Class contient les méthodes et propriétés statiques de la class. Il crée des occurrences de la classe si vous l’appelez en spécifiant l’opérateur <codeph>new</codeph>.
 
 <p>Certaines méthodes, telles que <codeph>flash.net.getClassByAlias()</codeph>, renvoient un objet de type Class. D’autres méthodes, telles que <codeph>flash.net.registerClassAlias()</codeph>, disposent parfois d’un paramètre de type Class. </p>
 <p>Le nom de classe renvoie à l’objet Class, comme illustré dans l’exemple ci-dessous :</p>
 <pre> 
 class Foo {
 }
 </pre> 
 <p>L’instruction <codeph>class Foo{}</codeph> est la définition de classe qui créé l’objet Class Foo. En outre, l’instruction <codeph>new Foo()</codeph> créera une occurrence de la classe Foo et le résultat sera de type Foo.</p>
 <p>Utilisez l’instruction <codeph>class</codeph> pour déclarer vos classes. Les objets Class s’avèrent utiles pour les techniques évoluées telles que l’affectation de classes à un objet existant lors de l’exécution, comme illustré à la section « Exemples » ci-dessous.</p>
 <p>Les méthodes et propriétés statiques d’une classe sont héritées par l’objet Class de la classe. En retour, Class déclare <codeph>prototype</codeph>.</p>
 
 <p>En règle générale, il est inutile de déclarer ou de créer manuellement des variables de type Class. Cependant, dans le code ci-dessous, une propriété Class publique <codeph>circleClass</codeph> est affectée à une classe et vous pouvez vous y référer en tant que propriété de la classe Library principale :</p>
 <codeblock>
 package {
  import flash.display.Sprite;
  public class Library extends Sprite {
      
      public var circleClass:Class = Circle;
      public function Library() {
      }
  }
 }
  
 import flash.display.Shape;
 class Circle extends Shape {
  public function Circle(color:uint = 0xFFCC00, radius:Number = 10) {
      graphics.beginFill(color);
      graphics.drawCircle(radius, radius, radius);
  }
 }
 </codeblock>
 
 <p>Un autre fichier SWF peut charger le fichier Library.swf généré, puis instancier les objets de type Circle. L’exemple suivant illustre une façon d’accéder aux ressources d’un fichier SWF enfant (d’autres techniques font appel à <codeph>flash.utils.getDefnitionByName()</codeph> ou importent des définitions souche (stub) du fichier SWF enfant).</p>
 
 <codeblock>
 package {
  import flash.display.Sprite;
  import flash.display.Shape;
  import flash.display.Loader;
  import flash.net.URLRequest;
  import flash.events.Event;
  public class LibaryLoader extends Sprite {
      public function LibaryLoader() {
          var ldr:Loader = new Loader();
          var urlReq:URLRequest = new URLRequest("Library.swf");
          ldr.load(urlReq);
          ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
      }
      private function loaded(event:Event):void {
          var library:Object = event.target.content;
          var circle:Shape = new library.circleClass();
          addChild(circle);
      }
  }
 }
 </codeblock>
 <p>ActionScript 3.0 vous permet de créer des classes intégrées destinées aux ressources externes (telles que les images, les sons ou les polices) qui sont compilées dans des fichiers SWF. Dans les versions antérieures d’ActionScript, vous associez ces ressources à la méthode <codeph>MovieClip.attachMovie()</codeph> par le biais d’un ID de liaison. Dans ActionScript 3.0, chaque ressource intégrée est représentée par une classe de ressources intégrées unique. Vous pouvez de ce fait utiliser l’opérateur <codeph>new</codeph> pour instancier la classe associée à la ressource et appeler des méthodes et des propriétés sur cette dernière.</p>
 <p product="flex">Par exemple, si vous utilisez un compilateur MXML pour générer des fichiers SWF, vous devez créer une classe intégrée de la manière suivante :</p>
 <codeblock product="flex">
     [Embed(source="bratwurst.jpg")]
     public var imgClass:Class;
 </codeblock>
 <p product="flex">Pour l’instancier, vous écrivez le code suivant :</p>
 <codeblock product="flex">
     var myImg:Bitmap = new imgClass();
 </codeblock>
 
 </apiDesc><example conref="examples\Class.1.as"> L’exemple suivant indique comment utiliser les objets Class pour reporter à la période d’exécution les décisions de création d’occurrences de classe à l’aide des procédures suivantes :
 <ol>
     <li>Déclare deux classes, <codeph>ClassA</codeph> et <codeph>ClassB</codeph>. </li>
     <li>Déclare une variable de type Class appelée <codeph>classToConstruct</codeph> et une autre de type Boolean appelée <codeph>chooseClassA</codeph>, qui est définie sur <codeph>true</codeph> dans ce cas. Votre code pourrait également utiliser une expression de test personnalisée pour définir la valeur de cette variable. </li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ClassExample extends Sprite {
        public function ClassExample() {
            var classToConstruct:Class;            
            var classInstance:Object;

            classToConstruct = ClassA;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassA]

            classToConstruct = ClassB;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassB]
        }
    }
}

class ClassA {
}
    
class ClassB {
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>Object.prototype</linktext></link><link href="operators.html#new"><linktext>new, opérateur</linktext></link></related-links></apiClassifier><apiClassifier id="globalClassifier:Namespace"><apiName>Namespace</apiName><shortdesc>

La classe Namespace contient les méthodes et propriétés destinées à la définition et à l’utilisation des espaces de nom.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Namespace
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>La classe Namespace contient les méthodes et propriétés destinées à la définition et à l’utilisation des espaces de nom des objets XML.

</apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

La classe Namespace contient les méthodes et propriétés destinées à la définition et à l’utilisation des espaces de nom. Les espaces de nom sont utilisés dans trois cas de figure :

<ul>
<li> <b>Espaces de nom d’objets XML</b> Les espaces de nom associent un préfixe d’espace de nom à un URI (Uniform Resource Identifier) qui les identifie. Le préfixe est une chaîne utilisée pour référencer l’espace de nom dans un objet XML. Si le préfixe n’est pas défini, il est automatiquement généré lorsque l’objet XML est converti en chaîne.
</li>

<li> <b>Espaces de nom utilisés pour différencier les méthodes</b> Les espaces de nom permettent de différencier les méthodes portant un nom identique pour effectuer des tâches différentes. Si deux méthodes ont le même nom, mais des espaces de nom distincts, elles peuvent exécuter des tâches différentes.
</li>

<li> <b>Espaces de nom pour le contrôle d’accès</b> Les espaces de nom permettent de contrôler l’accès à un groupe de propriétés et de méthodes d’une classe. Si vous placez les propriétés et les méthodes dans un espace de nom privé, tout code qui n’a pas accès à l’espace de nom ne peut pas non plus accéder à celles-ci. Vous pouvez accorder un accès au groupe de propriétés et de méthodes en transmettant l’espace de nom à d’autres classes, méthodes ou fonctions.
</li>
</ul>

<p>Cette classe utilise deux formes de la méthode de constructeur, car chaque forme accepte des paramètres différents.</p>

<p>A l’instar des classes XML, XMLList et QName, cette classe implémente des normes de gestion XML performantes définies dans la spécification ECMAScript pour XML (E4X) (ECMA-357, édition 2).</p>

</apiDesc><example conref="examples\NamespaceExample.as"> L’exemple suivant indique comment traiter les noms d’espace définis dans les objets XML. Cette opération s’accomplit de la façon suivante :
 <ol>
    <li>L’exemple définit trois objets Namespace, disposant tous d’un URI unique qui définit un nom d’espace.</li>
    <li>Cet exemple définit une variable XML appelée <codeph>myXML</codeph> et l’affecte à la valeur renvoyée par <codeph>getRSS()</codeph>. La méthode <codeph>getRSS()</codeph> définit un objet XML qui contient plusieurs noms d’espace et renvoie cet objet XML.</li>
    <li>Cet exemple déclare et évalue une variable Array en appelant la méthode <codeph>parseRSS()</codeph> tout en lui transmettant <codeph>myXML</codeph>. Dans <codeph>parseRSS()</codeph>, le nom d’espace XML par défaut est défini sous <codeph>rss</codeph> et l’exemple définit une variable XMLList en affectant la liste d’objets <codeph>item</codeph> dans <codeph>myXML</codeph>. Un tableau est créé et rempli par différents nœuds au sein de <codeph>myXML.item</codeph>. Le tableau est ensuite renvoyé.</li>
    <li>Les éléments du tableau sont imprimés à l’aide d’une boucle <codeph>for</codeph> et de trois appels à <codeph>trace()</codeph>.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class NamespaceExample extends Sprite {
        private var rss:Namespace = new Namespace("http://purl.org/rss/1.0/");
        private var rdf:Namespace = new Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
        private var dc:Namespace  = new Namespace("http://purl.org/dc/elements/1.1/");

        public function NamespaceExample() {
            var myXML:XML = getRSS();
            var rssItems:Array = parseRSS(myXML);
            
            var len:uint = rssItems.length;
            for (var i:uint; i &lt; len; i++) {
                trace(rssItems[i].title);
                trace(rssItems[i].creator);
                trace(rssItems[i].date);
                // Adobe Flash Developer Center
                // Adobe
                // 2005-08-08
                // Flex Developer Center
                // Adobe
                // 2005-10-16                
            }
        }
        
        private function parseRSS(rssXML:XML):Array {
            default xml namespace = rss;

            var items:XMLList = rssXML.item;

            var arr:Array = new Array();            
            var len:uint = items.length();
            for (var i:uint; i &lt; len; i++) {
                arr.push({title:items[i].title, creator:items[i].dc::creator, date:items[i].dc::date});
            }
            
            return arr;
        }

        private function getRSS():XML {
            var myXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/"
            >
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Adobe Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            return myXML;
        }
    }
}
</codeblock></example><example conref="examples\Namespace_2_Example.as"> L’exemple suivant indique comment les espaces de nom permettent de différencier les méthodes du même nom qui effectuent des tâches différentes. Dans cet exemple, trois méthodes appelées <codeph>hello()</codeph> résident dans des noms d’espace distincts, qui renvoient tous une chaîne distincte lorsqu’ils sont appelés.
<codeblock>
package {

    import flash.display.Sprite;

    public class Namespace_2_Example extends Sprite {    
        public function Namespace_2_Example() {
            var vocab:MultilingualVocabulary = new MultilingualVocabulary();

            trace(vocab.hello());    // hello
            
            var languages:Array = vocab.getLanguages();
            
            for (var i:uint; i &lt; languages.length; i++) {
                var ns:Namespace = languages[i];
                if (ns != null) {
                    trace(ns.toString() + ": " + vocab.ns::hello());
                    // hello
                    // MultilingualVocabulary:Hawaiian: aloha
                    // MultilingualVocabulary:French: bon jour
                }
            }
        }
    }    
}

class MultilingualVocabulary {
    public namespace French;
    public namespace Hawaiian;
    private var languages:Array;

    public function MultilingualVocabulary() {
        languages = new Array(Hawaiian, French);
    }
        
    public function hello():String { 
        return "hello";
    }

    Hawaiian function hello():String {
        return "aloha";
    }

    French function hello():String { 
        return "bon jour";
    }
        
    public function getLanguages():Array {
        return languages;
    }
}
</codeblock></example><example conref="examples\Namespace_3_Example.as"> L’exemple suivant utilise des noms d’espace de nom pour sélectionner une valeur de variable appropriée. Il indique comment vous pouvez stocker une valeur de nom d’espace dans une variable et utiliser cette dernière pour référencer des objets au sein de l’espace de nom.
 <p>L’exemple définit des espaces de nom et des couleurs qui correspondent à des états de souris pour un bouton rectangulaire. Lorsque le bouton est dessiné, l’exemple applique la couleur appropriée (rouge lorsque la souris quitte la zone active (out) ; jaune pour le survol (over) ; blanc pour abaissé (down)) en référençant la variable <codeph>bgcolor</codeph> pour l’espace de nom correspondant (<codeph>out</codeph>, <codeph>over</codeph>, <codeph>down</codeph>). </p>
<codeblock>
package {
    import flash.display.Sprite;
  
    public class Namespace_3_Example extends Sprite {     
        public function Namespace_3_Example() {
            addChild(new StateButton("Press Me."));
        }
    }
}

import flash.display.Sprite;
import flash.text.TextField;
import flash.events.Event;
import flash.events.MouseEvent;

class StateButton extends Sprite{
    private namespace out;
    private namespace over;
    private namespace down;
    private var label:TextField;
    private var labelTxt:String;
    private var ns:Namespace;
    out var bgColor:Number = 0xFF0000;
    over var bgColor:Number = 0xFFFF00;
    down var bgColor:Number = 0xFFFFFF;
      
    public function StateButton(str:String) {
        buttonMode = true;
        labelTxt = str;
        ns = out;
        draw();
        addLabel();
        addListeners();
    }

    private function addLabel():void {
        label = new TextField();
        label.text = labelTxt;
        label.width = 50;
        label.height = 20;
        label.mouseEnabled = false;
        addChild(label);
    }
      
    private function addListeners():void {
        addEventListener(MouseEvent.MOUSE_UP, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
    }
 
    private function mouseOutHandler(e:Event):void {
        ns = out;
        draw();
    }
 
    private function mouseOverHandler(e:Event):void {
        ns = over;
        draw();
    }
 
    private function mouseDownHandler(e:Event):void {
        ns = down;
        draw();
    }
 
    private function draw():void {
        this.graphics.clear();
        this.graphics.beginFill(ns::bgColor);
        this.graphics.drawRect(0, 0, 60, 20);
    }
} 
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>ECMAScript pour la spécification XML (E4X) (ECMA-357 edition 2)</linktext></link></related-links><apiConstructor id="Namespace:Namespace_0"><apiName>Namespace</apiName><shortdesc> 
	Crée un objet Namespace.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>URI (Uniform Resource Identifier) de l’espace de nom.
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Crée un objet Namespace en fonction du paramètre uriValue indiqué.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	Crée un objet Namespace. Les valeurs affectées aux propriétés <codeph>uri</codeph> et <codeph>prefix</codeph> du nouvel objet Namespace varient selon le type de valeur transmise pour le paramètre <codeph>uriValue</codeph> :
	<ul>
	  <li>Si aucune valeur n’est transmise, les propriétés <codeph>prefix</codeph> et <codeph>uri</codeph> sont réglées sur une chaîne vide.</li>
	  <li>Si la valeur est un objet Namespace, une copie de ce dernier est générée.</li>
	  <li>Si la valeur est un objet QName, la propriété <codeph>uri</codeph> est définie sur la propriété <codeph>uri</codeph> de l’objet QName.</li>
	</ul>
    <p><b>Remarque :</b> cette classe utilise deux entrées de constructeur, car chaque forme accepte des paramètres différents. Le constructeur se comporte différemment selon le type et le nombre de paramètres transmis, comme indiqué dans chaque entrée. ActionScript 3.0 ne prend pas en charge la surcharge d’une méthode ou d’un constructeur.</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="Namespace:Namespace_1"><apiName>Namespace</apiName><shortdesc> 
	Crée un objet Namespace en fonction de la valeur des paramètres prefixValue et uriValue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>prefixValue</apiItemName><apiType value=""/><apiDesc>Préfixe à utiliser pour l’espace de nom.   
	
	</apiDesc></apiParam><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>URI (Uniform Resource Identifier) de l’espace de nom.
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Crée un objet Namespace en fonction des paramètres prefixValue et uriValue indiqués.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	Crée un objet Namespace en fonction de la valeur des paramètres <codeph>prefixValue</codeph> et <codeph>uriValue</codeph>. Ce constructeur requiert les deux paramètres.
	<p>La valeur du paramètre <codeph>prefixValue</codeph> est octroyée à la propriété <codeph>prefix</codeph> de la façon suivante :</p>
	<ul>
	  <li>Si <codeph>undefined</codeph> est transmis, <codeph>prefix</codeph> est réglé sur <codeph>undefined</codeph>.</li>
	  <li>Si la valeur est un nom XML valide, déterminé par la fonction <codeph>isXMLName()</codeph>, elle est convertie en chaîne et octroyée à la propriété <codeph>prefix</codeph>.</li>
	  <li>Si la valeur n’est pas un nom XML valide, la propriété <codeph>prefix</codeph> est définie sur <codeph>undefined</codeph>.</li>
	</ul>
	
	<p>La valeur du paramètre <codeph>uriValue</codeph> est octroyée à la propriété <codeph>uri</codeph> de la façon suivante :</p>
	<ul>
	  <li>Si un objet QName est transmis, la propriété <codeph>uri</codeph> est définie sur la valeur de la propriété <codeph>uri</codeph> de l’objet QName.</li>
	  <li> Dans le cas contraire, le paramètre <codeph>uriValue</codeph> est converti en chaîne et octroyé à la propriété <codeph>uri</codeph>.</li>
	</ul>
    <p><b>Remarque :</b> cette classe utilise deux entrées de méthode de constructeur, car chaque forme accepte des paramètres différents. Le constructeur se comporte différemment selon le type et le nombre d’arguments transmis, comme indiqué dans chaque entrée. ActionScript 3.0 ne prend pas en charge la surcharge d’une méthode ou d’un constructeur.</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Namespace:AS3:toString"><apiName>toString</apiName><shortdesc>
	Equivalent à la propriété Namespace.uri.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>URI (Uniform Resource Identifier) de l’espace de nom, spécifié sous forme de chaîne.
	
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Equivalent à la propriété Namespace.uri. 
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Equivalent à la propriété <codeph>Namespace.uri</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="Namespace:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    Renvoie la valeur URI de l’objet spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>URI (Uniform Resource Identifier) de l’espace de nom, spécifié sous forme de chaîne.
    
    
    </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Equivalent à la propriété Namespace.uri. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Renvoie la valeur URI de l’objet spécifié. 
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="Namespace:prefix:get"><apiName>prefix</apiName><shortdesc>
	Préfixe de l’espace de nom.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.prefix, prefix
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Préfixe de l’espace de nom.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Préfixe de l’espace de nom.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="Namespace:uri:get"><apiName>uri</apiName><shortdesc>
	URI (Uniform Resource Identifier) de l’espace de nom.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>URI (Uniform Resource Identifier) de l’espace de nom.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	URI (Uniform Resource Identifier) de l’espace de nom.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:XML"><apiName>XML</apiName><shortdesc>
	La classe XML contient les méthodes et propriétés réservées aux objets XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XML
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	La classe XML contient les méthodes et propriétés réservées aux objets XML. A l’instar des classes XMLList, Namespace et QName, la classe XML implémente des normes de gestion XML performantes définies dans la spécification ECMAScript pour XML (E4X) (ECMA-357, édition 2).
	
	<p>La méthode <codeph>toXMLString()</codeph> permet de renvoyer une représentation sous forme de chaîne de l’objet XML, que son contenu soit simple ou complexe.</p>
	
	<p><b>Remarque </b>: la classe XML et les classes apparentées intégrées à ActionScript 2.0 ont été renommées XMLDocument et transférées dans le package flash.xml. La classe XML figure dans ActionScript 3.0 à des fins de compatibilité ascendante.</p> 
	
	
    </apiDesc><example conref="examples\XMLExample.as"> L’exemple suivant crée tout d’abord une variable XML, puis y ajoute des nœuds. Ensuite, les propriétés XML permettent de trouver et imprimer des nœuds XML. Vous pouvez constater que le symbole « arrobase » (<codeph>@</codeph>) est utilisé dans plusieurs des appels <codeph>trace()</codeph> pour rechercher des informations en fonction du nom d’attribut.
<codeblock>
package {
    import flash.display.Sprite;

    public class XmlExample extends Sprite {        
        public function XmlExample() {
            var employees:XML =
                &lt;employees>
                    &lt;employee ssn="123-123-1234">
                        &lt;name first="John" last="Doe"/>
                        &lt;address>
                            &lt;street>11 Main St.&lt;/street>
                            &lt;city>San Francisco&lt;/city>
                            &lt;state>CA&lt;/state>
                            &lt;zip>98765&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                    &lt;employee ssn="789-789-7890">
                        &lt;name first="Mary" last="Roe"/>
                        &lt;address>
                            &lt;street>99 Broad St.&lt;/street>
                            &lt;city>Newton&lt;/city>
                            &lt;state>MA&lt;/state>
                            &lt;zip>01234&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                &lt;/employees>;

            trace(employees.employee[0].address.zip);   // 98765

            trace(employees.employee[1].@ssn);          // 789-789-7890

            trace(employees.employee.name);             // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees..zip[0]);                   // 98765

            trace(employees..@ssn[1]);                  // 789-789-7890

            trace(employees..name);                     // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees.employee[0].address.*);     // &lt;street>11 Main St.&lt;/street>    
                                                        // &lt;city>San Francisco&lt;/city>
                                                        // &lt;state>CA&lt;/state>
                                                        // &lt;zip>98765&lt;/zip>
            var node:String = "zip";
            trace(employees.employee[0].address[node]); // 98765
            
            var attribute:String = "ssn";
            trace(employees.employee[1].@[attribute]);  // 789-789-7890
            
            for each (var num:XML in employees..@ssn) {
                trace(num);                             // 123-123-1234
            }                                           // 789-789-7890
            
            var ssnToFind:String = "789-789-7890";
            trace(employees.employee.(@ssn == ssnToFind).toXMLString());
                                                        // &lt;employee ssn="789-789-7890">
                                                        // &lt;name first="Mary" last="Roe"/>
                                                        // &lt;address>
                                                        // &lt;street>99 Broad St.&lt;/street>
                                                        // &lt;city>Newton&lt;/city>
                                                        // &lt;state>MA&lt;/state>
                                                        // &lt;zip>01234&lt;/zip>
                                                        // &lt;/address>
                                                        // &lt;/employee>
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Namespace"><linktext>Espace de nom </linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>ECMAScript pour la spécification XML (E4X) (ECMA-357 edition 2)</linktext></link></related-links><apiConstructor id="XML:XML"><apiName>XML</apiName><shortdesc> 
	Crée un objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Tout objet qui peut être converti en objet XML à l’aide de la fonction de niveau supérieur <codeph>XML()</codeph>.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc> 
	Crée un objet XML. Vous devez utiliser le constructeur pour créer un objet XML avant d’appeler une des méthodes de la classe XML. 
	
	<p>La méthode <codeph>toXMLString()</codeph> permet de renvoyer une représentation sous forme de chaîne de l’objet XML, que son contenu soit simple ou complexe.</p>
	
	</apiDesc></apiConstructorDetail><related-links><link href="package.html#XML()"><linktext>top-level XML(), fonction</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiConstructor><apiOperation id="XML:AS3:addNamespace"><apiName>addNamespace</apiName><shortdesc>
	Ajoute un espace de nom à l’ensemble d’espaces de nom du domaine associé à l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.addNamespace, addNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nouvel objet XML, auquel est ajouté l’espace de nom.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Espace de nom à ajouter à l’objet XML.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ajoute un espace de nom à l’ensemble d’espaces de nom du domaine associé à l’objet XML. Si l’espace de nom figure déjà dans l’ensemble d’espaces de noms du domaine associé à l’objet XML (avec un préfixe qui correspond au paramètre spécifié), le préfixe correspondant est réglé sur <codeph>undefined</codeph>. Si le paramètre d’entrée est un objet Namespace, il est utilisé directement. S’il correspond à un objet QName, l’URI du paramètre d’entrée est utilisé pour créer un espace de nom. Dans le cas contraire, il est converti en chaîne et un espace de nom est généré à partir de la chaîne.
	
	</apiDesc><example conref="examples\XML.addNamespace.1.as"> Cet exemple utilise un espace de nom défini dans un objet XML et l’applique à un autre objet XML :
<codeblock>
var xml1:XML = &lt;ns:foo xmlns:ns="www.example.com/ns" />;
var nsNamespace:Namespace = xml1.namespace();

var xml2:XML = &lt;bar />;
xml2.addNamespace(nsNamespace);
trace(xml2.toXMLString()); // &lt;bar xmlns:ns="www.example.com/ns"/>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:appendChild"><apiName>appendChild</apiName><shortdesc>
	Ajoute l’enfant indiqué à la fin des propriétés de l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.appendChild, appendChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XML produit.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet XML à ajouter.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
	Ajoute l’enfant indiqué à la fin des propriétés de l’objet XML. La méthode <codeph>appendChild()</codeph> accepte un objet XML, un objet XMLList ou tout autre type de données qui est ensuite converti en chaîne. 
    
    <p>Utilisez l’opérateur <codeph>delete</codeph> (XML) pour supprimer les nœuds XML.</p>
	
	</apiDesc><example conref="examples\XML.appendChild.1.as"> Cet exemple ajoute un nouvel élément à la fin de la liste enfant d’un objet XML :
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.appendChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>hello&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>world&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>delete, opérateur (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	Renvoie la valeur XML de l’attribut dont le nom correspond au paramètre attributeName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList ou objet XMLList vide. Renvoie un objet XMLList vide si vous n’avez pas défini la valeur d’un attribut.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>Nom de l’attribut.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Renvoie la valeur XML de l’attribut dont le nom correspond au paramètre <codeph>attributeName</codeph>. Les attributs sont intégrés aux éléments XML. Dans l’exemple suivant, l’élément a un attribut appelé "<codeph>gender</codeph>" avec la valeur "<codeph>boy</codeph>" : <codeph>&lt;first gender="boy">John&lt;/first></codeph>.
	
	<p>Le paramètre <codeph>attributeName</codeph> peut correspondre à n’importe quel type de données, mais String est généralement utilisé. Si vous transmettez un objet autre que QName, le paramètre <codeph>attributeName</codeph> utilise la méthode <codeph>toString()</codeph> pour convertir le paramètre en chaîne. </p>
	
	<p>Si une référence de nom complet s’impose, vous pouvez transmettre un objet QName. Un objet QName définit un espace de nom et le nom local, que vous pouvez utiliser pour définir le nom complet d’un attribut. De ce fait, appeler <codeph>attribute(qname)</codeph> n’est pas équivalent à appeler <codeph>attribute(qname.toString())</codeph>.</p>
	
	</apiDesc><example conref="examples\XMLAttributeExample1.as"> Cet exemple porte sur un objet QName transmis par la méthode <codeph>attribute()</codeph>. La propriété <codeph>localName</codeph> est <codeph>attr</codeph> et la propriété <codeph>namespace</codeph> est <codeph>ns</codeph>.
<codeblock>
 var xml:XML = &lt;ns:node xmlns:ns = "http://uri" ns:attr = '7' />       
 var qn:QName = new QName("http://uri", "attr");
 trace (xml.attribute(qn)); // 7
</codeblock></example><example conref="examples\XMLAttributeExample2.as"> Pour renvoyer un attribut avec un nom qui correspond à un mot ActionScript réservé, utilisez la méthode <codeph>attribute()</codeph> et non pas l’opérateur d’identificateur d’attribut (@), comme dans l’exemple suivant :
<codeblock>
 var xml:XML = &lt;example class="first" />
 trace(xml.attribute("class"));
 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#Namespace"><linktext>Espace de nom </linktext></link><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="operators.html#attribute_identifier"><linktext>opérateur d’identificateur d’attribut (&amp;#064;)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	Renvoie une liste de valeurs d’attribut associée à l’objet XML indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Liste de valeurs d’attributs.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une liste de valeurs d’attribut associée à l’objet XML indiqué. Utilisez la méthode <codeph>name()</codeph> en conjonction avec la méthode <codeph>attributes()</codeph> pour renvoyer le nom d’un attribut. L’utilisation de <codeph>xml.attributes()</codeph> est équivalente à <codeph>xml.@*</codeph>.
	
	</apiDesc><example conref="examples\XMLAttributesExample1.as"> L’exemple suivant renvoie le nom de l’attribut :

<codeblock>
var xml:XML=&lt;example id='123' color='blue'/>
trace(xml.attributes()[1].name()); //color
</codeblock></example><example conref="examples\XMLAttributesExample2.as"> Cet exemple renvoie les noms de tous les attributs :
<codeblock>
 
var xml:XML = &lt;example id='123' color='blue'/>
var attNamesList:XMLList = xml.@*;

trace (attNamesList is XMLList); // true
trace (attNamesList.length()); // 2

for (var i:int = 0; i &lt; attNamesList.length(); i++)
{ 
    trace (typeof (attNamesList[i])); // xml
    trace (attNamesList[i].nodeKind()); // attribute
    trace (attNamesList[i].name()); // id and color
} 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/name()"><linktext>XML.name()</linktext></link><link href="operators.html#attribute_identifier"><linktext>opérateur &amp;#064;</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:child"><apiName>child</apiName><shortdesc>
	Recense les enfants d’un objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les nœuds enfant qui correspondent au paramètre d’entrée. 
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Nom de l’élément ou entier de l’objet XML enfant. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Recense les enfants d’un objet XML. Un enfant XML est un élément, un nœud de texte, un commentaire ou une instruction de traitement XML. 
	
	<p>Le paramètre <codeph>propertyName</codeph> permet de recenser le contenu d’un enfant XML spécifique. Par exemple, pour renvoyer le contenu d’un enfant appelé <codeph>&lt;first></codeph>, utilisez <codeph>child.name("first")</codeph>. Vous pouvez générer le même résultat à partir du numéro d’index de l’enfant. Le numéro d’index identifie la position de l’enfant dans la liste d’enfants XML. Par exemple, <codeph>name.child(0)</codeph> renvoie le premier enfant d’une liste. </p>
	
	<p>Utilisez un astérisque (~~) pour extraire tous les enfants dans un document XML. Exemple : <codeph>doc.child("~~")</codeph>.</p>  
	
	<p>La méthode <codeph>length()</codeph> associée au paramètre astérisque (~~) de la méthode <codeph>child()</codeph> permet de produire le nombre total d’enfants. Exemple : <codeph>numChildren = doc.child("~~").length()</codeph>.</p>
	
	</apiDesc><example conref="examples\XML.child.1.as"> Cet exemple porte sur l’utilisation de la méthode <codeph>child()</codeph> pour identifier les éléments enfant avec le nom spécifié :
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;bar>text1&lt;/bar>
            &lt;bar>text2&lt;/bar>
        &lt;/foo>;
trace(xml.child("bar").length());  // 2
trace(xml.child("bar")[0].toXMLString()); // &lt;bar>text1&lt;/bar>
trace(xml.child("bar")[1].toXMLString()); // &lt;bar>text2&lt;/bar>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="#XMLList"><linktext>XMLList, classe</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:childIndex"><apiName>childIndex</apiName><shortdesc>
	Identifie la position d’index qui commence à zéro de cet objet XML dans le contexte de l’objet parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.childindex, childindex
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Position de l’objet. Renvoie -1 et des entiers positifs.
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Identifie la position d’index qui commence à zéro de cet objet XML dans le contexte de l’objet parent.
	
	</apiDesc><example conref="examples\XML.childIndex.1.as"> Cet exemple indique comment utiliser la méthode <codeph>childIndex()</codeph> :
<codeblock>
var xml:XML = 
            &lt;foo>
                &lt;bar />
                text
                &lt;bob />
            &lt;/foo>;
trace(xml.bar.childIndex()); // 0
trace(xml.bob.childIndex()); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:children"><apiName>children</apiName><shortdesc>
	Recense les enfants de l’objet XML dans l’ordre dans lequel ils apparaissent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant les enfants de l’objet XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Recense les enfants de l’objet XML dans l’ordre dans lequel ils apparaissent. Un enfant XML est un élément, un nœud de texte, un commentaire ou une instruction de traitement XML. 
	
	</apiDesc><example conref="examples\XML.children.1.as"> Cet exemple indique comment utiliser la méthode <codeph>children()</codeph> :
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var xml:XML = 
        &lt;foo id="22">
            &lt;bar>44&lt;/bar>
            text
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml.children().length()); // 4
trace(xml.children()[0].toXMLString()); // &lt;bar>44&lt;/bar>
trace(xml.children()[1].toXMLString()); // text
trace(xml.children()[2].toXMLString()); // &lt;!-- comment -->
trace(xml.children()[3].toXMLString()); // &lt;?instruction ?>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:comments"><apiName>comments</apiName><shortdesc>
	Recense les propriétés de l’objet XML qui contient des commentaires XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList des propriétés qui contiennent des commentaires.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Recense les propriétés de l’objet XML qui contient des commentaires XML.
	
	</apiDesc><example conref="examples\XML.comments.1.as"> Cet exemple indique comment utiliser la méthode <codeph>comments()</codeph> :
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;foo>
            &lt;!-- example -->
            &lt;!-- example2 -->
        &lt;/foo>;
trace(xml.comments().length()); // 2
trace(xml.comments()[1].toXMLString()); // &lt;!-- example2 -->
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:contains"><apiName>contains</apiName><shortdesc>
	Compare l’objet XML au paramètre value spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet XML correspond au paramètre <codeph>value</codeph>, <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Valeur à comparer à l’objet XML en cours.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Compare l’objet XML au paramètre <codeph>value</codeph> spécifié. 
	
	</apiDesc><example conref="examples\XML.contains.1.as"> Cet exemple indique comment utiliser la méthode <codeph>contains()</codeph> :
<codeblock>
var xml:XML = 
        &lt;order>
            &lt;item>Rice&lt;/item>
            &lt;item>Kung Pao Shrimp&lt;/item>
        &lt;/order>;
trace(xml.item[0].contains(&lt;item>Rice&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>Kung Pao Shrimp&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>MSG&lt;/item>)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:copy"><apiName>copy</apiName><shortdesc>
	Renvoie une copie de l’objet XML spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Copie de l’objet.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de l’objet XML spécifié. Cette copie est une duplication de l’arborescence entière de nœuds. L’objet XML copié ne possède pas de parent et renvoie <codeph>null</codeph> si vous tentez d’appeler la méthode <codeph>parent()</codeph>.
    
	</apiDesc><example conref="examples\XML.copy.1.as"> Cet exemple indique que la méthode <codeph>copy()</codeph> crée une nouvelle occurrence d’un objet XML. Lorsque vous modifiez la copie, l’original reste inchangé :
<codeblock>
var xml1:XML = &lt;foo />;
var xml2:XML = xml1.copy();
xml2.appendChild(&lt;bar />);
trace(xml1.bar.length()); // 0
trace(xml2.bar.length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:defaultSettings"><apiName>defaultSettings</apiName><shortdesc>
	Renvoie un objet avec les propriétés suivantes définies sur les valeurs par défaut : ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent et prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.defaultSettings, defaultSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Objet dont les propriétés sont réglées sur leur valeur par défaut.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie un objet avec les propriétés suivantes définies sur les valeurs par défaut : <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> et <codeph>prettyPrinting</codeph>. Les valeurs par défaut sont les suivantes :
	
	<ul>
	   <li><codeph>ignoreComments = true</codeph></li>
	   <li><codeph>ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>ignoreWhitespace = true</codeph></li>
	 <li><codeph>prettyIndent = 2</codeph></li>
	   <li><codeph>prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>Remarque :</b> cette méthode ne doit pas être appliquée à une occurrence de la classe XML, mais à <codeph>XML</codeph>, comme illustré dans le code suivant : <codeph>var df:Object = XML.defaultSettings()</codeph>. </p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> L’exemple ci-dessous illustre les points suivants : comment appliquer des paramètres personnalisés (pour l’inclusion de commentaires et d’instructions de traitement) avant de définir un objet XML ; comment ensuite rétablir les paramètres par défaut avant de définir un autre objet XML ; et enfin comment définir de nouveau les paramètres par défaut (pour définir d’autres objets XML) :
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link><link href="#XML/settings()"><linktext>XML.settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	Renvoie tous les descendants (enfants, petits-enfants, arrière-petits-enfants, etc.) de l’objet XML associés au paramètre name indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList contenant tous les descendants correspondants. S’il n’existe pas de descendants, la méthode renvoie un objet XMLList vide.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Nom de l’élément pour lequel établir une correspondance.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Renvoie tous les descendants (enfants, petits-enfants, arrière-petits-enfants, etc.) de l’objet XML associés au paramètre <codeph>name</codeph> indiqué. Le paramètre <codeph>name</codeph> est facultatif. Le paramètre <codeph>name</codeph> peut être un objet QName, un type de données String ou tout autre type de données converti ensuite au type de données String.
	
	<p>Pour renvoyer tous les descendants, utilisez le paramètre « ~~ ». Si aucun paramètre n’est transmis, la chaîne « ~~ » est transmise et renvoie tous les descendants de l’objet XML.</p>
	
	</apiDesc><example conref="examples\XMLDescendantsExample1.as"> Pour renvoyer les descendants sous des noms qui correspondent aux mots réservés ActionScript, utilisez la méthode <codeph>descendants()</codeph> de préférence à l’opérateur de descendance (..), comme indiqué dans l’exemple suivant : 
<codeblock>
var xml:XML = 
  &lt;enrollees>
    &lt;student id="239">
        &lt;class name="Algebra" />
        &lt;class name="Spanish 2"/>
    &lt;/student>
    &lt;student id="206">
        &lt;class name="Trigonometry" />
        &lt;class name="Spanish 2" />
    &lt;/student>
  &lt;/enrollees>
trace(xml.descendants("class")); 
</codeblock></example><example conref="examples\XML.descendants.1.as"> Cet exemple illustre le fait que la méthode <codeph>descendants()</codeph> renvoie un objet XMLList qui contient <i>tous</i> les objets descendants, ce qui inclut les enfants, les petits enfants, etc. :
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;body>
            &lt;!-- comment -->
            text1
            &lt;a>
                &lt;b>text2&lt;/b>
            &lt;/a>
        &lt;/body>;
trace(xml.descendants("*").length()); // 5
trace(xml.descendants("*")[0]); // // &lt;!-- comment -->
trace(xml.descendants("*")[1].toXMLString()); // text1
trace(xml.descendants("a").toXMLString()); // &lt;a>&lt;b>text2&lt;/b>&lt;/a>
trace(xml.descendants("b").toXMLString()); // &lt;b>text2&lt;/b>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#descendant_accessor"><linktext>accesseur de descendance (..) operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:elements"><apiName>elements</apiName><shortdesc>
	 Recense les éléments d’un objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.elements, elements
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XMLList qui comporte le contenu de l’élément. Le contenu d’un élément est compris entre la balise de début et la balise de fin. Si vous utilisez l’astérisque (~~) pour appeler tous les éléments, les balises et le contenu sont renvoyés.
	 
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Nom de l’élément. Un nom d’élément est entouré de chevrons. Par exemple, "<codeph>first</codeph>" correspond à <codeph>name</codeph> dans cet exemple : <codeph>&lt;first>&lt;/first></codeph> . 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Recense les éléments d’un objet XML. Un élément se compose d’une balise de début et d’une balise de fin, telle que <codeph>&lt;first>&lt;/first></codeph>. Le paramètre <codeph>name</codeph> est facultatif. Le paramètre <codeph>name</codeph> peut être un objet QName, un type de données String ou tout autre type de données converti ensuite au type de données String. Utilisez le paramètre <codeph>name</codeph> pour recenser un élément spécifique. Par exemple, l’élément <codeph>first</codeph> renvoie <codeph>John</codeph> dans cet exemple : <codeph>&lt;first>John&lt;/first></codeph>. 
	 
	 <p>Pour recenser tous les éléments, utilisez le paramètre astérisque (~~). L’astérisque est également le paramètre par défaut. </p>
	 
	 <p>La méthode <codeph>length()</codeph> associée au paramètre astérisque permet d’extraire le nombre total d’éléments. Par exemple, <codeph>numElement = addressbook.elements("~~").length()</codeph>.</p>
	 
	 </apiDesc><example conref="examples\XML.elements.1.as"> L’exemple suivant indique que la méthode <codeph>elements()</codeph> renvoie uniquement une liste d’éléments — sans commentaire, propriété de texte ou instruction de traitement :
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
            text
            &lt;a>1&lt;/a>
            &lt;b>2&lt;/b>
        &lt;/foo>;
trace(xml.elements("*").length()); // 2
trace(xml.elements("*")[0].toXMLString()); // &lt;a>1&lt;/a>
trace(xml.elements("b").length()); // 1
trace(xml.elements("b")[0].toXMLString()); // &lt;b>2&lt;/b>
</codeblock></example><example conref="examples\XMLElementsExample1.as"> Pour renvoyer les descendants sous des noms qui correspondent aux mots réservés ActionScript, utilisez la méthode <codeph>elements()</codeph> de préférence à l’opérateur point (.) du code XML, comme indiqué dans l’exemple suivant :
<codeblock>
var xml:XML =
 &lt;student id="206">
    &lt;class name="Trigonometry" />
    &lt;class name="Spanish 2" />
 &lt;/student>
trace(xml.elements("class")); 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XMLList"><linktext>XMLList, classe</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="operators.html#dot_(XML)"><linktext>point XML (.) operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	Vérifie si l’objet XML intègre un contenu complexe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet XML intègre un contenu complexe, <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Vérifie si l’objet XML intègre un contenu complexe. Le contenu d’un objet XML est complexe s’il possède des éléments enfant. Les objets XML qui représentent des attributs, des commentaires, des instructions de traitement et des nœuds de texte n’intègrent pas un contenu complexe. Le contenu d’un objet qui <i>intègre</i> ces entités peut néanmoins être considéré comme complexe si l’objet possède des éléments enfant.
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> L’exemple suivant porte sur un objet XML, avec une propriété appelée <codeph>a</codeph> qui a un contenu simple et une autre propriété <codeph>a</codeph> qui a du contenu complexe :
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	Vérifie si l’objet possède la propriété spécifiée par le paramètre p.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si la propriété existe, <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Propriété pour laquelle établir une correspondance.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vérifie si l’objet possède la propriété spécifiée par le paramètre <codeph>p</codeph>. 
	
	</apiDesc><example conref="examples\XML.hasOwnProperty.1.as"> L’exemple suivant utilise la méthode <codeph>hasOwnProperty()</codeph> pour s’assurer que la propriété (<codeph>b</codeph>) existe avant d’évaluer une expression (<codeph>b == "11"</codeph>) qui utilise cette propriété :
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a />
            &lt;a>
                &lt;b>10&lt;/b>
            &lt;/a>
            &lt;a>
                &lt;b>11&lt;/b>
            &lt;/a>
        &lt;/foo>;
trace(xml.a.(hasOwnProperty("b") &amp;&amp; b == "11")); 
</codeblock> Si la dernière ligne de cet exemple était remplacée par ce qui suit, Flash Player renverrait une exception dans la mesure où le premier élément appelé <codeph>a</codeph> ne comporte pas de propriété <codeph>b</codeph> :
 <p>
 <pre>trace(xml.a.(b == "11"));</pre>
 </p>
</example><example conref="examples\XML.hasOwnProperty.2.as"> L’exemple suivant utilise la méthode <codeph>hasOwnProperty()</codeph> pour s’assurer que la propriété (<codeph>item</codeph>) existe avant d’évaluer une expression (<codeph>item.contains("toothbrush")</codeph>) qui utilise cette propriété :
<codeblock>
var xml:XML = 
        &lt;orders>
            &lt;order id='1'>
                &lt;item>toothbrush&lt;/item>
                &lt;item>toothpaste&lt;/item>
            &lt;/order>
            &lt;order>
                &lt;returnItem>shoe polish&lt;/returnItem>
            &lt;/order>
        &lt;/orders>;
trace(xml.order.(hasOwnProperty("item") &amp;&amp; item.contains("toothbrush"))); 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	Vérifie si l’objet XML intègre un contenu simple.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet XML intègre un contenu simple, <codeph>false</codeph> dans le cas contraire.
	
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Vérifie si l’objet XML intègre un contenu simple. Un objet XML intègre un contenu simple s’il représente un nœud de texte, un nœud d’attribut ou un élément XML sans élément enfant. Les objets XML qui représentent des commentaires et des instructions de traitement n’intègrent <i>pas</i> un contenu simple.
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> L’exemple suivant porte sur un objet XML, avec une propriété appelée <codeph>a</codeph> qui a un contenu simple et une autre propriété <codeph>a</codeph> qui a du contenu complexe :
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:inScopeNamespaces"><apiName>inScopeNamespaces</apiName><shortdesc>
	Recense les espaces de nom associés à l’objet XML, par rapport au parent de l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.inScopeNamespaces, inScopeNamespaces
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Tableau d’objets Namespace. 
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Recense les espaces de nom associés à l’objet XML, par rapport au parent de l’objet. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:insertChildAfter"><apiName>insertChildAfter</apiName><shortdesc>
	Insère le paramètre child2 indiqué après le paramètre child1 dans cet objet XML et renvoie l’objet produit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildAfter, insertChildAfter
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XML produit ou <codeph>undefined</codeph>.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet dans l’objet source que vous insérez avant <codeph>child2</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet à insérer.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Insère le paramètre <codeph>child2</codeph> indiqué après le paramètre <codeph>child1</codeph> dans cet objet XML et renvoie l’objet produit. Si le paramètre <codeph>child1</codeph> est réglé sur <codeph>null</codeph>, la méthode insère le contenu de <codeph>child2</codeph> <i>avant</i> tous les enfants de l’objet XML (en d’autres termes, après <i>none</i>). Si <codeph>child1</codeph> est fourni, mais qu’il n’existe pas dans l’objet XML, celui-ci n’est pas modifié et <codeph>undefined</codeph> est renvoyé.
	
	<p>Si vous appelez cette méthode pour un enfant XML qui n’est pas un élément (texte, attributs, commentaires, pi, etc.), <codeph>undefined</codeph> est renvoyé.</p>
    
    <p>Utilisez l’opérateur <codeph>delete</codeph> (XML) pour supprimer les nœuds XML.</p>
	
	</apiDesc><example conref="examples\XML.insertChildAfter.1.as"> L’exemple suivant ajoute un nouvel élément à la fin des éléments enfant d’un objet XML :
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildAfter(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> Le code <codeph>trace()</codeph> suivant est renvoyé :
 <pre><codeph> &lt;menu>
     &lt;item>burger&lt;/item>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>soda&lt;/item>
 &lt;/menu></codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildBefore()"><linktext>XML.insertChildBefore()</linktext></link><link href="operators.html#delete_(XML)"><linktext>delete, opérateur (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:insertChildBefore"><apiName>insertChildBefore</apiName><shortdesc>
	Insère le paramètre child2 indiqué avant le paramètre child1 dans cet objet XML et renvoie l’objet produit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildBefore, insertChildBefore
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XML produit ou <codeph>undefined</codeph>.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet de l’objet source que vous insérez après <codeph>child2</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet à insérer.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Insère le paramètre <codeph>child2</codeph> indiqué après le paramètre <codeph>child1</codeph> dans cet objet XML et renvoie l’objet produit. Si le paramètre <codeph>child1</codeph> est réglé sur <codeph>null</codeph>, la méthode insère le contenu de <codeph>child2</codeph> <i>après</i> tous les enfants de l’objet XML (en d’autres termes, avant <i>none</i>). Si <codeph>child1</codeph> est fourni, mais qu’il n’existe pas dans l’objet XML, celui-ci n’est pas modifié et <codeph>undefined</codeph> est renvoyé.
	
	<p>Si vous appelez cette méthode pour un enfant XML qui n’est pas un élément (texte, attributs, commentaires, pi, etc.), <codeph>undefined</codeph> est renvoyé.</p>
    
    <p>Utilisez l’opérateur <codeph>delete</codeph> (XML) pour supprimer les nœuds XML.</p>
	
	</apiDesc><example conref="examples\XML.insertChildBefore.1.as"> L’exemple suivant ajoute un nouvel élément à la fin des éléments enfant d’un objet XML :
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildBefore(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> Le code <codeph>trace()</codeph> suivant est renvoyé :
 <pre>
 &lt;menu>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>burger&lt;/item>
     &lt;item>soda&lt;/item>
 &lt;/menu></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildAfter()"><linktext>XML.insertChildAfter()</linktext></link><link href="operators.html#delete_(XML)"><linktext>delete, opérateur (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:length"><apiName>length</apiName><shortdesc>
	Pour les objets XML, cette méthode renvoie toujours l’entier 1.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie toujours <codeph>1</codeph> pour tout objet XML.
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Pour les objets XML, cette méthode renvoie toujours l’entier <codeph>1</codeph>. La méthode <codeph>length()</codeph> de la classe XMLList renvoie la valeur <codeph>1</codeph> si l’objet XMLList ne contient qu’une seule valeur.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:localName"><apiName>localName</apiName><shortdesc>
	Indique la partie nom local du nom complet de l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.localName, localName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Nom local exprimé sous forme de chaîne ou <codeph>null</codeph>.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Indique la partie nom local du nom complet de l’objet XML.
	
	</apiDesc><example conref="examples\XML.localName.1.as"> L’exemple suivant illustre l’utilisation de la méthode <codeph>localName()</codeph>.
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.localName()); // Envelope
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:name"><apiName>name</apiName><shortdesc>
	Indique le nom complet de l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.name, name
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Le nom complet correspond à QName ou <codeph>null</codeph>.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Indique le nom complet de l’objet XML. 
	
	</apiDesc><example conref="examples\XML.name.1.as"> L’exemple suivant illustre l’utilisation de la méthode <codeph>name()</codeph> pour obtenir le nom qualifié d’un objet XML :
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.name().localName); // Envelope
trace(xml.name().uri); // "http://www.w3.org/2001/12/soap-envelope"
</codeblock></example><example conref="examples\XML.name.2.as"> L’exemple suivant illustre l’utilisation de la méthode <codeph>name()</codeph> lorsqu’elle est appelée sur une propriété XML, sur un élément de texte et sur un attribut :
<codeblock>
var xml:XML = 
        &lt;foo x="15" y="22">
            text
        &lt;/foo>;
        
trace(xml.name().localName); // foo
trace(xml.name().uri == ""); // true
trace(xml.children()[0]); // text
trace(xml.children()[0].name()); // null
trace(xml.attributes()[0]); // 15
trace(xml.attributes()[0].name()); // x
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="operators.html#attribute_identifier"><linktext>identificateur d’attribut</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:namespace"><apiName>namespace</apiName><shortdesc>
	Si vous ne fournissez pas de paramètre, indique l’espace de nom associé au nom complet de cet objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespace, namespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Renvoie <codeph>null</codeph>, <codeph>undefined</codeph> ou un espace de nom.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>prefix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Préfixe pour lequel établir une correspondance.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Si vous ne fournissez pas de paramètre, indique l’espace de nom associé au nom complet de cet objet XML. Si vous spécifiez un paramètre <codeph>prefix</codeph>, la méthode renvoie l’espace de nom correspondant au paramètre <codeph>prefix</codeph> qui figure dans le domaine associé à l’objet XML. S’il n’existe pas d’espace de nom de ce type, la méthode renvoie <codeph>undefined</codeph>.
	
	</apiDesc><example conref="examples\XML.namespace.1.as"> L’exemple suivant utilise la méthode <codeph>namespace()</codeph> pour obtenir l’espace de nom d’un objet XML et l’affecter à un objet Namespace appelé <codeph>soap</codeph> qui est ensuite utilisé pour identifier une propriété de l’objet <codeph>xml</codeph> (<codeph>xml.soap::Body[0]</codeph>) :
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
var soap:Namespace = xml.namespace();
trace(soap.prefix); // soap
trace(soap.uri); // http://www.w3.org/2001/12/soap-envelope

var body:XML = xml.soap::Body[0];
trace(body.namespace().prefix); // soap
trace(xml.namespace().uri); // http://www.w3.org/2001/12/soap-envelope
trace(body.namespace("wx").uri); // "http://example.com/weather"
</codeblock></example><example conref="examples\XML.namespace.2.as"> L’exemple suivant utilise la méthode <codeph>namespace()</codeph> pour obtenir l’espace de nom par défaut d’un nœud, ainsi que l’espace de nom pour un préfixe spécifique (<codeph>"dc"</codeph>) :
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">
                &lt;!-- ... -->
        &lt;/rdf:RDF>;
                    
trace(xml.namespace()); // http://www.w3.org/1999/02/22-rdf-syntax-ns#
trace(xml.namespace("dc")); // http://purl.org/dc/elements/1.1/
trace(xml.namespace("foo")); // undefined
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:namespaceDeclarations"><apiName>namespaceDeclarations</apiName><shortdesc>
	Recense les déclarations d’espace de nom associées à l’objet XML dans le contexte de l’objet parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespaceDeclarations, namespaceDeclarations
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Tableau d’objets Namespace.
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Recense les déclarations d’espace de nom associées à l’objet XML dans le contexte de l’objet parent. 
	
	</apiDesc><example conref="examples\XML.namespaceDeclarations.1.as"> L’exemple suivant renvoie les déclarations d’espace de nom d’un objet XML :
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">

            &lt;!-- ... -->
            
        &lt;/rdf:RDF>;
                    
for (var i:uint = 0; i &lt; xml.namespaceDeclarations().length; i++) {
    var ns:Namespace = xml.namespaceDeclarations()[i]; 
    var prefix:String = ns.prefix;
    if (prefix == "") {
        prefix = "(default)";
    }
    trace(prefix + ":" , ns.uri);
}
</codeblock> Le code <codeph>trace()</codeph> suivant est renvoyé :
 <pre><codeph>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
 dc: http://purl.org/dc/elements/1.1/
 (default): http://purl.org/rss/1.0/</codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/namespace()"><linktext>XML.namespace()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:nodeKind"><apiName>nodeKind</apiName><shortdesc>
	Définit le type de nœud : texte, commentaire, instruction de traitement, attribut ou élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.nodeKind, nodeKind
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Type de nœud utilisé.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Définit le type de nœud : texte, commentaire, instruction de traitement, attribut ou élément. 
	
	</apiDesc><example conref="examples\XMLNodeKindExample1.as"> Cet exemple suit les cinq types de nœud :
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;

var xml:XML = 
    &lt;example id="10">
        &lt;!-- this is a comment -->
        &lt;?test this is a pi ?>
        and some text
    &lt;/example>;

trace(xml.nodeKind()); // element
trace(xml.children()[0].nodeKind()); // comment
trace(xml.children()[1].nodeKind()); // processing-instruction
trace(xml.children()[2].nodeKind()); // text
trace(xml.@id[0].nodeKind()); // attribute
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#attribute_identifier"><linktext>identificateur d’attribut</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	Pour l’objet XML et tous les objets XML descendants, fusionne les nœuds de texte adjacents et supprime les nœuds de texte vides.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XML normalisé produit.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Pour l’objet XML et tous les objets XML descendants, fusionne les nœuds de texte adjacents et supprime les nœuds de texte vides.
	
	</apiDesc><example conref="examples\XML.normalize.1.as"> L’exemple suivant illustre l’effet de l’appel de la méthode <codeph>normalize()</codeph> :
<codeblock>
var xml:XML = &lt;body>&lt;/body>;
xml.appendChild("hello");
xml.appendChild(" world");
trace(xml.children().length()); // 2
xml.normalize();
trace(xml.children().length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:parent"><apiName>parent</apiName><shortdesc>
	Renvoie le parent de l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Une référence XML du noeud parent ou <codeph>undefined</codeph> si l’objet XML n’a pas de parent.
	
	</apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	Renvoie le parent de l’objet XML. Si l’objet XML ne possède pas de parent, la méthode renvoie <codeph>undefined</codeph>.
	
	</apiDesc><example conref="examples\XML.parent.1.as"> L’exemple suivant utilise la méthode <codeph>parent()</codeph> pour identifier l’élément parent d’un élément spécifique dans une structure XML :
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p id="p1">Hello&lt;/p>
        &lt;p id="p2">Test:
            &lt;ul>
                &lt;li>1&lt;/li>
                &lt;li>2&lt;/li>
            &lt;/ul>
        &lt;/p>
    &lt;/body>;
var node:XML = xml.p.ul.(li.contains("1"))[0]; // == &lt;ul> ... &lt;/ul>
trace(node.parent().@id); // p2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:prependChild"><apiName>prependChild</apiName><shortdesc>
	Insère une copie de l’objet child fourni dans l’élément XML avant toute propriété XML associée à cet élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prependChild, prependChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XML produit.
    
    </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet à insérer.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Insère une copie de l’objet <codeph>child</codeph> fourni dans l’élément XML avant toute propriété XML associée à cet élément.
    
    <p>Utilisez l’opérateur <codeph>delete</codeph> (XML) pour supprimer les nœuds XML.</p> 
	
	</apiDesc><example conref="examples\XML.prependChild.1.as"> L’exemple suivant utilise la méthode <codeph>prependChild()</codeph> pour ajouter un élément au début de la liste d’enfants d’un objet XML :
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.prependChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>world&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>opérateur delete (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	Si un paramètre name est spécifié, la méthode recense tous les enfants de l’objet XML qui contiennent des instructions de traitement portant le nom indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Liste d’objets enfant correspondants.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>Nom des instructions de traitement pour lesquelles établir une correspondance.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Si un paramètre <codeph>name</codeph> est spécifié, recense tous les enfants de l’objet XML qui contiennent des instructions de traitement portant le <codeph>name</codeph> indiqué. Si aucun paramètre n’est spécifié, la méthode recense tous les enfants de l’objet XML qui contiennent des instructions de traitement.
	
	</apiDesc><example conref="examples\XML.processingInstructions.1.as"> L’exemple suivant utilise la méthode <codeph>processingInstructions()</codeph> pour obtenir un tableau d’instructions de traitement pour un objet XML :
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml:XML =
    &lt;body>
            foo
            &lt;?xml-stylesheet href="headlines.css" type="text/css" ?>
            &lt;?instructionX ?>
            
    &lt;/body>;

trace(xml.processingInstructions().length()); // 2
trace(xml.processingInstructions()[0].name()); // xml-stylesheet
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	Vérifie si la propriété p figurre dans le jeu de propriétés qui peut faire l’objet d’une itération avec une instruction for..in appliquée à l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Si la propriété peut faire l’objet d’une itération dans une instruction <codeph>for..in</codeph>, puis <codeph>true</codeph> ; sinon <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Propriété à vérifier.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vérifie si la propriété <codeph>p</codeph> figurre dans le jeu de propriétés qui peut faire l’objet d’une itération avec une instruction <codeph>for..in</codeph> appliquée à l’objet XML. Ne renvoie <codeph>true</codeph> que si <codeph>toString(p) == "0"</codeph>. 
	
	</apiDesc><example conref="examples\XML.propertyIsEnumerable.1.as"> L’exemple suivant indique que, pour un objet XML, la méthode <codeph>propertyNameIsEnumerable()</codeph> ne renvoie la valeur <codeph>true</codeph> que pour la valeur <codeph>0</codeph>, tandis que pour un objet XMLList, la valeur renvoyée est <codeph>true</codeph> pour chaque valeur d’index valide pour l’objet XMLList :
<codeblock>
var xml:XML = 
        &lt;body>
             &lt;p>Hello&lt;/p>
               &lt;p>World&lt;/p>
        &lt;/body>;

trace(xml.propertyIsEnumerable(0)); // true
trace(xml.propertyIsEnumerable(1)); // false

for (var propertyName:String in xml) {
    trace(xml[propertyName]);
}

var list:XMLList = xml.p;
trace(list.propertyIsEnumerable(0)); // true
trace(list.propertyIsEnumerable(1)); // true
trace(list.propertyIsEnumerable(2)); // false

for (var propertyName:String in list) { 
    trace(list[propertyName]);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:removeNamespace"><apiName>removeNamespace</apiName><shortdesc>
	Supprime l’espace de nom indiqué pour cet objet et tous ses descendants.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.removeNamespace, removeNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Copie de l’objet XML produit.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Espace de nom à supprimer.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Supprime l’espace de nom indiqué pour cet objet et tous ses descendants. La méthode <codeph>removeNamespaces()</codeph> ne supprime pas un espace de nom s’il est référencé par le nom complet de l’objet ou celui des attributs de l’objet.
	
	</apiDesc><example conref="examples\XML.removeNamespace.1.as"> L’exemple suivant indique comment supprimer une déclaration d’espace de nom à partir d’un objet XML :
<codeblock>
var xml:XML = 
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
        xmlns:dc="http://purl.org/dc/elements/1.1/" 
        xmlns="http://purl.org/rss/1.0/">
    
        &lt;!-- ... -->
        
    &lt;/rdf:RDF>;

trace(xml.namespaceDeclarations().length); // 3
trace(xml.namespaceDeclarations()[0] is String); // 
var dc:Namespace = xml.namespace("dc");
xml.removeNamespace(dc);
trace(xml.namespaceDeclarations().length); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:replace"><apiName>replace</apiName><shortdesc>
	Remplace les propriétés spécifiées par le paramètre propertyName par le paramètre value indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.replace, replace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XML produit, dans lequel les propriétés correspondantes ont été remplacées.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Peut être une valeur numérique, un nom incomplet d’ensemble d’éléments XML, un nom complet d’ensemble d’éléments XML ou le caractère générique astérisque (« * »). Utilisez un nom incomplet pour identifier les éléments XML dans l’espace de nom par défaut. 
	
	</apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Valeur de remplacement, qui peut être un objet XML, un objet XMLList ou toute valeur pouvant être convertie par le biais de <codeph>toString()</codeph>. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Remplace les propriétés spécifiées par le paramètre <codeph>propertyName</codeph> par le paramètre <codeph>value</codeph> indiqué. Si aucune propriété ne correspond à <codeph>propertyName</codeph>, l’objet XML n’est pas modifié.
	
	</apiDesc><example conref="examples\XML.replace.1.as"> L’exemple suivant illustre l’appel à la méthode <codeph>replace()</codeph> avec un entier en tant que premier paramètre :
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace(1, &lt;p>Bob&lt;/p>);
trace(xml);
</codeblock> Le résultat du code <codeph>trace()</codeph> est le suivant :
 <pre><codeph>
 &lt;body>
     &lt;p>Hello&lt;/p>
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/body>
 </codeph></pre>
</example><example conref="examples\XML.replace.2.as"> L’exemple suivant appelle la méthode <codeph>replace()</codeph> avec une chaîne en tant que premier paramètre :
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("p", &lt;p>Hi&lt;/p>); 
trace(xml);
</codeblock> Le résultat du code <codeph>trace()</codeph> est le suivant :
 
 <pre><codeph>
 &lt;body>
     &lt;p>Hi&lt;/p>
     &lt;hr/>
 &lt;/body>;
 </codeph></pre>
</example><example conref="examples\XML.replace.3.as"> L’exemple suivant illustre l’appel à la méthode <codeph>replace()</codeph> avec un QName en tant que premier paramètre :
<codeblock>
var xml:XML = 
    &lt;ns:body xmlns:ns = "myNS">
        &lt;ns:p>Hello&lt;/ns:p>
        &lt;ns:p>World&lt;/ns:p>
        &lt;hr/>
    &lt;/ns:body>;

var qname:QName = new QName("myNS", "p");
xml.replace(qname, &lt;p>Bob&lt;/p>);
trace(xml);

</codeblock> Le résultat du code <codeph>trace()</codeph> est le suivant :
 
 <pre><codeph>
 &lt;ns:body xmlns:ns = "myNS">
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/ns:body>
 </codeph></pre>
</example><example conref="examples\XML.replace.4.as"> L’exemple suivant illustre l’appel à la méthode <codeph>replace()</codeph> avec la chaîne <codeph>"*"</codeph> en tant que premier paramètre :
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("*", &lt;img src = "hello.jpg"/>);
trace(xml);
</codeblock> Le résultat du code <codeph>trace()</codeph> est le suivant :
 
 <pre><codeph>
 &lt;body>
     &lt;img src="hello.jpg"/>
 &lt;/body>
 </codeph></pre>
</example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setChildren"><apiName>setChildren</apiName><shortdesc>
	Remplace les propriétés enfant de l’objet XML par l’ensemble de propriétés XML spécifié, fourni dans le paramètre value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setChildren, setChildren
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Objet XML produit. 
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Propriétés XML de remplacement (objet XML unique ou objet XMLList). 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Remplace les propriétés enfant de l’objet XML par l’ensemble de propriétés XML spécifié, fourni dans le paramètre <codeph>value</codeph>.
	
	</apiDesc><example conref="examples\XML.setChildren.1.as"> L’exemple suivant illustre l’appel de la méthode <codeph>setChildren()</codeph>, tout d’abord en utilisant un objet XML en tant que paramètre, puis utilise un objet XMLList en tant que paramètre :
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
    &lt;/body>;

var list:XMLList = xml.p;

xml.setChildren(&lt;p>hello&lt;/p>);
trace(xml);

//    &lt;body>
//        &lt;p>hello&lt;/p>
//    &lt;/body>

xml.setChildren(list);
trace(xml);

//    &lt;body>
//        &lt;p>Hello&lt;/p>
//        &lt;p>World&lt;/p>
//    &lt;/body>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setLocalName"><apiName>setLocalName</apiName><shortdesc>
	Remplace le nom local de l’objet XML par le paramètre name indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setLocalName, setLocalName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de remplacement du nom local.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Remplace le nom local de l’objet XML par le paramètre <codeph>name</codeph> indiqué. 
	
	</apiDesc><example conref="examples\XML.setLocalName.1.as"> L’exemple suivant utilise la méthode <codeph>setLocalName()</codeph> pour modifier le nom local d’un élément XML :
<codeblock>
var xml:XML = 
    &lt;ns:item xmlns:ns="http://example.com">
        toothbrush
    &lt;/ns:item>;
    
xml.setLocalName("orderItem");
trace(xml.toXMLString()); // &lt;ns:orderItem xmlns:ns="http://example.com">toothbrush&lt;/ns:orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setName"><apiName>setName</apiName><shortdesc>
	Règle le nom de l’objet XML sur le nom complet ou le nom d’attribut indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setName, setName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nouveau nom de l’objet.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Règle le nom de l’objet XML sur le nom complet ou le nom d’attribut indiqué. 
	
	</apiDesc><example conref="examples\XML.setName.1.as"> L’exemple suivant utilise la méthode <codeph>setName()</codeph> pour modifier le nom local d’un élément XML :
<codeblock>
var xml:XML = 
    &lt;item>
        toothbrush
    &lt;/item>;
    
xml.setName("orderItem");
trace(xml.toXMLString()); // &lt;orderItem>toothbrush&lt;/orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setNamespace"><apiName>setNamespace</apiName><shortdesc>
	Définit l’espace de nom associé à l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setNamespace, setNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Nouvel espace de nom.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Définit l’espace de nom associé à l’objet XML.
	
	</apiDesc><example conref="examples\XML.setNamespace.1.as"> L’exemple suivant utilise l’espace de nom <codeph>soap</codeph> défini dans un objet XML et l’applique à l’espace de nom d’un autre objet XML (<codeph>xml2</codeph>) :
<codeblock>
var xml1:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">
            &lt;!-- ... -->
        &lt;/soap:Envelope>;
var ns:Namespace = xml1.namespace("soap");

var xml2:XML = 
    &lt;Envelope>
        &lt;Body/>
    &lt;/Envelope>;
    
xml2.setNamespace(ns);

trace(xml2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setSettings"><apiName>setSettings</apiName><shortdesc>
	Définit les valeurs des propriétés XML suivantes : ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent et prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setSettings, setSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Objet doté des propriétés suivantes : 
	
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Définit les valeurs des propriétés XML suivantes : <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> et <codeph>prettyPrinting</codeph>. Les réglages par défaut, appliqués si vous ne spécifiez pas de paramètre <codeph>setObj</codeph>, sont les suivants :
	
	<ul>
	   <li><codeph>XML.ignoreComments = true</codeph></li>
	   <li><codeph>XML.ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>XML.ignoreWhitespace = true</codeph></li>
	   <li><codeph>XML.prettyIndent = 2</codeph></li>
	   <li><codeph>XML.prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>Remarque </b>: cette méthode ne doit pas être appliquée à une occurrence de la classe XML, mais à <codeph>XML</codeph>, comme illustré dans le code suivant : <codeph>XML.setSettings()</codeph>.</p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> L’exemple ci-dessous illustre les points suivants : comment appliquer des paramètres personnalisés (pour l’inclusion de commentaires et d’instructions de traitement) avant de définir un objet XML ; comment ensuite rétablir les paramètres par défaut avant de définir un autre objet XML ; et enfin comment définir de nouveau les paramètres par défaut (pour définir d’autres objets XML) :
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>defaultSettings()</linktext></link><link href="#XML/settings()"><linktext>settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:settings"><apiName>settings</apiName><shortdesc>
	Extrait les propriétés suivantes : ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent et prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.settings, settings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Objet doté des propriétés XML suivantes :
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Extrait les propriétés suivantes : <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> et <codeph>prettyPrinting</codeph>.
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> L’exemple ci-dessous illustre les points suivants : comment appliquer des paramètres personnalisés (pour l’inclusion de commentaires et d’instructions de traitement) avant de définir un objet XML ; comment ensuite rétablir les paramètres par défaut avant de définir un autre objet XML ; et enfin comment définir de nouveau les paramètres par défaut (pour définir d’autres objets XML) :
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>XML.defaultSettings()</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:text"><apiName>text</apiName><shortdesc>
	Renvoie un objet XMLList contenant toutes les propriétés XML de l’objet XML qui représente les nœuds de texte XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Liste des propriétés.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie un objet XMLList contenant toutes les propriétés XML de l’objet XML qui représente les nœuds de texte XML.
	
	</apiDesc><example conref="examples\XML.text.1.as"> L’exemple suivant utilise la méthode <codeph>text()</codeph> pour obtenir les nœuds texte d’un objet XML :
<codeblock>
var xml:XML =
        &lt;body>
            text1
            &lt;hr/>
            text2
        &lt;/body>;
trace(xml.text()[0]); // text1
trace(xml.text()[1]); // text2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:toString"><apiName>toString</apiName><shortdesc>
	Renvoie l’objet XML sous forme de chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’objet XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie l’objet XML sous forme de chaîne. Les règles de cette conversion varient selon que l’objet XML intègre un contenu simple ou complexe :
	
	<ul>
		<li>Si l’objet XML comporte un contenu simple, <codeph>toString()</codeph> renvoie le contenu de la chaîne de l’objet XML en éliminant les éléments suivants : la balise initiale, les attributs, les déclarations d’espace de nom et la balise de fin.</li> 
	</ul>
	
	<ul>
		<li> Si l’objet XML intègre un contenu complexe, <codeph>toString()</codeph> renvoie une chaîne codée au format XML qui représente l’objet XML entier, y compris la balise de début, les attributs, les déclarations d’espace de nom et la balise de fin.</li>
	</ul>
	
	<p>Pour renvoyer à chaque fois l’objet XML entier, utilisez la méthode <codeph>toXMLString()</codeph>.</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> L’exemple suivant indique ce que la méthode <codeph>toString()</codeph> renvoie lorsque l’objet XML a un contenu simple :
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> L’exemple suivant indique ce que la méthode <codeph>toString()</codeph> renvoie lorsque l’objet XML a un contenu complexe :
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	Renvoie l’objet XML sous forme de chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’objet XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie l’objet XML sous forme de chaîne. A l’encontre de la méthode <codeph>toString()</codeph>, la méthode <codeph>toXMLString()</codeph> renvoie toujours la balise de début, les attributs et la balise de fin de l’objet XML, que son contenu soit simple ou complexe (la méthode <codeph>toString()</codeph> supprime ces éléments si l’objet XML intègre un contenu simple).
	
	</apiDesc><example conref="examples\XML.toXMLString.1.as"> L’exemple suivant illustre la différence entre l’utilisation de la méthode <codeph>toString()</codeph> (qui s’applique à tous les paramètres d’une méthode <codeph>trace()</codeph>, par défaut) et celle de la méthode <codeph>toXMLString()</codeph> :
<codeblock>
var xml:XML =
        &lt;p>hello&lt;/p>;
trace(xml); // hello
trace(xml.toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/toString()"><linktext>XML.toString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	Renvoie l’objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur primitive d’une occurrence de XML.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie l’objet XML. 
	
	</apiDesc><example conref="examples\XML.valueOf.1.as"> L’exemple suivant indique que la valeur renvoyée par la méthode <codeph>valueOf()</codeph> est identique à l’objet XML source :
<codeblock>
var xml:XML = &lt;p>hello&lt;/p>;
trace(xml.valueOf() === xml); // true
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="XML:ignoreComments:get"><apiName>ignoreComments</apiName><shortdesc>
	Détermine si les commentaires XML sont ignorés lorsque les objets XML analysent les données XML source.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreComments, ignoreComments
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Détermine si les commentaires XML sont ignorés lorsque les objets XML analysent les données XML source. Par défaut, les commentaires sont ignorés (<codeph>true</codeph>). Pour inclure les commentaires XML, réglez cette propriété sur <codeph>false</codeph>. La propriété <codeph>ignoreComments</codeph> n’est utilisée que lors de l’analyse XML et non pendant l’appel d’une méthode, telle que <codeph>myXMLObject.child(~~).toXMLString()</codeph>. Si les données XML source contiennent des nœuds de commentaire, ils sont conservés ou éliminés lors de l’analyse XML. 
	
	</apiDesc><example conref="examples\XML.ignoreComments.1.as"> Cet exemple illustre l’effet de la définition de <codeph>XML.ignoreComments</codeph> sur <codeph>false</codeph> et sur <codeph>true</codeph> :
<codeblock>
XML.ignoreComments = false;
var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;!-- comment -->&lt;/foo>

XML.ignoreComments = true;
var xml2:XML = 
        &lt;foo>
            &lt;!-- example -->
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreProcessingInstructions:get"><apiName>ignoreProcessingInstructions</apiName><shortdesc>
	Détermine si les instructions de traitement XML sont ignorées lorsque les objets XML analysent les données XML source.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreProcessingInstructions, ignoreProcessingInstructions
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Détermine si les instructions de traitement XML sont ignorées lorsque les objets XML analysent les données XML source. Par défaut, les instructions de traitement sont ignorées (<codeph>true</codeph>). Pour les inclure, réglez la propriété sur <codeph>false</codeph>. La propriété <codeph>ignoreProcessingInstructions</codeph> n’est utilisée que lors de l’analyse XML et non pendant l’appel de toute méthode telle que <codeph>myXMLObject.child(~~).toXMLString()</codeph>. Si les données XML source contiennent des nœuds d’instructions de traitement, ils sont conservés ou éliminés lors de l’analyse XML.
	
	</apiDesc><example conref="examples\XML.ignoreProcessingInstructions.1.as"> Cet exemple illustre l’effet de la définition de <codeph>XML.ignoreProcessingInstructions</codeph> sur <codeph>false</codeph> et sur <codeph>true</codeph> :
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml1:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;?exampleInstruction ?>&lt;/foo>

XML.ignoreProcessingInstructions = true;
var xml2:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreWhitespace:get"><apiName>ignoreWhitespace</apiName><shortdesc>
	Détermine si les caractères d’espace blanc placés au début et à la fin des nœuds de texte sont ignorés lors de l’analyse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreWhitespace, ignoreWhitespace
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Détermine si les caractères d’espace blanc placés au début et à la fin des nœuds de texte sont ignorés lors de l’analyse. Les espaces blancs sont ignorés par défaut (<codeph>true</codeph>). Si un nœud de texte est entièrement composé d’espaces blancs et que la propriété <codeph>ignoreWhitespace</codeph> est définie sur <codeph>true</codeph>, il n’est pas créé. Pour afficher les espaces blancs dans un nœud de texte, réglez la propriété <codeph>ignoreWhitespace</codeph> sur <codeph>false</codeph>. 
	
	</apiDesc><example conref="examples\XML.ignoreWhitespace.1.as"> Cet exemple illustre l’effet de la définition de <codeph>XML.ignoreWhitespace</codeph> sur <codeph>false</codeph> et sur <codeph>true</codeph> :
<codeblock>
XML.ignoreWhitespace = false;
var xml1:XML = &lt;foo>    &lt;/foo>;
trace(xml1.children().length()); // 1

XML.ignoreWhitespace = true;
var xml2:XML = &lt;foo>    &lt;/foo>;
trace(xml2.children().length()); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="XML:prettyIndent:get"><apiName>prettyIndent</apiName><shortdesc>
	Détermine la taille du retrait appliqué par les méthodes toString() et toXMLString() si la propriété XML.prettyPrinting est définie sur true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyIndent, prettyIndent
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Détermine la taille du retrait appliqué par les méthodes <codeph>toString()</codeph> et <codeph>toXMLString()</codeph> si la propriété <codeph>XML.prettyPrinting</codeph> est définie sur <codeph>true</codeph>. Les retraits sont appliqués à l’aide de caractères d’espace et non de caractères de tabulation. La valeur par défaut est <codeph>2</codeph>.
	
	</apiDesc><example conref="examples\XML.prettyIndent.1.as"> Cet exemple illustre l’effet de la définiton de la propriété statique <codeph>XML.prettyIndent</codeph> :
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyIndent = 0;
trace(xml.toXMLString());

XML.prettyIndent = 1;
trace(xml.toXMLString());

XML.prettyIndent = 2;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:prettyPrinting:get"><apiName>prettyPrinting</apiName><shortdesc>
	Détermine si les méthodes toString() et toXMLString() normalisent les caractères d’espace blanc entre certaines balises.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyPrinting, prettyPrinting
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Détermine si les méthodes <codeph>toString()</codeph> et <codeph>toXMLString()</codeph> normalisent les caractères d’espace blanc entre certaines balises. La valeur par défaut est <codeph>true</codeph>.
	
	</apiDesc><example conref="examples\XML.prettyPrinting.1.as"> Cet exemple illustre l’effet de la définiton de la propriété statique <codeph>XML.prettyPrinting</codeph> :
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyPrinting = false;
trace(xml.toXMLString());

XML.prettyPrinting = true;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:Array"><apiName>Array</apiName><shortdesc>
	 Crée un tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Tableau de longueur zéro ou supérieure.
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Vous pouvez ne transmettre aucun argument pour produire un tableau vide, un seul argument entier pour produire un tableau de longueur spécifique ou une série de valeurs de types divers séparées par une virgule pour produire un tableau contenant ces valeurs.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Crée un tableau. Le tableau peut être de longueur zéro ou supérieure, ou contenir une liste d’éléments spécifiés, éventuellement de types de données différents. Le nombre et le type de données des arguments utilisés déterminent le contenu du tableau renvoyé.
	 <ul>
	   <li>Appeler <codeph>Array()</codeph> sans argument renvoie un tableau vide.</li>
	   <li>Appeler <codeph>Array()</codeph> avec un seul argument entier renvoie un tableau de la longueur spécifiée, mais dont les éléments possèdent une valeur non définie.</li>
	   <li>Appeler <codeph>Array()</codeph> avec une liste de valeurs spécifiques renvoie un tableau composé d’éléments contenant chacun des valeurs spécifiées.</li>
	 </ul>
	 L’utilisation de la fonction <codeph>Array()</codeph> revient à créer un tableau avec le constructeur de classe Array.
	 <p>Utilisez l’opérateur <codeph>as</codeph> pour effectuer une conversion de type explicite, ou attribution de type, si l’argument n’est pas une valeur primitive. Pour plus d’informations, voir la section Exemple de cette entrée. </p>
	 </apiDesc><example conref="examples\Array.func.4.as"> L’exemple suivant démontre le comportement de la fonction <codeph>Array()</codeph> lorsqu’un argument n’est pas une valeur primitive. L’une des principales situations de conversion en tableau est la conversion d’une occurrence d’objet qui stocke ses valeurs sous forme de tableau. Si <codeph>Array()</codeph> est appelé avec un argument de type <codeph>Object</codeph> ou tout autre type de données non primitif, une référence à l’objet est stocké dans un élément du nouveau tableau. En d’autres termes, si le seul argument transmis est un objet, une référence à cet objet devient le premier élément du nouveau tableau.
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = Array( obj );

trace(newArray == obj);    // false
trace(newArray[0] == obj); // true
trace(newArray[0][0])      // a
trace(newArray[0][1])      // b
trace(newArray[0][2])      // c
</codeblock></example><example conref="examples\Array.func.5.as"> Pour convertir <codeph>obj</codeph> en tableau, utilisez l’opérateur <codeph>as</codeph>, qui renvoie une référence de tableau si <codeph>obj</codeph> est un tableau valide et <codeph>null</codeph> dans tous les autres cas :
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = obj as Array;

trace(newArray == obj); // true
trace(newArray[0]);     // a
trace(newArray[1]);     // b
trace(newArray[2]);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array"><linktext>Classe Array</linktext></link><link href="operators.html#as"><linktext>Opérateur as</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:Boolean"><apiName>Boolean</apiName><shortdesc>
	 Convertit le paramètre expression en une valeur booléenne et renvoie une valeur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Résultat de la conversion au type Boolean.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Expression ou objet à convertir au type Boolean.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit le paramètre <codeph>expression</codeph> en une valeur booléenne et renvoie une valeur. 
	 <p>La valeur renvoyée varie selon le type de données et la valeur de l’argument, comme décrit dans le tableau suivant :</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Valeur entrée</entry><entry>Exemple</entry><entry>Valeur renvoyée</entry></row></thead><tbody><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>Boolean(0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Boolean(NaN)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Nombre (ni <codeph>0</codeph>, ni <codeph>NaN</codeph>)</entry>
	     <entry><codeph>Boolean(4)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Chaîne vide</entry>
	     <entry><codeph>Boolean("")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Chaîne non vide</entry>
	     <entry><codeph>Boolean("6")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>Boolean(null)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>non défini</codeph></entry>
	     <entry><codeph>Boolean(undefined)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Occurrence de classe Object</entry>
	     <entry><codeph>Boolean(new Object())</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Aucun argument</entry>
	     <entry><codeph>Boolean()</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 <p>A l’encontre des versions antérieures d’ActionScript, la fonction <codeph>Boolean()</codeph> renvoie les mêmes résultats que le constructeur de classe Boolean.</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Number"><apiName>Number</apiName><shortdesc>
	 Convertit une valeur spécifique en valeur numérique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur numérique convertie
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Valeur à convertir en nombre.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit une valeur spécifique en valeur numérique. Le tableau suivant affiche le résultat de divers types d’entrées :
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Type/valeur d’entrée</entry><entry>Exemple</entry><entry>Valeur renvoyée</entry></row></thead><tbody><row>
	     <entry><codeph>non défini</codeph></entry>
	     <entry><codeph>Number(undefined)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>Number(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>Number(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>Number(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Number(NaN)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry>Chaîne vide</entry>
	     <entry><codeph>Number("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Chaîne qui peut être convertie en nombre</entry>
	     <entry><codeph>Number("5")</codeph></entry>
	     <entry>Nombre (exemple : <codeph>5</codeph>)</entry>
	   </row><row>
	     <entry>Chaîne qui ne peut pas être convertie en nombre</entry>
	     <entry><codeph>Number("5a")</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Object"><apiName>Object</apiName><shortdesc>
	 Dans ActionScript 3.0, chaque valeur est un objet, ce qui signifie qu’appeler Object() pour une valeur renvoie celle-ci.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur spécifiée par le paramètre <codeph>value</codeph>.
     </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet ou nombre, chaîne ou valeur booléenne à convertir.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Dans ActionScript 3.0, chaque valeur est un objet, ce qui signifie qu’appeler <codeph>Object()</codeph> pour une valeur renvoie celle-ci.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:String"><apiName>String</apiName><shortdesc>
	 Renvoie une chaîne représentant le paramètre spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne représentant la valeur transmise pour le paramètre <codeph>expression</codeph>.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc> Expression à convertir en chaîne.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une chaîne représentant le paramètre spécifié.
	 <p>Le tableau suivant affiche le résultat de divers types d’entrées :</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Type/valeur d’entrée</entry><entry>Valeur renvoyée</entry></row></thead><tbody><row>
	     <entry><codeph>non défini</codeph></entry>
	     <entry><codeph>non défini</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>"null"</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>"true"</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>"false"</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>"NaN"</codeph></entry>
	   </row><row>
	     <entry>String</entry>
	     <entry>String</entry>
	   </row><row>
	     <entry>Object</entry>
	     <entry>Object.toString()</entry>
	   </row><row>
	     <entry>Number</entry>
	     <entry>Chaîne représentant le nombre</entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Vector"><apiName>Vector</apiName><shortdesc>
	 Crée une nouvelle occurrence de Vector dont les éléments sont des occurrences du type de données spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><commentPrivate>The reason this compiles with the .&lt;T> designation is because
	 a dummy class "T" is declared in the top level Vector.as file. If this file is
	 built without that one, the build will fail.
	 
	 </commentPrivate></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si l’argument <codeph>sourceArray</codeph> contient un élément qui ne pas être converti au type de données spécifié.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Une occurrence de Vector remplie avec les éléments du tableau <codeph>sourceArray</codeph>.
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>sourceArray</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Une occurrence de Array ou de Vector dont les éléments deviennent des éléments du vecteur résultant. Si l’argument est une occurrence de Vector dont le type de données associé est identique au type de données spécifié, l’argument est renvoyé comme résultat de la fonction.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Crée une nouvelle occurrence de Vector dont les éléments sont des occurrences du type de données spécifié. Lorsque vous appelez cette fonction, vous spécifiez le type de données des éléments du vecteur résultant (le <i>type de base</i> du vecteur) à l’aide d’un paramètre type. Cette fonction utilise la même syntaxe utilisée lors de la déclaration d’une occurrence de Vector ou de l’appel du constructeur <codeph>new Vector.&lt;T>()</codeph> :
	 
	 <codeblock>var v:Vector.&lt;String> = Vector.&lt;String>(["Hello", "World"]);</codeblock>
	 
	 <p>Le vecteur résultant est renseigné avec les valeurs contenues dans les éléments de l’argument <codeph>sourceArray</codeph>. Si l’argument <codeph>sourceArray</codeph> est déjà une occurrence de Vector.&lt;T>, où <codeph>T</codeph> représente le type de base, la fonction renvoie ce vecteur. Sinon, le vecteur résultant est renseigné avec les éléments du vecteur ou du tableau <codeph>sourceArray</codeph>.</p>
	 
	 <p>Quoi qu’il en soit, le type de données de tous les éléments de l’argument <codeph>sourceArray</codeph> doit correspondre au type de base <codeph>T</codeph> spécifié dans l’appel de fonction.</p>
	 
	 <p>Si la valeur <codeph>length</codeph> de la propriété <codeph>sourceArray</codeph> est de 0, la fonction renvoie un vecteur vide.</p>
	 
	 <p>Si un vecteur est transmis en tant qu’argument <codeph>sourceArray</codeph> et que son type de base n’est pas <codeph>T</codeph>, ou si un tableau est transmis et que ses éléments ne sont pas des occurrences du type de base <codeph>T</codeph>, une tentative de conversion des valeurs au type de base est effectuée. Si les valeurs peuvent être automatiquement converties, le vecteur obtenu contient les valeurs converties. Si aucune conversion n’est possible, une erreur se produit.</p>
	 
	 <p>De même, si un élément de l’argument <codeph>sourceArray</codeph> est une occurrence de la sous-classe du type de base<codeph>T</codeph>, l’appel aboutit et l’élément est ajouté au vecteur résultant. Ceci est valable même si l’argument <codeph>sourceArray</codeph> est un vecteur dont le type de base est une sous-classe de <codeph>T</codeph>. C’est en fait le seul moyen de convertir un vecteur avec un type de base <codeph>T</codeph> en un vecteur avec un type de base étant une super-classe de <codeph>T</codeph>.</p>
	 
	 <p>Par exemple, le code suivant génère une erreur de compilation en mode strict, ou une erreur TypeError à l’exécution, car il tente d’affecter un Vector.&lt;Sprite> à une variable Vector.&lt;DisplayObject> (Sprite est une sous-classe de DisplayObject) :</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = v1;
	 </codeblock>
	 
	 <p>La version alternative du code suivante copie avec succès les éléments d’une occurrence de Vector.&lt;Sprite> sur une occurrence de Vector.&lt;DisplayObject> :</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = Vector.&lt;DisplayObject>(v1);
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Vector"><linktext>Classe Vector</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XMLList"><apiName>XMLList</apiName><shortdesc>
     Convertit un objet en objet XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet XMLList contenant des valeurs enregistrées dans l’objet converti.
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet à convertir en objet XMLList.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Convertit un objet en objet XMLList.
     <p>Le tableau suivant décrit les valeurs renvoyées pour divers types d’entrées.</p>
	 <adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>Type de paramètre</entry><entry>Valeur renvoyée</entry></row></thead><tbody><row>
	 		<entry>Boolean</entry>
	 		<entry>La valeur est d’abord convertie en chaîne, puis en objet XMLList.</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>Il se produit une erreur d’exécution (exception TypeError).</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>La valeur est d’abord convertie en chaîne, puis en objet XMLList.</entry>
	 	</row><row>
	 		<entry>Object</entry>
	 		<entry>Converti au format XMLList sous réserve que la valeur soit de type String, Number ou Boolean. Dans tous les autres cas, il se produit une erreur d’exécution (exception TypeError).</entry>
	 	</row><row>
	 		<entry>String</entry>
	 		<entry>La valeur est convertie en objet XMLList.</entry>
	 	</row><row>
	 		<entry>Undefined</entry>
	 		<entry>Il se produit une erreur d’exécution (exception TypeError).</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>La valeur est convertie en objet XMLList.</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>La valeur entrée est renvoyée sans modification.</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XML()"><linktext>XML()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XML"><apiName>XML</apiName><shortdesc>
	 Convertit un objet en objet XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet XML contenant des valeurs enregistrées dans l’objet converti.
	 </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet à convertir au format XML.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit un objet en objet XML. 
	 <p>Le tableau suivant décrit les valeurs renvoyées pour divers types d’entrées.</p>
	 	<adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>Type de paramètre</entry><entry>Valeur renvoyée</entry></row></thead><tbody><row>
	 		<entry>Boolean</entry>
	 		<entry>La valeur est d’abord convertie en chaîne, puis en objet XML.</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>Il se produit une erreur d’exécution (exception TypeError).</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>La valeur est d’abord convertie en chaîne, puis en objet XML.</entry>
	 	</row><row>
	 		<entry>Object</entry>
	 		<entry>Converti au format XML sous réserve que la valeur soit de type String, Number ou Boolean. Dans tous les autres cas, il se produit une erreur d’exécution (exception TypeError).</entry>
	 	</row><row>
	 		<entry>String</entry>
	 		<entry>La valeur est convertie au format XML.</entry>
	 	</row><row>
	 		<entry>Undefined</entry>
	 		<entry>Il se produit une erreur d’exécution (exception TypeError).</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>La valeur entrée est renvoyée sans modification.</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>Ne renvoie un objet XML que si l’objet XMLList ne contient qu’une seule propriété de type XML. Dans tous les autres cas, il se produit une erreur d’exécution (exception TypeError).</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XMLList()"><linktext>XMLList()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURIComponent"><apiName>decodeURIComponent</apiName><shortdesc>
	 Décode un composant URI codé pour produire une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne dans laquelle tous les caractères précédemment convertis en séquence d’échappement par la fonction <codeph>encodeURIComponent</codeph> retrouvent leur forme sans séquence d’échappement.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne codée à l’aide de la fonction <codeph>encodeURIComponent</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Décode un composant URI codé pour produire une chaîne. Renvoie une chaîne dont tous les caractères précédemment convertis en séquence d’échappement par la fonction <codeph>encodeURIComponent</codeph> retrouvent leur forme non codée.
	 <p>Cette fonction est différente de la fonction <codeph>decodeURI()</codeph> en ce sens qu’elle est conçue pour être utilisée uniquement avec une partie de chaîne URI appelée composant URI. Un composant URI correspond à tout texte compris entre des caractères spéciaux nommés <i>séparateurs de composants</i> (<codeph> : / ; et ? </codeph>). « http » et « www.adobe.com » sont des exemples courants de composant URI.</p>
	 <p>Il existe une autre différence majeure entre cette fonction et <codeph>decodeURI()</codeph> : parce la fonction part du principe qu’elle manipule un composant URI, elle traite les séquences d’échappement qui représentent des caractères de séparation spéciaux (<codeph> ; / ? : @ &amp; = + $ , #</codeph>) en tant que texte ordinaire qui doit être décodé. </p>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURI"><apiName>decodeURI</apiName><shortdesc>
	 Décode une URI codée pour produire une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne dans laquelle tous les caractères précédemment convertis en séquence d’échappement par la fonction <codeph>encodeURI</codeph> retrouvent leur forme sans séquence d’échappement.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne codée à l’aide de la fonction <codeph>encodeURI</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Décode une URI codée pour produire une chaîne. Renvoie une chaîne dans laquelle tous les caractères précédemment codés par la fonction <codeph>encodeURI</codeph> retrouvent leur forme non codée.
	 <p>Le tableau suivant contient l’ensemble de séquences d’échappement qui ne sont <i>pas</i> décodées par la fonction <codeph>decodeURI</codeph> pour obtenir des caractères. Utilisez <codeph>decodeURIComponent()</codeph> pour décoder les séquences d’échappement répertoriées dans ce tableau.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Séquences d’échappement non décodées</entry><entry>Caractères équivalents</entry></row></thead><tbody><row>
	     <entry><codeph>%23</codeph></entry>
	     <entry><codeph>#</codeph></entry>
	   </row><row>
	     <entry><codeph>%24</codeph></entry>
	     <entry><codeph>$</codeph></entry>
	   </row><row>
	     <entry><codeph>%26</codeph></entry>
	     <entry><codeph>&amp;</codeph></entry>
	   </row><row>
	     <entry><codeph>%2B</codeph></entry>
	     <entry><codeph>+</codeph></entry>
	   </row><row>
	     <entry><codeph>%2C</codeph></entry>
	     <entry><codeph>,</codeph></entry>
	   </row><row>
	     <entry><codeph>%2F</codeph></entry>
	     <entry><codeph>/</codeph></entry>
	   </row><row>
	     <entry><codeph>%3A</codeph></entry>
	     <entry><codeph>:</codeph></entry>
	   </row><row>
	     <entry><codeph>%3B</codeph></entry>
	     <entry><codeph>;</codeph></entry>
	   </row><row>
	     <entry><codeph>%3D</codeph></entry>
	     <entry><codeph>=</codeph></entry>
	   </row><row>
	     <entry><codeph>%3F</codeph></entry>
	     <entry><codeph>?</codeph></entry>
	   </row><row>
	     <entry><codeph>%40</codeph></entry>
	     <entry><codeph>@</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example conref="examples\DecodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class DecodeURIExample extends Sprite {
        public function DecodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURIComponent"><apiName>encodeURIComponent</apiName><shortdesc>
	 Convertit une chaîne en composant URI valide.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 Convertit une chaîne en composant URI valide. Convertit une sous-chaîne d’URI en chaîne dont tous les caractères sont convertis en séquences d’échappement UTF-8, à moins qu’un caractère n’appartienne à un groupe très réduit de caractères de base.
	 <p>La fonction <codeph>encodeURIComponent()</codeph> est différente de la fonction <codeph>encodeURI()</codeph> en ce sens qu’elle est conçue pour être utilisée uniquement avec une partie de chaîne URI appelée composant URI. Un composant URI correspond à tout texte compris entre des caractères spéciaux nommés <i>séparateurs de composants</i> (<codeph> : / ; et ? </codeph>). « http » et « www.adobe.com » sont des exemples courants de composant URI.</p>
	 <p>Il existe une autre différence majeure entre cette fonction et <codeph>encodeURI()</codeph> : dans la mesure où la fonction manipule un composant URI, elle traite les caractères de séparation spéciaux (<codeph> ; / ? : @ &amp; = + $ , #</codeph>) en tant que texte ordinaire qui doit être codé. </p>
	 <p>Le tableau suivant répertorie tous les caractères qui ne sont <i>pas</i> convertis en séquences d’échappement UTF-8 par la fonction <codeph>encodeURIComponent</codeph>.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Caractères non codés</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>- _. ! ~ ~~ ’ ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURI"><apiName>encodeURI</apiName><shortdesc>
	 Convertit une chaîne en URI (Uniform Resource Identifier) valide.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne dont certains caractères sont convertis en séquences d’échappement UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne représentant une URI complète.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit une chaîne en URI (Uniform Resource Identifier) valide. Convertit une URI complète en chaîne dont tous les caractères sont codés en tant que séquences d’échappement UTF-8, à moins qu’un caractère n’appartienne à un petit groupe de caractères de base.
	 <p>Le tableau suivant répertorie l’ensemble complet des caractères de base qui ne sont <i>pas</i> convertis en séquences d’échappement UTF-8 par la fonction <codeph>encodeURI</codeph>.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Caractères non codés</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>; / ? : @ &amp; = + $ , #</codeph></entry>
	   </row><row>
	     <entry><codeph>- _. ! ~ ~~ ’ ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc><example conref="examples\EncodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class EncodeURIExample extends Sprite {
        public function EncodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:escape"><apiName>escape</apiName><shortdesc>
	 Convertit le paramètre en chaîne et applique le format de code URL, où la plupart des caractères qui ne sont pas de type alphanumérique sont remplacés par des séquences hexadécimales (%).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Une chaîne convertie en format d’URL.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Expression à convertir en chaîne et coder au format URL.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit le paramètre en chaîne et applique le format de code URL, où la plupart des caractères qui ne sont pas de type alphanumérique sont remplacés par des séquences hexadécimales <codeph>%</codeph>. Lorsque cette fonction est utilisée dans une chaîne codée au format URL, le symbole pour cent (<codeph>%</codeph>) introduit les caractères d’échappement et ne doit pas être confondu avec l’opérateur modulo (<codeph>%</codeph>).
	 <p>Le tableau suivant répertorie tous les caractères qui ne sont <i>pas</i> convertis en séquences d’échappement par la fonction <codeph>escape()</codeph>.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Caractères non codés</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>@ - _. ~~ + /</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/unescape()"><linktext>unescape()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:int"><apiName>int</apiName><shortdesc>
	 Convertit une valeur numérique spécifiée en entier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Entier converti.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur à convertir en entier.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit une valeur numérique spécifiée en entier. Les valeurs décimales sont tronquées au niveau de la virgule.
	 </apiDesc></apiOperationDetail><related-links><link href="#global/uint()"><linktext>uint()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:isFinite"><apiName>isFinite</apiName><shortdesc>
	 Renvoie true si la valeur est un nombre fini, false si la valeur est Infinity ou -Infinity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0."/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> s’il s’agit d’un nombre fini, <codeph>false</codeph> s’il s’agit de l’infini ou de l’infini négatif
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à évaluer en tant que valeur finie ou infinie.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie <codeph>true</codeph> si la valeur est un nombre fini, <codeph>false</codeph> si la valeur est <codeph>Infinity</codeph> ou <codeph>-Infinity</codeph>. La présence de <codeph>Infinity</codeph> ou <codeph>-Infinity</codeph> indique une erreur mathématique, telle que la division par 0.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isNaN"><apiName>isNaN</apiName><shortdesc>
	 Renvoie true si la valeur est NaN (not a number : n’est pas un nombre).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si la valeur est <codeph>NaN</codeph> (not a number : n’est pas un nombre), <codeph>false</codeph> dans tous les autres cas.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur numérique ou expression mathématique à évaluer.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie <codeph>true</codeph> si la valeur est <codeph>NaN</codeph> (not a number : n’est pas un nombre). La fonction <codeph>isNaN()</codeph> permet de s’assurer qu’une expression mathématique a été évaluée correctement en tant que nombre. La fonction <codeph>isNaN()</codeph> est principalement utilisée pour vérifier la valeur renvoyée par les fonctions <codeph>parseInt()</codeph> et <codeph>parseFloat()</codeph>. La valeur <codeph>NaN</codeph> est un membre spécial du type de données Number et représente une valeur qui « n’est pas un nombre ». 
	 <p><b>Remarque </b>: La valeur <codeph>NaN</codeph> ne fait pas partie des types de données int ou uint.</p>
	 <p>Le tableau ci-dessous décrit la valeur renvoyée par <codeph>isNaN()</codeph> pour divers types et valeurs d’entrées (si les avertissements de votre compilateur sont réglés sur le mode strict, certaines des opérations suivantes pourront générer des erreurs de compilation).</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Type/valeur d’entrée</entry><entry>Exemple</entry><entry>Valeur renvoyée</entry></row></thead><tbody><row>
	     <entry>0 divisé par 0</entry>
	     <entry><codeph>isNaN(0/0)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Nombre autre que zéro divisé par <codeph>0</codeph></entry>
	     <entry><codeph>isNaN(5/0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Racine carrée d’un nombre négatif</entry>
	     <entry><codeph>isNaN(Math.sqrt(-1))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Arc sinus d’un nombre supérieur à 1 ou inférieur à 0</entry>
	     <entry><codeph>isNaN(Math.asin(2))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Chaîne qui peut être convertie en nombre</entry>
	     <entry><codeph>isNaN("5")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Chaîne qui ne peut pas être convertie en nombre</entry>
	     <entry><codeph>isNaN("5a")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isXMLName"><apiName>isXMLName</apiName><shortdesc>
	 Détermine si la chaîne spécifiée est un nom valide d’attribut ou d’élément XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’argument <codeph>str</codeph> est un nom XML valide, <codeph>false</codeph> dans le cas contraire.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à évaluer.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Détermine si la chaîne spécifiée est un nom valide d’attribut ou d’élément XML.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseFloat"><apiName>parseFloat</apiName><shortdesc>
	 Convertit une chaîne en nombre à virgule flottante.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nombre ou <codeph>NaN</codeph> (n’est pas un nombre).
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à lire et convertir en nombre à virgule flottante.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit une chaîne en nombre à virgule flottante. Cette fonction lit, ou <i>analyse</i>, et renvoie les nombres dans une chaîne jusqu’à ce que cette dernière atteigne un caractère qui ne fait pas partie du nombre initial. Si la chaîne ne commence pas par un nombre qui peut être analysé, <codeph>parseFloat()</codeph> renvoie <codeph>NaN</codeph>. L’espace blanc qui précède un entier valide est ignoré, comme les caractères de fin non numériques.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseInt"><apiName>parseInt</apiName><shortdesc>
	 Convertit une chaîne en entier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nombre ou <codeph>NaN</codeph> (n’est pas un nombre).
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à convertir en entier.
	 </apiDesc></apiParam><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier représentant la base du nombre à analyser. Les valeurs valides sont comprises entre 2 et 36.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit une chaîne en entier. Si la chaîne spécifiée par les paramètres ne peut pas être convertie en nombre, la fonction renvoie <codeph>NaN</codeph>. Les chaînes commençant par 0x sont interprétées en tant que nombres hexadécimaux. A l’encontre des versions antérieures d’ActionScript, les entiers débutant par 0 ne sont <i>not</i> interprétés comme des nombres octaux. Vous devez spécifier la base 8 pour les nombres octaux. L’espace blanc et les zéros qui précèdent un entier valide sont ignorés, tout comme les caractères de fin non numériques.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:trace"><apiName>trace</apiName><shortdesc>
	 Affiche des expressions ou effectue une consignation dans les fichiers journaux pendant le débogage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs expressions (séparées par une virgule) à évaluer. S’il existe plusieurs expressions, un espace est inséré entre chacune d’elles dans la sortie.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Affiche des expressions ou effectue une consignation dans les fichiers journaux pendant le débogage. Une instruction trace unique peut prendre en charge plusieurs arguments. Si un argument d’instruction trace comprend un type de données autre que String, la fonction trace appelle la méthode <codeph>toString()</codeph> associée correspondante. Si par exemple l’argument est une valeur booléenne, la fonction trace appelle <codeph>Boolean.toString()</codeph> et affiche la valeur renvoyée. 
	 </apiDesc><example conref="examples\TraceExample.as"> L’exemple suivant utilise la classe <codeph>TraceExample</codeph> pour indiquer comment la méthode <codeph>trace()</codeph> peut être utilisée pour imprimer une chaîne simple. De manière générale, le message est imprimé sur une console de « débogage ».
<codeblock>
package {
    import flash.display.Sprite;

    public class TraceExample extends Sprite {

        public function TraceExample() {
            trace("Hello World");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="globalOperation:uint"><apiName>uint</apiName><shortdesc>
	 Convertit une valeur numérique spécifiée en entier non signé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Entier converti.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur à convertir en entier.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit une valeur numérique spécifiée en entier non signé. Les valeurs décimales sont tronquées au niveau de la virgule.
	 <p>Le tableau ci-dessous décrit la valeur renvoyée par <codeph>uint()</codeph> pour divers types et valeurs d’entrées.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Type/valeur d’entrée</entry><entry>Exemple</entry><entry>Valeur renvoyée</entry></row></thead><tbody><row>
	     <entry><codeph>non défini</codeph></entry>
	     <entry><codeph>uint(undefined)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>uint(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>uint(0)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>uint(NaN)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Nombre positif à virgule flottante</entry>
	     <entry><codeph>uint(5,31)</codeph></entry>
	     <entry>Entier tronqué non signé (<codeph>5</codeph>, par exemple)</entry>
	   </row><row>
	     <entry>Nombre négatif à virgule flottante</entry>
	     <entry><codeph>uint(-5,78)</codeph></entry>
	     <entry>Tronque le nombre décimal au niveau de la virgule pour obtenir un entier, puis lui applique une règle relative aux entiers négatifs</entry>
	   </row><row>
	     <entry>Entier négatif</entry>
	     <entry><codeph>uint(-5)</codeph></entry>
         <entry>Somme de <codeph>uint.MAX_VALUE</codeph> et de l’entier négatif (<codeph>uint.MAX_VALUE + (-5)</codeph>, par exemple)</entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>uint(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>uint(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Chaîne vide</entry>
	     <entry><codeph>uint("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Chaîne qui peut être convertie en nombre</entry>
	     <entry><codeph>uint("5")</codeph></entry>
	     <entry>Le nombre</entry>
	   </row><row>
	     <entry>Chaîne qui ne peut pas être convertie en nombre</entry>
	     <entry><codeph>uint("5a")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row></tbody></tgroup></adobetable>

	 </apiDesc></apiOperationDetail><related-links><link href="#global/int()"><linktext>int()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:unescape"><apiName>unescape</apiName><shortdesc>
	 Evalue le paramètre str en tant que chaîne, décode la chaîne qui est au format codé en URL (en convertissant toutes les séquences hexadécimales en caractères ASCII) et renvoie cette chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne décodée à partir d’un paramètre codé au format URL.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne comportant des séquences hexadécimales à convertir en séquences d’échappement.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Evalue le paramètre <codeph>str</codeph> en tant que chaîne, décode la chaîne qui est au format codé en URL (en convertissant toutes les séquences hexadécimales en caractères ASCII) et renvoie cette chaîne.
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="globalValue:Infinity"><apiName>Infinity</apiName><shortdesc>
 Valeur spéciale représentant une valeur Infinity positive.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Valeur spéciale représentant une valeur <codeph>Infinity</codeph> positive. La valeur de cette constante est identique à <codeph>Number.POSITIVE_INFINITY</codeph>.
 </apiDesc><example conref="examples\Constants.Infinity.1.as"> La division par 0 renvoie <codeph>Infinity</codeph>, mais seul le diviseur est un nombre positif.
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/POSITIVE_INFINITY"><linktext>Number.POSITIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:-Infinity"><apiName>-Infinity</apiName><shortdesc>
 Valeur spéciale représentant une valeur Infinity négative.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Valeur spéciale représentant une valeur <codeph>Infinity</codeph> négative. La valeur de cette constante est identique à <codeph>Number.NEGATIVE_INFINITY</codeph>.
 </apiDesc><example conref="examples\Constants.NegInfinity.1.as"> La division par 0 renvoie <codeph>-Infinity</codeph>, mais seul le diviseur est un nombre négatif.
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/NEGATIVE_INFINITY"><linktext>Number.NEGATIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:NaN"><apiName>NaN</apiName><shortdesc>
 Membre spécial du type de données Number qui représente une valeur qui « n’est pas un nombre » (NaN).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Membre spécial du type de données Number qui représente une valeur qui « n’est pas un nombre » (<codeph>NaN</codeph>). Lorsqu’une expression mathématique produit une valeur qui ne peut pas être exprimée sous forme de nombre, le résultat correspond à <codeph>NaN</codeph>. La liste suivante décrit des expressions courantes qui produisent <codeph>NaN</codeph>.
 <ul>
   <li>La division par 0 ne renvoie <codeph>NaN</codeph> que si le diviseur est également 0. Si le diviseur est supérieur à 0, la division par 0 produit <codeph><codeph>Infinity</codeph></codeph>. Si le diviseur est inférieur à 0, la division par 0 produit <codeph><codeph>-Infinity</codeph></codeph>.</li>
   <li>Racine carrée d’un nombre négatif.</li>
   <li>Arc sinus d’un nombre non compris entre 0 et 1 (la plage valide).</li>
   <li><codeph>Infinity</codeph> soustrait de <codeph>Infinity</codeph>.</li>
   <li><codeph>Infinity</codeph> ou <codeph>-Infinity</codeph> divisé par <codeph>Infinity</codeph> or <codeph>-Infinity</codeph>.</li>
   <li><codeph>Infinity</codeph> ou <codeph>-Infinity</codeph> multiplié par 0.</li>
  </ul>
 <p>La valeur <codeph>NaN</codeph> ne fait pas partie des types de données int ou uint.</p>
 <p>La valeur <codeph>NaN</codeph> n’étant pas considérée comme égale à toute autre valeur, <codeph>NaN</codeph> inclus, l’utilisation de l’opérateur d’égalité pour vérifier si une expression correspond à <codeph>NaN</codeph> est impossible. Pour déterminer si un nombre correspond à la fonction <codeph>NaN</codeph>, utilisez <codeph>isNaN()</codeph>.</p>
 
 </apiDesc></apiValueDetail><related-links><link href="#global/isNaN()"><linktext>isNaN()</linktext></link><link href="#Number/NaN"><linktext>Number.NaN</linktext></link></related-links></apiValue><apiValue id="globalValue:undefined"><apiName>undefined</apiName><shortdesc>
 Valeur spéciale appliquée aux variables sans type qui n’ont pas été initialisées ou aux propriétés d’objets dynamiques qui ne sont pas initialisées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
 Valeur spéciale appliquée aux variables sans type qui n’ont pas été initialisées ou aux propriétés d’objets dynamiques qui ne sont pas initialisées. Dans ActionScript 3.0, seules les variables qui n’ont pas de type peuvent recevoir la valeur <codeph>undefined</codeph>, contrairement à ActionScript 1.0 et ActionScript 2.0. Par exemple, les deux variables sont <codeph>undefined</codeph> dans la mesure où elles ne sont pas typées et pas initialisées :
 <ul>
   <li><codeph>var foo;</codeph></li>
   <li><codeph>var bar:~~;</codeph></li>
 </ul>
 <p>La valeur <codeph>undefined</codeph> s’applique également aux propriétés non initialisées ou non définies d’objets dynamiques. Par exemple, si un objet est une occurrence de la classe Object, la valeur de toute propriété ajoutée dynamiquement est définie sur <codeph>undefined</codeph> jusqu’à ce qu’une valeur lui soit affectée.
 </p>
 <p>Les résultats varient lorsque <codeph>undefined</codeph> est utilisé avec diverses fonctions :</p>
 <ul>
 <li><codeph>String(undefined)</codeph> renvoie la valeur <codeph>"undefined"</codeph> (<codeph>undefined</codeph> est converti en chaîne).</li> 
 <li><codeph>Number(undefined)</codeph> renvoie la valeur <codeph>NaN</codeph>.</li> 
 <li><codeph>int(undefined)</codeph> et <codeph>uint(undefined)</codeph> renvoient la valeur 0.</li>
 <li><codeph>Object(undefined)</codeph> renvoie une nouvelle occurrence d’Object.</li>
 <li>Si vous affectez la valeur <codeph>undefined</codeph> à une variable associée à un type, elle est convertie en la valeur par défaut du type de données.</li>
 </ul>
 <p>Veillez à ne pas confondre <codeph>undefined</codeph> et <codeph>null</codeph>. Lorsque les propriétés <codeph>null</codeph> et <codeph>undefined</codeph> sont comparées avec l’opérateur d’égalité (<codeph>==</codeph>), elles sont considérées comme égales. Lorsque les propriétés <codeph>null</codeph> et <codeph>undefined</codeph> sont comparées avec l’opérateur d’égalité stricte (<codeph>===</codeph>), elles sont considérées comme différentes.</p>
 </apiDesc><example conref="examples\Constants.undefined.1.as"> Dans l’exemple suivant, une variable non typée, <codeph>myVar</codeph> est déclarée mais pas initialisée. La valeur de <codeph>myVar</codeph> est <codeph>undefined</codeph> dans la mesure où la variable n’est pas typée. Ceci est vrai lorsque la variable ne comporte pas d’annotation de type ou utilise l’annotation non typée spéciale (~~) (<codeph>var myVar:~~;</codeph>).
<codeblock>

// trace value of untyped and uninitialized variable
var myVar;
trace(myVar); // undefined
</codeblock></example><example conref="examples\Constants.undefined.2.as"> La même règle s’applique aux propriétés non initialisées d’un objet dynamique. Par exemple, avec une occurrence donnée, <codeph>obj</codeph>, de la classe dynamique <codeph>A</codeph>, la valeur de <codeph>obj.propName</codeph>, qui est une propriété non initialisée de l’occurrence <codeph>obj</codeph>, est <codeph>undefined</codeph>.
<codeblock>

dynamic class A {}
var obj:A = new A()

// trace undefined property of obj
trace(obj.propName); // undefined

</codeblock></example></apiValueDetail><related-links><link href="statements.html#null"><linktext>null</linktext></link></related-links></apiValue><apiClassifier id="globalClassifier:uint"><apiName>uint</apiName><shortdesc>
 La classe uint propose des méthodes d’utilisation d’un type de données représentant un entier 32 bits non signé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint object, uint, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe uint propose des méthodes d’utilisation d’un type de données représentant un entier 32 bits non signé. Un entier non signé étant nécessairement positif, sa valeur maximale est le double de celle de la classe int.
 <p>La plage de valeurs représentée par la classe uint est comprise entre 0 et 4 294 967 295 (2^32-1).</p>
 <p>Pour créer un objet uint, déclarez une variable de type uint et affectez-lui une valeur littérale. La valeur par défaut d’une variable de type uint correspond à <codeph>0</codeph>.</p>
 <p>La classe uint est surtout utilisée pour les valeurs de couleur de pixel (ARVB et RVBA), ainsi que les cas où le type de données int ne fonctionne pas correctement. Par exemple, le nombre 0xFFFFFFFF, qui représente la valeur de la couleur blanche avec une valeur alpha 255, ne peut pas être représenté à l’aide du type de données int, car elle excède la plage de valeurs int valides.</p> 
 
 <p>L’exemple suivant crée un objet uint et appelle la méthode <codeph> toString()</codeph> :</p>
 <pre>
 var myuint:uint = 1234;
 trace(myuint.toString()); // 1234
 </pre>
 <p>L’exemple suivant affecte la valeur de la propriété <codeph>MIN_VALUE</codeph> à une variable sans l’utilisation du constructeur :</p>
 <pre>
 var smallest:uint = uint.MIN_VALUE;
 trace(smallest.toString()); // 0
 </pre> 
 
 </apiDesc><example conref="examples\UintExample.as"> L’exemple suivant déclare un paramètre uint <codeph>i</codeph> au sein d’une boucle <codeph>for</codeph>, qui imprime les nombres 0 à 9 (dans la mesure où uint applique par défaut la valeur 0).
<codeblock>

package {
    import flash.display.Sprite;

    public class UintExample extends Sprite {
        public function UintExample() {
            for(var i:uint; i &lt; 10; i++) {
                trace(i);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="uint:uint"><apiName>uint</apiName><shortdesc>
	 Crée un objet uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Valeur numérique de l’objet uint en cours de création, ou valeur à convertir en nombre. Si <codeph>num</codeph> n’est pas fourni, la valeur par défaut est <codeph>0</codeph>.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet uint. Vous pouvez créer une variable de type uint et lui affecter une valeur littérale. Le constructeur <codeph>new uint()</codeph> sert surtout d’espace réservé. Ne confondez pas l’objet uint avec la fonction <codeph> uint()</codeph>, qui convertit un paramètre en valeur primitive.
	 
	 </apiDesc><example>Le code suivant construit deux nouveaux objets uint. Pour créer le premier, il affecte une valeur littérale, tandis que pour créer le second, il utilise la fonction constructeur :
	 <pre>
	 var n1:uint = 3;
	 var n2:uint = new uint(10);
	 </pre>
	 
	 </example></apiConstructorDetail></apiConstructor><apiOperation id="uint:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>fractionDigits</codeph> n’est pas compris entre 0 et 20.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 0 et 20 inclus qui représente le nombre requis de décimales.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle. La chaîne contient un chiffre avant la virgule et jusqu’à 20 décimales, comme spécifié par le paramètre <codeph>fractionDigits</codeph>.
      </apiDesc><example conref="examples\Number.toExponential.1.as"> L’exemple suivant indique comment <codeph>toExponential(2)</codeph> renvoie une chaîne sous forme de notation exponentielle.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     Renvoie une représentation sous forme de chaîne du nombre en notation à virgule fixe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>fractionDigits</codeph> n’est pas compris entre 0 et 20.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 0 et 20 inclus qui représente le nombre requis de décimales.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie une représentation sous forme de chaîne du nombre en notation à virgule fixe. La notation à virgule fixe signifie que la chaîne contiendra un nombre spécifique de décimales, indiqué par le paramètre <codeph>fractionDigits</codeph>. Le paramètre <codeph>fractionDigits</codeph> gère une plage de valeurs comprises entre 0 et 20. Spécifier une valeur qui excède cette plage entraîne le renvoi d’une exception.
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> L’exemple suivant indique comment <codeph>toFixed(3)</codeph> renvoie une chaîne qui arrondit le résultat à trois chiffres après la virgule.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> L’exemple suivant indique comment <codeph>toFixed(2)</codeph> renvoie une chaîne qui ajoute des zéros à la fin.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle ou à virgule fixe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Renvoie une exception si l’argument <codeph>precision</codeph> n’est pas compris entre 1 et 21.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier compris entre 1 et 21 inclus qui indique le nombre requis de décimales dans la chaîne générée.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Renvoie une représentation sous forme de chaîne du nombre en notation exponentielle ou à virgule fixe. La chaîne contiendra le nombre de décimales spécifié par le paramètre <codeph>precision</codeph>.
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> L’exemple suivant indique comment <codeph>toPrecision(3)</codeph> renvoie une chaîne limitée à trois chiffres. La chaîne recourt à la notation à point fixe, dans la mesure où la notation exponentielle n’est pas requise.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> L’exemple suivant indique comment <codeph>toPrecision(3)</codeph> renvoie une chaîne limitée à trois chiffres. La chaîne applique la notation exponentielle dans la mesure où le nombre qui en résulte ne contient pas suffisamment de chiffres pour la notation à point fixe.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Renvoie la représentation sous forme de chaîne d’un objet uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’objet uint.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Spécifie la base numérique (de 2 à 36) à appliquer pour la conversion nombre vers chaîne. Si vous omettez le paramètre <codeph>radix</codeph>, la valeur par défaut est de <codeph>10</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie la représentation sous forme de chaîne d’un objet uint.
	 
     </apiDesc><example>L’exemple suivant utilise 2 et 8 pour les paramètres <codeph>radix</codeph> et renvoie une valeur de chaîne avec la représentation correspondante du numéro 9 :
	 <pre>
	 var myuint:uint = 9;
	 trace(myuint.toString(2)); // 1001
	 trace(myuint.toString(8)); // 11
	 </pre>
	 L’exemple suivant crée des valeurs hexadécimales :
	 <pre>
	 var r:uint = 250;
	 var g:uint = 128;
	 var b:uint = 114;
	 var rgb:String = "0x" + r.toString(16) + g.toString(16) + b.toString(16);
	 trace(rgb); // 0xfa8072 
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Renvoie la valeur du type uint de primitive de l’objet uint spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Valeur du type uint de primitive de l’objet uint.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie la valeur du type uint de primitive de l’objet uint spécifié.
	 
	 </apiDesc><example>L’exemple suivant renvoie la valeur primitive de l’objet <codeph> numSocks</codeph>.
	 <pre>
	 var numSocks:uint = 2;
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="uint:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	Entier non signé 32 bits représentable le plus élevé, soit 4 294 967 295.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4294967295</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
	Entier non signé 32 bits représentable le plus élevé, soit 4 294 967 295.
	
   	</apiDesc><example>Le code ActionScript suivant affiche les valeurs <codeph>uint</codeph> représentables les plus élevées et les plus faibles :
	<pre>
	trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	</pre>
	<p>Les valeurs sont les suivantes :</p>
	<pre>
	uint.MIN_VALUE = 0
	uint.MAX_VALUE = 4294967295
	</pre>
	
	</example></apiValueDetail></apiValue><apiValue id="uint:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 Entier non signé représentable le plus faible, soit 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Entier non signé représentable le plus faible, soit <codeph>0</codeph>.
	 
	 </apiDesc><example>Le code ActionScript suivant affiche les valeurs <codeph>uint</codeph> représentables les plus élevées et les plus faibles :
	 <pre>
	 trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	 trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	 </pre>
	 <p>Les valeurs sont les suivantes :</p>
	 <pre>
	 uint.MIN_VALUE = 0
	 uint.MAX_VALUE = 4294967295
	 </pre>
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Vector"><apiName>Vector</apiName><shortdesc>
 La classe Vector vous permet d’accéder à un vecteur et de le manipuler &amp;#8212; ; un vecteur est un tableau dont les éléments possèdent tous le même type de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector, Vector object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Vous permet de définir des vecteurs (de type Arrays).
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Vector vous permet d’accéder à un vecteur et de le manipuler ; un vecteur est un tableau dont les éléments possèdent tous le même type de données. Le type de données des éléments d’un vecteur est appelé le <i>type de base</i> du vecteur. Le type de base peut correspondre à n’importe quelle classe, notamment aux classes intégrées et aux classes personnalisées. Le type de base est spécifié lorsque vous déclarez la variable d’un vecteur et lorsque vous créez une occurrence en appelant le constructeur de classe.
 
 <p>Tout comme pour un tableau, vous pouvez utiliser l’opérateur (<codeph>[]</codeph>) d’accès au tableau pour définir ou récupérer la valeur d’un élément Vector. Plusieurs méthodes d’un objet Vector fournissent également des mécanismes permettant de définir et de récupérer les valeurs des éléments. Parmi ces méthodes figurent, notamment : <codeph>push()</codeph>, <codeph>pop()</codeph>, <codeph>shift()</codeph>, <codeph>unshift()</codeph>. Les propriétés et les méthodes d’un object Vector sont similaires, voire dans certains cas identiques, aux propriétés et aux méthodes d’un objet Array. Dans tous les cas où vous utilisez un objet Array dont tous les éléments possèdent le même type de données, il est préférable d’utiliser une occurrence de l’objet Vector.</p>
 
 <p>Le type de base du vecteur est spécifié à l’aide d’une syntaxe de paramètres de type postfix. La syntaxe de paramètres de type est une séquence constituée d’un point (<codeph>.</codeph>), d’un chevron gauche (<codeph>&lt;</codeph>), du nom de la classe, puis d’un chevron droit (<codeph>></codeph>), comme l’indique l’exemple suivant :</p>
 
 <codeblock>
 var v:Vector.&lt;String>;
 v = new Vector.&lt;String>();
 </codeblock>
 
 <p>Dans la première ligne de cet exemple, la variable <codeph>v</codeph> est déclarée comme l’occurrence d’un objet Vector.&lt;String>. En d’autres termes, elle représente un vecteur (un tableau) ne pouvant contenir que des occurrences de String et duquel seules des occurrences de String peuvent être récupérées. La deuxième ligne construit une occurrence du même type de vecteur (c’est-à-dire d’un vecteur dont les éléments sont tous des objets String) et l’affecte à <codeph>v</codeph>.</p>
 
 <p>Une variable déclarée avec le type de données Vector.&lt;T> peut stocker uniquement une occurrence de Vector construite avec le même type de base <codeph>T</codeph>. Par exemple, il est impossible d’affecter un vecteur construit en appelant <codeph>new Vector.&lt;String>()</codeph> à une variable déclarée avec le type de données Vector.&lt;int>. Les types de base doivent correspondre exactement. Par exemple, le code suivant ne se compile pas, car le type de base de l’objet n’est pas le même que le type de base déclaré de la variable (même si Sprite est une sous-classe de DisplayObject) :</p>
 
 <codeblock>
 // This code doesn't compile even though Sprite is a DisplayObject subclass
 var v:Vector.&lt;DisplayObject> = new Vector.&lt;Sprite>();
 </codeblock>
 
 <p>Pour convertir un objet Vector avec un type de base <codeph>T</codeph> en un objet Vector d’une super-classe de <codeph>T</codeph>, utilisez la fonction globale <codeph>Vector()</codeph>.</p>
 
 <p>Outre la restriction concernant le type de données, la classe Vector possède d’autres restrictions qui la distinguent de la classe Array :</p>
 
 <ul>
   <li>Un vecteur est un tableau dense. Contrairement à un tableau, qui peut posséder des valeurs dans les index 0 et 7 même s’il n’existe aucune valeur dans les positions 1 à 6, un vecteur doit posséder une valeur (ou la valeur <codeph>null</codeph>) dans chaque index.</li>
   <li>La longueur d’un vecteur peut éventuellement être fixe ; en d’autres termes, le nombre d’éléments qu’il contient est invariable.</li>
   <li>L’accès aux éléments d’un vecteur est défini par ses limites. Vous ne pouvez jamais lire une valeur d’un index supérieur à celui de l’élément final (<codeph>longueur - 1</codeph>). Vous ne pouvez jamais définir une valeur avec un index supérieur à l’index final actuel (en d’autres termes, vous pouvez définir une valeur uniquement à l’index existant où à une <codeph>[longueur]</codeph> d’index).</li>
 </ul>
 
 <p>Grâce à ses restrictions, un vecteur présente deux avantages principaux par rapport à une occurrence de Array dont les éléments sont tous des occurrences d’une seule classe :</p>
 <ul>
   <li>Performance : l’accès à l’élément de tableau et son itération sont beaucoup plus rapides lorsque vous utilisez une occurrence de Vector que lorsque vous utilisez une occurrence de Array.</li>
   <li>Sécurité des types : en mode strict, le compilateur peut identifier les erreurs de type de données, telles que l’attribution d’un type de données incorrect à un vecteur ou l’obtention d’un type de données incorrect lors de la lecture de la valeur d’un vecteur. Notez cependant que lorsque vous utilisez la méthode <codeph>push</codeph> ou <codeph>unshift()</codeph> pour ajouter des valeurs à un vecteur, les types de données des arguments ne sont pas vérifiés au moment de la compilation, mais le sont au moment de l’exécution.</li>
 </ul> 
 
 </apiDesc></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[], accès au tableau</linktext></link><link href="#global/Vector()"><linktext>Fonction Vector()</linktext></link><link href="#Array"><linktext>Classe Array</linktext></link></related-links><apiConstructor id="Vector:Vector"><apiName>Vector</apiName><shortdesc>
	 Crée un vecteur avec le type de base spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Longueur initiale (nombre d’éléments) du vecteur. Si ce paramètre est supérieur à zéro, les éléments de vecteur spécifiés sont créés et renseignés avec la valeur par défaut correspondant au type de base (<codeph>null</codeph> pour les types de référence).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fixed</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si la longueur du vecteur est fixe (<codeph>true</codeph>) ou si elle peut être modifiée (<codeph>false</codeph>). Il est également possible de définir cette valeur à l’aide de la propriété <codeph>fixed</codeph>.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un vecteur avec le type de base spécifié.
	 
	 <p>Lorsque vous appelez le constructeur <codeph>Vector&lt;T>()</codeph>, spécifiez le type de base à l’aide de la syntaxe de paramètres de type. La syntaxe de paramètres de type est une séquence constituée d’un point (<codeph>.</codeph>), d’un chevron gauche (<codeph>&lt;</codeph>), du nom de la classe, puis d’un chevron droit (<codeph>></codeph>), comme l’indique l’exemple suivant :</p>
	 
	 <pre product="flash">
	 var v:Vector.&lt;String> = new Vector.&lt;String>();
	 </pre>
	 
	 <p>Contrairement à la classe Array, vous ne pouvez pas utiliser le constructeur <codeph>Vector.&lt;T>()</codeph> pour créer une occurrence de Vector préremplie. Pour créer une occurrence de Vector à partir d’un tableau ou d’un autre vecteur (notamment avec un type de base différent), utilisez la fonction globale <codeph>Vector()</codeph>.</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="#global/Vector()"><linktext>Fonction Vector()</linktext></link></related-links></apiConstructor><apiOperation id="Vector:AS3:concat"><apiName>concat</apiName><shortdesc>
     Concatène les éléments spécifiés dans les paramètres avec ceux contenus dans le vecteur et crée un nouveau vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.concat, concat, concatenate
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Si un argument n’est pas une occurrence du type de base et ne peut pas être converti au type de base.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Un vecteur avec le même type de base que ce vecteur qui contient les éléments correspondants, suivis des éléments des paramètres.
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs valeurs du type de base de ce vecteur à concaténer dans un nouveau vecteur. Si vous ne transmettez aucune valeur, le nouveau vecteur est une duplication du vecteur d’origine.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Concatène les éléments spécifiés par les paramètres.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Concatène les éléments spécifiés dans les paramètres avec ceux contenus dans le vecteur et crée un nouveau vecteur. Si les paramètres spécifient un vecteur, les éléments correspondants sont concaténés. 
	 
	 <codeblock>hello world</codeblock>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:every"><apiName>every</apiName><shortdesc>
	Exécute une fonction de test sur chaque élément du vecteur jusqu’à ce que l’un d’eux renvoie false pour la fonction spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Une valeur boléenne <codeph>true</codeph> si la fonction spécifiée renvoie <codeph>true</codeph> lorsqu’elle est appelée sur tous les éléments dans le vecteur, <codeph>false</codeph> dans tous les autres cas.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du vecteur. Cette fonction est invoquée avec trois arguments : l’élément actuel du vecteur, l’index de l’élément et l’objet Vector :
	<pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre> 
	
	<p>La fonction de rappel doit renvoyer une valeur booléenne.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet auquel se réfère l’identifiant <codeph>this</codeph> dans le rappel lorsque la fonction est appelée.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Exécute une fonction de test sur chaque élément du vecteur jusqu’à ce que l’un d’eux renvoie <codeph>false</codeph> pour la fonction spécifiée. Cette méthode vous permet de déterminer si tous les éléments d’un vecteur répondent à un critère défini, tel que des valeurs inférieures à un nombre spécifique.
	
	<p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. C’est ainsi que cette méthode est le plus souvent utilisée.</p>
	
	<p product="flash">Néanmoins, supposons que vous créiez une fonction sur une image du scénario principal à l’aide de Flash Professional et que vous souhaitiez qu’elle soit appelée dans un contexte <codeph>this</codeph> différent :</p>
	
	<pre product="flash">
	function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre>
	
	<p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>every()</codeph> sur un vecteur appelé <codeph>myVector</codeph> :</p>
	
	<pre product="flash">
	myVector.every(myFunction, someObject);
	</pre>
	
	<p product="flash">Etant donné que <codeph>myFunction</codeph> est un membre de la classe principale du fichier SWF, elle ne peut pas être exécutée dans un contexte <codeph>this</codeph> différent. Flash Player ou AIR renvoie un exception lors de l’exécution de ce code. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
	
	<pre product="flash">
	var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	    //your code here
	};
	myVector.every(myFunction, someObject);
	</pre>
	
	</apiDesc></apiOperationDetail><related-links><link href="#Vector/some()"><linktext>Vector.some()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:filter"><apiName>filter</apiName><shortdesc>
     Exécute une fonction de test sur chaque élément du vecteur et construit un nouveau vecteur contenant tous les éléments qui renvoient true pour la fonction spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Un nouveau vecteur qui contient tous les éléments du vecteur d’origine pour lequel la fonction <codeph>callback</codeph> a renvoyé <codeph>true</codeph>.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du vecteur. Cette fonction est invoquée avec trois arguments : l’élément actuel du vecteur, l’index de l’élément et l’objet Vector :
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet auquel se réfère l’identifiant <codeph>this</codeph> dans le rappel lorsque la fonction est appelée.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Exécute une fonction de test sur chaque élément du vecteur et construit un nouveau vecteur contenant tous les éléments qui renvoient <codeph>true</codeph> pour la fonction spécifiée. Si un élément renvoie <codeph>false</codeph>, il ne figure pas dans le vecteur résultant. Le type de base du vecteur renvoyé correspond à celui du vecteur pour lequel la méthode est appelée.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. C’est ainsi que cette méthode est le plus souvent utilisée.</p>
	 
	 <p product="flash">Néanmoins, supposons que vous créiez une fonction sur une image du scénario principal à l’aide de Flash Professional et que vous souhaitiez qu’elle soit appelée dans un contexte <codeph>this</codeph> différent :</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>filter()</codeph> sur un vecteur appelé <codeph>myVector</codeph> :</p>
	 
     <pre product="flash">
     var result:Vector.&lt;T> = myVector.filter(myFunction, someObject);
     </pre>
	 
     <p product="flash">Etant donné que <codeph>myFunction</codeph> est un membre de la classe principale du fichier SWF, elle ne peut pas être exécutée dans un contexte <codeph>this</codeph> différent. Flash Player renvoie un exception lors de l’exécution de ce code. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.filter(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/map()"><linktext>Vector.map()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:forEach"><apiName>forEach</apiName><shortdesc>
     Exécute une fonction sur chaque élément du vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du vecteur. Cette fonction est invoquée avec trois arguments : l’élément actuel du vecteur, l’index de l’élément et l’objet Vector :
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):void;</pre>
	 <p>Toute valeur renvoyée depuis l’appel de fonction est supprimée.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet auquel se réfère l’identifiant <codeph>this</codeph> dans le rappel lorsque la fonction est appelée.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Exécute une fonction sur chaque élément du vecteur.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. C’est ainsi que cette méthode est le plus souvent utilisée.</p>
	 
	 <p product="flash">Néanmoins, supposons que vous créiez une fonction sur une image du scénario principal à l’aide de Flash Professional et que vous souhaitiez qu’elle soit appelée dans un contexte <codeph>this</codeph> différent :</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):void {
        // your code here
     }
     </pre>
	 
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>forEach()</codeph> sur un vecteur appelé <codeph>myVector</codeph> :</p>
	 
     <pre product="flash">
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     <p product="flash">Etant donné que <codeph>myFunction</codeph> est un membre de la classe principale du fichier SWF, elle ne peut pas être exécutée dans un contexte <codeph>this</codeph> différent. Flash Player renvoie un exception lors de l’exécution de ce code. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
     Recherche un élément dans le vecteur et renvoie la position d’index de l’élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Une position d’index commençant à zéro de l’élément du vecteur. Si l’argument <codeph>searchElement</codeph> n’est pas détecté, la valeur renvoyée est -1.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>Elément à rechercher dans le vecteur.
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Emplacement dans le vecteur à partir duquel débuter la recherche d’élément. Si ce paramètre est négatif, il est considéré comme <codeph>length + fromIndex</codeph>. Cela signifie que la recherche commence à partir des éléments <codeph>-fromIndex</codeph> jusqu’à la fin, puis continue à partir de cette position jusqu’à la fin du vecteur.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Recherche un élément dans le vecteur et renvoie la position d’index de l’élément. L’élément est comparé aux éléments du vecteur à l’aide de l’égalité stricte (<codeph>===</codeph>).
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/lastIndexOf()"><linktext>Vector.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (égalité stricte)</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:join"><apiName>join</apiName><shortdesc>
     Convertit les éléments d’un vecteur en chaînes, insère le séparateur spécifié entre les éléments, les concatène, puis renvoie la chaîne obtenue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.join, join
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Chaîne composée des éléments d’un vecteur convertis en chaînes et séparés par la chaîne spécifiée.
     
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>,</apiData><apiDesc>Caractère ou chaîne séparant les éléments du vecteur dans la chaîne renvoyée. Si vous omettez ce paramètre, une virgule est utilisée en tant que séparateur par défaut. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Convertit les éléments d’un vecteur en chaînes.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Convertit les éléments d’un vecteur en chaînes, insère le séparateur spécifié entre les éléments, les concatène, puis renvoie la chaîne obtenue. Un vecteur imbriqué est toujours séparé par une virgule (,) et non pas par le séparateur transmis à la méthode <codeph>join()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
     Recherche un élément dans le vecteur, en travaillant à rebours à partir de la position d’index spécifiée, puis renvoie la position d’index de l’élément correspondant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Une position d’index commençant à zéro de l’élément du vecteur. Si l’argument <codeph>searchElement</codeph> n’est pas détecté, la valeur renvoyée est -1.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>Elément à rechercher dans le vecteur.
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Emplacement dans le vecteur à partir duquel débuter la recherche d’élément. La valeur par défaut correspond à la valeur d’index maximale autorisée, ce qui signifie que la recherche commence à partir du dernier élément du vecteur.
	 <p>Si ce paramètre est négatif, il est considéré comme <codeph>length + fromIndex</codeph>. Cela signifie que la recherche commence à partir des éléments <codeph>-fromIndex</codeph> jusqu’à la fin, puis continue à partir de cette position jusqu’à l’index 0.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Recherche un élément dans le vecteur, en travaillant à rebours à partir de la position d’index spécifiée, puis renvoie la position d’index de l’élément correspondant. L’élément est comparé aux éléments du vecteur à l’aide de l’égalité stricte (<codeph>===</codeph>).
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/indexOf()"><linktext>Vector.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (égalité stricte)</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:map"><apiName>map</apiName><shortdesc>
     Exécute une fonction sur chaque élément du vecteur, puis renvoie un nouveau vecteur avec les éléments correspondants aux résultats de l’appel de fonction sur chaque élément de ce vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Un nouveau vecteur qui contient les résultats de l’appel de la fonction sur chaque élément de ce vecteur. Le vecteur résultant possède le même type de base et la même propriété <codeph>length</codeph> que le vecteur d’origine.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du vecteur. Cette fonction est invoquée avec trois arguments : l’élément actuel du vecteur, l’index de l’élément et l’objet Vector :
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):T;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet auquel se réfère l’identifiant <codeph>this</codeph> dans le rappel lorsque la fonction est appelée.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Exécute une fonction sur chaque élément du vecteur, puis renvoie un nouveau vecteur avec les éléments correspondants aux résultats de l’appel de fonction sur chaque élément de ce vecteur. Le vecteur résultant possède le même type de base et la même propriété <codeph>length</codeph> que le vecteur d’origine. L’élément qui occupe la position d’index <codeph>i</codeph> dans le vecteur obtenu est le résultat de l’appel de l’élément qui occupe la position d’index <codeph>i</codeph> dans le vecteur d’origine.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. C’est ainsi que cette méthode est le plus souvent utilisée.</p>
	 
	 <p product="flash">Néanmoins, supposons que vous créiez une fonction sur une image du scénario principal à l’aide de Flash Professional et que vous souhaitiez qu’elle soit appelée dans un contexte <codeph>this</codeph> différent :</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):T {
        // your code here
     }
     </pre>
	 
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>map()</codeph> sur un vecteur appelé <codeph>myVector</codeph> :</p>
	 
     <pre product="flash">
     myVector.map(myFunction, someObject);
     </pre>
	 
     <p product="flash">Etant donné que <codeph>myFunction</codeph> appartient à la classe principale du fichier SWF, elle ne peut pas être exécutée dans un contexte <codeph>this</codeph> différent. Flash Player renvoie un exception lors de l’exécution de ce code. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.map(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/filter()"><linktext>Vector.filter()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:pop"><apiName>pop</apiName><shortdesc>
     Supprime le dernier élément du vecteur et renvoie cet élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.pop, pop
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Si cette méthode est appelée alors que <codeph>fixed</codeph> est <codeph>true</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur du dernier élément dans le vecteur spécifié.
	 
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     Supprime le dernier élément du vecteur et renvoie cet élément. La propriété <codeph>length</codeph> du vecteur est diminuée d’une unité lorsque cette fonction est appelée.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:push"><apiName>push</apiName><shortdesc>
     Ajoute un ou plusieurs éléments à la fin d’un vecteur et renvoie la nouvelle longueur du vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.push, push
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Si un argument n’est pas une occurrence du type de base <codeph>T</codeph> du vecteur.
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Si cette méthode est appelée alors que <codeph>fixed</codeph> est <codeph>true</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>La longueur du vecteur une fois les éléments ajoutés.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs valeurs à ajouter au vecteur.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute un ou plusieurs éléments à la fin d’un vecteur et renvoie la nouvelle longueur du vecteur.
	 
	 <p>Etant donné que cette fonction peut accepter plusieurs arguments, le type de données des arguments n’est pas vérifié au moment de la compilation, même en mode strict. En revanche, si un argument n’étant pas une occurrence du type de base est transmis, une exception se produit au moment de l’exécution.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:reverse"><apiName>reverse</apiName><shortdesc>
     Inverse l’ordre les éléments dans le vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.reverse, reverse
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Le vecteur avec les éléments dans l’ordre inverse.
	 
     </apiDesc><apiType value="Vector$T"/></apiReturn></apiOperationDef><apiDesc>
     Inverse l’ordre les éléments dans le vecteur. Cette méthode modifie le vecteur pour lequel elle est appelée.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:shift"><apiName>shift</apiName><shortdesc>
     Supprime le premier élément du vecteur et renvoie cet élément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.shift, shift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Si la propriété <codeph>fixed</codeph> est définie sur <codeph>true</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Le premier élément dans le vecteur.
     
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     Supprime le premier élément du vecteur et renvoie cet élément. Les éléments restants du vecteur sont décalés de leur position d’origine, i, vers i -1.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:slice"><apiName>slice</apiName><shortdesc>
     Renvoie un nouveau vecteur constitué d’un éventail d’éléments issus du vecteur d’origine, sans modifier ce dernier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.slice, slice
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>un vecteur constitué d’un éventail d’éléments issus du vecteur d’origine.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre spécifiant l’index du point de départ pour la découpe. Si <codeph>startIndex</codeph> est un nombre négatif, le point de départ se trouve à la fin du vecteur, où la valeur -1 correspond au dernier élément.  
     
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>Nombre spécifiant l’index du point d’arrivée pour la découpe. Si vous omettez ce paramètre, la découpe inclut tous les éléments, du point de départ à la fin du vecteur. Si <codeph>endIndex</codeph> est un nombre négatif, le point d’arrivée spécifié se trouve à la fin du vecteur, où la valeur -1 correspond au dernier élément.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie un nouveau vecteur constitué d’un éventail d’éléments issus du vecteur d’origine.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Renvoie un nouveau vecteur constitué d’un éventail d’éléments issus du vecteur d’origine, sans modifier ce dernier. Le vecteur renvoyé inclut l’élément <codeph>startIndex</codeph> et tous les éléments, excepté l’élément <codeph>endIndex</codeph>.
	 
     <p>Si vous ne transmettez aucun paramètre, une duplication du vecteur d’origine est créée.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:some"><apiName>some</apiName><shortdesc>
     Exécute une fonction de test sur chaque élément du vecteur jusqu’à ce que l’un d’eux renvoie true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Une valeur booléenne <codeph>true</codeph> si un élément du vecteur renvoie <codeph>true</codeph> pour la fonction spécifiée, <codeph>false</codeph> dans tous les autres cas.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction à exécuter sur chaque élément du vecteur. Cette fonction est invoquée avec trois arguments : l’élément actuel du vecteur, l’index de l’élément et l’objet Vector :
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean</pre> 
     
     <p>La fonction de rappel doit renvoyer une valeur booléenne.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet auquel se réfère l’identifiant <codeph>this</codeph> dans le rappel lorsque la fonction est appelée.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Exécute une fonction de test sur chaque élément du vecteur jusqu’à ce que l’un d’eux renvoie <codeph>true</codeph>. Cette méthode vous permet de déterminer si un élément du vecteur répond au critère défini, tel qu’une valeur inférieure à un nombre spécifique.
     
     <p product="flash">Avec cette méthode, le second paramètre, <codeph>thisObject</codeph>, doit être réglé sur <codeph>null</codeph> si le premier paramètre, <codeph>callback</codeph>, est une fermeture de méthode. C’est ainsi que cette méthode est le plus souvent utilisée.</p>
	 
	 <p product="flash">Néanmoins, supposons que vous créiez une fonction sur une image du scénario principal et que vous souhaitiez qu’elle soit appelée dans un contexte <codeph>this</codeph> différent :</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">Supposons que vous utilisiez ensuite la méthode <codeph>some()</codeph> sur un vecteur appelé <codeph>myVector</codeph> :</p>
	 
     <pre product="flash">
     myVector.some(myFunction, someObject);
     </pre>
	 
     <p product="flash">Etant donné que <codeph>myFunction</codeph> appartient à la classe principale du fichier SWF, elle ne peut pas être exécutée dans un contexte <codeph>this</codeph> différent. Flash Player renvoie un exception lors de l’exécution de ce code. Pour éviter le renvoi de cette erreur d’exécution, affectez la fonction à une variable, comme suit :</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.some(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:sort"><apiName>sort</apiName><shortdesc>
     Trie les éléments dans le vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.sort, sort
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ce vecteur, avec les éléments dans le nouvel ordre.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>compareFunction</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Méthode de comparaison qui détermine le comportement du tri.
	 
     <p>La méthode spécifiée doit prendre deux arguments du type de base (<codeph>T</codeph>) du vecteur et renvoyer un nombre :</p>
	 
	 <codeblock>function compare(x:T, y:T):Number {}</codeblock>
	 
	 <p>La logique de la fonction <codeph>compareFunction</codeph> est que, selon deux éléments <codeph>x</codeph> et <codeph>y</codeph>, la fonction renvoie l’une des trois valeurs suivantes :</p>
	 
     <ul>
       <li>un nombre négatif, si <codeph>x</codeph> apparaît avant <codeph>y</codeph> dans la séquence triée ;</li>
       <li>0, si <codeph>x</codeph> équivaut à <codeph>y</codeph> ;</li>
       <li>un nombre positif, si <codeph>x</codeph> apparaît après <codeph>y</codeph> dans la séquence triée.</li>
     </ul>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Trie les éléments dans le vecteur. Cette méthode effectue le tri selon la fonction fournie en tant que paramètre <codeph>compareFunction</codeph>.
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:splice"><apiName>splice</apiName><shortdesc>
     Ajoute et supprime des éléments dans un vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.splice, splice
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Si les arguments <codeph>startIndex</codeph> et <codeph>deleteCount</codeph> spécifient un index à supprimer qui se trouve en dehors des limites du vecteur.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Si la méthode est appelée alors que la propriété <codeph>fixed</codeph> est définie sur <codeph>true</codeph> et que l’opération <codeph>splice()</codeph> modifie la <codeph>longueur</codeph> du vecteur.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>un vecteur contenant les éléments supprimés du vecteur d’origine.
     
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Entier spécifiant l’index de la position d’insertion ou de suppression de l’élément dans le vecteur. Vous pouvez utiliser un entier négatif pour définir une position par rapport à la fin du vecteur (par exemple, la valeur -1 représente le dernier élément du vecteur).
	 
     </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier spécifiant le nombre d’éléments à supprimer. Ce nombre inclut l’élément spécifié dans le paramètre <codeph>startIndex</codeph>. Si vous ne spécifiez pas de valeur pour le paramètre <codeph>deleteCount</codeph>, la méthode supprime toutes les valeurs comprises entre l’élément <codeph>startIndex</codeph> et le dernier élément du vecteur. Si la valeur est 0, aucun élément n’est supprimé.
	 
     </apiDesc></apiParam><apiParam><apiItemName>items</apiItemName><apiType value="restParam"/><apiDesc>Liste facultative d’une ou de plusieurs valeurs séparées par une virgule à insérer dans le vecteur à la position spécifiée par le paramètre <codeph>startIndex</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute et supprime des éléments dans un vecteur. Cette méthode modifie le vecteur sans faire de copie.
	 
     <p><b>Remarque :</b> pour annuler cette méthode dans une sous-classe de Vector, utilisez <codeph>...args</codeph> pour les paramètres, comme indiqué dans l’exemple ci-dessous :</p>
	 
     <pre>
     public override function splice(...args) {
       // your statements here
     }
     </pre>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     Renvoie une chaîne représentant les éléments du vecteur spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne d’éléments de vecteur.
	 
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Renvoie une chaîne représentant les éléments du vecteur spécifié. Chaque élément du vecteur, de la position d’index 0 à la position d’index la plus élevée, est converti en chaîne concaténée et séparé par des virgules. Dans l’implémentation d’ActionScript 3.0, cette méthode renvoie la même valeur que la méthode <codeph>Vector.toString()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/toString()"><linktext>Vector.toString()</linktext></link></related-links></apiOperation><apiOperation id="Vector:toString"><apiName>toString</apiName><shortdesc>
     Renvoie une chaîne représentant les éléments du vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.toString, toString
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne d’éléments de vecteur.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Renvoie une chaîne représentant les éléments du vecteur. Chaque élément du vecteur, de la position d’index 0 à la position d’index la plus élevée, est converti en chaîne concaténée et séparé par des virgules. Pour spécifier un séparateur personnalisé, utilisez la méthode <codeph>Vector.join()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Vector/join()"><linktext>Vector.join()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     Ajoute un ou plusieurs éléments du début d’un vecteur et renvoie la nouvelle longueur du vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.unshift, unshift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Si un argument n’est pas une occurrence du type de base <codeph>T</codeph> du vecteur.
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Si cette méthode est appelée alors que <codeph>fixed</codeph> est <codeph>true</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Entier représentant la nouvelle longueur du vecteur.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs occurrence du type de base du vecteur à insérer au début du vecteur.  
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute un ou plusieurs éléments du début d’un vecteur et renvoie la nouvelle longueur du vecteur. Les autres éléments du vecteur sont décalés de leur position d’origine, i, vers i + le nombre de nouveaux éléments.
     
	 <p>Etant donné que cette fonction peut accepter plusieurs arguments, le type de données des arguments n’est pas vérifié au moment de la compilation, même en mode strict. En revanche, si un argument n’étant pas une occurrence du type de base est transmis, une exception se produit au moment de l’exécution.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link></related-links></apiOperation><apiValue id="Vector:fixed:get"><apiName>fixed</apiName><shortdesc>
     Indique si la propriété length du vecteur peut être modifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.fixed, fixed
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si la propriété <codeph>length</codeph> du vecteur peut être modifiée. Si la valeur est <codeph>false</codeph>, la propriété <codeph>length</codeph> ne peut pas être modifiée. Cela signifie que les opérations suivantes ne sont pas autorisées lorsque <codeph>fixed</codeph> est <codeph>true</codeph> :
	 
	 <ul>
	   <li>réglage direct de la propriété <codeph>length</codeph> ;</li>
	   <li>attribution d’une valeur à la position d’index <codeph>length</codeph> ;</li>
	   <li>appel d’une méthode qui modifie la propriété <codeph>length</codeph>, notamment :
	     <ul>
	       <li><codeph>pop()</codeph></li>
	       <li><codeph>push()</codeph></li>
	       <li><codeph>shift()</codeph></li>
	       <li><codeph>unshift()</codeph></li>
	       <li><codeph>splice()</codeph> (si l’appel de la méthode <codeph>splice()</codeph> change la propriété <codeph>length</codeph> du vecteur).</li>
	     </ul>
	   </li>
	 </ul>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="Vector:length:get"><apiName>length</apiName><shortdesc>
     Plage des index disponibles dans le vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.length, length
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Si cette propriété est modifiée alors que <codeph>fixed</codeph> est <codeph>true</codeph>.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Si cette propriété est définie sur une valeur supérieure à l’index maximal autorisé (2<sup>32</sup>).
	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Plage des index disponibles dans le vecteur. Une occurrence de Vector a des positions d’index jusqu’à la valeur <codeph>length</codeph> (mais sans l’inclure).
	 
	 <p>Chaque élément du vecteur possède toujours une valeur qui correspond à une occurrence du type de base ou à la valeur <codeph>null</codeph>. Lorsque la propriété <codeph>length</codeph> est définie sur une valeur supérieure à sa valeur précédente, d’autres éléments sont créés et remplis avec la valeur par défaut correspondant au type de base (<codeph>null</codeph> pour les types de référence).</p>
	 
	 <p>Lorsque la propriété <codeph>length</codeph> est définie sur une valeur inférieure à sa valeur précédente, tous les éléments à des positions d’index supérieures ou égales à la nouvelle valeur <codeph>length</codeph> sont supprimés du vecteur.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>