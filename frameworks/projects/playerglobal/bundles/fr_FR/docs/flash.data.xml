<?xml version="1.0"?>
<apiPackage id="flash.data"><apiName>flash.data</apiName><apiDetail/><apiClassifier id="flash.data:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
 Une occurrence SQLViewSchema fournit des informations décrivant une vue spécifique dans une base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLTableSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une occurrence SQLViewSchema fournit des informations décrivant une vue spécifique dans une base de données. Elle contient le nom de la vue (la propriété <codeph>name</codeph>), l’instruction SQL utilisée pour créer la vue (la propriété <codeph>sql</codeph>) et des informations sur les colonnes de la vue (la propriété <codeph>columns</codeph>).
 
 <p>Pour obtenir les informations du schéma d’une vue d’une base de données, utilisez la méthode <codeph>SQLConnection.loadSchema()</codeph> pour charger les informations du schéma, en vous assurant d’utiliser <codeph>null</codeph> ou <codeph>SQLViewSchema</codeph> comme valeur d’argument <codeph>type</codeph>. Dans l’occurrence SQLSchemaResult résultante, la propriété <codeph>views</codeph> contient un tableau d’occurrences SQLViewSchema représentant les vues de la base de données.</p>
 
 <p>En général, le code du développeur ne construit pas directement d’occurrences SQLViewSchema.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLViewSchema:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
     Crée une occurrence SQLViewSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la base de données associée.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la vue.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Instruction SQL utilisée pour créer la vue.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau d’occurrences SQLColumnSchema décrivant les colonnes de cette vue.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence SQLViewSchema. En général, le code du développeur n’appelle pas directement le constructeur SQLViewSchema. Pour obtenir les informations du schéma d’une base de données, appelez la méthode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.data:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
 La classe SQLColumnSchema fournit des informations décrivant les caractéristiques d’une colonne spécifique dans une table de base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SQLColumnSchema fournit des informations décrivant les caractéristiques d’une colonne spécifique dans une table de base de données.
 
 <p>Pour obtenir les informations du schéma des colonnes pour une ou plusieurs tables de base de données, utilisez la méthode <codeph>SQLConnection.loadSchema()</codeph> pour charger les informations du schéma, en vous assurant d’utiliser <codeph>true</codeph> comme valeur d’argument <codeph>includeColumnSchema</codeph>. Dans l’occurrence SQLSchemaResult résultante, chaque définition de table et de vue inclut une propriété <codeph>columns</codeph>, tableau d’occurrences SQLColumnSchema représentant les colonnes de la table ou de la vue.</p>
 
 <p>En général, le code du développeur ne construit pas directement d’occurrences SQLColumnSchema.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLColumnSchema:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
     Construit une occurrence SQLColumnSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la colonne.
     
     </apiDesc></apiParam><apiParam><apiItemName>primaryKey</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Indique si cette colonne fait partie de la clé primaire de la table associée.
     
     </apiDesc></apiParam><apiParam><apiItemName>allowNull</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Indique si cette colonne peut contenir des valeurs <codeph>NULL</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoIncrement</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Indique s’il s’agit d’une colonne à incrémentation automatique.
     
     </apiDesc></apiParam><apiParam><apiItemName>dataType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type déclaré de la colonne.
     
     </apiDesc></apiParam><apiParam><apiItemName>defaultCollationType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ordre de classement défini pour cette colonne. Cette valeur correspond à l’une des constantes de la classe SQLCollationType :
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> indique que la colonne utilise l’ordre de classement <codeph>BINARY</codeph>.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> indique que la colonne utilise l’ordre de classement <codeph>NOCASE</codeph>, c’est-à-dire que les comparaisons de textes ne respectent pas la casse.</li>
     </ul>
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Construit une occurrence SQLColumnSchema. En général, le code du développeur n’appelle pas directement le constructeur SQLColumnSchema. Pour obtenir les informations du schéma d’une base de données, appelez la méthode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLColumnSchema:allowNull:get"><apiName>allowNull</apiName><shortdesc>
     Indique si les valeurs NULL sont autorisées dans cette colonne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si les valeurs <codeph>NULL</codeph> sont autorisées dans cette colonne. Une colonne déclarée avec une contrainte <codeph>NOT NULL</codeph> a une valeur <codeph>false</codeph> pour la propriété <codeph>allowNull</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:autoIncrement:get"><apiName>autoIncrement</apiName><shortdesc>
     Indique s’il s’agit d’une colonne à incrémentation automatique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique s’il s’agit d’une colonne à incrémentation automatique. Une colonne à incrémentation automatique est un type spécial de colonnes <codeph>PRIMARY KEY</codeph> dont la valeur est automatiquement générée en tant que valeur suivante d’une suite de nombres entiers lorsqu’une nouvelle ligne est insérée dans la table.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:dataType:get"><apiName>dataType</apiName><shortdesc>
     Extrait le type de données de la colonne sous la forme d’une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Extrait le type de données de la colonne sous la forme d’une chaîne. La valeur est le nom du type de données littéral spécifié dans l’instruction <codeph>CREATE TABLE</codeph> utilisée pour définir la table, ou <codeph>null</codeph> lorsque aucun type de données n’a été spécifié.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:defaultCollationType:get"><apiName>defaultCollationType</apiName><shortdesc>
     Indique l’ordre de classement défini pour cette colonne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indique l’ordre de classement défini pour cette colonne. La valeur de cette propriété correspond à l’une des constantes de la classe SQLCollationType :
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> indique que la colonne utilise l’ordre de classement <codeph>BINARY</codeph>.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> indique que la colonne utilise l’ordre de classement <codeph>NOCASE</codeph>, c’est-à-dire que les comparaisons de textes ne respectent pas la casse.</li>
     </ul>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnSchema:name:get"><apiName>name</apiName><shortdesc>
     Extrait le nom de la colonne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Extrait le nom de la colonne.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:primaryKey:get"><apiName>primaryKey</apiName><shortdesc>
     Indique si cette colonne est celle de la clé primaire (ou l’une des colonnes de clé primaire dans le cas d’une clé composite) de la table associée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si cette colonne est celle de la clé primaire (ou l’une des colonnes de clé primaire dans le cas d’une clé composite) de la table associée.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLColumnNameStyle"><apiName>SQLColumnNameStyle</apiName><shortdesc>
 Cette classe contient les constantes représentant les valeurs possibles de la propriété SQLConnection.columnNameStyle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Cette classe contient les constantes représentant les valeurs possibles de la propriété <codeph>SQLConnection.columnNameStyle</codeph>. Ces valeurs indiquent les différentes options qui contrôlent la mise en forme des noms de colonnes (noms des propriétés) dans les objets renvoyés en tant que résultat d’une instruction SQL <codeph>SELECT</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links><apiValue id="flash.data:SQLColumnNameStyle:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
     Indique que les noms de colonnes renvoyées par une instruction SELECT utilisent le format par défaut.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indique que les noms de colonnes renvoyées par une instruction <codeph>SELECT</codeph> utilisent le format par défaut. Dans le format par défaut, les noms de colonnes ont la forme <codeph>[nom tableau]_[nom colonne]</codeph> lorsque plusieurs tables sont incluses dans l’instruction <codeph>SELECT</codeph> ou <codeph>[nom colonne]</codeph> lorsque l’instruction <codeph>SELECT</codeph> ne comprend qu’une seule table.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:LONG"><apiName>LONG</apiName><shortdesc>
     Indique que les noms de colonnes renvoyées par une instruction SELECT utilisent le format nom-colonne-long.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>long</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indique que les noms de colonnes renvoyées par une instruction <codeph>SELECT</codeph> utilisent le format nom-colonne-long. Dans ce format, les noms de colonnes utilisent la forme <codeph>[nom tableau]_[nom colonne]</codeph> quel que soit le nombre de tables incluses dans l’instruction <codeph>SELECT</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:SHORT"><apiName>SHORT</apiName><shortdesc>
     Indique que les noms de colonnes renvoyées par une instruction SELECT utilisent le format nom-colonne-court.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>short</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indique que les noms de colonnes renvoyées par une instruction <codeph>SELECT</codeph> utilisent le format nom-colonne-court. Dans ce format, les noms de colonnes utilisent la forme <codeph>[nom colonne]</codeph> quel que soit le nombre de tables incluses dans l’instruction <codeph>SELECT</codeph>.
	 
	 <p>Si le jeu de résultats contient plusieurs colonnes portant le même nom, une seule propriété portant ce nom est ajoutée à l’objet de résultat. La valeur affectée à cette propriété provient de la dernière colonne portant ce nom dans la ligne de résultats. Examinons par exemple l’instruction <codeph>SELECT</codeph> suivante :</p>
	 
	 <pre>
	 SELECT customers.customerId, addresses.customerId
	 FROM customers INNER JOIN addresses
	    ON customers.customerId = addresses.customerId
	 </pre>
	 
	 <p>Lorsque cette instruction est exécutée sur une occurrence SQLConnection avec un format de nom de colonne court, chaque objet de résultat a une propriété nommée <codeph>customerId</codeph>, contenant la valeur de la colonne <codeph>customerId</codeph> de la table <codeph>addresses</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
 La classe SQLSchema est la classe de base pour les informations du schéma relatif aux objets de base de données; tels que les tables, les vues et les indices.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SQLSchema est la classe de base pour les informations du schéma relatif aux objets de base de données; tels que les tables, les vues et les indices.
 
 <p>Pour obtenir les informations du schéma d’une base de données, utilisez la méthode <codeph>SQLConnection.loadSchema()</codeph> pour charger les informations du schéma. L’occurrence SQLSchemaResult résultante contient des tableaux d’occurrences représentant les objets de la base de données.</p>
 
 <p>En général, le code du développeur ne construit pas directement d’occurrences SQLSchema.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchema:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
     Crée une occurrence SQLSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la base de données associée.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’objet de base de données.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Code SQL utilisé pour construire l’objet de base de données.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence SQLSchema. En général, le code du développeur n’appelle pas directement le constructeur SQLSchema. Pour obtenir les informations du schéma d’une base de données, appelez la méthode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLSchema:database:get"><apiName>database</apiName><shortdesc>
     Nom de la base de données à laquelle cet objet de schéma appartient.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Nom de la base de données à laquelle cet objet de schéma appartient. Le nom est « main » pour la base de données principale associée à une occurrence SQLConnection (le fichier de bases de données est ouvert en appelant la méthode <codeph>open()</codeph> ou <codeph>openAsync()</codeph> d’une occurrence SQLConnection). Pour les autres bases de données associées à la connexion à l’aide de la méthode <codeph>SQLConnection.attach()</codeph>, la valeur est le nom spécifié dans l’appel de méthode <codeph>attach()</codeph>.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>flash.data.SQLConnection.attach()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchema:name:get"><apiName>name</apiName><shortdesc>
     Nom de cet objet de schéma.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Nom de cet objet de schéma. Dans une base de données, chaque objet porte un nom unique. Le nom est défini dans l’instruction SQL qui crée l’objet (telle que l’instruction <codeph>CREATE TABLE</codeph> pour une table).
	 
	 <p>Par exemple, si un index de base de données est créé avec l’instruction SQL suivante, la valeur de la propriété <codeph>name</codeph> du schéma de cet index est <codeph>« customer_index »</codeph> :</p>
	 
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLSchema:sql:get"><apiName>sql</apiName><shortdesc>
     Renvoie l’ensemble du texte de l’instruction SQL utilisée pour créer cet objet de schéma.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie l’ensemble du texte de l’instruction SQL utilisée pour créer cet objet de schéma. Chaque objet d’une base de données est créé par une instruction SQL.
	 
	 <p>Par exemple, si un index de base de données est créé par l’instruction SQL suivante :</p>
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
	 <p>la propriété <codeph>sql</codeph> de ce schéma d’index est l’ensemble du texte de l’instruction.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLCollationType"><apiName>SQLCollationType</apiName><shortdesc>
 Cette classe contient les constantes représentant les valeurs possibles pour le paramètre defaultCollationType du constructeur SQLColumnSchema, ainsi que la propriété SQLColumnSchema.defaultCollationType.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Cette classe contient les constantes représentant les valeurs possibles pour le paramètre <codeph>defaultCollationType</codeph> du constructeur SQLColumnSchema, ainsi que la propriété <codeph>SQLColumnSchema.defaultCollationType</codeph>.
 
 <p>Ces valeurs représentent les différents ordres de classement pouvant être spécifiés pour une colonne dans une table de la base de données. Un <i>ordre de classement</i> est une façon de trier et de comparer les données, par exemple en indiquant si la base de données fait la différence entre les caractères majuscules et minuscules.</p>
 
 <p>Pour plus d’informations sur la définition et l’utilisation des ordres de classement, consultez la section intitulée <xref href="../../localDatabaseSQLSupport.html#collate">« COLLATE »</xref> dans l’annexe <xref href="../../localDatabaseSQLSupport.html">Prise en charge de SQL dans les bases de données locales</xref>.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links><apiValue id="flash.data:SQLCollationType:BINARY"><apiName>BINARY</apiName><shortdesc>
     Indique que la colonne est définie pour utiliser la séquence d’interclassement BINARY.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indique que la colonne est définie pour utiliser la séquence d’interclassement <codeph>BINARY</codeph>. Un interclassement <codeph>SQLCollationType.BINARY</codeph> compare deux valeurs en fonction de leurs valeurs d’octets, quel que soit le codage du texte des caractères.
	 
	 <p>Lorsqu’un classement binaire est utilisé avec des valeurs de la classe de stockage <codeph>TEXT</codeph>, la base de données fait la différence entre les caractères minuscules et majuscules lors du tri et de la comparaison des valeurs de la colonne.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLCollationType:NO_CASE"><apiName>NO_CASE</apiName><shortdesc>
     Indique que la colonne est définie pour utiliser la séquence d’interclassement NOCASE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noCase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indique que la colonne est définie pour utiliser la séquence d’interclassement <codeph>NOCASE</codeph>. Un classement <codeph>SQLCollationType.NO_CASE</codeph> ignore la casse pour trier et comparer deux valeurs.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTransactionLockType"><apiName>SQLTransactionLockType</apiName><shortdesc>
 Cette classe contient les constantes représentant les valeurs potentielles du paramètre option de la méthode SQLConnection.begin().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Cette classe contient les constantes représentant les valeurs potentielles du paramètre <codeph>option</codeph> de la méthode <codeph>SQLConnection.begin()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links><apiValue id="flash.data:SQLTransactionLockType:DEFERRED"><apiName>DEFERRED</apiName><shortdesc>
     Spécifie l’option de transaction à verrouillage différé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>deferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie l’option de transaction à verrouillage différé. Une transaction à verrouillage différé n’obtient aucun verrouillage de la base de données tant que celle-ci n’a pas été accédée une première fois. Avec une transaction différée, le verrouillage n’est pas obtenu avant la première opération de lecture ou d’écriture.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:EXCLUSIVE"><apiName>EXCLUSIVE</apiName><shortdesc>
     Spécifie l’option de transaction à verrouillage exclusif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exclusive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie l’option de transaction à verrouillage exclusif. Une transaction verrouillée exclusivement obtient immédiatement le verrouillage de la base de données. Les autres objets SQLStatement qui s’exécutent sur la même base de données par l’intermédiaire d’un objet SQLConnection différent (dans la même application AIR ou dans une autre application) ne peuvent pas lire ou écrire des données dans la base de données.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:IMMEDIATE"><apiName>IMMEDIATE</apiName><shortdesc>
     Spécifie l’option de transaction à verrouillage immédiat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>immediate</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie l’option de transaction à verrouillage immédiat. Une transaction à verrouillage immédiat obtient immédiatement le verrouillage de la base de données. Les autres objets SQLStatement qui s’exécutent sur la même base de données par l’intermédiaire d’un objet SQLConnection différent (dans la même application AIR ou dans une autre application) peuvent lire les données de la base de données mais ne peuvent pas en écrire. Toutefois, dans le cas des autres connexions qui peuvent lire les données de la base de données, l’état initial des données de la base est identique à l’état de la base de données avant l’appel à la méthode <codeph>begin()</codeph> de l’occurrence SQLConnection de la transaction entrante. Toutes les modifications de données non engagées apportées à la transaction à verrouillage immédiat ne sont pas disponibles pour les autres connexions.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
 Une occurrence SQLSchemaResult contient les informations résultant d’un appel à la méthode SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une occurrence SQLSchemaResult contient les informations résultant d’un appel à la méthode <codeph>SQLConnection.loadSchema()</codeph>. Elle contient quatre propriétés Array qui gèrent les données de schéma demandées, sur la base des valeurs d’argument utilisées lors de l’appel à <codeph>SQLConnection.loadSchema()</codeph>.
 
 <p>Pour récupérer l’occurrence SQLSchemaResult d’un appel à <codeph>SQLConnection.loadSchema()</codeph>, appelez la méthode <codeph>getSchemaResult()</codeph> de l’occurrence SQLConnection. En général, le code du développeur ne crée pas directement d’occurrences SQLSchemaResult.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchemaResult:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
     Crée une occurrence SQLSchemaResult.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>tables</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau d’occurrences SQLTableSchema tel que spécifié dans la requête <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>views</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau d’occurrences SQLViewSchema tel que spécifié dans la requête <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau d’occurrences SQLIndexSchema tel que spécifié dans la requête <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>triggers</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau d’occurrences SQLTriggerSchema tel que spécifié dans la requête <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence SQLSchemaResult. En général, le code du développeur n’appelle pas directement le constructeur SQLSchemaResult. Pour obtenir les informations de schéma d’une base de données, appelez la méthode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLSchemaResult:indices:get"><apiName>indices</apiName><shortdesc>
     Tableau d’occurrences SQLIndexSchema demandé dans un appel à SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau d’occurrences SQLIndexSchema demandé dans un appel à <codeph>SQLConnection.loadSchema()</codeph>. Si les bases de données spécifiées ne contiennent pas d’indice ou si l’appel <codeph>loadSchema()</codeph> indique que les indices doivent être exclus du résultat, la propriété <codeph>indices</codeph> est un tableau vide (un tableau dont la propriété <codeph>length</codeph> est 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:tables:get"><apiName>tables</apiName><shortdesc>
     Tableau d’occurrences SQLTableSchema demandé dans un appel à SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau d’occurrences SQLTableSchema demandé dans un appel à <codeph>SQLConnection.loadSchema()</codeph>. Si les bases de données spécifiées ne contiennent pas de table ou si l’appel à <codeph>loadSchema()</codeph> indique que les tables doivent être exclues du résultat, la propriété <codeph>tables</codeph> est un tableau vide (un tableau dont la propriété <codeph>length</codeph> est 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:triggers:get"><apiName>triggers</apiName><shortdesc>
     Tableau d’occurrences SQLTriggerSchema demandé dans un appel à SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau d’occurrences SQLTriggerSchema demandé dans un appel à <codeph>SQLConnection.loadSchema()</codeph>. Si les bases de données spécifiées ne contiennent pas de déclencheur ou si l’appel à <codeph>loadSchema()</codeph> indique que les déclencheurs doivent être exclus du résultat, la propriété <codeph>triggers</codeph> est un tableau vide (un tableau dont la propriété <codeph>length</codeph> est 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:views:get"><apiName>views</apiName><shortdesc>
     Tableau d’occurrences SQLViewSchema demandé dans un appel à SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau d’occurrences SQLViewSchema demandé dans un appel à <codeph>SQLConnection.loadSchema()</codeph>. Si les bases de données spécifiées ne contiennent pas de vue ou si l’appel à <codeph>loadSchema()</codeph> indique que les vues doivent être exclues du résultat, la propriété <codeph>views</codeph> est un tableau vide (un tableau dont la propriété <codeph>length</codeph> est 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
 Une occurrence SQLConnection est utilisée pour gérer la création et la connexion à des fichiers d’une base de données SQL locale (bases de données locales).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une occurrence SQLConnection est utilisée pour gérer la création et la connexion à des fichiers d’une base de données SQL locale (bases de données locales).
 
 <p>La fonctionnalité de la classe SQLConnection appartient à plusieurs catégories :</p>
 
 <ul>
   <li><p>Un fichier d’une base de données SQL locale est créé ou ouvert en appelant la méthode <codeph>open()</codeph> ou la méthode <codeph>openAsync()</codeph>. Si le fichier de base de données n’existe pas, ces méthodes peuvent éventuellement le créer en ouvrant la connexion. Lorsque la connexion à la base de données est établie, une instruction SQL peut être créée et exécutée sur la base de données en créant une occurrence SQLStatement et en affectant l’occurrence SQLConnection à la propriété <codeph>sqlConnection</codeph> de l’occurrence SQLStatement.</p></li>
 
   <li><p>La classe SQLConnection fournit également l’état des instructions SQL, y compris un mécanisme permettant d’exécuter plusieurs instructions dans une transaction, avec les méthodes <codeph>begin()</codeph>, <codeph>commit()</codeph> et <codeph>rollback()</codeph>.</p></li>
 
   <li><p>La classe SQLConnection fournit un accès aux informations du schéma de base de données pour les bases de données connectées. Le schéma d’une base de données décrit les définitions de ses tables, colonnes, indices et déclencheurs. Reportez-vous à la méthode <codeph>loadSchema()</codeph> pour plus d’informations.</p></li>
 
   <li><p>La classe SQLConnection permet de chiffrer les bases de données à l’aide de AES avec CCM. Cela permet d’authentifier les données et d’en assurer la privacité. Pour chiffrer une base de données, une clé de 16 octets doit être spécifiée (à l’aide d’un ByteArray) lors de la création de la base de données. Cette clé peut être modifiée ultérieurement à l’aide de la méthode <codeph>SQLConnection.reencrypt()</codeph>. Le chiffrement ralentit les performances d’écriture et de lecture de la base de données. Le chiffrement est appliqué aux données stockées sur le disque, mais pas aux données temporaires mises en mémoire cache. Le chiffrement n’est <i>pas</i> pris en charge par les bases de données en mémoire.</p></li>
 
   <li><p>Une occurrence de SQLConnection peut être utilisée pour recevoir des notifications d’événement au niveau de la base de données et permettre de contrôler la configuration de tous les aspects d’une base de données, notamment la taille de la page de cache, l’annulation de processus et les options d’exécution des instructions.</p></li>
 </ul>
 
 <p>Une occurrence <codeph>SQLConnection</codeph> opère dans l’un des deux modes d’exécution distincts : asynchrone ou synchrone. Pour utiliser l’exécution synchrone, utilisez la méthode <codeph>open()</codeph> pour la connexion à la base de données principale de l’occurrence SQLConnection. Pour utiliser l’exécution asynchrone, utilisez la méthode <codeph>openAsync()</codeph> pour la connexion à la base de données principale de l’occurrence.</p>
 
 <p>Lorsque vous utilisez l’exécution asynchrone, vous utilisez des écouteurs d’événement ou une occurrence Responder pour déterminer le moment où une opération se termine ou échoue. Les opérations s’exécutant en arrière-plan plutôt que dans la thread de l’application principale, l’application continue à s’exécuter et à répondre aux interactions de l’utilisateur même pendant l’exécution des opérations de base de données.</p>
 
 <p>En mode d’exécution asynchrone, vous commencez une opération spécifique en appelant la méthode appropriée, et vous pouvez détecter la fin (ou l’échec) de l’opération en enregistrant un écouteur pour l’événement approprié. Chaque opération est associée à un événement qui se déclenche lorsque l’opération se termine avec succès. Par exemple, lorsqu’un appel de la méthode <codeph>openAsync()</codeph> se termine avec succès (lorsque la connexion à la base de données est établie), l’événement <codeph>open</codeph> se déclenche. Lorsqu’une opération échoue, un événement <codeph>error</codeph> est distribué. L’occurrence SQLError de la propriété <codeph>error</codeph> de l’objet SQLErrorEvent contient des informations sur l’erreur spécifique, y compris l’opération tentée et la raison de son échec.</p>
 
 <p>Lorsque vous utilisez une exécution synchrone, il n’est pas nécessaire d’enregistrer des écouteurs d’événement pour déterminer le moment où une opération se termine ou échoue. Pour identifier les erreurs, placez les instructions rejetant l’erreur dans un bloc <codeph>try..catch</codeph>. Les opérations synchrones s’exécutant dans la thread d’exécution principale, toutes les fonctionnalités de l’application (y compris l’actualisation de l’écran et les interactions avec la souris et le clavier) sont interrompues pendant l’exécution de la ou des opérations de base de données. Dans le cas d’opérations à exécution longue, cela peut entraîner une interruption notable de l’application.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link><link href="flash.events.xml#SQLEvent"><linktext>flash.events.SQLEvent</linktext></link><link href="flash.events.xml#SQLErrorEvent"><linktext>flash.events.SQLErrorEvent</linktext></link><link href="flash.errors.xml#SQLError"><linktext>flash.errors.SQLError</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_en"><linktext>Démarrage rapide : Utilisation asynchrone d’une base de données SQL locale (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_flash_en"><linktext>Démarrage rapide : Utilisation asynchrone d’une base de données SQL locale (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_html_en"><linktext>Démarrage rapide : Utilisation asynchrone d’une base de données SQL locale (HTML)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_en"><linktext>Démarrage rapide : Utilisation asynchrone d’une base de données SQL locale (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_flash_en"><linktext>Démarrage rapide : Utilisation asynchrone d’une base de données SQL locale (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_html_en"><linktext>Démarrage rapide : Utilisation asynchrone d’une base de données SQL locale (HTML)</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.UPDATE_update"><apiName>update</apiName><shortdesc>
 Distribué lorsque les données d’une table de l’une des bases de données connectées changent après une commande SQL UPDATE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.UPDATE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque les données d’une table de l’une des bases de données connectées changent après une commande SQL <codeph>UPDATE</codeph>. La modification des données peut résulter directement d’une instruction <codeph>UPDATE</codeph> exécutée par une occurrence SQLStatement, ou résulter indirectement du déclenchement d’un déclencheur en réponse à une exécution d’instruction.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.SCHEMA_schema"><apiName>schema</apiName><shortdesc>
 Distribué lorsque l’opération d’un appel de la méthode loadSchema() se termine avec succès et que les résultats du schéma sont prêts.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.SCHEMA</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’opération d’un appel de la méthode <codeph>loadSchema()</codeph> se termine avec succès et que les résultats du schéma sont prêts.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ROLLBACK_rollback"><apiName>rollback</apiName><shortdesc>
 Distribué lorsque une opération d’appel de la méthode rollback() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ROLLBACK</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>rollback()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.REENCRYPT_reencrypt"><apiName>reencrypt</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode reencrypt() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.REENCRYPT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>reencrypt()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/reencrypt()"><linktext>reencrypt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.OPEN_open"><apiName>open</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode openAsync() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.OPEN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>openAsync()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.INSERT_insert"><apiName>insert</apiName><shortdesc>
 Distribué lorsque les données d’une table de l’une des bases de données connectées changent après une commande SQL INSERT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.INSERT</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque les données d’une table de l’une des bases de données connectées changent après une commande SQL <codeph>INSERT</codeph>. La modification des données peut résulter directement de l’exécution d’une instruction <codeph>INSERT</codeph> par l’intermédiaire d’une occurrence SQLStatement, ou résulter indirectement du déclenchement d’un déclencheur en réponse à l’exécution d’une instruction.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Distribué lorsque l’une des opérations asynchrones de l’objet SQLConnection provoque une erreur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’une des opérations asynchrones de l’objet SQLConnection provoque une erreur. L’occurrence SQLErrorEvent déclenchée en tant qu’objet événement a une propriété <codeph>error</codeph> qui contient des informations sur l’opération tentée et sur la cause de l’échec.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DETACH_detach"><apiName>detach</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode detach() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DETACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>detach()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.DELETE_delete"><apiName>delete</apiName><shortdesc>
 Distribué lorsque les données d’une table de l’une des bases de données connectées changent après une commande SQL DELETE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.DELETE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque les données d’une table de l’une des bases de données connectées changent après une commande SQL <codeph>DELETE</codeph>. La modification des données peut résulter directement de l’exécution d’une instruction <codeph>DELETE</codeph> par une occurrence SQLStatement, ou résulter indirectement du déclenchement d’un déclencheur en réponse à l’exécution d’une instruction.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DEANALYZE_deanalyze"><apiName>deanalyze</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode deanalyze() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DEANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>deanalyze()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMMIT_commit"><apiName>commit</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode commit() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMMIT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>commit()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CLOSE_close"><apiName>close</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode close() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>close()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMPACT_compact"><apiName>compact</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode compact() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMPACT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>compact()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/compact()"><linktext>compact()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode cancel() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>cancel()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/cancel()"><linktext>cancel()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.BEGIN_begin"><apiName>begin</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode begin() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.BEGIN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>begin()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ATTACH_attach"><apiName>attach</apiName><shortdesc>
 Distribué lorsqu’une opération d’appel de la méthode attach() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ATTACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération d’appel de la méthode <codeph>attach()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ANALYZE_analyze"><apiName>analyze</apiName><shortdesc>
 Distribué lorsqu’une opération analyze() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération <codeph>analyze()</codeph> se termine avec succès.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLConnection:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
     Crée une occurrence SQLConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>si un constructeur est appelé à partir d’un sandbox extérieur à celui de l’application principale. 
      
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Crée une occurrence SQLConnection.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLConnection:addEventListener"><apiName>addEventListener</apiName><shortdesc>
     
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction d’écouteur qui traite l’événement. Cette fonction doit accepter un objet Event comme paramètre unique et ne rien renvoyer<ph platform="actionscript">, comme illustré ci-dessous :</ph><ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Le nom de cette fonction n’a aucune importance.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Ce paramètre s’applique aux objets d’affichage dans l’architecture de la liste d’affichage ActionScript 3.0, utilisés par le contenu SWF.</ph> <ph platform="actionscript">Détermine si l’écouteur est actif pendant la phase de capture ou pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, l’écouteur traite l’événement uniquement pendant la phase de capture et non pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>false</codeph>, l’écouteur traite l’événement uniquement pendant les phases cible et de propagation vers le haut. Pour écouter l’événement dans les trois phases, appelez <codeph>addEventListener</codeph> à deux reprises, une première fois en définissant <codeph>useCapture</codeph> sur <codeph>true</codeph>, puis une nouvelle fois en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Niveau de priorité de l’écouteur d’événement. La priorité est indiquée par un entier signé de 32 bits. Plus le nombre est élevé, plus la priorité est élevée. Tous les écouteurs dont la priorité correspond à <i>n</i> sont traités avant les écouteurs dotés de la priorité <i>n</i> -1. Les écouteurs dont la priorité est identique sont traités dans l’ordre où ils ont été ajoutés. La priorité par défaut est 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Détermine si la référence à l’écouteur est forte ou faible. Une référence forte (valeur par défaut) empêche le nettoyage de votre écouteur, Cela n’est pas le cas avec une référence faible. <p>Les fonctions de membres de niveau classe n’étant pas soumises au nettoyage, vous pouvez définir <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour ces fonctions. Si vous définissez <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour un écouteur correspondant à une fonction imbriquée interne, la fonction sera nettoyée et ne sera donc pas permanente. Si vous créez des références à la fonction interne (enregistrée dans une autre variable), celle-ci n’est pas nettoyée et reste permanente.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement. <ph platform="actionscript">Vous pouvez enregistrer les écouteurs d’événement dans tous les nœuds de la liste d’affichage pour un type spécifique d’événement, de phase et de priorité.</ph>
	
	<p platform="javascript">Le code JavaScript dans le moteur d’exécution AIR utilise cette méthode pour enregistrer des écouteurs d’événements définis par les API AIR. Pour d’autres événements JavaScript (tels que l’événement <codeph>onload</codeph> de l’objet <codeph>body</codeph> DOM), vous pouvez utiliser des techniques de gestion d’événements standard, comme vous le feriez pour le contenu exécuté dans le navigateur.</p>
	
	<p>Après l’enregistrement d’un écouteur d’événement, vous ne pouvez plus modifier sa priorité par d’autres appels de <codeph>addEventListener()</codeph>. Pour modifier la priorité d’un écouteur, vous devez d’abord appeler <codeph>removeListener()</codeph>. Vous pouvez ensuite réenregistrer l’écouteur avec le nouveau niveau de priorité. </p>
	
	<p>N’oubliez pas qu’une fois l’écouteur enregistré, tous les prochains appels de <codeph>addEventListener()</codeph> avec une valeur <codeph>type</codeph> ou <codeph>useCapture</codeph> différente entraîneront la création d’un autre enregistrement d’écouteur. <ph platform="actionscript">Si, par exemple, vous enregistrez un écouteur dans lequel la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, il écoute uniquement pendant la phase de capture. Si vous appelez <codeph>addEventListener()</codeph> à l’aide du même objet écouteur, mais en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>, vous obtenez deux écouteurs distincts : l’un qui écoute pendant la phase de capture et l’autre qui écoute pendant les phases cible et de propagation vers le haut (bubbling).</ph>
	</p>
	
	<p platform="actionscript">Il est impossible d’enregistrer un écouteur d’événement uniquement pour la phase cible ou la phase de propagation vers le haut. Ces deux phases sont associées pendant l’enregistrement car la propagation vers le haut s’applique uniquement aux ancêtres du nœud cible.</p>
	
	<p>Si vous n’avez plus besoin d’un écouteur d’événements, supprimez-le en appelant <codeph>removeEventListener()</codeph>, afin d’éviter tout problème de mémoire. Les écouteurs d’événement ne sont pas automatiquement supprimés de la mémoire, car le nettoyeur de mémoire ne supprime pas l’écouteur tant que l’objet de distribution existe (à moins que le paramètre <codeph>useWeakReference</codeph> ne soit défini sur <codeph>true</codeph>).</p>
		
	<p>Lors de la copie d’une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés ne sont pas pris en compte (si le nouveau nœud nécessite un écouteur d’événement, vous devez associer celui-ci après la création du nœud). Toutefois, si vous déplacez une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés la suivent.</p>
	
	
	<p platform="actionscript">Si un écouteur d’événement est enregistré sur un nœud alors qu’un événement est en cours de traitement sur ce nœud, l’écouteur n’est pas déclenché pendant la phase actuelle, mais il peut l’être pendant une phase ultérieure du flux d’événements, telle que la phase de propagation vers le haut (bubbling).</p>
	
	<p platform="actionscript">Si un écouteur d’événement est supprimé d’un nœud sur lequel un événement est en cours de traitement, il est cependant déclenché par les actions en cours. Une fois supprimé, l’écouteur d’événement n’est plus jamais appelé (à moins d’être réenregistré à des fins de traitement ultérieur). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:analyze"><apiName>analyze</apiName><shortdesc>
     Collecte des statistiques sur les indices de base de données et les stocke dans la base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque cette méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>resourceName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Nom de la base de données ou de la table dont les indices doivent être analysés. Si la ressource spécifiée est une table dont le nom est unique parmi toutes les bases de données associées, seul le nom de la table doit être spécifié. Toutefois, un nom de table peut être spécifié au format <codeph>[nom-base de données].[nom-table]</codeph> afin d’éviter toute ambiguïté lorsque le nom de la table n’est pas unique. Si le paramètre <codeph>resourceName</codeph> est <codeph>null</codeph> (par défaut), tous les indices de toutes les bases de données associées sont analysés.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>analyze</codeph> ou <codeph>error</codeph> est distribué lorsque l’exécution se termine.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Collecte des statistiques sur les indices de base de données et les stocke dans la base de données. Ces statistiques peuvent alors être utilisées par l’optimiseur de requêtes (la partie du moteur de base de données qui détermine le moyen le plus efficace pour exécuter chaque instruction). Les statistiques permettent à l’optimiseur de requêtes d’améliorer ses choix quant aux index ou indices à utiliser pour exécuter une requête particulière.
	 
	 <p>Si des indices ont été définis pour une base de données mais que la méthode <codeph>analyze()</codeph> n’a pas été appelée, l’exécution continue à utiliser ces indices pour exécuter les instructions. Toutefois, sans les informations statistiques supplémentaires générées par la méthode <codeph>analyze()</codeph>, il est possible que le moteur d’exécution ne choisisse pas l’index le plus efficace pour une requête particulière.</p>
	 
	 <p>Lorsque les données d’une table changent (après des instructions <codeph>INSERT</codeph>, <codeph>UPDATE</codeph> ou <codeph>DELETE</codeph>), les indices associés à cette table changent également. Les informations statistiques générées par la méthode <codeph>analyze()</codeph> ne sont pas mises à jour automatiquement. Par conséquent, après un grand nombre de changements de données, un appel à la méthode <codeph>analyze()</codeph> peut être bénéfique. L’avantage apporté par un appel à la méthode <codeph>analyze()</codeph> dépend toutefois de plusieurs facteurs : le nombre d’indices définis sur une table, le rapport entre le nombre de lignes modifiées et le nombre total de lignes de la table, la quantité de variations existant dans les données indexées de la table et l’importance de la différence entre les données modifiées et les données d’origine.</p>
     
     <p>Le paramètre <codeph>resourceName</codeph> indique si l’opération est exécutée sur les indices de toutes les bases de données attachées, d’une base de données spécifique ou d’une table spécifique.</p>
     
     <p>A chaque appel de cette méthode, toutes les données statistiques précédemment créées sont purgées et recréées pour la base de données ou la table spécifiée dans le paramètre <codeph>resourceName</codeph> (ou toutes les tables de toutes les bases de données connectées si <codeph>resourceName</codeph> est <codeph>null</codeph>). Cette méthode peut être appelée à tout moment lorsque que la connexion à la base de données est établie. L’opération <codeph>analyze()</codeph> et ses données statistiques ne sont pas incluses dans une transaction. Toutefois, il est préférable de ne pas appeler <codeph>analyze()</codeph> lorsqu’une transaction est en cours dans la base de données (la propriété <codeph>inTransaction</codeph><codeph> est true</codeph>). Cela est dû au fait que toutes les modifications de données, de schéma de table ou d’index exécutées dans la transaction mais non encore validées ne seront pas pris en compte par l’appel <codeph>analyze()</codeph> et les données d’<codeph>analyze()</codeph> seront obsolètes dès la validation de la transaction.</p>
     
     <p>Pour supprimer les données statistiques créées avec la méthode <codeph>analyze()</codeph>, utilisez la méthode <codeph>deanalyze()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:analyze_analyze"><apiName>analyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:analyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:attach"><apiName>attach</apiName><shortdesc>
     Ajoute une autre base de données à l’occurrence SQLConnection, en lui attribuant le nom spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque le paramètre <codeph>name</codeph> est une chaîne vide (<codeph>""</codeph>) ou <codeph>null</codeph>
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque la valeur spécifiée pour le paramètre <codeph>reference</codeph> n’est pas une occurrence de flash.filesystem.File
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque l’argument <codeph>encryptionKey</codeph> n’est pas <codeph>null</codeph> et sa propriété <codeph>length</codeph> n’est pas de 16 octets
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque le paramètre <codeph>reference</codeph> est <codeph>null</codeph> et l’argument <codeph>encryptionKey</codeph> n’est pas <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque l’occurrence de SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>) ; ou si une transaction est actuellement en cours (la propriété <codeph>inTransaction</codeph> est <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom utilisé pour identifier la nouvelle base de données attachée. Ce nom peut être utilisé dans les instructions SQL pour indiquer explicitement qu’une table appartient à la base de données spécifiée, lorsque le format <codeph>[nom-base de données].[nom-table]</codeph> est utilisé. Les noms « main » et « temp » sont réservés et ne peuvent pas être choisis.
     
     </apiDesc></apiParam><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Référence au fichier de base de données à associer (une occurrence flash.filesystem.File). Si la référence désigne un fichier qui n’existe pas, un nouveau fichier de base de données est créé ou une erreur est renvoyée selon la valeur spécifiée pour le paramètre <codeph>openMode</codeph> dans l’appel <codeph>open()</codeph> ou <codeph>openAsync()</codeph> qui effectuait la connexion à la base de données principale.
	 
     <p>Si la valeur du paramètre est <codeph>null</codeph>, une base de données en mémoire est créée et associée.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>attach</codeph> ou <codeph>error</codeph> est distribué lorsque l’exécution se termine.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>La clé de chiffrement pour le fichier de base de données. Si l’appel de <codeph>attach()</codeph> crée une base de données, celle-ci est chiffrée et la clé spécifiée est utilisée comme clé de chiffrement. Si l’appel joint une base de données chiffrée existante, la valeur doit correspondre à la clé de chiffrement de la base de données ; dans le cas contraire, une erreur se produit. Si la base de données actuellement jointe n’est pas chiffrée, ou pour créer une base de données non chiffrée, la valeur doit être <codeph>null</codeph> (valeur par défaut).
	 
	 <p>Pour qu’une clé de chiffrement soit valide, sa longueur doit être de 16 octets. Une base de données en mémoire ne peut pas être chiffrée ; par conséquent, ce paramètre doit être <codeph>null</codeph> lorsque la valeur du paramètre <codeph>reference</codeph> est <codeph>null</codeph>.</p>
	 
	 <p>Lorsque vous joignez une base de données chiffrée, si la clé de chiffrement fournie ne correspond pas à celle de la base de données, une exception est renvoyée. En mode d’exécution synchrone, une exception SQLError est renvoyée. En mode d’exécution asynchrone, un SQLErrorEvent est distribué et la propriété <codeph>error</codeph> de l’objet événement contient une occurrence de SQLError. Dans les deux cas, la propriété <codeph>errorID</codeph> de l’objet SQLError est 3138 (« Le fichier ouvert n’est pas un fichier de base de données »).</p>
	 
	 <p>Le paramètre <codeph>encryptionKey</codeph> est disponible à partir de la version 1.5 d’AIR.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute une autre base de données à l’occurrence SQLConnection, en lui attribuant le nom spécifié. L’association d’une base de données permet d’utiliser cette dernière dans les instructions SQL exécutées sur l’occurrence SQLConnection.
     
     <p>Si une base de données est déjà associée à l’aide du nom spécifié, un appel à <codeph>attach()</codeph> résulte en un événement <codeph>error</codeph>. Toutefois, la même base de données peut être associée plusieurs fois à l’aide de noms uniques. Au maximum, dix bases de données peuvent être associées à une même occurrence SQLConnection.</p>
     
     <p>Toute instruction SQL peut être exécutée sur une base de données connectée par la méthode <codeph>attach()</codeph> qui peut être exécutée sur la base de données principale (celle qui est connectée avec <codeph>open()</codeph> ou <codeph>openAsync()</codeph>). Une instruction SQL peut accéder aux tables de toute base de données associée à l’occurrence SQLConnection conjointe de l’instruction, y compris en accédant aux tables de plusieurs bases de données dans une même instruction. Lorsque le moteur d’exécution résout les noms de table en instruction, elle lance une recherche dans les bases de données de l’occurrence SQLConnection dans l’ordre dans lequel celles-ci ont été associées, en commençant par la base de données connectée à l’aide de la méthode <codeph>open()</codeph> ou <codeph>openAsync()</codeph>. Pour qualifier un nom de table de façon explicite, utilisez le nom de sa base de données (tel que spécifié dans le paramètre <codeph>name</codeph> de la méthode <codeph>attach()</codeph>) dans l’instruction.</p>
     
     <p>Pour supprimer une base de données associée à l’aide de la méthode <codeph>attach()</codeph>, utilisez la méthode <codeph>detach()</codeph>. A la fermeture de l’occurrence SQLConnection (par un appel à la méthode <codeph>close()</codeph>), toutes les bases de données associées sont dissociées.</p>
     
     <p>La base de données associée utilise le même mode d’exécution (synchrone ou asynchrone) que la base de données principale, selon si la base de données principale a été connectée à l’aide de la méthode <codeph>open()</codeph> ou <codeph>openAsync()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:attach_attach"><apiName>attach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:attach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:begin"><apiName>begin</apiName><shortdesc>
     Commence une transaction, dans laquelle toutes les instructions SQL exécutées sur la ou les bases de données de la connexion sont regroupées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque cette méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’option spécifiée n’est pas l’une des constantes <codeph>SQLTransactionLockType</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>option</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Indique la stratégie de verrouillage utilisée par la transaction. La valeur peut correspondre à l’une des constantes définies dans la classe SQLTransactionLockType :
     <ul>
        <li><codeph>SQLTransactionLockType.DEFERRED</codeph> indique que le verrouillage n’est pas effectif avant la première opération de lecture ou d’écriture.</li>
        <li><codeph>SQLTransactionLockType.EXCLUSIVE</codeph> indique que le verrouillage est effectif dès que possible, et qu’aucune autre occurrence SQLConnection ne peut lire ou écrire dans la base de données.</li>
        <li><codeph>SQLTransactionLockType.IMMEDIATE</codeph> indique que le verrouillage est effectif dès que possible, et que les autres occurrences SQLConnection peuvent lire mais pas écrire dans la base de données.</li>
     </ul>
	 <p>La valeur par défaut (<codeph>null</codeph>) équivaut à <codeph>SQLTransactionLockType.DEFERRED</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>begin</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Commence une transaction, dans laquelle toutes les instructions SQL exécutées sur la ou les bases de données de la connexion sont regroupées.
     
     <p>Par défaut, chaque instruction SQL est exécutée dans sa propre transaction et celle-ci se termine lorsque l’exécution de l’instruction réussit ou échoue. La création d’une transaction à l’aide de la méthode <codeph>begin()</codeph> entraîne la création d’une nouvelle transaction manuelle. A partir de ce point, toutes les instructions SQL exécutées sur l’occurrence SQLConnection le sont dans la transaction, et toutes les actions ou modifications exécutées par les instructions peuvent être validées (rendues permanentes) ou annulées en un seul lot.</p>
     
     <p>Les transactions imbriquées ne sont pas autorisées (les appels imbriqués à <codeph>begin()</codeph> sont ignorés). Pour terminer une transaction, appelez la méthode <codeph>commit()</codeph> ou <codeph>rollback()</codeph>, selon que les modifications apportées par les instructions de la transaction doivent devenir permanentes ou être annulées.</p>
	 
	 <p>Si la connexion à la base de données se ferme lorsqu’une transaction est en cours, AIR restaure automatiquement la transaction (remarque : pour AIR 1.1 et versions antérieures, une transaction en cours est automatiquement validée lorsqu’une connexion se ferme).</p>
     
     <p>Une transaction n’est pas limitée aux exécutions d’instructions dans une seule base de données, mais peut comprendre des instructions exécutées sur d’autres bases de données associées.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link><link href="flash.data.xml#SQLTransactionLockType"><linktext>flash.data.SQLTransactionLockType</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:begin_begin"><apiName>begin</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:begin_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:cancel"><apiName>cancel</apiName><shortdesc>
     Annule toutes les instructions SQL en cours d’exécution sur les bases de données connectées à l’occurrence SQLConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque cette méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>cancel</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Annule toutes les instructions SQL en cours d’exécution sur les bases de données connectées à l’occurrence SQLConnection. Cette méthode peut être utilisée pour interrompre des requêtes d’exécution longue ou des requêtes qui s’emballent.
     
     <p>Si des instructions s’exécutent lors de l’appel à <codeph>cancel()</codeph>, cette méthode annule les opérations des instructions et toutes les mises à jour ou transactions incomplètes sont annulées. Lorsque aucune instruction n’est en cours d’exécution, l’appel à cette méthode annule la transaction ouverte, sinon elle est sans effet.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:cancel_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:cancel_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:close"><apiName>close</apiName><shortdesc>
     Ferme la connexion à la base de données en cours.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>close</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ferme la connexion à la base de données en cours. Toutes les bases de données associées sont également dissociées.
     
     <p>Si une transaction est ouverte lors de l’appel à <codeph>close()</codeph>, la transaction est validée. Lorsqu’une occurrence SQLConnection est nettoyée, le moteur d’exécution appelle automatiquement <codeph>close()</codeph>, y compris si une application AIR est fermée alors qu’une occurrence SQLConnection est toujours connectée à une base de données.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:close_close"><apiName>close</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:close_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:commit"><apiName>commit</apiName><shortdesc>
     Valide une transaction existante, en rendant permanentes toutes les actions effectuées par ses instructions dans la base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque la méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>) ; ou si aucune transaction n’est actuellement ouverte (la propriété <codeph>inTransaction</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>commit</codeph> ou <codeph>error</codeph> est distribué lorsque l’exécution se termine.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Valide une transaction existante, en rendant permanentes toutes les actions effectuées par ses instructions dans la base de données.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:commit_commit"><apiName>commit</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:commit_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec un échec.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec un échec.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:compact"><apiName>compact</apiName><shortdesc>
     Récupère tout l’espace non utilisé dans la base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>) ; ou si une transaction est actuellement en cours (la propriété <codeph>inTransaction</codeph> est <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>compact</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Récupère tout l’espace non utilisé dans la base de données. Lorsqu’un objet (table, index ou déclencheur) est abandonné dans la base de données, il laisse un espace vide. Le fichier de bases de données est alors plus volumineux que nécessaire, mais cela peut accélérer les opérations <codeph>INSERT</codeph>. Avec le temps, les opérations <codeph>INSERT</codeph> et <codeph>DELETE</codeph> peuvent fragmenter la structure du fichier de la base de données, ce qui ralentit les accès disque au contenu de la base de données. Cette méthode compacte le fichier de base de données en éliminant les pages libres, en alignant les données de la table de façon contiguë et en nettoyant la structure du fichier de base de données.
     
     <p>L’opération <codeph>compact()</codeph> ne peut pas être exécutée sur un fichier d’une base de données associée, mais uniquement sur le fichier de la base de données principale (originale) ouvert par l’occurrence SQLConnection. Cette opération échoue si une transaction est active et n’a pas d’effet sur une base de données en mémoire.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:compact_compact"><apiName>compact</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:compact_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:deanalyze"><apiName>deanalyze</apiName><shortdesc>
     Supprime toutes les informations statistiques créées par un appel de la méthode analyze().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque cette méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>deanalyze</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Supprime toutes les informations statistiques créées par un appel de la méthode <codeph>analyze()</codeph>.
	 
	 <p>Les statistiques générées par la méthode <codeph>analyze()</codeph> occupant de l’espace dans une base de données, un appel à <codeph>deanalyze()</codeph> vous permet de récupérer cet espace, par exemple après l’abandon de plusieurs indices ou tables.</p>
     
     <p>Cette opération n’est pas incluse dans une transaction active.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:deanalyze_deanalyze"><apiName>deanalyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:deanalyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:detach"><apiName>detach</apiName><shortdesc>
     Dissocie une base de données supplémentaire précédemment associée à l’occurrence SQLConnection à l’aide de la méthode attach().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si l’argument <codeph>name</codeph> est <codeph>null</codeph> ou contient une chaîne vide (<codeph>""</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si cette méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>) ou si une transaction est actuellement ouverte dans l’occurrence SQLConnection (la propriété <codeph>inTransaction</codeph> est <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la base de données à dissocier.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>detach</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Dissocie une base de données supplémentaire précédemment associée à l’occurrence SQLConnection à l’aide de la méthode <codeph>attach()</codeph>. Il est possible d’associer le même fichier de base de données plusieurs fois à l’aide de noms différents et de dissocier une connexion à un fichier sans toucher aux autres connexions. Une base de données ne peut pas être dissociée si elle contient une transaction ouverte (si la propriété <codeph>inTransaction</codeph><codeph> est true</codeph>).
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:detach_detach"><apiName>detach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:detach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:getSchemaResult"><apiName>getSchemaResult</apiName><shortdesc>
     Permet d’accéder au résultat d’un appel à la méthode loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.data:SQLSchemaResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Permet d’accéder au résultat d’un appel à la méthode <codeph>loadSchema()</codeph>. La méthode <codeph>getSchemaResult()</codeph> se comporte comme une file d’attente de résultats premier entré-premier sorti. Chaque fois qu’un appel à la méthode <codeph>loadSchema()</codeph> se termine (chaque fois que l’événement <codeph>schema</codeph> est déclenché en mode d’exécution asynchrone), un nouvel objet SQLSchemaResult est ajouté à la file d’attente. Chaque fois que la méthode <codeph>getSchemaResult()</codeph> est appelée, le premier résultat (celui qui a été ajouté en premier à la file d’attente) est renvoyé et retiré de la file. Lorsqu’il ne reste plus aucun objet dans la file d’attente, <codeph>getSchemaResult()</codeph> renvoie <codeph>null</codeph>.
     
     <p>Lorsque la connexion à la base de données est fermée, la méthode renvoie <codeph>null</codeph>.</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>schéma</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLConnection:loadSchema"><apiName>loadSchema</apiName><shortdesc>
     Charge les informations de schéma depuis la base de données connectées ou depuis l’une des bases de données associées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque la méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque la valeur de l’argument <codeph>type</codeph> spécifié n’est pas l’un des types autorisés.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lors d’une utilisation en mode d’exécution synchrone, si une valeur non valide est fournie pour les paramètres name ou database.
	 
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiData>null</apiData><apiDesc>Indique le type de schéma à charger. Une valeur <codeph>null</codeph> (définie par défaut) indique que toutes les informations du schéma doivent être chargées. La définition d’une valeur non <codeph>null</codeph> pour ce paramètre limite l’étendue du schéma résultant, en supprimant les informations potentiellement inutiles des résultats et en rendant l’opération plus efficace. La valeur doit être le nom de l’une des classes suivantes :
	 <ul>
	     <li>SQLIndexSchema</li>
	     <li>SQLTableSchema</li>
	     <li>SQLTriggerSchema</li>
	     <li>SQLViewSchema</li>
	 </ul>
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Indique quel schéma de ressources est chargé. La manière dont cette valeur est utilisée dépend de l’argument <codeph>type</codeph> spécifié. En général, il s’agit du nom d’un objet de base de données, tel que le nom d’une table, d’un index ou d’une vue, etc. Lorsqu’une valeur est spécifiée, seules les informations du schéma de l’objet de base de données portant le nom spécifié sont incluses dans le résultat.
	 
	 <p>Si la valeur spécifiée n’est pas valide, un événement <codeph>error</codeph> est déclenché (ou une erreur est renvoyée en mode d’exécution synchrone). La valeur du paramètre <codeph>type</codeph> doit correspondre au type de l’objet nommé pour que la valeur soit valide, selon la description de la méthode.</p>
	 
	 <p>Si l’argument <codeph>name</codeph> est <codeph>null</codeph>, toutes les données de schéma du type spécifié sont incluses. Si la valeur spécifiée n’est pas valide, un événement <codeph>error</codeph> est déclenché.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>main</apiData><apiDesc>Nom de la base de données dont le schéma est chargé. Si la valeur spécifiée n’est pas valide, un événement <codeph>error</codeph> est déclenché.
     
     </apiDesc></apiParam><apiParam><apiItemName>includeColumnSchema</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Indique si le résultat comprend les informations du schéma des colonnes des tables et des vues.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>schema</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Charge les informations de schéma depuis la base de données connectées ou depuis l’une des bases de données associées. Le schéma indique la structure des tables, des colonnes, des indices et des déclencheurs de la base de données.
	 
     <p>Pour accéder au schéma chargé, utilisez la méthode <codeph>SQLConnection.getSchemaResult()</codeph>.</p>
	 
     <p>En mode d’exécution asynchrone, un événement <codeph>schema</codeph> est déclenché si l’opération réussit, ou un événement <codeph>error</codeph> est déclenché si elle échoue.</p>
	 
	 <p>La combinaison des valeurs des paramètres <codeph>type</codeph> et <codeph>name</codeph> détermine le type de données du schéma généré par la méthode <codeph>loadSchema()</codeph>, et par conséquent les valeurs des propriétés de l’occurrence SQLSchemaResult générées. Le tableau suivant présente la liste des paires <codeph>type</codeph> et <codeph>name</codeph> valides et les données de schéma générées en résultat :</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Argument <codeph>type</codeph></entry><entry>Argument <codeph>name</codeph></entry><entry>Récupère les données de schéma pour : </entry></row></thead><tbody><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>tous les objets de la base de données (tables, vues, déclencheurs et indices)</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>tous les indices de la base de données</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>nom de table valide</entry>
	     <entry>tous les indices définis dans la table spécifiée</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>nom d’index valide</entry>
	     <entry>index spécifié</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>toutes les tables de la base de données</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry>nom de table valide</entry>
	     <entry>la table spécifiée</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>tous les déclencheurs de la base de données</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>nom de table valide</entry>
	     <entry>tous les déclencheurs associés à la table spécifiée</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>nom de vue valide</entry>
	     <entry>tous les déclencheurs associés à la vue spécifiée </entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>nom de déclencheur valide</entry>
	     <entry>le déclencheur spécifié </entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>toutes les vues de la base de données</entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry>nom de vue valide</entry>
	     <entry>la vue spécifiée </entry>
	   </row></tbody></tgroup></adobetable>
	 
	 <p>Si la combinaison d’arguments <codeph>type</codeph> et <codeph>name</codeph> ne correspond pas à l’une des combinaisons spécifiées, un événement <codeph>error</codeph> est déclenché en mode d’exécution asynchrone ou une exception est renvoyée en mode d’exécution synchrone. Par exemple si l’argument <codeph>type</codeph> est <codeph>SQLViewSchema</codeph> et que l’argument <codeph>name</codeph> est le nom d’une table (au lieu de celui d’une vue), une erreur est renvoyée pour indiquer que la base de données ne contient pas d’objet présentant le type spécifié avec le nom spécifié.</p>
	 
	 <p>Si la base de données est vide (elle ne contient pas de table, ni de vue, ni de déclencheur, ni d’indice), l’appel de la méthode <codeph>loadSchema()</codeph> déclenche une erreur.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>getSchemaResult()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>schéma</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:loadSchema_schema"><apiName>schema</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:loadSchema_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec un échec.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec un échec.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:open"><apiName>open</apiName><shortdesc>
     Ouvre une connexion synchrone au fichier de base de données à l’emplacement spécifié dans le système de fichiers, crée et ouvre un nouveau fichier de base de données à cet emplacement, ou crée et ouvre une base de données en mémoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque l’occurrence SQLConnection a déjà une connexion établie avec une base de données (la propriété <codeph>connected</codeph> est <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue. La connexion ne résiste jamais à un échec d’opération.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque la valeur spécifiée pour le paramètre <codeph>reference</codeph> n’est pas une occurrence de flash.filesystem.File
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque l’argument <codeph>encryptionKey</codeph> n’est pas <codeph>null</codeph> et sa propriété <codeph>length</codeph> n’est pas de 16 octets
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque le paramètre <codeph>reference</codeph> est <codeph>null</codeph> et l’argument <codeph>encryptionKey</codeph> n’est pas <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si un paramètre <codeph>pageSize</codeph> non valide est spécifié. Cela comprend la transmission de la taille d’une page lorsque le mode est <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Emplacement du fichier de base de données ouvert. Cette valeur doit être une occurrence flash.filesystem.File. Si la valeur du paramètre est <codeph>null</codeph>, une base de données est créée en mémoire et ouverte.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Indique comment la base de données est ouverte. La valeur peut être l’une des constantes définies dans la classe SQLMode. La valeur par défaut est <codeph>SQLMode.CREATE</codeph> et indique que, si le fichier de base de données est introuvable à l’emplacement spécifié, il doit être créé. Si <codeph>openMode</codeph> est <codeph>SQLMode.READ</codeph> et que le fichier spécifié n’existe pas, un événement error est déclenché. Ce paramètre est ignoré lorsque le paramètre <codeph>reference</codeph> est <codeph>null</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si l’espace non utilisé dans la base de données est récupéré automatiquement. Ce paramètre n’est valide que pour la création d’un nouveau fichier de base de données ou pour l’ouverture d’un fichier de base de données dans lequel aucune table n’a été créée. Par défaut, l’espace récupéré lors de la suppression des données est conservé dans le fichier de base de données et réutilisé lorsque nécessaire. Si ce paramètre est défini sur <codeph>true</codeph>, la base de données récupère automatiquement l’espace non utilisé. Cela peut avoir un impact négatif sur les performances car un traitement supplémentaire est nécessaire à chaque opération d’écriture dans la base de données. De plus, les données de la base de données peuvent également se fragmenter avec le temps. Pour forcer la base de données à récupérer à tout moment l’espace non utilisé dans un fichier de base de données et à le défragmenter, utilisez la méthode <codeph>compact()</codeph>.
	 
	 <p>Ce paramètre est ignoré lorsque le paramètre <codeph>openMode</codeph> est <codeph>SQLMode.READ</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Indique la taille de la page (en octets) de la base de données. Ce paramètre n’est valide que pour la création d’un nouveau fichier de base de données ou pour l’ouverture d’un fichier de base de données dans lequel aucune table n’a été créée. La valeur doit être une puissance de deux supérieure ou égale à 512 et inférieure ou égale à 32768. La valeur par défaut est 1024 octets. Cette valeur ne peut être définie qu’avant la création des tables. Une fois que des tables ont été créées, la tentative de modification de cette valeur entraîne une erreur. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>La clé de chiffrement pour le fichier de base de données. Si l’appel de <codeph>open()</codeph> crée une base de données, celle-ci est chiffrée et la clé spécifiée est utilisée comme clé de chiffrement. Si l’appel ouvre une base de données chiffrée, la valeur doit correspondre à la clé de chiffrement de la base de données. Dans le cas contraire, une erreur se produit. Si la base de données en cours d’ouverture n’est pas chiffrée, ou si vous souhaitez créer une base de données non chiffrée, la valeur doit être <codeph>null</codeph> (valeur par défaut) ; dans le cas contraire, une erreur se produit.
	 
	 <p>Pour qu’une clé de chiffrement soit valide, sa longueur doit être de 16 octets. Une base de données en mémoire ne peut pas être chiffrée ; par conséquent, ce paramètre doit être <codeph>null</codeph> lorsque la valeur du paramètre <codeph>reference</codeph> est <codeph>null</codeph>.</p>
	 
	 <p>Lors de l’ouverture d’une base de données chiffrée, si la clé de chiffrement fournie ne correspond pas à celle de la base de données, une exception SQLError est renvoyée. Le cas échéant, la propriété <codeph>errorID</codeph> de l’objet SQLError est 3138 (« Le fichier ouvert n’est pas un fichier de base de données »).</p>
	 
	 <p>Le paramètre <codeph>encryptionKey</codeph> est disponible à partir de la version 1.5 d’AIR.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ouvre une connexion synchrone au fichier de base de données à l’emplacement spécifié dans le système de fichiers, crée et ouvre un nouveau fichier de base de données à cet emplacement, ou crée et ouvre une base de données en mémoire. Les opérations de création et d’ouverture de base de données, comme toutes les autres opérations exécutées avec cette occurrence SQLConnection (y compris l’exécution d’instructions et d’autres opérations exécutées par une occurrence SQLStatement associée à cette occurrence SQLConnection) sont exécutées de façon <i>synchrone</i> lorsque la base de données est ouverte avec cette méthode. Pour exécuter des opérations de façon asynchrone, ouvrez la connexion de la base de données à l’aide de la méthode <codeph>openAsync()</codeph>.
	 
	 <p>Après la connexion d’une base de données, utilisez une occurrence de <xref href="SQLStatement.html">SQLStatement</xref> pour exécuter les commandes SQL. Les opérations au niveau de la base de données, notamment le démarrage ou l’arrêt de transactions, ainsi que le chargement d’informations de schéma sont exécutées à l’aide de l’occurrence de SQLConnection.</p>
     
     <p>Une base de données connectée avec la méthode <codeph>open()</codeph> se voit automatiquement attribuer le nom de base de données « main ». Ce nom peut être utilisé pour qualifier explicitement les noms de table dans les instructions SQL qui utilisent le format <codeph>[nom-base de données].[nom-table]</codeph>. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:open_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:openAsync"><apiName>openAsync</apiName><shortdesc>
     Ouvre une connexion asynchrone au fichier de base de données à l’emplacement spécifié dans le système de fichiers, crée et ouvre un nouveau fichier de base de données à cet emplacement, ou crée et ouvre une base de données en mémoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque l’occurrence SQLConnection a déjà une connexion établie avec une base de données (la propriété <codeph>connected</codeph> est <codeph>true</codeph>).
     
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque la valeur spécifiée pour le paramètre <codeph>reference</codeph> n’est pas une occurrence de flash.filesystem.File
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque l’argument <codeph>encryptionKey</codeph> n’est pas <codeph>null</codeph> et sa propriété <codeph>length</codeph> n’est pas de 16 octets
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque le paramètre <codeph>reference</codeph> est <codeph>null</codeph> et l’argument <codeph>encryptionKey</codeph> n’est pas <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si un paramètre <codeph>pageSize</codeph> non valide est spécifié. Cela comprend la transmission de la taille d’une page lorsque le mode est <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Emplacement du fichier de base de données ouvert. Cette valeur doit être une occurrence flash.filesystem.File. Si la valeur du paramètre est <codeph>null</codeph>, une base de données est créée en mémoire et ouverte.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Indique comment la base de données est ouverte. La valeur peut être l’une des constantes définies dans la classe SQLMode. La valeur par défaut est <codeph>SQLMode.CREATE</codeph> et indique que, si le fichier de base de données est introuvable à l’emplacement spécifié, il doit être créé. Si <codeph>openMode</codeph> est <codeph>SQLMode.READ</codeph> et que le fichier spécifié n’existe pas, un événement error est déclenché. Ce paramètre est ignoré lorsque le paramètre <codeph>reference</codeph> est <codeph>null</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. Si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>open</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si l’espace non utilisé dans la base de données est récupéré automatiquement. Ce paramètre n’est valide que pour la création d’un nouveau fichier de base de données ou pour l’ouverture d’un fichier de base de données dans lequel aucune table n’a été créée. Par défaut, l’espace récupéré lors de la suppression des données est conservé dans le fichier de base de données et réutilisé lorsque nécessaire. Si ce paramètre est défini sur <codeph>true</codeph>, la base de données récupère automatiquement l’espace non utilisé. Cela peut avoir un impact négatif sur les performances car un traitement supplémentaire est nécessaire à chaque opération d’écriture dans la base de données. De plus, les données de la base de données peuvent également se fragmenter avec le temps. Pour forcer la base de données à récupérer à tout moment l’espace non utilisé dans un fichier de base de données et à le défragmenter, utilisez la méthode <codeph>compact()</codeph>.
	 
	 <p>Ce paramètre est ignoré lorsque le paramètre <codeph>openMode</codeph> est <codeph>SQLMode.READ</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Indique la taille de la page (en octets) de la base de données. Ce paramètre n’est valide que pour la création d’un nouveau fichier de base de données ou pour l’ouverture d’un fichier de base de données dans lequel aucune table n’a été créée. La valeur doit être une puissance de deux supérieure ou égale à 512 et inférieure ou égale à 32768. La valeur par défaut est 1024 octets. Cette valeur ne peut être définie qu’avant la création des tables. Une fois que des tables ont été créées, la tentative de modification de cette valeur entraîne une erreur. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>La clé de chiffrement pour le fichier de base de données. Si l’appel de <codeph>openAsync()</codeph> crée une base de données, celle-ci est chiffrée et la clé spécifiée est utilisée comme clé de chiffrement. Si l’appel ouvre une base de données chiffrée, la valeur doit correspondre à la clé de chiffrement de la base de données. Dans le cas contraire, une erreur se produit. Si la base de données en cours d’ouverture n’est pas chiffrée, la valeur doit être <codeph>null</codeph> (valeur par défaut). Dans le cas contraire, une erreur se produit.
	 
	 <p>Pour qu’une clé de chiffrement soit valide, sa longueur doit être de 16 octets. Une base de données en mémoire ne peut pas être chiffrée ; par conséquent, ce paramètre doit être <codeph>null</codeph> lorsque la valeur du paramètre <codeph>reference</codeph> est <codeph>null</codeph>.</p>
	 
	 <p>Lors de l’ouverture d’une base de données chiffrée, si la clé de chiffrement fournie ne correspond pas à celle de la base de données, une exception SQLErrorEvent est renvoyée. La propriété <codeph>error</codeph> de l’objet événement contient une occurrence de SQLError. La propriété <codeph>errorID</codeph> de l’objet SQLError est 3138 (« Le fichier ouvert n’est pas un fichier de base de données »).</p>
	 
	 <p>Le paramètre <codeph>encryptionKey</codeph> est disponible à partir de la version 1.5 d’AIR.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ouvre une connexion asynchrone au fichier de base de données à l’emplacement spécifié dans le système de fichiers, crée et ouvre un nouveau fichier de base de données à cet emplacement, ou crée et ouvre une base de données en mémoire. Les opérations de création et d’ouverture de base de données, comme toutes les autres opérations exécutées avec cette occurrence SQLConnection (y compris l’exécution d’instructions et d’autres opérations exécutées par une occurrence SQLStatement associée à cette occurrence SQLConnection) sont exécutées de façon <i>asynchrone</i> lorsque la base de données est ouverte avec cette méthode. Pour exécuter des opérations de façon synchrone, ouvrez la connexion de la base de données à l’aide de la méthode <codeph>open()</codeph>.
     
	 <p>Après la connexion d’une base de données, utilisez une occurrence de <xref href="SQLStatement.html">SQLStatement</xref> pour exécuter les commandes SQL. Les opérations au niveau de la base de données, notamment le lancement ou la finalisation de transactions, ainsi que le chargement d’informations de schéma sont exécutées à l’aide de l’occurrence de SQLConnection.</p>
     
     <p>Une base de données connectée avec la méthode <codeph>openAsync()</codeph> se voit automatiquement attribuer le nom de base de données « main ». Ce nom peut être utilisé pour qualifier explicitement les noms de table dans les instructions SQL utilisant le format <codeph>[nom-base de données].[nom-table]</codeph>. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:openAsync_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:openAsync_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue. La connexion ne résiste jamais à un échec d’opération.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:reencrypt"><apiName>reencrypt</apiName><shortdesc>
	 Modifie la clé de chiffrement d’une base de donnée chiffrée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque la valeur de <codeph>newEncryptionKey</codeph> est <codeph>null</codeph> ou si sa propriété <codeph>length</codeph> n’est pas de 16 octets.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque la connexion n’est pas ouverte ou si une transaction est ouverte.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newEncryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Un ByteArray contenant la nouvelle clé de chiffrement de la base de données. Pour qu’une clé de chiffrement soit valide, sa longueur doit être de 16 octets. 
	 
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. Si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>reencrypt</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Modifie la clé de chiffrement d’une base de donnée chiffrée. Cette méthode affecte uniquement la clé de chiffrement de la base de données principale (c’est-à-dire la base de données connectée à l’aide de la méthode <codeph>open()</codeph> ou <codeph>openAsync()</codeph>). Vous pouvez appeler <codeph>reencrypt()</codeph> uniquement sur une base de données ayant été chiffrée lors de sa création. Après avoir créé une base de données chiffrée, il est impossible de la déchiffrer. De la même manière, si une base de données non chiffrée est créée, celle-ci ne peut pas être chiffrée ultérieurement.
	 
	 <p>La nouvelle tentative de chiffrement est exécutée dans sa propre transaction. Si la nouvelle tentative de chiffrement est interrompue, la base de données restaure la transaction et la clé de chiffrement reste inchangée.</p> 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:reencrypt_reencrypt"><apiName>reencrypt</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:reencrypt_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:removeEventListener"><apiName>removeEventListener</apiName><shortdesc>
     
	Supprime un écouteur de l’objet EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Objet écouteur à supprimer.
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Ce paramètre s’applique aux objets d’affichage dans l’architecture de la liste d’affichage ActionScript 3.0, utilisés par le contenu SWF.</ph><ph platform="actionscript">Indique si l’écouteur a été enregistré pendant la phase de capture ou pendant les phases cible et de propagation vers le haut (bubbling). Si l’écouteur a été enregistré pendant la phase de capture et pendant les phases cible et de propagation vers le haut (bubbling), il est nécessaire d’appeler <codeph>removeEventListener()</codeph> à deux reprises pour le supprimer. Appelez <codeph>useCapture()</codeph> une première fois en la définissant sur <codeph>true</codeph>, puis une seconde fois <codeph>useCapture()</codeph> en la définissant sur <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Supprime un écouteur de l’objet EventDispatcher. Si aucun écouteur correspondant n’est enregistré auprès de l’objet EventDispatcher, l’appel de cette méthode n’a aucun effet.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:rollback"><apiName>rollback</apiName><shortdesc>
     Annule une transaction existante créée avec la méthode begin(), ce qui signifie que toutes les modifications apportées à la transaction par les instructions SQL sont annulées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque la méthode est appelée alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>) ; ou si aucune transaction n’est actuellement ouverte (la propriété <codeph>inTransaction</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>rollback</codeph> ou <codeph>error</codeph> est distribué à la fin de l’exécution.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Annule une transaction existante créée avec la méthode <codeph>begin()</codeph>, ce qui signifie que toutes les modifications apportées à la transaction par les instructions SQL sont annulées.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:rollback_rollback"><apiName>rollback</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération se termine avec succès.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération se termine avec succès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:rollback_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLConnection:autoCompact:get"><apiName>autoCompact</apiName><shortdesc>
     Indique si l’auto-compactage était activé lors de la création de la base de données en cours (valeur spécifiée pour le paramètre autoCompact dans l’appel à open() ou openAsync() qui a créé la base de données).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’auto-compactage était activé lors de la création de la base de données en cours (valeur spécifiée pour le paramètre <codeph>autoCompact</codeph> dans l’appel à <codeph>open()</codeph> ou <codeph>openAsync()</codeph> qui a créé la base de données). Si cette propriété est <codeph>true</codeph>, l’espace non utilisé est automatiquement supprimé du fichier de base de données après chaque opération d’écriture, ce qui réduit la taille du fichier. Si la propriété est <codeph>false</codeph>, l’espace précédemment occupé par les données supprimées est conservé dans le fichier de base de données et réutilisé lorsque nécessaire. Même lorsque <codeph>autoCompact</codeph> est <codeph>false</codeph>, vous pouvez forcer la base de données à récupérer l’espace non utilisé en appelant la méthode <codeph>compact()</codeph>.
     
     <p>Si la propriété <codeph>connected</codeph> est <codeph>false</codeph>, cette propriété est définie sur <codeph>false</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:cacheSize:get"><apiName>cacheSize</apiName><shortdesc>
     Permet d’accéder à la taille du cache de cette connexion, représentant le nombre maximal de pages de disque de base de données pouvant être conservé en mémoire simultanément.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Lors d’une tentative de définition de cette propriété alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>) ou si une transaction est actuellement en cours (la propriété <codeph>inTransaction</codeph> est <codeph>true</codeph>).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Permet d’accéder à la taille du cache de cette connexion, représentant le nombre maximal de pages de disque de base de données pouvant être conservé en mémoire simultanément. Chaque page utilise environ 1,5 Ko de mémoire (selon la valeur spécifiée pour le paramètre <codeph>pageSize</codeph> de l’appel de la méthode <codeph>open()</codeph> ou <codeph>openAsync()</codeph> qui a créé la base de données). La taille par défaut est 2 000. Si une application exécute des opérations <codeph>UPDATE</codeph> ou <codeph>DELETE</codeph> qui modifient un grand nombre de lignes d’une base de données, l’augmentation de la taille du cache peut améliorer la vitesse, mais accroît la consommation de mémoire.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:columnNameStyle:get"><apiName>columnNameStyle</apiName><shortdesc>
     Indique comment les noms de colonne sont reportés dans le résultat d’une instruction SELECT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Lors d’une tentative de définition de cette propriété alors que l’occurrence SQLConnection n’est pas connectée à une base de données (la propriété <codeph>connected</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Indique comment les noms de colonne sont reportés dans le résultat d’une instruction <codeph>SELECT</codeph>.
     
     <p>Les constantes définies dans la classe SQLColumnNameStyle représentent les valeurs possibles pour cette propriété :</p>
     
     <ul>
         <li><codeph>SQLColumnNameStyle.LONG</codeph> indique que les noms de colonne sont renvoyés au format <codeph>[nom-table]_[nom-colonne]</codeph>.</li>
         <li><codeph>SQLColumnNameStyle.SHORT</codeph> spécifie que les noms de colonne sont donnés au format <codeph>[nom-colonne]</codeph>. Si plusieurs colonnes portent le même nom, une seule propriété portant ce nom est ajoutée à l’objet de résultats.</li>
         <li><codeph>SQLColumnNameStyle.DEFAULT</codeph> est la valeur par défaut. Lorsque cette valeur est utilisée, les noms de colonne du résultat sont mis en forme en fonction du nombre de tables portant des noms de colonnes similaires dans l’instruction <codeph>SELECT</codeph>. Si l’instruction <codeph>SELECT</codeph> ne comprend qu’une table, le format de nom court <codeph>[nom-colonne]</codeph> est utilisé, et si l’instruction <codeph>SELECT</codeph> contient plusieurs tables réunies, le format de nom long <codeph>[nom-table]_[nom-colonne]</codeph> est utilisé chaque fois que le nom de deux colonnes est identique.</li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnNameStyle"><linktext>flash.data.SQLColumnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:connected:get"><apiName>connected</apiName><shortdesc>
     Indique si l’occurrence SQLConnection a une connexion établie avec un fichier de base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’occurrence SQLConnection a une connexion établie avec un fichier de base de données.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:inTransaction:get"><apiName>inTransaction</apiName><shortdesc>
	 Indique si cette connexion est actuellement impliquée dans une transaction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si cette connexion est actuellement impliquée dans une transaction.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     Dernier identifiant généré par une instruction SQL INSERT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Dernier identifiant généré par une instruction SQL <codeph>INSERT</codeph>. Un identifiant de ligne est utilisé pour identifier de façon unique une ligne d’une table de la base de données. La valeur est fréquemment générée par la base de données.
	 
     <p>La valeur est zéro si aucune base de données n’est connectée ou si aucune instruction <codeph>INSERT</codeph> n’a été exécutée.</p>
	 
	 <p>L’identifiant de ligne d’une seule exécution d’instruction SQL <codeph>INSERT</codeph> peut être obtenu par la propriété <codeph>lastInsertRowID</codeph> de l’objet SQLResult renvoyé par la méthode <codeph>getResult()</codeph> de l’objet SQLStatement (lorsqu’elle est appelée après que SQLStatement déclenche son événement <codeph>result</codeph>).</p>
	 
	 <p>Pour plus d’informations sur les clés primaires et les identifiants de ligne générés, consultez les sections « <xref href="../../localDatabaseSQLSupport.html#createTable">CREATE TABLE</xref> » et « <xref href="../../localDatabaseSQLSupport.html#expressions">Expressions</xref> » à l’annexe « <xref href="../../localDatabaseSQLSupport.html">Prise en charge de SQL dans les bases de données locales</xref> ».</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/lastInsertRowID"><linktext>flash.data.SQLResult.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:pageSize:get"><apiName>pageSize</apiName><shortdesc>
     Indique la taille de la page de base de données (en octets) spécifiée lors de la création de la base de données en cours (valeur spécifiée pour le paramètre pageSize dans l’appel à open() ou openAsync() qui a créé la base de données).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Indique la taille de la page de base de données (en octets) spécifiée lors de la création de la base de données en cours (valeur spécifiée pour le paramètre <codeph>pageSize</codeph> dans l’appel à <codeph>open()</codeph> ou <codeph>openAsync()</codeph> qui a créé la base de données).
     
     <p>Si la propriété <codeph>connected</codeph> est <codeph>false</codeph>, la valeur de cette propriété est 0.</p>
     
	 <p>La taille de la page d’une base de données peut être modifiée (à l’aide des méthodes <codeph>open()</codeph> ou <codeph>openAsync()</codeph>) jusqu’à la création de la première table dans la base de données.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:totalChanges:get"><apiName>totalChanges</apiName><shortdesc>
     Contient le nombre total de modifications de données effectuées depuis l’ouverture de la connexion à la base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Contient le nombre total de modifications de données effectuées depuis l’ouverture de la connexion à la base de données. En plus du suivi des modifications effectuées par les instructions <codeph>INSERT</codeph>, <codeph>DELETE</codeph> et <codeph>UPDATE</codeph>, cette valeur comprend les modifications dues aux déclencheurs.
	 
	 <p>Lorsque la connexion à la base de données est fermée, la valeur est réinitialisée sur 0. Lorsque l’occurrence SQLConnection n’est pas connectée à un fichier de base de données, la valeur est 0.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/rowsAffected"><linktext>flash.data.SQLResult.rowsAffected</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
 Une occurrence SQLTriggerSchema fournit des informations décrivant un déclencheur spécifique dans une base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une occurrence SQLTriggerSchema fournit des informations décrivant un déclencheur spécifique dans une base de données. Elle contient le nom du déclencheur (propriété <codeph>name</codeph>), le nom de la table associée (propriété <codeph>table</codeph>) et l’instruction SQL utilisée pour créer le déclencheur (propriété <codeph>sql</codeph>).
 
 <p>Pour obtenir les informations du schéma des déclencheurs d’une base de données, utilisez la méthode <codeph>SQLConnection.loadSchema()</codeph> pour charger les informations du schéma, en vous assurant d’utiliser <codeph>null</codeph> ou <codeph>SQLTriggerSchema</codeph> comme valeur de l’argument <codeph>type</codeph>. Dans l’occurrence SQLSchemaResult résultante, la propriété <codeph>triggers</codeph> contient un tableau d’occurrences SQLTriggerSchema représentant les déclencheurs de la base de données.</p>
 
 <p>En général, le code du développeur ne construit pas directement d’occurrences SQLTriggerSchema.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLTriggerSchema:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
     Crée une occurrence SQLTriggerSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la base de données associée.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom du déclencheur.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Instruction SQL utilisée pour créer le déclencheur.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom du déclencheur de la table associée.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence SQLTriggerSchema. En général, le code du développeur n’appelle pas directement le constructeur SQLTriggerSchema. Pour obtenir les informations du schéma d’une base de données, appelez la méthode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLTriggerSchema:table:get"><apiName>table</apiName><shortdesc>
     Nom de la table dans laquelle ce déclencheur est défini ou le nom de la vue si le déclencheur est défini dans une vue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Nom de la table dans laquelle ce déclencheur est défini ou le nom de la vue si le déclencheur est défini dans une vue.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
 Une occurrence SQLStatement permet d’exécuter une instruction SQL sur une base de données SQL locale ouverte par une occurrence SQLConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une occurrence SQLStatement permet d’exécuter une instruction SQL sur une base de données SQL locale ouverte par une occurrence SQLConnection.
 
 <p>Une occurrence SQLStatement est reliée à une occurrence SQLConnection en définissant l’occurrence SQLConnection comme valeur de la propriété <codeph>sqlConnection</codeph> de l’occurrence SQLStatement. La propriété <codeph>text</codeph> est renseignée par le véritable texte de l’instruction SQL à exécuter. Si nécessaire, les valeurs des paramètres de l’instruction SQL sont spécifiées à l’aide de la propriété <codeph>parameters</codeph>, et l’instruction est exécutée par un appel à la méthode <codeph>execute()</codeph>.</p>
 
 <p>Pour obtenir une description complète du dialecte SQL pris en charge par les bases de données SQL locales, consultez l’annexe <xref href="../../localDatabaseSQLSupport.html">Prise en charge de SQL dans les bases de données locales</xref>.</p>
 
 <p>En mode d’exécution asynchrone, les méthodes <codeph>execute()</codeph> et <codeph>next()</codeph> sont exécutées en arrière-plan et l’exécution distribue des événements vers les écouteurs d’événements enregistrés ou vers une occurrence Responder spécifiée lorsque les opérations sont terminées ou échouent. En mode synchrone, les méthodes sont exécutées sur la thread principale de l’application, ce que signifie que aucun autre code ne s’exécute tant que les opérations de la base de données ne sont pas terminées. De plus, en mode synchrone, si la méthode échoue, l’exécution renvoie une exception au lieu de déclencher un événement d’erreur.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection"><linktext>flash.data.SQLConnection</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Distribué lorsqu’une erreur se produit au cours d’une opération.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une erreur se produit au cours d’une opération.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLEvent.RESULT_result"><apiName>result</apiName><shortdesc>
 Distribué lorsque l’opération d’un appel de méthode execute() ou next() se termine avec succès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.RESULT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’opération d’un appel de méthode <codeph>execute()</codeph> ou <codeph>next()</codeph> se termine avec succès. Une fois que l’événement <codeph>result</codeph> est déclenché, la méthode <codeph>getResult()</codeph> peut être appelée pour récupérer les résultats de l’instruction.
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLStatement:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
     Crée une occurrence SQLStatement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Si le constructeur est appelé à partir d’un sandbox extérieur au sandbox de l’application principale. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Crée une occurrence SQLStatement.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLStatement:cancel"><apiName>cancel</apiName><shortdesc>
     Annule l’exécution de cette instruction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Annule l’exécution de cette instruction. Comme <codeph>SQLConnection.cancel()</codeph>, cette méthode est utilisée pour interrompre une requête d’exécution longue ou pour annuler une requête qui n’est pas encore terminée. Toutefois, contrairement à <codeph>SQLConnection.cancel()</codeph>, cette méthode n’annule que la seule instruction. Si l’instruction n’est pas en cours d’exécution, l’appel à cette méthode ne donne rien.
	 
	 <p>Aucun événement n’est déclenché en réponse directe à l’achèvement de l’opération <codeph>cancel()</codeph>. Toutefois, une fois que l’opération <codeph>cancel()</codeph> est terminée et que l’exécution de l’instruction est annulée, l’occurrence SQLStatement déclenche un événement <codeph>error</codeph> qui indique que l’exécution de l’instruction (l’appel <codeph>execute()</codeph> ou <codeph>next()</codeph>) ne s’est pas terminée. Alternativement, si une valeur a été spécifiée pour le paramètre <codeph>responder</codeph> de l’appel <codeph>execute()</codeph> ou <codeph>next()</codeph>, la méthode du gestionnaire de fautes spécifiée est appelée. Dans les deux cas, l’occurrence SQLError transmise aux écouteurs présente une propriété <codeph>errorID</codeph> avec la valeur 3118 (Opération annulée).</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLStatement:clearParameters"><apiName>clearParameters</apiName><shortdesc>
     Efface tous les paramètres actuels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Efface tous les paramètres actuels.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/parameters"><linktext>paramètres</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:execute"><apiName>execute</apiName><shortdesc>
     Exécute l’instruction SQL de la propriété text sur la base de données connectée à l’objet SQLConnection dans la propriété sqlConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la propriété <codeph>text</codeph> est <codeph>null</codeph> ou contient une chaîne vide (<codeph>""</codeph>) ; si la propriété <codeph>sqlConnection</codeph> n’est pas définie ; si l’occurrence SQLConnection affectée à la propriété <codeph>sqlConnection</codeph> n’est pas connectée ; ou si l’instruction est en cours d’exécution.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’opération échoue en mode d’exécution synchrone.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Lorsque la propriété <codeph>text</codeph> de l’instruction est une instruction <codeph>SELECT</codeph>, cette valeur indique le nombre de lignes renvoyées en une seule fois par l’instruction. La valeur par défaut est -1, indiquant que toutes les lignes du résultat sont renvoyées en une seule fois. Ce paramètre est utilisé en combinaison avec la méthode <codeph>next()</codeph> pour diviser les grands jeux de résultats en jeux de données plus petits. L’utilisateur peut ainsi mieux percevoir les performances de l’application car les résultats initiaux sont renvoyés plus rapidement et que les opérations de traitement des résultats sont divisées.
     
     <p>Lorsque l’instruction SQL est une requête <codeph>SELECT</codeph> et qu’un argument <codeph>prefetch</codeph> supérieur à zéro est spécifié, l’instruction est censée s’exécuter jusqu’à ce que l’ensemble du jeu de résultats soit renvoyé ou que la méthode <codeph>SQLStatement.cancel()</codeph> ou <codeph>SQLConnection.cancel()</codeph> soit appelée. Notez que, le nombre de lignes du jeu de résultats étant inconnu au moment de l’exécution, le curseur de la base de données doit se déplacer au-delà de la dernière ligne du jeu de résultats pour que l’instruction soit considérée comme terminée. Lorsqu’un argument <codeph>prefetch</codeph> est spécifié dans un appel <codeph>execute()</codeph>, au moins une ligne de plus que le nombre total de lignes du jeu de résultats doit être demandée (par l’intermédiaire d’une valeur <codeph>prefetch</codeph> supérieure au nombre de lignes du jeu de résultats, ou par l’intermédiaire d’appels consécutifs à la méthode <codeph>next()</codeph>) avant que la valeur de la propriété <codeph>complete</codeph> de l’occurrence SQLResult résultante soit <codeph>true</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>result</codeph> ou <codeph>error</codeph> est distribué lorsque l’exécution se termine.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Exécute l’instruction SQL de la propriété <codeph>text</codeph> sur la base de données connectée à l’objet SQLConnection dans la propriété <codeph>sqlConnection</codeph>.
     
	 <p>En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> n’est pas <codeph>null</codeph>, l’objet Responder spécifié indique les méthodes appelées pour gérer les résultats de l’opération. Si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>result</codeph> est distribué si l’opération est réussie, ou un événement <codeph>error</codeph> si l’opération échoue.</p>
	 
	 <p>Pour accéder aux résultats d’une instruction, notamment aux lignes de résultats d’une instruction <codeph>SELECT</codeph> ou à la clé primaire générée via la base de données d’une instruction <codeph>INSERT</codeph>, appelez la  méthode <codeph>getResult()</codeph>. Ces résultats sont disponibles immédiatement après l’exécution de l’instruction en mode synchrone et lors de la distribution de l’événement <codeph>result</codeph> en mode asynchrone.</p>
     
     <p>Chaque instruction doit être préparée (compilée) avant de pouvoir être exécutée. Lors du premier appel de la méthode <codeph>execute()</codeph> de l’occurrence SQLStatement, l’instruction est préparée par le moteur d’exécution. Une fois qu’une instruction est préparée, elle n’a pas besoin de l’être à nouveau sauf si la propriété <codeph>text</codeph> change. La définition d’une ou plusieurs valeurs de paramètres n’entraîne pas la nécessité de préparer de nouveau l’instruction.</p>
	 
     </apiDesc><example conref="examples\SQLStatement.execute.1.as"> L’exemple suivant démontre l’exécution d’une occurrence SQLStatement, avec des écouteurs d’événements pour déterminer le moment où l’exécution de l’instruction se termine ou échoue.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example><example conref="examples\SQLStatement.execute.2.as"> L’exemple suivant illustre l’exécution d’une occurrence de SQLStatement, avec un objet Responder pour indiquer quelles fonctions sont appelées lorsque l’exécution de l’instruction se termine ou échoue.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;
var employeeResponder:Responder;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    employeeResponder = new Responder(resultHandler, errorHandler);
    dbStatement.execute(-1, employeeResponder);
}

function resultHandler(result:SQLResult):void
{
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(error:SQLError):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:execute_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’exécution de l’instruction se termine avec succès ou lorsqu’une valeur d’argument <codeph>prefetch</codeph> est spécifiée et qu’une instruction <codeph>SELECT</codeph> renvoie une ou plusieurs lignes de données.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’exécution de l’instruction se termine avec succès ou lorsqu’une valeur d’argument prefetch est spécifiée et qu’une instruction SELECT renvoie une ou plusieurs lignes de données.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:execute_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLStatement:getResult"><apiName>getResult</apiName><shortdesc>
     Permet d’accéder à un objet SQLResult contenant les résultats de l’exécution de l’instruction, y compris les lignes de résultat d’une instruction SELECT et d’autres informations sur l’exécution de toutes les instructions exécutées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet SQLResult contenant le résultat d’un appel à la méthode <codeph>execute()</codeph> ou <codeph>next()</codeph>.
     
     </apiDesc><apiOperationClassifier>flash.data:SQLResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Permet d’accéder à un objet SQLResult contenant les résultats de l’exécution de l’instruction, y compris les lignes de résultat d’une instruction <codeph>SELECT</codeph> et d’autres informations sur l’exécution de toutes les instructions exécutées. En mode d’exécution asynchrone, les informations de résultat ne sont pas disponibles avant le déclenchement de l’événement <codeph>result</codeph>.
     
     <p>Lorsqu’une instruction <codeph>SELECT</codeph> est exécutée, si la méthode <codeph>execute()</codeph> est appelée avec l’argument <codeph>prefetch</codeph> par défaut défini sur -1, l’objet SQLResult renvoyé contient l’ensemble du jeu de résultats de la requête.</p>
     
     <p>Lorsqu’un argument <codeph>prefetch</codeph> est spécifié pour un appel de méthode <codeph>execute()</codeph> ou <codeph>next()</codeph>, la méthode <codeph>getResult()</codeph> se comporte comme une file d’attente de résultats premier arrivé-premier sorti. Chaque fois que l’événement <codeph>result</codeph> est distribué, un nouvel objet SQLResult est ajouté à la file d’attente. Chaque fois que la méthode <codeph>getResult()</codeph> est appelée, le premier objet SQLResult (celui qui a été ajouté le premier à la file d’attente) est renvoyé et supprimé de la file. Lorsqu’il ne reste plus aucun objet SQLResult dans la file d’attente, <codeph>getResult()</codeph> renvoie <codeph>null</codeph>.</p>
	 
	 <p>Notez qu’à moins d’être supprimés par un appel de <codeph>getResult()</codeph>, les objets SQLResult demeurent dans la file d’attente. Par exemple, si la méthode <codeph>execute()</codeph> est appelée plusieurs fois sans appel à <codeph>getResult()</codeph>, les objets SQLResult associés à chaque appel <codeph>execute()</codeph> restent dans la file d’attente.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/result"><linktext>result</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:next"><apiName>next</apiName><shortdesc>
     Récupère la partie suivante d’un jeu de résultats d’une instruction SELECT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque la méthode est appelée alors que l’instruction n’est pas en cours d’exécution (la propriété <codeph>executing</codeph> est <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>si l’opération échoue en mode d’exécution synchrone.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Lorsque la propriété <codeph>text</codeph> de l’instruction est une instruction <codeph>SELECT</codeph>, cette valeur indique le nombre de lignes renvoyées en une seule fois par l’instruction. La valeur par défaut est -1, indiquant que toutes les lignes du résultat sont renvoyées en une seule fois. L’utilisateur peut ainsi mieux percevoir les performances de l’application car les résultats initiaux sont renvoyés plus rapidement et que les opérations de traitement des résultats sont divisées.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet qui désigne les méthodes à appeler lorsque l’opération réussit ou échoue. Si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>result</codeph> ou <codeph>error</codeph> est distribué lorsque l’exécution se termine.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Récupère la partie suivante d’un jeu de résultats d’instruction <codeph>SELECT</codeph>. Si le jeu de résultats ne contient plus aucune ligne, un événement <codeph>result</codeph> est distribué, mais aucun autre objet SQLResult n’est ajouté dans la file d’attente <codeph>getResult()</codeph>.
     
     <p>En mode d’exécution asynchrone, si l’argument <codeph>responder</codeph> n’est pas <codeph>null</codeph>, l’objet Responder spécifié indique les méthodes appelées pour gérer les résultats de l’opération. Si l’argument <codeph>responder</codeph> est <codeph>null</codeph>, un événement <codeph>result</codeph> est distribué si l’opération est réussie, ou un événement <codeph>error</codeph> si l’opération échoue.</p>
     
     <p>Cette méthode ne peut être appelée que si l’instruction est encore en exécution. Lorsque l’instruction est une requête <codeph>SELECT</codeph> et qu’un argument <codeph>prefetch</codeph> supérieur à zéro est spécifié, l’instruction est censée s’exécuter jusqu’à ce que l’ensemble du jeu du résultats soit renvoyé ou que la méthode <codeph>SQLStatement.cancel()</codeph> ou<codeph>SQLConnection.cancel()</codeph> soit appelée.</p>
     
     </apiDesc><example conref="examples\SQLStatement.next.1.as"> L’exemple suivant démontre l’exécution d’une occurrence SQLStatement, indiquant explicitement que seules les 10 premières lignes du jeu de résultats doivent être renvoyées lors du premier renvoi des résultats. Le code vérifie la propriété <codeph>complete</codeph> de SQLResult et, si toutes les lignes n’ont pas été récupérées, appelle la méthode <codeph>next()</codeph>.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute(10);
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
        if (!result.complete)
        {
            dbStatement.next(10);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:next_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’exécution de l’instruction se termine avec succès ou lorsqu’une valeur d’argument <codeph>prefetch</codeph> est spécifiée et que l’appel <codeph>next()</codeph> renvoie une ou plusieurs lignes de données.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’exécution de l’instruction se termine avec succès ou lorsqu’une valeur d’argument prefetch est spécifiée et que l’appel next() renvoie une ou plusieurs lignes de données.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:next_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération échoue en mode d’exécution asynchrone.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLStatement:executing:get"><apiName>executing</apiName><shortdesc>
     Indique si l’instruction est en cours d’exécution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’instruction est en cours d’exécution.
     
     <p>Cette propriété est true si la méthode <codeph>execute()</codeph> a été appelée et que tous les résultats n’ont pas été renvoyés de la base de données.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>execute()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:itemClass:get"><apiName>itemClass</apiName><shortdesc>
     Indique une classe (type de données) utilisée pour chaque ligne renvoyée en tant que résultat de l’exécution de l’instruction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Class</apiValueClassifier></apiValueDef><apiDesc>
     Indique une classe (type de données) utilisée pour chaque ligne renvoyée en tant que résultat de l’exécution de l’instruction.
     
     <p platform="javascript">Cette propriété est conçue pour être utilisée dans une application AIR basée sur SWF uniquement. Vous ne pouvez pas l’utiliser dans JavaScript (ActionScript vous permet de définir des classes personnalisées, que vous pouvez utiliser avec cette propriété).</p>
     
     <p platform="actionscript">Par défaut, chaque ligne renvoyée par une instruction <codeph>SELECT</codeph> est créée en tant qu’occurrence Object, avec les noms de colonnes du jeu de résultats correspondant au nom des propriétés de l’objet, et la valeur de chaque colonne correspondant à la valeur de sa propriété associée.</p>
     
     <p platform="actionscript">En spécifiant la classe de la propriété <codeph>itemClass</codeph>, chaque ligne renvoyée par une instruction <codeph>SELECT</codeph> exécutée par cette occurrence SQLStatement et créée sous la forme d’une occurrence de la classe désignée. Chaque propriété de l’occurrence <codeph>itemClass</codeph> se voit affecter la valeur de la colonne portant le même nom que la propriété.</p>
     
     <p platform="actionscript">Toute classe affectée à cette propriété doit avoir un constructeur qui ne requiert aucun paramètre. En outre, la classe doit avoir une seule propriété pour chaque colonne renvoyée par l’instruction <codeph>SELECT</codeph>. Le fait qu’une colonne de la liste <codeph>SELECT</codeph> ne présente pas de nom de propriété correspondant dans la classe <codeph>itemClass</codeph> est considéré comme une erreur.</p>
     
     </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> Le code suivant illustre l’utilisation de la propriété <codeph>itemClass</codeph> pour que l’exécution crée des occurrences d’une classe personnalisée à partir des résultats de l’instruction SQL <codeph>SELECT</codeph>.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/data"><linktext>flash.data.SQLResult.data</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:parameters:get"><apiName>parameters</apiName><shortdesc>
     Joue le rôle de tableau associatif dans lequel vous ajoutez des valeurs pour les paramètres spécifiés dans la propriété text de l’instruction SQL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Joue le rôle de tableau associatif dans lequel vous ajoutez des valeurs pour les paramètres spécifiés dans la propriété <codeph>text</codeph> de l’instruction SQL. Les clés du tableau sont les noms des paramètres. Si un paramètre sans nom est spécifié dans la propriété text de l’instruction, sa clé est l’index du paramètre.
     
     <p>Dans le texte d’une instruction SQL, un paramètre est indiqué avec l’un des caractères suivants : « ? », « : » ou « @ ».</p>
     
     <p>Les jetons « : » et « @ » indiquent un paramètre nommé ; les caractères qui suivent le jeton désignent le nom du paramètre.</p>
     
     <p>Par exemple, dans l’instruction SQL suivante, un paramètre nommé <codeph>firstName</codeph> est spécifié à l’aide du caractère « : » :</p>
     
     <pre>SELECT FROM employees WHERE firstName = :firstName</pre>
     
     <p>Le jeton « ? » indique un paramètre indexé (numéroté) ; chaque paramètre se voit automatiquement attribué un index en fonction de la séquence des paramètres du texte de l’instruction. Les valeurs d’index des paramètres sont basées sur zéro. En d’autres termes, le premier index de paramètre est 0.</p>
     
     <p>Les paramètres autorisent la substitution avec type de valeurs inconnues au moment de la construction de l’instruction SQL. L’utilisation des paramètres est le seul moyen de garantir la classe de stockage d’une valeur transmise à la base de données. Lorsque des paramètres ne sont pas utilisés, toutes les valeurs sont converties de leur représentation texte en une classe de stockage en fonction de l’affinité du type de la colonne associée. Pour plus d’informations sur les classes de stockage et l’affinité des colonnes, consultez la section « <xref href="../../localDatabaseSQLSupport.html#dataTypes">Prise en charge des types de données</xref> » dans l’annexe « <xref href="../../localDatabaseSQLSupport.html">Prise en charge de SQL dans les bases de données locales</xref> ».</p>
     
     <p>Les paramètres sont également utilisés comme mesure de sécurité pour empêcher une technique malveillante appelée attaque par injection de code SQL. Dans une attaque par injection de code SQL, l’utilisateur entre du code SQL dans un emplacement accessible (par exemple dans un champ de saisie de données). Si le code de l’application construit une instruction SQL en concaténant directement la saisie de l’utilisateur dans le texte SQL, le code SQL saisi par l’utilisateur est exécuté sur la base de données. L’exemple suivant illustre la concaténation de la saisie de l’utilisateur dans le texte SQL. <b>N’utilisez pas cette technique </b>:</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement = new air.SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <p>L’utilisation des paramètres d’instruction à la place de la concaténation des valeurs entrées par l’utilisateur dans le texte d’une instruction empêche les attaques par injection de code SQL car les valeurs des paramètres sont traitées explicitement sous forme de valeurs substituées au lieu de devenir une partie du texte de l’instruction littérale. L’exemple suivant est l’alternative recommandée :</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement = new air.SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <p>Toutes les valeurs des paramètres doivent être définies avant l’exécution de l’instruction. Les valeurs des paramètres spécifiés dans le tableau <codeph>parameters</codeph> sont liées (c’est-à-dire combinées avec le texte de l’instruction) lorsque la méthode <codeph>execute()</codeph> est appelée. Après l’appel de la méthode <codeph>execute()</codeph>, les modifications suivantes des valeurs ne sont pas appliquées à l’instruction en exécution. Toutefois, lors des appels consécutifs à <codeph>execute()</codeph>, les valeurs modifiées sont utilisées. Si le texte de l’instruction comprend un paramètre pour lequel aucune valeur n’a été spécifiée dans la propriété <codeph>parameters</codeph>, le résultat est une erreur.</p>
     
     <p>Pour effacer toutes les valeurs de paramètres de la propriété <codeph>parameters</codeph>, utilisez la méthode <codeph>clearParameters()</codeph>.</p>
     
	 </apiDesc><example conref="examples\SQLStatement.parameters.1.as"> L’exemple suivant illustre l’utilisation d’un paramètre nommé, <codeph>:firstName</codeph>, dans une instruction SQL.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = :firstName";
employees.parameters[":firstName"] = "Sam";
employees.execute();
</codeblock></example><example conref="examples\SQLStatement.parameters.2.as"> L’exemple suivant illustre l’utilisation d’un paramètre sans nom dans une instruction SQL.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = ?";
employees.parameters[0] = "Sam";
employees.execute();
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/text"><linktext>text</linktext></link><link href="flash.data.xml#SQLStatement/clearParameters()"><linktext>clearParameters()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:sqlConnection:get"><apiName>sqlConnection</apiName><shortdesc>
     Objet SQLConnection qui gère la connexion à la ou aux bases de données dans lesquelles l’instruction est exécutée.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.data:SQLConnection</apiValueClassifier><apiException><apiDesc>Lors d’une tentative de modification de la valeur de cette propriété alors que l’instruction est en cours d’exécution.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Objet SQLConnection qui gère la connexion à la ou aux bases de données dans lesquelles l’instruction est exécutée.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLStatement:text:get"><apiName>text</apiName><shortdesc>
     Véritable texte SQL de l’instruction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Lors d’une tentative de modification de la valeur de la propriété <codeph>text</codeph> alors que l’instruction est en cours d’exécution.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Véritable texte SQL de l’instruction.
	 
     <p>Le texte peut être n’importe quel code SQL pris en charge. Pour obtenir une description complète du dialecte SQL pris en charge par les bases de données SQL locales, consultez l’annexe « <xref href="../../localDatabaseSQLSupport.html">Prise en charge de SQL dans les bases de données locales</xref> ».</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLMode"><apiName>SQLMode</apiName><shortdesc>
 Cette classe contient les constantes représentant les valeurs possibles du paramètre openMode des méthodes SQLConnection.open() et SQLConnection.openAsync().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Cette classe contient les constantes représentant les valeurs possibles du paramètre <codeph>openMode</codeph> des méthodes <codeph>SQLConnection.open()</codeph> et <codeph>SQLConnection.openAsync()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links><apiValue id="flash.data:SQLMode:CREATE"><apiName>CREATE</apiName><shortdesc>
	 Indique que la connexion est ouverte pour les mises à jour et qu’un fichier de base de données est créé lorsque le fichier spécifié n’existe pas.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>create</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que la connexion est ouverte pour les mises à jour et qu’un fichier de base de données est créé lorsque le fichier spécifié n’existe pas. Dans ce mode, la lecture et l’écriture sont autorisées dans la base de données. Si la base de données n’existe pas, une base de données est créée avant la fin de l’opération.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:READ"><apiName>READ</apiName><shortdesc>
	 Indique que la connexion est ouverte en mode lecture seule.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>read</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que la connexion est ouverte en mode lecture seule. Dans ce mode, l’écriture n’est pas autorisée dans la base de données. Si la base de données n’existe pas, l’opération d’ouverture échoue.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:UPDATE"><apiName>UPDATE</apiName><shortdesc>
	 Indique que la connexion est ouverte pour les mises à jour mais que aucun nouveau fichier de base de données n’est créé lorsque le fichier spécifié n’existe pas.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>update</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que la connexion est ouverte pour les mises à jour mais que aucun nouveau fichier de base de données n’est créé lorsque le fichier spécifié n’existe pas. Dans ce mode, la lecture et l’écriture sont autorisées dans la base de données. Si la base de données n’existe pas, l’opération d’ouverture échoue.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:EncryptedLocalStore"><apiName>EncryptedLocalStore</apiName><shortdesc>
	La classe EncryptedLocalStore fournit des méthodes qui permettent de définir et de récupérer des objets dans le stockage de données local crypté pour une application AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	La classe EncryptedLocalStore fournit des méthodes qui permettent de définir et de récupérer des objets dans le stockage de données local crypté pour une application AIR. Un stockage local crypté permanent est disponible pour chaque application AIR installée sur l’ordinateur de l’utilisateur. Vous pouvez ainsi enregistrer et récupérer des données stockées sur le disque dur local de l’utilisateur dans un format crypté que les autres applications ou utilisateurs ne peuvent pas déchiffrer. Un stockage local crypté distinct est utilisé pour chaque application AIR et chaque application AIR utilise un stockage local crypté distinct pour chaque utilisateur. 
	
	<p>Vous pouvez utiliser le stockage local crypté pour stocker les informations confidentielles, telles que les identifiants de connexion aux services Web.</p>
	
	<p>Lorsque vous testez une application dans l’application de débogage du lanceur AIR (ADL), l’application utilise un autre stockage local crypté que celui employé par l’application AIR installée.</p>
	
	<p>AIR utilise DPAPI sous Windows <sup>®</sup>, KeyChain sous Mac<sup>®</sup> OS<sup>®</sup> et KeyRing ou KWallet sous Linux<sup>®</sup> pour associer le stockage local crypté à chaque application et utilisateur. Le stockage local crypté utilise un cryptage AES-CBC de 128 bits.</p>
	
	<p>Les informations conservées dans le stockage local crypté ne sont disponibles que pour le contenu de l’application AIR dans le sandbox de sécurité de celle-ci. </p>
	
	<p>Les éléments du stockage local crypté sont identifiés par une chaîne. Tous les éléments sont stockés sous forme de données de tableau d’octets.</p>
	
	<p>Le stockage local crypté peut s’exécuter plus lentement si les données stockées dépassent 10 Mo.</p>
	
	<p>Lorsque vous désinstallez une application AIR, le programme de désinstallation ne supprime pas les données stockées dans le stockage local crypté.</p>
	
	<p>Les données du stockage local crypté sont placées dans un sous-répertoire du répertoire de données de l’application de l’utilisateur ; le chemin du sous-répertoire est Adobe/AIR/ELS/suivi de l’ID de l’application.</p>
	
	</apiDesc><example conref="examples\EncryptedLocalStore.1.as"> Le code suivant stocke une chaîne dans le stockage local crypté, la récupère, puis la supprime :
<codeblock>
var str:String = "Bob";
var bytes:ByteArray = new ByteArray();
bytes.writeUTFBytes(str);
EncryptedLocalStore.setItem("firstName", bytes);

var storedValue:ByteArray = EncryptedLocalStore.getItem("firstName");
trace(storedValue.readUTFBytes(storedValue.length)); // "Bob"

EncryptedLocalStore.removeItem("firstName");
</codeblock></example></apiClassifierDetail><apiOperation id="flash.data:EncryptedLocalStore:getItem"><apiName>getItem</apiName><shortdesc>
		Renvoie les données de l’élément portant le paramètre name donné dans le stockage local crypté.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>La valeur <codeph>name</codeph> est <codeph>null</codeph> ou une chaîne vide.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Données ByteArray. S’il n’y a pas de données pour le paramètre <codeph>name</codeph> fourni, la méthode renvoie <codeph>null</codeph>.
		
		</apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’élément dans le stockage local crypté.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Renvoie les données de l’élément portant le paramètre name donné dans le stockage local crypté. Si un élément n’existe pas avec le paramètre name spécifié, cette méthode renvoie <codeph>null</codeph>.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:removeItem"><apiName>removeItem</apiName><shortdesc>
		Supprime l’élément présentant le paramètre name donné du stockage local crypté.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>La valeur <codeph>name</codeph> est <codeph>null</codeph> ou une chaîne vide.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’élément dans le stockage local crypté.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Supprime l’élément présentant le paramètre name donné du stockage local crypté.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:reset"><apiName>reset</apiName><shortdesc>
		Efface tout le stockage local crypté, en supprimant toutes les données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		Efface tout le stockage local crypté, en supprimant toutes les données.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:setItem"><apiName>setItem</apiName><shortdesc>
		Définit l’élément sur le nom donné aux données ByteArray fournies.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>La valeur <codeph>name</codeph> est <codeph>null</codeph> ou une chaîne vide.
		
		<p>Par défaut, une application AIR ne peut pas lire le stockage local crypté d’une autre application. Le paramètre <codeph>stronglyBound</codeph> fournit une liaison supplémentaire (aux données des bits de l’application) qui empêche les applications pirates d’essayer de lire dans le stockage local crypté de votre application en tentant de détourner l’ID de l’éditeur de votre application.</p> 
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’élément dans le stockage local crypté.
		
		</apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Données.
		
		</apiDesc></apiParam><apiParam><apiItemName>stronglyBound</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si défini sur <codeph>true</codeph>, l’élément stocké est fortement lié à la signature numérique et aux bits de l’application AIR (le contenu du répertoire de l’application), en plus de l’ID de l’éditeur de l’application. Un appel suivant à <codeph>getItem()</codeph> pour cet élément entraîne une exception d’exécution si les bits de l’application AIR appelante ne correspondent pas à ceux de l’application de stockage. Si vous mettez à jour votre application, elle ne peut pas lire les données fortement liées précédemment écrites dans le stockage local crypté. 
		
		<p>Si le paramètre <codeph>stronglyBound</codeph> est défini sur <codeph>false</codeph> (valeur par défaut), il suffit que l’ID d’éditeur reste la même pour que l’application puisse lire les données. Les bits de l’application peuvent changer (et doivent être signés par l’éditeur) mais ne doivent pas correspondre exactement aux bits de l’application qui a stocké les données.</p>
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Définit l’élément sur le nom donné aux <codeph>données</codeph> ByteArray fournies.
		
		</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.data:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
 Une occurrence SQLIndexSchema fournit des informations décrivant un index spécifique dans une base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une occurrence SQLIndexSchema fournit des informations décrivant un index spécifique dans une base de données. Les informations disponibles incluent le nom de la table associée (la propriété <codeph>table</codeph>), l’instruction SQL utilisée pour créer l’index (la propriété <codeph>sql</codeph>) et le nom de l’index (la propriété <codeph>name</codeph>).
 
 <p>Pour obtenir des informations de schéma d’index pour une base de données, utilisez la méthode <codeph>SQLConnection.loadSchema()</codeph> pour charger les informations du schéma, en vous assurant d’utiliser <codeph>null</codeph> ou <codeph>SQLIndexSchema</codeph> comme valeur d’argument <codeph>type</codeph>. Dans l’occurrence SQLSchemaResult résultante, la propriété <codeph>indices</codeph> contient un tableau d’occurrences SQLIndexSchema représentant les indices de la base de données.</p>
 
 <p>En général, le code du développeur ne construit pas directement d’occurrences SQLIndexSchema.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLIndexSchema:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
     Crée une occurrence SQLIndexSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la base de données associée.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’index.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Instruction SQL utilisée pour créer cet index.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la table à laquelle cet index est attaché.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence SQLIndexSchema. En général, le code du développeur n’appelle pas directement le constructeur SQLIndexSchema. Pour obtenir les informations du schéma d’une base de données, appelez la méthode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/indices"><linktext>flash.data.SQLSchemaResult.indices</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLIndexSchema:table:get"><apiName>table</apiName><shortdesc>
     Nom de la table à laquelle cet index est attaché.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Nom de la table à laquelle cet index est attaché.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
 Une occurrence SQLTableSchema fournit des informations décrivant une table spécifique dans une base de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Une occurrence SQLTableSchema fournit des informations décrivant une table spécifique dans une base de données. Elle contient le nom de la table (la propriété <codeph>name</codeph>), l’instruction SQL utilisée pour créer la table (la propriété <codeph>sql</codeph>) et des informations sur les colonnes de la table (la propriété <codeph>columns</codeph>).
 
 <p>Pour obtenir les informations du schéma des tables d’une base de données, utilisez la méthode <codeph>SQLConnection.loadSchema()</codeph> pour charger les informations du schéma, en vous assurant d’utiliser <codeph>null</codeph> ou <codeph>SQLTableSchema</codeph> comme valeur d’argument <codeph>type</codeph>. Dans l’occurrence SQLSchemaResult résultante, la propriété <codeph>tables</codeph> contient un tableau d’occurrences SQLTableSchema représentant les tables de la base de données.</p>
 
 <p>En général, le code du développeur ne construit pas directement d’occurrences SQLTableSchema.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLTableSchema:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
     Crée une occurrence SQLTableSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la base de données associée.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la table.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Instruction SQL utilisée pour créer la table.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau d’occurrences SQLColumnSchema décrivant les colonnes de cette table.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence SQLTableSchema. En général, le code du développeur n’appelle pas directement le constructeur SQLTableSchema. Pour obtenir les informations du schéma d’une base de données, appelez la méthode <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/tables"><linktext>flash.data.SQLSchemaResult.tables</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLTableSchema:columns:get"><apiName>columns</apiName><shortdesc>
     Tableau d’occurrences SQLColumnSchema contenant les informations du schéma relatif aux colonnes de cette table.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau d’occurrences SQLColumnSchema contenant les informations du schéma relatif aux colonnes de cette table. Si l’appel <codeph>SQlConnection.loadSchema()</codeph> indique que les informations de colonnes doivent être exclues du résultat, la propriété <codeph>columns</codeph> est un tableau vide (un tableau dont la propriété <codeph>length</codeph> est 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLResult"><apiName>SQLResult</apiName><shortdesc>
 La classe SQLResult fournit un accès aux données renvoyées en réponse à l’exécution d’une instruction SQL (une occurrence SQLStatement).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SQLResult fournit un accès aux données renvoyées en réponse à l’exécution d’une instruction SQL (une occurrence SQLStatement).
 
 <p>L’occurrence SQLResult d’une instruction SQL est accédée par un appel à la méthode <codeph>SQLStatement.getResult()</codeph> ou sous forme d’argument transmis au gestionnaire de résultats d’une occurrence Responder spécifiée dans un appel à <codeph>SQLStatement.execute()</codeph> ou <codeph>SQLStatement.next()</codeph>. En général, le code du développeur ne construit pas directement d’occurrences SQLResult.</p>
 
 <p>Vous utilisez un objet SQLResult pour accéder aux lignes de données renvoyées par une instruction <codeph>SELECT</codeph> (avec la propriété <codeph>data</codeph>), pour obtenir les informations sur l’identificateur de lignes d’une instruction <codeph>INSERT</codeph> (avec la propriété <codeph>lastInsertRowID</codeph>), pour déterminer le nombre de lignes affectées par une instruction <codeph>INSERT</codeph>, <codeph>UPDATE</codeph> ou <codeph>DELETE</codeph> (avec la propriété <codeph>rowsAffected</codeph>) ou pour déterminer si d’autres lignes de résultats <codeph>SELECT</codeph> n’ont pas été récupérées (avec la propriété <codeph>complete</codeph>).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement/getResult()"><linktext>flash.data.SQLStatement.getResult()</linktext></link><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links><apiConstructor id="flash.data:SQLResult:SQLResult"><apiName>SQLResult</apiName><shortdesc>
     Crée une occurrence SQLResult.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de lignes renvoyées par l’exécution d’une instruction. Si l’instruction ne renvoie aucune ligne, cette valeur doit être nulle.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowsAffected</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Indique le nombre de ligne affectées par l’instruction exécutée.
     
     </apiDesc></apiParam><apiParam><apiItemName>complete</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Indique si d’autres lignes peuvent être récupérées ou si toutes les données ont été renvoyées.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowID</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Si l’instruction était une opération SQL <codeph>INSERT</codeph>, il s’agit du nouvel identifiant unique de la ligne.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence SQLResult. En général, le code du développeur n’appelle pas directement le constructeur SQLResult. Pour récupérer une occurrence SQLResult associée à une occurrence SQLStatement particulière, appelez la méthode <codeph>getResult()</codeph> de l’occurrence. Une occurrence SQLResult est également transmise sous forme d’argument à la fonction gestionnaire de résultats lorsqu’une occurrence Responder est spécifiée pour un appel de méthode <codeph>execute()</codeph> ou <codeph>next()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLResult:complete:get"><apiName>complete</apiName><shortdesc>
     Indique si toutes les données résultantes d’une exécution d’instruction ont été renvoyées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si toutes les données résultantes d’une exécution d’instruction ont été renvoyées.
     
     <p>Lorsqu’une instruction renvoie une ou plusieurs lignes, cette propriété indique si toutes les lignes ont été renvoyées. Lorsque la méthode <codeph>execute()</codeph> de l’objet SQLStatement est appelée avec une valeur d’argument <codeph>prefetch</codeph>, seul le nombre de lignes de données résultantes spécifié est renvoyé dans la propriété <codeph>data</codeph> de l’objet SQLResult. Les appels suivants à <codeph>SQLStatement.next()</codeph> rendent d’autres données disponibles. Cette propriété est utilisée pour déterminer le moment où les résultats finaux ont été renvoyés.</p>
     
     <p>Notez que, le nombre de lignes étant inconnu au moment de l’exécution, le curseur de la base de données doit se déplacer au-delà de la dernière ligne pour que l’exécution d’une instruction soit considérée comme complète. Lorsque la méthode <codeph>SQLStatement.execute()</codeph> est appelée avec un argument <codeph>prefetch</codeph>, au moins une ligne de plus que le nombre total de lignes du jeu de résultats doit être demandée avant que la propriété <codeph>complete</codeph> de l’occurrence SQLResult résultante soit <codeph>true</codeph>.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:data:get"><apiName>data</apiName><shortdesc>
     Données renvoyées en tant que résultat de l’exécution de l’instruction, en particulier lorsqu’une instruction SQL SELECT est exécutée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Données renvoyées en tant que résultat de l’exécution de l’instruction, en particulier lorsqu’une instruction SQL <codeph>SELECT</codeph> est exécutée.
     
     <p>Lorsqu’une instruction renvoie une ou plusieurs lignes, cette propriété est un tableau contenant les objets qui représentent les lignes de données de résultat. Chaque objet dans le tableau possède des noms de propriété qui correspondent aux noms des colonnes du jeu de résultats.</p>
	 
	 <p>Par exemple, supposons que vous exécutez l’instruction SQL <codeph>SELECT</codeph> suivante : </p>
	 
	 <codeblock>
	 SELECT lastName, firstName
	 FROM employees
	 </codeblock>
	 
	 <p>En supposant que la table <codeph>employees</codeph> contient 10 lignes, la propriété <codeph>SQLResult.data</codeph> est un tableau de 10 éléments. Chaque élément est un objet avec deux propriétés : <codeph>lastName</codeph> et <codeph>firstName</codeph>.</p>
	 
	 <p>La situation est plus complexe lorsque vous utilisez une instruction <codeph>SELECT</codeph> avec une colonne de résultats complexes, par exemple une fonction de regroupement. Par exemple, supposons que vous exécutez l’instruction SQL suivante : </p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary)
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>Dans les résultats de cette instruction, chaque objet du tableau <codeph>data</codeph> comprend deux propriétés nommées <codeph>departmentId</codeph> et <codeph>SUM(salary)</codeph>. Toutefois, "SUM(salary)" n’est pas un identifiant valable. Si vous utilisez une colonne calculée, par exemple une fonction de regroupement ou autre, spécifiez un alias pour la colonne calculée dans l’instruction SQL. Cet alias est utilisé comme nom de la propriété dans les objets de données de résultat. Par exemple, considérons cette alternative à l’instruction précédente :</p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary) AS salarySubtotal
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>Dans le tableau <codeph>data</codeph> de cette instruction, les objets de résultat possèdent deux propriétés nommées <codeph>departmentId</codeph> et <codeph>salarySubtotal</codeph>. </p>
	 
	 <p>La propriété <codeph>data</codeph> est toujours un tableau, quel que soit le nombre de lignes et de colonnes du jeu de résultats. Par exemple, l’instruction <codeph>SELECT</codeph> suivante génère une ligne et une colonne, qui représentent une valeur unique :</p>
	 
	 <codeblock>
	 SELECT COUNT(~~) AS numEmployees
	 FROM employees
	 </codeblock>
	 
	 <p>Après avoir exécuté la requête, la propriété <codeph>data</codeph> contient un objet Array avec un élément. Cet élément est un objet avec une seule propriété, <codeph>numEmployees</codeph>.</p>
	 
	 <p>Si plusieurs noms de colonne sont dupliqués dans les données de résultat, notamment si l’instruction <codeph>SELECT</codeph> comporte deux colonnes <codeph>id</codeph> différentes de deux tableaux distincts, des noms de propriété sont attribués aux noms dupliqués en fonction de la valeur de la propriété <codeph>SQLConnection.columnNameStyle</codeph>. Par défaut, le nom de chaque colonne est utilisé comme nom de la propriété. Néanmoins, s’il existe plusieurs colonnes dans le jeu de résultats portant le même nom, le format de nom long <codeph>[nom-table]_[nom-colonne]</codeph> est utilisé chaque fois que le nom de plusieurs colonnes est identique. Ce comportement peut être modifié en définissant la propriété<codeph>SQLConnection.columnNameStyle</codeph>.</p>
	 
	 <p>Par défaut, les objets du tableau <codeph>data</codeph> sont des occurrences d’Object. Toutefois, si la valeur de la propriété <codeph>SQLStatement.itemClass</codeph> d’une classe est définie, les éléments du tableau <codeph>data</codeph> sont créés sous forme d’occurrences de cette classe. Pour chaque colonne du jeu de données de résultat, la classe <codeph>itemClass</codeph> doit avoir une propriété dont le nom correspond exactement au nom de la colonne. </p> 
	 
	 <p>Lorsque l’instruction ne renvoie aucune donnée, cette propriété est <codeph>null</codeph>. C’est le cas notamment s’il ne s’agit pas d’une instruction <codeph>SELECT</codeph> ou s’il s’agit d’une instruction <codeph>SELECT</codeph> qui renvoie 0 ligne. </p>
     
	 </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> Le code suivant illustre l’utilisation de la propriété <codeph>itemClass</codeph> pour que l’exécution crée des occurrences d’une classe personnalisée à partir des résultats de l’instruction SQL <codeph>SELECT</codeph>.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>SQLConnection.columnNameStyle</linktext></link><link href="flash.data.xml#SQLStatement/itemClass"><linktext>SQLStatement.itemClass</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     Dernier identifiant généré par une instruction SQL INSERT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Dernier identifiant généré par une instruction SQL <codeph>INSERT</codeph>.
	 
     <p>La valeur est 0 si l’instruction exécutée n’était pas une instruction <codeph>INSERT</codeph>.</p>
	 
	 <p>Un identifiant de ligne est utilisé pour identifier de façon unique une ligne d’une table de la base de données. La valeur est générée fréquemment par la base de données.</p>
	 
	 <p>Pour plus d’informations sur les clés primaires et les identifiants de ligne générés, reportez-vous aux sections « <xref href="../../localDatabaseSQLSupport.html#createTable">CREATE TABLE</xref> » et « <xref href="../../localDatabaseSQLSupport.html#expressions">Expressions</xref> » à l’annexe « <xref href="../../localDatabaseSQLSupport.html">Prise en charge SQL dans les bases de données locales</xref> ».</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/lastInsertRowID"><linktext>flash.data.SQLConnection.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:rowsAffected:get"><apiName>rowsAffected</apiName><shortdesc>
     Indique le nombre de lignes affectées par l’opération.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique le nombre de lignes affectées par l’opération. Seules les modifications spécifiées directement par une instruction <codeph>INSERT</codeph>, <codeph>UPDATE</codeph> ou <codeph>DELETE</codeph> sont comptées.
     
     <p>Les modifications auxiliaires causées par des déclencheurs ne sont pas prises en compte. Pour connaître le nombre total de modifications, y compris dues à des déclencheurs, utilisez la propriété <codeph>SQLConnection.totalChanges</codeph>.</p>
	 
	 <p>Notez que, lorsque l’opération SQL associée est une instruction <codeph>DELETE</codeph> sans clause <codeph>WHERE</codeph> (c’est-à-dire qu’elle supprime toutes les lignes de la table), la propriété <codeph>rowsAffected</codeph> est toujours 0, quel que soit le nombre de lignes supprimées. Pour connaître le nombre de lignes supprimées, vous pouvez inclure la clause <codeph>WHERE</codeph>, <codeph>WHERE 1 = 1</codeph>. Dans ce cas toutes les lignes sont supprimées et la propriété <codeph>rowsAffected</codeph> indique précisément le nombre de lignes supprimées. Toutefois, selon le nombre de lignes supprimées, cette opération affecte négativement les performances de l’instruction.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/totalChanges"><linktext>flash.data.SQLConnection.totalChanges</linktext></link></related-links></apiValue></apiClassifier></apiPackage>