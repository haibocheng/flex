<?xml version="1.0"?>
<apiPackage id="flash.desktop"><apiName>flash.desktop</apiName><apiDetail/><apiClassifier id="flash.desktop:InvokeEventReason"><apiName>InvokeEventReason</apiName><shortdesc>
	 La classe InvokeEventReason énumère les valeurs renvoyées par la propriété reason d’un objet InvokeEvent. </shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe InvokeEventReason énumère les valeurs renvoyées par la propriété <codeph>reason</codeph> d’un objet <codeph>InvokeEvent</codeph>. 
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#InvokeEvent/reason"><linktext>flash.events.InvokeEvent.reason</linktext></link></related-links><apiValue id="flash.desktop:InvokeEventReason:LOGIN"><apiName>LOGIN</apiName><shortdesc>
			Indique que l’événement InvokeEvent s’est produit parce que l’utilisateur s’est connecté. </shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>login</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
			Indique que l’événement InvokeEvent s’est produit parce que l’utilisateur s’est connecté. 
			
			</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:InvokeEventReason:STANDARD"><apiName>STANDARD</apiName><shortdesc>
			Indique que l’événement InvokeEvent s’est produit pour une raison autre que la connexion. </shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
			Indique que l’événement InvokeEvent s’est produit pour une raison autre que la connexion. 
			
			</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:InteractiveIcon"><apiName>InteractiveIcon</apiName><shortdesc>
	 La classe InteractiveIcon est la classe de base pour les icônes du système d’exploitation associées aux applications.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.desktop:Icon</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe InteractiveIcon est la classe de base pour les icônes du système d’exploitation associées aux applications. 
	 
	 <p>Utilisez la propriété <codeph>icon</codeph> de l’objet NativeApplication pour obtenir une occurrence de l’icône de l’application. Le type d’icône est l’une des sous-classes de InteractiveIcon, DockIcon sous Mac OS X<sup>®</sup> ou SystemTrayIcon sous Windows<sup>®</sup> et Linux.</p>
	 
	 <p>Il est impossible d’instancier directement la classe InteractiveIcon. Les appels au constructeur <codeph>new InteractiveIcon()</codeph> renvoient une exception ArgumentError.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsDockIcon"><linktext>flash.desktop.NativeApplication.supportsDockIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsSystemTrayIcon"><linktext>flash.desktop.NativeApplication.supportsSystemTrayIcon</linktext></link></related-links><apiValue id="flash.desktop:InteractiveIcon:bitmaps:set"><apiName>bitmaps</apiName><shortdesc>
		  
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		  
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.
	   
	 <p>Lorsqu’une icône est affichée dans le contexte d’un certain système d’exploitation, l’image bitmap du tableau se rapprochant le plus de la taille affichée est utilisée (et éventuellement mise à l’échelle). Les tailles courantes sont 16x16, 32x32, 48x48 et 128x128 (des icônes de 512x512 pixels peuvent être utilisées pour des système d’exploitation futurs).</p>
	 
	 <p>Dans certains cas, le système d’exploitation peut utiliser une icône système par défaut lorsque rien n’a été affecté à la propriété <codeph>bitmaps</codeph>. Dans d’autres cas, aucune icône n’apparaît.</p>
	 
	 <p>Pour définir ou modifier l’apparence de l’icône, affectez un tableau d’objets bitmapData à la propriété <codeph>bitmaps</codeph> :</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>La modification directe du tableau <codeph>bitmaps</codeph> n’a aucun effet.</p>
	 
	 <p>Pour effacer l’image de l’icône, affectez un tableau vide à la propriété <codeph>bitmaps</codeph>.</p>
	 
	 <p>
	 <b>Remarque :</b> lors du chargement de fichiers image pour une icône, le format de fichier PNG fournit généralement le meilleur fondu alpha. Le format GIF ne prend en charge que l’activation ou la désactivation de la transparence (pas le fondu). Le format JPG ne prend pas en charge la transparence du tout.  
	 </p>
	  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:InteractiveIcon:height:get"><apiName>height</apiName><shortdesc>
		 Hauteur d’affichage actuelle de l’icône, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Hauteur d’affichage actuelle de l’icône, en pixels.
		 
		 <p>Certains contextes d’icône prennent en charge les tailles dynamiques. La propriété <codeph>height</codeph> indique la hauteur de l’icône choisie dans le tableau <codeph>bitmaps</codeph> pour le contexte actuel. La hauteur d’affichage réelle peut être différente si le système d’exploitation a mis l’icône à l’échelle.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:InteractiveIcon:width:get"><apiName>width</apiName><shortdesc>
		 Largeur d’affichage actuelle de l’icône, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Largeur d’affichage actuelle de l’icône, en pixels. 
		 
		 <p>Certains contextes d’icône prennent en charge les tailles dynamiques. La propriété <codeph>width</codeph> indique la largeur de l’icône choisie dans le tableau <codeph>bitmaps</codeph> pour le contexte actuel. La largeur d’affichage réelle peut être différente si le système d’exploitation a mis l’icône à l’échelle.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeDragActions"><apiName>NativeDragActions</apiName><shortdesc>
La classe NativeDragActions définit des constantes de chaîne pour les noms des actions de glisser-déposer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe NativeDragActions définit des constantes de chaîne pour les noms des actions de glisser-déposer.
 
 <p>Les constantes NativeDragActions sont utilisées comme valeurs pour la propriété <codeph>dropAction</codeph> des classes NativeDragManager et NativeDragEvent.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeDragManager"><linktext>flash.desktop.NativeDragManager</linktext></link><link href="flash.events.xml#NativeDragEvent"><linktext>flash.events.NativeDragEvent</linktext></link></related-links><apiValue id="flash.desktop:NativeDragActions:COPY"><apiName>COPY</apiName><shortdesc>
	Définit la chaîne à utiliser pour l’action de copie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>copy</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit la chaîne à utiliser pour l’action de copie.
	
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragActions:LINK"><apiName>LINK</apiName><shortdesc>
	Définit la chaîne à utiliser pour l’action de liaison.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>link</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit la chaîne à utiliser pour l’action de liaison.
	
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragActions:MOVE"><apiName>MOVE</apiName><shortdesc>
	 Définit la chaîne à utiliser pour l’action de déplacement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>move</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Définit la chaîne à utiliser pour l’action de déplacement.
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragActions:NONE"><apiName>NONE</apiName><shortdesc>
	Définit la chaîne à utiliser lorsque aucune action n’est spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit la chaîne à utiliser lorsque aucune action n’est spécifiée.
	 
	 <p>Dans un événement <codeph>nativeDragComplete</codeph>, une action <codeph>none</codeph> indique que l’opération de glisser-déposer a été abandonnée par l’utilisateur.</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:ClipboardFormats"><apiName>ClipboardFormats</apiName><shortdesc>
La classe ClipboardFormats définit des constantes pour les noms des formats de données standard utilisés avec la classe Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Clipboard, ClipboardFormats and ClipboardTransferMode were all added to AIR 1.0. These are also being added, with some exceptions listed in this file, to FP10.
</internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe ClipboardFormats définit des constantes pour les noms des formats de données standard utilisés avec la classe Clipboard. Flash Player 10 ne prend en charge que TEXT_FORMAT, RICH_TEXT_FORMAT et HTML_FORMAT.

</apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#Clipboard"><linktext>flash.desktop.Clipboard</linktext></link></related-links><apiValue id="flash.desktop:ClipboardFormats:BITMAP_FORMAT"><apiName>BITMAP_FORMAT</apiName><shortdesc>
	Données image (AIR uniquement).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not supported in FP10.
	</internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:bitmap</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Données image (AIR uniquement).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:FILE_LIST_FORMAT"><apiName>FILE_LIST_FORMAT</apiName><shortdesc>
	Tableau de fichiers (AIR uniquement).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not supported in FP10.
	</internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:file list</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Tableau de fichiers (AIR uniquement).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:HTML_FORMAT"><apiName>HTML_FORMAT</apiName><shortdesc>
	Données HTML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:html</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Données HTML.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:RICH_TEXT_FORMAT"><apiName>RICH_TEXT_FORMAT</apiName><shortdesc>
	Données RTF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:rtf</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Données RTF.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:TEXT_FORMAT"><apiName>TEXT_FORMAT</apiName><shortdesc>
	Données de chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:text</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Données de chaîne.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:URL_FORMAT"><apiName>URL_FORMAT</apiName><shortdesc>
	Chaîne URL (AIR uniquement).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not supported in FP10.
	</internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:url</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Chaîne URL (AIR uniquement).
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeApplication"><apiName>NativeApplication</apiName><shortdesc>
	 La classe NativeApplication représente cette application AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe NativeApplication représente cette application AIR.
	 
	 <p>
	 La classe NativeApplication fournit des informations sur l’application et sur ses fonctions, et déclenche des événements au niveau de l’application.
	 </p>
	 <p>
	 L’objet NativeApplication est un objet Singleton créé automatiquement au démarrage. Récupérez l’occurrence NativeApplication d’une application avec la propriété statique <codeph>NativeApplication.nativeApplication</codeph>.
	 </p>
	 
	 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.USER_PRESENT_userPresent"><apiName>userPresent</apiName><shortdesc>
	 Distribué lorsque le système d’exploitation détecte l’activité de la souris ou du clavier après une période d’inactivité.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.USER_PRESENT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsque le système d’exploitation détecte l’activité de la souris ou du clavier après une période d’inactivité.
	 
	 <p>La durée à partir de laquelle l’inactivité est avérée peut être configurée avec la propriété <codeph>idleThreshold</codeph>. La durée pendant laquelle l’utilisateur est resté inactif peut être déterminée avec la propriété <codeph>timeSinceLastUserInput</codeph>.</p>
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.desktop.xml#NativeApplication/idleThreshold"><linktext>idleThreshold</linktext></link><link href="flash.desktop.xml#NativeApplication/timeSinceLastUserInput"><linktext>timeSinceLastUserInput</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.USER_IDLE_userIdle"><apiName>userIdle</apiName><shortdesc>
	 Distribué lorsque l’utilisateur est resté inactif pendant la période spécifiée par la propriété idleThreshold.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.USER_IDLE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsque l’utilisateur est resté inactif pendant la période spécifiée par la propriété <codeph>idleThreshold</codeph>. 
	 
	 <p>La durée pendant laquelle l’utilisateur est resté inactif peut être déterminée avec la propriété <codeph>timeSinceLastUserInput</codeph>.</p>
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.desktop.xml#NativeApplication/idleThreshold"><linktext>idleThreshold</linktext></link><link href="flash.desktop.xml#NativeApplication/timeSinceLastUserInput"><linktext>timeSinceLastUserInput</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.NETWORK_CHANGE_networkChange"><apiName>networkChange</apiName><shortdesc>
	 Distribué lorsqu’une nouvelle connexion réseau devient disponible ou lorsqu’une connexion réseau existante est perdue.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.NETWORK_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsqu’une nouvelle connexion réseau devient disponible ou lorsqu’une connexion réseau existante est perdue. 
	 
	 <p>Un événement <codeph>networkChange</codeph> ne signifie pas obligatoirement que l’ordinateur hôte est passé en ligne ou hors ligne ; il peut simplement être en transition entre deux types de connexion. Les applications peuvent utiliser cet événement pour optimiser la surveillance de la disponibilité des ressources distantes. Le déclenchement d’un événement <codeph>networkChange</codeph> est souvent le bon moment pour vérifier la disponibilité des ressources distantes.
	 </p> 
	 <p><b>Remarque :</b> il peut y avoir un court délai entre le changement de réseau et l’arrivée de cet événement.</p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.EXITING_exiting"><apiName>exiting</apiName><shortdesc>
	 Distribué lorsque la séquence de fermeture de l’application commence.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXITING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsque la séquence de fermeture de l’application commence. 
	 
	 <p>L’événement exiting est distribué lorsque la fermeture de l’application est initiée par le système d’exploitation, par exemple lorsqu’un utilisateur tape la combinaison de touches <codeph>Cmd-Q</codeph> sous Mac OS X, ou lorsque la propriété <codeph>autoExit</codeph>de l’objet NativeApplication est <codeph>true</codeph> et que la dernière fenêtre de l’application est fermée. L’annulation de cet événement empêche la fermeture de l’application.</p>
	 
	 <p><b>Remarque :</b> un appel à la méthode <codeph>NativeApplication.exit()</codeph> n’entraîne pas le déclenchement d’un événement <codeph>exiting</codeph>. Pour avertir les composants de la fermeture imminente, déclenchez l’événement <codeph>exiting</codeph> avant d’appeler <codeph>exit()</codeph>.</p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
	 Distribué lorsque le focus du bureau est muté vers une application différente.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsque le focus du bureau est muté vers une application différente.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
	 Distribué lorsque cette application devient l’application active du bureau.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsque cette application devient l’application active du bureau.
	  
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.BrowserInvokeEvent.Browser_INVOKE_browserInvoke"><apiName>browserInvoke</apiName><shortdesc>
	 Distribué lorsqu’une application est invoquée par le biais d’un fichier SWF qui s’exécute dans le navigateur de l’utilisateur.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.BrowserInvokeEvent.Browser_INVOKE</apiEventType><adobeApiEventClassifier>flash.events.BrowserInvokeEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsqu’une application est invoquée par le biais d’un fichier SWF qui s’exécute dans le navigateur de l’utilisateur. 
	 
	 <p>L’invocation d’un navigateur n’est autorisée que si l’application spécifie les éléments suivants dans son fichier descripteur :</p>
	 
	 <codeblock>&lt;allowBrowserInvocation>true&lt;/allowBrowserInvocation></codeblock>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.InvokeEvent.INVOKE_invoke"><apiName>invoke</apiName><shortdesc>
	 Distribué lorsqu’une application est invoquée.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.InvokeEvent.INVOKE</apiEventType><adobeApiEventClassifier>flash.events.InvokeEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsqu’une application est invoquée. 
	 
	 <p>La seconde invocation d’une application ne démarre pas une autre occurrence de l’application. A la place, la première occurrence reçoit un événement invoke supplémentaire. L’application est chargée de gérer les prochains événements <codeph>invoke</codeph> de façon appropriée.</p>
	 
	 <p><b>Remarque :</b> tous les événements <codeph>invoke</codeph> sont mis en file d’attente. Lorsqu’un écouteur est enregistré pour cet événement, il reçoit tous les événements de la file d’attente, ainsi que les nouveaux événements. Les événements placés en file d’attente peuvent être délivrés avant ou après les nouveaux événements <codeph>invoke</codeph>.</p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.desktop:NativeApplication:activate"><apiName>activate</apiName><shortdesc>
         Active cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet NativeWindow de la fenêtre à activer en même temps que l’application.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         Active cette application. 
         
         <p>Selon les circonstances déterminées par le système d’exploitation, cette méthode n’active pas d’application. La plupart des systèmes d’exploitation limitent la capacité d’une application à s’activer elle-même pour qu’elle ne puisse pas empêcher l’utilisateur d’employer d’autres applications, accidentellement ou non.</p>
         
         <p>Si le système d’exploitation autorise l’activation, la fenêtre spécifiée est activée et ramenée au premier plan, c’est-à-dire par-dessus les fenêtres des autres applications éventuellement ouvertes (si le paramètre <codeph>window</codeph> est <codeph>null</codeph>, une fenêtre visible de cette application est activée).</p>
         
         <p>La méthode <codeph>activate()</codeph> na pas d’effet si l’application n’a pas de fenêtre visible.</p>
		 
		 <p>L’opération active est synchrone.</p>
		 
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.desktop:NativeApplication:activate_activate"><apiName>activate</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué si l’état de l’activation change.
         
         </apiDesc></adobeApiEventDetail><shortdesc>Distribué si l’état de l’activation change.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.desktop:NativeApplication:addEventListener"><apiName>addEventListener</apiName><shortdesc>
		
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction d’écouteur qui traite l’événement. Cette fonction doit accepter un objet Event comme paramètre unique et ne rien renvoyer<ph platform="actionscript">, comme illustré ci-dessous :</ph><ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Le nom de cette fonction n’a aucune importance.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Ce paramètre s’applique aux objets d’affichage dans l’architecture de la liste d’affichage ActionScript 3.0, utilisés par le contenu SWF.</ph> <ph platform="actionscript">Détermine si l’écouteur est actif pendant la phase de capture ou pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, l’écouteur traite l’événement uniquement pendant la phase de capture et non pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>false</codeph>, l’écouteur traite l’événement uniquement pendant les phases cible et de propagation vers le haut. Pour écouter l’événement dans les trois phases, appelez <codeph>addEventListener</codeph> à deux reprises, une première fois en définissant <codeph>useCapture</codeph> sur <codeph>true</codeph>, puis une nouvelle fois en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Niveau de priorité de l’écouteur d’événement. La priorité est indiquée par un entier signé de 32 bits. Plus le nombre est élevé, plus la priorité est élevée. Tous les écouteurs dont la priorité correspond à <i>n</i> sont traités avant les écouteurs dotés de la priorité <i>n</i> -1. Les écouteurs dont la priorité est identique sont traités dans l’ordre où ils ont été ajoutés. La priorité par défaut est 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Détermine si la référence à l’écouteur est forte ou faible. Une référence forte (valeur par défaut) empêche le nettoyage de votre écouteur, Cela n’est pas le cas avec une référence faible. <p>Les fonctions de membres de niveau classe n’étant pas soumises au nettoyage, vous pouvez définir <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour ces fonctions. Si vous définissez <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour un écouteur correspondant à une fonction imbriquée interne, la fonction sera nettoyée et ne sera donc pas permanente. Si vous créez des références à la fonction interne (enregistrée dans une autre variable), celle-ci n’est pas nettoyée et reste permanente.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
		
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement. <ph platform="actionscript">Vous pouvez enregistrer les écouteurs d’événement dans tous les nœuds de la liste d’affichage pour un type spécifique d’événement, de phase et de priorité.</ph>
	
	<p platform="javascript">Le code JavaScript dans le moteur d’exécution AIR utilise cette méthode pour enregistrer des écouteurs d’événements définis par les API AIR. Pour d’autres événements JavaScript (tels que l’événement <codeph>onload</codeph> de l’objet <codeph>body</codeph> DOM), vous pouvez utiliser des techniques de gestion d’événements standard, comme vous le feriez pour le contenu exécuté dans le navigateur.</p>
	
	<p>Après l’enregistrement d’un écouteur d’événement, vous ne pouvez plus modifier sa priorité par d’autres appels de <codeph>addEventListener()</codeph>. Pour modifier la priorité d’un écouteur, vous devez d’abord appeler <codeph>removeListener()</codeph>. Vous pouvez ensuite réenregistrer l’écouteur avec le nouveau niveau de priorité. </p>
	
	<p>N’oubliez pas qu’une fois l’écouteur enregistré, tous les prochains appels de <codeph>addEventListener()</codeph> avec une valeur <codeph>type</codeph> ou <codeph>useCapture</codeph> différente entraîneront la création d’un autre enregistrement d’écouteur. <ph platform="actionscript">Si, par exemple, vous enregistrez un écouteur dans lequel la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, il écoute uniquement pendant la phase de capture. Si vous appelez <codeph>addEventListener()</codeph> à l’aide du même objet écouteur, mais en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>, vous obtenez deux écouteurs distincts : l’un qui écoute pendant la phase de capture et l’autre qui écoute pendant les phases cible et de propagation vers le haut (bubbling).</ph>
	</p>
	
	<p platform="actionscript">Il est impossible d’enregistrer un écouteur d’événement uniquement pour la phase cible ou la phase de propagation vers le haut. Ces deux phases sont associées pendant l’enregistrement car la propagation vers le haut s’applique uniquement aux ancêtres du nœud cible.</p>
	
	<p>Si vous n’avez plus besoin d’un écouteur d’événements, supprimez-le en appelant <codeph>removeEventListener()</codeph>, afin d’éviter tout problème de mémoire. Les écouteurs d’événement ne sont pas automatiquement supprimés de la mémoire, car le nettoyeur de mémoire ne supprime pas l’écouteur tant que l’objet de distribution existe (à moins que le paramètre <codeph>useWeakReference</codeph> ne soit défini sur <codeph>true</codeph>).</p>
		
	<p>Lors de la copie d’une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés ne sont pas pris en compte (si le nouveau nœud nécessite un écouteur d’événement, vous devez associer celui-ci après la création du nœud). Toutefois, si vous déplacez une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés la suivent.</p>
	
	
	<p platform="actionscript">Si un écouteur d’événement est enregistré sur un nœud alors qu’un événement est en cours de traitement sur ce nœud, l’écouteur n’est pas déclenché pendant la phase actuelle, mais il peut l’être pendant une phase ultérieure du flux d’événements, telle que la phase de propagation vers le haut (bubbling).</p>
	
	<p platform="actionscript">Si un écouteur d’événement est supprimé d’un nœud sur lequel un événement est en cours de traitement, il est cependant déclenché par les actions en cours. Une fois supprimé, l’écouteur d’événement n’est plus jamais appelé (à moins d’être réenregistré à des fins de traitement ultérieur). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:clear"><apiName>clear</apiName><shortdesc>
         Invoque une commande de suppression interne sur l’objet d’affichage qui a le focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Invoque une commande de suppression interne sur l’objet d’affichage qui a le focus.
		 
         <p>Cet appel de fonction est ignoré si l’objet qui a le focus n’implémente pas la commande. Seuls les objets d’affichage descendant des classes TextField ou HTMLLoader peuvent implémenter cette commande actuellement.</p>
         
         <p><b>Remarque :</b> la commande <codeph>clear()</codeph> supprime le texte sélectionné. Si rien n’est sélectionné, l’ensemble du texte n’est pas supprimé.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:copy"><apiName>copy</apiName><shortdesc>
         Invoque une commande de copie interne sur l’objet d’affichage qui a le focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Invoque une commande de copie interne sur l’objet d’affichage qui a le focus.
         
         <p>Cet appel de fonction est ignoré si le composant n’implémente pas la commande. Seuls les objets d’affichage descendant des classes TextField ou HTMLLoader peuvent implémenter cette commande actuellement.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:cut"><apiName>cut</apiName><shortdesc>
         Invoque une commande de coupe interne sur l’objet d’affichage qui a le focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Invoque une commande de coupe interne sur l’objet d’affichage qui a le focus.
		 
         <p>Cet appel de fonction est ignoré si le composant n’implémente pas la commande. Seuls les objets d’affichage descendant des classes TextField ou HTMLLoader peuvent implémenter ces commandes actuellement.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
		
	Distribue un événement dans le flux d’événements.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Une valeur <codeph>true</codeph> si l’événement a bien été distribué. La valeur <codeph>false</codeph> indique un échec ou que <codeph>preventDefault()</codeph> a été appelé sur l’événement.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>Objet Event qui est distribué dans le flux d’événements. Si l’événement est redistribué, un clone est automatiquement créé. Après la distribution d’un événement, il est impossible de modifier sa propriété <codeph>target</codeph>. Pour que la redistribution fonctionne, vous devez donc créer une copie de l’événement.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
		
	Distribue un événement dans le flux d’événements. La cible de l’événement est l’objet EventDispatcher sur lequel la méthode <codeph>dispatchEvent()</codeph> est appelée.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:exit"><apiName>exit</apiName><shortdesc>
		 Met fin à cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>errorCode</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Code de fermeture signalé au système d’exploitation lors de la fermeture de cette application.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Met fin à cette application. 
		 
		 <p>L’appel à la méthode <codeph>exit()</codeph> <i>renverra</i> ; la séquence de fermeture ne commence pas avant la fin du code en cours d’exécution (par exemple un gestionnaire d’événement en cours). Les opérations asynchrones en attente sont annulées et peuvent ou non être terminées.</p>
		 
		 <p>Notez qu’aucun événement <codeph>exiting</codeph> n’est déclenché. Si un événement <codeph>exiting</codeph> est requis par la logique de l’application, appelez <codeph>NativeApplication.nativeApplication.dispatchEvent()</codeph> en transmettant un objet Event de type <codeph>exiting</codeph>. De même, aucun événement <codeph>closing</codeph> ou <codeph>close</codeph> n’est déclenché avant la fermeture des fenêtres de l’application. Si des fenêtres doivent être averties avant la fermeture de votre application, vous pouvez déclencher des événements <codeph>closing</codeph> pour chaque fenêtre ouverte. Si un événement <codeph>close</codeph> est requis pour une fenêtre, appelez la méthode <codeph>close()</codeph> de la fenêtre avant la fermeture.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:getDefaultApplication"><apiName>getDefaultApplication</apiName><shortdesc>
		 Récupère l’application par défaut pour ouvrir les fichiers présentant l’extension spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>extension</codeph> ne contient pas l’une des extensions de fichier déclarées dans le descripteur de l’application.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Chemin de l’application par défaut.
		 
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne contenant l’extension du type de fichier visé (sans le « . »).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Récupère l’application par défaut pour ouvrir les fichiers présentant l’extension spécifiée.
		 
		 <p><b>Remarque :</b> cette méthode ne peut être utilisée qu’avec les types de fichiers déclarés dans l’instruction <codeph>fileTypes</codeph> du descripteur de l’application.</p>
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:NativeApplication:isSetAsDefaultApplication"><apiName>isSetAsDefaultApplication</apiName><shortdesc>
		 Spécifie si cette application est actuellement attribuée par défaut pour ouvrir les fichiers portant l’extension spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>extension</codeph> ne contient pas l’une des extensions de fichier déclarées dans le descripteur de l’application.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> s’il s’agit bien de l’application par défaut.
		 
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne contenant l’extension du type de fichier visé (sans le « . »).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Spécifie si cette application est actuellement attribuée par défaut pour ouvrir les fichiers portant l’extension spécifiée.
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:NativeApplication:paste"><apiName>paste</apiName><shortdesc>
         Invoque une commande de collage interne sur l’objet d’affichage qui a le focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Invoque une commande de collage interne sur l’objet d’affichage qui a le focus.
		 
         <p>Cet appel de fonction est ignoré si le composant n’implémente pas la commande. Seuls les objets d’affichage descendant des classes TextField ou HTMLLoader peuvent implémenter cette commande actuellement.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:removeAsDefaultApplication"><apiName>removeAsDefaultApplication</apiName><shortdesc>
		 Supprime cette application en tant qu’application par défaut pour ouvrir les fichiers portant l’extension spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>extension</codeph> ne contient pas l’une des extensions de fichier déclarées dans le descripteur de l’application.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne contenant l’extension du type de fichier visé (sans le « . »).
         
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Supprime cette application en tant qu’application par défaut pour ouvrir les fichiers portant l’extension spécifiée.
		 
		 <p><b>Remarque :</b> cette méthode ne peut être utilisée qu’avec les types de fichiers énumérés dans l’instruction <codeph>fileTypes</codeph> du descripteur de l’application.</p>
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:NativeApplication:removeEventListener"><apiName>removeEventListener</apiName><shortdesc>
		
	Supprime un écouteur de l’objet EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Objet écouteur à supprimer.
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Ce paramètre s’applique aux objets d’affichage dans l’architecture de la liste d’affichage ActionScript 3.0, utilisés par le contenu SWF.</ph><ph platform="actionscript">Indique si l’écouteur a été enregistré pendant la phase de capture ou pendant les phases cible et de propagation vers le haut (bubbling). Si l’écouteur a été enregistré pendant la phase de capture et pendant les phases cible et de propagation vers le haut (bubbling), il est nécessaire d’appeler <codeph>removeEventListener()</codeph> à deux reprises pour le supprimer. Appelez <codeph>useCapture()</codeph> une première fois en la définissant sur <codeph>true</codeph>, puis une seconde fois <codeph>useCapture()</codeph> en la définissant sur <codeph>false</codeph>.</ph>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
		
	Supprime un écouteur de l’objet EventDispatcher. Si aucun écouteur correspondant n’est enregistré auprès de l’objet EventDispatcher, l’appel de cette méthode n’a aucun effet.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:selectAll"><apiName>selectAll</apiName><shortdesc>
         Invoque une commande selectAll interne sur l’objet d’affichage qui a le focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Invoque une commande selectAll interne sur l’objet d’affichage qui a le focus.
		 
         <p>Cet appel de fonction est ignoré si le composant n’implémente pas la commande. Seuls les objets d’affichage descendant des classes TextField ou HTMLLoader peuvent implémenter cette commande actuellement.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:setAsDefaultApplication"><apiName>setAsDefaultApplication</apiName><shortdesc>
		 Définit cette application comme l’application par défaut pour ouvrir les fichiers portant l’extension spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>extension</codeph> ne contient pas l’une des extensions de fichier déclarées dans le descripteur de l’application.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne contenant l’extension du type de fichier visé (sans le « . »).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Définit cette application comme l’application par défaut pour ouvrir les fichiers portant l’extension spécifiée.
		 
		 <p><b>Remarque :</b> cette méthode ne peut être utilisée qu’avec les types de fichiers déclarés dans l’instruction <codeph>fileTypes</codeph> du descripteur de l’application.</p>
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:NativeApplication:activeWindow:get"><apiName>activeWindow</apiName><shortdesc>
         Fenêtre de l’application active.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
         Fenêtre de l’application active. 
		 
		 <p>Si la fenêtre du bureau active n’appartient pas à cette application ou s’il n’y a pas de fenêtre active, la propriété <codeph>activeWindow</codeph> est <codeph>null</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:applicationDescriptor:get"><apiName>applicationDescriptor</apiName><shortdesc> 
		 Contenu du fichier descripteur de cette application AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>XML</apiValueClassifier></apiValueDef><apiDesc> 
		 Contenu du fichier descripteur de cette application AIR.
		 
		 <p platform="javascript">Le code ActionScript 3.0 des fichiers SWF prend en charge la syntaxe E4X pour travailler avec des données XML. Toutefois, dans les applications AIR de type HTML, vous souhaiterez convertir la valeur XML de cette propriété en objet DOMParser, avec la méthode <codeph>parseFromString()</codeph> d’un objet DOMParser.</p>
		 
		 </apiDesc><example conref="examples\NativeApplication.applicationDescriptor.1.as"> L’exemple suivant lit les éléments <codeph>copyright</codeph> et <codeph>version</codeph> dans le fichier descripteur de l’application. Notez que vous devez utiliser l’espace de nom par défaut défini dans le descripteur d’application XML.
<codeblock>
var appDescriptor:XML = NativeApplication.nativeApplication.applicationDescriptor;
var ns:Namespace = appDescriptor.namespace();
var appCopyright:String = appDescriptor.ns::copyright;
var appVersion:String = appDescriptor.ns::version;
trace("appId:", appCopyright);
trace("version:", appVersion);
</codeblock><swfblock conref="examples\NativeApplication.applicationDescriptor.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:applicationID:get"><apiName>applicationID</apiName><shortdesc> 
		 ID d’application de cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
		 ID d’application de cette application. 
		 
		 <p>La valeur de cet ID est définie dans le fichier descripteur de l’application.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:autoExit:get"><apiName>autoExit</apiName><shortdesc>
		 Spécifie si l’application doit se fermer automatiquement lorsque toutes les fenêtres ont été fermées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		 Spécifie si l’application doit se fermer automatiquement lorsque toutes les fenêtres ont été fermées.  
		 
		 <p>Lorsque <codeph>autoExit</codeph> est <codeph>true</codeph>, par défaut, l’application s’interrompt lorsque toutes ses fenêtres ont été fermées. Les événements <codeph>exiting</codeph> et <codeph>exit</codeph> sont tous deux déclenchés. Lorsque <codeph>autoExit</codeph> est <codeph>false</codeph>, vous devez appeler <codeph>NativeApplication.nativeApplication.exit()</codeph> pour fermer l’application. </p> 
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:icon:get"><apiName>icon</apiName><shortdesc>
		 Icône de l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:InteractiveIcon</apiValueClassifier></apiValueDef><apiDesc>
		 Icône de l’application.
		 
		 <p>Utilisez <codeph>NativeApplication.supportsDockIcon</codeph> et <codeph>NativeApplication.supportsSystemTrayIcon</codeph> pour déterminer la classe icon. Le type sera l’une des sous-classes d’InteractiveIcon. Sous Mac<sup>®</sup> OS X, <codeph>NativeApplication.icon</codeph> est un objet de type <codeph>DockIcon</codeph>. Sous Windows<sup>®</sup>, <codeph>NativeApplication.icon</codeph> est un objet de type <codeph>SystemTrayIcon</codeph>. Sous Linux, l’icône d’une application n’est pas toujours prise en charge. Le cas échéant, la propriété <codeph>icon</codeph> est <codeph>null</codeph>.</p>  
		 
		 <p>L’objet <codeph>icon</codeph> est créé automatiquement mais n’est pas initialisé avec les données d’image. Sous certains systèmes d’exploitation, tels que Mac OS X, une image par défaut est fournie. Avec d’autres, tels que Windows, l’icône n’est pas affichée à moins que des données d’image ne lui soient affectées. Pour affecter une image d’icône, définissez la propriété <codeph>icon.bitmaps</codeph> avec un tableau contenant au moins un objet BitmapData. Si le tableau comprend plusieurs objets BitmapData, le système d’exploitation choisit l’image dont la taille est la plus proche des dimensions d’affichage de l’icône, en la mettant à l’échelle si nécessaire.</p>  
   		 
         </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/supportsDockIcon"><linktext>supportsDockIcon</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsSystemTrayIcon"><linktext>supportsSystemTrayIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:idleThreshold:get"><apiName>idleThreshold</apiName><shortdesc>
		 Nombre de secondes devant s’écouler sans saisie du clavier ou action de la souris avant qu’un événement userIdle ne soit distribué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Si vous tentez de définir la propriété sur une valeur non valide. La plage acceptable des valeurs est comprise entre 5 (5 secondes) et 86 400 (1 jour), inclus. 
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
		 Nombre de secondes devant s’écouler sans saisie du clavier ou action de la souris avant qu’un événement <codeph>userIdle</codeph> ne soit distribué. 
		 
		 <p>Par défaut, le seuil d’inactivité est de 300 secondes (5 minutes). La plage acceptable des valeurs est comprise entre 5 (5 secondes) et 86 400 (1 jour), inclus. </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/event:userIdle"><linktext>userIdle</linktext></link><link href="flash.desktop.xml#NativeApplication/event:userPresent"><linktext>userPresent</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:menu:get"><apiName>menu</apiName><shortdesc>
		 Menu de l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Menu de l’application.
		 
		 <p>Les menus de l’application sont pris en charge lorsque <codeph>NativeApplication.nativeApplication.supportsMenu</codeph> est <codeph>true</codeph>. Les menus d’application ne sont pas pris en charge par tous les systèmes d’exploitation. Par exemple, ils sont pris en charge par Mac OS X, mais pas par Windows ou Linux. L’affectation d’un objet NativeMenu à cette propriété lorsque <codeph>NativeApplication.nativeApplication.supportsMenu</codeph> est <codeph>false</codeph> est autorisée, mais n’a aucun effet. Utilisez la propriété <codeph>NativeApplication.nativeApplication.supportsMenu</codeph> pour déterminer si le système d’exploitation prend en charge les menus de l’application. Faire appel à d’autres méthodes (comme <codeph>Capabilities.os</codeph>) pour déterminer les prises en charge peut entraîner des erreurs de programmation (si certains systèmes d’exploitation cible possibles ne sont pas pris en compte). </p>
		 
         <p><b>Remarque :</b> sous Mac OS X, la propriété <codeph>menu</codeph> fait référence au menu d’application par défaut fourni par le système d’exploitation. Vous pouvez modifier la structure du menu existant en ajoutant et en supprimant des éléments et des sous-menus, et en ajoutant des écouteurs d’événement. Vous pouvez également remplacer entièrement les menus par défaut en affectant un nouvel objet NativeMenu à cette propriété <codeph>menu</codeph>.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:nativeApplication:get"><apiName>nativeApplication</apiName><shortdesc> 
		 Occurrence singleton de l’objet NativeApplication.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:NativeApplication</apiValueClassifier><apiException><apiDesc>Si accédé par du contenu extérieur au sandbox de sécurité de l’application.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
		 Occurrence singleton de l’objet NativeApplication.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:openedWindows:get"><apiName>openedWindows</apiName><shortdesc>
		 Tableau contenant toutes les fenêtres natives et ouvertes de cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 Tableau contenant toutes les fenêtres natives et ouvertes de cette application.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:publisherID:get"><apiName>publisherID</apiName><shortdesc> 
		 ID d’éditeur de cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
		 ID d’éditeur de cette application. 
		 
		 <p>La valeur de cet ID est définie dans le fichier publisherid de l’application, généré au moment de l’installation à partir de la chaîne de certificat utilisée pour signer l’application.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:runtimePatchLevel:get"><apiName>runtimePatchLevel</apiName><shortdesc> 
		 Niveau de correctif du moteur d’exécution hébergeant cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		 Niveau de correctif du moteur d’exécution hébergeant cette application.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:runtimeVersion:get"><apiName>runtimeVersion</apiName><shortdesc> 
		 Numéro de version du moteur d’exécution hébergeant cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
		 Numéro de version du moteur d’exécution hébergeant cette application.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:startAtLogin:set"><apiName>startAtLogin</apiName><shortdesc>
        Spécifie si cette application se lance automatiquement dès que l’utilisateur actuel se connecte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Sous Windows, lorsqu’une autre application portant le même nom (mais dont le chemin du fichier exécutable diffère) est déjà définie pour démarrer lorsque cet utilisateur ouvre une session.
        
        </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si cette application n’est pas installée, ce qui peut être le cas lorsqu’elle est lancée par l’application de débogage du lanceur AIR (ADL).
        
		</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
        Spécifie si cette application se lance automatiquement dès que l’utilisateur actuel se connecte.
        
        <p>
        La propriété <codeph>startAtLogin</codeph> reflète l’état du mécanisme défini par le système d’exploitation pour indiquer qu’une application doit démarrer automatiquement lorsqu’un utilisateur se connecte. L’utilisateur peut modifier l’état manuellement via l’interface utilisateur du système d’exploitation. Cette propriété reflète l’état actuel, qu’il ait été modifié pour la dernière fois par l’application AIR ou par le système d’exploitation.   
        </p>
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:supportsDockIcon:get"><apiName>supportsDockIcon</apiName><shortdesc> 
	   Indique si AIR prend en charge les icônes du Dock de l’application dans le système d’exploitation actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	   Indique si AIR prend en charge les icônes du Dock de l’application dans le système d’exploitation actuel.
	  
	  <p>Si <codeph>true</codeph>, la propriété <codeph>NativeApplication.icon</codeph> est de type <codeph>DockIcon</codeph>.</p>
	  
      <p>Mac OS X et diverses interfaces de Linux<sup>®</sup> fournissent un « Dock » d’applications contenant des icônes qui permettent d’exécuter les applications fréquemment utilisées.</p>
	  
	  <p>Utilisez la propriété <codeph>NativeApplication.supportsDockIcon</codeph> pour déterminer si le système d’exploitation prend en charge les icônes d’ancrage de l’application. Faire appel à d’autres méthodes (comme <codeph>Capabilities.os</codeph>) pour déterminer les prises en charge peut entraîner des erreurs de programmation (si certains systèmes d’exploitation cible possibles ne sont pas pris en compte). </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>icône</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
	   Spécifie si le système d’exploitation actuel prend en charge une barre de menus d’application globale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	   Spécifie si le système d’exploitation actuel prend en charge une barre de menus d’application globale.
	  
	  <p>Lorsque sa valeur est <codeph>true</codeph>, la propriété <codeph>NativeApplication.menu</codeph> peut être utilisée pour définir (ou accéder à) un menu d’application natif.</p> 
	  
	  <p>Utilisez la propriété <codeph>NativeApplication.supportsMenu</codeph> pour déterminer si le système d’exploitation prend en charge la barre de menus de l’application. Faire appel à d’autres méthodes (comme <codeph>Capabilities.os</codeph>) pour déterminer les prises en charge peut entraîner des erreurs de programmation (si certains systèmes d’exploitation cible possibles ne sont pas pris en compte). </p>
	  
      </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/menu"><linktext>menu</linktext></link><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:supportsSystemTrayIcon:get"><apiName>supportsSystemTrayIcon</apiName><shortdesc> 
	  Spécifie si AIR prend en charge les icônes de la barre d’état système dans le système d’exploitation en cours.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	  Spécifie si AIR prend en charge les icônes de la barre d’état système dans le système d’exploitation actuel.
	  
	  <p>Si <codeph>true</codeph>, la propriété <codeph>NativeApplication.icon</codeph> est de type <codeph>SystemTrayIcon</codeph>.</p>
	  
	  <p>Utilisez la propriété <codeph>NativeApplication.supportsSystemTrayIcon</codeph> pour déterminer si le système d’exploitation prend en charge les icônes de la barre d’état système. Faire appel à d’autres méthodes (comme <codeph>Capabilities.os</codeph>) pour déterminer les prises en charge peut entraîner des erreurs de programmation (si certains systèmes d’exploitation cible possibles ne sont pas pris en compte). </p>
	  
      <p><b>Remarque :</b> sous Windows, la zone d’état système de la barre des tâches est officiellement appelée <i>Zone de notification</i>.</p> 
      
      </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>icône</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:timeSinceLastUserInput:get"><apiName>timeSinceLastUserInput</apiName><shortdesc>
         Durée écoulée, en secondes, depuis la dernière entrée de la souris ou du clavier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Durée écoulée, en secondes, depuis la dernière entrée de la souris ou du clavier.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/event:userIdle"><linktext>userIdle</linktext></link><link href="flash.desktop.xml#NativeApplication/event:userPresent"><linktext>userPresent</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.desktop:Updater"><apiName>Updater</apiName><shortdesc>
     La classe Updater est utilisée pour mettre à jour l’application en cours d’exécution avec une version différente.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     La classe Updater est utilisée pour mettre à jour l’application en cours d’exécution avec une version différente. Pour l’utiliser, instanciez un objet Updater, puis appelez sa méthode <codeph>update()</codeph>.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="air.update.xml#ApplicationUpdater"><linktext>air.update.ApplicationUpdater</linktext></link><link href="air.update.xml#ApplicationUpdaterUI"><linktext>air.update.ApplicationUpdaterUI</linktext></link></related-links><apiConstructor id="flash.desktop:Updater:Updater"><apiName>Updater</apiName><shortdesc>
         Fonction constructeur de la classe Updater.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
         Fonction constructeur de la classe Updater. Notez que la méthode <codeph>update()</codeph> n’est pas un membre statique de la classe. Vous devez instancier un objet Updater et appeler la méthode <codeph>update()</codeph> sur ce dernier.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.desktop:Updater:update"><apiName>update</apiName><shortdesc>
         Actualise l’application en cours d’exécution avec la version de l’application contenue dans le fichier AIR spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La méthode a été appelée alors qu’elle s’exécutait dans ADL. 
		 
		 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>airFile</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>Objet File pointant vers le fichier AIR contenant la version de mise à jour de l’application.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>version</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Version requise dans le nouveau fichier AIR. La chaîne de l’attribut <codeph>version</codeph> de l’élément <codeph>application</codeph> principal du fichier descripteur d’application du fichier AIR doit correspondre à cette valeur pour que la mise à jour réussisse.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         Actualise l’application en cours d’exécution avec la version de l’application contenue dans le fichier AIR spécifié. L’identificateur de l’application (<codeph>appID</codeph>) du fichier AIR doit correspondre à celui de l’application en cours d’exécution.
		 
         <p>Un appel à cette méthode entraîne la fermeture de l’application en cours (comme si la méthode <codeph>NativeApplication.exit()</codeph> avait été appelée). Cette opération est nécessaire car Adobe AIR ne peut pas procéder à la mise à jour complète de l’application si cette dernière est en cours d’exécution. Après une installation réussie de la nouvelle version de l’application, cette dernière démarre. Si le moteur d’exécution ne peut pas installer la nouvelle version (par exemple si son ID d’application ne correspond pas à la version existante), le programme d’installation AIR présente un message d’erreur à l’utilisateur et l’ancienne version redémarre.</p>
		 
		 <p>Le processus de mise à jour redémarre l’application, que la mise à jour ait réussi ou non. La mise à jour peut échouer pour diverses raisons, y compris pour des raisons que l’application ne peut pas contrôler (par exemple lorsque l’utilisateur ne dispose pas de privilèges suffisants pour installer l’application). Les applications doivent s’efforcer de détecter les défaillances et éviter de recommencer encore et encore la même mise à jour en échec. La boucle infinie qui en résulterait désactiverait radicalement l’application. Ecrire le numéro de version actuelle dans un fichier avant de commencer la mise à jour, puis comparer ce numéro au numéro de version lorsque l’application est redémarrée est un moyen de vérifier la réussite de la mise à jour.</p>
		 
		 <p>Lorsqu’une application est testée à l’aide de l’application de débogage du lanceur AIR (ADL), un appel à la méthode <codeph>update()</codeph> renvoie une exception IllegalOperationError.</p>
		 
		 <p>Pour installer la version mise à jour d’une application sous Mac OS, l’utilisateur doit disposer des privilèges système adéquats sur le répertoire de l’application. Sous Windows ou Linux, l’utilisateur doit disposer de privilèges administratifs. </p>
		 
		 <p>Si la version mise à jour de l’application requiert une mise à jour du moteur d’exécution, la nouvelle version du moteur est installée. Pour mettre à jour le moteur d’exécution, l’utilisateur doit disposer de privilèges administratifs sur l’ordinateur.</p>
		 
		 <p><i>Remarque :</i> par mesure de sécurité, la définition du paramètre <codeph>version</codeph> est obligatoire. Obliger l’application à vérifier le numéro de version dans le fichier AIR l’empêche d’installer par inadvertance une version plus ancienne, pouvant éventuellement contenir une faille de sécurité corrigée.</p>
		 
		 </apiDesc><example conref="examples\Updater.update.1.as"> Notez que la méthode <codeph>update()</codeph> n’est <i>pas</i> une méthode statique de la classe. Vous instanciez un objet Updater et appelez la méthode <codeph>update()</codeph> de cet objet.
<codeblock>
import flash.fileSystem.File;
import flash.desktop.Updater;
 
var updater:Updater = new Updater();
var airFile:File = File.applicationStore.resolvePath("Example Application.air");
var version:String = "2.01";
updater.update(airFile, version);
</codeblock></example></apiOperationDetail><related-links><link href="air.update.xml#ApplicationUpdater"><linktext>air.update.ApplicationUpdater</linktext></link><link href="air.update.xml#ApplicationUpdaterUI"><linktext>air.update.ApplicationUpdaterUI</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.desktop:SystemTrayIcon"><apiName>SystemTrayIcon</apiName><shortdesc>
	 La classe SystemTrayIcon représente l’icône de style de la zone de notification de la barre des tâches de Windows (barre d’état système).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.desktop:InteractiveIcon</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe SystemTrayIcon représente l’icône de style de la zone de notification de la barre des tâches de Windows<sup>®</sup> (barre d’état système).
	 
	 <p>Tous les systèmes d’exploitation n’ont pas d’icônes de barre d’état système. Pour savoir si les icônes de barre d’état système sont prises en charge par le système en cours, vérifiez <codeph>NativeApplication.supportsSystemTrayIcon</codeph>.</p>
	 
	 <p>Il n’est pas possible de créer une occurrence de la classe SystemTrayIcon. Récupérez l’objet représentant l’icône de barre d’état système dans la propriété <codeph>icon</codeph> de l’objet NativeApplication « global ».
	 </p>
	 
	 <p>Lorsque ces icônes sont prises en charge, l’icône est de type <i>SystemTrayIcon</i>. Autrement, le type de <codeph>icon</codeph> est une autre sous-classe de InteractiveIcon, en général DockIcon.</p>
	 
	 
	 <p><b>Important :</b> une tentative d’appel à une méthode de la classe SystemTrayIcon sur l’objet <codeph>NativeApplication.icon</codeph> dans un système d’exploitation pour lequel AIR ne prend pas en charge les icônes de barre d’état système génère une exception à l’exécution.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsSystemTrayIcon"><linktext>flash.desktop.NativeApplication.supportsSystemTrayIcon</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link></related-links><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur clique du bouton droit de sa souris.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur clique du bouton droit de sa souris.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur relâche le bouton droit de sa souris.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur relâche le bouton droit de sa souris.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur enfonce le bouton droit de sa souris.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur enfonce le bouton droit de sa souris.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur clique avec sa souris.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur clique avec sa souris.
 	 
 	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur relâche le bouton de sa souris.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur relâche le bouton de sa souris.
 	 
 	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur enfonce le bouton de sa souris.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 	 Distribué par cet objet SystemTrayIcon lorsque l’utilisateur enfonce le bouton de sa souris.
 	 
 	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiValue id="flash.desktop:SystemTrayIcon:MAX_TIP_LENGTH"><apiName>MAX_TIP_LENGTH</apiName><shortdesc>
		 Longueur autorisée de l’info-bulle de l’icône de la barre d’état système.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>63</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Longueur autorisée de l’info-bulle de l’icône de la barre d’état système.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:bitmaps:get"><apiName>bitmaps</apiName><shortdesc> 
		
		  
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc> 
		
		  
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.
	   
	 <p>Lorsqu’une icône est affichée dans le contexte d’un certain système d’exploitation, l’image bitmap du tableau se rapprochant le plus de la taille affichée est utilisée (et éventuellement mise à l’échelle). Les tailles courantes sont 16x16, 32x32, 48x48 et 128x128 (des icônes de 512x512 pixels peuvent être utilisées pour des système d’exploitation futurs).</p>
	 
	 <p>Dans certains cas, le système d’exploitation peut utiliser une icône système par défaut lorsque rien n’a été affecté à la propriété <codeph>bitmaps</codeph>. Dans d’autres cas, aucune icône n’apparaît.</p>
	 
	 <p>Pour définir ou modifier l’apparence de l’icône, affectez un tableau d’objets bitmapData à la propriété <codeph>bitmaps</codeph> :</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>La modification directe du tableau <codeph>bitmaps</codeph> n’a aucun effet.</p>
	 
	 <p>Pour effacer l’image de l’icône, affectez un tableau vide à la propriété <codeph>bitmaps</codeph>.</p>
	 
	 <p>
	 <b>Remarque :</b> lors du chargement de fichiers image pour une icône, le format de fichier PNG fournit généralement le meilleur fondu alpha. Le format GIF ne prend en charge que l’activation ou la désactivation de la transparence (pas le fondu). Le format JPG ne prend pas en charge la transparence du tout.  
	 </p>
	  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:height:get"><apiName>height</apiName><shortdesc> 
		
		 Hauteur d’affichage actuelle de l’icône, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Hauteur d’affichage actuelle de l’icône, en pixels.
		 
		 <p>Certains contextes d’icône prennent en charge les tailles dynamiques. La propriété <codeph>height</codeph> indique la hauteur de l’icône choisie dans le tableau <codeph>bitmaps</codeph> pour le contexte actuel. La hauteur d’affichage réelle peut être différente si le système d’exploitation a mis l’icône à l’échelle.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:menu:get"><apiName>menu</apiName><shortdesc>
		 Menu de l’icône de barre d’état système.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Menu de l’icône de barre d’état système.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:tooltip:get"><apiName>tooltip</apiName><shortdesc>
		 Info-bulle qui s’affiche pour l’icône de barre d’état système.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Info-bulle qui s’affiche pour l’icône de barre d’état système. Si la longueur est supérieure à <codeph>SystemTrayIcon.MAX_TIP_LENGTH</codeph>, l’info-bulle est tronquée.
		 
	     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:width:get"><apiName>width</apiName><shortdesc> 
		
		 Largeur d’affichage actuelle de l’icône, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Largeur d’affichage actuelle de l’icône, en pixels. 
		 
		 <p>Certains contextes d’icône prennent en charge les tailles dynamiques. La propriété <codeph>width</codeph> indique la largeur de l’icône choisie dans le tableau <codeph>bitmaps</codeph> pour le contexte actuel. La largeur d’affichage réelle peut être différente si le système d’exploitation a mis l’icône à l’échelle.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:Clipboard"><apiName>Clipboard</apiName><shortdesc>
 La classe Clipboard fournit un conteneur pour transférer les données et les objets par l’intermédiaire du presse-papiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>NativeDragManager is AIR only and is not in FP10.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Clipboard fournit un conteneur pour transférer les données et les objets par l’intermédiaire du presse-papiers. Dans AIR, la classe Clipboard est également utilisée pour les opérations de glisser-déposer. Le presse-papiers du système d’exploitation est accessible par la propriété statique <codeph>generalClipboard</codeph>.
 
 <p>Un objet Clipboard peut contenir les mêmes informations en plusieurs formats. Le fait de fournir les informations en plusieurs formats augmente les chances qu’une autre application puisse les exploiter. Ajoutez des données dans un objet Clipboard avec la méthode <codeph>setData()</codeph> ou <codeph>setDataHandler()</codeph>.</p> 
 
 <p>Les formats standard sont :</p>
 <ul>
 <li>BITMAP_FORMAT : objet BitmapData (AIR uniquement) </li>
 <li>FILE_LIST_FORMAT: tableau d’objets File (AIR uniquement)</li>
 <li>HTML_FORMAT: données de chaîne au format HTML</li>
 <li>TEXT_FORMAT: données de chaîne</li>
 <li>RICH_TEXT_FORMAT : objet ByteArray contenant des données au format RTF</li>
 <li>URL_FORMAT : chaîne d’URL (AIR uniquement)</li>
 </ul>
 <p>Ces constantes des noms des formats standard sont définies dans la classe ClipboardFormats.</p>
 
 <p>Lors d’un transfert entre Flash Player ou une application AIR et le système d’exploitation, les formats standard sont automatiquement convertis entre les types de données <ph platform="javascript">JavaScript</ph><ph platform="actionscript">ActionScript</ph> et le presse-papiers natif.</p>
 
 <p>Vous pouvez utiliser des formats définis par l’application pour ajouter des objets <ph platform="javascript">JavaScript</ph><ph platform="actionscript">ActionScript</ph> dans un objet Clipboard. Si un objet est sérialisable, une référence et un clone de l’objet peuvent être rendus disponibles. Les références d’objet ne sont valides que dans l’application d’origine.</p>
 
 <p>Lorsque la conversion des informations à transférer en un format particulier réclame des calculs poussés, vous pouvez fournir le nom d’une fonction qui effectue la conversion. La fonction est appelée si, et seulement si, ce format est lu par le composant ou l’application de réception. Ajoutez une fonction de rendu différé à un objet Clipboard avec la méthode <codeph>setDataHandler()</codeph>.</p>
 
 <p><b>Remarque réservée aux applications AIR :</b> les objets Clipboard référencés par les objets événement déclenchés pour les événements de glisser/déposer et de copier/coller HTML ne sont pas du même type que l’objet AIR Clipboard. L’objet Clipboard JavaScript est décrit dans le guide du développeur AIR.</p>
 
 <p>Sous Linux, les données du Presse-papiers ne persistent pas lorsqu’une application AIR se ferme. </p>
  
 </apiDesc><example conref="examples\ClipboardExample.as"> L’exemple suivant, pour Adobe AIR, utilise la classe ClipboardExample pour copier une chaîne d’une variable à l’autre via le Presse-papiers du système. Pour ce faire, procédez comme suit :
 
 <ol>
     <li>Ecrivez les données, dans ce cas une chaîne, dans <codeph>Clipboard.generalClipboard</codeph>.</li>
    <li>Lisez le contenu du presse-papiers dans <codeph>Clipboard.generalClipboard</codeph>.</li>
 </ol>
 <p><b>Remarque :</b> en raison des restrictions d’accès aux données du Presse-papiers, cet exemple ne fonctionne pas dans Flash Player. Dans Flash Player, vous ne pouvez appeler que la méthode <codeph>getData()</codeph> de l’objet Presse-papiers dans un gestionnaire d’événement <codeph>paste</codeph>.</p>
<codeblock>
package
{
    import flash.display.Sprite;
    import flash.desktop.Clipboard;
    import flash.desktop.ClipboardFormats;
    import flash.desktop.ClipboardTransferMode;

    public class ClipboardExample extends Sprite
    {
        public function ClipboardExample()
        {
            var sally:String = "Sally";
            var person:String;
            
            copy(sally);
            person = paste();
            trace(person); //traces: "Sally"
        }

        private function copy(text:String):void 
        {
            Clipboard.generalClipboard.clear();
            Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, text);
        }
        
        private function paste():String
        {
            if(Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT))
            {
                return String(Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT));
            } 
            else 
            {
                return null;
            }
        }
        
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeDragManager"><linktext>flash.desktop.NativeDragManager</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link><link href="flash.desktop.xml#ClipboardTransferMode"><linktext>flash.desktop.ClipboardTransferMode</linktext></link></related-links><apiConstructor id="flash.desktop:Clipboard:Clipboard"><apiName>Clipboard</apiName><shortdesc>
	Crée un objet Clipboard vide.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>the example located at examples\Clipboard.clipboard.1.as should not be displayed with FP10 docs because FP10 will throw an error when new Clipboard() is called.
	</internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc><codeph>new Clipboard()</codeph> n’est pas pris en charge dans Flash Player, car seul le presse-papiers du système d’exploitation peut être utilisé dans Flash Player. Pour les opérations de copier-coller impliquant le presse-papiers du système d’exploitation, utilisez l’objet Clipboard.generalClipboard au lieu de créer un nouvel objet Clipboard. Ne renvoie pas d’erreur dans une application AIR.
	
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
	Crée un objet Clipboard vide.
	
	</apiDesc><example conref="examples\Clipboard.clipboard.1.as"> L’exemple suivant crée un nouveau presse-papiers à utiliser avec la classe NativeDragManager.
 
 <p><b>Remarque :</b> pour les opérations de copier-coller impliquant le presse-papiers du système d’exploitation, utilisez l’objet <codeph>Clipboard.generalClipboard</codeph> au lieu de créer un nouveau presse-papiers.</p>
<codeblock>
 import flash.desktop.Clipboard;
 
 var clipboard:Clipboard = new Clipboard();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.desktop.xml#Clipboard/generalClipboard"><linktext>generalClipboard</linktext></link></related-links></apiConstructor><apiOperation id="flash.desktop:Clipboard:clear"><apiName>clear</apiName><shortdesc>
	Supprime toutes les représentations de données dans cet objet Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	Supprime toutes les représentations de données dans cet objet Clipboard.
	
 	</apiDesc><example conref="examples\Clipboard.clear.1.as"> L’exemple suivant efface le contenu du presse-papiers du système :
<codeblock>
 Clipboard.generalClipboard.clear();
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:Clipboard:clearData"><apiName>clearData</apiName><shortdesc>
	Supprime la représentation des données au format spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Format des données à supprimer.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Supprime la représentation des données au format spécifié.
	
 	</apiDesc><example conref="examples\Clipboard.clearData.1.as"> L’exemple suivant efface toutes les données au format <codeph>ClipboardFormats.TEXT_FORMAT</codeph> dans le presse-papiers du système :
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 Clipboard.generalClipboard.clearData(ClipboardFormats.TEXT_FORMAT);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:Clipboard:getData"><apiName>getData</apiName><shortdesc>
	Récupère les données du presse-papiers si elles sont présentes au format spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>transferMode</codeph> n’est pas l’un des noms définis dans la classe ClipboardTransferMode.
	</apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>L’objet Clipboard demandé n’est plus dans le domaine (AIR uniquement).
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>La lecture ou l’écriture dans le presse-papiers n’est plus autorisée dans ce contexte. Dans Flash Player, l’appel de cette méthode ne réussit que lors du traitement d’un événement <codeph>paste</codeph>. Dans AIR, cette restriction s’applique uniquement au contenu s’exécutant hors du sandbox de sécurité de l’application.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet dont le type correspond au format des données.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Format des données à renvoyer. La chaîne de format peut contenir l’un des noms standard définis dans la classe ClipboardFormats ou un nom défini par l’application.
	</apiDesc></apiParam><apiParam><apiItemName>transferMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>originalPreferred</apiData><apiDesc>Indique si une référence ou une copie sérialisée doit être renvoyée lors d’un accès à un format de données défini par l’application. La valeur doit être l’un des noms définis dans la classe ClipboardTransferMode. Cette valeur est ignorée pour les formats de données standard ; une copie est toujours renvoyée.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Récupère les données du presse-papiers si elles sont présentes au format spécifié.
	
	<p>Avec Flash Player, la méthode <codeph>getData()</codeph> doit être appelée dans un gestionnaire d’événement <codeph>paste</codeph>. Dans AIR, cette restriction s’applique uniquement au contenu s’exécutant hors du sandbox de sécurité de l’application.</p>
	
	<p>Lors d’un accès à un format de données standard, les données sont renvoyées sous forme de nouvel objet de type Flash Player ou AIR correspondant.</p>
	
	<p>Lors d’un accès à un format défini par l’application, la valeur du paramètre <codeph>transferMode</codeph> détermine si une référence à l’objet original ou un objet anonyme contenant une copie sérialisée de l’objet original est renvoyé. Lorsqu’un mode <codeph>originalPreferred</codeph> ou <codeph>clonePreferred</codeph> est spécifié, Flash Player ou AIR renvoie l’autre version lorsque la version favorite n’est pas disponible. Lorsqu’un mode <codeph>originalOnly</codeph> ou <codeph>cloneOnly</codeph> est spécifié, Flash Player ou AIR renvoie <codeph>null</codeph> lorsque la version demandée n’est pas disponible.</p>
	
	</apiDesc><example conref="examples\Clipboard.getData.1.as"> L’exemple suivant lit le texte provenant du presse-papiers du système, si disponible :
<codeblock>
 import flash.desktop.ClipboardFormats;

 var pasteData:String = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard/setData()"><linktext>setData()</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link><link href="flash.desktop.xml#ClipboardTransferMode"><linktext>flash.desktop.ClipboardTransferMode</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:Clipboard:hasFormat"><apiName>hasFormat</apiName><shortdesc>
	Vérifie si des données sont présentes au format spécifié dans cet objet Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>L’objet Clipboard demandé n’est plus dans le domaine (AIR uniquement).
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>La lecture ou l’écriture dans le presse-papiers n’est plus autorisée dans ce contexte.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, si des données sont présentes au format spécifié.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type de format à vérifier.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Vérifie si des données sont présentes au format spécifié dans cet objet Clipboard.
	
	<p>Utilisez les constantes dans la classe ClipboardFormats pour référencer les noms de format standard.</p>
	
	</apiDesc><example conref="examples\Clipboard.hasFormat.1.as"> L’exemple suivant teste le contenu du presse-papiers du système afin de déterminer si des données au format texte y sont disponibles :
<codeblock>
if(Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT)){
    //do something 
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:Clipboard:setData"><apiName>setData</apiName><shortdesc>
	Ajoute une représentation des informations à transférer dans le format de données spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>L’objet Clipboard demandé n’est plus dans le domaine (AIR uniquement).
	
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>La lecture ou l’écriture dans le presse-papiers n’est plus autorisée dans ce contexte. Dans Flash Player, l’appel de cette méthode n’aboutit que lors du traitement d’un événement utilisateur (pression de touche ou clic de souris, par exemple). Dans AIR, cette restriction s’applique uniquement au contenu s’exécutant hors du sandbox de sécurité de l’application.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>format</codeph> ou <codeph>data</codeph> est <codeph>null</codeph>.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> si les données ont bien été définies ; <codeph>false</codeph> dans le cas contraire. Dans Flash Player, renvoie <codeph>false</codeph> lorsque <codeph>format</codeph> est un membre non pris en charge de ClipboardFormats. (Flash Player ne prend pas en charge <codeph>ClipboardFormats.URL_FORMAT</codeph>, <codeph>ClipboardFormats.FILE_LIST_FORMAT</codeph> et <codeph>ClipboardFormats.BITMAP_FORMAT</codeph>).
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Format des données.
	</apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Informations à ajouter. 
	</apiDesc></apiParam><apiParam><apiItemName>serializable</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Définissez <codeph>true</codeph> pour les objets qui ne peuvent pas être sérialisés (ni désérialisés).
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ajoute une représentation des informations à transférer dans le format de données spécifié. Dans Flash Player, un événement utilisateur (pression de touche ou clic de souris, par exemple) est requis avant d’utiliser <codeph>setData()</codeph>. Dans AIR, cette restriction s’applique uniquement au contenu s’exécutant hors du sandbox de sécurité de l’application.
	
	<p>Différentes représentations des mêmes informations peuvent être ajoutées dans le presse-papiers dans divers formats. Ceci augmente la capacité des autres composants ou applications à exploiter les données disponibles. Par exemple, dans une application AIR, une image peut être ajoutée sous forme de données bitmap pour une utilisation dans des applications de retouche d’images, sous forme d’objet Bitmap pour une utilisation avec d’autres applications AIR et sous forme de fichier PNG encodé pour un transfert vers le système de fichiers natif.</p>
	
	<p>Le paramètre data doit être du type de données approprié pour le format spécifié :</p>
	<adobetable class="innertable">
	    
	    
	    
	    
	    
	    
	    
	    
	<tgroup cols="3"><thead><row><entry>Format</entry><entry>Type</entry><entry>Description</entry></row></thead><tbody><row><entry><codeph>ClipboardFormats.TEXT_FORMAT</codeph></entry><entry><codeph>String</codeph></entry><entry>Données de chaîne</entry></row><row><entry><codeph>ClipboardFormats.HTML_FORMAT</codeph></entry><entry><codeph>String</codeph></entry><entry> Données de chaîne HTML</entry></row><row><entry><codeph>ClipboardFormats.URL_FORMAT</codeph></entry><entry><codeph>String</codeph></entry><entry>Chaîne URL (AIR uniquement)</entry></row><row><entry><codeph>ClipboardFormats.RICH_TEXT_FORMAT</codeph></entry><entry><codeph>ByteArray</codeph></entry><entry>Données RTF</entry></row><row><entry><codeph>ClipboardFormats.BITMAP_FORMAT</codeph></entry><entry><codeph>BitmapData</codeph></entry><entry>données bitmap (AIR uniquement) </entry></row><row><entry><codeph>ClipboardFormats.FILE_LIST_FORMAT</codeph></entry><entry>Tableau de <codeph>File</codeph></entry><entry>tableau de fichiers (AIR uniquement)</entry></row><row><entry>Nom de format personnalisé</entry><entry>Tous</entry><entry>Référence d’objet et clone sérialisé</entry></row></tbody></tgroup></adobetable>
	
	<p>Les noms de format personnalisé ne doivent pas commencer par « air: » ou « flash: ». Dans une application AIR, pour éviter les conflits de noms lorsque vous utilisez des formats personnalisés, vous pouvez utiliser l’ID de votre application ou un nom de package comme préfixe, par exemple « com.nomApplication.exemple.dataPacket ».</p>
	
	<p>Dans le cas d’un transfert au sein de Flash Player ou d’une application ou entre Flash Player et des applications AIR, le paramètre <codeph>serializable</codeph> détermine si une référence et une copie doivent toutes deux être disponibles ou si seule une référence à un objet est disponible. Définissez <codeph>serializable</codeph> sur <codeph>true</codeph> pour que la référence et une copie de l’objet de données soient disponibles. Définissez <codeph>serializable</codeph> sur <codeph>false</codeph> pour que seule la référence de l’objet soit disponible. Les références d’objet n’étant valides que dans l’application en cours, le fait de définir <codeph>serializable</codeph> sur <codeph>false</codeph> implique également que les données de ce format ne soient pas disponibles pour les autres applications AIR ou Flash Player. Un composant peut choisir d’obtenir la référence ou la copie de l’objet en définissant le mode de transfert du presse-papiers approprié lors de l’accès aux données de ce format.</p>
	
	<p><b>Remarque :</b> les formats standard étant toujours convertis en formats natifs lorsque les données sont collées ou glissées (AIR uniquement) hors d’une application prise en charge, la valeur du paramètre <codeph>serializable</codeph> n’affecte pas la disponibilité des données aux formats standard pour les applications non AIR ou non Flash Player.</p>
	
	<p>Pour différer le rendu des données pour un format, utilisez plutôt la méthode <codeph>setDataHandler()</codeph>. Si les méthodes <codeph>setData()</codeph> et <codeph>setDataHandler()</codeph> sont toutes deux utilisées pour ajouter une représentation de données avec le même nom de format, la fonction du gestionnaire n’est jamais appelée.</p>
	
	<p><b>Remarque :</b> sous Mac OS, lorsque vous définissez le paramètre <codeph>format</codeph> sur <codeph>ClipboardFormats.URL_FORMAT</codeph>, l’URL n’est transférée que s’il s’agit d’une URL valide. Dans le cas contraire, l’objet Clipboard est vidé (et l’appel de <codeph>getData()</codeph> renvoie <codeph>null</codeph>).</p>
	
	</apiDesc><example conref="examples\Clipboard.setData.1.as"> L’exemple suivant ajoute du contenu dans le presse-papiers du système aux formats texte et HTML :
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 var htmlString:String = "&lt;html>&lt;body>Body content&lt;/body>&lt;/html>";
 Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, urlString);
 Clipboard.generalClipboard.setData(ClipboardFormats.HTML_FORMAT, urlString);
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard/setDataHandler()"><linktext>setDataHandler()</linktext></link><link href="flash.desktop.xml#Clipboard/getData()"><linktext>getData()</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link><link href="flash.desktop.xml#ClipboardTransferMode"><linktext>flash.desktop.ClipboardTransferMode</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:Clipboard:setDataHandler"><apiName>setDataHandler</apiName><shortdesc>
	Ajoute une référence à une fonction de gestionnaire qui produit les données pour le format spécifié à la demande.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>format</codeph> ou <codeph>handler</codeph> est <codeph>null</codeph>.
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>L’objet Clipboard demandé n’est plus dans le domaine (AIR uniquement).
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>La lecture ou l’écriture dans le presse-papiers n’est plus autorisée dans ce contexte. Dans Flash Player, l’appel de cette méthode n’aboutit que lors du traitement d’un événement utilisateur (pression de touche ou clic de souris, par exemple). Dans AIR, cette restriction s’applique uniquement au contenu s’exécutant hors du sandbox de sécurité de l’application.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> si le gestionnaire a bien été défini ; <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Fonction qui renvoie les données à transférer.
	</apiDesc></apiParam><apiParam><apiItemName>handler</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Format des données. 
	</apiDesc></apiParam><apiParam><apiItemName>serializable</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Spécifiez <codeph>true</codeph> si l’objet renvoyé par <codeph>handler</codeph> peut être sérialisé (et désérialisé).
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Ajoute une référence à une fonction de gestionnaire qui produit les données pour le format spécifié à la demande. Utilisez cette méthode pour différer la création ou le rendu des données jusqu’à ce qu’elles soient réellement accédées. Dans Flash Player, un événement utilisateur (pression de touche ou clic de souris, par exemple) est requis avant d’utiliser <codeph>setDataHandler()</codeph>. Dans AIR, cette restriction s’applique uniquement au contenu s’exécutant hors du sandbox de sécurité de l’application.
	
	<p>La fonction du gestionnaire doit renvoyer le type de données approprié pour le format spécifié :</p>
	<adobetable class="innertable">
	    
	    
	    
	    
	    
	    
	    
	      
	<tgroup cols="2"><thead><row><entry>Format</entry><entry>Type renvoyé</entry></row></thead><tbody><row><entry><codeph>ClipboardFormats.TEXT_FORMAT</codeph></entry><entry><codeph>String</codeph></entry></row><row><entry><codeph>ClipboardFormats.HTML_FORMAT</codeph></entry><entry><codeph>String</codeph></entry></row><row><entry><codeph>ClipboardFormats.URL_FORMAT</codeph></entry><entry><codeph>Chaîne</codeph> (AIR uniquement)</entry></row><row><entry><codeph>ClipboardFormats.RICH_TEXT_FORMAT</codeph></entry><entry><codeph>ByteArray</codeph></entry></row><row><entry><codeph>ClipboardFormats.BITMAP_FORMAT</codeph></entry><entry><codeph>BitmapData</codeph> (AIR uniquement)</entry></row><row><entry><codeph>ClipboardFormats.FILE_LIST_FORMAT</codeph></entry><entry>Tableau de <codeph>File</codeph> (AIR uniquement)</entry></row><row><entry>Nom de format personnalisé</entry><entry>Non Void</entry></row></tbody></tgroup></adobetable>
	
	<p>La fonction de gestionnaire n’est appelée que lorsque les données au format spécifié sont lues, et seulement à ce moment-là. Notez que les données sous-jacentes peuvent changer entre le moment où le gestionnaire est ajouté et le moment où les données sont lues, sauf si votre application prend des mesures pour protéger les données. Le comportement qui se produit lorsque les données du presse-papier représentées par une fonction du gestionnaire sont lues plusieurs fois n’est pas garanti. Flash Player ou AIR peut renvoyer les données produites par le premier appel de la fonction ou rappeler la fonction. Ne comptez pas sur ces comportements.</p>
	
	<p>Pour ajouter directement des données dans cet objet Clipboard, utilisez plutôt la méthode <codeph>setData()</codeph>. Si les méthodes <codeph>setData()</codeph> et <codeph>setDataHandler()</codeph> sont toutes deux appelées par le même nom de format, la fonction du gestionnaire n’est jamais appelée.</p>
	
	<p><b>Remarque :</b> sous Mac OS, lorsque vous définissez le paramètre <codeph>format</codeph> sur <codeph>ClipboardFormats.URL_FORMAT</codeph>, l’URL n’est transférée que s’il s’agit d’une URL valide. Dans le cas contraire, l’objet Clipboard est vidé (et l’appel de <codeph>getData()</codeph> renvoie <codeph>null</codeph>).</p>
	
	</apiDesc><example conref="examples\Clipboard.setDataHandler.1.as"> L’exemple suivant ajoute un nombre aléatoire dans le presse-papiers du système par l’intermédiaire d’une fonction de données différée :
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 Clipboard.generalClipboard.setDataHandler(ClipboardFormats.TEXT_FORMAT, randomNumberGenerator);

 public function randomNumberGenerator():String{
     return Math.random().toString();
 }
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard/setData()"><linktext>setData()</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:Clipboard:formats:get"><apiName>formats</apiName><shortdesc>
	Tableau de chaînes contenant les noms des formats de données disponibles dans cet objet Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	Tableau de chaînes contenant les noms des formats de données disponibles dans cet objet Clipboard.
	
	<p>Les constantes de chaîne des noms des formats standard sont définies dans la classe ClipboardFormats. D’autres chaînes, définies par l’application, peuvent également être utilisées comme noms de format pour transférer les données sous forme d’objet.</p>
	
	</apiDesc><example conref="examples\Clipboard.formats.1.as"> L’exemple suivant lit le tableau de <codeph>formats</codeph> du presse-papiers du système :
<codeblock>
 var availableFormats:Array = Clipboard.generalClipboard.formats;
</codeblock></example></apiValueDetail><related-links><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link></related-links></apiValue><apiValue id="flash.desktop:Clipboard:generalClipboard:get"><apiName>generalClipboard</apiName><shortdesc>
	 Presse-papiers du système d’exploitation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:Clipboard</apiValueClassifier></apiValueDef><apiDesc>
	 Presse-papiers du système d’exploitation.
	 
	 <p>Toutes les données collées dans le presse-papiers du système sont disponibles pour les autres applications. Cela peut comprendre le code distant non sécurisé s’exécutant dans un navigateur Web.</p>
	 
	 <p><b>Remarque :</b> dans les applications de Flash Player 10, une opération de collage à partir du presse-papiers implique tout d’abord un événement utilisateur (par exemple, utilisation du raccourci clavier de la commande Coller ou clic de souris sur la commande Coller d’un menu contextuel). <codeph>Clipboard.getData()</codeph> ne renvoie le contenu du presse-papiers que si InteractiveObject a reçu et exécute un événement coller. En aucun autre cas, l’appel à <codeph>Clipboard.getData()</codeph> ne peut échouer. La même restriction s’applique dans le contenu AIR qui se trouve en dehors du sandbox de l’application.</p>
	 
	 <p>L’objet <codeph>generalClipboard</codeph> est créé automatiquement. Vous ne pouvez pas affecter une autre occurrence Clipboard à cette propriété. Vous pouvez par contre utiliser les méthodes <codeph>getData()</codeph> et <codeph>setData()</codeph> pour lire et écrire des données dans l’objet existant.</p>
	 
	 <p>Il est toujours préférable d’effacer le presse-papiers avant d’y écrire de nouvelles données afin de s’assurer que les anciennes données de tous les formats sont effacées.</p>
	 
	 </apiDesc><example conref="examples\Clipboard.generalClipboard.1.as"> Pour écrire dans le presse-papiers du système d’exploitation :
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 var copy:String = "A string to copy to the system clipboard.";
 Clipboard.generalClipboard.clear();
 Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, copy);
</codeblock></example><example conref="examples\Clipboard.generalClipboard.2.as"> Pour lire le presse-papiers du système d’exploitation :
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 var pasteData:String  = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NotificationType"><apiName>NotificationType</apiName><shortdesc>
 La classe NotificationType définit les constantes à utiliser dans le paramètre priority de la méthode DockIcon bounce() et dans le paramètre type de la méthode NativeWindow notifyUser().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe NotificationType définit les constantes à utiliser dans le paramètre <codeph>priority</codeph> de la méthode DockIcon <codeph>bounce()</codeph> et dans le paramètre <codeph>type</codeph> de la méthode NativeWindow <codeph>notifyUser()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#DockIcon/bounce()"><linktext>flash.desktop.DockIcon.bounce()</linktext></link><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links><apiValue id="flash.desktop:NotificationType:CRITICAL"><apiName>CRITICAL</apiName><shortdesc>
	 Spécifie qu’une alerte de notification est de nature critique et que l’utilisateur doit s’en préoccuper rapidement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>critical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie qu’une alerte de notification est de nature critique et que l’utilisateur doit s’en préoccuper rapidement.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NotificationType:INFORMATIONAL"><apiName>INFORMATIONAL</apiName><shortdesc>
	 Spécifie qu’une alerte de notification est de nature informationnelle et que l’utilisateur peut l’ignorer sans risque.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>informational</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie qu’une alerte de notification est de nature informationnelle et que l’utilisateur peut l’ignorer sans risque.
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:ClipboardTransferMode"><apiName>ClipboardTransferMode</apiName><shortdesc>
 La classe ClipboardTransferMode définit des constantes pour les modes utilisés comme valeurs du paramètre transferMode de la méthode Clipboard.getData().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Clipboard, ClipboardFormats and ClipboardTransferMode were all added to AIR 1.0. These are also being added, with some exceptions listed in this file, to FP10.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe ClipboardTransferMode définit des constantes pour les modes utilisés comme valeurs du paramètre <codeph>transferMode</codeph> de la méthode <codeph>Clipboard.getData()</codeph>.
 
 <p>Le mode de transfert fournit un repère pour savoir si une référence ou une copie doit être renvoyée lors de l’accès à un objet du presse-papiers.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#Clipboard/getData()"><linktext>flash.desktop.Clipboard.getData()</linktext></link></related-links><apiValue id="flash.desktop:ClipboardTransferMode:CLONE_ONLY"><apiName>CLONE_ONLY</apiName><shortdesc>
    L’objet Clipboard ne doit renvoyer qu’une copie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>cloneOnly</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    L’objet Clipboard ne doit renvoyer qu’une copie.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardTransferMode:CLONE_PREFERRED"><apiName>CLONE_PREFERRED</apiName><shortdesc>
    L’objet Clipboard doit renvoyer une copie lorsqu’il y en a une et une référence dans le cas contraire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>clonePreferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    L’objet Clipboard doit renvoyer une copie lorsqu’il y en a une et une référence dans le cas contraire.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardTransferMode:ORIGINAL_ONLY"><apiName>ORIGINAL_ONLY</apiName><shortdesc>
    L’objet Clipboard ne doit renvoyer qu’une référence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>originalOnly</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    L’objet Clipboard ne doit renvoyer qu’une référence.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardTransferMode:ORIGINAL_PREFERRED"><apiName>ORIGINAL_PREFERRED</apiName><shortdesc>
    L’objet Clipboard doit renvoyer une référence lorsqu’il y en a une et une copie dans le cas contraire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>originalPreferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    L’objet Clipboard doit renvoyer une référence lorsqu’il y en a une et une copie dans le cas contraire.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeDragManager"><apiName>NativeDragManager</apiName><shortdesc>
 La classe NativeDragManager coordonne les opérations de glisser-déposer.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe NativeDragManager coordonne les opérations de glisser-déposer. L’API glisser-déposer native permet à l’utilisateur de faire glisser des données d’une application vers le système d’exploitation natif, d’une application AIR à une autre ou entre des composants d’une même application.
 
 <p>Les types de données suivants peuvent être transférés :</p>
 <ul>
 <li>Images bitmap</li>
 <li>Fichiers</li>
 <li>Texte</li>
 <li>Chaînes URL</li>
 <li>Objets sérialisés</li>
 <li>Références d’objet (valides uniquement dans l’application d’origine)</li>
 </ul>
 
 <p><b>Remarque :</b> tous les membres NativeDragManager sont statiques. Il n’est pas nécessaire de créer une occurrence de cette classe.</p>
 
 <p>Une opération de glisser-déposer est un geste de l’interface utilisateur qui commence lorsque l’utilisateur clique sur un élément visible et le fait glisser vers un autre emplacement. Pendant l’action de déplacement, les objets interactifs de la liste d’affichage distribuent des événements de déplacement natifs tout au long du déplacement à travers la fenêtre de l’application AIR. Des gestionnaires de ces événements peuvent appeler les méthodes de la classe NativeDragManager pour indiquer si l’élément déplacé peut être déposé sur un objet. En réponse, la classe NativeDragManager change le pointeur de la souris pour prévenir l’utilisateur.</p>
 
 <p><b>Actions de déplacement</b></p>
 <p>Les gestes de glisser-déposer sont généralement utilisés pour trois types d’opérations appelées <i>actions</i>. Comme la signification de ces actions dépend du contexte de l’application, le moteur d’exécution n’impose pas un comportement particulier par rapport à ces actions. Toutefois, une implémentation appropriée des actions améliore la convivialité de votre application pour l’utilisateur.
 </p> 
 
 <p>Les actions possibles sont :</p>
 <ul>
 <li>Copie : une copie des données est faite, sans que l’original n’en soit affecté (lors du déplacement d’objets au sein d’une application, faites attention à copier l’objet original lui-même plutôt que sa référence).</li>
 <li>Déplacement : les données sont déplacées du contexte d’origine vers le contexte défini par la cible visée, par exemple lors du déplacement d’un élément d’une liste à une autre.</li>
 <li>Lien : une référence ou un raccourci des données d’origine est créé, l’élément lui-même demeurant dans son contexte original.</li>
 </ul>
 
 <p>Les actions autorisées pour un geste de déplacement peuvent être définies en fournissant un paramètre <codeph>allowedActions</codeph> dans l’appel <codeph>NativeDragManager.doDrag()</codeph> qui lance l’opération de déplacement. Si aucun paramètre <codeph>allowedActions</codeph> n’est fourni, toutes les actions sont autorisées. Les cibles de déplacement potentielles peuvent vérifier les actions autorisées à l’aide de la propriété <codeph>allowedActions</codeph> d’un objet NativeDragEvent, et ne doivent pas accepter de dépôt autorisant uniquement des actions incompatibles (cela n’est toutefois pas imposé par le moteur d’exécution).</p>
 
 <p>Si la cible de dépôt n’implémente qu’une seule action, l’objet peut définir la propriété <codeph>dropAction</codeph> de NativeDragManager dans les gestionnaires des événements <codeph>nativeDragEnter</codeph> et <codeph>nativeDragOver</codeph>. La définition de la propriété avant le dépôt permet au gestionnaire de glissement d’actualiser le pointeur de la souris pour indiquer l’action prise en charge et empêcher l’utilisateur de choisir une action incompatible avec les touches de modification. Si l’action spécifiée ne correspond pas à l’une des actions autorisées, le dépôt n’est pas autorisé, même si la cible appelle la méthode <codeph>acceptDrop()</codeph>.</p>
 
 <p>Lorsqu’un dépôt est accepté, une cible de dépôt potentielle doit spécifier l’action choisie en définissant la propriété <codeph>NativeDragManager.dropAction</codeph> en réponse à l’événement <codeph>nativeDragDrop</codeph>. Cette action est signalée à l’objet d’affichage d’origine dans l’événement <codeph>nativeDragComplete</codeph>. Lorsque aucune action n’est définie par la cible de dépôt, une action par défaut est choisie parmi les actions autorisées dans cet ordre de priorité : copie, déplacement, lien. L’objet d’origine est responsable de la mise à jour de son état interne en réponse à l’action choisie.</p> 
 
 <p>Les constantes de chaîne des noms d’action sont définies dans la classe NativeDragActions.</p>
  
 <p><b>Séquence des événements</b></p>
 <p>Le geste de déplacement commence par un appel à la méthode <codeph>NativeDragManager.doDrag()</codeph> à l’intérieur d’un gestionnaire d’événement <codeph>mouseDown</codeph> ou <codeph>mouseMove</codeph> et suit la séquence d’événements suivante en réponse aux actions de l’utilisateur :</p>
 <ul>
 <li>Evénement <codeph>nativeDragStart</codeph> : lorsque la méthode <codeph>NativeDragManager.doDrag()</codeph> est appelée, l’objet interactif transmis sous forme de paramètre à la méthode devient l’objet initiateur et distribue un événement <codeph>nativeDragStart</codeph>.</li> 
 
 <li>Evénement <codeph>nativeDragUpdate</codeph> : pendant que le déplacement se poursuit, l’objet initiateur distribue continuellement des événements <codeph>nativeDragUpdate</codeph>.</li>
 
 <li>Evénements <codeph>nativeDragEnter</codeph>, <codeph>nativeDragOver</codeph> : lorsqu’un geste de déplacement survole un objet interactif, ce dernier déclenche un événement <codeph>nativeDragEnter</codeph>. Tant que le geste de déplacement survole l’objet interactif, celui-ci déclenche continuellement des événements <codeph>nativeDragOver</codeph>. En réponse à l’un de ces événements, l’objet qui sert de cible de dépôt potentielle doit vérifier les propriétés de l’objet événement pour savoir s’il peut accepter le dépôt. Si le format des données et les actions autorisées sont appropriés, le gestionnaire de ces événements doit appeler la méthode <codeph>NativeDragManager.acceptDrop()</codeph>, en transmettant une référence à l’objet d’affichage servant de cible de glissement (généralement l’objet qui a déclenché l’événement <codeph>nativeDragEnter</codeph> ou <codeph>nativeDragOver</codeph>). L’utilisateur peut alors déposer l’élément déplacé sur sa cible.</li>
 
 <li>Evénement <codeph>nativeDragExit</codeph> : lorsque le geste de déplacement quitte un objet interactif, ce dernier déclenche un événement <codeph>nativeDragExit</codeph>. Si l’objet a été désigné comme la cible de dépôt par un appel précédent à la méthode <codeph>NativeDragManager.acceptDrop()</codeph>, cet appel n’est plus valide et la méthode <codeph>acceptDrop()</codeph> doit être appelée de nouveau si le geste revient survoler l’objet interactif.</li>
 
 <li>Evénement <codeph>nativeDragDrop</codeph> : l’objet d’affichage cible déclenche un événement <codeph>nativeDragDrop</codeph> lorsque l’utilisateur relâche le bouton de sa souris sur l’objet. Le gestionnaire de cet événement peut accéder aux données de la propriété <codeph>transferable</codeph> de l’objet événement et doit définir la propriété <codeph>NativeDragManager.dropAction</codeph> pour signaler l’action que doit effectuer l’objet initiateur.</li>
 
 <li>Evénement <codeph>nativeDragComplete</codeph> : lorsque l’utilisateur relâche le bouton de la souris à la fin du déplacement, l’objet initiateur déclenche un événement <codeph>nativeDragComplete</codeph> (que le dépôt lui-même ait été consommé ou non). Le gestionnaire de cet événement peut vérifier la propriété <codeph>dropAction</codeph> de l’objet événement pour savoir quelle modification, le cas échéant, doit être apportée à son état de données interne, telle que la suppression d’un élément sorti d’une liste. Si <codeph>dropAction</codeph> est <codeph>NativeDragActions.NONE</codeph>, l’élément déplacé n’a pas été déposé sur une cible qualifiée.</li>
 </ul>
 
 <p><b>Gestes entre applications</b></p>
 <p>Lorsqu’un geste de déplacement entre dans une fenêtre d’application AIR à partir d’une application non AIR, aucun objet initiateur ne déclenche l’événement <codeph>nativeDragStart</codeph> ou <codeph>nativeDragComplete</codeph>. Autrement, les événements déclenchés au cours du geste suivent le même schéma que dans un geste commençant et se terminant au sein de la même application AIR. </p>
 
 <p>Lorsqu’un geste de déplacement quitte la fenêtre d’une application AIR, aucun objet cible ne déclenche les événements <codeph>nativeDragEnter</codeph>, <codeph>nativeDragOver</codeph> ou <codeph>nativeDragDrop</codeph>. L’objet initiateur déclenche toujours un événement <codeph>nativeDragComplete</codeph>, qui signale l’action de déplacement définie par le système d’exploitation natif (ou <codeph>aucune</codeph> si le dépôt n’a pas été accepté).</p>
 
 <p>Lorsqu’un geste de déplacement passe d’une application AIR à une autre, les objets d’affichage initiateur et cible déclenchent des événements dans leurs applications respectives, comme d’habitude.</p>
 
 <p><b>Transfert des informations</b></p>
 <p>Les données transférées au cours d’un geste de glisser-déposer sont renfermées dans un objet Clipboard. Cet objet de données est ajouté à l’opération de déplacement avec la méthode <codeph>NativeDragManager.doDrag()</codeph> à l’origine du geste. Les cibles de dépôt potentielles peuvent accéder à l’objet Clipboard par l’intermédiaire de la propriété <codeph>clipboard</codeph> de l’objet d’événement de déplacement natif. Après le démarrage d’une opération de déplacement, l’objet Clipboard ne peut plus être accédé que dans le gestionnaire d’un événement NativeDragEvent. Tout autre tentative d’accès à l’objet génère une erreur à l’exécution.</p>
 
 <p><b>Considérations de sécurité</b></p>
 <p>Les sandbox de sécurité des objets initiateur et cible potentielle déterminent comment accéder aux données déplacées. Si les deux objets se trouvent dans le même sandbox, tout objet NativeDragEvent peut alors accéder aux données. Toutefois, si les objets initiateur et cible potentielle sont dans des sandbox différents, les données ne sont accessibles que dans le sandbox cible à l’intérieur du gestionnaire de l’événement <codeph>nativeDragDrop</codeph>. D’autres gestionnaires d’événement de déplacement natifs peuvent toujours accéder à l’objet Clipboard référencé dans la propriété <codeph>clipboard</codeph> de l’événement pour identifier les formats de données disponibles, mais un appel à la méthode <codeph>clipboard.getData()</codeph> génère une erreur de sécurité.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#NativeDragEvent"><linktext>flash.events.NativeDragEvent</linktext></link><link href="flash.desktop.xml#NativeDragActions"><linktext>flash.desktop.NativeDragActions</linktext></link><link href="flash.desktop.xml#NativeDragOptions"><linktext>flash.desktop.NativeDragOptions</linktext></link><link href="flash.desktop.xml#Clipboard"><linktext>flash.desktop.Clipboard</linktext></link></related-links><apiOperation id="flash.desktop:NativeDragManager:acceptDragDrop"><apiName>acceptDragDrop</apiName><shortdesc>
	 Indique à l’objet NativeDragManager que l’objet interactif cible spécifié peut accepter un dépôt correspondant à l’événement de déplacement en cours.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 Indique à l’objet NativeDragManager que l’objet interactif cible spécifié peut accepter un dépôt correspondant à l’événement de déplacement en cours.
	 
     <p>Cette méthode ne peut être appelée que lorsque l’objet cible spécifié contient un gestionnaire <codeph>nativeDragDrop</codeph> capable de gérer au moins l’un des formats de données dans l’élément déplacé et au moins l’une des actions autorisées.</p>
     
	 <p>Cette fonction ne peut être appelée qu’à l’intérieur d’un gestionnaire d’événement <codeph>nativeDragEnter</codeph> ou <codeph>nativeDragOver</codeph>.</p>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeDragManager:doDrag"><apiName>doDrag</apiName><shortdesc>
	 Commence une opération de glisser-déposer.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dragInitiator</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>Généralement l’objet à partir duquel le geste de déplacement commence. Reçoit les événements <codeph>nativeDragStart</codeph> et <codeph>nativeDragComplete</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipboard</apiItemName><apiOperationClassifier>flash.desktop:Clipboard</apiOperationClassifier><apiDesc>Objet conteneur des données déplacées.
	 
     </apiDesc></apiParam><apiParam><apiItemName>dragImage</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Image proxy facultative affichée sous le pointeur de la souris pendant le déplacement. Si <codeph>null</codeph>, aucune image n’est affichée.
     
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Décalage entre la zone réactive de la souris et le coin supérieur gauche de l’image déplacée. Des coordonnées négatives déplacent l’image vers le haut et la gauche par rapport à la zone réactive. Si <codeph>null</codeph>, le coin supérieur gauche de l’image déplacée est placée sur la zone réactive de la souris. 
     
     </apiDesc></apiParam><apiParam><apiItemName>allowedActions</apiItemName><apiOperationClassifier>flash.desktop:NativeDragOptions</apiOperationClassifier><apiData>null</apiData><apiDesc>Limite les actions de glisser-déposer autorisées pour cette opération. Si <codeph>null</codeph>, toutes les actions sont autorisées.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Commence une opération de glisser-déposer.
	 
	 <p>Pour commencer une opération de déplacement :</p>
	 <ol>
	 <li>Créez un nouvel objet Clipboard.</li>
	 <li>Ajoutez les données à transférer en un ou plusieurs formats.</li>
	 <li>Eventuellement, créez un objet BitmapData devant servir d’image proxy pendant le déplacement.</li>
	 <li>Eventuellement, créez un objet NativeDragOptions pour limiter les actions autorisées dans cette opération (si le paramètre <codeph>allowedActions</codeph> reste <codeph>null</codeph>, toutes les actions sont autorisées).</li>
     <li>Appelez <codeph>NativeDragManager.doDrag()</codeph>.</li>
	 </ol>
	 
     <p>L’objet initiateur déclenche un événement <codeph>nativeDragStart</codeph> après l’appel à cette méthode, des événements <codeph>nativeDragStart</codeph> pendant que le déplacement est en cours et un événement <codeph>nativeDragComplete</codeph> lorsque l’utilisateur relâche la souris pour mettre fin au déplacement. Le gestionnaire de l’événement <codeph>nativeDragComplete</codeph> peut vérifier la propriété <codeph>dropAction</codeph> de l’événement pour déterminer si l’opération de glisser-déposer s’est terminée avec succès. Si <codeph>dropAction</codeph> is <codeph>NativeDragActions.NONE</codeph>, l’élément déplacé n’a pas été déposé sur une cible qualifiée.</p>
	 
     <p>Cette méthode ne peut être appelée qu’à l’intérieur d’un gestionnaire d’événement <codeph>mouseDown</codeph> ou <codeph>mouseMove</codeph> (si elle est appelée en réponse à un événement <codeph>mouseMove</codeph>, le bouton de la souris doit également être maintenu enfoncé).</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeDragActions"><linktext>flash.desktop.NativeDragActions</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:NativeDragManager:dragInitiator:get"><apiName>dragInitiator</apiName><shortdesc>
	Objet interactif transmis à l’appel NativeDragManager.doDrag() à l’origine de l’opération de déplacement.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier></apiValueDef><apiDesc>
	Objet interactif transmis à l’appel <codeph>NativeDragManager.doDrag()</codeph> à l’origine de l’opération de déplacement.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragManager:dropAction:get"><apiName>dropAction</apiName><shortdesc>
	Action de déplacement définie par la cible de dépôt.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Action de déplacement définie par la cible de dépôt.
	 
     <p>La propriété <codeph>dropAction</codeph> doit être définie dans le gestionnaire pour l’événement <codeph>nativeDragDrop</codeph>. Si la propriété <codeph>dropAction</codeph> n’est pas définie avant <codeph>nativeDragComplete</codeph>, NativeDragManager définit automatiquement la valeur sur la première action autorisée de la liste : copie, déplacement, lien (dans cette ordre).</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeDragActions"><linktext>flash.desktop.NativeDragActions</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeDragManager:isDragging:get"><apiName>isDragging</apiName><shortdesc>
	Indique si une opération de déplacement est actuellement en cours.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Indique si une opération de déplacement est actuellement en cours.
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeDragOptions"><apiName>NativeDragOptions</apiName><shortdesc>
 La classe NativeDragOptions définit les constantes pour les noms d’actions de glisser-déposer autorisées dans une opération de glisser-déposer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe NativeDragOptions définit les constantes pour les noms d’actions de glisser-déposer autorisées dans une opération de glisser-déposer.
 
 <p>Les actions de déplacement font partie d’un mécanisme de compte rendu pour que les objets source et cible puissent coopérer lors de l’échange glisser-déposer. Les actions sont seulement un <i>repère</i> pour le système d’exploitation. Il revient à l’instigateur du déplacement et aux objets cible concernés par la transaction d’implémenter le comportement approprié.</p>
 
 <p>Un objet d’origine doit autoriser uniquement les actions qu’il prend en charge. Par exemple, un objet d’origine ne doit autoriser que l’action <i>move</i> si la logique interne de cet objet supprime les données source lorsqu’une cible accepte le dépôt avec une action de déplacement.</p>
 
 
 <p>Toutes les propriétés d’un nouvel objet NativeDragOptions sont initialisées sur <codeph>true</codeph> (toutes les actions sont autorisées).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeDragManager"><linktext>flash.desktop.NativeDragManager</linktext></link><link href="flash.events.xml#NativeDragEvent"><linktext>flash.events.NativeDragEvent</linktext></link></related-links><apiOperation id="flash.desktop:NativeDragOptions:toString"><apiName>toString</apiName><shortdesc>
	
	 Renvoie la représentation sous forme de chaîne de l’objet spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Représentation sous forme de chaîne de l’objet.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Renvoie la représentation sous forme de chaîne de l’objet spécifié.
	 
     <p platform="actionscript"><b>Remarque :</b> les méthodes de la classe Object sont créées dynamiquement sur le prototype correspondant. Pour redéfinir cette méthode dans une sous-classe d’Object, n’utilisez pas le mot-clé <codeph>override</codeph>. Par exemple, une sous-classe d’Object met en œuvre <codeph>function toString():String</codeph> au lieu d’utiliser un remplacement de la classe de base.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.desktop:NativeDragOptions:allowCopy"><apiName>allowCopy</apiName><shortdesc>
	Une cible de dépôt peut copier les données déplacées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>true</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Une cible de dépôt peut copier les données déplacées.
	
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragOptions:allowLink"><apiName>allowLink</apiName><shortdesc>
	 Une cible de dépôt peut créer un lien vers les données déplacées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>true</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Une cible de dépôt peut créer un lien vers les données déplacées.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragOptions:allowMove"><apiName>allowMove</apiName><shortdesc>
	Une cible de dépôt peut déplacer les données déplacées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>true</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Une cible de dépôt peut déplacer les données déplacées.
	
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:DockIcon"><apiName>DockIcon</apiName><shortdesc>
	 La classe DockIcon représente l’icône d’ancrage de style MacOS X&amp;#xAE;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.desktop:InteractiveIcon</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe DockIcon représente l’icône du Dock de style MacOS X<sup>®</sup>.
	 
	 <p>Vous pouvez utiliser la classe DockIcon pour modifier l’apparence de l’icône standard, par exemple pour l’animer ou lui ajouter des graphiques d’informations. Vous pouvez également ajouter des éléments au menu de l’icône du Dock. Ces éléments s’afficheront au-dessus de ceux du menu standard.</p>
	 
	 <p>Il n’est pas possible de créer une occurrence de la classe DockIcon. Récupérez l’objet représentant l’icône du dock du système d’exploitation dans <codeph>NativeApplication.icon</codeph>.
	 </p>
	 
	 <p>Tous les systèmes d’exploitation n’ont pas d’icônes de Dock. Pour savoir si les icônes de Dock sont prises en charge par ce système, vérifiez <codeph>NativeApplication.supportsDockIcon</codeph>. Si les icônes de Dock sont prises en charge, la propriété <codeph>NativeApplication.icon</codeph> est de type DockIcon. Autrement, le type de <codeph>NativeApplication.icon</codeph> est une autre sous-classe de InteractiveIcon, en général SystemTrayIcon.</p>
	 
	 <p><b>Important :</b> une tentative d’appel à une méthode de la classe DockIcon sur l’objet <codeph>NativeApplication.icon</codeph> dans un système d’exploitation pour lequel AIR ne prend pas en charge les icônes de barre d’état système génère une exception à l’exécution.</p>
	 
	 </apiDesc><example conref="examples\DockIconExample.as"> L’exemple suivant charge une séquence d’images, puis lorsque le minuteur est lancé à l’aide du menu de l’icône du Dock, anime l’image d’icône (pour que l’exemple fonctionne, vous devez fournir un ensemble d’images d’icône et modifier les URL dans le tableau imageURLs).
<codeblock>

 package {
    import flash.desktop.DockIcon;
    import flash.desktop.NativeApplication;
    import flash.display.Loader;
    import flash.display.NativeMenu;
    import flash.display.NativeMenuItem;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.TimerEvent;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class AnimatedDockIcon extends Sprite
    {
        private var imageURLs:Array =  ['gfx/frame01.png',
                                        'gfx/frame02.png',
                                        'gfx/frame03.png',
                                        'gfx/frame04.png'];
        
        private var images:Array = new Array();
        private var animTimer:Timer = new Timer(100);
                                        
        public function AnimatedDockIcon()
        {
            NativeApplication.nativeApplication.autoExit = false;
            
            addEventListener(Event.COMPLETE, loadImages);
            loadImages();
            
            animTimer.addEventListener(TimerEvent.TIMER,advanceFrame);
            addMenu();
            stage.nativeWindow.close();
        }
        
        private function addMenu():void{
            var menu:NativeMenu = new NativeMenu();
            var start:NativeMenuItem = menu.addItem(new NativeMenuItem("Start animation"));
            var stop:NativeMenuItem = menu.addItem(new NativeMenuItem("Stop animation"));
            start.addEventListener(Event.SELECT, startTimer);
            stop.addEventListener(Event.SELECT, stopTimer);
            
            var dockIcon:DockIcon =    NativeApplication.nativeApplication.icon as DockIcon;
            dockIcon.menu = menu;
        }
        
        private function startTimer(event:Event):void{
            animTimer.start();
        }

        private function stopTimer(event:Event):void{
            animTimer.stop();
        }

        private var currentFrame:int = 0;
        private function advanceFrame(event:Event):void{
            if(currentFrame &lt; images.length){
                currentFrame++;
            } else {
                currentFrame = 0;
            }
            NativeApplication.nativeApplication.icon.bitmaps = [images[currentFrame]];
        }
        

        private function loadImages(event:Event = null):void{
            if(event != null){
                images.push(event.target.content.bitmapData);
            }
            if(imageURLs.length > 0){
                var urlString:String = imageURLs.pop();
                var loader:Loader = new Loader();
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadImages, false, 0, true);
                loader.load(new URLRequest(urlString));
            } else {
                var complete:Event = new Event(Event.COMPLETE,false,false);
                dispatchEvent(complete);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsDockIcon"><linktext>flash.desktop.NativeApplication.supportsDockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link></related-links><apiOperation id="flash.desktop:DockIcon:bounce"><apiName>bounce</apiName><shortdesc>
		 Avertit l’utilisateur qu’un événement pouvant requérir son attention s’est produit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiDefaultValue>NotificationType.Informational
		 
		 </apiDefaultValue><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>informational</apiData><apiDesc>Urgence avec laquelle le Dock doit rebondir.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Avertit l’utilisateur qu’un événement pouvant requérir son attention s’est produit.
		 
		 <p>Un appel à cette méthode fait rebondir l’icône du Dock si, et seulement si, l’application est en arrière-plan. Lorsque <codeph>priority</codeph> est <codeph>NotificationType.Informational</codeph>, il n’y a qu’un seul rebond. Lorsque <codeph>priority</codeph> est <codeph>NotificationType.Critical</codeph>, l’icône rebondit jusqu’à ce que l’application soit ramenée au premier plan.</p>
		 
		 </apiDesc><example conref="examples\DockIcon.bounce.1.as"> Dans l’exemple suivant, l’icône du Dock rebondit jusqu’à ce que l’utilisateur active l’application :
<codeblock>
 import flash.display.DockIcon;
 import flash.display.NotificationType;
 import flash.desktop.NativeApplication;

 if(NativeApplication.supportsDockIcon){
     var dockIcon:DockIcon = NativeApplication.nativeApplication.icon As DockIcon;
     dockIcon.bounce(NotificationType.CRITICAL);
 }
 
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#NotificationType"><linktext>flash.desktop.NotificationType</linktext></link><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:DockIcon:bitmaps:set"><apiName>bitmaps</apiName><shortdesc> 
		
		  
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc> 
		
		  
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.
	   
	 <p>Lorsqu’une icône est affichée dans le contexte d’un certain système d’exploitation, l’image bitmap du tableau se rapprochant le plus de la taille affichée est utilisée (et éventuellement mise à l’échelle). Les tailles courantes sont 16x16, 32x32, 48x48 et 128x128 (des icônes de 512x512 pixels peuvent être utilisées pour des système d’exploitation futurs).</p>
	 
	 <p>Dans certains cas, le système d’exploitation peut utiliser une icône système par défaut lorsque rien n’a été affecté à la propriété <codeph>bitmaps</codeph>. Dans d’autres cas, aucune icône n’apparaît.</p>
	 
	 <p>Pour définir ou modifier l’apparence de l’icône, affectez un tableau d’objets bitmapData à la propriété <codeph>bitmaps</codeph> :</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>La modification directe du tableau <codeph>bitmaps</codeph> n’a aucun effet.</p>
	 
	 <p>Pour effacer l’image de l’icône, affectez un tableau vide à la propriété <codeph>bitmaps</codeph>.</p>
	 
	 <p>
	 <b>Remarque :</b> lors du chargement de fichiers image pour une icône, le format de fichier PNG fournit généralement le meilleur fondu alpha. Le format GIF ne prend en charge que l’activation ou la désactivation de la transparence (pas le fondu). Le format JPG ne prend pas en charge la transparence du tout.  
	 </p>
	  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:DockIcon:height:get"><apiName>height</apiName><shortdesc> 
		
		 Hauteur d’affichage actuelle de l’icône, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Hauteur d’affichage actuelle de l’icône, en pixels.
		 
		 <p>Certains contextes d’icône prennent en charge les tailles dynamiques. La propriété <codeph>height</codeph> indique la hauteur de l’icône choisie dans le tableau <codeph>bitmaps</codeph> pour le contexte actuel. La hauteur d’affichage réelle peut être différente si le système d’exploitation a mis l’icône à l’échelle.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:DockIcon:menu:set"><apiName>menu</apiName><shortdesc>
		 Menu fourni par le système de cette icône du Dock.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Menu fourni par le système de cette icône du Dock.
		 
		 <p>Les éléments du menu s’affichent au-dessus des éléments habituels. Les éléments habituels ne peuvent être ni modifiés ni supprimés.</p>
		 
		 </apiDesc><example conref="examples\DockIcon.menu.1.as"> L’exemple suivant ajoute un élément au menu de l’icône du dock :
<codeblock>
 import flash.desktop.NativeApplication;
 import flash.events.Event;
 
private function createDockIconMenu():void{
    if(NativeApplication.supportsDockIcon){                
        var dockIcon:DockIcon = NativeApplication.nativeApplication.icon as DockIcon;
        
        var dockMenu:NativeMenu = new NativeMenu();
        var command:NativeMenuItem = dockMenu.addItem(new NativeMenuItem("Command"));
        command.addEventListener(Event.SELECT, onCommand);
        
        dockIcon.menu = dockMenu;
    }
}

 private function onCommand(event:Event):void{
     //do command...
 }
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.desktop:DockIcon:width:get"><apiName>width</apiName><shortdesc> 
		
		 Largeur d’affichage actuelle de l’icône, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Largeur d’affichage actuelle de l’icône, en pixels. 
		 
		 <p>Certains contextes d’icône prennent en charge les tailles dynamiques. La propriété <codeph>width</codeph> indique la largeur de l’icône choisie dans le tableau <codeph>bitmaps</codeph> pour le contexte actuel. La largeur d’affichage réelle peut être différente si le système d’exploitation a mis l’icône à l’échelle.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:Icon"><apiName>Icon</apiName><shortdesc> 
	 La classe Icon représente une icône du système d’exploitation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc> 
	 La classe Icon représente une icône du système d’exploitation. 
	 
	 <p>Un objet Icon a une propriété, <codeph>bitmaps</codeph>, correspondant à un tableau d’objets BitmapData. Une seule image est affichée à la fois. Le système d’exploitation sélectionne l’image dont la taille est la plus proche de la taille d’affichage actuel de l’icône, en la mettant à l’échelle si nécessaire.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#File/icon"><linktext>flash.filesystem.File.icon</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiValue id="flash.desktop:Icon:bitmaps:set"><apiName>bitmaps</apiName><shortdesc> 
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc> 
	 Image de l’icône sous forme de tableau d’objets BitmapData de tailles différentes.
	   
	 <p>Lorsqu’une icône est affichée dans le contexte d’un certain système d’exploitation, l’image bitmap du tableau se rapprochant le plus de la taille affichée est utilisée (et éventuellement mise à l’échelle). Les tailles courantes sont 16x16, 32x32, 48x48 et 128x128 (des icônes de 512x512 pixels peuvent être utilisées pour des système d’exploitation futurs).</p>
	 
	 <p>Dans certains cas, le système d’exploitation peut utiliser une icône système par défaut lorsque rien n’a été affecté à la propriété <codeph>bitmaps</codeph>. Dans d’autres cas, aucune icône n’apparaît.</p>
	 
	 <p>Pour définir ou modifier l’apparence de l’icône, affectez un tableau d’objets bitmapData à la propriété <codeph>bitmaps</codeph> :</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>La modification directe du tableau <codeph>bitmaps</codeph> n’a aucun effet.</p>
	 
	 <p>Pour effacer l’image de l’icône, affectez un tableau vide à la propriété <codeph>bitmaps</codeph>.</p>
	 
	 <p>
	 <b>Remarque :</b> lors du chargement de fichiers image pour une icône, le format de fichier PNG fournit généralement le meilleur fondu alpha. Le format GIF ne prend en charge que l’activation ou la désactivation de la transparence (pas le fondu). Le format JPG ne prend pas en charge la transparence du tout.  
	 </p>
	  
	 </apiDesc></apiValueDetail><related-links><link href="flash.filesystem.xml#File/icon"><linktext>flash.filesystem.File.icon</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue></apiClassifier></apiPackage>