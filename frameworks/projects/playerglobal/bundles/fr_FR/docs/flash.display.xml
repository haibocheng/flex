<?xml version="1.0"?>
<apiPackage id="flash.display"><apiName>flash.display</apiName><apiDetail/><apiClassifier id="flash.display:FrameLabel"><apiName>FrameLabel</apiName><shortdesc>
	
	L’objet FrameLabel contient des propriétés qui spécifient un numéro d’image et le nom d’étiquette correspondant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	
	L’objet FrameLabel contient des propriétés qui spécifient un numéro d’image et le nom d’étiquette correspondant. La classe Scene inclut la propriété <codeph>labels</codeph>, qui correspond à un tableau d’objets FrameLabel pour la séquence. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Scene/labels"><linktext>Scene.labels</linktext></link><link href="flash.display.xml#MovieClip/currentLabel"><linktext>MovieClip.currentLabel</linktext></link><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:FrameLabel:frame:get"><apiName>frame</apiName><shortdesc>
		Numéro de l’image qui contient l’étiquette.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		Numéro de l’image qui contient l’étiquette.
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FrameLabel:name:get"><apiName>name</apiName><shortdesc>
		Nom de l’étiquette.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Nom de l’étiquette.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
 La classe InteractiveObject correspond à la classe de base abstraite de l’ensemble des objets d’affichage avec lesquels l’utilisateur peut interagir à l’aide de la souris et du clavier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe InteractiveObject correspond à la classe abstraite de l’ensemble des objets d’affichage avec lesquels l’utilisateur peut interagir à l’aide de la souris et du clavier.
 
 <p>Il est impossible d’instancier directement la classe InteractiveObject. Tout appel au constructeur <codeph>new InteractiveObject()</codeph> renvoie une exception <codeph>ArgumentError</codeph>.</p>
 
 <p>La classe InteractiveObject n’inclut pas d’API pour le rendu de contenu à l’écran. Par conséquent, si vous devez créer une sous-classe personnalisée de la classe InteractiveObject, vous devez étendre l’une de ses sous-classes qui dispose d’API de rendu de contenu à l’écran, telles que les classes Sprite, SimpleButton, TextField ou MovieClip.</p>
 
 </apiDesc><example conref="examples\InteractiveObjectExample.as"> L’exemple suivant utilise la classe <codeph>InteractiveObjectExample</codeph>, qui en retour utilise la classe <codeph>ChildSprite</codeph> pour dessiner un rectangle et le manipule en fonction des différents événements de la souris. Pour ce faire, procédez comme suit :
 <ol>
    <li>Dans le constructeur <codeph>InteractiveObjectExample</codeph>, un nouvel objet ChildSprite de type Sprite appelé <codeph>child</codeph> est créé, qui en retour appelle la méthode de constructeur ChildSprite pour dessiner la forme et ajoute des événements de souris à la forme (comme expliqué au cours des étapes suivantes). L’objet <codeph>child</codeph> est ajouté dans la partie supérieure de la liste d’affichage aux coordonnées <i>x = 0, y = 0</i>.  </li>
 
    <li>Dans la classe <codeph>ChildSprite</codeph>, déclarez les propriétés <codeph>size</codeph> et <codeph>overSize</codeph> qui sont utilisées par la suite par les méthodes <codeph>draw()</codeph> et MouseEvent.</li>
 
     <li>Déclare des propriétés qui définissent la couleur de fond sur orange, la couleur de survol de la souris sur jaune et la couleur clic sur bleu clair.</li>
 
    <li>Dans le constructeur <codeph>ChildSprite</codeph>, un carré orange est dessiné à l’aide des méthodes de la classe Graphics et de la méthode <codeph>draw()</codeph>.</li>
 
    <li>Le constructeur ajoute quatre méthodes d’écouteur d’événements MouseEvent :
 
     <ul>
        <li><codeph>mouseOverHandler</codeph> : dessine de nouveau un carré plus grand, de 60x60 pixels, en jaune plus sombre et aux coordonnées d’origine.</li>
        <li><codeph>mouseOutHandler</codeph> : rétablit la couleur et la taille d’origine du carré.</li>
        <li><codeph>mouseDownHandler</codeph> : dessine de nouveau un carré plus grand, de 60x60 pixels, en bleu clair et aux coordonnées d’origine.</li>
        <li><codeph>mouseUpHandler</codeph> : identique à <codeph>mouseOverHandler</codeph>.</li>
     </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class InteractiveObjectExample extends Sprite {

        public function InteractiveObjectExample() {
            var child:Sprite = new ChildSprite();
            addChild(child);
        }
    }
}

import flash.display.Sprite;
import flash.events.MouseEvent;

class ChildSprite extends Sprite {
    private var size:uint = 50;
    private var overSize:uint = 60;
    private var backgroundColor:uint = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;

    public function ChildSprite() {
        buttonMode = true;
        draw(size, size, backgroundColor);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
        addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
    }

    private function draw(w:uint, h:uint, bgColor:uint):void {
        graphics.clear();
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }

    public function mouseOverHandler(event:MouseEvent):void {
        trace("mouseOverHandler");
        draw(overSize, overSize, overColor);
    }

    public function mouseOutHandler(event:MouseEvent):void {
        trace("mouseOutHandler");
        draw(size, size, backgroundColor);
    }

    public function mouseDownHandler(event:MouseEvent):void {
        trace("mouseDownHandler");
        draw(overSize, overSize, downColor);
    }

    public function mouseUpHandler(event:MouseEvent):void {
        trace("mouseUpHandler");
        draw(overSize, overSize, overColor);
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.display:InteractiveObject_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 Distribué lorsqu’un utilisateur entre un ou plusieurs caractères de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur entre un ou plusieurs caractères de texte. Différentes méthodes de saisie de texte peuvent générer cet événement, ce qui inclut les claviers standard, les éditeurs de méthode d’entrée (IME), les systèmes de reconnaissance vocale, voire même la copie de texte simple sans formatage ni ajout de style.
 </apiDesc><example conref="examples\TextField_textInput.as"/></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CONTEXT_MENU_contextMenu"><apiName>contextMenu</apiName><shortdesc>
 Distribué lorsque l’action d’un utilisateur active le menu contextuel associé à cet objet interactif dans une application AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CONTEXT_MENU</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’action d’un utilisateur active le menu contextuel associé à cet objet interactif dans une application AIR.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>contextMenu</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE_nativeDragComplete"><apiName>nativeDragComplete</apiName><shortdesc>
 Distribué par l’initiateur glisser InteractiveObject lorsque l’utilisateur arrête l’opération glisser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par l’initiateur glisser InteractiveObject lorsque l’utilisateur arrête l’opération glisser.
 
 <p>La propriété dropAction de l’événement indique l’action définie par l’objet cible drag ; une valeur « none » (<codeph>DragActions.NONE</codeph>) indique que l’opération déposer a été annulée ou refusée.</p>
 
 <p>Le gestionnaire d’événements <codeph>nativeDragComplete</codeph> est un endroit commode pour mettre à jour l’état de l’objet d’affichage déclencheur, par exemple, en supprimant un élément d’une liste (sur une action glisser de « move ») ou en changeant les propriétés visuelles.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE_nativeDragUpdate"><apiName>nativeDragUpdate</apiName><shortdesc>
 Distribué lors d’une opération glisser par l’objet InteractiveObject spécifié comme initiateur de l’action glisser dans l’appel DragManager.doDrag().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lors d’une opération glisser par l’objet InteractiveObject spécifié comme initiateur de l’action glisser dans l’appel DragManager.doDrag().
 
 <p>Les événements <codeph>nativeDragUpdate</codeph> ne sont pas distribués sous Linux.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_START_nativeDragStart"><apiName>nativeDragStart</apiName><shortdesc>
 Distribué au début d’une opération glisser par l’objet InteractiveObject spécifié comme initiateur de l’action glisser dans l’appel DragManager.doDrag().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_START</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué au début d’une opération glisser par l’objet InteractiveObject spécifié comme initiateur de l’action glisser dans l’appel DragManager.doDrag().
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_EXIT_nativeDragExit"><apiName>nativeDragExit</apiName><shortdesc>
 Distribué par un InteractiveObject lorsqu’une opération glisser sort des limites.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_EXIT</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par un InteractiveObject lorsqu’une opération glisser sort des limites.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_DROP_nativeDragDrop"><apiName>nativeDragDrop</apiName><shortdesc>
 Distribué par l’objet InteractiveObject cible lorsqu’un objet glissé est déposé dessus et que l’opération déposer a été acceptée avec un appel à DragManager.acceptDragDrop().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_DROP</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par l’objet InteractiveObject cible lorsqu’un objet glissé est déposé dessus et que l’opération déposer a été acceptée avec un appel à DragManager.acceptDragDrop().
 
 <p>Accédez aux données déposées à l’aide de la propriété <codeph>clipboard</codeph> de l’objet événement.</p>
 
 <p>Le gestionnaire de cet événement doit régler la propriété <codeph>DragManager.dropAction</codeph> pour fournir des informations à l’objet déclencheur sur l’action glisser effectuée. Si aucune valeur n’est réglée, le DragManager sélectionne une valeur par défaut dans la liste des actions autorisées.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_OVER_nativeDragOver"><apiName>nativeDragOver</apiName><shortdesc>
 Distribué par un objet InteractiveObject de façon continue lorsqu’une opération glisser reste dans ses limites.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_OVER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par un objet InteractiveObject de façon continue lorsqu’une opération glisser reste dans ses limites.
 
 <p>Les événements <codeph>nativeDragOver</codeph> sont distribués dès que la souris est déplacée. Sous Windows et Mac, ils sont également distribués après quelques secondes, même lorsque la souris n’a pas été déplacée.</p>
 
 <p>Gérez les événements <codeph>nativeDragOver</codeph> ou <codeph>nativeDragEnter</codeph> pour permettre à l’objet d’affichage de devenir la cible déposer.</p> 
 
 <p>Pour déterminer si l’objet d’affichage de distribution peut accepter l’opération déposer, vérifiez si les données dans la propriété <codeph>clipboard</codeph> de l’objet événement sont adaptées, et les actions glisser dans la propriété<codeph>allowedActions</codeph>.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_ENTER_nativeDragEnter"><apiName>nativeDragEnter</apiName><shortdesc>
 Distribué par un InteractiveObject lorsqu’une opération glisser entre dans ses limites.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_ENTER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par un InteractiveObject lorsqu’une opération glisser entre dans ses limites.
 
 <p>Gérez les événements <codeph>nativeDragEnter</codeph> ou <codeph>nativeDragOver</codeph> pour permettre à l’objet d’affichage de devenir la cible déposer.</p>
 
 <p>Pour déterminer si l’objet d’affichage de distribution peut accepter l’opération déposer, vérifiez si les données dans la propriété <codeph>clipboard</codeph> de l’objet événement sont adaptées, et les actions glisser dans la propriété<codeph>allowedActions</codeph>.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_INDEX_CHANGE_tabIndexChange"><apiName>tabIndexChange</apiName><shortdesc>
 Distribué lorsque la valeur de la propriété tabIndex de l’objet change.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_INDEX_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque la valeur de la propriété <codeph>tabIndex</codeph> de l’objet change. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_ENABLED_CHANGE_tabEnabledChange"><apiName>tabEnabledChange</apiName><shortdesc>
 Distribué lorsque l’indicateur tabEnabled de l’objet change.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_ENABLED_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’indicateur <codeph>tabEnabled</codeph> de l’objet change. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_CHILDREN_CHANGE_tabChildrenChange"><apiName>tabChildrenChange</apiName><shortdesc>
 Distribué lorsque la valeur de l’indicateur tabChildren de l’objet change.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_CHILDREN_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque la valeur de l’indicateur <codeph>tabChildren</codeph> de l’objet change. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_UP_keyUp"><apiName>keyUp</apiName><shortdesc>
 Distribué lorsque l’utilisateur relâche une touche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_UP</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur relâche une touche. La concordance entre les touches et des caractères spécifiques dépend du périphérique et du système d’exploitation. Ce type d’événement est généré lors du mappage, mais avant le traitement d’un éditeur de méthode d’entrée (IME). Les IME permettent d’entrer des caractères, tels que les idéogrammes chinois, que le clavier AZERTY standard ne permet pas de produire. Cet événement se produit après un événement <codeph>keyDown</codeph> et présente les caractéristiques suivantes :
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_DOWN_keyDown"><apiName>keyDown</apiName><shortdesc>
 Distribué lorsque l’utilisateur appuie sur une touche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_DOWN</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur appuie sur une touche. La concordance entre les touches et des caractères spécifiques dépend du périphérique et du système d’exploitation. Ce type d’événement est généré lors du mappage, mais avant le traitement d’un éditeur de méthode d’entrée (IME). Les IME permettent d’entrer des caractères, tels que les idéogrammes chinois, que le clavier AZERTY standard ne permet pas de produire. Cet événement se produit avant l’événement <codeph>keyUp</codeph>.
 
 <p>Dans AIR, l’annulation de cet événement empêche le caractère d’être inséré dans un champ de texte. </p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
 Distribué lorsqu’un utilisateur relâche le bouton du périphérique de pointage sur une occurrence InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur relâche le bouton du périphérique de pointage sur une occurrence InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
 Distribué lorsqu’un utilisateur appuie sur le bouton du périphérique de pointage sur une occurrence InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur appuie sur le bouton du périphérique de pointage sur une occurrence InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
 Distribué lorsque l’utilisateur appuie sur le bouton droit de son périphérique de pointage et le relâche sur la même occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur appuie sur le bouton droit de son périphérique de pointage et le relâche sur la même occurrence de InteractiveObject. Pour qu’un événement <codeph>rightClick</codeph> se produise, il doit toujours suivre cette série d’événements dans l’ordre suivant : événement <codeph>rightMouseDown</codeph>, puis <codeph>rightMouseUp</codeph>. L’objet cible doit être identique pour ces deux événements, sans quoi l’événement <codeph>rightClick</codeph> ne se produit pas. Quel que soit le nombre d’autres événements de souris effectués entre les événements <codeph>rightmouseDown</codeph> et <codeph>rightmouseUp</codeph>, l’événement <codeph>rightclick</codeph> se produit. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_UP_middleMouseUp"><apiName>middleMouseUp</apiName><shortdesc>
 Distribué lorsqu’un utilisateur relâche le bouton du périphérique de pointage sur une occurrence InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur relâche le bouton du périphérique de pointage sur une occurrence InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_DOWN_middleMouseDown"><apiName>middleMouseDown</apiName><shortdesc>
 Distribué lorsqu’un utilisateur appuie sur le bouton du périphérique de pointage central sur une occurrence InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur appuie sur le bouton du périphérique de pointage central sur une occurrence InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_CLICK_middleClick"><apiName>middleClick</apiName><shortdesc>
 Distribué lorsque l’utilisateur appuie sur le bouton central de son périphérique de pointage et le relâche sur la même occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur appuie sur le bouton central de son périphérique de pointage et le relâche sur la même occurrence de InteractiveObject. Pour qu’un événement <codeph>middleClick</codeph> se produise, il doit toujours suivre cette série d’événements dans l’ordre suivant : événement <codeph>middleMouseDown</codeph>, puis <codeph>middleMouseUp</codeph>. L’objet cible doit être identique pour ces deux événements, sans quoi l’événement <codeph>middleClick</codeph> ne se produit pas. Quel que soit le nombre d’autres événements de souris effectués entre les événements <codeph>middleMouseDown</codeph> et <codeph>middleMouseUp</codeph>, l’événement <codeph>middleClick</codeph> se produit. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OVER_rollOver"><apiName>rollOver</apiName><shortdesc>
 Distribué lorsque l’utilisateur place un périphérique de pointage sur une occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur place un périphérique de pointage sur une occurrence d’InteractiveObject. L’événement a pour cible l’objet placé sous le périphérique de pointage ou un parent de cet objet. <codeph>relatedObject</codeph> correspond à l’objet précédemment placé sous le périphérique de pointage. Les événements <codeph>rollOver</codeph> sont envoyés de façon consécutive vers le bas de la chaîne parent de l’objet, en commençant par le parent de plus haut niveau qui ne constitue ni la racine, ni l’ancêtre de <codeph>relatedObject</codeph> et se termine par l’objet.
 <p>L’événement <codeph>rollOver</codeph> a pour objet de simplifier le codage des comportements de fin de sélection des conteneurs d’objet d’affichage avec enfants. Lorsque la souris pénètre dans la zone d’un objet d’affichage ou de l’un de ses enfants à partir d’un objet qui ne fait pas partie de ses enfants, l’objet d’affichage distribue l’événement <codeph>rollOver</codeph>. Ce comportement diffère de celui de l’événement <codeph>mouseOver</codeph>, qui est envoyé lorsque la souris entre dans la zone d’un objet enfant du conteneur d’objet d’affichage, même si la souris reste au-dessus d’un autre objet enfant du conteneur d’objet d’affichage. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OUT_rollOut"><apiName>rollOut</apiName><shortdesc>
 Distribué lorsque l’utilisateur éloigne un périphérique de pointage d’une occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur éloigne un périphérique de pointage d’une occurrence d’InteractiveObject. L’événement a pour cible l’objet placé précédemment sous le périphérique de pointage ou un parent de cet objet. L’objet <codeph>relatedObject</codeph> correspond à l’objet sur lequel s’est placé le périphérique de pointage. Les événements <codeph>rollOut</codeph> sont envoyés de façon consécutive vers le haut de la chaîne parent de l’objet, en commençant par l’objet et en se terminant par le parent de plus haut niveau qui n’est ni la racine, ni l’ancêtre de <codeph>relatedObject</codeph>. 
 <p>L’événement <codeph>rollOut</codeph> a pour objet de simplifier le codage des comportements de survol des conteneurs d’objet d’affichage avec enfants. Lorsque la souris quitte la zone d’un objet d’affichage ou de l’un de ses enfants pour atteindre un objet qui ne fait pas partie de ses enfants, l’objet d’affichage distribue l’événement <codeph>rollOut</codeph>. Ce comportement diffère de celui de l’événement <codeph>mouseOut</codeph>, qui est envoyé lorsque la souris quitte la zone d’un objet enfant du conteneur d’objet d’affichage, même si la souris reste au-dessus d’un autre objet enfant du conteneur d’objet d’affichage.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_WHEEL_mouseWheel"><apiName>mouseWheel</apiName><shortdesc>
 Distribué lorsque la molette d’une souris est actionnée sur une occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_WHEEL</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque la molette d’une souris est actionnée sur une occurrence de InteractiveObject. Si la cible est un champ de texte, le comportement par défaut consiste à faire défiler le texte. Disponible uniquement sur les systèmes d’exploitation Microsoft Windows. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 Distribué lorsqu’un utilisateur relâche le bouton du périphérique de pointage sur une occurrence InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur relâche le bouton du périphérique de pointage sur une occurrence InteractiveObject. Si la cible est une occurrence de SimpleButton, l’objet présente l’objet d’affichage <codeph>upState</codeph>. Si la cible est un champ de texte sélectionnable, le champ de texte termine la sélection, ce qui est son comportement par défaut.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OVER_mouseOver"><apiName>mouseOver</apiName><shortdesc>
 Distribué lorsque l’utilisateur place un périphérique de pointage sur une occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur place un périphérique de pointage sur une occurrence de InteractiveObject. <codeph>relatedObject</codeph> correspond à l’objet précédemment placé sous le périphérique de pointage. Si la cible est une occurrence de SimpleButton, l’objet présente l’objet d’affichage <codeph>overState</codeph> ou <codeph>upState</codeph>, selon que le bouton de la souris est enfoncé ou non, comme comportement par défaut.
 <p>L’événement <codeph>mouseOver</codeph> est envoyé chaque fois que la souris pénètre dans la zone d’un objet enfant du conteneur d’objet d’affichage, même si la souris survolait déjà un autre objet enfant du conteneur d’objet d’affichage. Ce comportement est différent de celui de l’événement <codeph>rollOver</codeph> qui a pour objet de simplifier le codage des comportements de fin de sélection des conteneurs d’objet d’affichage avec enfants. Lorsque la souris pénètre dans la zone d’un objet d’affichage ou de l’un de ses enfants à partir d’un objet qui ne fait pas partie de ses enfants, l’objet d’affichage distribue l’événement <codeph>rollOver</codeph>. Les événements <codeph>rollOver</codeph> sont envoyés de façon consécutive vers le bas de la chaîne parent de l’objet, en commençant par le parent de plus haut niveau qui ne constitue ni la racine, ni l’ancêtre de <codeph>relatedObject</codeph> et se termine par l’objet.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OUT_mouseOut"><apiName>mouseOut</apiName><shortdesc>
 Distribué lorsque l’utilisateur éloigne un périphérique de pointage d’une occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur éloigne un périphérique de pointage d’une occurrence d’InteractiveObject. L’événement a pour cible l’objet précédemment placé sous le périphérique de pointage. L’objet <codeph>relatedObject</codeph> correspond à l’objet sur lequel s’est placé le périphérique de pointage. Lorsque la cible est une occurrence de SimpleButton, le bouton présente l’objet d’affichage <codeph>upState</codeph> comme comportement par défaut.
 <p>L’événement <codeph>mouseOut</codeph> est envoyé chaque fois que la souris quitte la zone d’un objet enfant du conteneur d’objet d’affichage, même si la souris reste au-dessus d’un autre objet enfant du conteneur d’objet d’affichage. Ce comportement est différent de celui de l’événement <codeph>rollOut</codeph> qui a pour objet de simplifier le codage des comportements de survol des conteneurs d’objet d’affichage avec enfants. Lorsque la souris quitte la zone d’un objet d’affichage ou de l’un de ses enfants pour atteindre un objet qui ne fait pas partie de ses enfants, l’objet d’affichage distribue l’événement <codeph>rollOut</codeph>. Les événements <codeph>rollOut</codeph> sont distribués de façon consécutive vers le haut de la chaîne parent de l’objet, en commençant par l’objet et en se terminant par le parent de plus haut niveau qui n’est ni la racine, ni l’ancêtre de <codeph>relatedObject</codeph>.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_MOVE_mouseMove"><apiName>mouseMove</apiName><shortdesc>
 Distribué lorsque l’utilisateur déplace le périphérique de pointage placé sur une occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_MOVE</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur déplace le périphérique de pointage placé sur une occurrence d’InteractiveObject. Si la cible est un champ de texte sélectionné par l’utilisateur, le comportement par défaut consiste à mettre à jour la sélection.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 Distribué lorsqu’un utilisateur appuie sur le bouton du périphérique de pointage sur une occurrence InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur appuie sur le bouton du périphérique de pointage sur une occurrence InteractiveObject. Lorsque la cible est une occurrence de SimpleButton, celle-ci affiche l’objet d’affichage <codeph>downState</codeph> en tant que comportement par défaut. Si la cible est un champ de texte sélectionnable, le champ de texte commence la sélection, ce qui est son comportement par défaut.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.DOUBLE_CLICK_doubleClick"><apiName>doubleClick</apiName><shortdesc>
 Distribué lorsque l’utilisateur appuie sur le bouton principal d’un périphérique de pointage et le relâche deux fois de suite sur la même occurrence d’InteractiveObject si l’indicateur doubleClickEnabled de cet objet est réglé sur true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.DOUBLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur appuie sur le bouton principal d’un périphérique de pointage et le relâche deux fois de suite sur la même occurrence d’InteractiveObject si l’indicateur <codeph>doubleClickEnabled</codeph> de cet objet est défini sur <codeph>true</codeph>. Pour qu’un événement <codeph>doubleClick</codeph> se produise, il doit suivre immédiatement la série d’événements ci-après : <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>, <codeph>click</codeph>, <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>. Tous ces événements doivent partager la même cible en tant qu’événement <codeph>doubleClick</codeph>. Le second clic, représenté par les seconds événements <codeph>mouseDown</codeph> et <codeph>mouseUp</codeph>, doit se produire dans un délai spécifique après l’événement <codeph>click</codeph>. La longueur autorisée de ce délai varie selon le système d’exploitation et peut souvent être configurée par l’utilisateur. Si la cible est un champ de texte sélectionnable, le comportement par défaut consiste à sélectionner le mot qui se trouve sous le pointeur. Si l’indicateur <codeph>doubleClickEnabled</codeph> de l’objet InteractiveObject cible n’est pas réglé sur <codeph>true</codeph>, celui-ci reçoit deux événements <codeph>click</codeph>.  
 
 <p>La propriété <codeph>doubleClickEnabled</codeph> prend par défaut la valeur <codeph>false</codeph>.  </p>
 
 <p>Le comportement de sélection de texte par le biais d’un double clic d’un objet TextField n’est pas lié à l’événement <codeph>doubleClick</codeph>. Utilisez <codeph>TextField.doubleClickEnabled</codeph> pour contrôler les sélections TextField.</p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/doubleClickEnabled"><linktext>doubleClickEnabled</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 Distribué lorsque l’utilisateur appuie sur le bouton principal de son périphérique de pointage et le relâche sur la même occurrence de InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur appuie sur le bouton principal de son périphérique de pointage et le relâche sur la même occurrence de InteractiveObject. Pour qu’un événement clic se produise, il doit toujours suivre cette série d’événements dans l’ordre suivant : événement mouseDown, puis mouseUp. L’objet cible doit être identique pour ces deux événements, sans quoi l’événement <codeph>click</codeph> ne se produit pas. Quel que soit le nombre d’autres événements de souris effectués entre les événements <codeph>mouseDown</codeph> et <codeph>mouseUp</codeph>, l’événement <codeph>click</codeph> se produit. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.MOUSE_FOCUS_CHANGE_mouseFocusChange"><apiName>mouseFocusChange</apiName><shortdesc>
 Distribué lorsque l’utilisateur tente de déplacer le focus à l’aide d’un périphérique de pointage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.MOUSE_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur tente de déplacer le focus à l’aide d’un périphérique de pointage. Le comportement par défaut de cet événement consiste à déplacer le focus et à distribuer les événements <codeph>focusIn</codeph> et <codeph>focusOut</codeph> correspondants. 
 
 <p>Cet événement est distribué à l’objet qui possède actuellement le focus. L’objet apparenté de cet événement correspond à l’occurrence d’InteractiveObject qui reçoit le focus si vous ne bloquez pas le comportement par défaut. Pour éviter le déplacement du focus, appelez <codeph>preventDefault()</codeph> dans un écouteur d’événement correctement enregistré auprès de l’objet cible. La propriété <codeph>shiftKey</codeph> n’est pas utilisée. Le focus change et les événements <codeph>focusIn</codeph> et <codeph>focusOut</codeph> sont distribués par défaut.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.KEY_FOCUS_CHANGE_keyFocusChange"><apiName>keyFocusChange</apiName><shortdesc>
 Distribué lorsque l’utilisateur tente de déplacer le focus à l’aide du clavier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.KEY_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur tente de déplacer le focus à l’aide du clavier. Le comportement par défaut de cet événement consiste à déplacer le focus et à distribuer les événements <codeph>focusIn</codeph> et <codeph>focusOut</codeph> correspondants.
 
 <p>Cet événement est distribué à l’objet qui possède actuellement le focus. L’objet apparenté de cet événement correspond à l’occurrence d’InteractiveObject qui reçoit le focus si vous ne bloquez pas le comportement par défaut. Pour éviter le déplacement du focus, appelez <codeph>preventDefault()</codeph> dans un écouteur d’événement correctement enregistré auprès de l’objet cible. Le focus change et les événements <codeph>focusIn</codeph> et <codeph>focusOut</codeph> sont distribués par défaut.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_OUT_focusOut"><apiName>focusOut</apiName><shortdesc>
 Distribué après la perte de focus par un objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_OUT</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué <i>après</i> la perte de focus d’un objet d’affichage. Ce cas de figure se produit lorsqu’un utilisateur affiche en surbrillance un autre objet à l’aide d’un périphérique de pointage ou du clavier. L’objet qui perd le focus s’appelle l’objet cible de cet événement, tandis que l’occurrence d’InteractiveObject correspondante qui reçoit le focus porte le nom d’objet apparenté. Une référence à l’objet apparenté est enregistrée dans la propriété <codeph>relatedObject</codeph> de l’objet cible. La propriété <codeph>shiftKey</codeph> n’est pas utilisée. Cet événement précède la distribution de l’événement <codeph>focusIn</codeph> par l’objet apparenté.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_IN_focusIn"><apiName>focusIn</apiName><shortdesc>
 Distribué après la prise de focus par un objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_IN</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué <i>après</i> la prise de focus d’un objet d’affichage. Ce cas de figure se produit lorsqu’un utilisateur affiche l’objet en surbrillance à l’aide d’un périphérique de pointage ou du clavier. L’objet qui reçoit le focus s’appelle l’objet cible de cet événement, tandis que l’occurrence d’InteractiveObject correspondante qui perd le focus en raison de ce changement porte le nom d’objet apparenté. Une référence à l’objet apparenté est enregistrée dans la propriété <codeph>relatedObject</codeph> de l’objet cible. La propriété <codeph>shiftKey</codeph> n’est pas utilisée. Cet événement suit la distribution de l’événement <codeph>focusOut</codeph> de l’objet précédent.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.SELECT_ALL_selectAll"><apiName>selectAll</apiName><shortdesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour tout sélectionner ou choisit ’Sélectionner tout’ dans le menu contextuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT_ALL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour tout sélectionner ou choisit ’Sélectionner tout’ dans le menu contextuel. Cet événement est distribué à l’objet qui possède actuellement le focus. Si l’objet qui a actuellement le focus est un TextField, le comportement par défaut de cet événement est de sélectionner l’ensemble du contenu du champ de texte. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.PASTE_paste"><apiName>paste</apiName><shortdesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour une opération de collage ou sélectionne ’Coller’ dans le menu contextuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.PASTE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour une opération de collage ou sélectionne ’Coller’ dans le menu contextuel. Cet événement est distribué à l’objet qui possède actuellement le focus. Si l’objet qui a le focus est un TextField, le comportement par défaut de cet événement est de coller le contenu du presse-papiers dans le champ de texte, au niveau du point d’insertion actuel, en remplaçant éventuellement le texte actuellement sélectionné dans le champ de texte. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CUT_cut"><apiName>cut</apiName><shortdesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour une opération de coupage ou sélectionne ’Couper’ dans le menu contextuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CUT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour une opération de coupage ou sélectionne ’Couper’ dans le menu contextuel. Cet événement est distribué à l’objet qui possède actuellement le focus. Si l’objet qui a le focus est un TextField, le comportement par défaut de cet événement est de couper le texte actuellement sélectionné dans le champ de texte pour l’envoyer dans le presse-papiers. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.COPY_copy"><apiName>copy</apiName><shortdesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour une opération de copie ou sélectionne ’Copier’ dans le menu contextuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COPY</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur active la combinaison de touches de raccourci propre à la plateforme pour une opération de copie ou sélectionne ’Copier’ dans le menu contextuel. Cet événement est distribué à l’objet qui possède actuellement le focus. Si l’objet qui a le focus est un TextField, le comportement par défaut de cet événement est de copier le texte actuellement sélectionné dans le champ de texte pour l’envoyer dans le presse-papiers. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CLEAR_clear"><apiName>clear</apiName><shortdesc>
 Distribué lorsque l’utilisateur sélectionne ’Effacer’ (ou ’Supprimer’) dans le menu contextuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLEAR</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur sélectionne ’Effacer’ (ou ’Supprimer’) dans le menu contextuel. Cet événement est distribué à l’objet qui possède actuellement le focus. Si l’objet qui a le focus est un TextField, le comportement par défaut de cet événement est de supprimer le texte actuellement sélectionné dans le champ de texte. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:InteractiveObject:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
	L’appel du constructeur InteractiveObject() renvoie une exception ArgumentError.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	L’appel du constructeur <codeph>new InteractiveObject()</codeph> renvoie une exception <codeph>ArgumentError</codeph>. Vous pouvez cependant appeler des constructeurs pour les sous-classes suivantes de InteractiveObject :
	
	<ul>
	
		<li><codeph>new SimpleButton()</codeph></li>
		<li><codeph>new TextField()</codeph></li>
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:InteractiveObject:contextMenu:get"><apiName>contextMenu</apiName><shortdesc> 
	 Spécifie le menu contextuel associé à l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier><apiTipTexts><apiTipText>Menu contextuel associé à l’objet.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Spécifie le menu contextuel associé à l’objet.
	 
	 <p>Pour le contenu s’exécutant dans Flash Player, cette propriété est un objet ContextMenu. Dans le moteur d’exécution AIR, la classe ContextMenu étend la classe NativeMenu, mais Flash Player prend en charge la classe ContextMenu uniquement, pas la classe NativeMenu.
	 </p>
	 
	 <p><b>Remarque :</b> les objets TextField incluent toujours un menu du Presse-papiers dans le menu contextuel. Le menu du Presse-papiers comporte les commandes Couper, Copier, Coller, Effacer et Sélectionner tout. Vous ne pouvez pas supprimer ces commandes du menu contextuel pour les objets TextField. Pour les objets TextField, la sélection de ces commandes (ou leurs équivalents clavier) ne génère pas d’événement <codeph>clear</codeph>, <codeph>copy</codeph>, <codeph>cut</codeph>, <codeph>paste</codeph> ou <codeph>selectAll</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:doubleClickEnabled:get"><apiName>doubleClickEnabled</apiName><shortdesc> 
	 Spécifie si l’objet reçoit les événements doubleClick.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Spécifie si cet objet reçoit les messages double clic.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Spécifie si l’objet reçoit les événements <codeph>doubleClick</codeph>. La valeur par défaut est <codeph>false</codeph>, ce qui signifie que, par défaut, une occurrence d’InteractiveObject ne reçoit pas les événements <codeph>doubleClick</codeph>. Si la propriété <codeph>doubleClickEnabled</codeph> est réglée sur <codeph>true</codeph>, l’occurrence reçoit les événements <codeph>doubleClick</codeph> qui la concernent. La propriété <codeph>mouseEnabled</codeph> de l’occurrence d’InteractiveObject doit également être réglée sur <codeph>true</codeph> pour que l’objet reçoive les événements <codeph>doubleClick</codeph>.
	 
	 <p>Définir cette propriété ne distribue aucun événement. Vous devez utiliser la méthode <codeph>addEventListener()</codeph> pour ajouter un écouteur d’événement à l’événement <codeph>doubleClick</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InteractiveObject/event:doubleClick"><linktext>doubleClick</linktext></link><link href="flash.display.xml#InteractiveObject/mouseEnabled"><linktext>mouseEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:focusRect:get"><apiName>focusRect</apiName><shortdesc> 
	 Spécifie si l’objet affiche un rectangle de focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip._focusRect, Button._focusRect, and 
	 _focusRect (global property) topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc> 
	 Spécifie si l’objet affiche un rectangle de focus. Trois valeurs sont possibles : <codeph>true</codeph>, <codeph>false</codeph> ou <codeph>null</codeph>. Les valeurs <codeph>true</codeph> et <codeph>false</codeph> fonctionnent comme prévu, c’est-à-dire indiquent si le rectangle du focus s’affiche. La valeur <codeph>null</codeph> indique que cet objet dépend de la propriété <codeph>stageFocusRect</codeph> de la scène.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:mouseEnabled:get"><apiName>mouseEnabled</apiName><shortdesc> 
	 Spécifie si l’objet reçoit les messages souris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 Spécifie si l’objet reçoit les messages souris. La valeur par défaut est <codeph>true</codeph>, ce qui signifie que, par défaut, toute occurrence de InteractiveObject figurant dans la liste d’affichage reçoit les événements de souris. Si <codeph>mouseEnabled</codeph> est défini sur <codeph>false</codeph>, l’occurrence ne reçoit pas d’événement de souris. Aucun enfant de cette occurrence figurant dans la liste d’affichage n’est affecté. Pour modifier le comportement <codeph>mouseEnabled</codeph> de tous les enfants d’un objet figurant dans la liste d’affichage, utilisez <codeph>flash.display.DisplayObjectContainer.mouseChildren</codeph>.
	 <p> Définir cette propriété ne distribue aucun événement. La méthode <codeph>addEventListener()</codeph> vous permet de créer une fonctionnalité interactive.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:tabEnabled:get"><apiName>tabEnabled</apiName><shortdesc> 
	 Indique si cet objet est spécifié dans l’ordre de tabulation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip.tabEnabled, Button.tabEnabled, and 
	 TextField.tabEnabled topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Indique si cet objet est spécifié dans l’ordre de tabulation.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Indique si cet objet est spécifié dans l’ordre de tabulation. Lorsque cet objet figure dans l’ordre de tabulation, la valeur est <codeph>true</codeph>. Sinon, elle est <codeph>false</codeph>. La valeur par défaut est <codeph>false</codeph>, sauf pour les éléments suivants :
     <ul><li>Pour un objet SimpleButton, la valeur est <codeph>true</codeph>.</li>
     <li>Pour un objet TextField avec <codeph>type = "input"</codeph>, la valeur est <codeph>true</codeph>.</li>
     <li>Pour un objet Sprite ou MovieClip avec <codeph>buttonMode = true</codeph>, la valeur <codeph>true</codeph>.</li></ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:tabIndex:get"><apiName>tabIndex</apiName><shortdesc> 
   	 Spécifie l’ordre de tabulation des objets dans un fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Index de tabulation de l’objet.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
   	 Spécifie l’ordre de tabulation des objets dans un fichier SWF. La propriété <codeph>tabIndex</codeph> est réglée sur -1 par défaut, ce qui signifie qu’aucun index de tabulation n’est associé à l’objet.
	 
   	 <p>Si un objet actuellement affiché dans le fichier SWF contient une propriété <codeph>tabIndex</codeph>, l’ordre de tabulation automatique est désactivé : l’ordre de tabulation est alors calculé à partir des propriétés <codeph>tabIndex</codeph> des objets contenus dans le fichier SWF. L’ordre de tabulation personnalisé inclut uniquement les objets dotés de propriétés <codeph>tabIndex</codeph>.</p>
	 
   	 <p>La propriété <codeph>tabIndex</codeph> peut être un entier non négatif. Les objets sont triés selon leurs propriétés <codeph>tabIndex</codeph>, par ordre croissant. Un objet dont la valeur de <codeph>tabIndex</codeph> est définie sur 1 précède celui dont la valeur de <codeph>tabIndex</codeph> est 2. N’appliquez pas la même valeur <codeph>tabIndex</codeph> à plusieurs objets.</p>
	 
	 <p>L’ordre de tabulation personnalisé défini par la propriété <codeph>tabIndex</codeph> est <i>flat</i>. Cela signifie que les relations hiérarchiques des objets contenus dans le fichier SWF ne sont pas prises en compte. Tous les objets du fichier SWF dotés de propriétés <codeph>tabIndex</codeph> sont placés dans l’ordre de tabulation, qui est déterminé par l’ordre des valeurs <codeph>tabIndex</codeph>. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
 Définit un ensemble ordonné de triangles pouvant être restitués à l’aide de coordonnées de remplissage (u,v) ou d’un remplissage normal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit un ensemble ordonné de triangles pouvant être restitués à l’aide de coordonnées de remplissage (u,v) ou d’un remplissage normal. Chaque triangle du tracé est représenté par trois jeux de coordonnées (x, y), correspondant chacun à un point du triangle.
 
 <p>
 Les sommets du triangle ne contiennent pas de coordonnées z et ne représentent pas nécessairement des faces 3D. Toutefois, un tracé de triangle peut être utilisé pour assurer le rendu d’une géométrie 3D dans un espace 2D.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsTrianglePath:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
     Crée un nouvel objet GraphicsTrianglePath.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Vecteur de Nombres où chaque paire de nombres est traitée comme un point (paire x, y). Obligatoire.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Vecteur d’entiers ou d’index, où chaque groupe de trois index définit un triangle. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Vecteur de coordonnées normalisées utilisées pour appliquer un mappage de texture.
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Spécifie si les triangles tournés vers une direction donnée doivent être restitués. Utilisé pour éviter de restituer les triangles que la vue en cours ne permet pas de voir. Peut être défini sur toute valeur définie par la classe TriangleCulling. 
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un nouvel objet GraphicsTrianglePath.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsTrianglePath/culling"><linktext>culling</linktext></link><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsTrianglePath:indices"><apiName>indices</apiName><shortdesc>
     Vecteur d’entiers ou d’index, où chaque groupe de trois index définit un triangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     Vecteur d’entiers ou d’index, où chaque groupe de trois index définit un triangle. Si le paramètre indexes est défini sur null, chaque groupe de trois sommets (six paires de x,y dans le vecteur vertices) définit un triangle. Sinon, chaque index fait référence à un sommet, c’est-à-dire à une paire de nombres dans le vecteur vertices. Par exemple <codeph>indexes[1]</codeph> fait référence à (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>). 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:uvtData"><apiName>uvtData</apiName><shortdesc>
     Vecteur de coordonnées normalisées utilisées pour appliquer un mappage de texture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Vecteur de coordonnées normalisées utilisées pour appliquer un mappage de texture. Chaque coordonnée fait référence à un point sur l’image bitmap utilisée pour le remplissage. Il doit y avoir une coordonnée UV ou UVT par sommet.
     
     <p>
     Dans coordonnées UV, (0,0) est le coin supérieur gauche de l’image bitmap et (1,1) le coin inférieur droit. 
     </p>
                    
     <p>
     Si la longueur de ce vecteur est le double de celle du vecteur <codeph>vertices</codeph>, les coordonnées normalisées sont utilisées sans correction de perspective.
     </p>
     
     <p>
     Si la longueur de ce vecteur est le triple de la longueur du vecteur <codeph>vertices</codeph>, la troisième coordonnée est interprétée comme ’t’, distance séparant l’oeil de la texture dans l’espace visuel. Cela permet au moteur de rendu d’appliquer correctement la perspective lors du mappage des textures en 3D.
     </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:vertices"><apiName>vertices</apiName><shortdesc>
     Vecteur de Nombres, où chaque paire de nombres est traitée comme un point (paire x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Vecteur de Nombres, où chaque paire de nombres est traitée comme un point (paire x, y).
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:culling:get"><apiName>culling</apiName><shortdesc>
     Spécifie si les triangles tournés vers une direction donnée doivent être restitués. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie si les triangles tournés vers une direction donnée doivent être restitués. Utilisé pour éviter de restituer les triangles que la vue en cours ne permet pas de voir.  
     <p>
     Peut être défini sur toute valeur définie par la classe TriangleCulling. 
     </p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObject"><apiName>DisplayObject</apiName><shortdesc>
 La classe DisplayObject constitue la classe de base de tous les objets susceptibles d’être insérés dans la liste d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe DisplayObject constitue la classe de base de tous les objets susceptibles d’être insérés dans la liste d’affichage. Celle-ci gère tous les objets affichés dans Flash Player ou Adobe AIR. La classe DisplayObjectContainer permet d’organiser les objets d’affichage dans la liste d’affichage. Les objets DisplayObjectContainer peuvent avoir des objets enfant, tandis que d’autres objets d’affichage, tels que Shape et TextField, sont des nœuds « feuille » qui comportent uniquement des parents et des frères, pas d’enfant. 
 
 <p>La classe DisplayObject prend en charge des fonctionnalités enfant, telles que la position <i>x</i> et <i>y</i> d’un objet, ainsi que les propriétés les plus avancées de l’objet, telles que sa matrice de transformation. 
 </p>
 
 <p>DisplayObject est une classe de base abstraite. De ce fait, il est impossible de l’appeler directement. Appeler <codeph>new DisplayObject()</codeph> renvoie une exception <codeph>ArgumentError</codeph>. </p>
 
 <p>Tous les objets d’affichage héritent de la classe DisplayObject.</p>
 
 <p>La classe DisplayObject n’inclut pas d’API pour le rendu de contenu à l’écran. Par conséquent, si vous devez créer une sous-classe personnalisée de la classe DisplayObject, vous devez étendre l’une de ses sous-classes qui dispose d’API de rendu de contenu à l’écran, telles que les classes Shape, Sprite, Bitmap, SimpleButton, TextField ou MovieClip.</p>
 
 <p>La classe DisplayObject contient plusieurs événements de diffusion. En règle générale, la cible d’un événement spécifique correspond à une occurrence de DisplayObject. Par exemple, la cible d’un événement <codeph>added</codeph> correspond à l’occurrence de DisplayObject spécifique ajoutée à la liste d’affichage. Ne posséder qu’une seule cible réduit le placement des écouteurs d’événement à cette cible, et dans certains cas aux ancêtres de la cible sur la liste d’affichage. Néanmoins, s’il s’agit d’événements de diffusion, la cible ne correspond pas à une occurrence de DisplayObject spécifique, mais plutôt à toutes les occurrences de DisplayObject, y compris à celles qui ne figurent pas dans la liste d’affichage. Cela signifie que vous pouvez ajouter un écouteur à n’importe quelle occurrence de DisplayObject afin d’écouter les événements de diffusion. Outre les événements de diffusion répertoriés dans le tableau des événements de la classe DisplayObject, la classe DisplayObject hérite de la classe EventDispatcher les deux événements de diffusion suivants : <codeph>activate</codeph> et <codeph>deactivate</codeph>.</p>
 
 <p>Certaines propriétés utilisées précédemment dans les classes MovieClip, TextField et Button d’ActionScript 1.0 et 2.0 (telles que <codeph>_alpha</codeph>, <codeph>_height</codeph>, <codeph>_name</codeph>, <codeph>_width</codeph>, <codeph>_x</codeph>, <codeph>_y</codeph> et autres) disposent d’équivalents dans la classe DisplayObject d’ActionScript 3.0 qui sont renommés de façon à commencer par le caractère souligné (_).</p>
 
 <p>Pour plus d’informations, voir le chapitre « Programmation de l’affichage » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
 
 </apiDesc><example conref="examples\DisplayObjectExample.as"> L’exemple suivant, utilise la classe <codeph>DisplayObjectExample</codeph> pour dessiner un carré orange dans le coin de la scène, puis répondre aux événements en affichant des informations sur le texte de chaque événement. Pour ce faire, procédez comme suit :
 <ol>
    <li>Les propriétés de classe sont déclarées pour la couleur et la taille du carré.</li>
     <li>Le constructeur appelle la méthode <codeph>draw()</codeph> qui dessine un carré orange sur la scène aux coordonnées par défaut <i>x = 0, y = 0</i>.</li>
    <li>Les méthodes d’écouteur d’événements suivantes sont associées au carré :
     <ul>
        <li><codeph>addedHandler()</codeph> écoute les événements <codeph>added</codeph>, appelés lorsque le carré est ajouté à la liste d’affichage.</li>
        <li><codeph>enterFrameHandler()</codeph> écoute les événements <codeph>enterFrame</codeph>, qui n’ont aucune signification réelle dans cet exemple.</li>
        <li><codeph>removedHandler()</codeph> écoute les événements <codeph>removed</codeph>, distribués lorsque le carré est supprimé de la liste d’affichage, ce qui se produit lorsque l’utilisateur clique sur le carré.</li>
        <li><codeph>clickHandler()</codeph> écoute les événements <codeph>click</codeph>, qui sont distribués lorsque l’utilisateur clique sur le carré orange.</li>
        <li><codeph>renderHandler()</codeph> écoute les événements <codeph>render</codeph> une fois la liste d’affichage mise à jour.</li>
  </ul></li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class DisplayObjectExample extends Sprite {
        public function DisplayObjectExample() {
            var child:CustomDisplayObject = new CustomDisplayObject();
            addChild(child);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.events.*;

class CustomDisplayObject extends Sprite {
    private var bgColor:uint = 0xFFCC00;
    private var size:uint    = 80;

    public function CustomDisplayObject() {
        draw();
        addEventListener(Event.ADDED, addedHandler);
        addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        addEventListener(Event.REMOVED, removedHandler);
        addEventListener(MouseEvent.CLICK, clickHandler);
        addEventListener(Event.RENDER, renderHandler);
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }

    private function clickHandler(event:MouseEvent):void {
        trace("clickHandler: " + event);
        parent.removeChild(this);
    }

    private function addedHandler(event:Event):void {
        trace("addedHandler: " + event);
        stage.scaleMode = StageScaleMode.NO_SCALE;
        stage.align = StageAlign.TOP_LEFT;
        stage.addEventListener("resize", resizeHandler);
    }

    private function enterFrameHandler(event:Event):void {
        trace("enterFrameHandler: " + event);
        removeEventListener("enterFrame", enterFrameHandler);
    }

    private function removedHandler(event:Event):void {
        trace("removedHandler: " + event);
        stage.removeEventListener("resize", resizeHandler);
    }

    private function renderHandler(event:Event):void {
        trace("renderHandler: " + event);
    }

    private function resizeHandler(event:Event):void {
        trace("resizeHandler: " + event);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.RENDER_render"><apiName>render</apiName><shortdesc>
 [événement de diffusion] Distribué lorsque la liste d’affichage est sur le point d’être mise à jour et restituée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RENDER</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [événement de diffusion] Distribué lorsque la liste d’affichage est sur le point d’être mise à jour et restituée. Cet événement offre une dernière possibilité de modification des objets qui écoutent cet événement avant le rendu de la liste d’affichage. Vous devez appeler la méthode <codeph>invalidate()</codeph> de l’objet Stage chaque fois que vous souhaitez distribuer un événement <codeph>render</codeph>. Les événements <codeph>Render</codeph> ne sont distribués à un objet que s’il existe un lien d’approbation entre ce dernier et l’objet qui a appelé <codeph>Stage.invalidate()</codeph>. Cet événement est un événement de diffusion, ce qui signifie qu’il est distribué par tous les objets d’affichage avec un écouteur enregistré pour cet événement.
 
 <p><b>Remarque : </b>cet événement n’est pas distribué si l’affichage n’effectue pas de rendu. Tel est le cas lorsque le contenu est réduit en icône ou masqué. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_FROM_STAGE_removedFromStage"><apiName>removedFromStage</apiName><shortdesc>
 Distribué lorsqu’un objet d’affichage est sur le point d’être supprimé de la liste d’affichage de la scène, directement ou par l’intermédiaire de la suppression d’une arborescence secondaire qui contient l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED_FROM_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet d’affichage est sur le point d’être supprimé de la liste d’affichage de la scène, directement ou par l’intermédiaire de la suppression d’une arborescence secondaire qui contient l’objet d’affichage. Les deux méthodes de la classe DisplayObjectContainer génèrent cet événement : <codeph>removeChild()</codeph> et <codeph>removeChildAt()</codeph>. 
 
 <p>Les méthodes suivantes d’un objet DisplayObjectContainer génèrent également cet événement lorsqu’un objet doit être supprimé pour céder la place au nouvel objet : <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph> et <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_removed"><apiName>removed</apiName><shortdesc>
 Distribué lorsqu’un objet d’affichage est sur le point d’être supprimé de la liste d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet d’affichage est sur le point d’être supprimé de la liste d’affichage. Les deux méthodes de la classe DisplayObjectContainer génèrent cet événement : <codeph>removeChild()</codeph> et <codeph>removeChildAt()</codeph>. 
 
 <p>Les méthodes suivantes d’un objet DisplayObjectContainer génèrent également cet événement lorsqu’un objet doit être supprimé pour céder la place au nouvel objet : <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph> et <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.EXIT_FRAME_exitFrame"><apiName>exitFrame</apiName><shortdesc>
 [événement de diffusion] Distribué lorsque la tête de lecture quitte l’image en cours.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXIT_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [événement de diffusion] Distribué lorsque la tête de lecture quitte l’image en cours. Tous les scripts d’image ont été exécutés. Lorsque la tête de lecture ne bouge pas, ou lorsqu’il n’y a qu’une seule image, cet événement est distribué de façon continue, en fonction de la cadence d’images. Cet événement est un événement de diffusion, ce qui signifie qu’il est distribué par tous les objets d’affichage avec un écouteur enregistré pour cet événement.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.FRAME_CONSTRUCTED_frameConstructed"><apiName>frameConstructed</apiName><shortdesc>
 [événement de diffusion] Distribué après l’exécution des constructeurs des objets d’affichage d’image, mais avant celle des scripts d’image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.FRAME_CONSTRUCTED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [événement de diffusion] Distribué après l’exécution des constructeurs des objets d’affichage d’image, mais avant celle des scripts d’image. Lorsque la tête de lecture ne bouge pas ou lorsqu’il n’existe qu’une seule image, cet événement est distribué de façon continue, en fonction de la cadence d’images. Cet événement est un événement de diffusion, ce qui signifie qu’il est distribué par tous les objets d’affichage avec un écouteur enregistré pour cet événement.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ENTER_FRAME_enterFrame"><apiName>enterFrame</apiName><shortdesc>
 [événement de diffusion] Distribué lorsque la tête de lecture est placée sur une nouvelle image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ENTER_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [événement de diffusion] Distribué lorsque la tête de lecture est placée sur une nouvelle image. Lorsque la tête de lecture ne bouge pas ou lorsqu’il n’existe qu’une seule image, cet événement est distribué de façon continue, en fonction de la cadence d’images. Cet événement est un événement de diffusion, ce qui signifie qu’il est distribué par tous les objets d’affichage avec un écouteur enregistré pour cet événement.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_TO_STAGE_addedToStage"><apiName>addedToStage</apiName><shortdesc>
 Envoyé lorsqu’un objet d’affichage est ajouté dans la liste d’affichage de la scène, directement ou par l’intermédiaire d’une arborescence secondaire qui contient l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED_TO_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Envoyé lorsqu’un objet d’affichage est ajouté dans la liste d’affichage de la scène, directement ou par l’intermédiaire d’une arborescence secondaire qui contient l’objet d’affichage. Les méthodes suivantes déclenchent cet événement : <codeph>DisplayObjectContainer.addChild()</codeph>, <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_added"><apiName>added</apiName><shortdesc>
 Distribué lorsqu’un objet d’affichage est ajouté à la liste d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet d’affichage est ajouté à la liste d’affichage. Les méthodes suivantes déclenchent cet événement : <codeph>DisplayObjectContainer.addChild()</codeph>, <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:DisplayObject:getBounds"><apiName>getBounds</apiName><shortdesc>
     Renvoie un rectangle qui définit la zone de l’objet d’affichage relativement au système de coordonnées de l’objet targetCoordinateSpace.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Le rectangle qui définit la zone de l’objet d’affichage par rapport au système de coordonnées de l’objet <codeph>targetCoordinateSpace</codeph>.
     
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Objet d’affichage qui définit le système de coordonnées à utiliser.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie un rectangle qui définit la zone de l’objet d’affichage relativement au système de coordonnées de l’objet <codeph>targetCoordinateSpace</codeph>. Consultez le code suivant, qui indique comment le rectangle renvoyé peut varier en fonction du paramètre <codeph>targetCoordinateSpace</codeph> que vous transmettez à la méthode :
     
     <codeblock>
     var container:Sprite = new Sprite();
     container.x = 100;
     container.y = 100;
     this.addChild(container);
     var contents:Shape = new Shape();
     contents.graphics.drawCircle(0,0,100);
     container.addChild(contents);
     trace(contents.getBounds(container));
      // (x=-100, y=-100, w=200, h=200)
     trace(contents.getBounds(this));
      // (x=0, y=0, w=200, h=200)
     </codeblock>
     
     
     <p><b>Remarque :</b> utilisez les méthodes <codeph>localToGlobal()</codeph> et <codeph>globalToLocal()</codeph> pour convertir les coordonnées locales de l’objet d’affichage en coordonnées d’affichage, ou pour convertir les coordonnées d’affichage en coordonnées locales.</p>
     
     <p>La méthode <codeph>getBounds()</codeph> est semblable à la méthode <codeph>getRect()</codeph>. Cependant, le rectangle renvoyé par la méthode <codeph>getBounds()</codeph> inclut les traits appliqués aux formes, contrairement au rectangle renvoyé par la méthode <codeph>getRect()</codeph>. Pour consulter un exemple d’utilisation de la méthode <codeph>getRect()</codeph>, reportez-vous à la description correspondante.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getRect()"><linktext>getRect()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:getRect"><apiName>getRect</apiName><shortdesc>
    Renvoie un rectangle qui définit les limites de l’objet d’affichage, en se basant sur le système de coordonnées défini par le paramètre targetCoordinateSpace, moins tout trait appliqué aux formes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Le rectangle qui définit la zone de l’objet d’affichage par rapport au système de coordonnées de l’objet <codeph>targetCoordinateSpace</codeph>.
    
    </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Objet d’affichage qui définit le système de coordonnées à utiliser.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Renvoie un rectangle qui définit les limites de l’objet d’affichage, en se basant sur le système de coordonnées défini par le paramètre <codeph>targetCoordinateSpace</codeph>, moins tout trait appliqué aux formes. Les valeurs renvoyées par la méthode <codeph>getRect()</codeph> sont inférieures ou égales à celles qui sont renvoyées par la méthode <codeph>getBounds()</codeph>.
    
    <p><b>Remarque :</b> utilisez les méthodes <codeph>localToGlobal()</codeph> et <codeph>globalToLocal()</codeph> pour convertir les coordonnées locales de l’objet d’affichage en coordonnées de scène, ou pour convertir les coordonnées de scène en coordonnées locales.</p>
    
    </apiDesc><example conref="examples\DisplayObject.getRect.1.as"> L’exemple suivant indique comment la méthode <codeph>getBounds()</codeph> peut renvoyer un rectangle dont les dimensions sont supérieures à celles de la méthode <codeph>getRect()</codeph>, du fait de la zone supplémentaire qui est occupée par les traits. Dans ce cas, le sprite <codeph>triangle</codeph> inclut des traits supplémentaires en raison des paramètres <codeph>width</codeph> et <codeph>jointStyle</codeph> de la méthode <codeph>lineStyle()</codeph>. La sortie <codeph>trace()</codeph> (dans les deux dernières lignes) indique la différence entre les rectangles <codeph>getRect()</codeph> et <codeph>getBounds()</codeph> :
<codeblock>

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.geom.Rectangle;

var triangle:Sprite = new Sprite();
var color:uint = 0xFF0044;
var width:Number = 20;
var alpha:Number = 1.0;
var pixelHinting:Boolean = true;
var scaleMode:String = LineScaleMode.NORMAL;
var caps:String = CapsStyle.SQUARE;
var joints:String = JointStyle.MITER;
triangle.graphics.lineStyle(width, color, alpha, pixelHinting, scaleMode, caps, joints);

var triangleSide:Number = 100;
triangle.graphics.moveTo(0, 0);
triangle.graphics.lineTo(0, triangleSide);
triangle.graphics.lineTo(triangleSide, triangleSide);
triangle.graphics.lineTo(0, 0);

addChild(triangle);

trace(triangle.getBounds(this)); // (x=-10, y=-24.1, w=134.10000000000002, h=134.1)
trace(triangle.getRect(this));     // (x=0, y=0, w=100, h=100)
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getBounds()"><linktext>getBounds()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal"><apiName>globalToLocal</apiName><shortdesc>
     Convertit l’objet point des coordonnées de scène (globales) vers les coordonnées de l’objet d’affichage (locales).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Point dont les coordonnées sont relatives à l’objet d’affichage.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Objet créé avec la classe Point. L’objet Point spécifie les coordonnées <i>x</i> et <i>y</i> en tant que propriétés.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Convertit l’objet <codeph>point</codeph> des coordonnées de l’objet Stage (globales) vers les coordonnées de l’objet d’affichage (locales).
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Convertit l’objet <codeph>point</codeph> des coordonnées de scène (globales) vers les coordonnées de l’objet d’affichage (locales).
     
     <p>Pour utiliser cette méthode, commencez par créer une occurrence de la classe Point. Les valeurs <i>x</i> et <i>y</i> que vous affectez représentent des coordonnées globales dans la mesure où elles se référent à l’origine (0,0) de la zone d’affichage principal. Passez ensuite l’occurrence Point en tant que paramètre à la méthode <codeph>globalToLocal()</codeph>. La méthode renvoie un nouvel objet Point avec des valeurs <i>x</i> et <i>y</i> qui se rapportent à l’origine de l’objet d’affichage et non pas à l’origine de la scène.</p>
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> Le code suivant crée un objet Shape et affiche le résultat de l’appel de la méthode <codeph>hitTestPoint()</codeph>, qui utilise différents points en tant que paramètres. La méthode <codeph>globalToLocal()</codeph> convertit le point provenant des coordonnées de l’objet Stage en espace de coordonnées de la forme :
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link><link href="flash.geom.xml#Point"><linktext>Classe flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal3D"><apiName>globalToLocal3D</apiName><shortdesc>
     Convertit un point bidimensionnel à partir des coordonnées de scène (globales) vers les coordonnées d’un objet d’affichage tridimensionnel (locales).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Vector3D dont les coordonnées sont relatives à l’objet d’affichage tridimensionnel. 
     
     </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Objet Point bidimensionnel représentant les coordonnés globales x et y.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Convertit un point bidimensionnel à partir des coordonnées de scène (globales) vers les coordonnées d’un objet d’affichage tridimensionnel (locales).
     
     <p>Pour utiliser cette méthode, commencez par créer une occurrence de la classe Point. Les valeurs x et y que vous affectez à l’objet Point représentent des coordonnées globales dans la mesure où elles se rapportent à l’origine (0,0) de la zone d’affichage principale. Transmettez ensuite l’objet Point à la méthode <codeph>globalToLocal3D()</codeph> en tant que paramètre <codeph>point</codeph>. La méthode renvoie les coordonnées tridimensionnelles en tant qu’objet Vector3D contenant les valeurs <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph> relatives à l’origine de l’objet d’affichage tridimensionnel.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestObject"><apiName>hitTestObject</apiName><shortdesc>
     Evalue le cadre de sélection de l’objet d’affichage pour savoir s’il recouvre ou recoupe le cadre de sélection de l’objet d’affichage obj.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Définie sur <codeph>true</codeph> si les cadres de sélection des objets d’affichage se recoupent, sur <codeph>false</codeph> dans le cas contraire.
     
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Objet d’affichage à utiliser pour le test.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Evalue le cadre de sélection de l’objet d’affichage pour savoir s’il recouvre ou recoupe le cadre de sélection de l’objet d’affichage transmis en tant que paramètre.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Evalue le cadre de sélection de l’objet d’affichage pour savoir s’il recouvre ou recoupe le cadre de sélection de l’objet d’affichage <codeph>obj</codeph>.
     
     </apiDesc><example conref="examples\DisplayObject.hitTestObject.1.as"> Le code suivant crée trois objets Shape et affiche le résultat de l’appel de la méthode <codeph>hitTestObject()</codeph>. Notez que même si les objets circle2 et circle3 ne se recoupent pas, leurs cadres de sélection, eux, se recoupent. Par conséquent, le test de recherche des objets circle2 et circle3 renvoie <codeph>true</codeph>.
<codeblock>

import flash.display.Shape;

var circle1:Shape = new Shape();
circle1.graphics.beginFill(0x0000FF);
circle1.graphics.drawCircle(40, 40, 40);
addChild(circle1);

var circle2:Shape = new Shape();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(40, 40, 40);
circle2.x = 50;
addChild(circle2);

var circle3:Shape = new Shape();
circle3.graphics.beginFill(0xFF0000);
circle3.graphics.drawCircle(40, 40, 40);
circle3.x = 100;
circle3.y = 67;
addChild(circle3);

trace(circle1.hitTestObject(circle2)); // true
trace(circle1.hitTestObject(circle3)); // false
trace(circle2.hitTestObject(circle3)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestPoint"><apiName>hitTestPoint</apiName><shortdesc>
     Evalue l’objet d’affichage pour savoir s’il recouvre ou recoupe le point spécifié par les paramètres x et y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si l’objet d’affichage recouvre ou recoupe le point spécifié, <codeph>false</codeph> dans tous les autres cas.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> à tester par rapport à l’objet.
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> à tester par rapport à l’objet.
     
     </apiDesc></apiParam><apiParam><apiItemName>shapeFlag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si la vérification doit porter sur les pixels réels de l’objet (<codeph>true</codeph>) ou du cadre de sélection (<codeph>false</codeph>). 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Evalue l’objet d’affichage pour savoir s’il recouvre ou recoupe le point spécifié par x et y.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Evalue l’objet d’affichage pour savoir s’il recouvre ou recoupe le point spécifié par les paramètres <codeph>x</codeph> et <codeph>y</codeph>. Les paramètres <codeph>x</codeph> et <codeph>y</codeph> spécifient un point dans l’espace de coordonnées de la scène et non pas le conteneur d’objet d’affichage qui contient l’objet d’affichage (sauf si ce conteneur correspond à la scène).
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> Le code suivant crée un objet Shape et affiche le résultat de l’appel de la méthode <codeph>hitTestPoint()</codeph>, qui utilise différents points en tant que paramètres. La méthode <codeph>globalToLocal()</codeph> convertit le point provenant des coordonnées de l’objet Stage en espace de coordonnées de la forme :
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:local3DToGlobal"><apiName>local3DToGlobal</apiName><shortdesc>
     Convertit un point tridimensionnel des coordonnées de l’objet d’affichage tridimensionnel (locales) vers un point bidimensionnel dans les coordonnées de scène (globales).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Point bidimensionnel représentant un point tridimensionnel dans un espace bidimensionnel.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point3d</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D contenant soit un point tridimensionnel soit les coordonnées de l’objet d’affichage tridimensionnel.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Convertit un point tridimensionnel des coordonnées de l’objet d’affichage tridimensionnel (locales) vers un point bidimensionnel dans les coordonnées de scène (globales).
     
     <p>Par exemple, vous pouvez utiliser uniquement des coordonnées bidimensionnelles (x,y) pour dessiner à l’aide des méthodes <codeph>display.Graphics</codeph>. Pour dessiner un objet tridimensionnel, vous devez mapper les coordonnées tridimensionnelles d’un objet d’affichage sur les coordonnées bidimensionnelles. Commencez par créer une occurrence de la classe Vector3D contenant les coordonnées x, y, et z de l’objet d’affichage tridimensionnel. Transmettez ensuite l’objet Vector3D à la méthode <codeph>local3DToGlobal()</codeph> en tant que paramètre <codeph>point3d</codeph>. La méthode renvoie un objet Point bidimensionnel pouvant être utilisé avec l’API graphique pour dessiner l’objet tridimensionnel.</p>
     
     
     </apiDesc><example conref="examples\Local3DToGlobalExample.as"> Cet exemple dessine un cube tridimensionnel simple dans un espace bidimensionnel à l’aide des méthodes <codeph>display.Graphics</codeph>. L’emplacement de l’objet d’affichage <codeph>this</codeph> est décalé afin que le point d’alignement du cube soit en son centre. Un vecteur des objets Vector3D contient les coordonnées tridimensionnelles du cube. La partie supérieure du cube est dessinée en premier. Vient ensuite la partie inférieure. Enfin, les quatre coins supérieurs et inférieurs sont connectés. Pour utiliser la méthode <codeph>local3DToGlobal()</codeph>, vous devez ajouter le cube au conteneur d’objet d’affichage avant de dessiner le cube. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.geom.*;

    public class Local3DToGlobalExample extends MovieClip {
        private var myCube:Sprite = new Sprite();
        private var v8:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(8);

        public function Local3DToGlobalExample():void {
            this.x = -(this.stage.stageWidth / 2);
            this.y = -(this.stage.stageWidth / 2);

            v8[0] = new Vector3D(-40,-40,-40);
            v8[1] = new Vector3D(40,-40,-40);
            v8[2] = new Vector3D(40,-40,40);
            v8[3] = new Vector3D(-40,-40,40);
            v8[4] = new Vector3D(-40,100,-40);
            v8[5] = new Vector3D(40,100,-40);
            v8[6] = new Vector3D(40,100,40);
            v8[7] = new Vector3D(-40,100,40);

            myCube.x = (this.stage.stageWidth / 2);
            myCube.y = (this.stage.stageWidth / 2);
            myCube.z = 1;
            addChild(myCube);

            Cube();         
        }

        private function Cube():void {
            var ps:Point = new Point(0,0);

            myCube.graphics.lineStyle(2,0xFF0000);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:localToGlobal"><apiName>localToGlobal</apiName><shortdesc>
     Convertit l’objet point des coordonnées de l’objet d’affichage (locales) vers les coordonnées de la scène (globales).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Point dont les coordonnées sont relatives à la scène.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le nom ou l’identificateur d’un point créé avec la classe Point, qui spécifie les coordonnées <i>x</i> et <i>y</i> en tant que propriétés.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Convertit l’objet <codeph>point</codeph> des coordonnées de l’objet d’affichage (locales) vers les coordonnées de la scène (globales).
     
     <p>Cette méthode permet de convertir les coordonnées <i>x</i> et <i>y</i> des valeurs qui se rapportent à l’origine (0,0) d’un objet d’affichage spécifique (coordonnées locales) en valeurs qui se rapportent à l’origine de la scène (coordonnées globales).</p>
     
     <p>Pour utiliser cette méthode, commencez par créer une occurrence de la classe Point. Les valeurs <i>x</i> et <i>y</i> que vous affectez représentent des coordonnées locales dans la mesure où elles se référent à l’origine de l’objet d’affichage principal.</p>
     
     <p>Vous transmettez ensuite l’occurrence de Point que vous avez créée en tant que paramètre à la méthode <codeph>localToGlobal()</codeph>. La méthode renvoie un nouvel objet Point avec des valeurs <i>x</i> et <i>y</i> qui se rapportent à l’origine de la scène et non pas à l’origine de l’objet d’affichage.</p>
     
     </apiDesc><example conref="examples\DisplayObject.localToGlobal.1.as"> Le code suivant crée un objet Sprite. Les propriétés <codeph>mouseX</codeph> et <codeph>mouseY</codeph> du sprite figurent dans l’espace de coordonnées de l’objet d’affichage. Ce code utilise la méthode <codeph>localToGlobal()</codeph> pour convertir ces propriétés en coordonnées globales (scène) :
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.Point;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
square.x = 100;
square.y = 200;

addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates)

function traceCoordinates(event:MouseEvent):void {
    var clickPoint:Point = new Point(square.mouseX, square.mouseY);
    trace("display object coordinates:", clickPoint);
    trace("stage coordinates:", square.localToGlobal(clickPoint));
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.geom.xml#Point"><linktext>Classe flash.geom.Point</linktext></link></related-links></apiOperation><apiValue id="flash.display:DisplayObject:accessibilityProperties:get"><apiName>accessibilityProperties</apiName><shortdesc>
     Options d’accessibilité actuelles de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.accessibility:AccessibilityProperties</apiValueClassifier></apiValueDef><apiDesc>
     Options d’accessibilité actuelles de l’objet d’affichage. Si vous modifiez la propriété <codeph>accessibilityProperties</codeph> ou l’un de ses champs dans <codeph>accessibilityProperties</codeph>, vous devez appeler la méthode <codeph>Accessibility.updateProperties()</codeph> pour appliquer vos modifications.
     
     <p class="flashonly"><b>Remarque </b>: Pour tout objet créé dans l’environnement de programmation Flash, la valeur de <codeph>accessibilityProperties</codeph> est préremplie avec les informations que vous avez entrées dans le panneau Accessibilité pour cet objet.</p>
     
     </apiDesc><example conref="examples\DisplayObject.accessibilityProperties.1.as"> L’exemple suivant indique comment joindre un objet AccessibilityProperties simple à une occurrence TextField :
<codeblock>

import flash.text.TextField;
import flash.accessibility.AccessibilityProperties;
import flash.accessibility.Accessibility;
import flash.system.Capabilities;

var tf:TextField = new TextField();
tf.text = "hello";

var accessProps:AccessibilityProperties = new AccessibilityProperties();
accessProps.name = "Greeting";

tf.accessibilityProperties = accessProps;

if (Capabilities.hasAccessibility) {
    Accessibility.updateProperties();
}

trace(tf.accessibilityProperties.name); // Greeting
</codeblock></example></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link><link href="flash.accessibility.xml#AccessibilityProperties"><linktext>flash.accessibility.AccessibilityProperties</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:alpha:get"><apiName>alpha</apiName><shortdesc>
     Indique la valeur de transparence alpha de l’objet spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la valeur de transparence alpha de l’objet spécifié. Les valeurs gérées sont comprises entre 0 (entièrement transparent) et 1 (entièrement opaque). La valeur par défaut est 1. Les objets d’affichage où <codeph>alpha</codeph> est défini sur 0 <i>sont</i> actifs, même s’ils sont invisibles.
     
     </apiDesc><example conref="examples\DisplayObject.alpha.1.as"> Le code suivant définit la propriété <codeph>alpha</codeph> d’un sprite sur 50 % lorsque la souris survole le sprite :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.alpha = 0.5;
}

function restoreObject(event:MouseEvent):void {
    event.target.alpha = 1.0;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:blendMode:get"><apiName>blendMode</apiName><shortdesc>
     Valeur de la classe BlendMode qui spécifie le mode de fondu à utiliser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur de la classe BlendMode qui spécifie le mode de fusion à utiliser. Une image bitmap peut être tracée en interne de deux manières. Si un mode de fusion ou un masque de découpage externe est activé, l’image bitmap est tracée en ajoutant au rendu vectoriel une forme carrée contenant cette image bitmap. Si vous tentez de régler cette propriété sur une valeur non valide, Flash Player ou Adobe AIR la remplace par <codeph>BlendMode.NORMAL</codeph>.
     
     <p>La propriété <codeph>blendMode</codeph> affecte chaque pixel de l’objet d’affichage. Chaque pixel est composé de trois couleurs élémentaires (rouge, vert et bleu), chacune de ces couleurs ayant une valeur située entre 0x00 et 0xFF. Flash Player ou Adobe AIR compare chaque couleur constituante d’un pixel dans le clip avec la couleur correspondante du pixel d’arrière-plan. Par exemple si <codeph>blendMode</codeph> est défini sur <codeph>BlendMode.LIGHTEN</codeph>, Flash Player ou Adobe AIR compare la valeur rouge de l’objet d’affichage avec la valeur rouge de l’arrière-plan, et utilise la plus claire des deux comme valeur pour le composant rouge de la couleur affichée.</p>
     
     <p>Le tableau suivant répertorie les réglages <codeph>blendMode</codeph>. La classe BlendMode définit les valeurs de chaîne que vous pouvez utiliser. Les illustrations du tableau ci-dessous présentent les valeurs <codeph>blendMode</codeph> appliquées à un objet d’affichage (2) circulaire superposé sur un autre objet d’affichage (1).</p>
     
     
     <p>
      <adobeimage alt="Carré numéro 1" href="../../images/blendMode-0a.jpg"/> <adobeimage alt="Cercle numéro 2" href="../../images/blendMode-0b.jpg"/>
     
     </p>
     
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Constante BlendMode</entry><entry>Illustration</entry><entry>Description</entry></row></thead><tbody><row valign="top">
     <entry><codeph>BlendMode.NORMAL</codeph></entry>
     <entry><adobeimage alt="mode de fondu NORMAL" href="../../images/blendMode-1.jpg"/></entry>
     <entry>L’objet d’affichage apparaît devant l’arrière-plan. Les valeurs de pixels de l’objet d’affichage écrasent celles de l’arrière-plan. Lorsque l’objet d’affichage est transparent, l’arrière-plan est visible.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LAYER</codeph></entry>
     <entry><adobeimage alt="mode de fondu LAYER" href="../../images/blendMode-2.jpg"/></entry>
     
     <entry>Impose la création d’un groupe de transparences pour l’objet d’affichage. Cela signifie que l’objet d’affichage est précomposé dans un tampon temporaire avant que son traitement ne se poursuive. Cette opération s’exécute automatiquement si l’objet d’affichage est préplacé en mémoire cache par le biais d’une mise en cache des bitmaps ou s’il correspond à un conteneur d’objet d’affichage qui possède au moins un objet enfant associé à un réglage <codeph>blendMode</codeph> autre que <codeph>BlendMode.NORMAL</codeph>.
     </entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.MULTIPLY</codeph></entry>
     <entry><adobeimage alt="mode de fondu MULTIPLY" href="../../images/blendMode-3.jpg"/></entry>
     
     <entry>Multiplie les valeurs des couleurs élémentaires de l’objet d’affichage par celles de la couleur d’arrière-plan, puis les normalise en les divisant par 0xFF, ce qui donne des couleurs plus sombres. Ce réglage est souvent utilisé pour les effets d’ombre et de profondeur.
     
     <p>Par exemple, si une couleur élémentaire (comme le rouge) d’un pixel de l’objet d’affichage et la couleur correspondante du pixel de l’arrière-plan ont toutes les deux une valeur de 0x88, le résultat de la multiplication est 0x4840. La division par 0xFF donne une valeur de 0x48 pour cette couleur élémentaire, qui est plus sombre que celle de l’objet d’affichage ou de l’arrière-plan.</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SCREEN</codeph></entry>
     <entry><adobeimage alt="mode de fondu SCREEN" href="../../images/blendMode-4.jpg"/></entry>
     
     <entry>Multiplie le complément (l’inverse) de la couleur de l’objet d’affichage par le complément de la couleur d’arrière-plan, ce qui donne un effet de blanchissement. Ce réglage est couramment utilisé pour la mise en valeur ou pour supprimer les parties noires de l’objet d’affichage.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LIGHTEN</codeph></entry>
     <entry><adobeimage alt="mode de fondu LIGHTEN" href="../../images/blendMode-5.jpg"/></entry>
     
     <entry>Sélectionne les plus claires des couleurs élémentaires de l’objet d’affichage et la couleur d’arrière-plan (celles qui ont les valeurs les plus élevées). Ce réglage est généralement utilisé pour les superpositions.
     
     <p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xFFCC33, et que le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDDF800, la valeur RVB obtenue pour le pixel affiché est 0xFFF833 (car 0xFF > 0xDD, 0xCC &lt; 0xF8 et 0x33 > 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DARKEN</codeph></entry>
     <entry><adobeimage alt="mode de fondu DARKEN" href="../../images/blendMode-6.jpg"/></entry>
     
     <entry>Sélectionne les plus sombres des couleurs élémentaires de l’objet d’affichage et de l’arrière-plan (celles qui ont les valeurs les plus faibles). Ce réglage est généralement utilisé pour les superpositions.
     
     <p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xFFCC33, et que le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDDF800, la valeur RVB obtenue pour le pixel affiché est 0xDDCC00 (car 0xFF > 0xDD, 0xCC &lt; 0xF8 et 0x33 > 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DIFFERENCE</codeph></entry>
     <entry><adobeimage alt="mode de fondu DIFFERENCE" href="../../images/blendMode-7.jpg"/></entry>
     
     <entry>Compare les couleurs élémentaires de l’objet d’affichage à celles de son arrière-plan et soustrait la valeur la plus sombre des deux couleurs élémentaires de la plus claire. Ce réglage est habituellement utilisé pour obtenir des couleurs plus vibrantes.
     
     <p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xFFCC33, et le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDDF800, la valeur RVB résultante du pixel affiché est 0x222C33 (parce que 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C et 0x33 - 0x00 = 0x33).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ADD</codeph></entry>
     <entry><adobeimage alt="mode de fondu ADD" href="../../images/blendMode-8.jpg"/></entry>
     
     <entry>Ajoute les valeurs des couleurs élémentaires de l’objet d’affichage à celles de son arrière-plan, en appliquant un plafond de 0xFF. Ce réglage est habituellement utilisé pour animer un fondu d’éclaircissement entre deux objets.
     
     <p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xAAA633, et que le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDD2200, la valeur RVB résultante du pixel affiché est 0xFFC833 (parce que 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8 et 0x33 + 0x00 = 0x33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.SUBTRACT</codeph></entry>
     <entry><adobeimage alt="mode de fondu SUBTRACT" href="../../images/blendMode-9.jpg"/></entry>
     
     <entry>Soustrait les valeurs des couleurs élémentaires de l’objet d’affichage de celles de la couleur d’arrière-plan, en appliquant un plancher de 0. Ce réglage est habituellement utilisé pour animer un fondu de plus en plus sombre entre deux objets.
     
     <p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xAA2233, et que le pixel d’arrière-plan a une valeur RVB réglée sur 0xDDA600, alors la valeur RVB obtenue pour le pixel affiché est 0x338400 (car 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84 et 0x00 - 0x33 &lt; 0x00).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.INVERT</codeph></entry>
     <entry><adobeimage alt="mode de fondu INVERT" href="../../images/blendMode-10.jpg"/></entry>
     
     <entry>Inverse l’arrière-plan.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ALPHA</codeph></entry>
     <entry><adobeimage alt="mode de fondu ALPHA" href="../../images/blendMode-11.jpg"/></entry>
     
     <entry>Applique la valeur alpha de chaque pixel de l’objet d’affichage à l’arrière-plan. Pour ce faire, le réglage <codeph>blendMode</codeph> de l’objet d’affichage parent doit être réglé sur <codeph>BlendMode.LAYER</codeph>. Par exemple, dans l’illustration, l’objet d’affichage parent, qui est un arrière-plan blanc, a un paramètre <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ERASE</codeph></entry>
     <entry><adobeimage alt="mode de fondu ERASE" href="../../images/blendMode-12.jpg"/></entry>
     
     <entry>Efface l’arrière-plan sur la base de la valeur alpha de l’objet d’affichage. Pour ce faire, le réglage <codeph>blendMode</codeph> de l’objet d’affichage parent doit être défini sur <codeph>BlendMode.LAYER</codeph>. Par exemple, dans l’illustration, l’objet d’affichage parent, qui est un arrière-plan blanc, a un paramètre <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.OVERLAY</codeph></entry>
     <entry><adobeimage alt="mode de fondu OVERLAY" href="../../images/blendMode-13.jpg"/></entry>
     
     <entry>Ajuste la couleur de chaque pixel sur la base de l’obscurité de l’arrière-plan. Si l’arrière-plan est plus clair qu’un gris à 50 %, les couleurs de l’objet d’affichage et de l’arrière-plan sont masquées, ce qui donne une couleur plus claire. Si l’arrière-plan est plus foncé qu’un gris à 50 %, les couleurs sont multipliées, ce qui donne une couleur plus sombre. Ce réglage est habituellement utilisé pour les effets d’ombrage.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.HARDLIGHT</codeph></entry>
     <entry><adobeimage alt="mode de fondu HARDLIGHT" href="../../images/blendMode-14.jpg"/></entry>
     
     <entry>Ajuste la couleur de chaque pixel sur la base de l’obscurité de l’objet d’affichage. Si l’objet d’affichage est plus clair qu’un gris à 50 %, les couleurs de l’objet d’affichage et de l’arrière-plan sont masquées, ce qui permet d’obtenir une couleur plus claire. Si l’objet d’affichage est plus foncé qu’un gris à 50 %, les couleurs sont multipliées, ce qui donne une couleur plus sombre. Ce réglage est habituellement utilisé pour les effets d’ombrage.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SHADER</codeph></entry>
     <entry align="center" valign="middle">S/O</entry>
     
     <entry>Ajuste la couleur à l’aide d’une routine de shader personnalisée. Le shader utilisé est spécifié en tant qu’occurrence Shader affectée à la propriété <codeph>blendShader</codeph>. La définition de la propriété <codeph>blendShader</codeph> d’un objet d’affichage sur une occurrence Shader définit automatiquement la propriété <codeph>blendMode</codeph> de l’objet d’affichage sur <codeph>BlendMode.SHADER</codeph>. Si la propriété <codeph>blendMode</codeph> est définie sur <codeph>BlendMode.SHADER</codeph> sans que la propriété <codeph>blendShader</codeph> n’ait été définie auparavant, la propriété <codeph>blendMode</codeph> est définie sur <codeph>BlendMode.NORMAL</codeph>.</entry>
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\DisplayObject.blendMode.1.as"> Le code suivant crée deux objets sprite, un carré et un cercle, puis définit le mode de fondu du cercle (au premier plan) sur <codeph>BlendMode.SUBTRACT</codeph> lorsque le pointeur survole le cercle :
<codeblock>
import flash.display.Sprite;
import flash.display.BlendMode;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF88CC);
square.graphics.drawRect(0, 0, 80, 80);
addChild(square);

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.SUBTRACT;
}

function restoreObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.NORMAL;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>blendShader</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:cacheAsBitmap:get"><apiName>cacheAsBitmap</apiName><shortdesc>
     Si true est défini, Flash Player ou Adobe AIR place en mémoire cache une version bitmap interne de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Indique si la mise en cache de cet objet DisplayObject sous forme d’image bitmap est activée ou non.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Si <codeph>true</codeph> est défini, Flash Player ou Adobe AIR place en mémoire cache une version bitmap interne de l’objet d’affichage. Cette mise en cache permet d’améliorer les performances des objets d’affichage qui intègrent du contenu vectoriel complexe.
     
     <p>Toutes les données vectorielles d’un objet d’affichage contenant une image bitmap en mémoire cache sont tracées sur l’image bitmap et non pas sur l’affichage principal. Cette image bitmap est ensuite copiée sur l’affichage principal sous forme de pixels sans étirement ou rotation et accrochés aux limites de pixels les plus proches. Les correspondances des pixels avec l’objet parent se font selon un rapport de 1 à 1. Si les limites de l’image bitmap changent, elle est recréée au lieu d’être étirée.</p>
     
     <p>Aucune bitmap interne n’est créée sauf si la propriété <codeph>cacheAsBitmap</codeph> est définie sur <codeph>true</codeph>.</p>
     
     <p>Après avoir défini la propriété <codeph>cacheAsBitmap</codeph> du bouton sur <codeph>true</codeph>, le rendu ne change pas, bien que l’objet d’affichage procède automatiquement à l’accrochage aux pixels. La vitesse d’animation peut être beaucoup plus importante selon la complexité du contenu vectoriel.
     </p>
     
     <p>La propriété <codeph>cacheAsBitmap</codeph> est définie automatiquement sur <codeph>true</codeph> lorsque vous appliquez un filtre à l’objet d’affichage (lorsque son tableau <codeph>filter</codeph> n’est pas vide). Lorsqu’un objet d’affichage est filtré, <codeph>cacheAsBitmap</codeph> renvoie la valeur <codeph>true</codeph> pour cet objet d’affichage, même si vous l’aviez définie sur <codeph>false</codeph>. Si vous supprimez tous les filtres d’un objet d’affichage, le réglage <codeph>cacheAsBitmap</codeph> à sa position précédente.</p>
     
     <p>Un objet d’affichage n’utilise pas d’image bitmap, même si la propriété <codeph>cacheAsBitmap</codeph> est définie sur <codeph>true</codeph> et procède au rendu à partir de données vectorielles dans les cas suivants :</p>
     
     <ul>
     
       <li>L’image bitmap est trop grande : Dans AIR 1.5 et Flash Player 10, la taille maximale d’une image bitmap est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image bitmap est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large.</li>
     
       <li>L’image bitmap ne peut être allouée en mémoire (erreur liée à une saturation de la mémoire). </li>
     
     </ul>
     
     <p>La propriété <codeph>cacheAsBitmap</codeph> est utilisée de préférence avec les clips dont le contenu est principalement statique et qui n’est ni redimensionné, ni pivoté de façon fréquente. Avec ce type de clip, <codeph>cacheAsBitmap</codeph> permet d’améliorer les performances lors de la conversion (lorsque les positions <i>x</i> et <i>y</i> sont changées).</p>
     
     </apiDesc><example conref="examples\DisplayObject.cacheAsBitmap.1.as"> L’exemple suivant applique un filtre d’ombre portée à une occurrence de l’objet Shape. Il présente ensuite la valeur de la propriété <codeph>cacheAsBitmap</codeph> définie sur <codeph>true</codeph> lorsqu’un filtre est appliqué :
<codeblock>
import flash.display.Sprite;
import flash.filters.DropShadowFilter

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);

addChild(circle);

trace(circle.cacheAsBitmap); // false

var filter:DropShadowFilter = new DropShadowFilter();
circle.filters = [filter];

trace(circle.cacheAsBitmap); // true
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:filters:get"><apiName>filters</apiName><shortdesc>
     Tableau indexé contenant tous les objets filtre actuellement associés à l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Lorsque <codeph>filters</codeph> comprend un ShaderFilter et que le type de sortie du shader n’est pas compatible avec cette opération (le shader doit spécifier une sortie <codeph>pixel4</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque <codeph>filters</codeph> comprend un ShaderFilter et que le shader ne spécifie aucune entrée d’image ou que la première entrée n’est pas une entrée <codeph>image4</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque <codeph>filters</codeph> comprend un ShaderFilter et que le shader spécifie une entrée d’image n’ont fournie.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque <codeph>filters</codeph> comprend une occurrence de ShaderFilter, ByteArray ou Vector.&lt;Number> en tant qu'entrée de shader, et les propriétés <codeph>width</codeph> et <codeph>height</codeph> ne sont pas spécifiées pour l’objet ShaderInput, ou les valeurs spécifiées ne correspondent pas à la quantité de données dans les données d’entrée. Voir la propriété <codeph>ShaderInput.input</codeph> pour plus d’informations.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Tableau indexé contenant tous les objets filtre actuellement associés à l’objet d’affichage. Le package flash.filters contient plusieurs classes qui définissent des filtres spécifiques.
     
     <p>Ces filtres peuvent s’appliquer dans l’outil de programmation de Flash pendant la phase de conception ou d’exécution du code ActionScript. Pour appliquer un filtre avec ActionScript, vous devez créer une copie temporaire de l’intégralité du tableau <codeph>filters</codeph>, modifier le tableau temporaire, puis reporter les valeurs de ce tableau temporaire dans le tableau <codeph>filters</codeph>. Vous ne pouvez pas ajouter directement un nouvel objet filtre au tableau <codeph>filters</codeph>.</p>
     
     <p>Pour ajouter un filtre à l’aide du code ActionScript, exécutez les opérations suivantes (supposons que l’objet d’affichage cible est appelé <codeph>myDisplayObject</codeph>) :</p>
     
     <ol>
     
       <li>Créez un objet filtre avec la méthode constructeur de la classe de filtre choisie.</li>
     
       <li>Assignez la valeur du tableau <codeph>myDisplayObject.filters</codeph> à un tableau temporaire, tel que celui qui est nommé <codeph>myFilters</codeph>.</li>
     
       <li>Ajoutez le nouvel objet filtre au tableau temporaire, <codeph>myFilters</codeph>.</li>
     
       <li>Affectez la valeur du tableau temporaire au tableau <codeph>myDisplayObject.filters</codeph>.</li>
     
     </ol>
     
     <p>Si le tableau <codeph>filters</codeph> n’est pas défini, il n’est pas nécessaire d’utiliser un tableau temporaire. Par contre, vous pouvez affecter directement un littéral de tableau contenant un ou plusieurs des objets filtre que vous avez créés. Le premier exemple de la section Exemples ajoute un filtre d’ombre portée à l’aide du code qui traite à la fois les tableaux de <codeph>filters</codeph> définis et non définis.</p>
     
     <p>Pour modifier un objet filtre, vous devez utiliser la technique de modification d’une copie du tableau <codeph>filters</codeph> :</p>
     
     <ol>
     
       <li>Assignez la valeur du tableau <codeph>filters</codeph> à un tableau temporaire, tel que celui qui est nommé <codeph>myFilters</codeph>.</li>
     
       <li>Modifiez la propriété avec le tableau temporaire, <codeph>myFilters</codeph>. Par exemple, pour définir la propriété quality du premier filtre du tableau, utilisez le code suivant : <codeph>myFilters[0].quality = 1;</codeph></li>
     
       <li>Affectez la valeur du tableau temporaire au tableau <codeph>filters</codeph>.</li>
     
     </ol>
     
     <p>Lors du chargement, si un objet d’affichage est associé à un filtre, ce bouton se place en mémoire cache en tant qu’image bitmap transparente. A partir de ce stade, tant que le clip possède une liste de filtres valide, le lecteur place le clip en mémoire cache au format bitmap. Cette image bitmap source est ensuite reprise en tant qu’image source pour les effets de filtrage. Tout objet d’affichage comporte généralement deux bitmaps : le premier avec l’objet d’affichage source non filtré d’origine et un autre pour l’image finale après filtrage. L’image finale est utilisée pour le rendu. Tant que l’objet d’affichage ne change pas, l’image source ne nécessite aucune mise à jour.</p>
     
     <p>Le package flash.filters contient des classes de filtres. Par exemple, pour créer un filtre DropShadow, vous devez écrire le code suivant :</p>
     
     <codeblock>
     import flash.filters.DropShadowFilter
     var myFilter:DropShadowFilter = new DropShadowFilter (distance, angle, color, alpha, blurX, blurY, quality, inner, knockout)
     </codeblock>
     
     <p>Vous pouvez utiliser l’opérateur <codeph>is</codeph> pour déterminer le type de filtre affecté à chaque position d’index dans le tableau <codeph>filter</codeph>. Par exemple, le code suivant indique comment déterminer la position du premier filtre dans le tableau <codeph>filters</codeph> qui est DropShadowFilter :
     </p>
     
     <codeblock>
     import flash.text.TextField;
     import flash.filters.~~;
     var tf:TextField = new TextField();
     var filter1:DropShadowFilter = new DropShadowFilter();
     var filter2:GradientGlowFilter = new GradientGlowFilter();
     tf.filters = [filter1, filter2];
     
     tf.text = "DropShadow index: " + filterPosition(tf, DropShadowFilter).toString(); // 0
     addChild(tf)
     
     function filterPosition(displayObject:DisplayObject, filterClass:Class):int {
         for (var i:uint = 0; i &lt; displayObject.filters.length; i++) {
             if (displayObject.filters[i] is filterClass) {
                 return i;
             }
         }
         return -1;
     }
     </codeblock>
     <p><b>Remarque :</b> Comme vous ne pouvez pas appliquer directement un nouvel objet filtre au tableau <codeph>DisplayObject.filters</codeph>, le code suivant n’a pas d’effet sur l’objet d’affichage cible, appelé <codeph>myDisplayObject</codeph> :</p>
     
     <codeblock>
     myDisplayObject.filters.push(myDropShadow);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="../../flash/filters/package-detail.html"><linktext>Package flash.filters</linktext></link><link href="flash.display.xml#ShaderInput/input"><linktext>flash.display.ShaderInput.input</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:height:get"><apiName>height</apiName><shortdesc>
     Indique la hauteur de l’objet d’affichage, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la hauteur de l’objet d’affichage, en pixels. La hauteur est calculée en fonction des limites du contenu de l’objet d’affichage. Lorsque vous définissez la propriété <codeph>height</codeph>, la propriété <codeph>scaleY</codeph> est ajustée en conséquence, comme illustré dans le code suivant :
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>A l’exception des objets TextField et Video, un objet d’affichage sans contenu (comme un sprite vide) a une hauteur de 0, même si vous essayez de définir <codeph>height</codeph> sur une valeur différente.</p>
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> Le code suivant crée deux objets TextField et règle la propriété <codeph>height</codeph> de chacun en fonction de leur propriété <codeph>textHeight</codeph> ; il place également le deuxième champ de texte en définissant sa propriété <codeph>y</codeph> :
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:loaderInfo:get"><apiName>loaderInfo</apiName><shortdesc>
     Renvoie un objet LoaderInfo qui contient des informations relatives au chargement du fichier auquel appartient cet objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie un objet LoaderInfo qui contient des informations relatives au chargement du fichier auquel appartient cet objet d’affichage. La propriété <codeph>loaderInfo</codeph> est définie uniquement pour l’objet d’affichage racine d’un fichier SWF ou d’une image bitmap chargée (et non pas d’une image bitmap dessinée avec le code ActionScript). Pour trouver l’objet <codeph>loaderInfo</codeph> associé avec le fichier SWF qui contient un objet d’affichage <codeph>myDisplayObject</codeph>, utilisez <codeph>myDisplayObject.root.loaderInfo</codeph>.
     
     <p>Un grand fichier SWF peut superviser son téléchargement en appelant <codeph>this.root.loaderInfo.addEventListener(Event.COMPLETE, func)</codeph>.</p>
     
     </apiDesc><example conref="examples\DisplayObject.loaderInfo.1.as"> Le code suivant suppose que <codeph>this</codeph> se rapporte à un objet d’affichage. Le code renvoie l’URL du fichier SWF racine pour l’objet d’affichage :
<codeblock>
 trace (this.loaderInfo.url);
 
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>Classe LoaderInfo</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:mask:get"><apiName>mask</apiName><shortdesc>
     L’objet d’affichage appelant est masqué par l’objet mask spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Définit un masque pour l’objet d’affichage.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     L’objet d’affichage appelant est masqué par l’objet <codeph>mask</codeph> spécifié. Afin de vous assurer que le masquage fonctionne lorsque la scène est redimensionnée, l’objet d’affichage <codeph>mask</codeph> doit figurer dans la section active de la liste d’affichage. L’objet <codeph>mask</codeph> en tant que tel n’est pas dessiné. Réglez <codeph>mask</codeph> sur <codeph>null</codeph> pour supprimer le masque.
     
     <p>Pour pouvoir redimensionner un objet masque, il doit figurer dans la liste d’affichage. Pour faire glisser un objet Sprite de masque (à l’aide de sa méthode <codeph>startDrag()</codeph>), vous devez placer ce dernier dans la liste d’affichage. Pour appeler la méthode <codeph>startDrag()</codeph> d’un sprite de masque en fonction d’un événement <codeph>mouseDown</codeph> en cours de distribution par le sprite, définissez la propriété <codeph>buttonMode</codeph> du sprite sur <codeph>true</codeph>.</p>
     
     <p><b>Remarque :</b> un seul objet <codeph>mask</codeph> ne peut être utilisé pour masquer plusieurs objets d’affichage appelants. Lorsque <codeph>mask</codeph> est affecté à un deuxième objet d’affichage, il est supprimé du masque du premier objet et la propriété <codeph>mask</codeph> de cet objet devient <codeph>null</codeph>.</p>  
     
     </apiDesc><example conref="examples\DisplayObject.mask.1.as"> Le code suivant crée un objet TextField, ainsi qu’un objet Sprite qui est défini en tant que masque pour l’objet TextField. Lorsque l’utilisateur clique sur le champ de texte, la fonction écouteur d’événement <codeph>drag()</codeph> appelle la méthode <codeph>startDrag()</codeph> de l’objet Sprite de masque :
<codeblock>
import flash.text.TextField;
import flash.display.Sprite;
import flash.events.MouseEvent;

var tf:TextField = new TextField();
tf.text = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " 
            + "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
tf.selectable = false;
tf.wordWrap = true;
tf.width = 150;
addChild(tf);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 40, 40);
addChild(square);

tf.mask = square;

tf.addEventListener(MouseEvent.MOUSE_DOWN, drag);
tf.addEventListener(MouseEvent.MOUSE_UP, noDrag);

function drag(event:MouseEvent):void {
    square.startDrag();
}
function noDrag(event:MouseEvent):void {
    square.stopDrag();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseX:get"><apiName>mouseX</apiName><shortdesc>
     Indique la coordonnée x de la position de la souris, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la coordonnée x de la position de la souris, en pixels.
     
     <p><b>Remarque</b> : si vous avez fait pivoter un objet DisplayObject, la coordonnée x renvoyée reflète l’objet non pivoté.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> Le code suivant crée un objet Sprite et suit les positions <codeph>mouseX</codeph> et <codeph>mouseY</codeph> lorsque l’utilisateur clique sur le sprite :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseY:get"><apiName>mouseY</apiName><shortdesc>
     Indique la coordonnée y de la position de la souris, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la coordonnée y de la position de la souris, en pixels.
     
     <p><b>Remarque</b> : si vous avez fait pivoter un objet DisplayObject, la coordonnée y renvoyée reflète l’objet non pivoté.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> Le code suivant crée un objet Sprite et suit les positions <codeph>mouseX</codeph> et <codeph>mouseY</codeph> lorsque l’utilisateur clique sur le sprite :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:name:get"><apiName>name</apiName><shortdesc>
     Indique le nom d’occurrence de DisplayObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Si vous tentez de définir cette propriété sur un objet qui a été placé dans le scénario de l’outil de programmation Flash.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Nom de cette occurrence de DisplayObject.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Indique le nom d’occurrence de DisplayObject. L’objet peut être identifié dans la liste d’enfants de son conteneur d’objet d’affichage parent en appelant la méthode <codeph>getChildByName()</codeph> du conteneur de l’objet d’affichage.
     
     </apiDesc><example conref="examples\DisplayObject.name.1.as"> Le code suivant crée deux objets Sprite et suit la propriété <codeph>name</codeph> associée lorsque l’utilisateur clique sur l’un des objets :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.name = "circle1";
addChild(circle1);
circle1.addEventListener(MouseEvent.CLICK, traceName);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x0000FF);
circle2.graphics.drawCircle(140, 40, 40);
circle2.name = "circle2";
addChild(circle2);
circle2.addEventListener(MouseEvent.CLICK, traceName);

function traceName(event:MouseEvent):void {
    trace(event.target.name);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:opaqueBackground:get"><apiName>opaqueBackground</apiName><shortdesc>
     Indique si l’objet d’affichage est opaque avec une couleur d’arrière-plan spécifique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’objet d’affichage est opaque avec une couleur d’arrière-plan spécifique. Une image bitmap transparente contient des données de canal alpha et est dessinée de façon transparente. Une image bitmap opaque ne comporte pas de canal alpha (et procède au rendu plus rapidement qu’avec une image bitmap transparente). Si l’image bitmap est opaque, vous spécifiez la couleur d’arrière-plan à utiliser.
     
     <p>Si elle est réglée sur une valeur numérique, la surface est opaque (et non transparente) et la couleur d’arrière-plan RVB correspond au nombre spécifié. Si défini sur <codeph>null</codeph> (la valeur par défaut), l’objet d’affichage a un arrière-plan transparent.</p>
     
     <p>La propriété <codeph>opaqueBackground</codeph> est conçue principalement pour l’utilisation avec la propriété <codeph>cacheAsBitmap</codeph>, pour l’optimisation du rendu. Pour les objets d’affichage dont la propriété <codeph>cacheAsBitmap</codeph> est définie sur true, le paramètre <codeph>opaqueBackground</codeph> peut améliorer les performances de rendu.</p>
     
     <p>La zone opaque d’arrière-plan n’est <i>pas</i> prise comme référence lors de l’appel de la méthode <codeph>hitTestPoint()</codeph> avec le paramètre <codeph>shapeFlag</codeph> défini sur <codeph>true</codeph>.</p>
     
     <p>La zone d’arrière-plan opaque ne réagit pas aux événements de souris.</p>
     
     </apiDesc><example conref="examples\DisplayObject.opaqueBackground.1.as"> Le code suivant crée un objet Shape avec un cercle bleu et définit sa propriété <codeph>opaqueBackground</codeph> sur rouge (0xFF0000) :
<codeblock>
import flash.display.Shape;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.opaqueBackground = 0xFF0000;
addChild(circle);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/hitTestPoint()"><linktext>hitTestPoint()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:parent:get"><apiName>parent</apiName><shortdesc>
     Indique l’objet DisplayObjectContainer qui contient l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObjectContainer</apiValueClassifier><apiException><apiDesc>L’objet d’affichage parent appartient à un sandbox de sécurité auquel vous n’avez pas accès. Pour éviter ce cas de figure, faites en sorte que l’animation parent appelle la méthode <codeph>Security.allowDomain()</codeph>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Indique l’objet DisplayObjectContainer qui contient l’objet d’affichage. Appliquez la propriété <codeph>parent</codeph> pour spécifier un chemin relatif vers les objets d’affichage qui figurent au-dessus de l’objet d’affichage actuel dans la hiérarchie de liste d’affichage.
     
     <p>Vous pouvez utiliser <codeph>parent</codeph> pour remonter de plusieurs niveaux dans l’arborescence de la liste d’affichage, comme dans l’exemple suivant :</p>
     
     <codeblock>
     this.parent.parent.alpha = 20;
     </codeblock>
     
     </apiDesc><example conref="examples\DisplayObject.parent.1.as"> Le code suivant crée trois objets Sprite et indique comment la propriété <codeph>parent</codeph> doit refléter la hiérarchie de la liste d’affichage :
<codeblock>

import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite2.parent.name); // sprite1
trace(sprite3.parent.name); // sprite2
trace(sprite3.parent.parent.name); // sprite1
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:root:get"><apiName>root</apiName><shortdesc>
     Pour un objet d’affichage résidant dans un fichier SWF chargé, la propriété root correspond à l’objet d’affichage de premier niveau dans la partie de la structure arborescente de la liste d’affichage représentée par ce fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Renvoie l’objet d’affichage racine associé à l’objet.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Pour un objet d’affichage résidant dans un fichier SWF chargé, la propriété <codeph>root</codeph> correspond à l’objet d’affichage de premier niveau dans la partie de la structure arborescente de la liste d’affichage représentée par ce fichier. Pour un objet Bitmap représentant un fichier d’image chargé, la propriété <codeph>root</codeph> correspond à l’objet Bitmap lui-même. Pour l’occurrence de la classe principale du premier fichier SWF chargé, la propriété <codeph>root</codeph> correspond à l’objet d’affichage lui-même. La propriété <codeph>root</codeph> de l’objet Stage correspond à l’objet Stage en tant que tel. La propriété <codeph>root</codeph> est définie sur <codeph>null</codeph> pour tout objet d’affichage qui n’a pas été ajouté à la liste d’affichage, sauf s’il a été ajouté à un conteneur d’objet d’affichage qui ne rentre pas dans le cadre de la liste d’affichage, mais qui est un enfant de l’objet d’affichage de plus haut niveau dans un fichier SWF chargé.
     
     <p>Par exemple, si vous créez un nouvel objet Sprite en appelant la méthode de constructeur <codeph>Sprite()</codeph>, sa propriété <codeph>root</codeph> reste <codeph>null</codeph> jusqu’à ce qu’elle soit ajoutée à la liste d’affichage (ou pour un conteneur d’objet d’affichage qui ne rentre pas dans le cadre de la liste d’affichage, mais qui est un enfant de l’objet d’affichage de plus haut niveau dans un fichier SWF chargé).</p>
     
     <p>Pour un fichier SWF chargé, même si l’objet Loader utilisé pour charger le fichier ne figure pas dans la liste d’affichage, l’objet d’affichage de plus haut niveau du fichier SWF voit sa propriété <codeph>root</codeph> définie sur lui-même. La propriété <codeph>root</codeph> de l’objet Loader n’est pas définie tant qu’elle n’est pas ajoutée en tant qu’enfant de l’objet d’affichage pour lequel la propriété <codeph>root</codeph> est définie.</p>
     
     </apiDesc><example conref="examples\DisplayObject.root.1.as"> Le code suivant indique la différence entre la propriété <codeph>root</codeph> de l’objet Stage, pour un objet d’affichage (un objet Loader) qui n’est pas chargé (avant et après avoir été ajouté à la liste d’affichage) et pour un objet chargé (un objet Bitmap chargé) :
<codeblock>
import flash.display.Loader;
import flash.net.URLRequest;
import flash.events.Event;

trace(stage.root); // [object Stage]

var ldr:Loader = new Loader();
trace (ldr.root); // null

addChild(ldr); 
trace (ldr.root); // [object ...]

var urlReq:URLRequest = new URLRequest("example.jpg");
ldr.load(urlReq);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void {
    trace(ldr.content.root); // [object Bitmap]
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotation:get"><apiName>rotation</apiName><shortdesc>
     Indique la rotation de l’occurrence de DisplayObject, en degrés, à partir de son orientation d’origine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la rotation de l’occurrence de DisplayObject, en degrés, à partir de son orientation d’origine. Les valeurs comprises entre 0 et 180 représentent la rotation en sens horaire ; les valeurs comprises entre 0 et -180 représentent la rotation en sens anti-horaire. Les valeurs hors de cette plage sont ajoutées ou soustraites de 360 pour obtenir une valeur comprise dans la plage. Par exemple, l’instruction <codeph>my_video.rotation = 450</codeph> correspond à <codeph> my_video.rotation = 90</codeph>.
     
     </apiDesc><example conref="examples\DisplayObject.rotation.1.as"> Le code suivant crée un objet Sprite et le fait pivoter lorsque l’utilisateur clique dessus :
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(-50, -50, 100, 100);
square.x = 150;
square.y = 150;
addChild(square);

square.addEventListener(MouseEvent.CLICK, rotate);

function rotate(event:MouseEvent):void {
        square.rotation += 15;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationX:get"><apiName>rotationX</apiName><shortdesc>
     Indique la rotation de l’axe des x de l’occurrence DisplayObject, en degrés, à partir de son orientation d’origine par rapport au conteneur 3D parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la rotation de l’axe des x de l’occurrence DisplayObject, en degrés, à partir de son orientation d’origine par rapport au conteneur 3D parent. Les valeurs comprises entre 0 et 180 représentent la rotation en sens horaire ; les valeurs comprises entre 0 et -180 représentent la rotation en sens anti-horaire. Les valeurs hors de cette plage sont ajoutées ou soustraites de 360 pour obtenir une valeur comprise dans la plage.
     
     </apiDesc><example conref="examples\RotationExample1.as"> Dans cet exemple, deux ellipses pivotent grâce à leurs propriétés <codeph>rotationX</codeph> et <codeph>rotationY</codeph>. Le point d’alignement de la première ellipse est défini en son centre. Elle pivote sur elle-même. La deuxième ellipse pivote autour d’un point externe. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationY:get"><apiName>rotationY</apiName><shortdesc>
     Indique la rotation de l’axe des y de l’occurrence DisplayObject, en degrés, à partir de son orientation d’origine par rapport au conteneur 3D parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la rotation de l’axe des y de l’occurrence DisplayObject, en degrés, à partir de son orientation d’origine par rapport au conteneur 3D parent. Les valeurs comprises entre 0 et 180 représentent la rotation en sens horaire ; les valeurs comprises entre 0 et -180 représentent la rotation en sens anti-horaire. Les valeurs hors de cette plage sont ajoutées ou soustraites de 360 pour obtenir une valeur comprise dans la plage.
     
     
     </apiDesc><example conref="examples\RotationExample1.as"> Dans cet exemple, deux ellipses pivotent grâce à leurs propriétés <codeph>rotationX</codeph> et <codeph>rotationY</codeph>. Le point d’alignement de la première ellipse est défini en son centre. Elle pivote sur elle-même. La deuxième ellipse pivote autour d’un point externe. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationZ:get"><apiName>rotationZ</apiName><shortdesc>
     Indique la rotation de l’axe des z de l’occurrence DisplayObject, en degrés, à partir de son orientation d’origine par rapport au conteneur 3D parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la rotation de l’axe des z de l’occurrence DisplayObject, en degrés, à partir de son orientation d’origine par rapport au conteneur 3D parent. Les valeurs comprises entre 0 et 180 représentent la rotation en sens horaire ; les valeurs comprises entre 0 et -180 représentent la rotation en sens anti-horaire. Les valeurs hors de cette plage sont ajoutées ou soustraites de 360 pour obtenir une valeur comprise dans la plage.
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scale9Grid:get"><apiName>scale9Grid</apiName><shortdesc>
     Grille de mise à l’échelle en vigueur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following creates a movie clip that contains a 20-pixel line (which forms a border)
     and a gradient fill. The movie clip scales based on the mouse position, and because of the
     <code>scale9Grid</code> set for the movie clip, the thickness of the 20-pixel line does not
     vary when the clip scales (although the gradient in the movie clip <em>does</em> scale):
     
     <listing version="2.0">
     import flash.geom.Rectangle;
     import flash.geom.Matrix;
     
     this.createEmptyMovieClip("my_mc", this.getNextHighestDepth());
     
     var grid:Rectangle = new Rectangle(20, 20, 260, 260);
     my_mc.scale9Grid = grid ;
     
     my_mc._x = 50;
     my_mc._y = 50;
     
     function onMouseMove()
     {
      my_mc._width  = _xmouse;
      my_mc._height = _ymouse;
     }
     
     my_mc.lineStyle(20, 0xff3333, 100);
     var gradient_matrix:Matrix = new Matrix();
     gradient_matrix.createGradientBox(15, 15, Math.PI, 10, 10);
     my_mc.beginGradientFill("radial", [0xffff00, 0x0000ff],
              [100, 100], [0, 0xFF], gradient_matrix,
              "reflect", "RGB", 0.9);
     my_mc.moveTo(0, 0);
     my_mc.lineTo(0, 300);
     my_mc.lineTo(300, 300);
     my_mc.lineTo(300, 0);
     my_mc.lineTo(0, 0);
     my_mc.endFill();
     </listing>
     
     </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>Si vous transmettez un argument non valide à la méthode.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Grille de mise à l’échelle en vigueur. Si la valeur est définie sur <codeph>null</codeph>, tout l’objet d’affichage est alors dimensionné normalement lorsqu’une transformation par redimensionnement est appliquée.
     
     <p>Lorsque vous définissez une propriété <codeph>scale9Grid</codeph>, l’objet d’affichage est divisé dans une grille comportant neuf zones, en fonction du rectangle <codeph>scale9Grid</codeph>, qui définit le centre de la grille. La grille est constituée des huit autres zones suivantes : </p>
     
     <ul>
       <li>le coin supérieur gauche, en dehors du rectangle,</li>
       <li>la zone située au-dessus du rectangle, </li>
       <li>le coin supérieur droit, en dehors du rectangle,</li>
       <li>la zone située à gauche du rectangle,</li>
       <li>la zone située à droite du rectangle,</li>
       <li>le coin inférieur gauche, en dehors du rectangle,</li>
       <li>la zone située au-dessous du rectangle,</li>
       <li>le coin inférieur droit, en dehors du rectangle.</li>
     </ul>
     
     <p>Les huit zones entourant la partie centrale (définie par le rectangle) peuvent être conçues comme un cadre qui bénéficie de règles spécifiques de redimensionnement.</p>
     
     <p>Lorsque la propriété <codeph>scale9Grid</codeph> est définie et qu’un objet d’affichage est redimensionné, la totalité du texte et les dégradés sont dimensionnés normalement ; toutefois, les règles suivantes s’appliquent pour les autres types d’objets :</p>
     
     <ul>
       <li>Le contenu de la zone centrale est redimensionné normalement. </li>
       <li>Le contenu apparaissant dans les coins n’est pas redimensionné. </li>
       <li>Le contenu des zones supérieures et inférieures est redimensionné horizontalement uniquement. Le contenu apparaissant dans les zones de gauche et de droite est redimensionné verticalement uniquement.</li>
      <li>Tous les remplissages (ce qui inclut les bitmaps, les vidéos et les dégradés) sont étirés pour remplir leur forme.</li>
     </ul>
     
     <p>Si vous faites pivoter un objet d’affichage, tout redimensionnement effectué ultérieurement est normal et la propriété <codeph>scale9Grid</codeph> est ignorée.</p>
     
     <p>Par exemple, considérez l’objet d’affichage suivant et un rectangle qui lui est appliqué en tant que propriété <codeph>scale9Grid</codeph> :</p>
     
     <adobetable>
     
       
     
     <tgroup cols="2"><tbody><row>
      <entry align="center"><adobeimage alt="image d’objet d’affichage" href="../../images/scale9Grid-a.jpg"/>
     <p>Objet d’affichage.</p></entry>
     
      <entry align="center"><adobeimage alt="zone échelle-9 d’objet d’affichage" href="../../images/scale9Grid-b.jpg"/>
      <p>Le rectangle rouge représente la zone couverte par <codeph>scale9Grid</codeph>.</p></entry>
       </row></tbody></tgroup></adobetable>
     
     <p>Lorsque l’objet d’affichage est redimensionné ou étiré, les objets placés dans le rectangle se redimensionnent normalement. Par contre, les objets situés en dehors du rectangle sont redimensionnés selon les règles de <codeph>scale9Grid</codeph> :</p>
     
     <adobetable>
      
     
      
     
      
     
      
     
     <tgroup cols="2"><tbody><row>
      <entry>Redimensionné à 75 % :</entry>
      <entry><adobeimage alt="objet d’affichage à 75 %" href="../../images/scale9Grid-c.jpg"/></entry>
      </row><row>
      <entry>Redimensionné à 50 % :</entry>
      <entry><adobeimage alt="objet d’affichage à 50 %" href="../../images/scale9Grid-d.jpg"/></entry>
      </row><row>
      <entry>Redimensionné à 25 % :</entry>
      <entry><adobeimage alt="objet d’affichage à 25 %" href="../../images/scale9Grid-e.jpg"/></entry>
      </row><row>
      <entry>Etiré à l’horizontal à 150 % : </entry>
      <entry><adobeimage alt="affichage étiré à 150 %" href="../../images/scale9Grid-f.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     
     <p>L’une des principales utilisations de <codeph>scale9Grid</codeph> consiste à définir un objet d’affichage en tant que composant où les zones de bordure conservent la même largeur lorsque le composant est redimensionné.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scale9Grid.1.as"> Le code suivant crée un objet Shape avec un rectangle dessiné dans sa propriété <codeph>graphics</codeph>. La ligne de bordure du rectangle fait 20 pixels de large et est remplie par un dégradé. Cet événement d’horloge appelle la fonction <codeph>scale()</codeph>, qui redimensionne l’objet Shape en réglant les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph>. La propriété <codeph>scale9Grid</codeph> appliquée à l’objet Shape empêche le redimensionnement de la ligne de bordure de l’écran, seul le remplissage en dégradé est redimensionné :
<codeblock>

import flash.display.Shape;
import flash.display.GradientType;
import flash.display.SpreadMethod;
import flash.display.InterpolationMethod;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var square:Shape = new Shape();
square.graphics.lineStyle(20, 0xFFCC00);
var gradientMatrix:Matrix = new Matrix();
gradientMatrix.createGradientBox(15, 15, Math.PI, 10, 10);
square.graphics.beginGradientFill(GradientType.RADIAL, 
            [0xffff00, 0x0000ff], 
            [100, 100], 
            [0, 0xFF], 
            gradientMatrix, 
            SpreadMethod.REFLECT, 
            InterpolationMethod.RGB, 
            0.9);
square.graphics.drawRect(0, 0, 100, 100);

var grid:Rectangle = new Rectangle(20, 20, 60, 60);
square.scale9Grid = grid ;

addChild(square);

var tim:Timer = new Timer(100);
tim.start();
tim.addEventListener(TimerEvent.TIMER, scale);

var scaleFactor:Number = 1.01;

function scale(event:TimerEvent):void {
    square.scaleX *= scaleFactor;
    square.scaleY *= scaleFactor;
    
    if (square.scaleX > 2.0) {
        scaleFactor = 0.99;
    }
    if (square.scaleX &lt; 1.0) {
        scaleFactor = 1.01;
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scaleX:get"><apiName>scaleX</apiName><shortdesc>
     Indique l’échelle horizontale (pourcentage) de l’objet telle qu’elle est appliquée à partir du point d’alignement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique l’échelle horizontale (pourcentage) de l’objet telle qu’elle est appliquée à partir du point d’alignement. Le point d’alignement par défaut est (0,0). 1.0 correspond à une échelle 100 %.
     
     <p>La mise à l’échelle du système de coordonnées local modifie les valeurs des propriétés <codeph>x</codeph> et <codeph>y</codeph> définies en pixels. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> Le code suivant crée un objet Sprite avec un rectangle dessiné dans sa propriété <codeph>graphics</codeph>. Le fait de cliquer sur le sprite, entraîne son redimensionnement par un facteur de 10 % :
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleY:get"><apiName>scaleY</apiName><shortdesc>
     Indique le redimensionnement vertical (pourcentage) de l’objet tel qu’il est appliqué à partir du point d’alignement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique l’échelle verticale (pourcentage) de l’objet telle qu’elle est appliquée à partir du point d’alignement. Le point d’alignement par défaut est (0,0). 1.0 correspond à une échelle 100 %.
     
     <p>La mise à l’échelle du système de coordonnées local modifie les valeurs des propriétés <codeph>x</codeph> et <codeph>y</codeph> définies en pixels. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> Le code suivant crée un objet Sprite avec un rectangle dessiné dans sa propriété <codeph>graphics</codeph>. Le fait de cliquer sur le sprite, entraîne son redimensionnement par un facteur de 10 % :
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleZ:get"><apiName>scaleZ</apiName><shortdesc>
     Indique l’échelle de profondeur (pourcentage) de l’objet tel qu’elle est appliquée à partir du point d’alignement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique l’échelle de profondeur (pourcentage) de l’objet tel qu’elle est appliquée à partir du point d’alignement. Le point d’alignement par défaut est (0,0). 1.0 correspond à une échelle 100 %.
     
     <p>La mise à l’échelle du système de coordonnées local modifie les valeurs des propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph> définies en pixels. </p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/z"><linktext>z</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scrollRect:get"><apiName>scrollRect</apiName><shortdesc>
     Cadre de sélection du défilement de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     Cadre de sélection du défilement de l’objet d’affichage. L’objet d’affichage est recadré en fonction de la taille définie par le rectangle et il défile au sein de ce dernier lorsque vous modifiez les propriétés <codeph>x</codeph> et <codeph>y</codeph> de l’objet <codeph>scrollRect</codeph>.
     
     <p>Les propriétés de l’objet rectangle <codeph>scrollRect</codeph> reprennent l’espace de coordonnées de l’objet d’affichage et sont redimensionnées tout comme l’objet d’affichage global. Les angles de la fenêtre recadrée de l’objet d’affichage avec défilement correspondent à l’origine de l’objet d’affichage (0,0) et le point défini par la largeur et la hauteur du rectangle. Ils ne sont pas centrés autour de l’origine, mais utilisent cette dernière pour définir le coin supérieur gauche de la zone. L’objet d’affichage avec défilement se fait toujours par pixels entiers. </p>
     
     <p>Vous pouvez faire défiler un objet vers la gauche ou la droite en définissant la propriété <codeph>x</codeph> de l’objet rectangle <codeph>scrollRect</codeph>. Vous pouvez faire défiler un objet vers le haut ou le bas en définissant la propriété <codeph>y</codeph> de l’objet rectangle <codeph>scrollRect</codeph>. Si l’objet d’affichage subit une rotation de 90° et que vous le faites défiler vers la gauche ou vers la droite, il défile en fait vers le haut ou vers le bas.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scrollRect.1.as"> L’exemple suivant indique comment la propriété <codeph>scrollRect</codeph> définit la zone de défilement d’un objet d’affichage, <codeph>circle</codeph> . Lorsque vous cliquez sur l’objet <codeph>circle</codeph>, la méthode de gestionnaire d’événements <codeph>clicked()</codeph> ajuste la coordonnée <codeph>y</codeph> de la propriété <codeph>scrollRect</codeph> de l’objet <codeph>circle</codeph>, ce qui entraîne le défilement de l’objet vers le bas :
<codeblock>

import flash.display.Sprite;
import flash.geom.Rectangle;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(200, 200, 200);
circle.scrollRect = new Rectangle(0, 0, 200, 200);
addChild(circle);

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    var rect:Rectangle = event.target.scrollRect;
    rect.y -= 5;
    event.target.scrollRect = rect;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:stage:get"><apiName>stage</apiName><shortdesc>
     Scène de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
     Scène de l’objet d’affichage. Une application Flash ne possède qu’un seul objet Stage. Par exemple, vous pouvez créer et charger plusieurs objets d’affichage dans la liste d’affichage. La propriété <codeph>stage</codeph> de chaque objet d’affichage se rapporte au même objet Stage (même si l’objet d’affichage appartient à un fichier SWF chargé).
     
     <p>Si un objet d’affichage n’est pas ajouté à la liste d’affichage, sa propriété <codeph>stage</codeph> est définie sur <codeph>null</codeph>.</p>
     
     </apiDesc><example conref="examples\DisplayObject.stage.1.as"> Le code suivant crée deux objets TextField et exploite la propriété <codeph>width</codeph> de l’objet Stage pour placer les champs texte :
<codeblock>

import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.x = 10;
addChild(tf1);
tf1.width = tf1.stage.stageWidth / 2 - 10;

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.x = tf1.x + tf1.width + 5;
addChild(tf2);
tf2.width = tf2.stage.stageWidth / 2 - 10;

trace(stage.stageWidth);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:transform:get"><apiName>transform</apiName><shortdesc>
    Objet dont les propriétés se rapportent à la matrice, à la transformation des couleurs et aux limites des pixels d’un objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Transform</apiValueClassifier></apiValueDef><apiDesc>
    Objet dont les propriétés se rapportent à la matrice, à la transformation des couleurs et aux limites des pixels d’un objet d’affichage. Les propriétés spécifiques, telles que matrix, colorTransform et trois propriétés en lecture seule (<codeph>concatenatedMatrix</codeph>, <codeph>concatenatedColorTransform</codeph> et <codeph>pixelBounds</codeph>) sont décrites dans la section relative à la classe Transform.
    
    <p>Chacune des propriétés de l’objet transform constitue un objet. Ce concept est important dans la mesure où la seule façon de définir de nouvelles valeurs pour les objets matrix ou colorTransform consiste à créer un objet et à le copier dans la propriété transform.matrix ou transform.colorTransform.</p>
    
    <p>Par exemple, pour augmenter la valeur <codeph>tx</codeph> d’une matrice d’objet d’affichage, vous devez copier l’ensemble de l’objet de la matrice, puis copier le nouvel objet dans la propriété matrix de l’objet transform :</p>
    
    <pre><codeph>
    var myMatrix:Matrix = myDisplayObject.transform.matrix;  
    myMatrix.tx += 10; 
    myDisplayObject.transform.matrix = myMatrix;  
    </codeph></pre>
    
    <p>Vous ne pouvez pas définir directement la propriété <codeph>tx</codeph>. Le code suivant n’a pas d’effet sur <codeph>myDisplayObject</codeph> : </p>
    
    <pre><codeph>
    myDisplayObject.transform.matrix.tx += 10;
    </codeph></pre>
    
    <p>Vous pouvez copier un objet transform et l’associer à la propriété transform d’un autre objet d’affichage. Par exemple, le code suivant copie l’objet transform dans son intégralité, de <codeph>myOldDisplayObj</codeph> à <codeph>myNewDisplayObj</codeph> :</p>
    <codeph>myNewDisplayObj.transform = myOldDisplayObj.transform;</codeph>
    <p>Le nouvel objet d’affichage qui en résulte, <codeph>myNewDisplayObj</codeph>, dispose désormais des mêmes valeurs pour ses paramètres de matrice, transformation de couleurs et limites de pixels que l’ancien objet d’affichage, <codeph>myOldDisplayObj</codeph>.</p>
     
    </apiDesc><example conref="examples\DisplayObject.transform.1.as"> Le code suivant définit un objet Sprite <codeph>square</codeph>. Lorsque l’utilisateur clique sur le sprite, la méthode <codeph>transformer()</codeph> ajuste les propriétés <codeph>colorTransform</codeph> et <codeph>matrix</codeph> de la propriété <codeph>transform</codeph> du sprite :
<codeblock>

import flash.display.Sprite;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Transform;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.lineStyle(20, 0xFF2200);
square.graphics.beginFill(0x0000DD);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

var resultColorTransform:ColorTransform = new ColorTransform();
resultColorTransform.alphaMultiplier = 0.5;
resultColorTransform.redOffset = 155;
resultColorTransform.greenMultiplier = 0.5;

var skewMatrix:Matrix = new Matrix(1, 1, 0, 1);

square.addEventListener(MouseEvent.CLICK, transformer);

function transformer(event:MouseEvent):void {
    var transformation:Transform = square.transform;
    var tempMatrix:Matrix = square.transform.matrix;
    tempMatrix.concat(skewMatrix);
    square.transform.colorTransform = resultColorTransform;
    
    square.transform.matrix = tempMatrix;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Transform"><linktext>Transform, classe</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:visible:get"><apiName>visible</apiName><shortdesc>
     Indique si l’objet d’affichage est visible ou non.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’objet d’affichage est visible ou non. Les objets d’affichage qui ne sont pas visibles sont désactivés. Par exemple, si <codeph>visible=false</codeph> pour une occurrence InteractiveObject, il est impossible de cliquer sur cette dernière.
     
     </apiDesc><example conref="examples\DisplayObject.visible.1.as"> Le code suivant utilise un objet Timer pour appeler une fonction qui modifie de façon périodique la propriété <codeph>visible</codeph> d’un objet d’affichage, ce qui produit un effet de clignotement :
<codeblock>

import flash.text.TextField;
import flash.utils.Timer;
import flash.events.TimerEvent;

var tf:TextField = new TextField();
tf.text = "Hello.";
addChild(tf);

var tim:Timer = new Timer(250);
tim.start();
tim.addEventListener(TimerEvent.TIMER, blinker);

function blinker(event:TimerEvent):void {
    tf.visible = !tf.visible;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:width:get"><apiName>width</apiName><shortdesc>
     Indique la largeur de l’objet d’affichage, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la largeur de l’objet d’affichage, en pixels. La largeur est calculée en fonction des limites du contenu de l’objet d’affichage. Lorsque vous définissez la propriété <codeph>width</codeph>, la propriété <codeph>scaleX</codeph> est ajustée en conséquence, comme illustré dans le code suivant :
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>A l’exception des objets TextField et Video, un objet d’affichage sans contenu (comme un sprite vide) a une largeur de 0, même si vous essayez de définir <codeph>width</codeph> sur une valeur différente.</p>
     
     </apiDesc><example conref="examples\DisplayObject.width.1.as"> Le code suivant définit un objet Sprite <codeph>square</codeph>. Lorsque l’utilisateur clique sur le sprite, la méthode <codeph>widen()</codeph> augmente la propriété <codeph>width</codeph> du sprite :
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, widen);

function widen(event:MouseEvent):void {
    square.width += 10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:x:get"><apiName>x</apiName><shortdesc>
     Indique la coordonnée x de l’occurrence de DisplayObject par rapport aux coordonnées locales de l’objet DisplayObjectContainer parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la coordonnée <i>x</i> de l’occurrence de DisplayObject par rapport aux coordonnées locales de l’objet DisplayObjectContainer parent. Si l’objet figure dans un objet DisplayObjectContainer qui dispose de transformations, ce dernier figure dans le système de coordonnées locales de l’objet DisplayObjectContainer qui l’englobe. Ainsi, dans le cas d’un objet DisplayObjectContainer qui a subi une rotation de 90 ° en sens anti-horaire, les enfants de DisplayObjectContainer héritent d’un système de coordonnées ayant effectué une rotation à 90 ° en sens anti-horaire. Les coordonnées de l’objet renvoient à la position du point d’alignement.
     
     </apiDesc><example conref="examples\DisplayObject.x.1.as"> Le code suivant définit un objet Sprite <codeph>circle</codeph>. Un objet Timer permet de modifier la propriété <codeph>x</codeph> du sprite toutes les 50 millisecondes :
<codeblock>

import flash.display.Sprite;
import flash.utils.Timer;
import flash.events.TimerEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(100, 100, 100);
addChild(circle);

var tim:Timer = new Timer(50);
tim.start();
tim.addEventListener(TimerEvent.TIMER, bounce);

var xInc:Number = 2;

function bounce(event:TimerEvent):void {
    circle.x += xInc;
    if (circle.x > circle.width) {
        xInc = -2;
    }
    if (circle.x &lt; 0) {
        xInc = 2;
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:y:get"><apiName>y</apiName><shortdesc>
     Indique la coordonnée y de l’occurrence de DisplayObject par rapport aux coordonnées locales de l’objet DisplayObjectContainer parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la coordonnée <i>y</i> de l’occurrence de DisplayObject par rapport aux coordonnées locales de l’objet DisplayObjectContainer parent. Si l’objet figure dans un objet DisplayObjectContainer qui dispose de transformations, ce dernier figure dans le système de coordonnées locales de l’objet DisplayObjectContainer qui l’englobe. Ainsi, dans le cas d’un objet DisplayObjectContainer qui a subi une rotation de 90 ° en sens anti-horaire, les enfants de DisplayObjectContainer héritent d’un système de coordonnées ayant effectué une rotation à 90 ° en sens anti-horaire. Les coordonnées de l’objet renvoient à la position du point d’alignement.
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> Le code suivant crée deux objets TextField et règle la propriété <codeph>height</codeph> de chacun en fonction de leur propriété <codeph>textHeight</codeph> ; il place également le deuxième champ de texte en définissant sa propriété <codeph>y</codeph> :
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:z:get"><apiName>z</apiName><shortdesc>
     Indique la position de coordonnée z le long de l’axe des z de l’occurrence DisplayObject par rapport au conteneur 3D parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la position de coordonnée z le long de l’axe z de l’occurrence de DisplayObject par rapport au conteneur 3D parent. La propriété z est utilisée avec des coordonnées 3D et non avec des coordonnées d’écran ou de pixel. 
     <p>Lorsque vous réglez la propriété <codeph>z</codeph> d’un objet d’affichage sur une valeur autre que la valeur par défaut, à savoir <codeph>0</codeph>, l’objet Matrix3D correspondant est automatiquement créé pour régler la position et l’orientation 3D d’un objet d’affichage. Lorsque l’on utilise l’axe des z, le comportement existant des propriétés x et y passe des coordonnées d’écran ou pixel aux positions par rapport au conteneur 3D parent.</p>
     <p>Par exemple, un enfant de <codeph>_root</codeph> dont la position est x = 100, y = 100, z = 200 n’est pas dessiné à l’emplacement du pixel (100,100). L’enfant est dessiné à l’endroit où les calculs de projection 3D le placent. Ce calcul est :</p>
     <p><codeph> (x~~cameraFocalLength/cameraRelativeZPosition, y~~cameraFocalLength/cameraRelativeZPosition)</codeph></p>
     
     
     </apiDesc><example conref="examples\ZAxisExample1.as"> Cet exemple dessine deux ellipses et les fait se déplacer vers l’avant et vers l’arrière (de bas en haut sur l’axe <codeph>z</codeph>) du point de fuite. L’une des ellipses est définie de sorte à se déplacer plus vite que l’autre. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.geom.*;

    public class ZAxisExample1 extends MovieClip {
        private var ellipse1Back:int = 1;
        private var ellipse2Back:int = 1;
        private var depth:int = 1000;
        
        public function ZAxisExample1():void {
            
            var ellipse1 = drawEllipse((this.stage.stageWidth / 2) - 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 10);
            var ellipse2 = drawEllipse((this.stage.stageWidth / 2) + 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 300);

            this.addChild(ellipse1);
            this.addChild(ellipse2);
            
            ellipse1.addEventListener(Event.ENTER_FRAME, ellipse1FrameHandler);
            ellipse2.addEventListener(Event.ENTER_FRAME, ellipse2FrameHandler);
        }

        private function drawEllipse(x:Number, y:Number, w:Number, h:Number, z:Number):Shape {
            var s:Shape = new Shape();                            
            s.z = z;
            s.graphics.beginFill(0xFF0000);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(x, y, w, h);
            s.graphics.endFill();
            return s;
        }

        private function ellipse1FrameHandler(e:Event):void {
            ellipse1Back = setDepth(e, ellipse1Back);
            e.currentTarget.z += ellipse1Back * 10;
        }

        private function ellipse2FrameHandler(e:Event):void {
            ellipse2Back = setDepth(e, ellipse2Back);
            e.currentTarget.z += ellipse2Back * 20;
        }

        private function setDepth(e:Event, d:int):int {
            if(e.currentTarget.z > depth) {
                e.currentTarget.z = depth; 
                d = -1;
            }else if (e.currentTarget.z &lt;  0) {
                e.currentTarget.z = 0;
                d = 1;
            }
            return d;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>transformation</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:blendShader:set"><apiName>blendShader</apiName><shortdesc>
     Définit un shader utilisé pour le fondu de l’arrière-plan et du premier plan.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.display:Shader</apiValueClassifier><apiException><apiDesc>Lorsque le type de sortie du shader n’est pas compatible avec cette opération (le shader doit spécifier une sortie <codeph>pixel4</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque le shader spécifie moins de deux entrées d’image ou que les deux premières entrées ne sont pas des entrées <codeph>image4</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque le shader spécifie une entrée d’image non fournie.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsqu’une occurrence de ByteArray ou de Vector.&lt;Number> est utilisée comme entrée et les propriétés <codeph>width</codeph> et <codeph>height</codeph> ne sont pas spécifiées pour le ShaderInput, ou les valeurs spécifiées ne correspondent pas à la quantité de données dans l’objet d’entrée. Voir la propriété <codeph>ShaderInput.input</codeph> pour plus d’informations.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Définit un shader utilisé pour le fondu de l’arrière-plan et du premier plan. Lorsque la propriété<codeph>blendMode</codeph> est définie sur <codeph>BlendMode.SHADER</codeph>, le Shader spécifié est utilisé pour créer la sortie du mode fondu pour l’objet d’affichage.
     
     <p>La définition de la propriété <codeph>blendShader</codeph> d’un objet d’affichage sur une occurrence Shader définit automatiquement la propriété <codeph>blendMode</codeph> de l’objet d’affichage sur <codeph>BlendMode.SHADER</codeph>. Si la propriété <codeph>blendShader</codeph> est définie (ce qui définit la propriété <codeph>blendMode</codeph> sur <codeph>BlendMode.SHADER</codeph>) et que la valeur de la propriété <codeph>blendMode</codeph> est modifiée, le mode de fondu peut être réinitialisé pour utiliser le shader de fondu en définissant simplement la propriété <codeph>blendMode</codeph> sur <codeph>BlendMode.SHADER</codeph>. La propriété <codeph>blendShader</codeph> n’a plus besoin d’être définie, sauf pour modifier le shader utilisé pour définir le mode de fondu.</p>
     
     <p>Le Shader affecté à la propriété <codeph>blendShader</codeph> doit spécifier au moins deux entrées <codeph>image4</codeph>. Il n’est <b>pas</b> nécessaire de spécifier les entrées en code à l’aide des propriétés <codeph>input</codeph> des objets ShaderInput. L’objet d’affichage de l’arrière-plan est automatiquement utilisé comme première entrée (l’entrée présentant un <codeph>index</codeph> 0). L’objet d’affichage de premier-plan est automatiquement utilisé comme seconde entrée (l’entrée présentant un <codeph>index</codeph> 1). Un shader utilisé comme shader de fondu peut spécifier plus de deux entrées. Dans ce cas, toute entrée supplémentaire doit être spécifiée par la définition de la propriété <codeph>input</codeph> de son occurrence ShaderInput.</p>
     
     <p>Lorsque vous affectez une occurrence Shader à cette propriété, le shader est copié en interne. L’opération de fondu utilise cette copie interne et non une référence au shader d’origine. Toute modification apportée au shader, par exemple la modification de la valeur d’un paramètre, l’entrée ou le pseudo-code binaire, n’est pas appliquée au shader copié qui est utilisé pour le mode de fondu.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Loader"><apiName>Loader</apiName><shortdesc>
 La classe Loader permet de charger des fichiers SWF ou des fichiers d’image (JPG, PNG ou GIF).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Loader permet de charger des fichiers SWF ou des fichiers d’image (JPG, PNG ou GIF). Utilisez la méthode <codeph>load()</codeph> pour lancer le chargement. L’objet d’affichage chargé est intégré en tant qu’enfant à l’objet Loader.
 
 <p>Utilisez la classe URLLoader pour charger du texte ou des données binaires.</p>
 
 <p>La classe Loader bloque les méthodes indiquées ci-dessous dont elle hérite, car un objet Loader ne peut disposer que d’un seul objet d’affichage enfant, celui qu’il charge. L’appel des méthodes suivantes renvoie une exception : <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph>, <codeph>removeChild()</codeph>, <codeph>removeChildAt()</codeph> et <codeph>setChildIndex()</codeph>. Pour supprimer un objet d’affichage chargé, vous devez supprimer l’objet <i>Loader</i> du tableau des enfants de l’occurrence de DisplayObjectContainer parent. </p>
 
 <p><b>Remarque :</b> les classes MovieClipLoader et LoadVars d’ActionScript 2.0 ne sont plus utilisées dans ActionScript 3.0. Les classes Loader et URLLoader les remplacent.</p>
 
 <p>Pour utiliser la classe Loader, tenez compte du modèle de sécurité de Flash Player et d’Adobe AIR : </p>
 
 <ul>
  <li>Vous pouvez charger du contenu à partir de toute source accessible. </li>
 
  <li>Le chargement n’est pas autorisé si le fichier SWF appelant est sur un sandbox réseau et que le fichier à charger est local. </li>
 
  <li>Si le contenu chargé est un fichier SWF écrit en langage ActionScript 3.0, il ne peut pas être intercodé par un fichier SWF appartenant à un autre sandbox de sécurité, à moins que des dispositions d’intercodage n’aient été approuvées par un appel à la méthode <codeph>System.allowDomain()</codeph> ou <codeph>System.allowInsecureDomain()</codeph> dans le fichier de contenu chargé.</li>
  
  <li>Si le contenu chargé est un fichier SWF AVM1 (écrit en langage ActionScript 1.0 ou 2.0), il ne peut pas être intercodé par un fichier SWF AVM2 (écrit en langage ActionScript 3.0). La classe LocalConnection permet cependant aux deux fichiers SWF de communiquer entre eux.</li>
  
  <li>Si le contenu chargé est une image, un fichier SWF situé en dehors du sandbox de sécurité ne peut pas accéder aux données correspondantes, à moins que le domaine de ce fichier n’ait été inclus dans un fichier de régulation d’URL dans le domaine d’origine de l’image.</li>
 
  <li>Les clips situés dans le sandbox local avec système de fichier ne peuvent pas inscrire des clips dans le sandbox local avec accès au réseau (l’inverse est également impossible). </li>
 
  <li>Vous ne pouvez pas vous connecter à des ports réservés. Pour obtenir une liste complète des ports bloqués, reportez-vous à la rubrique « Restriction des API de réseau » dans le <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref> </ph> du manuel <i>Programmation avec ActionScript 3.0</i>. </li>
 
 
 </ul>
 
 <p>Néanmoins, dans AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
 
 <p>Pour plus d’informations, voir les références suivantes :</p>
 
 <ul>
 
 <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
 
 </ul>
 
 <p>Lorsque vous chargez un fichier SWF d’une source non approuvée (telle qu’un domaine autre que celui du fichier SWF racine de l’objet Loader), il peut s’avérer utile de définir un masque pour ce dernier, afin d’empêcher le contenu chargé, qui est un enfant de l’objet Loader, d’apparaître dans des parties de la scène qui ne relèvent pas de ce masque, comme illustré par le code suivant :</p>
 
 <codeblock>import flash.display.~~;
 import flash.net.URLRequest;
 var rect:Shape = new Shape();
 rect.graphics.beginFill(0xFFFFFF);
 rect.graphics.drawRect(0, 0, 100, 100);
 rect.graphics.endFill();
 addChild(rect);
 var ldr:Loader = new Loader();
 ldr.mask = rect;
 var url:String = "http://www.unknown.example.com/content.swf";
 var urlReq:URLRequest = new URLRequest(url);
 ldr.load(urlReq);
 addChild(ldr);
 </codeblock>
 
 </apiDesc><example conref="examples\LoaderExample.as"> L’exemple suivant exploite la classe LoaderExample pour illustrer la façon dont les différents écouteurs d’événement sont utilisés. Pour ce faire, procédez comme suit :
 <ol>
  <li>Une propriété <codeph>url</codeph> est créée pour désigner l’emplacement et le nom du fichier d’image.</li>
  <li>Dans le constructeur <codeph>LoaderExample</codeph>, un nouvel objet Loader appelé <codeph>loader</codeph> est créé, qui est ensuite transmis à la méthode <codeph>configureListeners()</codeph>, décrite à l’étape 3.</li>
  <li>Le constructeur crée une occurrence d’objet URLRequest, <codeph>request</codeph>, et transmet le paramètre <codeph>url</codeph> de façon à identifier le nom de fichier et son emplacement.</li>
  <li>L’objet <codeph>request</codeph> est ensuite transmis à la méthode <codeph>load()</codeph> de l’objet <codeph>loader</codeph>, qui charge l’image dans la liste d’affichage.</li>
  <li>Un écouteur d’événement <codeph>clickHandler</codeph> est enregistré pour l’événement <codeph>click</codeph> sur l’objet loader. Lorsque l’utilisateur clique avec la souris, l’image chargée est déchargée.</li>
  <li>La méthode <codeph>configureListeners()</codeph> ajoute sept écouteurs d’événement à l’aide des méthodes suivantes :
  <ul>
      <li>La méthode <codeph>completeHandler()</codeph> s’exécute lorsque l’image termine son chargement.</li>
 
      <li>La méthode <codeph>httpStatusHandler()</codeph> s’exécute lorsque l’image n’est pas chargée de façon locale et uniquement lorsque la requête réseau est rendue disponible et lorsque Flash Player peut la détecter.</li>
 
      <li>La méthode <codeph>initHandler()</codeph> s’exécute avant la méthode <codeph>completeHandler()</codeph> et après la méthode <codeph>progressHandler()</codeph>. En général, l’événement <codeph>init</codeph> est plus utile lors du chargement des fichiers SWF.</li>
 
      <li>La méthode <codeph>ioErrorHandler()</codeph> s’exécute si le fichier d’image n’est pas disponible ou n’est pas accessible.</li>
 
      <li>La méthode <codeph>openHandler()</codeph> s’exécute lorsque le fichier d’image est ouvert en premier.</li>
 
      <li>La méthode <codeph>progressHandler()</codeph> s’exécute lorsque le fichier d’image commence son chargement et s’exécute de nouveau à la fin de cette procédure.</li>
 
      <li>La méthode <codeph>unLoadHandler()</codeph> s’exécute lorsque l’image est déchargée à l’aide de la méthode <codeph>unload()</codeph> lorsque l’utilisateur clique sur l’image.</li>
 
  </ul>
  </li>
 </ol>
 <p> N’oubliez pas les spécifications suivantes :</p>
 
 <ul>
  <li>Cet exemple implique le placement d’un fichier appelé Image.gif dans le même répertoire que le fichier SWF compilé. Utilisez une image dont la zone corresponde aux dimensions du fichier SWF principal.</li>
 
  <li>Cet exemple couvre tous les événements disponibles pour l’objet LoaderInfo. Cependant, la plupart des situations n’en nécessite qu’un sous-ensemble. En particulier, lors du chargement d’un fichier d’image unique, l’événement <codeph>complete</codeph> (voire l’événement <codeph>ioError</codeph>) suffisent lors du chargement d’une image locale.</li>
 
 </ul>
 
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderExample() {
            var loader:Loader = new Loader();
            configureListeners(loader.contentLoaderInfo);
            loader.addEventListener(MouseEvent.CLICK, clickHandler);

            var request:URLRequest = new URLRequest(url);
            loader.load(request);

            addChild(loader);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(Event.INIT, initHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(Event.UNLOAD, unLoadHandler);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function initHandler(event:Event):void {
            trace("initHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function unLoadHandler(event:Event):void {
            trace("unLoadHandler: " + event);
        }

        private function clickHandler(event:MouseEvent):void {
            trace("clickHandler: " + event);
            var loader:Loader = Loader(event.target);
            loader.unload();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:Loader:Loader"><apiName>Loader</apiName><shortdesc>
     Crée un objet Loader qui permet de charger des fichiers (SWF, JPEG, GIF ou PNG).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need wording on parent/child relationships, root DisplayObjects, and so on.
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Crée un objet Loader qui permet de charger des fichiers (SWF, JPEG, GIF ou PNG). Appelez la méthode <codeph>load()</codeph> pour charger la ressource en tant qu’enfant de l’occurrence de Loader. Vous pouvez alors ajouter l’objet Loader à la liste d’affichage (par le biais de la méthode <codeph>addChild()</codeph> d’une occurrence de DisplayObjectContainer, par exemple). La ressource apparaît sur la scène au fur et à mesure de son chargement.
     
     <p>Vous pouvez également utiliser une occurrence de Loader sans l’intégrer à un conteneur d’objet d’affichage de la liste d’affichage. Si ce mode est activé, l’occurrence de Loader peut être utilisée pour charger un fichier SWF contenant d’autres modules d’une application. </p>
     
     <p>Pour détecter la fin du chargement du fichier SWF, vous disposez des événements de l’objet LoaderInfo associés à la propriété <codeph>contentLoaderInfo</codeph> de l’objet Loader. A ce stade, vous pouvez exécuter le code du fichier SWF du module pour initialiser et démarrer ce dernier. En mode hors liste, l’occurrence de Loader peut également être utilisée pour charger un fichier SWF contenant des composants ou des ressources multimédias. Il est également possible d’utiliser les notifications d’événement associées à l’objet LoaderInfo pour détecter la fin du chargement des composants. L’application peut alors commencer à utiliser les composants et les ressources multimédias intégrés à la bibliothèque du fichier SWF en instanciant les classes ActionScript 3.0 qui représentent ces composants et ces ressources.</p>
     
     <p>Pour déterminer le statut d’un objet Loader, supervisez les événements suivants que l’objet LoaderInfo a associé à la propriété <codeph>contentLoaderInfo</codeph> de l’objet Loader :</p>
     
     <ul>
       
     <li>L’événement <codeph>open</codeph> est distribué lorsque le chargement commence.</li>
       
     <li>L’événement <codeph>ioError</codeph> ou <codeph>securityError</codeph> est distribué s’il est impossible de charger le fichier ou s’il se produit une erreur lors du processus de chargement. </li>
       
     <li>L’événement <codeph>progress</codeph> est déclenché continuellement lors du chargement du fichier.</li>
       
     <li>L’événement <codeph>complete</codeph> est distribué lorsque le chargement d’un fichier est terminé, mais avant la mise à disposition des méthodes et des propriétés du clip qui vient d’être chargé. </li>
       
     <li>L’événement <codeph>init</codeph> est distribué après la mise à disposition des méthodes et des propriétés du fichier SWF chargé, afin de vous permettre de commencer à manipuler ce dernier. Cet événement est distribué avant le gestionnaire <codeph>complete</codeph>. Dans les fichiers SWF en diffusion continue, l’événement <codeph>init</codeph> risque de se produire bien avant l’événement <codeph>complete</codeph>. Dans la plupart des cas, utilisez le gestionnaire <codeph>init</codeph>.</li>
     
     </ul>
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:Loader:close"><apiName>close</apiName><shortdesc>
     Annule une opération associée à la méthode load() actuellement en cours d’exécution pour l’occurrence de Loader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Annule une opération associée à la méthode <codeph>load()</codeph> qui est en cours d’exécution pour l’occurrence de Loader. 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:load"><apiName>load</apiName><shortdesc>
     Charge un fichier SWF, JPEG, JPEG progressif, GIF non animé ou PNG dans un objet enfant de l’objet Loader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how to use the <code>MovieClipLoader.loadClip()</code> 
     method by creating a handler for the <code>onLoadInit</code> event and then making the request.
     <p>You should either place the following code directly into a frame action on a Timeline, or 
     paste it into a class that extends MovieClip. This code also expects an image named YourImage.jpg
     to exist in the same directory as the compiled SWF file.</p>
     
     <listing version="2.0">
     var container:MovieClip = createEmptyMovieClip("container", getNextHighestDepth());
     var mcLoader:MovieClipLoader = new MovieClipLoader();
     mcLoader.addListener(this);
     mcLoader.loadClip("YourImage.jpg", container);
     
     function onLoadInit(mc:MovieClip) {
         trace("onLoadInit: " + mc);
     }
     </listing>
     
     </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La propriété <codeph>digest</codeph> de l’objet <codeph>request</codeph> n’est pas définie sur <codeph>null</codeph>. Vous devez définir la propriété <codeph>digest</codeph> d’un objet URLRequest uniquement lorsque vous appelez la méthode <codeph>URLLoader.load()</codeph> en vue de charger un fichier SWZ (un composant de la plateforme Adobe).
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La valeur de <codeph>LoaderContext.securityDomain</codeph> doit être réglée sur <codeph>null</codeph> ou <codeph>SecurityDomain.currentDomain</codeph>. En effet, vous ne pouvez placer le média chargé que dans son sandbox de sécurité naturel ou dans le vôtre, auquel cas l’utilisation d’un fichier de régulation s’impose.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Les fichiers SWF locaux sont susceptibles de ne régler LoaderContext.securityDomain que sur la valeur <codeph>null</codeph>. Il est interdit d’importer des médias non locaux dans un sandbox local ou de placer d’autres médias locaux dans un environnement autre que son sandbox naturel.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port réservé. Pour obtenir une liste complète des ports bloqués, reportez-vous à la rubrique « Restriction des API de réseau » dans le manuel <i>Programmation avec ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si les propriétés <codeph>applicationDomain</codeph> or <codeph>securityDomain</codeph> du paramètre <codeph>context</codeph> proviennent d’un domaine interdit.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si un fichier SWF local tente d’utiliser la propriété <codeph>securityDomain</codeph> du paramètre <codeph>context</codeph>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> URL absolue ou relative du fichier SWF, JPEG, GIF ou PNG à charger. Un chemin relatif doit être relatif par rapport au fichier SWF principal. Une URL absolue doit inclure la référence de protocole, telle que http:// ou file:///. Les noms de fichier ne doivent pas inclure les spécifications de lecteur de disque.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet LoaderContext, dont les propriétés :
     
     <ul>
     
	 <li>Spécifie si l’existence d’un fichier de régulation lors du chargement de l’objet doit être vérifiée ou non</li>
     
     <li>définissent le paramètre ApplicationDomain de l’objet chargé ;</li>
     
     <li>définissent le paramètre SecurityDomain de l’objet chargé.</li>
     
     </ul>
     <p>Si le paramètre <codeph>context</codeph> n’est pas spécifié ou renvoie à un objet null, le contenu chargé reste dans son propre domaine de sécurité.</p>
     
     <p>Pour obtenir des informations détaillées, veuillez consulter la description des propriétés de la classe <xref href="../system/LoaderContext.html">LoaderContext</xref>.</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Charge un fichier SWF ou un fichier d’image dans un objet DisplayObject, qui est un enfant de cette occurrence de Loader.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Charge un fichier SWF, JPEG, JPEG progressif, GIF non animé ou PNG dans un objet enfant de l’objet Loader. Si vous chargez un fichier GIF animé, seule la première image est affichée. Puisque l’objet Loader ne peut contenir qu’un seul enfant, générer une nouvelle requête <codeph>load()</codeph> met fin à la requête précédente si elle est en attente et démarre un autre chargement.
     
     <p><b>Remarque</b> : dans AIR 1.5 et Flash Player 10, la taille maximale d’une image chargée est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image chargée est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large.</p>
     
     <p>Un fichier SWF ou une image chargé(e) dans un objet Loader hérite des propriétés position, rotation et scale (échelle) des objets d’affichage parent de l’objet Loader. </p>
     
     <p>Utilisez <codeph>unload()</codeph> pour supprimer des animations ou des images chargées à l’aide de cette méthode ou pour annuler une opération de chargement en cours.</p>
     
     <p>Vous pouvez empêcher un fichier SWF d’utiliser cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui comporte le contenu SWF.</p>
     
     <p>Si vous utilisez cette méthode, tenez compte du modèle de sécurité de Flash Player, expliqué dans la description de la classe Loader. </p>
     
     <p> Dans Flash Player versions 10 et ultérieures, si vous utilisez un Content-Type en plusieurs parties (par exemple « multipart/form-data ») qui contient un chargement (indiqué par un paramètre « filename » dans un en-tête « content-disposition » au sein du corps POST), l’opération POST est soumise aux règles de sécurité appliquées aux chargements :</p>
	 <ul>
	 <li>L’opération POST doit être effectuée en réponse à l’action d’un utilisateur, comme un clic de souris ou la pression d’une touche.</li>
	 <li>Si l’opération POST se fait entre plusieurs domaines (la cible POST ne se trouve pas sur le même serveur que le fichier SWF qui envoie la demande POST), le serveur cible doit fournir un fichier de régulation d’URL qui permette l’accès interdomaines.</li>
	 </ul>
     <p>Par ailleurs, la syntaxe de tous les Content-Type en plusieurs parties doit être correcte (selon la norme RFC2046). Si la syntaxe s’avère incorrecte, l’opération POST est soumise aux règles de sécurité appliquées aux chargements.</p>
     <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/contentLoaderInfo"><linktext>contentLoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>flash.display.Loader.unload()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><adobeApiEvent id="flash.display:Loader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> associé lorsque le fichier a terminé son chargement. L’événement <codeph>complete</codeph> est toujours distribué après l’événement <codeph>init</codeph>.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo associé lorsque le fichier a terminé son chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> associé lorsqu’une requête réseau est envoyée via HTTP et que Flash Player peut détecter le code d’état HTTP.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo associé lorsqu’une requête réseau est envoyée via HTTP et que Flash Player peut détecter le code d’état HTTP.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_init"><apiName>init</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> associé lorsque les propriétés et les méthodes du fichier SWF chargé sont accessibles. L’événement <codeph>init</codeph> précède toujours l’événement <codeph>complete</codeph>.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo associé lorsque les propriétés et les méthodes du fichier SWF chargé sont accessibles.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> associé lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération de chargement.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo associé lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> associé lorsque l’opération de chargement commence.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo associé lorsque l’opération de chargement commence.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> associé en tant que données et reçu pendant la progression de l’opération de chargement.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo associé en tant que données et reçu pendant la progression de l’opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> si un fichier SWF du sandbox local avec système de fichiers tente de charger du contenu dans un sandbox local avec accès au réseau, ou vice versa.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo si un fichier SWF du sandbox local avec système de fichiers tente de charger du contenu dans un sandbox local avec accès au réseau, ou vice versa.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_unload"><apiName>unload</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué par l’objet <codeph>contentLoaderInfo</codeph> associé lorsqu’un objet chargé est supprimé.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué par l’objet contentLoaderInfo associé lorsqu’un objet chargé est supprimé.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:Loader:loadBytes"><apiName>loadBytes</apiName><shortdesc>
     Charge des données binaires stockées dans un objet ByteArray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la propriété <codeph>length</codeph> de l’objet ByteArray n’est pas supérieure à 0.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si la propriété <codeph>checkPolicyFile</codeph> ou <codeph>securityDomain</codeph> du paramètre <codeph>context</codeph> n’est pas réglée sur la valeur null.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si la propriété <codeph>applicationDomain</codeph> proposée de la propriété <codeph>context</codeph> provient d’un domaine interdit.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port réservé. Pour obtenir une liste complète des ports bloqués, reportez-vous à la rubrique « Restriction des API de réseau » dans le manuel <i>Programmation avec ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray. Le format du contenu de cet objet peut correspondre à n’importe quel type de fichier géré par la classe Loader : SWF, GIF, JPEG ou PNG.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet LoaderContext. Seule la propriété <codeph>applicationDomain</codeph> de cet objet entre en vigueur. Les propriétés <codeph>checkPolicyFile</codeph> et <codeph>securityDomain</codeph> sont exclues. 
     
     <p>Si le paramètre <codeph>context</codeph> n’est pas spécifié ou renvoie à un objet null, le contenu est chargé dans le domaine de sécurité actif ; cette opération est appelée « chargement en vue de l’exportation » dans la documentation de sécurité de Flash Player. De façon spécifique, si le fichier SWF de chargement approuve le fichier SWF distant en l’incorporant dans son code, le fichier SWF de chargement peut l’importer directement dans son propre domaine de sécurité.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Charge des données binaires stockées dans un objet ByteArray.
     
     <p>Si vous utilisez cette méthode, tenez compte du modèle de sécurité de Flash Player, expliqué dans la description de la classe Loader. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unload"><apiName>unload</apiName><shortdesc>
     Supprime un enfant de l’objet Loader chargé à l’aide de la méthode load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The funky-looking code formatting above is intentional to work around a bug!
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Supprime un enfant de l’objet Loader chargé à l’aide de la méthode <codeph>load()</codeph>. La valeur <codeph>property</codeph> de la propriété<codeph>null</codeph> de l’objet LoaderInfo associé est réinitialisée. L’enfant n’est pas nécessairement détruit, car d’autres objets risquent de s’y référer. Il n’est cependant plus un enfant de l’objet Loader.
     
     <p>Avant de décharger un fichier SWF enfant, il est recommandé de fermer explicitement tout flux continu dans les objets enfant du fichier SWF, tels que les objets LocalConnection, NetConnection, NetStream et Sound. Si vous n’effectuez pas cette opération, la lecture de l’audio risque de continuer dans le fichier SWF enfant, bien que ce dernier soit déchargé. Pour fermer les flux continus dans le fichier SWF enfant, ajoutez un écouteur d’événement à l’enfant qui écoute l’événement <codeph>unload</codeph>. Lorsque le parent appelle <codeph>Loader.unload()</codeph>, l’événement <codeph>unload</codeph> est distribué à l’enfant. L’exemple suivant illustre cette opération :</p>
<pre>
function closeAllStreams(evt:Event) { 
    myNetStream.close();
    mySound.close();
    myNetConnection.close();
    myLocalConnection.close();
}

myMovieClip.loaderInfo.addEventListener(Event.UNLOAD, closeAllStreams);</pre>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.media.xml#Sound/close()"><linktext>flash.media.Sound.close()</linktext></link><link href="flash.net.xml#LocalConnection/close()"><linktext>flash.net.LocalConnection.close()</linktext></link><link href="flash.net.xml#NetConnection/close()"><linktext>flash.net.NetConnection.close()</linktext></link><link href="flash.net.xml#NetStream/close()"><linktext>flash.net.NetStream.close()</linktext></link><link href="../../operators.html#delete"><linktext>opérateur delete</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unloadAndStop"><apiName>unloadAndStop</apiName><shortdesc>
     Tente de décharger le contenu du fichier SWF enfant et interrompt l’exécution des commandes des fichiers SWF chargés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>gc</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Indique au nettoyeur de mémoire de s’exécuter sur les objets SWF enfant (<codeph>true</codeph>) ou pas (<codeph>false</codeph>). Si vous déchargez plusieurs objets de façon asynchrone, définissez le paramètre <codeph>gc</codeph> sur <codeph>false</codeph> afin d’améliorer les performances de l’application. Toutefois, si ce paramètre est défini sur <codeph>false</codeph>, les objets multimédia et les objets d’affichage du fichier SWF enfant peuvent rester en mémoire après l’exécution de la commande <codeph>unloadAndStop()</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Tente de décharger le contenu du fichier SWF enfant et interrompt l’exécution des commandes des fichiers SWF chargés. Cette méthode tente de décharger les fichiers SWF qui ont été chargés à l’aide de la méthode <codeph>Loader.load()</codeph> ou <codeph>Loader.loadBytes()</codeph> en supprimant les références aux objets EventDispatcher, NetConnection, Timer, Sound ou Video du fichier SWF enfant. Par conséquent, les actions suivantes sont effectuées dans le fichier SWF enfant et la liste d’affichage du fichier SWF enfant :
     <ul><li>Les sons sont arrêtés.</li>
     <li>Les écouteurs d’événement sont supprimés de la scène.</li>
     <li>Les écouteurs d’événement des événements <codeph>enterFrame</codeph>, <codeph>frameConstructed</codeph>, <codeph>exitFrame</codeph>, <codeph>activate</codeph> et <codeph>deactivate</codeph> sont supprimés.</li>
     <li>Les horloges sont arrêtées.</li>
     <li>Les occurrences Camera et Microphone sont détachées.</li>
     <li>Les clips sont arrêtés.</li></ul>
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Loader:content:get"><apiName>content</apiName><shortdesc>
     Contient l’objet d’affichage racine du fichier SWF ou du fichier d’image (JPG, PNG ou GIF) qui a été chargé à l’aide de la méthode load() ou loadBytes().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>Le fichier SWF ou le fichier d’image chargé appartient à un sandbox de sécurité auquel vous n’avez pas accès. Pour un fichier SWF chargé, vous pouvez éviter ce problème en forçant le fichier à appeler la méthode <codeph>Security.allowDomain()</codeph> ou en imposant au fichier en cours de chargement de spécifier un paramètre <codeph>loaderContext</codeph>, la propriété <codeph>securityDomain</codeph> correspondante étant réglée sur <codeph>SecurityDomain.currentDomain</codeph> lorsque vous appelez la méthode <codeph>load()</codeph> ou <codeph>loadBytes()</codeph>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Contient l’objet d’affichage racine du fichier SWF ou du fichier d’image (JPG, PNG ou GIF) qui a été chargé à l’aide de la méthode <codeph>load()</codeph> ou <codeph>loadBytes()</codeph>.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:Loader:contentLoaderInfo:get"><apiName>contentLoaderInfo</apiName><shortdesc>
     Renvoie un objet LoaderInfo qui correspond à l’objet en cours de chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie un objet LoaderInfo qui correspond à l’objet en cours de chargement. Les objets LoaderInfo sont partagés entre l’objet Loader et l’objet chargé. L’objet LoaderInfo fournit des informations relatives à la progression du déroulement du chargement et des statistiques sur le fichier chargé. 
     
     <p>Les événements liés au chargement sont distribués par l’objet LoaderInfo qui est référencé par la propriété <codeph>contentLoaderInfo</codeph> de l’objet Loader. La propriété <codeph>contentLoaderInfo</codeph> est définie sur un objet LoaderInfo valide, y compris avant le chargement du contenu, ce qui permet d’ajouter des écouteurs d’événement à l’objet avant l’opération de chargement.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
     La classe NativeMenuItem représente une seule option dans un menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     La classe NativeMenuItem représente une seule option dans un menu.
     
     <p>Une option de menu peut être une commande, un sous-menu ou une ligne de démarcation :</p> 
     
     <ul>
     <li>Pour créer un élément de commande, appelez le constructeur NativeMenuItem en transmettant une chaîne pour l’étiquette et <codeph>false</codeph> pour le paramètre <codeph>isSeparator</codeph>.</li>
     
     <li>Pour créer un sous-menu, créez un élément de commande pour le menu parent et attribuez l’objet NativeMenu du sous-menu à la propriété <codeph>submenu</codeph> de l’élément. Vous pouvez également appeler la méthode <codeph>addSubmenu()</codeph> de l’objet NativeMenu parent pour créer l’élément et définir la propriété <codeph>submenu</codeph> en même temps.</li>
     
     <li>Pour créer un séparateur, appelez le constructeur NativeMenuItem en transmettant une chaîne vide pour l’étiquette et <codeph>true</codeph> pour le paramètre <codeph>isSeparator</codeph>.</li>
     </ul>
     
     <p>Ecoutez les événements <codeph>select</codeph> sur un élément ou un menu parent pour détecter le moment où une commande de menu est sélectionnée. Ni les sous-menus ni les séparateurs ne distribuent d’événements select. Ecoutez les événements <codeph>displaying</codeph> pour déterminer le moment où une option de menu va s’afficher.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Distribué par cet objet NativeMenuItem immédiatement avant l’affichage du menu contenant l’option.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Distribué par cet objet NativeMenuItem immédiatement avant l’affichage du menu contenant l’option. 
     
	 <p>La propriété <codeph>target</codeph> de l’objet event fait référence à l’objet NativeMenu contenant cet objet NativeMenuItem ; la propriété <codeph>currentTarget</codeph> référence ce NativeMenuItem.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Distribué chaque fois que l’utilisateur sélectionne une option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Distribué chaque fois que l’utilisateur sélectionne une option de menu. 
     
     <p>Un événement <codeph>select</codeph> effectue une <i>propagation vers le haut</i> de cet élément vers le menu qu’il contient jusqu’à l’objet menu racine en passant par la chaîne de menu parent. La propriété <codeph>target</codeph> de l’objet event fait référence à cet objet NativeMenuItem ; la propriété <codeph>currentTarget</codeph> fait référence à l’objet dispatching (cet objet NativeMenuItem ou un ancien objet NativeMenu).</p>
	 
	 <p><b>Remarque :</b> si la fenêtre contenant le menu est en mode plein écran, l’objet NativeMenuItem ne distribue <i>pas</i> un événement <codeph>select</codeph> lorsque l’utilisateur entre un équivalent clavier pour une option de menu. Néanmoins, vous pouvez écouter un événement <codeph>keyDown</codeph> distribué par la propriété <codeph>stage</codeph> de l’objet NativeWindow.</p>
       
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeMenuItem:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
         Crée un nouvel objet NativeMenuItem.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>L’étiquette d’affichage pour l’élément ou une chaîne vide pour des séparateurs.
         </apiDesc></apiParam><apiParam><apiItemName>isSeparator</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Réglez sur <codeph>true</codeph> pour créer un séparateur ; autrement, réglez sur <codeph>false</codeph>.
         
         </apiDesc></apiParam></apiConstructorDef><apiDesc>
         Crée un nouvel objet NativeMenuItem.
         
         <p>Pour créer une commande de menu, définissez le paramètre <codeph>label</codeph> sur une chaîne contenant l’étiquette d’affichage et définissez <codeph>isSeparator</codeph> sur <codeph>false</codeph>.</p>
	     
	     <p>Pour créer une commande de sous-menu, créez un élément de commande, puis affectez l’objet NativeMenu du sous-menu à la propriété <codeph>submenu</codeph> de cet élément. Ajoutez l’élément au menu parent.</p>
		  
	     <p>Pour créer un séparateur, définissez le paramètre <codeph>label</codeph> sur une chaîne vide et définissez <codeph>isSeparator</codeph> sur <codeph>true</codeph>.</p>
         
         <p>Ajoutez et supprimez des éléments d’un menu à l’aide des méthodes NativeMenu <codeph>addItem()</codeph> et <codeph>removeItem()</codeph>.</p>
         
         </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeMenuItem:clone"><apiName>clone</apiName><shortdesc>
         Crée une copie de l’objet NativeMenuItem.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Crée une copie de l’objet NativeMenuItem.
         
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenuItem:toString"><apiName>toString</apiName><shortdesc>
         Renvoie une chaîne répertoriant toutes les propriétés de l’objet NativeMenuItem.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Chaîne répertoriant toutes les propriétés de l’objet Event.
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Renvoie une chaîne répertoriant toutes les propriétés de l’objet NativeMenuItem.
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenuItem:checked:get"><apiName>checked</apiName><shortdesc>
         Contrôle si cette option de menu affiche une case à cocher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Contrôle si cette option de menu affiche une case à cocher.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:data:get"><apiName>data</apiName><shortdesc>
         Un objet de données arbitraire associé à cette option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
         Un objet de données arbitraire associé à cette option de menu.
         
         <p>Vous pouvez attribuer n’importe quel objet à cette propriété. L’objet affecté n’est pas utilisé par le système de menu mais est disponible pour le code de gestion des événements (via la propriété target de l’objet event). Par défaut, la valeur de cette propriété est <codeph>null</codeph>.</p>
           
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:enabled:get"><apiName>enabled</apiName><shortdesc>
         Contrôle si cette option de menu est activée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Contrôle si cette option de menu est activée.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:isSeparator:get"><apiName>isSeparator</apiName><shortdesc>
         Indique si cet élément est une ligne de démarcation de menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Indique si cet élément est une ligne de démarcation de menu.
         
         <p>Créez une ligne de démarcation en définissant le paramètre <codeph>isSeparator</codeph> dans le constructeur NativeMenuItem sur <codeph>true</codeph>.</p> 
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalent:get"><apiName>keyEquivalent</apiName><shortdesc>
         L’équivalent de touche de cette option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         L’équivalent de touche de cette option de menu.
		 
		 <p>Définissez <codeph>keyEquivalent</codeph> avec une minuscule pour affecter un raccourci sans touche de modification Maj. Définissez une lettre majuscule pour affecter un raccourci avec la touche de modification Maj.</p>
		 
		 <p>Par défaut, un modificateur d’équivalent de touche (Ctrl sous Windows ou Linux et Commande sous Mac OS X) est inclus dans l’équivalent de touche. Si vous souhaitez que l’équivalent de touche soit une touche sans modificateur, définissez la propriété <codeph>keyEquivalentModifiers</codeph> sur un tableau vide.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalentModifiers:get"><apiName>keyEquivalentModifiers</apiName><shortdesc>
         Le tableau de codes de touche pour les modificateurs des équivalents de touche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         Le tableau de codes de touche pour les modificateurs des équivalents de touche.
         
         <p>Utilisez les constantes définies dans la classe Keyboard pour spécifier les codes de touche de modificateur. Les touches de modificateur valides comprennent :</p>
         <ul>
         <li><codeph>Keyboard.ALTERNATE</codeph></li>
         <li><codeph>Keyboard.COMMAND</codeph></li>
         <li><codeph>Keyboard.CONTROL</codeph></li>
         </ul>
		 
		 <p>Si vous n’affectez aucun modificateur, la touche <codeph>Keyboard.CONTROL</codeph> est affectée par défaut sous Windows ou Linux et la touche <codeph>Keyboard.COMMAND</codeph> est affectée sous Mac OS X. Si vous ne souhaitez pas que l’équivalent de touche comprenne ces modificateurs, définissez cette propriété sur un tableau vide.</p>
		 
		 <p>Si vous affectez une lettre majuscule à la propriété <codeph>keyEquivalent</codeph>, la touche Maj est automatiquement utilisée comme modificateur. La définition de <codeph>keyEquivalentModifier</codeph> sur un tableau vide ne supprime pas la touche Maj comme modificateur.</p> 
         
         </apiDesc></apiValueDetail><related-links><link href="flash.ui.xml#Keyboard"><linktext>flash.ui.Keyboard</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeMenuItem:label:get"><apiName>label</apiName><shortdesc>
         La chaîne d’affichage de cette option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         La chaîne d’affichage de cette option de menu.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:menu:get"><apiName>menu</apiName><shortdesc>
         Le menu qui contient cette option.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         Le menu qui contient cette option.  
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:mnemonicIndex:get"><apiName>mnemonicIndex</apiName><shortdesc>
         La position du caractère mnémonique dans l’étiquette de l’option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         La position du caractère mnémonique dans l’étiquette de l’option de menu.
         
         <p>Le caractère à la position spécifiée devient le caractère mnémonique pour l’option de menu. L’index est de base zéro, donc le premier caractère a un index de 0.</p>
         
         <p>Cette propriété est ignorée sur les systèmes d’exploitation qui n’utilisent pas de mnémoniques de menu.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:name:get"><apiName>name</apiName><shortdesc>
         Le nom de cette option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Le nom de cette option de menu.  
         
         <p>La valeur de nom n’est pas affichée et peut être utilisée comme identifiant indépendant des paramètres régionaux. Le nom n’est pas affecté automatiquement.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:submenu:get"><apiName>submenu</apiName><shortdesc>
		 Le sous-menu associé à cette option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Le sous-menu associé à cette option de menu.  
		 
		 <p>L’attribution d’un objet NativeMenu à cette propriété change l’aspect et le comportement de l’option de menu. Un élément de sous-menu affiche l’icône du sous-menu et ne déclenche plus d’événements select.</p>
         
        <p><b>Remarque :</b> l’ajout d’un menu comme sous-menu de lui-même (dans une référence circulaire) peut provoquer l’arrêt intempestif d’une application. </p>
        
         </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenu"><apiName>NativeMenu</apiName><shortdesc>
     La classe NativeMenu contient des méthodes et des propriétés permettant de définir des menus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     La classe NativeMenu contient des méthodes et des propriétés permettant de définir des menus.
     
     <p>AIR prend en charge les types de menus suivants :</p>
     <adobetable class="innertable">
     
     
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>Menu</entry><entry>Occurrence</entry><entry>Test de fonctionnalité</entry><entry>Pris en charge sur</entry><entry>Valeur par défaut fournie ?</entry></row></thead><tbody><row><entry>Application</entry><entry><codeph>NativeApplication.nativeApplication.menu</codeph></entry><entry><codeph>NativeApplication.supportsMenu</codeph></entry><entry>Mac OS X</entry><entry>Oui</entry></row><row><entry>Window</entry><entry><codeph>NativeWindow.menu</codeph></entry><entry><codeph>NativeWindow.supportsMenu</codeph></entry><entry>Windows, Linux </entry><entry>Non</entry></row><row><entry>Icône du Dock</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsDockIcon</codeph></entry><entry>Mac OS X</entry><entry>Oui</entry></row><row><entry>Icône de la zone de notification</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry><entry>Windows, Linux </entry><entry>Non</entry></row><row><entry>Contexte</entry><entry><codeph>InteractiveObject.contextMenu</codeph></entry><entry>Toujours pris en charge</entry><entry>Tout</entry><entry>Non</entry></row><row><entry>Menu déroulant</entry><entry>Toute occurrence de NativeMenu</entry><entry>Toujours pris en charge</entry><entry>Tout</entry><entry>Non</entry></row></tbody></tgroup></adobetable>
     
     <p>Un menu peut contenir des options pour des commandes, des sous-menus et des lignes de démarcation. Des options de menu sont ajoutées à un menu à l’aide des méthodes <codeph>addItem()</codeph>, <codeph>addItemAt()</codeph>, <codeph>addSubmenu()</codeph> et <codeph>addSubmenuAt()</codeph>. L’ordre d’affichage des options d’un menu correspond à l’ordre des options dans le tableau <codeph>items</codeph> du menu.</p>
      
     <p>Des sous-menus sont associés à leur menu parent via la propriété <codeph>submenu</codeph> de l’option de menu correspondant dans le menu parent. Le menu racine de fenêtres et de menus d’application doit contenir uniquement des options de sous-menu ; les options sans sous-menus risquent de ne pas s’afficher et sont contraires à l’attente de l’utilisateur pour ces types de menus.</p>
     
     <p>Les menus distribuent des événements <codeph>select</codeph> lorsqu’un de leurs éléments de commande, ou l’un de ses sous-menu, est sélectionné (les éléments de sous-menu et de séparateur ne peuvent pas être sélectionnés). La propriété <codeph>target</codeph> de l’objet événement fait référence à l’élément sélectionné.</p>
     
     <p>Les menus distribuent des événements <codeph>displaying</codeph> juste avant l’affichage du menu. Vous pouvez utiliser cet événement pour mettre à jour le contenu du menu en fonction de l’état actuel de l’application.</p> 
     
     <p platform="actionscript"><b>Remarque </b>: vous pouvez utiliser un objet NativeMenu ou ContextMenu pour définir un menu contextuel. Flash Player prend en charge la classe ContextMenu uniquement, pas la classe NativeMenu.
	 </p>
     
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>flash.display.InteractiveObject.contextMenu</linktext></link><link href="flash.display.xml#NativeMenuItem"><linktext>flash.display.NativeMenuItem</linktext></link><link href="flash.display.xml#NativeWindow/menu"><linktext>flash.display.NativeWindow.menu</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/menu"><linktext>flash.desktop.NativeApplication.menu</linktext></link><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Distribué par cet objet NativeMenu immédiatement avant l’affichage du menu.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Distribué par cet objet NativeMenu immédiatement avant l’affichage du menu. 
     
     <p>Ecoutez cet événement pour mettre à jour le menu avant son affichage. Les événements d’affichage sont distribués également par les options dans un menu.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Distribué par cet objet NativeMenu lorsque l’une de ses options de menu ou un élément dans l’un de ses sous-menus descendants est sélectionné.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Distribué par cet objet NativeMenu lorsque l’une de ses options de menu ou un élément dans l’un de ses sous-menus descendants est sélectionné. 
     
     <p>Un événement select effectue une <i>propagation vers le haut</i> de cette option de menu vers le menu qu’il contient jusqu’à l’objet menu racine en passant par la chaîne de menu parent. La propriété <codeph>target</codeph> de l’objet event fait référence à l’objet NativeMenuItem sélectionné ; la propriété <codeph>currentTarget</codeph> fait référence à cet objet NativeMenu.</p>  
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:NativeMenu:addItem"><apiName>addItem</apiName><shortdesc>
         Ajoute un élément de menu en bas du menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si <codeph>item</codeph> est <codeph>null</codeph>.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si <codeph>item</codeph> est membre d’un autre menu.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Objet NativeMenuItem à ajouter au bas du menu.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Ajoute un élément de menu en bas du menu.
         
         <p platform="actionscript">Lors de la création d’un menu contextuel, vous pouvez ajouter des objets NativeMenuItem ou ContextMenuItem. Nous vous conseillons toutefois de n’utiliser qu’un seul type d’objet dans un menu contextuel afin que tous les éléments du menu possèdent les mêmes propriétés.</p>
         
         <p><b>Remarque :</b> l’ajout d’un élément à un menu peut provoquer l’arrêt intempestif d’une application si le sous-menu de l’élément est défini sur le menu lui-même (ce qui provoque une référence circulaire). </p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addItemAt"><apiName>addItemAt</apiName><shortdesc>
         Insère une option de menu à la position spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si <codeph>item</codeph> est <codeph>null</codeph>.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si <codeph>item</codeph> est membre d’un autre menu.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’index est situé hors des limites du tableau <codeph>items</codeph> du menu.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Objet NativeMenuItem à insérer.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position (basée sur zéro) dans le menu à laquelle l’option de menu doit être insérée.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Insère une option de menu à la position spécifiée.
         
         <p><b>Remarque :</b> l’ajout d’un élément à un menu peut provoquer l’arrêt intempestif d’une application si le sous-menu de l’élément est défini sur le menu lui-même (ce qui provoque une référence circulaire). </p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenu"><apiName>addSubmenu</apiName><shortdesc>
        Ajoute un sous-menu au menu en insérant une nouvelle option de menu.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet NativeMenuItem créé pour le sous-menu. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>Objet NativeMenu définissant le sous-menu à ajouter.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>L’étiquette d’affichage pour l’option de menu à ajouter.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Ajoute un sous-menu au menu en insérant une nouvelle option de menu.
        
        <p>Un appel à la méthode <codeph>addSubMenuAt()</codeph> équivaut à créer une option de menu, en l’ajoutant au menu, et en attribuant un objet NativeMenu à sa propriété <codeph>submenu</codeph>.</p>
        
        <p><b>Remarque :</b> l’ajout d’un menu comme sous-menu de lui-même (dans une référence circulaire) peut provoquer l’arrêt intempestif d’une application. </p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenuAt"><apiName>addSubmenuAt</apiName><shortdesc>
        Ajoute un sous-menu au menu en insérant une nouvelle option de menu à la position spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet NativeMenuItem créé pour le sous-menu. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>Objet NativeMenu définissant le sous-menu à ajouter.
        </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>La position dans le tableau <codeph>items</codeph> de ce menu à laquelle insérer l’option de menu à ajouter.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>L’étiquette d’affichage pour l’option de menu à ajouter.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Ajoute un sous-menu au menu en insérant une nouvelle option de menu à la position spécifiée.
        
        <p>Un appel à la méthode <codeph>addSubMenuAt()</codeph> équivaut à créer une option de menu, en l’insérant à la position souhaitée dans le menu, et en attribuant un objet NativeMenu à sa propriété <codeph>submenu</codeph>.</p>
        
        <p><b>Remarque :</b> l’ajout d’un menu comme sous-menu de lui-même (dans une référence circulaire) peut provoquer l’arrêt intempestif d’une application. </p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:clone"><apiName>clone</apiName><shortdesc>
        
        Crée une copie du menu et de toutes les options.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
        
        Crée une copie du menu et de toutes les options.
        
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:containsItem"><apiName>containsItem</apiName><shortdesc>
         Indique si ce menu contient l’option de menu spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si <codeph>item</codeph> est dans ce menu.
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Objet NativeMenuItem à rechercher.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Indique si ce menu contient l’option de menu spécifiée.
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:display"><apiName>display</apiName><shortdesc>
        Déroule ce menu à l’emplacement spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stage</apiItemName><apiOperationClassifier>flash.display:Stage</apiOperationClassifier><apiDesc>L’objet Stage sur lequel afficher ce menu.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre de pixels horizontaux, par rapport à l’origine de la scène, sur laquelle afficher ce menu.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre de pixels verticaux, par rapport à l’origine de la scène, sur laquelle afficher ce menu.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
        Déroule ce menu à l’emplacement spécifié.
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemAt"><apiName>getItemAt</apiName><shortdesc>
         Obtient l’option de menu à l’index spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si <codeph>index</codeph> est situé hors des limites du tableau <codeph>items</codeph> du menu.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet NativeMenuItem à la position spécifiée dans le menu.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position (basée sur zéro) dans l’option à renvoyer.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Obtient l’option de menu à l’index spécifié.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemByName"><apiName>getItemByName</apiName><shortdesc>
         Obtient l’option de menu avec le nom spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet NativeMenuItem avec le nom spécifié ou <codeph>null</codeph>, si aucune option n’existe dans le menu.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à rechercher.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Obtient l’option de menu avec le nom spécifié.
         
         <p><b>Remarque :</b> la propriété <codeph>name</codeph> des options de menu n’est pas attribuée par défaut.</p>
            
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemIndex"><apiName>getItemIndex</apiName><shortdesc>
         Obtient la position de l’option spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Position (basée sur zéro) de l’élément spécifié dans ce menu ou <codeph>null</codeph>, si l’élément n’est pas dans ce menu.
         
         </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>L’objet NativeMenuItem à rechercher.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Obtient la position de l’option spécifiée. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeAllItems"><apiName>removeAllItems</apiName><shortdesc>
         Supprime tous les éléments du menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
         Supprime tous les éléments du menu.  
         
         
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItem"><apiName>removeItem</apiName><shortdesc>
         Supprime l’élément de menu spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si <codeph>item</codeph> n’est pas dans ce menu
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Objet NativeMenuItem à supprimer de ce menu.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Supprime l’élément de menu spécifié. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItemAt"><apiName>removeItemAt</apiName><shortdesc>
         Supprime et renvoie l’option de menu à l’index spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si <codeph>index</codeph> est situé hors des limites du tableau <codeph>items</codeph> de ce menu.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet NativeMenuItem supprimé.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position (basée sur zéro) de l’élément à supprimer.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Supprime et renvoie l’option de menu à l’index spécifié.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:setItemIndex"><apiName>setItemIndex</apiName><shortdesc>
         Déplace une option de menu vers la position spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si <codeph>index</codeph> est situé hors des limites du tableau <codeph>items</codeph> du menu.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Objet NativeMenuItem à déplacer.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position (basée sur zéro) dans le menu vers lequel déplacer <codeph>item</codeph>.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Déplace une option de menu vers la position spécifiée. Si l’élément n’est pas déjà dans le menu, l’appel de cette méthode ajoute l’élément au menu. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenu:items:get"><apiName>items</apiName><shortdesc>
         Tableau d’objets NativeMenuItem dans ce menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         Tableau d’objets NativeMenuItem dans ce menu.
         
         <p>Le tableau est trié par ordre d’affichage.</p>
         
         <p><i>Remarque :</i> cette propriété est disponible en lecture seule dans AIR 1.0. Elle est disponible en lecture et en écriture dans AIR 1.1.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:numItems:get"><apiName>numItems</apiName><shortdesc>
         Nombre d’objets NativeMenuItem dans ce menu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Nombre d’objets NativeMenuItem dans ce menu.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:parent:get"><apiName>parent</apiName><shortdesc>
         Le menu parent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         Le menu parent.  
         
         <p>Le <codeph>parent</codeph> de l’objet menu racine (niveau supérieur) est <codeph> null</codeph>.</p>
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
La classe DisplayObjectContainer est la classe de base de tous les objets susceptibles de servir de conteneurs d’objet d’affichage dans la liste d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Classe de base abstraite de tous les objets d’affichage pouvant contenir des objets enfant.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe DisplayObjectContainer est la classe de base de tous les objets susceptibles de servir de conteneurs d’objet d’affichage dans la liste d’affichage. Celle-ci gère tous les objets affichés dans Flash Player ou Adobe AIR. La classe DisplayObjectContainer permet d’organiser les objets d’affichage dans la liste d’affichage. Chaque objet DisplayObjectContainer possède sa propre liste d’enfants, qui organise l’ordre Z des objets. L’ordre z correspond à l’ordre d’empilement du premier plan vers l’arrière-plan qui détermine l’objet dessiné au premier plan, l’objet dessiné derrière lui, etc. 
 
 <p>DisplayObject est une classe de base abstraite. De ce fait, il est impossible de l’appeler directement. Appeler <codeph>new DisplayObject()</codeph> renvoie une exception <codeph>ArgumentError</codeph>.</p>
 
 La classe DisplayObjectContainer est une classe de base abstraite destinée à tous les objets pouvant contenir des objets enfant. Il est impossible de l’instancier directement. Appeler le constructeur <codeph>new DisplayObjectContainer()</codeph> renvoie une exception <codeph>ArgumentError</codeph>.
 
 <p>Pour plus d’informations, voir le chapitre « Programmation de l’affichage » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
 
 </apiDesc><example conref="examples\DisplayObjectContainerExample.as"> L’exemple suivant exploite la classe <codeph>DisplayObjectContainerExample</codeph> pour créer cinq carrés orange les uns à la suite des autres. Pour ce faire, procédez comme suit :
 
 <ol>
     <li>Le constructeur appelle la méthode <codeph>configureAssets()</codeph>.</li>
 
  <li>La méthode <codeph>configureAssets()</codeph> crée des objets Sprite <codeph>child</codeph> et <codeph>lastChild</codeph>.</li>
 
    <li>Une boucle <codeph>for</codeph> crée les cinq carrés orange et les place les uns à la suite des autres.</li>
 
     <li>Lorsqu’un objet CustomSprite est créé, son constructeur appelle la méthode <codeph>draw()</codeph> de l’objet <codeph>CustomSprite</codeph>, qui crée un carré de 50 x 50 pixels en appelant les méthodes <codeph>beginFill()</codeph>, <codeph>drawRect()</codeph> et <codeph>endFill()</codeph> de la classe Graphics. La méthode <codeph>addChild()</codeph> place les carrés ainsi créé dans la liste d’affichage.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class DisplayObjectContainerExample extends Sprite {
        private var gutter:uint     = 5;
        private var childCount:uint = 5;

        public function DisplayObjectContainerExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var child:Sprite = new CustomSprite();
            var lastChild:Sprite = child;
            for (var i:uint = 1; i &lt;= childCount; i++) {
                child = new CustomSprite();
                child.x = lastChild.x + lastChild.width + gutter;
                addChild(child);
                lastChild = child;
            }
        }
    }
}

import flash.display.Sprite;

class CustomSprite extends Sprite {
    private var size:uint = 50;
    private var bgColor:uint = 0xFFCC00;

    public function CustomSprite() {
        draw(size, size);
    }

    private function draw(w:uint, h:uint):void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:DisplayObjectContainer:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
	L’appel du constructeur DisplayObjectContainer() renvoie une exception ArgumentError.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	L’appel du constructeur <codeph>new DisplayObjectContainer()</codeph> renvoie une exception <codeph>ArgumentError</codeph>. Vous <i>pouvez</i> cependant appeler des constructeurs pour les sous-classes suivantes de DisplayObjectContainer :
	
	<ul>
	
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
 	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:DisplayObjectContainer:addChild"><apiName>addChild</apiName><shortdesc>
     Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoie une exception si l’enfant et le parent sont identiques. Renvoie également une exception si l’appelant est un enfant (ou petit-enfant, etc.) de l’enfant qui est en cours d’ajout.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Occurrence DisplayObject que vous transmettez au paramètre <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence DisplayObject à ajouter en tant qu’enfant à cette occurrence DisplayObjectContainer.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Ajoute un objet enfant à cette occurrence de DisplayObjectContainer.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer. L’enfant est ajouté devant (par-dessus) tous les autres enfants dans cette occurrence de DisplayObjectContainer (pour ajouter un enfant à une position d’index spécifique, utilisez la méthode <codeph>addChildAt()</codeph>).
     
	 <p>Si vous ajoutez un objet enfant qui est déjà doté d’un autre conteneur d’objet d’affichage en tant que parent, il est supprimé de la liste d’enfants de cet autre conteneur d’objet d’affichage. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> L’exemple suivant définit deux objets Sprite appelés <codeph>container1</codeph> et <codeph>container2</codeph>. Un Sprite est un type de conteneur d’objet d’affichage. L’exemple appelle la méthode <codeph>addChild()</codeph> pour configurer la hiérarchie d’affichage : <codeph>container1</codeph> est un enfant de <codeph>container2</codeph>, tandis que deux autres objets d’affichage, <codeph>circle1</codeph> et <codeph>circle2</codeph>, sont des enfants de <codeph>container1</codeph>. Les appels à la méthode <codeph>trace()</codeph> affichent le nombre d’enfants de chaque objet. Tenez compte du fait que les petits-enfants ne sont pas inclus dans le décompte de <codeph>numChildren</codeph> :
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChild_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un objet d’affichage est ajouté à la liste d’affichage.
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un objet d’affichage est ajouté à la liste d’affichage.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoie une exception si la position d’index n’existe pas dans la liste d’enfants.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Renvoie une exception si l’enfant et le parent sont identiques. Renvoie également une exception si l’appelant est un enfant (ou petit-enfant, etc.) de l’enfant qui est en cours d’ajout.
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Occurrence DisplayObject que vous transmettez au paramètre <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence DisplayObject à ajouter en tant qu’enfant à cette occurrence DisplayObjectContainer.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index à laquelle l’enfant est ajouté. Si vous spécifiez une position d’index actuellement occupée, l’objet enfant associé à cette position et toutes les positions supérieures sont décalés d’une position vers le haut dans la liste d’enfants. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Ajoute un objet enfant à cette occurrence de DisplayObjectContainer.
     
  	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer. L’enfant est placé à la position d’index spécifiée. La position d’index 0 représente la fin (le bas) de la liste d’affichage pour cet objet DisplayObjectContainer.
	 
	 <p>Ainsi, l’exemple suivant illustre trois objets d’affichage appelés a, b et c, qui occupent respectivement les positions d’index 0, 2 et 1 :</p>
	 
	 <p><adobeimage alt="b sur c sur a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>Si vous ajoutez un objet enfant qui est déjà doté d’un autre conteneur d’objet d’affichage en tant que parent, il est supprimé de la liste d’enfants de cet autre conteneur d’objet d’affichage. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.addChildAt.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage, <codeph>container</codeph>, et ajoute un objet d’affichage <codeph>circle1</codeph> à sa liste d’affichage. Ensuite, en appelant <codeph>container.addChildAt(circle2, 0)</codeph>, il ajoute l’objet <codeph>circle2</codeph> à la position d’index zéro (arrière) et déplace l’objet <codeph>circle1</codeph> vers la position d’index 1 :
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
var circle2:Sprite = new Sprite();

container.addChild(circle1);
container.addChildAt(circle2, 0);

trace(container.getChildAt(0) == circle2); // true
trace(container.getChildAt(1) == circle1); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>addChild()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChildAt_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un objet d’affichage est ajouté à la liste d’affichage.
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un objet d’affichage est ajouté à la liste d’affichage.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:areInaccessibleObjectsUnderPoint"><apiName>areInaccessibleObjectsUnderPoint</apiName><shortdesc>
	 Indique si les restrictions de sécurité entraîneraient l’omission des objets d’affichage de la liste renvoyée en appelant la méthode DisplayObjectContainer.getObjectsUnderPoint() avec le point « point » spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si le point contient des objets d’affichage enfant associés à des restrictions de sécurité.
	 
 	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le point sous lequel sont extraits les objets.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique si les restrictions de sécurité entraîneraient l’omission des objets d’affichage de la liste renvoyée en appelant la méthode <codeph>DisplayObjectContainer.getObjectsUnderPoint()</codeph> avec le point <codeph>point</codeph> spécifié. Par défaut, le contenu d’un domaine ne peut pas accéder aux objets d’un autre domaine, à moins d’y être autorisé par un appel de la méthode <codeph>Security.allowDomain()</codeph>. 
	 
	 <p>Pour plus d’informations, voir les références suivantes : </p>
	 
     <ul>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>     
     
	 <p>Le paramètre <codeph>point</codeph> est exprimé dans l’espace de coordonnées de la scène, qui risque d’être différent de l’espace de coordonnées du conteneur d’objet d’affichage (à moins que ce dernier ne corresponde à la scène). Vous pouvez utiliser les méthodes <codeph>globalToLocal()</codeph> et <codeph>localToGlobal()</codeph> pour passer d’un espace de coordonnées à l’autre.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.areInaccessibleObjectsUnderPoint.as"> Le code suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>. Le bloc de code suivant a recours à un objet Loader pour charger un fichier JPEG appelé « test.jpg » à partir d’un serveur de fichiers distant. Tenez compte du fait que la propriété <codeph>checkPolicyFile</codeph> de l’objet LoaderContext utilisé en tant que paramètre dans la méthode <codeph>load()</codeph> est défini sur <codeph>false</codeph>. Une fois le fichier chargé, le code appelle la méthode <codeph>loaded()</codeph>, qui en retour appelle <codeph>container.areInaccessibleObjectsUnderPoint()</codeph>, qui renvoie la valeur <codeph>true</codeph> car le contenu chargé est considéré comme provenant d’un domaine inaccessible :
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.system.LoaderContext;
import flash.net.URLRequest;
import flash.events.Event;
import flash.geom.Point;

var container:Sprite = new Sprite();

var urlReq:URLRequest = new URLRequest("http://localhost/RemoteFile.swf");
var ldr:Loader = new Loader();
var context:LoaderContext = new LoaderContext();
context.checkPolicyFile = false;
ldr.load(urlReq, context);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);

function loaded(event:Event):void {
    var pt:Point = new Point(1, 1);
    trace(container.areInaccessibleObjectsUnderPoint(pt)); // true
}

function urlNotFound(event:Event):void {
    trace("The URL was not found."); 
}
</codeblock> Cet exemple suppose que le fichier SWF produit par ce code est chargé à partir d’un domaine différent de celui du fichier JPEG, et que le fichier JPEG chargé occupe le point (1, 1). 
</example></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getObjectsUnderPoint()"><linktext>getObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:contains"><apiName>contains</apiName><shortdesc>
	 Détermine si l’objet d’affichage spécifié est un enfant de l’occurrence de DisplayObjectContainer ou l’occurrence en tant que telle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’objet <codeph>child</codeph> est un enfant de l’occurrence de DisplayObjectContainer ou le conteneur en tant que tel, <codeph>false</codeph> dans tous les autres cas.
	 
	  
	  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>L’objet enfant à tester.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Détermine si l’objet d’affichage spécifié est un enfant de l’occurrence de DisplayObjectContainer ou l’occurrence en tant que telle. La recherche comprend la liste d’affichage entière, y compris cette occurrence de DisplayObjectContainer. Les petits-enfants, les arrière-petits-enfants, et ainsi de suite renvoient chacun la valeur <codeph>true</codeph>.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.contains.1.as"> L’exemple suivant définit plusieurs objets Sprite et en ajoute une partie à la liste d’enfants des autres (un objet Sprite est un type de conteneur d’objet d’affichage). La relation entre les différents objets s’affiche en appelant la méthode <codeph>contains()</codeph> :
<codeblock>
import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();
var sprite4:Sprite = new Sprite();

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite1.contains(sprite1)); // true
trace(sprite1.contains(sprite2)); // true
trace(sprite1.contains(sprite3)); // true
trace(sprite1.contains(sprite4)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildAt"><apiName>getChildAt</apiName><shortdesc>
     Renvoie l’occurrence enfant de l’objet d’affichage associée à l’index spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoie une exception si l’index n’existe pas dans la liste d’enfants.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Cet objet d’affichage enfant appartient à un sandbox auquel vous n’avez pas accès. Pour éviter ce cas de figure, faites en sorte que l’animation enfant appelle la méthode <codeph>Security.allowDomain()</codeph>.
     
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>L’objet d’affichage enfant qui occupe la position d’index spécifiée.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index de l’objet enfant.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie l’occurrence enfant de l’objet d’affichage associée à l’index spécifié.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildAt.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute trois objets d’affichage enfant à la liste d’enfants de l’objet <codeph>container</codeph>. Les appels à la méthode <codeph>getChildAt()</codeph> révèlent ensuite les positions des objets enfant :
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();

container.addChild(sprite1);
container.addChild(sprite2);
container.addChildAt(sprite3, 0);

trace(container.getChildAt(0) == sprite3); // true
trace(container.getChildAt(1) == sprite1); // true
trace(container.getChildAt(2) == sprite2); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildByName()"><linktext>getChildByName()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildByName"><apiName>getChildByName</apiName><shortdesc>
     Renvoie l’objet d’affichage enfant portant le nom spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Cet objet d’affichage enfant appartient à un sandbox auquel vous n’avez pas accès. Pour éviter ce cas de figure, faites en sorte que l’animation enfant appelle la méthode <codeph>Security.allowDomain()</codeph>.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet d’affichage enfant portant le nom spécifié.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’enfant à renvoyer.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie l’objet d’affichage enfant portant le nom spécifié. Si plusieurs objets d’affichage enfant portent le nom spécifié, la méthode renvoie le premier objet de la liste d’enfants.
     
	 <p>La méthode <codeph>getChildAt()</codeph> est plus rapide que la méthode <codeph>getChildByName()</codeph>. La méthode <codeph>getChildAt()</codeph> accède à un enfant à partir d’un tableau en mémoire cache, tandis que la méthode <codeph>getChildByName()</codeph> doit parcourir une liste liée pour accéder à l’enfant.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute deux objets d’affichage enfant au conteneur. Ensuite, le code appelle les méthodes <codeph>getChildByName()</codeph> et <codeph>getChildIndex()</codeph> pour renvoyer la position d’index de l’enfant de l’objet <codeph>container</codeph> avec le paramètre <codeph>name "sprite1"</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildAt()"><linktext>getChildAt()</linktext></link><link href="flash.display.xml#DisplayObject/name"><linktext>flash.display.DisplayObject.name</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildIndex"><apiName>getChildIndex</apiName><shortdesc>
     Renvoie la position d’index d’une occurrence enfant de DisplayObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoie une exception si le paramètre enfant n’est pas un enfant de cet objet.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Position d’index de l’objet d’affichage enfant à identifier.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence de DisplayObject à identifier.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie le numéro d’index d’une occurrence enfant de DisplayObject.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Renvoie la position d’index d’une occurrence <codeph>child</codeph> de DisplayObject.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute deux objets d’affichage enfant au conteneur. Ensuite, le code appelle les méthodes <codeph>getChildByName()</codeph> et <codeph>getChildIndex()</codeph> pour renvoyer la position d’index de l’enfant de l’objet <codeph>container</codeph> avec le paramètre <codeph>name "sprite1"</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getObjectsUnderPoint"><apiName>getObjectsUnderPoint</apiName><shortdesc>
     Renvoie un tableau d’objets de niveau inférieur au point spécifié et qui sont les enfants (ou les petits-enfants, etc.) de l’occurrence de DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Tableau d’objets de niveau inférieur au point spécifié et qui sont les enfants (ou les petits-enfants, etc.) de cette occurrence de DisplayObjectContainer.
     
 	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le point sous lequel sont extraits les objets.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie un tableau d’objets de niveau inférieur au point spécifié et qui sont les enfants (ou les petits-enfants, etc.) de l’occurrence de DisplayObjectContainer. Tout objet enfant auquel il est impossible d’accéder pour des raisons de sécurité est omis du tableau renvoyé. Pour vérifier si cette restriction de sécurité affecte le tableau renvoyé, appelez la méthode <codeph>areInaccessibleObjectsUnderPoint()</codeph>.
	 
	 <p>Le paramètre <codeph>point</codeph> est exprimé dans l’espace de coordonnées de la scène, qui risque d’être différent de l’espace de coordonnées du conteneur d’objet d’affichage (à moins que ce dernier ne corresponde à la scène). Vous pouvez utiliser les méthodes <codeph>globalToLocal()</codeph> et <codeph>localToGlobal()</codeph> pour passer d’un espace de coordonnées à l’autre.</p>
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getObjectsUnderPoint.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute deux objets d’affichage enfant qui se chevauchent au conteneur. Ensuite le code appelle deux fois <codeph>getObjectsUnderPoint()</codeph>. Une première fois avec un point qui ne touche qu’un seul objet, puis à l’aide d’un point où les objets se chevauchent. Enfin, le paramètre <codeph>length</codeph> du tableau renvoyé affiche le nombre d’objets de tous les points du conteneur :
<codeblock>
import flash.display.Sprite;
import flash.geom.Point;

var container:Sprite = new Sprite();

var square1:Sprite = new Sprite();
square1.graphics.beginFill(0xFFCC00);
square1.graphics.drawRect(0, 0, 40, 40);

var square2:Sprite = new Sprite();
square2.graphics.beginFill(0x00CCFF);
square2.graphics.drawRect(20, 0, 30, 40);

container.addChild(square1);
container.addChild(square2);

var pt:Point = new Point(10, 20);
var objects:Array = container.getObjectsUnderPoint(pt); 
trace(objects.length); // 1

pt = new Point(35, 20);
objects = container.getObjectsUnderPoint(pt);
trace(objects.length);  // 2
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/areInaccessibleObjectsUnderPoint()"><linktext>areInaccessibleObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChild"><apiName>removeChild</apiName><shortdesc>
	 Supprime l’occurrence enfant de DisplayObject spécifiée de la liste d’enfants de l’occurrence de DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoie une exception si le paramètre enfant n’est pas un enfant de cet objet.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Occurrence DisplayObject que vous transmettez au paramètre <codeph>child</codeph>.
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence de DisplayObject à supprimer.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Supprime un objet d’affichage enfant de l’occurrence de DisplayObjectContainer.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Supprime l’occurrence <codeph>child</codeph> de DisplayObject spécifiée de la liste d’enfants de l’occurrence de DisplayObjectContainer. La propriété <codeph>parent</codeph> de l’enfant supprimé est réglée sur <codeph>null</codeph> et l’objet est nettoyé s’il n’existe aucune autre référence à l’enfant. Les positions d’index de tout objet d’affichage placé au-dessus de l’enfant dans DisplayObjectContainer sont diminuées d’une unité.
	 
	 <p>Le processus de nettoyage de la mémoire réaffecte l’espace mémoire non utilisé. Lorsqu’une variable ou un objet n’est plus référencé ou stocké de façon active, le nettoyeur de mémoire vide toutes ses références en mémoire qui ne sont plus utilisées.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChild.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute deux objets d’affichage enfant au conteneur. Un écouteur d’événement est ajouté à l’objet <codeph>container</codeph>, de façon à ce que lorsque l’utilisateur clique sur une objet enfant du conteneur, la méthode <codeph>removeChild()</codeph> l’enfant sur lequel l’utilisateur a cliqué dans la liste d’enfants du conteneur :
<codeblock>
 
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);

container.addChild(circle1);
container.addChild(circle2);

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    container.removeChild(DisplayObject(event.target)); 
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 Supprime une occurrence enfant de DisplayObject de la position d’index spécifiée dans la liste d’enfants de DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Cet objet d’affichage enfant appartient à un sandbox auquel l’objet appelant n’a pas accès. Pour éviter ce cas de figure, faites en sorte que l’animation enfant appelle la méthode <codeph>Security.allowDomain()</codeph>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Renvoie une exception si l’index n’existe pas dans la liste d’enfants.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Occurrence de DisplayObject supprimée.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Index enfant de l’objet DisplayObject à supprimer.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>[Supprime un objet d’affichage enfant, à la position d’<codeph>index</codeph> spécifiée, à partir de l’occurrence DisplayObjectContainer.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Supprime une occurrence enfant de DisplayObject de la position d’<codeph>index</codeph> spécifiée dans la liste d’enfants de DisplayObjectContainer. La propriété <codeph>parent</codeph> de l’enfant supprimé est réglée sur <codeph>null</codeph> et l’objet est nettoyé s’il n’existe aucune autre référence à l’enfant. Les positions d’index de tout objet d’affichage placé au-dessus de l’enfant dans DisplayObjectContainer sont diminuées d’une unité.
	 
	 <p>Le processus de nettoyage de la mémoire réaffecte l’espace mémoire non utilisé. Lorsqu’une variable ou un objet n’est plus référencé ou stocké de façon active, le nettoyeur de mémoire vide toutes ses références en mémoire qui ne sont plus utilisées.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChildAt.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute deux objets d’affichage enfant au conteneur. Vous pouvez ensuite constater que lorsque le code appelle la méthode <codeph>removeChildAt()</codeph> pour supprimer l’enfant à la position d’index la plus basse (0), tout autre objet enfant descend d’un niveau dans la liste :
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.numChildren) // 2
container.removeChildAt(0); 
trace(container.numChildren) // 1
trace(container.getChildAt(0).name); // sprite2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	Modifie la position d’un enfant existant dans le conteneur d’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoie une exception si l’index n’existe pas dans la liste d’enfants.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Renvoie une exception si le paramètre enfant n’est pas un enfant de cet objet.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence enfant de DisplayObject dont vous voulez modifier le numéro d’index.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Nouveau numéro d’index de l’objet d’affichage <codeph>child</codeph>.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Modifie le numéro d’index d’un enfant existant.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Modifie la position d’un enfant existant dans le conteneur d’objet d’affichage. L’ordre des objets enfant est alors affecté. Ainsi, l’exemple suivant illustre trois objets d’affichage appelés a, b et c, qui occupent respectivement les positions d’index 0, 1 et 2 :
	
	<p><adobeimage alt="c sur b sur a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>Lorsque vous utilisez la méthode <codeph>setChildIndex()</codeph> et spécifiez une position d’index déjà occupée, les seules positions qui changent sont celles situées entre l’ancienne et la nouvelle position de l’objet d’affichage. Toutes les autres positions restent identiques. Si un enfant est déplacé sur un index INFERIEUR à son index actuel, tous les enfants situés entre les deux sont AUGMENTES de 1 pour leur référence d’index. Si un enfant est déplacé sur un index SUPERIEUR à son index actuel, tous les enfants situés entre les deux sont DIMINUES de 1 pour leur référence d’index. Par exemple, si le conteneur d’objet d’affichage de l’exemple précédent s’appelle <codeph>container</codeph>, vous pouvez permuter la position des objets d’affichage a et b en appelant le code suivant :</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>Ce code entraîne la réorganisation suivante des objets :</p>
	
    <p><adobeimage alt="c sur a sur b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc><example conref="examples\DisplayObjectContainer.setChildIndex.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute trois objets d’affichage enfant, qui se chevauchent légèrement, au conteneur. Lorsque l’utilisateur clique sur l’un de ces objets, la méthode <codeph>clicked()</codeph> appelle la méthode <codeph>setChildIndex()</codeph> pour déplacer l’objet cliqué vers la position la plus haute de la liste enfant de l’objet <codeph>container</codeph> :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.addEventListener(MouseEvent.CLICK, clicked);
 
var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(100, 40, 40);
circle2.addEventListener(MouseEvent.CLICK, clicked);
 
var circle3:Sprite = new Sprite();
circle3.graphics.beginFill(0x0000FF);
circle3.graphics.drawCircle(70, 80, 40);
circle3.addEventListener(MouseEvent.CLICK, clicked);
 
container.addChild(circle1);
container.addChild(circle2);
container.addChild(circle3);
addChild(container);
 
function clicked(event:MouseEvent):void {
    var circle:Sprite = Sprite(event.target);
    var topPosition:uint = container.numChildren - 1;
    container.setChildIndex(circle, topPosition);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getChildIndex()"><linktext>getChildIndex()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildren"><apiName>swapChildren</apiName><shortdesc>
	 Intervertit l’ordre z (ordre d’empilement du premier plan vers l’arrière-plan) des deux objets enfant spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoie une exception si l’un des deux paramètres enfant n’est pas un enfant de cet objet.
	 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Premier objet enfant.
	 
     </apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Second objet enfant.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Intervertit l’ordre z (ordre d’empilement du premier plan vers l’arrière-plan) des deux objets enfant spécifiés. Tous les autres objets enfant du conteneur d’objet d’affichage conservent leur position d’index.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildren.1.as"> L’exemple suivant crée un conteneur d’objets d’affichage appelé <codeph>container</codeph>, puis ajoute deux objets d’affichage enfant au conteneur et enfin, indique l’effet d’un appel à la méthode <codeph>swapChildren()</codeph> :
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2

container.swapChildren(sprite1, sprite2);

trace(container.getChildAt(0).name); // sprite2
trace(container.getChildAt(1).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 Intervertit l’ordre z (ordre d’empilement du premier plan vers l’arrière-plan) des objets enfant aux deux positions d’index spécifiées dans la liste d’enfants.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si l’un ou l’autre des index n’existe pas dans la liste d’enfants.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index du premier objet enfant.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index du second objet enfant.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Intervertit l’ordre z (ordre d’empilement du premier plan vers l’arrière-plan) des objets enfant aux deux positions d’index spécifiées dans la liste d’enfants. Tous les autres objets enfant du conteneur d’objet d’affichage conservent leur position d’index.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildrenAt.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage appelé <codeph>container</codeph>, puis ajoute trois objets d’affichage enfant au conteneur et enfin indique comment un appel à la méthode <codeph>swapChildrenAt()</codeph> modifie l’ordre de la liste d’enfants du conteneur de l’objet d’affichage :
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

container.addChild(sprite1);
container.addChild(sprite2);
container.addChild(sprite3);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite3

container.swapChildrenAt(0, 2);

trace(container.getChildAt(0).name); // sprite3
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:DisplayObjectContainer:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 Détermine si les enfants de l’objet prennent ou non en charge la souris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Détermine si les enfants de l’objet prennent ou non en charge la souris. Si tel est le cas, un utilisateur peut le manipuler à l’aide de la souris. La valeur par défaut est <codeph>true</codeph>.
	 
	 <p>Cette propriété s’avère utile lorsque vous créez un bouton avec une occurrence de la classe Sprite (au lieu d’utiliser la classe SimpleButton). Si vous utilisez une occurrence de Sprite pour créer un bouton, vous pouvez le décorer à l’aide de la méthode <codeph>addChild()</codeph> pour ajouter d’autres occurrences de Sprite. Ce processus risque d’associer un comportement imprévu aux événements de souris, car les occurrences de Sprite ajoutées en tant qu’enfants peuvent devenir l’objet cible d’un événement de souris alors que vous vous attendiez à ce que ce dernier corresponde à l’occurrence parent. Pour vous assurer que l’occurrence parent serve d’objet cible pour les événements de souris, vous pouvez régler la propriété <codeph>mouseChildren</codeph> de l’occurrence parent sur <codeph>false</codeph>.</p>
	 <p> Définir cette propriété ne distribue aucun événement. La méthode <codeph>addEventListener()</codeph> vous permet de créer une fonctionnalité interactive.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.mouseChildren.1.as"> L’exemple suivant définit un objet Sprite (un type de conteneur d’objet d’affichage) appelé <codeph>container</codeph> et indique que lorsque vous définissez sa propriété <codeph>mouseChildren</codeph> sur <codeph>false</codeph>, la cible de l’événement<codeph>mouseClick</codeph> devient l’objet <codeph>container</codeph> et non pas l’un de ses objets enfant :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
container.name = "container";
addChild(container);

var circle:Sprite = new Sprite();
circle.name = "circle";
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);

container.addChild(circle);

container.mouseChildren = false;

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace(event.target.name); // container
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>flash.display.Sprite.buttonMode</linktext></link><link href="flash.events.xml#EventDispatcher/addEventListener()"><linktext>flash.events.EventDispatcher.addEventListener()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObjectContainer:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 Renvoie le nombre d’enfants de l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Renvoie le nombre d’enfants de l’objet.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> L’exemple suivant définit deux objets Sprite appelés <codeph>container1</codeph> et <codeph>container2</codeph>. Un Sprite est un type de conteneur d’objet d’affichage. L’exemple appelle la méthode <codeph>addChild()</codeph> pour configurer la hiérarchie d’affichage : <codeph>container1</codeph> est un enfant de <codeph>container2</codeph>, tandis que deux autres objets d’affichage, <codeph>circle1</codeph> et <codeph>circle2</codeph>, sont des enfants de <codeph>container1</codeph>. Les appels à la méthode <codeph>trace()</codeph> affichent le nombre d’enfants de chaque objet. Tenez compte du fait que les petits-enfants ne sont pas inclus dans le décompte de <codeph>numChildren</codeph> :
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 Détermine si les enfants de l’objet prennent ou non en charge la tabulation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Le fait d’appeler cette propriété à partir de l’objet Stage renvoie une exception, car il ne met pas en œuvre cette propriété.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Détermine si les enfants de l’objet prennent ou non en charge la tabulation. Active ou désactive la sélection des enfants de l’objet avec la touche de tabulation. La valeur par défaut est <codeph>true</codeph>.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.tabChildren.1.as"> L’exemple suivant crée un conteneur d’objet d’affichage, <codeph>container1</codeph>, et ajoute deux objets d’affichage <codeph>circle1</codeph> et <codeph>circle2</codeph> à sa liste d’affichage. Cet exemple définit tabChildren sur <codeph>false</codeph> pour les enfants de façon à pouvoir gérer son propre ordre de tabulation à l’aide de la propriété <codeph>tabIndex</codeph> :
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();
container.tabChildren = false;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.tabIndex = 1;

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);
circle2.tabIndex = 0;

container.addChild(circle1);
container.addChild(circle2);
</codeblock> Pour afficher les résultats de cet exemple, compilez et exécutez le fichier. Lorsque vous cliquez sur l’un de ces cercles, vous pouvez appuyer sur la touche de tabulation pour déplacer le focus vers un autre objet d’affichage (indiqué par un rectangle jaune de sélection).
</example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
     Renvoie un objet TextSnapshot pour l’occurrence de DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie un objet TextSnapshot pour l’occurrence de DisplayObjectContainer.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.textSnapshot.1.as"> L’exemple suivant fonctionne uniquement dans l’environnement de programmation Flash. Flex ne permet pas d’ajouter du texte statique à un fichier. Pour préparer le fichier Flash dans cet exemple, ajoutez un ou plusieurs champs texte statiques dans la première image d’un clip. Ensuite, insérez le script suivant dans la première image et exécutez le fichier. Ceci renvoie le texte statique que vous avez ajouté :
<codeblock>
trace(this.textSnapshot.getText(0, this.textSnapshot.charCount));
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot"><linktext>flash.text.TextSnapshot</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
 Définit un remplissage dégradé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit un remplissage dégradé. 
 
 <p>
 Utilisez l’objet GraphicsGradientFill avec la méthode <codeph>Graphics.drawGraphicsData()</codeph>. Dessiner un objet GraphicsGradientFill revient à appeler la méthode <codeph>Graphics.beginGradientFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsGradientFill:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
     Crée un nouvel objet GraphicsGradientFill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>linear</apiData><apiDesc>Valeur de la classe GradientType qui spécifie le type de dégradé à utiliser : <codeph>GradientType.LINEAR</codeph> ou <codeph>GradientType.RADIAL</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de valeurs de couleurs RVB hexadécimales utilisé pour le dégradé (par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.). Vous pouvez définir jusqu’à 15 couleurs. Pour chaque couleur, définissez une valeur correspondante dans les paramètres alphas et ratios.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de valeurs alpha pour les couleurs correspondantes du tableau de couleurs ; les valeurs disponibles sont comprises entre 0 et 1. Si la valeur est inférieure à 0, 0 est utilisé. Si la valeur est supérieure à 1, 1 est utilisé.
     
     </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de taux de distribution des couleurs ; les valeurs disponibles sont comprises entre 0 et 255. Cette valeur définit le pourcentage de la largeur où la couleur est échantillonnée sur 100 %. La valeur 0 représente la position de gauche dans la zone de dégradés, tandis que 255 représente la position de droite. 
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Matrice de transformation définie par la classe flash.geom.Matrix. La classe flash.geom.Matrix inclut une méthode <codeph>createGradientBox()</codeph>, qui permet de configurer facilement la matrice en vue de son utilisation avec la méthode <codeph>beginGradientFill()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>pad</apiData><apiDesc>Valeur de la classe SpreadMethod qui spécifie la méthode d’étalement à utiliser : <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> ou <codeph>SpreadMethod.REPEAT</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiType value=""/><apiData>rgb</apiData><apiDesc>Valeur de la classe InterpolationMethod qui spécifie la valeur à utiliser : <codeph>InterpolationMethod.LINEAR_RGB</codeph> ou <codeph>InterpolationMethod.RGB</codeph>
     
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiType value=""/><apiData>0.0</apiData><apiDesc>Nombre qui contrôle l’emplacement du point focal du dégradé. Une valeur de 0 permet de définir le point focal au centre. Une valeur de 1 permet de définir le point focal sur l’un des bords du cercle du dégradé. Une valeur de -1 permet de définir le point focal sur l’autre bord du cercle du dégradé. Toute valeur inférieure à -1 ou supérieure à 1 est respectivement arrondie à -1 ou 1.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un nouvel objet GraphicsGradientFill.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsGradientFill:alphas"><apiName>alphas</apiName><shortdesc>
     Tableau de valeurs alpha pour les couleurs correspondantes du tableau de couleurs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau de valeurs alpha pour les couleurs correspondantes du tableau de couleurs. Les valeurs disponibles sont comprises entre 0 et 1. Si la valeur est inférieure à 0, 0 est utilisé. Si la valeur est supérieure à 1, 1 est utilisé.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:colors"><apiName>colors</apiName><shortdesc>
     Tableau de valeurs hexadécimales de couleur RVB à utiliser pour le dégradé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau de valeurs hexadécimales de couleur RVB à utiliser pour le dégradé. Par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc. Vous pouvez définir jusqu’à 15 couleurs. Pour chaque couleur, définissez une valeur correspondante dans les propriétés alphas et ratios.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:focalPointRatio"><apiName>focalPointRatio</apiName><shortdesc>
     Nombre qui contrôle l’emplacement du point focal du dégradé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Nombre qui contrôle l’emplacement du point focal du dégradé. Une valeur de 0 permet de définir le point focal au centre. Une valeur de 1 signifie que le point focal se trouve sur l’un des bords du cercle du dégradé. Une valeur de -1 permet de définir le point focal sur l’autre bord du cercle du dégradé. Toute valeur inférieure à -1 ou supérieure à 1 est respectivement arrondie à -1 ou 1. L’exemple suivant affiche un paramètre <codeph>focalPointRatio</codeph> défini sur 0,75 :
     
     <p><adobeimage alt="dégradé linéaire avec le paramètre focalPointRatio défini sur 0,75" href="../../images/radial_sketch.jpg"/> </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:matrix"><apiName>matrix</apiName><shortdesc>
     Matrice de transformation définie par la classe Matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Matrice de transformation définie par la classe Matrix. La classe flash.geom.Matrix inclut une méthode <codeph>createGradientBox()</codeph>, qui permet de configurer la matrice en vue de l’utiliser avec la méthode <codeph>beginGradientFill()</codeph>.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:ratios"><apiName>ratios</apiName><shortdesc>
     Tableau des taux de répartition des couleurs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau des taux de répartition des couleurs. Les valeurs disponibles sont comprises entre 0 et 255. Cette valeur définit le pourcentage de la largeur où la couleur est échantillonnée sur 100 %. La valeur 0 représente la position de gauche dans la zone de dégradés, tandis que la valeur 255 représente la position de droite. 
     
     <p><b>Remarque :</b> cette valeur représente les positions de la zone de dégradés, plutôt que l’espace de coordonnées du dégradé final, susceptible d’être plus large ou plus étroit que la zone de dégradés. Spécifiez une valeur correspondante pour chaque valeur dans la propriété <codeph>colors</codeph>. </p>
     
     <p>Par exemple, pour un dégradé linéaire qui comprend deux couleurs (bleu et vert), l’exemple suivant illustre l’emplacement des couleurs dans le dégradé selon les différentes valeurs du tableau <codeph>ratios</codeph> :</p>
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Dégradé</entry></row></thead><tbody><row>
     
      <entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 0 et 127" href="../../images/gradient-ratios-1.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 0 et 255" href="../../images/gradient-ratios-2.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 127 et 255" href="../../images/gradient-ratios-3.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     <p>Les valeurs du tableau doivent augmenter de manière séquentielle ; par exemple, <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:interpolationMethod:get"><apiName>interpolationMethod</apiName><shortdesc>
     Valeur de la classe InterpolationMethod qui spécifie la valeur à utiliser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur de la classe InterpolationMethod qui spécifie la valeur à utiliser. Les valeurs disponibles sont les suivantes : <codeph>InterpolationMethod.LINEAR_RGB</codeph> et <codeph>InterpolationMethod.RGB</codeph>
     
     <p>L’exemple suivant montre un dégradé linéaire simple entre deux couleurs (le paramètre <codeph>spreadMethod</codeph> étant défini sur <codeph>SpreadMethod.REFLECT</codeph>). Les différentes méthodes d’interpolation modifient l’aspect de la façon suivante : </p>
     
      <adobetable>
      
      
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="dégradé linéaire avec InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="dégradé linéaire avec InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
      </row><row>
      <entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
      <entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
      </row></tbody></tgroup></adobetable>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:spreadMethod:get"><apiName>spreadMethod</apiName><shortdesc>
     Valeur de la classe SpreadMethod qui spécifie la méthode d’étalement à utiliser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur de la classe SpreadMethod qui spécifie la méthode d’étalement à utiliser. Les valeurs disponibles sont les suivantes : <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> et <codeph>SpreadMethod.REPEAT</codeph>. 
     
     <p>L’exemple suivant montre un dégradé linéaire simple entre deux couleurs :</p>
     
     <codeblock>
     import flash.geom.*
     import flash.display.*
     var fillType:String = GradientType.LINEAR;
     var colors:Array = [0xFF0000, 0x0000FF];
     var alphas:Array = [1, 1];
     var ratios:Array = [0x00, 0xFF];
     var matr:Matrix = new Matrix();
     matr.createGradientBox(20, 20, 0, 0, 0);
     var spreadMethod:String = SpreadMethod.PAD;
     this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       
     this.graphics.drawRect(0,0,100,100);
     </codeblock>
     
      <p>Cet exemple utilise <codeph>SpreadMethod.PAD</codeph> comme méthode d’étalement, et le remplissage en dégradé prend l’aspect suivant :</p>
     
      <p><adobeimage alt="dégradé linéaire avec SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
     
      <p>Si vous utilisez <codeph>SpreadMethod.REFLECT</codeph> comme méthode d’étalement, le remplissage en dégradé prend l’aspect suivant :</p>
     
      <p><adobeimage alt="dégradé linéaire avec SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
     
      <p>Si vous utilisez <codeph>SpreadMethod.REPEAT</codeph> comme méthode d’étalement, le remplissage en dégradé prend l’aspect suivant :</p>
     
      <p><adobeimage alt="dégradé linéaire avec SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:type:get"><apiName>type</apiName><shortdesc>
     Valeur de la classe GradientType qui spécifie le type de dégradé à utiliser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur de la classe GradientType qui spécifie le type de dégradé à utiliser. Les valeurs disponibles sont <codeph>GradientType.LINEAR</codeph> et <codeph>GradientType.RADIAL</codeph>. 
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Sprite"><apiName>Sprite</apiName><shortdesc>
 La classe Sprite est un bloc constitutif de base de la liste d’affichage : un nœud de liste d’affichage qui permet d’afficher des images et peut également contenir des enfants.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>L’objet d’affichage de base des objets créés par ActionScript.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Sprite est un bloc constitutif de base de la liste d’affichage : un nœud de liste d’affichage qui permet d’afficher des images et peut également contenir des enfants.
 
 <p>Un objet Sprite est similaire à un clip, mais ne possède pas de scénario. Sprite est une classe de base particulièrement adaptée aux objets qui ne nécessitent pas de scénario. Elle conviendrait par exemple aux composants de l’interface utilisateur qui ne requièrent en règle générale pas de scénario.</p>
 
 <p>La classe Sprite est nouvelle dans ActionScript 3.0. Vous pouvez l’utiliser à la place de la classe MovieClip, qui conserve l’ensemble des fonctionnalités des versions antérieures d’ActionScript pour assurer une compatibilité ascendante.</p>
 
 </apiDesc><example conref="examples\SpriteExample.as"> L’exemple suivant utilise la classe SpriteExample pour dessiner un carré orange sur la scène, puis distribue les événements que lorsque l’utilisateur clique ou fait glisser le carré. Pour ce faire, procédez comme suit :
 <ol>
  <li>Déclarez la propriété <codeph>size</codeph> (100 x 100 pixels) et la couleur de fond (orange) pour une exploitation ultérieure lors du dessin du carré.</li>
 
  <li>Le constructeur crée ensuite un nouvel objet Sprite <codeph>child</codeph> et l’utilise pour ajouter deux écouteurs d’événement et leurs méthodes associées : <codeph>mouseDownHandler()</codeph> et <codeph>mouseUpHandler()</codeph>.</li>
 
  <li>L’objet Sprite <codeph>child</codeph> est ensuite transmis à la méthode <codeph>draw()</codeph>, qui dessine le carré orange.</li>
 
  <li>L’enfant est ensuite placé dans la liste d’affichage grâce à un appel à la méthode <codeph>addChild()</codeph>. </li>
 
  <li>Les écouteurs d’événements fonctionnent de la façon suivante :
 
  <ul>
      <li><codeph>mouseDownHandler()</codeph> : lorsque l’utilisateur clique sur l’objet Sprite, cette méthode ajoute un écouteur d’événements mouseMove, la méthode <codeph>mouseMoveHandler()</codeph>, qui traite les mouvements de la souris. La méthode <codeph>startDrag()</codeph> est ensuite appelée et permet de faire glisser l’objet Sprite.</li>
 
      <li><codeph>mouseUpHandler()</codeph> : lorsque le bouton de la souris est relâché, l’écouteur d’événements mouseMove est supprimé et la méthode <codeph>stopDrag()</codeph> est appelée, ce qui fige le carré orange.</li>
 
      <li><codeph>mouseMoveHandler</codeph> : tant que le bouton gauche de la souris reste enfoncé, cette méthode demande au lecteur de redessiner en continu le carré orange.</li>
 
  </ul>
  </li>
 
 </ol>
 
 <p><b>Remarque : </b>Chacune des méthodes de l’écouteur d’événements déclare une variable <codeph>sprite</codeph> locale, qui se voit affecter la propriété <codeph>target</codeph> de l’événement.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;

    public class SpriteExample extends Sprite {
        private var size:uint    = 100;
        private var bgColor:uint = 0xFFCC00;

        public function SpriteExample() {
            var child:Sprite = new Sprite();
            child.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
            child.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
            draw(child);
            addChild(child);
        }

        private function mouseDownHandler(event:MouseEvent):void {
            trace("mouseDownHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.startDrag();
        }

        private function mouseUpHandler(event:MouseEvent):void {
            trace("mouseUpHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.stopDrag();
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            trace("mouseMoveHandler");
            event.updateAfterEvent();
        }

        private function draw(sprite:Sprite):void {
            sprite.graphics.beginFill(bgColor);
            sprite.graphics.drawRect(0, 0, size, size);
            sprite.graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:Sprite:Sprite"><apiName>Sprite</apiName><shortdesc>
	Crée une occurrence de Sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Crée une occurrence de Sprite. Une fois l’occurrence de Sprite créée, appelez la méthode <codeph>DisplayObjectContainer.addChild()</codeph> ou <codeph>DisplayObjectContainer.addChildAt()</codeph> pour ajouter le sprite à une occurrence de l’objet DisplayObjectContainer parent.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:Sprite:startDrag"><apiName>startDrag</apiName><shortdesc>
	 Permet à l’utilisateur de faire glisser le sprite spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.startDrag, startDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lockCenter</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Spécifie si le sprite à déplacer doit être verrouillé au centre de la position de la souris (<codeph>true</codeph>) ou verrouillé au point où l’utilisateur a cliqué sur le sprite en premier lieu (<codeph>false</codeph>). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>bounds</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur relative aux coordonnées du parent du sprite qui spécifie un rectangle de délimitation pour le sprite. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Permet à l’utilisateur de faire glisser le sprite spécifié. Il reste possible de faire glisser le sprite jusqu’à l’arrêt explicite de cette action par un appel à la méthode <codeph>Sprite.stopDrag()</codeph> ou lorsqu’un autre sprite est rendu déplaçable. Vous ne pouvez déplacer qu’un seul sprite à la fois.
	 <p>Les objets d’affichage tridimensionnels suivent la souris et la méthode <codeph>Sprite.startDrag()</codeph> déplace l’objet dans le plan tridimensionnel défini par l’objet d’affichage. Si l’objet d’affichage est un objet bidimensionnel et l’enfant d’un objet tridimensionnel, l’objet bidimensionnel se déplace dans le plan tridimensionnel défini par l’objet parent tridimensionnel.</p>
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> L’exemple suivant crée un sprite <codeph>circle</codeph> et deux sprites <codeph>target</codeph>. La méthode <codeph>startDrag()</codeph> est appelée sur le sprite <codeph>circle</codeph> lorsque l’utilisateur place le curseur sur le sprite et appuie sur le bouton de la souris, et lorsque la méthode <codeph>stopDrag()</codeph> est appelée si l’utilisateur relâche le bouton de la souris. Cette opération permet de faire glisser le sprite. Lorsque l’utilisateur relâche le bouton de sa souris, la méthode <codeph>mouseRelease()</codeph> est appelée, qui en retour suit la propriété <codeph>name</codeph> de l’objet <codeph>dropTarget</codeph> — celui vers lequel l’utilisateur fait glisser le sprite <codeph>circle</codeph> :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Sprite:stopDrag"><apiName>stopDrag</apiName><shortdesc>
	 Met fin à la méthode startDrag().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sprite, movieclip.stopDrag, stopDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Met fin à la méthode <codeph>startDrag()</codeph>. Un sprite qu’il est possible de déplacer grâce à la méthode <codeph>startDrag()</codeph> reste déplaçable jusqu’à ce qu’une autre méthode <codeph>stopDrag()</codeph> soit ajoutée, ou jusqu’à ce qu’un autre sprite devienne déplaçable. Vous ne pouvez déplacer qu’un seul sprite à la fois.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> L’exemple suivant crée un sprite <codeph>circle</codeph> et deux sprites <codeph>target</codeph>. La méthode <codeph>startDrag()</codeph> est appelée sur le sprite <codeph>circle</codeph> lorsque l’utilisateur place le curseur sur le sprite et appuie sur le bouton de la souris, et lorsque la méthode <codeph>stopDrag()</codeph> est appelée si l’utilisateur relâche le bouton de la souris. Cette opération permet de faire glisser le sprite. Lorsque l’utilisateur relâche le bouton de sa souris, la méthode <codeph>mouseRelease()</codeph> est appelée, qui en retour suit la propriété <codeph>name</codeph> de l’objet <codeph>dropTarget</codeph> — celui vers lequel l’utilisateur fait glisser le sprite <codeph>circle</codeph> :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Sprite:buttonMode:get"><apiName>buttonMode</apiName><shortdesc>
     Spécifie le mode de bouton du sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Spécifie le mode de bouton du sprite.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Spécifie le mode de bouton du sprite. Si <codeph>true</codeph> est renvoyé, ce sprite se comporte comme un bouton, ce qui signifie qu’il déclenche l’affichage du curseur en forme de main lorsque la souris le survole et peut recevoir un événement <codeph>click</codeph> si l’utilisateur appuie sur la touche Entrée ou la barre d’espacement lorsque le sprite dispose du focus. Pour remplacer le curseur en forme de main par le pointeur standard, réglez la propriété <codeph>useHandCursor</codeph> sur <codeph>false</codeph>.
     
     <p>Bien qu’il soit préférable d’utiliser la classe SimpleButton pour créer des boutons, la propriété <codeph>buttonMode</codeph> permet d’affecter à un sprite une fonctionnalité similaire à celle d’un bouton. Pour inclure un sprite dans l’ordre de tabulation, réglez la propriété <codeph>tabEnabled</codeph> (héritée de la classe InteractiveObject et réglée sur <codeph>false</codeph> par défaut) sur <codeph>true</codeph>. Demandez-vous en outre si les enfants de votre sprite doivent prendre en charge la souris. La plupart des boutons n’activent pas l’interactivité avec la souris pour leurs objets enfant, en raison de son impact sur le flux d’événements. Pour désactiver l’interactivité avec la souris pour tous les objets enfant, réglez la propriété <codeph>mouseChildren</codeph> (héritée de la classe DisplayObjectContainer) sur <codeph>false</codeph>.</p>
     
     <p>Si vous utilisez la propriété <codeph>buttonMode</codeph> avec la classe MovieClip (une sous-classe de la classe Sprite), la fonctionnalité de votre bouton risque d’être enrichie. Si vous incluez les étiquettes d’images _up, _over et _down, Flash Player gère les changements d’état automatiques (fonctionnalité similaire à celle intégrée aux versions antérieures d’ActionScript pour les clips utilisés en tant que boutons). Ces changements d’état automatiques ne sont pas disponibles pour les sprites, qui ne disposent pas de scénario et donc, pas d’images à étiqueter. </p>
	 
	 </apiDesc><example conref="examples\Sprite.buttonMode.1.as"> L’exemple suivant crée deux sprites et définit la propriété <codeph>buttonMode</codeph> sur <codeph>true</codeph> pour l’un et <codeph>false</codeph> pour l’autre. Lorsque vous compilez et exécutez l’application, les deux sprites répondent aux événements de la souris, mais seul celui où <codeph>buttonMode</codeph> est défini sur <codeph>true</codeph> a recours au curseur en forme de main et est inclus dans l’ordre de tabulation :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton"><linktext>SimpleButton</linktext></link><link href="flash.display.xml#Sprite/useHandCursor"><linktext>Sprite.useHandCursor</linktext></link><link href="flash.display.xml#InteractiveObject/tabEnabled"><linktext>InteractiveObject.tabEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:dropTarget:get"><apiName>dropTarget</apiName><shortdesc>
	 Spécifie l’objet d’affichage sur lequel le sprite est glissé ou sur lequel il a été déposé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Sprite, Sprite.dropTarget, dropTarget
	 
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Spécifie l’occurrence de DisplayObject sur laquelle le sprite est glissé ou sur laquelle il a été déposé.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Spécifie l’objet d’affichage sur lequel le sprite est glissé ou sur lequel il a été déposé.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> L’exemple suivant crée un sprite <codeph>circle</codeph> et deux sprites <codeph>target</codeph>. La méthode <codeph>startDrag()</codeph> est appelée sur le sprite <codeph>circle</codeph> lorsque l’utilisateur place le curseur sur le sprite et appuie sur le bouton de la souris, et lorsque la méthode <codeph>stopDrag()</codeph> est appelée si l’utilisateur relâche le bouton de la souris. Cette opération permet de faire glisser le sprite. Lorsque l’utilisateur relâche le bouton de sa souris, la méthode <codeph>mouseRelease()</codeph> est appelée, qui en retour suit la propriété <codeph>name</codeph> de l’objet <codeph>dropTarget</codeph> — celui vers lequel l’utilisateur fait glisser le sprite <codeph>circle</codeph> :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:graphics:get"><apiName>graphics</apiName><shortdesc>
     Spécifie l’objet Graphics appartenant au sprite qui prend en charge les commandes de dessin vectoriel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Spécifie un objet Graphics.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Spécifie l’objet Graphics appartenant au sprite qui prend en charge les commandes de dessin vectoriel.
     
	 </apiDesc><example conref="examples\Sprite.graphics.1.as"> L’exemple suivant crée un sprite <codeph>circle</codeph> et utilise sa propriété <codeph>graphics</codeph> pour dessiner un cercle avec une trame jaune (0xFFCC00) :
<codeblock>
import flash.display.Sprite;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:hitArea:get"><apiName>hitArea</apiName><shortdesc>
	 Désigne un autre sprite qui fera office de zone active d’un sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Sprite</apiValueClassifier></apiValueDef><apiDesc>
	 Désigne un autre sprite qui fera office de zone active d’un sprite. Si la propriété <codeph>hitArea</codeph> n’existe pas, ou si sa valeur est <codeph>null</codeph> ou <codeph>undefined</codeph>, le sprite fait office de zone active. La valeur de la propriété <codeph>hitArea</codeph> peut être une référence à un objet Sprite.
	 
	 <p>Vous pouvez modifier la propriété <codeph>hitArea</codeph> à tout moment ; le sprite modifié accepte immédiatement le nouveau comportement de la zone active. Il n’est pas nécessaire que le sprite désigné comme zone active soit visible ; bien qu’elle ne soit pas visible, sa forme graphique est encore détectée comme zone active.</p>
	 
	 <p><b>Remarque :</b> vous devez définir sur <codeph>false</codeph> la propriété <codeph>mouseEnabled</codeph> du sprite désigné comme zone active. Sinon, votre bouton sprite risque de ne pas fonctionner, car le sprite désigné comme zone active reçoit les événements de souris au lieu du bouton sprite.</p>
	 
	 </apiDesc><example conref="examples\Sprite.hitArea.1.as"> L’exemple suivant crée les sprites <codeph>circle</codeph> et <codeph>square</codeph>. Le sprite <codeph>square</codeph> correspond à <codeph>hitArea</codeph> pour le sprite <codeph>circle</codeph>. Par conséquent, lorsque l’utilisateur clique sur le sprite <codeph>square</codeph>, le sprite <codeph>circle</codeph> distribue un événement <codeph>click</codeph> :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xCCFF00);
square.graphics.drawRect(200, 0, 100, 100);

circle.hitArea = square;
square.mouseEnabled = false;

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void{
    trace(event.target == circle); // true
    trace(event.target == square); // false
}

addChild(circle);
addChild(square);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Contrôle le son à l’intérieur du sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Contrôle le son à l’intérieur du sprite.
	 
	 </apiDesc><example conref="examples\Sprite.soundTransform.1.as"> L’exemple suivant crée un sprite appelé <codeph>container</codeph> et ajoute un objet Loader à sa liste enfant. L’objet Loader charge un fichier SWF. Lorsque l’utilisateur clique sur le champ de texte <codeph>tf</codeph>, <codeph>true</codeph>. La méthode <codeph>mute()</codeph> définit la propriété <codeph>volume</codeph> de la propriété <codeph>soundTransform</codeph> du sprite <codeph>container</codeph> :
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.events.IOErrorEvent;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.text.TextField;
import flash.media.SoundTransform;

var container:Sprite = new Sprite();
addChild(container);

var ldr:Loader = new Loader;
var urlReq:URLRequest = new URLRequest("SoundPlayer.swf");
ldr.load(urlReq);

container.addChild(ldr);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);
            
var tf:TextField = new TextField();
tf.htmlText = "&lt;a href = 'event:Mute'>Mute / Unmute&lt;/a>";
addChild(tf);

var mySoundTransform:SoundTransform = new SoundTransform();
mySoundTransform.volume = 1;

tf.addEventListener(MouseEvent.CLICK, mute);

function mute(event:MouseEvent):void {    
    if (mySoundTransform.volume == 0) {
        mySoundTransform.volume = 1;
    } else {
        mySoundTransform.volume = 0;        
    }
    container.soundTransform = mySoundTransform;
}

function urlNotFound(event:IOErrorEvent):void {
    trace("The URL was not found."); 
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
	 Valeur booléenne indiquant si le curseur en forme de main apparaît lorsque la souris survole un sprite dont la propriété buttonMode est réglée sur true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Valeur booléenne indiquant si le curseur en forme de main apparaît lorsque la souris survole un sprite dont la propriété buttonMode est réglée sur true. 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur booléenne indiquant si le curseur en forme de main apparaît lorsque la souris survole un sprite dont la propriété <codeph>buttonMode</codeph> est réglée sur <codeph>true</codeph>. La valeur par défaut de la propriété <codeph>useHandCursor</codeph> est <codeph>true</codeph>. Si la propriété <codeph>useHandCursor</codeph> est définie sur <codeph>true</codeph>, le curseur en forme de main utilisé pour les boutons s’affiche lorsque la souris survole un sprite. Si la propriété <codeph>useHandCursor</codeph> est définie sur <codeph>false</codeph>, le pointeur flèche est utilisé.
	 
	 <p>Vous pouvez modifier la propriété <codeph>useHandCursor</codeph> à tout moment ; le sprite modifié accepte immédiatement la nouvelle apparence du curseur. </p>
     
     <p product="flex"><b>Remarque :</b> si votre sprite a des sprites enfant, vous pouvez définir la propriété <codeph>mouseChildren</codeph> sur <codeph>false</codeph>. Par exemple, si vous souhaitez qu’un curseur en forme de main apparaisse sur une commande Flex &lt;mx:Label>, réglez les propriétés <codeph>useHandCursor</codeph> et <codeph>buttonMode</codeph> sur <codeph>true</codeph>, et la propriété <codeph>mouseChildren</codeph> sur <codeph>false</codeph>.</p>
	 
	 </apiDesc><example conref="examples\Sprite.useHandCursor.1.as"> L’exemple suivant crée deux sprites et définit la propriété <codeph>buttonMode</codeph> sur <codeph>true</codeph> pour les deux, cependant il définit la propriété <codeph>useHandCursor</codeph> sur <codeph>true</codeph> pour l’un et sur <codeph>false</codeph> pour l’autre. Lorsque vous compilez et exécutez l’application, les deux sprites se comportent en tant que bouton et sont inclus dans l’ordre de tabulation, mais seul celui où <codeph>useHandCursor</codeph> est défini sur <codeph>true</codeph> a recours au curseur en forme de main :
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.useHandCursor = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = true;
circle2.useHandCursor = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>buttonMode</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
 Définit un remplissage bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit un remplissage bitmap. L’image bitmap peut être lissée, répétée ou former une mosaïque afin de remplir la zone ; elle peut également être manipulée avec une matrice de transformation.
 <p>
 Utilisez l’objet GraphicsBitmapFill avec la méthode <codeph>Graphics.drawGraphicsData()</codeph>. Dessiner un objet GraphicsBitmapFill revient à appeler la méthode <codeph>Graphics.beginBitmapFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsBitmapFill:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
     Crée un nouvel objet GraphicsBitmapFill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Image bitmap transparente ou opaque qui contient les bits à afficher.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet matrix (appartenant à la classe flash.geom.Matrix), qui permet de définir les transformations sur l’image bitmap.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Si la valeur est <codeph>true</codeph>, l’image bitmap se reproduit pour former un motif. Si la valeur est <codeph>false</codeph>, l’image bitmap ne se répète pas et les bords de l’image sont utilisés pour tout remplissage qui dépasse l’image. 
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si la valeur est définie sur <codeph>false</codeph>, les images bitmap agrandies sont rendues en appliquant un algorithme d’approximation et ont un aspect pixélisé. Si la valeur est définie sur <codeph>true</codeph>, les images bitmap agrandies sont rendues avec un algorithme bilinéaire. Les rendus qui résultent de l’utilisation de l’algorithme d’approximation sont généralement plus rapides.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un nouvel objet GraphicsBitmapFill.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsBitmapFill:bitmapData"><apiName>bitmapData</apiName><shortdesc>
     Image bitmap transparente ou opaque.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
     Image bitmap transparente ou opaque.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:matrix"><apiName>matrix</apiName><shortdesc>
     Objet matrix (appartenant à la classe flash.geom.Matrix) qui définit les transformations sur l’image bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Objet matrix (appartenant à la classe flash.geom.Matrix) qui définit les transformations sur l’image bitmap. Par exemple, l’objet matrix suivant fait pivoter une image bitmap de 45 degrés (pi/4 radians) :
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:repeat"><apiName>repeat</apiName><shortdesc>
     Indique si l’image bitmap doit être reproduite pour former un motif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’image bitmap doit être reproduite pour former un motif.
     
     <p>
     Si la valeur est <codeph>true</codeph>, l’image bitmap se reproduit pour former un motif. Si la valeur est définie sur <codeph>false</codeph>, l’image bitmap n’est pas reproduite et les pixels les plus éloignés des bords extérieurs de l’image bitmap sont utilisés pour tout remplissage dépassant les limites de cette dernière.</p>
     
     <p>Considérons par exemple l’image bitmap suivante (un motif en damier de 20 x 20 pixels) :</p>
     
     <p><adobeimage alt="damier de 20x20 pixels" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
     
     <p>Lorsque la propriété <codeph>repeat</codeph> est définie sur <codeph>true</codeph> (comme dans l’exemple suivant), le remplissage bitmap répète l’image bitmap :</p>
     
     <p><adobeimage alt="damier de 60x60 pixels" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
     
     <p>Lorsque la propriété <codeph>repeat</codeph> est définie sur <codeph>false</codeph>, le remplissage bitmap utilise les pixels du bord pour le remplissage en dehors de l’image bitmap :</p>
     
     <p><adobeimage alt="image de 60x60 pixels sans répétition" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsBitmapFill:smooth"><apiName>smooth</apiName><shortdesc>
     Indique si un algorithme de lissage doit être appliqué à l’image bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si un algorithme de lissage doit être appliqué à l’image bitmap.
     <p>
     Si la valeur est <codeph>false</codeph>, les images bitmap agrandies sont rendues en appliquant un algorithme d’approximation et ont un aspect pixélisé. Si la valeur est <codeph>true</codeph>, les images bitmap agrandies sont rendues avec un algorithme bilinéaire. Les rendus qui résultent de l’utilisation de l’algorithme d’approximation sont généralement plus rapides.
     </p>
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Définit un style de ligne ou un trait.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsStroke</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit un style de ligne ou un trait. 
 
 <p>
 Utilisez l’objet GraphicsStroke avec la méthode <codeph>Graphics.drawGraphicsData()</codeph>. Dessiner un objet GraphicsStroke revient à appeler l’une des méthodes de la classe Graphics qui définit le style de ligne, par exemple les méthodes <codeph>Graphics.lineStyle()</codeph>, <codeph>Graphics.lineBitmapStyle()</codeph> ou <codeph>Graphics.lineGradientStyle()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>flash.display.Graphics.lineBitmapStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsStroke:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Crée un nouvel objet GraphicsStroke.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Un entier qui indique l’épaisseur de la ligne en points ; les valeurs disponibles sont comprises entre 0 et 255. Si aucun nombre n’est spécifié, ou si le paramètre n’est pas défini, aucune ligne n’est dessinée. Si une valeur inférieure à 0 est transmise, la valeur par défaut est de 0. 0 correspond à l’épaisseur minimale et 255 à l’épaisseur maximale. Si la valeur transmise est supérieure à 255, la valeur par défaut est de 255. 
 
 </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Valeur booléenne qui permet d’ajouter des indices supplémentaires de lissage des pixels. Cette valeur affecte à la fois la position des ancres de courbe et la taille du trait. Si <codeph>pixelHinting</codeph> est défini sur <codeph>true</codeph>, Flash Player propose des indices de largeur des pixels. Si <codeph>pixelHinting</codeph> est défini sur <codeph>false</codeph>, les courbes et les lignes droites risquent de ne pas être continues. Les exemples ci-dessous illustrent comment Flash Player effectue le rendu de deux rectangles arrondis identiques à une exception près : le réglage du paramètre <codeph>pixelHinting</codeph> utilisé par la méthode <codeph>lineStyle()</codeph> (les images sont mises à l’échelle 200 %, pour mettre en évidence la différence) :
 
 <p><adobeimage alt="pixelHinting false et pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 <p>Si vous ne spécifiez pas de valeur, la ligne n’utilise pas les indices de lissage des pixels.</p>
  
 </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>Valeur de la classe LineScaleMode qui spécifie le mode d’échelle à utiliser :
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> — Redimensionne toujours l’épaisseur du trait si l’objet est redimensionné (valeur par défaut).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> — Ne redimensionne jamais l’épaisseur du trait.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> — N’ajuste pas l’épaisseur du trait si l’objet est redimensionné verticalement <i>uniquement</i>. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.VERTICAL</codeph>. Le cercle de gauche est redimensionné verticalement uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale :
 
 <p><adobeimage alt="Un cercle redimensionné verticalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> — N’ajuste pas l’épaisseur du trait si l’objet est redimensionné horizontalement <i>uniquement</i>. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.HORIZONTAL</codeph>. Le cercle de gauche est redimensionné horizontalement uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale :
 
 <p><adobeimage alt="Un cercle redimensionné horizontalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 
 </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Valeur de la classe CapsStyle qui spécifie le type d’extrémité au bout des lignes. Les valeurs possibles sont les suivantes : <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> et <codeph>CapsStyle.SQUARE</codeph>. En l’absence de valeur, Flash utilise des extrémités rondes. 
 <p>Par exemple, l’illustration suivante présente les différents réglages <codeph>capsStyle</codeph>. Pour chaque paramètre, l’illustration présente une ligne bleue dont l’épaisseur est de 30 (pour laquelle <codeph>capsStyle</codeph> s’applique), et une ligne noire superposée dont l’épaisseur est de 1 (pour laquelle aucun <codeph>capsStyle</codeph> ne s’applique) :
 </p>
 <p><adobeimage alt="NONE, ROUND et SQUARE" href="../../images/linecap.jpg"/></p>
 
 </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>round</apiData><apiDesc>Valeur de la classe JointStyle qui spécifie le type d’apparence de liaison utilisé dans les angles. Les valeurs possibles sont les suivantes : <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> et <codeph>JointStyle.ROUND</codeph>. En l’absence de valeurs, Flash utilise des liaisons rondes. 
 
 <p>Par exemple, l’illustration suivante présente les différents réglages <codeph>joints</codeph>. Pour chaque paramètre, l’illustration présente une ligne bleue en angle dont l’épaisseur est de 30 (pour laquelle <codeph>jointStyle</codeph> s’applique), et une ligne noire en angle superposée dont l’épaisseur est de 1 (pour laquelle aucun <codeph>jointStyle</codeph> ne s’applique) :
 </p>
 
 <p><adobeimage alt="MITER, ROUND et BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Remarque :</b> Pour les paramètres <codeph>joints</codeph> définis sur <codeph>JointStyle.MITER</codeph>, vous pouvez utiliser le paramètre <codeph>miterLimit</codeph> pour limiter la longueur de la pointe.</p>
 
 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3.0</apiData><apiDesc>Nombre qui indique la limite à laquelle une pointe est coupée. Les valeurs disponibles sont comprises entre 1 et 255 (et les valeurs qui excèdent cette plage sont arrondies à 1 ou 255). Cette valeur n’est utilisée que si <codeph>jointStyle</codeph> est défini sur <codeph>"miter"</codeph>. La valeur <codeph>miterLimit</codeph> représente la longueur maximale d’une pointe au-delà du point où les lignes se rencontrent pour former une liaison. La valeur exprime un facteur du paramètre <codeph>thickness</codeph> de la ligne. Par exemple, avec un facteur <codeph>miterLimit</codeph> de 2,5 et une valeur de <codeph>thickness</codeph> de 10 pixels, la pointe est coupée à 25 pixels. 
 
 <p>Par exemple, les lignes d’angle suivantes dessinent un objet avec un paramètre <codeph>thickness</codeph> d’une valeur de 20, mais un paramètre <codeph>miterLimit</codeph> défini sur 1, 2 et 4. Les lignes de référence noires sont surimposées et indiquent les points de rencontre des pointes :</p>
 
 <p><adobeimage alt="lignes avec miterLimit défini sur 1, 2 et 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Notez qu’une valeur <codeph>miterLimit</codeph> donnée possède un angle maximal spécifique pour lequel la pointe est coupée. Vous trouverez quelques exemples dans le tableau suivant :</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Valeur <codeph>miterLimit</codeph> :</entry><entry>Les angles inférieurs aux valeurs indiquées sont coupés :</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 degrés</entry></row><row><entry>2</entry>      <entry>60 degrés</entry></row><row><entry>4</entry>      <entry>30 degrés</entry></row><row><entry>8</entry>      <entry>15 degrés</entry></row></tbody></tgroup></adobetable>
 </apiDesc></apiParam><apiParam><apiItemName>fill</apiItemName><apiOperationClassifier>flash.display:IGraphicsFill</apiOperationClassifier><apiData>null</apiData><apiDesc>Une occurrence IGraphicsFill contenant les données pour le remplissage d’un trait. Une occurrence IGraphicsFill peut représenter une série de commandes de remplissage.
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Crée un nouvel objet GraphicsStroke.
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsStroke:fill"><apiName>fill</apiName><shortdesc>
 Spécifie l’occurrence contenant les données pour le remplissage d’un trait.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:IGraphicsFill</apiValueClassifier></apiValueDef><apiDesc>
 Spécifie l’occurrence contenant les données pour le remplissage d’un trait. Une occurrence IGraphicsFill peut représenter une série de commandes de remplissage.
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:miterLimit"><apiName>miterLimit</apiName><shortdesc>
 Indique la limite à laquelle une pointe est coupée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Indique la limite à laquelle une pointe est coupée. Les valeurs disponibles sont comprises entre 1 et 255 (et les valeurs qui excèdent cette plage sont arrondies à 1 ou 255). Cette valeur n’est utilisée que si <codeph>jointStyle</codeph> est défini sur <codeph>"miter"</codeph>. La valeur <codeph>miterLimit</codeph> représente la longueur maximale d’une pointe au-delà du point où les lignes se rencontrent pour former une liaison. La valeur exprime un facteur du paramètre <codeph>thickness</codeph> de la ligne. Par exemple, avec un facteur <codeph>miterLimit</codeph> de 2,5 et une valeur de <codeph>thickness</codeph> de 10 pixels, la pointe est coupée à 25 pixels. 
 
 <p>Par exemple, les lignes d’angle suivantes dessinent un objet avec un paramètre <codeph>thickness</codeph> d’une valeur de 20, mais un paramètre <codeph>miterLimit</codeph> défini sur 1, 2 et 4. Les lignes de référence noires sont surimposées et indiquent les points de rencontre des pointes :</p>
 
 <p><adobeimage alt="lignes avec miterLimit défini sur 1, 2 et 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Notez qu’une valeur <codeph>miterLimit</codeph> donnée possède un angle maximal spécifique pour lequel la pointe est coupée. Vous trouverez quelques exemples dans le tableau suivant :</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Valeur <codeph>miterLimit</codeph> :</entry><entry>Les angles inférieurs aux valeurs indiquées sont coupés :</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 degrés</entry></row><row><entry>2</entry>      <entry>60 degrés</entry></row><row><entry>4</entry>      <entry>30 degrés</entry></row><row><entry>8</entry>      <entry>15 degrés</entry></row></tbody></tgroup></adobetable>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:pixelHinting"><apiName>pixelHinting</apiName><shortdesc>
 Indique si des indices supplémentaires de lissage des pixels doivent être ajoutés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
 Indique si des indices supplémentaires de lissage des pixels doivent être ajoutés. Cette valeur affecte à la fois la position des ancres de courbe et la taille du trait. Si <codeph>pixelHinting</codeph> est défini sur <codeph>true</codeph>, Flash Player propose des indices de largeur des pixels. Si <codeph>pixelHinting</codeph> est défini sur <codeph>false</codeph>, les courbes et les lignes droites risquent de ne pas être continues. Les exemples ci-dessous illustrent comment Flash Player effectue le rendu de deux rectangles arrondis identiques à une exception près : le réglage du paramètre <codeph>pixelHinting</codeph> utilisé par la méthode <codeph>lineStyle()</codeph> (les images sont mises à l’échelle 200 %, pour mettre en évidence la différence) :
 
 <p><adobeimage alt="pixelHinting false et pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:thickness"><apiName>thickness</apiName><shortdesc>
 Indique l’épaisseur de la ligne en points ; les valeurs disponibles sont comprises entre 0 et 255.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Indique l’épaisseur de la ligne en points ; les valeurs disponibles sont comprises entre 0 et 255. Si aucun nombre n’est spécifié, ou si le paramètre n’est pas défini, aucune ligne n’est dessinée. Si une valeur inférieure à 0 est transmise, la valeur par défaut est de 0. 0 correspond à l’épaisseur minimale et 255 à l’épaisseur maximale. Si la valeur transmise est supérieure à 255, la valeur par défaut est de 255.
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:caps:get"><apiName>caps</apiName><shortdesc>
 Spécifie le type d’extrémité au bout des lignes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Spécifie le type d’extrémité au bout des lignes. Les valeurs possibles sont les suivantes : <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> et <codeph>CapsStyle.SQUARE</codeph>. En l’absence de valeur, Flash utilise des extrémités rondes. 
 <p>Par exemple, l’illustration suivante présente les différents réglages <codeph>capsStyle</codeph>. Pour chaque paramètre, l’illustration présente une ligne bleue dont l’épaisseur est de 30 (pour laquelle <codeph>capsStyle</codeph> s’applique), et une ligne noire superposée dont l’épaisseur est de 1 (pour laquelle aucun <codeph>capsStyle</codeph> ne s’applique) :
 </p>
 <p><adobeimage alt="NONE, ROUND et SQUARE" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:joints:get"><apiName>joints</apiName><shortdesc>
 Spécifie le type d’apparence de liaison utilisé dans les angles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Spécifie le type d’apparence de liaison utilisé dans les angles. Les valeurs possibles sont les suivantes : <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> et <codeph>JointStyle.ROUND</codeph>. En l’absence de valeurs, Flash utilise des liaisons rondes. 
 
 <p>Par exemple, l’illustration suivante présente les différents réglages <codeph>joints</codeph>. Pour chaque paramètre, l’illustration présente une ligne bleue en angle dont l’épaisseur est de 30 (pour laquelle <codeph>jointStyle</codeph> s’applique), et une ligne noire en angle superposée dont l’épaisseur est de 1 (pour laquelle aucun <codeph>jointStyle</codeph> ne s’applique) :
 </p>
 
 <p><adobeimage alt="MITER, ROUND et BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Remarque :</b> Pour les paramètres <codeph>joints</codeph> définis sur <codeph>JointStyle.MITER</codeph>, vous pouvez utiliser le paramètre <codeph>miterLimit</codeph> pour limiter la longueur de la pointe.</p>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
 Spécifie l’échelle de l’épaisseur du trait.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Spécifie l’échelle de l’épaisseur du trait. Valeurs valides :
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> — Redimensionne toujours l’épaisseur du trait si l’objet est redimensionné (valeur par défaut).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> — Ne redimensionne jamais l’épaisseur du trait.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> — N’ajuste pas l’épaisseur du trait si l’objet est redimensionné verticalement <i>uniquement</i>. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.VERTICAL</codeph>. Le cercle de gauche est redimensionné verticalement uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale :
 
 <p><adobeimage alt="Un cercle redimensionné verticalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> — N’ajuste pas l’épaisseur du trait si l’objet est redimensionné horizontalement <i>uniquement</i>. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.HORIZONTAL</codeph>. Le cercle de gauche est redimensionné horizontalement uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale :
 
 <p><adobeimage alt="Un cercle redimensionné horizontalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Indique la fin du remplissage des graphiques.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Indique la fin du remplissage des graphiques. Utilisez l’objet GraphicsEndFill avec la méthode <codeph>Graphics.drawGraphicsData()</codeph>.
 
 <p>
 Dessiner un objet GraphicsEndFill revient à appeler la méthode <codeph>Graphics.endFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsEndFill:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Crée un objet à utiliser avec la méthode Graphics.drawGraphicsData() pour terminer le remplissage de façon explicite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 Crée un objet à utiliser avec la méthode <codeph>Graphics.drawGraphicsData()</codeph> pour terminer le remplissage de façon explicite.
 
 
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderPrecision"><apiName>ShaderPrecision</apiName><shortdesc>
	 Cette classe contient les constantes représentant les valeurs possibles de la propriété precisionHint de la classe Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Cette classe contient les constantes représentant les valeurs possibles de la propriété <codeph>precisionHint</codeph> de la classe Shader. Chaque constante représente l’un des modes de précision pour l’exécution des opérations du shader.
	 
	 <p>Le choix du mode de précision affecte les opérations de shader suivantes. Ces opérations sont plus rapides sur un processeur Intel avec l’instruction SSE définie :</p>
	 
	 <ul>
	   <li><codeph>sin(x)</codeph></li>
	   <li><codeph>cos(x)</codeph></li>
	   <li><codeph>tan(x)</codeph></li>
	   <li><codeph>asin(x)</codeph></li>
	   <li><codeph>acos(x)</codeph></li>
	   <li><codeph>atan(x)</codeph></li>
	   <li><codeph>atan(x, y)</codeph></li>
	   <li><codeph>exp(x)</codeph></li>
	   <li><codeph>exp2(x)</codeph></li>
	   <li><codeph>log(x)</codeph></li>
	   <li><codeph>log2(x)</codeph></li>
	   <li><codeph>pow(x, y)</codeph></li>
	   <li><codeph>reciprocal(x)</codeph></li>
	   <li><codeph>sqrt(x)</codeph></li>
	 </ul>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links><apiValue id="flash.display:ShaderPrecision:FAST"><apiName>FAST</apiName><shortdesc>
		 Représente le mode de précision rapide.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fast</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Représente le mode de précision rapide.
		 
		 <p>Le mode de précision rapide est conçu pour des performances maximales, mais n’assure pas la même cohérence sur les différentes plates-formes et les configurations de CPU individuelles. Dans la plupart des cas, ce niveau de précision suffit pour créer des effets graphiques sans artefact visible.</p>
		 
		 <p>L’utilisation du mode de précision rapide est généralement plus rapide que celle des tables de recherche.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderPrecision:FULL"><apiName>FULL</apiName><shortdesc>
		 Représente le mode de précision totale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Représente le mode de précision totale.
		 
		 <p>En mode de précision totale, le shader calcule toutes les opérations mathématiques en utilisant toute la largeur de virgule flottante 32 bits de la norme IEEE. Ce mode assure un comportement cohérent sur toutes les plates-formes. Dans ce mode, certaines opérations mathématiques, telles que les fonctions trigonométriques et exponentielles, peuvent être lentes.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:BlendMode"><apiName>BlendMode</apiName><shortdesc>
Classe qui fournit des valeurs constantes relatives aux effets de mode de fondu visuels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Classe qui fournit des valeurs constantes relatives aux effets de mode de fondu visuels. Ces constantes sont utilisées dans les éléments suivants :

<ul>

	<li> La propriété <codeph>blendMode</codeph> de la classe flash.display.DisplayObject.</li>

	<li> Le paramètre <codeph>blendMode</codeph> de la méthode <codeph>draw()</codeph> de la classe flash.display.BitmapData.</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiValue id="flash.display:BlendMode:ADD"><apiName>ADD</apiName><shortdesc>
Ajoute les valeurs des couleurs élémentaires de l’objet d’affichage à celles de son arrière-plan, en appliquant un plafond de 0xFF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>add</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Ajoute les valeurs des couleurs élémentaires de l’objet d’affichage à celles de son arrière-plan, en appliquant un plafond de 0xFF. Ce réglage est habituellement utilisé pour animer un fondu d’éclaircissement entre deux objets.

<p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xAAA633, et que le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDD2200, la valeur RVB résultante du pixel affiché est 0xFFC833 (parce que 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8 et 0x33 + 0x00 = 0x33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ALPHA"><apiName>ALPHA</apiName><shortdesc>
Applique la valeur alpha de chaque pixel de l’objet d’affichage à l’arrière-plan.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>alpha</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Applique la valeur alpha de chaque pixel de l’objet d’affichage à l’arrière-plan. Pour ce faire, la propriété <codeph>blendMode</codeph> de l’objet d’affichage parent doit être réglée sur <codeph>flash.display.BlendMode.LAYER</codeph>. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DARKEN"><apiName>DARKEN</apiName><shortdesc>
Sélectionne les plus sombres des couleurs élémentaires de l’objet d’affichage et de l’arrière-plan (celles qui ont les valeurs les plus faibles).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>darken</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Sélectionne les plus sombres des couleurs élémentaires de l’objet d’affichage et de l’arrière-plan (celles qui ont les valeurs les plus faibles). Ce réglage est généralement utilisé pour les superpositions. 

<p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xFFCC33, et que le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDDF800, la valeur RVB obtenue pour le pixel affiché est 0xDDCC00 (car 0xFF > 0xDD, 0xCC &lt; 0xF8 et 0x33 > 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DIFFERENCE"><apiName>DIFFERENCE</apiName><shortdesc>
Compare les couleurs élémentaires de l’objet d’affichage à celles de son arrière-plan et soustrait la valeur la plus sombre des deux couleurs élémentaires de la plus claire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>difference</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Compare les couleurs élémentaires de l’objet d’affichage à celles de son arrière-plan et soustrait la valeur la plus sombre des deux couleurs élémentaires de la plus claire. Ce réglage est habituellement utilisé pour obtenir des couleurs plus vibrantes. 

<p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xFFCC33, et le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDDF800, la valeur RVB résultante du pixel affiché est 0x222C33 (parce que 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C et 0x33 - 0x00 = 0x33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ERASE"><apiName>ERASE</apiName><shortdesc>
Efface l’arrière-plan sur la base de la valeur alpha de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>erase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Efface l’arrière-plan sur la base de la valeur alpha de l’objet d’affichage. Ce processus implique de définir la propriété <codeph>blendMode</codeph> de l’objet d’affichage parent sur <codeph>flash.display.BlendMode.LAYER</codeph>. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:HARDLIGHT"><apiName>HARDLIGHT</apiName><shortdesc>
Ajuste la couleur de chaque pixel sur la base de l’obscurité de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>hardlight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Ajuste la couleur de chaque pixel sur la base de l’obscurité de l’objet d’affichage. Si l’objet d’affichage est plus clair qu’un gris à 50 %, les couleurs de l’objet d’affichage et de l’arrière-plan sont masquées, ce qui permet d’obtenir une couleur plus claire. Si l’objet d’affichage est plus foncé qu’un gris à 50 %, les couleurs sont multipliées, ce qui donne une couleur plus sombre. Ce réglage est habituellement utilisé pour les effets d’ombrage. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:INVERT"><apiName>INVERT</apiName><shortdesc>
Inverse l’arrière-plan.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>invert</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Inverse l’arrière-plan.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LAYER"><apiName>LAYER</apiName><shortdesc>
Impose la création d’un groupe de transparences pour l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>layer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Impose la création d’un groupe de transparences pour l’objet d’affichage. Cela signifie que l’objet d’affichage est précomposé dans un tampon temporaire avant que son traitement ne se poursuive. La précomposition est exécutée automatiquement si l’objet d’affichage est préplacé en mémoire cache par le biais d’une mise en cache des bitmaps ou s’il correspond à un conteneur d’objet d’affichage qui possède au moins un objet enfant associé à un réglage <codeph>blendMode</codeph> autre que <codeph>"normal"</codeph>.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LIGHTEN"><apiName>LIGHTEN</apiName><shortdesc>
Sélectionne les plus claires des couleurs élémentaires de l’objet d’affichage et de l’arrière-plan (celles qui ont les valeurs les plus élevées).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lighten</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Sélectionne les plus claires des couleurs élémentaires de l’objet d’affichage et de l’arrière-plan (celles qui ont les valeurs les plus élevées). Ce réglage est généralement utilisé pour les superpositions. 

<p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xFFCC33, et que le pixel d’arrière-plan possède une valeur RVB réglée sur 0xDDF800, la valeur RVB obtenue pour le pixel affiché est 0xFFF833 (car 0xFF > 0xDD, 0xCC &lt; 0xF8 et 0x33 > 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:MULTIPLY"><apiName>MULTIPLY</apiName><shortdesc>
Multiplie les valeurs des couleurs élémentaires de l’objet d’affichage par celles de la couleur d’arrière-plan, puis les normalise en les divisant par 0xFF, ce qui donne des couleurs plus sombres.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>multiply</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Multiplie les valeurs des couleurs élémentaires de l’objet d’affichage par celles de la couleur d’arrière-plan, puis les normalise en les divisant par 0xFF, ce qui donne des couleurs plus sombres. Ce réglage est souvent utilisé pour les effets d’ombre et de profondeur.

<p>Par exemple, si une couleur élémentaire (comme le rouge) d’un pixel de l’objet d’affichage et la couleur correspondante du pixel de l’arrière-plan ont toutes les deux une valeur de 0x88, le résultat de la multiplication est 0x4840. La division par 0xFF donne une valeur de 0x48 pour cette couleur élémentaire, qui est plus sombre que celle de l’objet d’affichage ou de l’arrière-plan.</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
L’objet d’affichage apparaît devant l’arrière-plan.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
L’objet d’affichage apparaît devant l’arrière-plan. Les valeurs de pixel de l’objet d’affichage remplacent celles de l’arrière-plan. Lorsque l’objet d’affichage est transparent, l’arrière-plan est visible.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:OVERLAY"><apiName>OVERLAY</apiName><shortdesc>
Ajuste la couleur de chaque pixel sur la base de l’obscurité de l’arrière-plan.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>overlay</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Ajuste la couleur de chaque pixel sur la base de l’obscurité de l’arrière-plan. Si l’arrière-plan est plus clair qu’un gris à 50 %, les couleurs de l’objet d’affichage et de l’arrière-plan sont masquées, ce qui donne une couleur plus claire. Si l’arrière-plan est plus foncé qu’un gris à 50 %, les couleurs sont multipliées, ce qui donne une couleur plus sombre. Ce réglage est habituellement utilisé pour les effets d’ombrage. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SCREEN"><apiName>SCREEN</apiName><shortdesc>
Multiplie le complément (l’inverse) de la couleur de l’objet d’affichage par le complément de la couleur d’arrière-plan, ce qui donne un effet de blanchissement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>screen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Multiplie le complément (l’inverse) de la couleur de l’objet d’affichage par le complément de la couleur d’arrière-plan, ce qui donne un effet de blanchissement. Ce réglage est couramment utilisé pour la mise en valeur ou pour supprimer les parties noires de l’objet d’affichage. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SHADER"><apiName>SHADER</apiName><shortdesc>
Utilise un shader pour définir le fondu entre les objets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>shader</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Utilise un shader pour définir le fondu entre les objets.

<p>Définir la propriété <codeph>blendShader</codeph> sur une occurrence Shader définit automatiquement la propriété <codeph>blendMode</codeph> de l’objet d’affichage sur <codeph>BlendMode.SHADER</codeph>. Si la propriété <codeph>blendMode</codeph> est définie sur <codeph>BlendMode.SHADER</codeph> sans que la propriété <codeph>blendShader</codeph> n’ait été définie auparavant, la propriété <codeph>blendMode</codeph> est définie à la place sur <codeph>BlendMode.NORMAL</codeph>. Si la propriété <codeph>blendShader</codeph> est définie (ce qui définit la propriété <codeph>blendMode</codeph> sur <codeph>BlendMode.SHADER</codeph>) et que la valeur de la propriété <codeph>blendMode</codeph> est ensuite modifiée, le mode de fondu peut être réinitialisé pour utiliser le shader de fondu en définissant simplement la propriété <codeph>blendMode</codeph> sur <codeph>BlendMode.SHADER</codeph>. La propriété <codeph>blendShader</codeph> n’a plus besoin d’être définie, sauf pour modifier le shader utilisé afin de définir le mode de fondu.</p>

</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue><apiValue id="flash.display:BlendMode:SUBTRACT"><apiName>SUBTRACT</apiName><shortdesc>
Soustrait les valeurs des couleurs élémentaires de l’objet d’affichage de celles de la couleur d’arrière-plan, en appliquant un plancher de 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subtract</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Soustrait les valeurs des couleurs élémentaires de l’objet d’affichage de celles de la couleur d’arrière-plan, en appliquant un plancher de 0. Ce réglage est habituellement utilisé pour animer un fondu de plus en plus sombre entre deux objets.

<p>Par exemple, si l’objet d’affichage possède un pixel dont la valeur RVB est 0xAA2233, et que le pixel d’arrière-plan a une valeur RVB réglée sur 0xDDA600, alors la valeur RVB obtenue pour le pixel affiché est 0x338400 (car 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84 et 0x00 - 0x33 &lt; 0x00).</p>
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Graphics"><apiName>Graphics</apiName><shortdesc>
 La classe Graphics contient un ensemble de méthodes permettant de créer une forme vectorielle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Graphics contient un ensemble de méthodes permettant de créer une forme vectorielle. Les objets d’affichage qui prennent en charge le dessin incluent les objets Sprite et Shape. Chacune de ces classes comporte une propriété <codeph>graphics</codeph> correspondant à un objet Graphics. Vous trouverez ci-dessous quelques-unes des fonctionnalités d’aide à la visualisation qui sont à votre disposition : <codeph>drawRect()</codeph>, <codeph>drawRoundRect()</codeph>, <codeph>drawCircle()</codeph> et <codeph>drawEllipse()</codeph>.
 
 <p>Il est impossible de créer un objet Graphics directement à partir du code ActionScript. Si vous appelez <codeph>new Graphics()</codeph>, une exception est renvoyée.</p>
 
 <p>La classe Graphics ne gère pas les sous-classes.</p>
 
 
 </apiDesc><example conref="examples\GraphicsExample.as"> L’exemple suivant utilise la classe GraphicsExample pour dessiner un cercle, un rectangle arrondi et un carré. Cette tâche s’accomplit de la façon suivante :
 <ol>
    <li>Elle déclare la propriété <codeph>size</codeph> qui servira par la suite à déterminer la taille de chaque forme.</li>
     <li>Elle déclare les propriétés qui définissent la couleur de fond sur orange, la couleur de bordure sur gris foncé, la taille de la bordure sur 0 pixel, le rayon de l’angle sur 9 pixels et définit l’espace entre le bord de la scène et les autres objets sur 5 pixels.</li>
    <li>Elle utilise les propriétés déclarées au cours des étapes précédentes, ainsi que les méthodes intégrées de la classe Graphics pour dessiner le cercle, le rectangle arrondi et le carré aux coordonnées x = 0, y = 0.</li>
    <li>Elle redessine les formes situées le long de la partie supérieure de la scène, en commençant par x = 5, y = 5, avec un espacement de 5 pixels entre les formes.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class GraphicsExample extends Sprite {
        private var size:uint         = 80;
        private var bgColor:uint      = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function GraphicsExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size / 2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Graphics:beginBitmapFill"><apiName>beginBitmapFill</apiName><shortdesc>
	 Remplit une zone de tracé en utilisant une image bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Image bitmap transparente ou opaque qui contient les bits à afficher.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet matrix (appartenant à la classe flash.geom.Matrix), qui permet de définir les transformations de l’image bitmap. Par exemple, vous pouvez utiliser la matrice suivante pour faire pivoter une image bitmap de 45 degrés (pi/4 radians) :
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Si la valeur est <codeph>true</codeph>, l’image bitmap se reproduit pour former un motif. Si la valeur est <codeph>false</codeph>, l’image bitmap ne se répète pas et les bords de l’image sont utilisés pour tout remplissage qui dépasse l’image. 
	 
	 <p>Considérons par exemple l’image bitmap suivante (un motif en damier de 20 x 20 pixels) :</p>
	 
     <p><adobeimage alt="damier de 20x20 pixels" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
	 
	 <p>Lorsque la propriété <codeph>repeat</codeph> est définie sur <codeph>true</codeph> (comme dans l’exemple suivant), le remplissage bitmap répète l’image bitmap :</p>
	 
     <p><adobeimage alt="damier de 60x60 pixels" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
	 
	 <p>Lorsque la propriété <codeph>repeat</codeph> est définie sur <codeph>false</codeph>, le remplissage bitmap utilise les pixels du bord pour le remplissage en dehors de l’image bitmap :</p>
	 
     <p><adobeimage alt="image de 60x60 pixels sans répétition" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 
   	 
	 </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si la valeur est <codeph>false</codeph>, les images bitmap agrandies sont rendues en appliquant un algorithme d’approximation et ont un aspect pixélisé. Si la valeur est <codeph>true</codeph>, les images bitmap agrandies sont rendues avec un algorithme bilinéaire. Les rendus qui résultent de l’utilisation de l’algorithme d’approximation sont plus rapides.
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Début d’une forme remplie de bitmaps.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Remplit une zone de tracé en utilisant une image bitmap. L’image bitmap peut être répétée ou former une mosaïque afin de remplir la zone. Le remplissage demeure actif jusqu’à ce que vous appeliez la méthode <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginShaderFill()</codeph>. Appeler la méthode <codeph>clear()</codeph> permet d’effacer le remplissage.
	 
	 <p>L’application effectue le remplissage lorsque trois points ou plus sont dessinés, ou lorsque la méthode <codeph>endFill()</codeph> est appelée. </p>
	 
	 </apiDesc><example conref="examples\Graphics_beginBitmapFillExample.as"> L’exemple suivant utilise une image (<codeph>image1.jpg</codeph>), pivotée et répétée pour remplir un rectangle.
 
 <ol>
    <li>Le fichier image (<codeph>image1.jpg</codeph>) est chargé via les objets <codeph>Loader</codeph> et <codeph>URLRequest</codeph>. Ici, le fichier est dans le même répertoire que le fichier SWF. Le fichier SWF doit être compilé avec la Protection de lecture locale définie sur Accéder aux fichiers locaux seulement.</li>
     <li>Dès que l’image est chargée (à la fin de l’<codeph>événement</codeph>), la méthode <codeph>drawImage()</codeph> est appelée. La méthode <codeph>ioErrorHandler()</codeph> écrit un commentaire de suivi si l’image n’a pas été chargée correctement.</li>  
  <li>Dans la méthode <codeph>drawImage()</codeph>, un objet <codeph>BitmapData</codeph> est instancié et sa largeur et sa largeur sont définies en fonction de l’image (<codeph>image1.jpg</codeph>). L’image source est ensuite dessinée dans l’objet BitmapData. Ensuite, un rectangle est tracé dans l’objet Sprite <codeph>mySprite</codeph> et l’objet BitmapData est utilisé pour le remplir. A l’aide d’un objet <codeph>Matrix</codeph>, la méthode <codeph>beginBitmapFill()</codeph> fait pivoter l’image de 45 degrés, puis commence à remplir le rectangle avec l’image jusqu’à ce qu’il soit terminé.</li> 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.geom.Matrix;

    public class Graphics_beginBitmapFillExample extends Sprite {
 
        private var url:String = "image1.jpg";
        private var loader:Loader = new Loader();

        public function Graphics_beginBitmapFillExample() {

            var request:URLRequest = new URLRequest(url);
            
            loader.load(request);
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, drawImage);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function drawImage(event:Event):void {

            var mySprite:Sprite = new Sprite();
            var myBitmap:BitmapData = new BitmapData(loader.width, loader.height, false);
  
            myBitmap.draw(loader, new Matrix());
            
            var matrix:Matrix = new Matrix();
            matrix.rotate(Math.PI/4);
            
            mySprite.graphics.beginBitmapFill(myBitmap, matrix, true);
            mySprite.graphics.drawRect(100, 50, 200, 90);
            mySprite.graphics.endFill();
            
            addChild(mySprite);
        }
 
         private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }   
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginFill"><apiName>beginFill</apiName><shortdesc>
 	 Spécifie un remplissage simple d’une couleur que des appels ultérieurs à d’autres méthodes Graphics (telles que lineTo() ou drawCircle()) utilisent lors du dessin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Couleur du remplissage (0xRRGGBB).
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur alpha du remplissage (de 0.0 à 1.0). 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Spécifie un remplissage d’une couleur.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Spécifie un remplissage simple d’une couleur que des appels ultérieurs à d’autres méthodes Graphics (telles que <codeph>lineTo()</codeph> ou <codeph>drawCircle()</codeph>) utilisent lors du dessin. Le remplissage demeure actif jusqu’à ce que vous appeliez la méthode <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginShaderFill()</codeph>. Appeler la méthode <codeph>clear()</codeph> permet d’effacer le remplissage.
	 
	 <p>L’application effectue le remplissage lorsque trois points ou plus sont dessinés, ou lorsque la méthode <codeph>endFill()</codeph> est appelée.</p>
	 
	 </apiDesc><example>Pour une illustration de l’utilisation de cette méthode, voir l’<xref href="Graphics.html#includeExamplesSummary">exemple</xref> présenté à la fin de ce cours. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginGradientFill"><apiName>beginGradientFill</apiName><shortdesc>
	 Spécifie un remplissage en dégradé utilisé lors des appels suivants d’autres méthodes Graphics (telles que lineTo() ou drawCircle()) associées à l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>type</codeph> n’est pas valide.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la classe GradientType qui spécifie le type de dégradé à utiliser : <codeph>GradientType.LINEAR</codeph> ou <codeph>GradientType.RADIAL</codeph>. 
	 
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau de valeurs de couleurs RVB hexadécimales utilisé pour le dégradé (par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.). Vous pouvez définir jusqu’à 15 couleurs. Pour chaque couleur, définissez une valeur correspondante dans les paramètres alphas et ratios.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Un tableau de valeurs alpha pour les couleurs correspondantes du tableau de couleurs ; les valeurs valides vont de 0 à 1. Si la valeur est inférieure à 0, la valeur par défaut est de 0. Si la valeur est supérieure à 1, la valeur par défaut est de 1.
     
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau de taux de distribution des couleurs ; les valeurs disponibles sont comprises entre 0 et 255. Cette valeur définit le pourcentage de la largeur où la couleur est échantillonnée sur 100 %. La valeur 0 représente la position de gauche dans la zone de dégradés, tandis que 255 représente la position de droite. 
	 
	 <p><b>Remarque :</b> cette valeur représente les positions de la zone de dégradés, plutôt que l’espace de coordonnées du dégradé final, susceptible d’être plus large ou plus étroit que la zone de dégradés. Spécifiez une valeur pour chaque valeur dans le paramètre <codeph>colors</codeph>. </p>
	 
	 <p>Par exemple, pour un dégradé linéaire qui comprend deux couleurs, bleu et vert, l’exemple suivant illustre l’emplacement des couleurs dans le dégradé selon les différentes valeurs du tableau <codeph>ratios</codeph> :</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Dégradé</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
	 	<entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 0 et 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 0 et 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 127 et 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Les valeurs du tableau doivent augmenter de manière séquentielle ; par exemple, <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Matrice de transformation définie par la classe flash.geom.Matrix. La classe flash.geom.Matrix inclut une méthode <codeph>createGradientBox()</codeph>, qui permet de configurer facilement la matrice en vue de son utilisation avec la méthode <codeph>beginGradientFill()</codeph>.
	 
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>Valeur de la classe SpreadMethod qui spécifie la méthode d’étalement à utiliser : <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> ou <codeph>SpreadMethod.REPEAT</codeph>. 
	 
	 <p>Par exemple, considérons un dégradé linéaire simple entre deux couleurs :</p>
	 
	 <codeblock>
	 import flash.geom.*
	 import flash.display.*
	 var fillType:String = GradientType.LINEAR;
	 var colors:Array = [0xFF0000, 0x0000FF];
	 var alphas:Array = [1, 1];
	 var ratios:Array = [0x00, 0xFF];
	 var matr:Matrix = new Matrix();
	 matr.createGradientBox(20, 20, 0, 0, 0);
	 var spreadMethod:String = SpreadMethod.PAD;
	 this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);		
	 this.graphics.drawRect(0,0,100,100);
	 </codeblock>
	 
	 	<p>Cet exemple utilise <codeph>SpreadMethod.PAD</codeph> comme méthode d’étalement, et le remplissage en dégradé prend l’aspect suivant :</p>
	 
      <p><adobeimage alt="dégradé linéaire avec SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
 	 
	 	<p>Si vous utilisez <codeph>SpreadMethod.REFLECT</codeph> comme méthode d’étalement, le remplissage en dégradé prend l’aspect suivant :</p>
 	 
      <p><adobeimage alt="dégradé linéaire avec SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
 	 
	 	<p>Si vous utilisez <codeph>SpreadMethod.REPEAT</codeph> comme méthode d’étalement, le remplissage en dégradé prend l’aspect suivant :</p>
 	 
      <p><adobeimage alt="dégradé linéaire avec SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>Valeur de la classe InterpolationMethod qui spécifie la valeur à utiliser : <codeph>InterpolationMethod.LINEAR_RGB</codeph> ou <codeph>InterpolationMethod.RGB</codeph>
	 
	 <p>Prenons, par exemple, un dégradé linéaire simple entre deux couleurs (le paramètre <codeph>spreadMethod</codeph> étant réglé sur <codeph>SpreadMethod.REFLECT</codeph>). Les différentes méthodes d’interpolation influent sur l’aspect de la façon suivante : </p>
	 
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="dégradé linéaire avec InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="dégradé linéaire avec InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre qui contrôle l’emplacement du point focal du dégradé. La valeur 0 signifie que le point focal est au centre. La valeur 1 signifie que le point focal est au bord du cercle du dégradé. La valeur -1 signifie que le point focal est sur l’autre bord du cercle du dégradé. Toute valeur inférieure à -1 ou supérieure à 1 est arrondie à -1 ou 1. Par exemple, l’exemple suivant affiche un paramètre <codeph>focalPointRatio</codeph> défini sur 0,75 :
	 
     <p><adobeimage alt="dégradé linéaire avec focalPointRatio défini sur 0.75" href="../../images/radial_sketch.jpg"/> </p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Spécifie un remplissage dégradé.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Spécifie un remplissage en dégradé utilisé lors des appels suivants d’autres méthodes Graphics (telles que <codeph>lineTo()</codeph> ou <codeph>drawCircle()</codeph>) associées à l’objet. Le remplissage demeure actif jusqu’à ce que vous appeliez la méthode <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginShaderFill()</codeph>. Appeler la méthode <codeph>clear()</codeph> permet d’effacer le remplissage.
	 
	 <p>L’application effectue le remplissage lorsque trois points ou plus sont dessinés, ou lorsque la méthode <codeph>endFill()</codeph> est appelée. </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginShaderFill"><apiName>beginShaderFill</apiName><shortdesc>
 	 Spécifie un remplissage de shader utilisé lors des appels suivants d’autres méthodes Graphics (telles que lineTo() ou drawCircle()) associées à l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque le type de sortie du shader n’est pas compatible avec cette opération (le shader doit spécifier une sortie <codeph>pixel3</codeph> ou <codeph>pixel4</codeph>).
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque le shader spécifie une entrée d’image non fournie.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsqu’une occurrence de ByteArray ou de Vector.&lt;Number> est utilisée comme entrée et les propriétés <codeph>width</codeph> et <codeph>height</codeph> ne sont pas spécifiées pour le ShaderInput, ou les valeurs spécifiées ne correspondent pas à la quantité de données dans l’objet d’entrée. Voir la propriété <codeph>ShaderInput.input</codeph> pour plus d’informations.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>Shader à utiliser pour le remplissage. Cette occurrence Shader n’est pas obligatoire pour spécifier une entrée d’image. Toutefois, si une entrée d’image est spécifiée dans le shader, elle doit être fournie manuellement. Pour spécifier l’entrée, définissez la propriété <codeph>input</codeph> de la propriété ShaderInput correspondante de la propriété <codeph>Shader.data</codeph>.
	 
	 <p>Lorsque vous transmettez une occurrence Shader sous forme d’argument, le shader est copié en interne. L’opération de remplissage utilise cette copie interne et non une référence au shader d’origine. Toute modification apportée au shader, par exemple la modification de la valeur d’un paramètre, l’entrée ou le pseudo-code binaire, n’est pas appliquée au shader copié utilisé pour le remplissage.</p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet matrice (de la classe flash.geom.Matrix), que vous pouvez utiliser pour définir des transformations sur le shader. Par exemple, vous pouvez utiliser la matrice suivante pour faire pivoter un shader de 45 degrés (pi/4 radians) :
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 <p>Les coordonnées reçues dans le shader sont basées sur la matrice spécifiée dans le paramètre <codeph>matrix</codeph>. Dans le cas d’une matrice par défaut (<codeph>null</codeph>), les coordonnées dans le shader sont en coordonnées de pixel locales qui peuvent être utilisées pour échantillonner une entrée.</p>
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Spécifie un remplissage de shader.
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Spécifie un remplissage de shader utilisé lors des appels suivants d’autres méthodes Graphics (telles que <codeph>lineTo()</codeph> ou <codeph>drawCircle()</codeph>) associées à l’objet. Le remplissage demeure actif jusqu’à ce que vous appeliez la méthode <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginShaderFill()</codeph>. Appeler la méthode <codeph>clear()</codeph> permet d’effacer le remplissage.
	 
	 <p>L’application effectue le remplissage lorsque trois points ou plus sont dessinés, ou lorsque la méthode <codeph>endFill()</codeph> est appelée.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:clear"><apiName>clear</apiName><shortdesc>
     Efface les graphiques dessinés dans l’objet Graphics et réinitialise les réglages de style de trait et de remplissage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Efface les graphiques dessinés dans l’objet Graphics et réinitialise les réglages de style de trait et de remplissage.
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:copyFrom"><apiName>copyFrom</apiName><shortdesc>
	 Copie toutes les commandes de dessin de l’objet Graphics source dans l’objet Graphics appelant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceGraphics</apiItemName><apiOperationClassifier>flash.display:Graphics</apiOperationClassifier><apiDesc>Objet Graphics à partir duquel les commandes de dessin doivent être copiées.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Copie toutes les commandes de dessin de l’objet Graphics source dans l’objet Graphics appelant.
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:curveTo"><apiName>curveTo</apiName><shortdesc>
	 Trace une courbe entre la position actuelle et la position (anchorX, anchorY), en utilisant le style de trait actuel et le point de contrôle spécifié par les coordonnées (controlX, controlY).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position horizontale du point de contrôle par rapport au point d’alignement de l’objet d’affichage parent.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position verticale du point de contrôle par rapport au point d’alignement de l’objet d’affichage parent.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position horizontale du point d’ancrage suivant par rapport au point d’alignement de l’objet d’affichage parent.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position verticale du point d’ancrage suivant par rapport au point d’alignement de l’objet d’affichage parent.  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Dessine une courbe à partir de la position de dessin actuelle jusqu’à (anchorX, anchorY) en utilisant le point de contrôle spécifié par (controlX, controlY).
     
	 
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Dessine une courbe en utilisant le style de trait actuel à partir de la position actuelle jusqu’à (anchorX, anchorY) en utilisant le point de contrôle spécifié par (<codeph>controlX</codeph>, <codeph>controlY</codeph>). La position de dessin actuelle est ensuite définie sur (<codeph>anchorX</codeph>, <codeph>anchorY</codeph>). Si le clip dans lequel vous dessinez intègre du contenu créé à l’aide des outils de dessin Flash, les appels de la méthode <codeph>curveTo()</codeph> sont tracés sous le contenu. Si vous appelez la méthode <codeph>curveTo()</codeph> avant d’appeler la méthode <codeph>moveTo()</codeph>, la position de dessin actuelle prend par défaut la valeur (0, 0). Si l’un des paramètres n’est pas spécifié, cette méthode échoue et la position de dessin actuelle n’est pas modifiée.
	 
	 <p>La courbe dessinée est une courbe de Bézier quadratique. Les courbes de Bézier quadratiques comprennent deux points d’ancrage et un point de contrôle. La courbe interpole les deux points d’ancrage et s’incurve en direction du point de contrôle. </p>
	 
	 <p><adobeimage alt="Bézier quadratique et Bézier cubique" href="../../images/quad_bezier.jpg"/></p>
	 
  	 </apiDesc><example conref="examples\Graphics_curveToExample1.as"> L’exemple suivant dessine un objet circulaire vert avec une largeur et une hauteur de 100 pixels, 250 pixels à droite du point d’alignement (0, 0) de l’objet d’affichage Sprite. 
 <p>Trace quatre courbes pour produire un cercle et le remplir en vert.</p>
   
 <p>Notez que, du fait de la nature quadratique de l’équation Bézier, ce n’est pas un cercle parfait. La meilleure façon de tracer un cercle est d’utiliser la méthode <codeph>drawCircle()</codeph> de la classe Graphics.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_curveToExample1 extends Sprite
    {
        public function Graphics_curveToExample1():void
        {
            var roundObject:Shape = new Shape();

            roundObject.graphics.beginFill(0x00FF00);
            roundObject.graphics.moveTo(250, 0);
            roundObject.graphics.curveTo(300, 0, 300, 50);
            roundObject.graphics.curveTo(300, 100, 250, 100);
            roundObject.graphics.curveTo(200, 100, 200, 50);
            roundObject.graphics.curveTo(200, 0, 250, 0);
            roundObject.graphics.endFill();
            
            this.addChild(roundObject);
        }
    }
}
</codeblock></example><example conref="examples\Graphics_curveToExample2.as"> L’exemple suivant trace une nouvelle lune à l’aide de la méthode <codeph>curveTo()</codeph>.
 
 <p>Deux lignes courbes de 1 pixel sont tracées et l’espace qui les sépare est rempli en blanc. La méthode <codeph>moveTo()</codeph> est utilisée pour placer la position du dessin en cours aux coordonnées (100, 100). La première courbe déplace la position du dessin sur (100, 200), son point de destination. La seconde courbe retourne à la position d’origine (100, 100), son point de destination. Les points de contrôle horizontaux déterminent les différentes tailles des courbes.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_curveToExample2 extends Sprite
    {
        public function Graphics_curveToExample2() {
            var newMoon:Shape = new Shape();
            
            newMoon.graphics.lineStyle(1, 0);
            newMoon.graphics.beginFill(0xFFFFFF);
            newMoon.graphics.moveTo(100, 100); 
            newMoon.graphics.curveTo(30, 150, 100, 200);    
            newMoon.graphics.curveTo(50, 150, 100, 100);
            graphics.endFill();
            
            this.addChild(newMoon);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:drawCircle"><apiName>drawCircle</apiName><shortdesc>
	 Dessine un cercle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Position <i>x</i> du centre du cercle par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> du centre du cercle par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>radius</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Rayon du cercle (en pixels).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Dessine un cercle.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Dessine un cercle. Vous devez définir le remplissage et/ou le style de ligne avant d’appeler la méthode <codeph>drawCircle()</codeph>, à l’aide de la méthode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example>Pour une illustration de l’utilisation de cette méthode, voir l’<xref href="Graphics.html#includeExamplesSummary">exemple</xref> présenté à la fin de ce cours. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawEllipse()"><linktext>drawEllipse()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawEllipse"><apiName>drawEllipse</apiName><shortdesc>
	 Dessine une ellipse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Position <i>x</i> de la partie supérieure gauche du cadre de sélection de l’ellipse par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
	
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> de la partie supérieure gauche du cadre de sélection de l’ellipse par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
	
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Largeur de l’ellipse (en pixels).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Hauteur de l’ellipse (en pixels).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Dessine une ellipse.
         
         </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Dessine une ellipse. Vous devez définir le remplissage et/ou le style de ligne avant d’appeler la méthode <codeph>drawEllipse()</codeph>, à l’aide de la méthode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example conref="examples\Graphics_drawEllipseExample.as"> L’exemple suivant utilise la fonction <codeph>drawEgg()</codeph> pour tracer trois œufs de tailles différentes (trois tailles d’ovale), en fonction du paramètre <codeph>eggSize</codeph>.  
 <ol>
 <li>Le constructeur appelle la fonction <codeph>drawEgg()</codeph> et transmet les paramètres horizontaux et verticaux d’emplacement du traçage des œufs, plus le type d’œuf (<codeph>eggSize</codeph>) (la hauteur et la largeur des œufs (les ovales) peuvent être utilisées pour décider de l’emplacement où ils doivent s’afficher).</li> 
 <li>La fonction <codeph>drawEgg()</codeph> trace les ovales de tailles différentes et les remplit à l’aide de la méthode <codeph>beginFill()</codeph>. Aucune gestion d’erreur avancée n’a été écrite pour sa fonction.</li>
 </ol>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_drawEllipseExample extends Sprite
    {
        public static const SMALL:uint = 0;
        public static const MEDIUM:uint = 1;
        public static const LARGE:uint = 2;

        public function Graphics_drawEllipseExample()
        {
            drawEgg(SMALL, 0, 100);
            drawEgg(MEDIUM, 100, 60);
            drawEgg(LARGE, 250, 35);    
        }

        public function drawEgg(eggSize:uint, x:Number, y:Number):void  {
            
            var myEgg:Shape = new Shape();
            
            myEgg.graphics.beginFill(0xFFFFFF);
            myEgg.graphics.lineStyle(1);

            switch(eggSize) {
                case SMALL:
                    myEgg.graphics.drawEllipse(x, y, 60, 70);
                    break;
                case MEDIUM:
                    myEgg.graphics.drawEllipse(x, y, 120, 150);    
                    break;
                case LARGE:
                    myEgg.graphics.drawEllipse(x, y, 150, 200);
                    break;
                default:
                    trace ("Wrong size! There is no egg.");
                break;            
            }
            
            myEgg.graphics.endFill();
    
            this.addChild(myEgg);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawCircle()"><linktext>drawCircle()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawGraphicsData"><apiName>drawGraphicsData</apiName><shortdesc>
	 Soumet une série d’occurrences IGraphicsData pour le dessin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>graphicsData</apiItemName><apiType value="Vector$flash.display:IGraphicsData"/><apiDesc>Objet Vector contenant des objets graphiques, dont chacun doit implémenter l’interface IGraphicsData.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Soumet une série d’occurrences IGraphicsData pour le dessin. Cette méthode accepte un objet Vector contenant des objets, y compris des tracés, des remplissages et des traits, qui implémentent l’interface IGraphicsData. Un objet Vector des occurrences IGraphicsData peut se reporter à une forme ou à un jeu de données complexe et complètement défini pour restituer une forme complète.
     
     
     <p>
     Les tracés des graphiques peuvent contenir d’autres tracés de graphiques. Si le vecteur <codeph>graphicsData</codeph> inclut un tracé, ce dernier et tous ses sous-tracés sont restitués au cours de cette opération.
     </p>
     
     </apiDesc><example conref="examples\Graphics_DrawGraphicsDataExample.as"> L’exemple suivant crée un objet GraphicsGradientFill pour établir les propriétés de remplissage d’un carré. Ensuite, l’exemple crée une classe d’objet GraphicsStroke (pour l’épaisseur des lignes) et un objet GraphicsSolidFill (pour la couleur des lignes) afin de définir les propriétés de la ligne de bordure du carré. L’exemple crée alors un objet GraphicsPath qui contient les valeurs permettant de dessiner la forme. Tous ces objets sont stockées dans un objet IGraphicsData et transmises à la commande <codeph>drawGraphicsData()</codeph> pour rendre la forme. 
<codeblock>
package{
    import flash.display.*;
    import flash.geom.*;
    
    public class DrawGraphicsDataExample extends Sprite {

    public function DrawGraphicsDataExample(){    

    // establish the fill properties
    var myFill:GraphicsGradientFill = new GraphicsGradientFill();
    myFill.colors = [0xEEFFEE, 0x0000FF];
    myFill.matrix = new Matrix();
    myFill.matrix.createGradientBox(100, 100, 0);
 
    // establish the stroke properties
    var myStroke:GraphicsStroke = new GraphicsStroke(2);
    myStroke.fill = new GraphicsSolidFill(0x000000);
 
    // establish the path properties
    var myPath:GraphicsPath = new GraphicsPath(new Vector.&lt;int>(), new Vector.&lt;Number>());
    myPath.commands.push(1,2,2,2,2);
    myPath.data.push(10,10, 10,100, 100,100, 100,10, 10,10);
 
    // populate the IGraphicsData Vector array
    var myDrawing:Vector.&lt;IGraphicsData> = new Vector.&lt;IGraphicsData>();
    myDrawing.push(myFill, myStroke, myPath);
 
    // render the drawing 
    graphics.drawGraphicsData(myDrawing);
    }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#IGraphicsData"><linktext>flash.display.IGraphicsData</linktext></link><link href="flash.display.xml#GraphicsBitmapFill"><linktext>flash.display.GraphicsBitmapFill</linktext></link><link href="flash.display.xml#GraphicsEndFill"><linktext>flash.display.GraphicsEndFill</linktext></link><link href="flash.display.xml#GraphicsGradientFill"><linktext>flash.display.GraphicsGradientFill</linktext></link><link href="flash.display.xml#GraphicsPath"><linktext>flash.display.GraphicsPath</linktext></link><link href="flash.display.xml#GraphicsShaderFill"><linktext>flash.display.GraphicsShaderFill</linktext></link><link href="flash.display.xml#GraphicsSolidFill"><linktext>flash.display.GraphicsSolidFill</linktext></link><link href="flash.display.xml#GraphicsStroke"><linktext>flash.display.GraphicsStroke</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawPath"><apiName>drawPath</apiName><shortdesc>
	 Soumet une série de commandes pour le dessin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiDesc>Vecteur d’entiers représentant les commandes définies par la classe GraphicsPathCommand. La classe GraphicsPathCommand associe les commandes à des identifiants numériques pour ce tableau vectoriel.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiDesc>Vecteur de nombres où chaque paire de nombres est traitée comme un emplacement de coordonnées (paire x, y). Les valeurs des coordonnées x et y ne sont pas des objets Point ; le vecteur <codeph>data</codeph> correspond à une série de nombres où chaque groupe de deux nombres représente l’emplacement d’une coordonnée. 
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Spécifie la règle d’enroulement à l’aide d’une valeur définie dans la classe GraphicsPathWinding.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Soumet une série de commandes pour le dessin. La méthode <codeph>drawPath()</codeph> utilise les tableaux vectoriels pour regrouper les commandes de dessin individuelles <codeph>moveTo()</codeph>, <codeph>lineTo()</codeph> et <codeph>curveTo()</codeph> dans un seul appel. Les paramètres de la méthode <codeph>drawPath()</codeph> associent des commandes de dessin comportant des paires de valeurs de coordonnées x et y à une direction de dessin. Les commandes de dessin sont des valeurs issues de la classe GraphicsPathCommand. Les paires de valeurs des coordonnées x et y sont des nombres dans un tableau où chaque paire définit un emplacement de coordonnée. La direction de dessin est une valeur issue de la classe GraphicsPathWinding.
     
	 <p>
	 En général, le rendu des dessins sera plus rapide avec la méthode <codeph>drawPath()</codeph> qu’avec une série de méthodes individuelles <codeph>lineTo()</codeph> et <codeph>curveTo()</codeph>. 
	 </p>
     
	 <p>
     La méthode <codeph>drawPath()</codeph> utilise un calcul en virgule flottante afin que la rotation et la mise à l’échelle des formes soient plus précises et donnent de meilleurs résultats. Toutefois, les courbes soumises à l’aide de la méthode <codeph>drawPath()</codeph> peuvent comporter de petites erreurs d’alignement des sous-pixels lorsqu’elles sont utilisées en conjonction avec les méthodes <codeph>lineTo()</codeph> et <codeph>curveTo()</codeph>.
     </p>
     
	 <p>
	 La méthode <codeph>drawPath()</codeph> utilise également des règles légèrement différentes pour le remplissage et le dessin des lignes. Voici ces règles :
     </p>
     
	 <ul>
     <li>Lorsqu’un remplissage est appliqué au rendu d’un tracé :
	  <ul>
          <li>Tout sous-tracé de moins de 3 points n’est pas rendu (cependant, le rendu du trait se produira tout de même, en respectant les règles des traits ci-dessous).</li>
	      <li>Tout sous-tracé qui n’est pas clos (le point de fin n’est pas égal au point de début) est fermé implicitement.</li>
	   </ul>
     </li>
     <li>Lorsqu’un trait est appliqué au rendu d’un tracé :
       <ul>
	     <li>Les sous-tracés peuvent être composés de tout nombre de points.</li>
	     <li>Le sous-tracé n’est jamais implicitement fermé.</li>
        </ul>
     </li>
     </ul>
     
     </apiDesc><example conref="examples\Graphics_DrawPathExample.as"> L’exemple suivant remplit deux objets Vector, puis les transmet à la méthode <codeph>drawPath()</codeph> pour obtenir une étoile bleue. Le premier objet Vector, <codeph>star_commands</codeph>, contient une série d’entiers qui représentent les commandes de dessin de la classe flash.display.GraphicsPathCommand, où la valeur 1 correspond à la commande <codeph>MoveTo()</codeph> et la valeur 2 correspond à la commande <codeph>LineTo()</codeph>. Le deuxième objet Vector, <codeph>star_coord</codeph>, contient 5 jeux de paires de coordonnées x et y. La méthode <codeph>drawPath()</codeph> fait correspondre les commandes avec les positions afin de dessiner une étoile.
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {

    public function DrawPathExample(){

    var star_commands:Vector.&lt;int> = new Vector.&lt;int>(5, true);
    
    star_commands[0] = 1;
    star_commands[1] = 2;
    star_commands[2] = 2;
    star_commands[3] = 2;
    star_commands[4] = 2;

    var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>(10, true);
    star_coord[0] = 66; //x
    star_coord[1] = 10; //y 
    star_coord[2] = 23; 
    star_coord[3] = 127; 
    star_coord[4] = 122; 
    star_coord[5] = 50; 
    star_coord[6] = 10; 
    star_coord[7] = 49; 
    star_coord[8] = 109; 
    star_coord[9] = 127;


    graphics.beginFill(0x003366);
    graphics.drawPath(star_commands, star_coord);

    }

    }
}

</codeblock></example><example conref="examples\Graphics_DrawPathExample2.as"> Dans l’exemple ci-dessus, chaque commande et paire de coordonnées est affecté individuellement pour indiquer leur position dans le tableau, mais elles peuvent être attribuées dans une même instruction. L’exemple suivant dessine le même étoile en affectant les valeurs de chaque tableau dans une seule instruction <codeph>push()</codeph> :
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {
    public function DrawPathExample(){
        var star_commands:Vector.&lt;int> = new Vector.&lt;int>();
        star_commands.push(1, 2, 2, 2, 2);

           var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>();
           star_coord.push(66,10, 23,127, 122,50, 10,49, 109,127);

        graphics.beginFill(0x003366);
        graphics.drawPath(star_commands, star_coord);
    }
    }
}


</codeblock> <b>Remarque :</b> par défaut, la méthode <codeph>drawPath()</codeph> utilise le type d’enroulement pair/impair. Par conséquent, le centre de l’étoile n’est pas rempli. Pour remplir le centre de l’étoile, spécifiez le type d’enroulement non nul du troisième paramètre :
 <codeblock>
 graphics.drawPath(star_commands, star_coord, GraphicsPathWinding.NON_ZERO);
 </codeblock>
 
</example></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRect"><apiName>drawRect</apiName><shortdesc>
	 Dessine un rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>width</codeph> ou <codeph>height</codeph> n’est pas un nombre (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position horizontale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position verticale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Largeur du rectangle (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Hauteur du rectangle (en pixels).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Dessine un rectangle arrondi.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Dessine un rectangle. Vous devez définir le remplissage et/ou le style de ligne avant d’appeler la méthode <codeph>drawRect()</codeph>, à l’aide de la méthode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example>Pour une illustration de l’utilisation de cette méthode, voir l’<xref href="Graphics.html#includeExamplesSummary">exemple</xref> présenté à la fin de ce cours. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRoundRect()"><linktext>drawRoundRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRoundRect"><apiName>drawRoundRect</apiName><shortdesc>
	 Dessine un rectangle arrondi.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>width</codeph>, <codeph>height</codeph>, <codeph>ellipseWidth</codeph> ou <codeph>ellipseHeight</codeph> n’est pas un nombre (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position horizontale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position verticale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Largeur du rectangle arrondi (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Hauteur du rectangle arrondi (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>La largeur de l’ellipse utilisée pour dessiner les coins arrondis (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>La hauteur de l’ellipse utilisée pour dessiner les coins arrondis (en pixels). Facultatif. Si aucune valeur n’est spécifiée, la valeur par défaut correspond à la valeur fournie pour le paramètre <codeph>ellipseWidth</codeph>.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Dessine un rectangle arrondi.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Dessine un rectangle arrondi. Vous devez définir le remplissage et/ou le style de ligne avant d’appeler la méthode <codeph>drawRoundRect()</codeph>, à l’aide de la méthode <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example>Pour une illustration de l’utilisation de cette méthode, voir l’<xref href="Graphics.html#includeExamplesSummary">exemple</xref> présenté à la fin de ce cours. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRect()"><linktext>drawRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawTriangles"><apiName>drawTriangles</apiName><shortdesc>
	 Restitue un ensemble de triangles, généralement pour déformer les images bitmap et leur donner un aspect tridimensionnel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiDesc>Vecteur de nombres où chaque paire de nombres est traitée comme un emplacement de coordonnées (paire x, y). Le paramètre <codeph>vertices</codeph> est requis.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Vecteur d’entiers ou d’index, où chaque groupe de trois index définit un triangle. Si le paramètre <codeph>indexes</codeph> est défini sur null, chaque groupe de trois sommets (six paires de x,y dans le vecteur <codeph>vertices</codeph>) définit un triangle. Sinon, chaque index fait référence à un sommet, ou paire de nombres dans le vecteur <codeph>vertices</codeph>. Par exemple <codeph>indexes[1]</codeph> fait référence à (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>). Le paramètre <codeph>indexes</codeph> est facultatif, mais il permet généralement de réduire le volume des données envoyées et traitées. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Vecteur de coordonnées normalisées utilisées pour appliquer un mappage de texture. Chaque coordonnée fait référence à un point sur l’image bitmap utilisée pour le remplissage. Vous devez disposer d’une coordonnée UV ou UVT par sommet. Dans coordonnées UV, (0,0) est le coin supérieur gauche de l’image bitmap et (1,1) le coin inférieur droit. 
     <p>Si la longueur de ce vecteur est le double de celle du vecteur <codeph>vertices</codeph>, les coordonnées normalisées sont utilisées sans correction de perspective. </p>
     <p>Si la longueur de ce vecteur est le triple de la longueur du vecteur <codeph>vertices</codeph>, la troisième coordonnée est interprétée comme ’t’ (distance séparant l’oeil de la texture dans l’espace visuel). Cela permet au moteur de rendu d’appliquer correctement la perspective lors du mappage des textures en 3D.</p>
     <p>Si le paramètre <codeph>uvtData</codeph> est null, les règles de remplissage normal (et tous types de remplissage) s’appliquent.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Indique si les triangles tournés vers une direction spécifique doivent être restitués. Ce paramètre permet d’éviter de restituer les triangles que la vue en cours ne permet pas de voir. Ce paramètre peut être réglé sur toute valeur définie par la classe TriangleCulling.  
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Restitue un ensemble de triangles, généralement pour déformer les images bitmap et leur donner un aspect tridimensionnel. La méthode <codeph>drawTriangles()</codeph> mappe le remplissage actuel ou un remplissage sur les faces des triangles à l’aide d’un jeu de coordonnées (u,v). 
     <p>
     Tous les types de remplissage peuvent être utilisés, mais si le remplissage possède une matrice de transformation, celle-ci est ignorée.
     </p>
     
     <p>
     Un paramètre <codeph>uvtData</codeph> permet d’améliorer le mappage des textures lorsqu’un remplissage bitmap est utilisé. 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:endFill"><apiName>endFill</apiName><shortdesc>
	 Applique un remplissage aux lignes et aux courbes ajoutées depuis le dernier appel de la méthode beginFill(), beginGradientFill() ou beginBitmapFill().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a square with red fill on the Stage:
	 
	 <listing>
	 this.createEmptyMovieClip("square_mc", this.getNextHighestDepth());
	 square_mc.beginFill(0xFF0000);
	 square_mc.moveTo(10, 10);
	 square_mc.lineTo(100, 10);
	 square_mc.lineTo(100, 100);
	 square_mc.lineTo(10, 100);
	 square_mc.lineTo(10, 10);
	 square_mc.endFill();
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Applique un remplissage aux lignes et aux courbes.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Applique un remplissage aux lignes et aux courbes ajoutées depuis le dernier appel de la méthode <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginBitmapFill()</codeph>. Flash utilise le remplissage spécifié lors de l’appel précédent de la méthode <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>beginBitmapFill()</codeph>. Si la position de dessin actuelle n’est pas égale à la position précédente spécifiée dans une méthode <codeph>moveTo()</codeph> et si un remplissage est défini, le tracé est fermé à l’aide d’une ligne, puis rempli.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineBitmapStyle"><apiName>lineBitmapStyle</apiName><shortdesc>
	 Spécifie une image bitmap à utiliser pour le trait lors du traçage des lignes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Bitmap à utiliser pour le trait.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Matrice de transformation optionnelle définie par la classe flash.geom.Matrix. La matrice peut être utilisée pour redimensionner ou manipuler l’image bitmap d’une manière ou d’une autre avant de l’appliquer au style de ligne.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Indique si l’image bitmap doit être répétée pour former une mosaïque.
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si l’image bitmap doit être lissée.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie une image bitmap à utiliser pour le trait lors du traçage des lignes. 
     
     <p>Le style de ligne de l’image bitmap est utilisé pour les prochains appels aux méthodes Graphics, telles que <codeph>lineTo()</codeph> ou <codeph>drawCircle()</codeph>. Le style de ligne demeure en vigueur jusqu’à ce que vous appeliez les méthodes <codeph>lineStyle()</codeph> ou <codeph>lineGradientStyle()</codeph>, ou de nouveau la méthode <codeph>lineBitmapStyle()</codeph> en spécifiant d’autres paramètres. </p>
     
     <p>Vous pouvez appeler la méthode <codeph>lineBitmapStyle()</codeph> au cours du traçage pour spécifier différents styles pour divers segments de ligne dans un tracé. </p>
     
     <p>Appelez la méthode <codeph>lineStyle()</codeph> avant d’appeler la méthode <codeph>lineBitmapStyle()</codeph> pour activer un trait, sinon la valeur du style de ligne est <codeph>undefined</codeph>.</p>
     
     <p>les appels de la méthode <codeph>clear()</codeph> redéfinissent le style de trait sur <codeph>undefined</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineGradientStyle"><apiName>lineGradientStyle</apiName><shortdesc>
	 Spécifie le dégradé à utiliser pour le trait lors du tracé des lignes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la classe GradientType qui spécifie le type de dégradé à utiliser, GradientType.LINEAR ou GradientType.RADIAL.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau de valeurs de couleurs RVB hexadécimales à utiliser pour le dégradé (par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.).
	 
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Un tableau de valeurs alpha pour les couleurs correspondantes du tableau de couleurs ; les valeurs valides vont de 0 à 1. Si la valeur est inférieure à 0, la valeur par défaut est de 0. Si la valeur est supérieure à 1, la valeur par défaut est de 1.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Tableau de taux de distribution des couleurs ; les valeurs valides sont comprises entre 0 et 255. Cette valeur définit le pourcentage de la largeur où la couleur est échantillonnée sur 100 %. La valeur 0 représente la position de gauche dans la zone de dégradés, tandis que 255 représente la position de droite. Cette valeur représente les positions de la zone de dégradés, plutôt que l’espace de coordonnées du dégradé final, pouvant être plus large ou plus étroit que la zone de dégradés. Spécifiez une valeur pour chaque valeur dans le paramètre <codeph>colors</codeph>. 
	 
	 <p>Par exemple, pour un dégradé linéaire qui comprend deux couleurs, bleu et vert, la figure suivante illustre l’emplacement des couleurs dans le dégradé selon les différentes valeurs du tableau <codeph>ratios</codeph> :</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Dégradé</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 0 et 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des taux de 0 et 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="dégradé linéaire du bleu au vert avec des rapports 127 et 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Les valeurs du tableau doivent augmenter de manière séquentielle ; par exemple, <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
   	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Matrice de transformation définie par la classe flash.geom.Matrix. La classe flash.geom.Matrix inclut une méthode <codeph>createGradientBox()</codeph>, qui permet de configurer facilement la matrice en vue de son utilisation avec la méthode <codeph>lineGradientStyle()</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>Valeur de la classe SpreadMethod qui spécifie la méthode d’étalement à utiliser : 
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="3"><tbody><row><entry align="center"><adobeimage alt="dégradé linéaire avec SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>
      <entry align="center"><adobeimage alt="dégradé linéaire avec SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>
      <entry align="center"><adobeimage alt="dégradé linéaire avec SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>Valeur de la classe InterpolationMethod qui spécifie la valeur à utiliser. Prenons, par exemple, un dégradé linéaire simple entre deux couleurs (le paramètre <codeph>spreadMethod</codeph> étant réglé sur <codeph>SpreadMethod.REFLECT</codeph>). Les différentes méthodes d’interpolation influent sur l’aspect de la façon suivante :
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="dégradé linéaire avec InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="dégradé linéaire avec InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre qui contrôle l’emplacement du point focal du dégradé. La valeur 0 signifie que le point focal est au centre. La valeur 1 signifie que le point focal est au bord du cercle du dégradé. La valeur -1 signifie que le point focal est sur l’autre bord du cercle du dégradé. Toute valeur inférieure à -1 ou supérieure à 1 est arrondie à -1 ou 1. L’image suivante affiche un dégradé avec le paramètre <codeph>focalPointRatio</codeph> défini sur -0,75 :
   	 
     <p><adobeimage alt="dégradé linéaire avec focalPointRatio défini sur 0.75" href="../../images/radial_sketch.jpg"/> </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie le dégradé à utiliser pour le trait lors du tracé des lignes.
     
     <p>Le style de ligne dégradée est utilisé pour tous les appels suivants aux méthodes Graphics, telles que les méthodes <codeph>lineTo()</codeph> ou <codeph>drawCircle()</codeph>. Le style de ligne demeure en vigueur jusqu’à ce que vous appeliez les méthodes <codeph>lineStyle()</codeph> ou <codeph>lineBitmapStyle()</codeph>, ou de nouveau la méthode <codeph>lineGradientStyle()</codeph> en spécifiant d’autres paramètres. </p>
     
     <p>Vous pouvez appeler la méthode <codeph>lineGradientStyle()</codeph> au cours du dessin pour spécifier différents styles pour divers segments de ligne dans un tracé. </p>
     
     <p>Appelez la méthode <codeph>lineStyle()</codeph> avant d’appeler la méthode <codeph>lineGradientStyle()</codeph> pour activer un trait, sinon la valeur du style de ligne est <codeph>undefined</codeph>.</p>
     
     <p>les appels de la méthode <codeph>clear()</codeph> redéfinissent le style de trait sur <codeph>undefined</codeph>.
     </p>
	 
	 </apiDesc><example conref="examples\Graphics_lineGradientStyleExample.as"> L’exemple suivant trace un rectangle et un cercle qui utilisent un contour dégradé du rouge au bleu en passant par le vert.
 
 <p>La méthode <codeph>createGradientBox()</codeph> de la classe <codeph>Matrix</codeph> est utilisée pour définir la zone de dégradé sur une largeur de 200 et une hauteur de 40. L’épaisseur de la ligne est définie sur 5 pixels. L’épaisseur du contour doit être définie pour la méthode <codeph>lineGradientStyle()</codeph>. Le dégradé est défini sur linéaire. Les couleurs du dégradé sont définies sur rouge, vert et bleu. La transparence (valeur alpha) des couleurs est définie sur 1 (opaque). La distribution du dégradé est régulière, avec des couleurs allant de 100 % à 0 (à gauche de la zone de dégradé), 128 (centre de la zone) et 255 (à droite de la zone). La largeur du rectangle couvre tout le spectre du dégradé, alors que le cercle en couvre 50 % depuis le centre du spectre.</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    import flash.geom.Matrix; 
    import flash.display.GradientType;
    
    public class Graphics_lineGradientStyleExample extends Sprite
    {
        public function Graphics_lineGradientStyleExample()
        {
            var myShape:Shape = new Shape();
            var gradientBoxMatrix:Matrix = new Matrix();
  
            gradientBoxMatrix.createGradientBox(200, 40, 0, 0, 0);  
            
            myShape.graphics.lineStyle(5);
  
            myShape.graphics.lineGradientStyle(GradientType.LINEAR, [0xFF0000,
            0x00FF00, 0x0000FF], [1, 1, 1], [0, 128, 255], gradientBoxMatrix);
            
            myShape.graphics.drawRect(0, 0, 200, 40);
            myShape.graphics.drawCircle(100, 120, 50);  
             
            this.addChild(myShape);
    
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineShaderStyle"><apiName>lineShaderStyle</apiName><shortdesc>
	 Spécifie un shader à utiliser pour le trait lors du traçage des lignes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>Shader à utiliser pour le trait.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Matrice de transformation optionnelle définie par la classe flash.geom.Matrix. La matrice peut être utilisée pour redimensionner ou manipuler l’image bitmap d’une manière ou d’une autre avant de l’appliquer au style de ligne.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie un shader à utiliser pour le trait lors du traçage des lignes. 
     
     <p>Le style de ligne du shader est utilisé pour les prochains appels aux méthodes Graphics, telles que <codeph>lineTo()</codeph> ou <codeph>drawCircle()</codeph>. Le style de ligne demeure en vigueur jusqu’à ce que vous appeliez les méthodes <codeph>lineStyle()</codeph> ou <codeph>lineGradientStyle()</codeph>, ou de nouveau la méthode <codeph>lineBitmapStyle()</codeph> en spécifiant d’autres paramètres. </p>
     
     <p>Vous pouvez appeler la méthode <codeph>lineShaderStyle()</codeph> au cours du tracé afin de spécifier différents styles pour divers segments de ligne dans un tracé. </p>
     
     <p>Appelez la méthode <codeph>lineStyle()</codeph> avant d’appeler la méthode <codeph>lineShaderStyle()</codeph> pour activer un trait, sinon la valeur du style de ligne est <codeph>undefined</codeph>.</p>
     
     <p>les appels de la méthode <codeph>clear()</codeph> redéfinissent le style de trait sur <codeph>undefined</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineStyle"><apiName>lineStyle</apiName><shortdesc>
     Spécifie le style de ligne utilisé pour les prochains appels aux méthodes Graphics, telles que lineTo() ou drawCircle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following code draws a triangle with a 5-pixel, solid magenta line with 
	 no fill, with pixel hinting, no stroke scaling, no caps, and miter joints with 
	 <code>miterLimit</code> set to 1:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", this.getNextHighestDepth());
	 triangle_mc.lineStyle(5, 0xff00ff, 100, true, "none", "round", "miter", 1);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 </listing>
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Un entier qui indique l’épaisseur de la ligne en points ; les valeurs disponibles sont comprises entre 0 et 255. Si aucun nombre n’est spécifié, ou si le paramètre n’est pas défini, aucune ligne n’est dessinée. Si une valeur inférieure à 0 est transmise, la valeur par défaut est de 0. 0 correspond à l’épaisseur minimale et 255 à l’épaisseur maximale. Si la valeur transmise est supérieure à 255, la valeur par défaut est de 255. 
     
     </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur hexadécimale de la couleur de la ligne (par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.). Si aucune valeur n’est indiquée, la valeur par défaut correspond à 0x000000 (noir). Facultatif. 
	 
 	 
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Un nombre qui indique la valeur alpha de la couleur de la ligne. Les valeurs valides vont de 0 à 1. Si aucune valeur n’est indiquée, la valeur par défaut est de 1 (uni). Si la valeur est inférieure à 0, la valeur par défaut est de 0. Si la valeur est supérieure à 1, la valeur par défaut est de 1. 
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Valeur booléenne qui permet d’ajouter des indices supplémentaires de lissage des pixels. Cette valeur affecte à la fois la position des ancres de courbe et la taille du trait. Avec <codeph>pixelHinting</codeph> réglé sur <codeph>true</codeph>, les largeurs de lignes sont réglées sur des largeurs de pixels entières . Si <codeph>pixelHinting</codeph> est défini sur <codeph>false</codeph>, les courbes et les lignes droites risquent de ne pas être continues. Les exemples ci-dessous illustrent comment Flash Player ou Adobe AIR effectue le rendu de deux rectangles arrondis identiques à une exception près : le réglage du paramètre <codeph>pixelHinting</codeph> utilisé par la méthode <codeph>lineStyle()</codeph> (les images sont mises à l’échelle 200 %, pour mettre en évidence la différence) :
	 
	 <p><adobeimage alt="pixelHinting false et pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
	 
	 <p>Si vous ne spécifiez pas de valeur, la ligne n’utilise pas les indices de lissage des pixels.</p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>Valeur de la classe LineScaleMode qui spécifie le mode d’échelle à utiliser :
	 
	 <ul>
	 
	 <li>
	 <codeph>LineScaleMode.NORMAL</codeph> — Redimensionne toujours l’épaisseur du trait si l’objet est redimensionné (valeur par défaut).
	 </li>
	 
	 <li>
	 <codeph>LineScaleMode.NONE</codeph> — Ne redimensionne jamais l’épaisseur du trait.
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.VERTICAL</codeph> — N’ajuste pas l’épaisseur du trait si l’objet est redimensionné verticalement <i>uniquement</i>. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.VERTICAL</codeph>. Le cercle de gauche est redimensionné verticalement uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale :
	 
     <p><adobeimage alt="Un cercle redimensionné verticalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	 
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.HORIZONTAL</codeph> — N’ajuste pas l’épaisseur du trait si l’objet est redimensionné horizontalement <i>uniquement</i>. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.HORIZONTAL</codeph>. Le cercle de gauche est redimensionné horizontalement uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale :
	 
     <p><adobeimage alt="Un cercle redimensionné horizontalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	 
	 </li>
	 
	 
	 </ul>
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur de la classe CapsStyle qui spécifie le type d’extrémité au bout des lignes. Les valeurs possibles sont les suivantes : <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> et <codeph>CapsStyle.SQUARE</codeph>. En l’absence de valeur, Flash utilise des extrémités rondes. 
	 <p>Par exemple, l’illustration suivante présente les différents réglages <codeph>capsStyle</codeph>. Pour chaque paramètre, l’illustration présente une ligne bleue dont l’épaisseur est de 30 (pour laquelle <codeph>capsStyle</codeph> s’applique), et une ligne noire superposée dont l’épaisseur est de 1 (pour laquelle aucun <codeph>capsStyle</codeph> ne s’applique) :
	 </p>
	 <p><adobeimage alt="NONE, ROUND et SQUARE" href="../../images/linecap.jpg"/></p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur de la classe JointStyle qui spécifie le type d’apparence de liaison utilisé dans les angles. Les valeurs possibles sont les suivantes : <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> et <codeph>JointStyle.ROUND</codeph>. En l’absence de valeurs, Flash utilise des liaisons rondes. 
	 
	 <p>Par exemple, l’illustration suivante présente les différents réglages <codeph>joints</codeph>. Pour chaque paramètre, l’illustration présente une ligne bleue en angle dont l’épaisseur est de 30 (pour laquelle <codeph>jointStyle</codeph> s’applique), et une ligne noire en angle superposée dont l’épaisseur est de 1 (pour laquelle aucun <codeph>jointStyle</codeph> ne s’applique) :
	 </p>
	 
     <p><adobeimage alt="MITER, ROUND et BEVEL" href="../../images/linejoin.jpg"/></p>
	 
	 <p><b>Remarque :</b> Pour les paramètres <codeph>joints</codeph> définis sur <codeph>JointStyle.MITER</codeph>, vous pouvez utiliser le paramètre <codeph>miterLimit</codeph> pour limiter la longueur de la pointe.</p>
 	 
	 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3</apiData><apiDesc>Nombre qui indique la limite à laquelle une pointe est coupée. Les valeurs disponibles sont comprises entre 1 et 255 (et les valeurs qui excèdent cette plage sont arrondies à 1 ou 255). Cette valeur n’est utilisée que si <codeph>jointStyle</codeph> est défini sur <codeph>"miter"</codeph>. La valeur <codeph>miterLimit</codeph> représente la longueur maximale d’une pointe au-delà du point où les lignes se rencontrent pour former une liaison. La valeur exprime un facteur du paramètre <codeph>thickness</codeph> de la ligne. Par exemple, avec un facteur <codeph>miterLimit</codeph> de 2,5 et une valeur de <codeph>thickness</codeph> de 10 pixels, la pointe est coupée à 25 pixels. 
	 
	 <p>Par exemple, les lignes d’angle suivantes dessinent un objet avec un paramètre <codeph>thickness</codeph> d’une valeur de 20, mais un paramètre <codeph>miterLimit</codeph> défini sur 1, 2 et 4. Les lignes de référence noires sont surimposées et indiquent les points de rencontre des pointes :</p>
	 
     <p><adobeimage alt="lignes avec miterLimit défini sur 1, 2 et 4" href="../../images/miterLimit.jpg"/></p>
	 
	 <p>Notez qu’une valeur <codeph>miterLimit</codeph> donnée possède un angle maximal spécifique pour lequel la pointe est coupée. Vous trouverez quelques exemples dans le tableau suivant :</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>Valeur <codeph>miterLimit</codeph> :</entry><entry>Les angles inférieurs aux valeurs indiquées sont coupés :</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 degrés</entry></row><row><entry>2</entry>      <entry>60 degrés</entry></row><row><entry>4</entry>      <entry>30 degrés</entry></row><row><entry>8</entry>      <entry>15 degrés</entry></row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Spécifie le style de trait utilisé par Flash pour tracer des lignes.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Spécifie le style de ligne utilisé pour les prochains appels aux méthodes Graphics, telles que <codeph>lineTo()</codeph> ou <codeph>drawCircle()</codeph>. Le style de trait demeure en vigueur jusqu’à l’appel de la méthode <codeph>lineGradientStyle()</codeph>, <codeph>lineBitmapStyle()</codeph> ou <codeph>lineStyle()</codeph> en spécifiant d’autres paramètres. 
     
     <p>Vous pouvez appeler la méthode <codeph>lineStyle()</codeph> au cours du traçage afin de spécifier des styles différents pour les divers segments de ligne dans le tracé.</p> 
	 
	 <p><b>Remarque : </b>les appels de la méthode <codeph>clear()</codeph> redéfinissent le style de trait sur <codeph>undefined</codeph>.</p>
     
	 </apiDesc><example>Consultez l’exemple de la méthode <xref href="Graphics.html#lineTo()">lineTo()</xref> ou <xref href="Graphics.html#moveTo()">moveTo()</xref> pour voir des illustrations de l’utilisation de la méthode <codeph>getStyle()</codeph>. 
     
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineBitmapStyle"><linktext>lineBitmapStyle</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle"><linktext>lineGradientStyle</linktext></link><link href="flash.display.xml#LineScaleMode"><linktext>LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>JointStyle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineTo"><apiName>lineTo</apiName><shortdesc>
	 Trace une ligne en utilisant le style de trait actuel à partir de la position de dessin actuelle jusqu’à (x, y) ; la position de dessin actuelle est ensuite définie sur (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill.
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position horizontale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position verticale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Dessine une ligne de la position de dessin actuelle vers (x, y).
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Trace une ligne en utilisant le style de trait actuel à partir de la position de dessin actuelle jusqu’à (<codeph>x</codeph>, <codeph>y</codeph>) ; la position de dessin actuelle est ensuite réglée sur (<codeph>x</codeph>, <codeph>y</codeph>). Si l’objet d’affichage dans lequel vous effectuez le traçage possède un contenu créé à l’aide des outils de dessin Flash, les appels de la méthode <codeph>lineTo()</codeph> sont tracés sous le contenu. Si vous appelez <codeph>lineTo()</codeph> avant d’appeler la méthode <codeph>moveTo()</codeph>, la position de dessin par défaut prend la valeur (<i>0, 0</i>). Si l’un des paramètres n’est pas spécifié, cette méthode échoue et la position de dessin actuelle n’est pas modifiée.
	 
	 </apiDesc><example conref="examples\Graphics_lineToExample.as"> L’exemple suivant trace un trapèze via la méthode <codeph>lineTo()</codeph>, en commençant aux pixels (100, 100). 
 <p>L’épaisseur des lignes est définie sur 10 pixels, la couleur est dorée et opaque, les extrémités des lignes sont définies sur aucun (car toutes les lignes se rejoignent) et la jonction entre les lignes est définie sur <codeph>MITER</codeph> avec une limite de pointe définie sur 10, pour obtenir des angles pointus.</p>     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.LineScaleMode;
    import flash.display.CapsStyle;
    import flash.display.JointStyle;
    import flash.display.Shape;


    public class Graphics_lineToExample extends Sprite {

        public function Graphics_lineToExample() {

            var trapezoid:Shape = new Shape();    

            trapezoid.graphics.lineStyle(10, 0xFFD700, 1, false, LineScaleMode.VERTICAL,
                               CapsStyle.NONE, JointStyle.MITER, 10);

            trapezoid.graphics.moveTo(100, 100);
 
            trapezoid.graphics.lineTo(120, 50);
            trapezoid.graphics.lineTo(200, 50);
            trapezoid.graphics.lineTo(220, 100);
            trapezoid.graphics.lineTo(100, 100); 

            this.addChild(trapezoid);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:moveTo"><apiName>moveTo</apiName><shortdesc>
     Déplace la position de dessin actuelle vers (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
	 
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position horizontale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre indiquant la position verticale par rapport au point d’alignement de l’objet d’affichage parent (en pixels).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Déplace la position de dessin actuelle vers (x, y).
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Déplace la position de dessin actuelle vers (<codeph>x</codeph>, <codeph>y</codeph>). Si l’un des paramètres n’est pas spécifié, cette méthode échoue et la position de dessin actuelle n’est pas modifiée.
     
	 </apiDesc><example conref="examples\Graphics_moveToExample.as"> L’exemple suivant trace une ligne pointillée de trois pixels d’épaisseur à l’aide des méthodes <codeph>moveTo()</codeph> et <codeph>lineTo()</codeph>.
 
 <p>Via la méthode <codeph>lineStyle()</codeph>, 
l’épaisseur de la ligne est définie sur 3 pixels. Elle est également définie pour ne pas changer d’échelle. La couleur est définie sur le rouge avec 25 pour cent d’opacité. La propriété <codeph>CapsStyle</codeph> est définie sur carré (le rond est défini par défaut).</p>
 
 <p><codeph>Graphics_moveToExample</codeph> étant une occurrence de la classe <codeph>Sprite</codeph>, elle a accès à toutes les méthodes de la classe Graphics. Les méthodes de la classe Graphics ne peuvent pas être utilisées pour dessiner directement sur l’objet Sprite <codeph>Graphic_moveToExample</codeph>. Toutefois, le fait de ne pas placer l’objet de traçage du vecteur dans une <codeph>forme</codeph> limite les possibilités de gestion, de déplacement et de modification.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.CapsStyle;
    import flash.display.LineScaleMode;

    public class Graphics_moveToExample extends Sprite
    {
        public function Graphics_moveToExample() {
            
            graphics.lineStyle(3, 0x990000, 0.25, false, 
                            LineScaleMode.NONE, CapsStyle.SQUARE);

            graphics.moveTo(10, 20);
            graphics.lineTo(20, 20);
            graphics.moveTo(30, 20);
            graphics.lineTo(50, 20);
            graphics.moveTo(60, 20);
            graphics.lineTo(80, 20);
            graphics.moveTo(90, 20);
            graphics.lineTo(110, 20);            
            graphics.moveTo(120, 20);
            graphics.lineTo(130, 20);           
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.display:NativeWindowType"><apiName>NativeWindowType</apiName><shortdesc>
	 La classe NativeWindowType définit des constantes pour la propriété type de l’objet NativeWindowInitOptions utilisée pour créer une fenêtre native.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe NativeWindowType définit des constantes pour la propriété <codeph>type</codeph> de l’objet NativeWindowInitOptions utilisée pour créer une fenêtre native.
	 
	 <p><b>Remarque :</b> la valeur type est spécifiée lorsqu’une fenêtre est créée et ne peut pas être modifiée.</p>
	 	  
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowType:LIGHTWEIGHT"><apiName>LIGHTWEIGHT</apiName><shortdesc>
		 Une fenêtre légère.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lightweight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Une fenêtre légère.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
		 Une fenêtre classique.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Une fenêtre classique.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:UTILITY"><apiName>UTILITY</apiName><shortdesc>
		 Une fenêtre d’utilitaire.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>utility</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Une fenêtre d’utilitaire.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowDisplayState"><apiName>NativeWindowDisplayState</apiName><shortdesc>
     La classe NativeWindowDisplayState définit des constantes pour les noms des états d’affichage de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     La classe NativeWindowDisplayState définit des constantes pour les noms des états d’affichage de la fenêtre.
     
     <p><b>Remarque :</b> les modes plein écran sont définis à l’aide de la propriété <codeph>displayState</codeph> de l’objet Stage et non via la propriété <codeph>displaySate</codeph> de la fenêtre.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link></related-links><apiValue id="flash.display:NativeWindowDisplayState:MAXIMIZED"><apiName>MAXIMIZED</apiName><shortdesc>
         L’état d’affichage agrandi.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>maximized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         L’état d’affichage agrandi.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:MINIMIZED"><apiName>MINIMIZED</apiName><shortdesc>
         L’état d’affichage réduit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>minimized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         L’état d’affichage réduit.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
         L’état d’affichage normal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         L’état d’affichage normal.
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Screen"><apiName>Screen</apiName><shortdesc>
	 La classe Screen fournit des informations sur les écrans d’affichage disponibles pour cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe Screen fournit des informations sur les écrans d’affichage disponibles pour cette application.
	 
	 <p>Les écrans sont des zones de bureau indépendantes au sein d’un « bureau virtuel » si possible plus grand. L’origine du bureau virtuel est l’angle supérieur gauche de l’écran principal conçu par le système d’exploitation. Par conséquent, les coordonnées pour les limites d’un écran d’affichage individuel peuvent être négatives. Il peut également y avoir des zones du bureau virtuel situées en dehors des écrans d’affichage.</p>
	 
	 <p>La classe Screen comprend des membres de classe statiques permettant d’accéder aux objets screen disponibles et des membres d’occurrence permettant d’accéder aux propriétés d’un écran individuel. Les informations d’écran ne doivent pas être mises en mémoire cache car un utilisateur peut les modifier à tout moment.</p>
	  
	 <p>Il n’existe pas forcément de correspondance univoque entre des écrans et les moniteurs physiques raccordés à un ordinateur. Par exemple, deux moniteurs peuvent afficher le même écran.</p>
	 
	 <p>Il est impossible d’instancier directement la classe Screen. Les appels au constructeur <codeph>new Screen()</codeph> renvoient une exception <codeph>ArgumentError</codeph>.</p>
	 
	 </apiDesc><example conref="examples\ScreenExample.as"> L’exemple suivant définit une classe DockingWindow pour créer une fenêtre qui se fixe sur les côtés de l’écran. Pour ce faire, procédez comme suit :
 
 <ol>
     <li>En répondant aux événements de clavier pour déterminer sur quel côté de l’écran fixer la fenêtre.</li>
 
    <li>En accédant à la méthode de la classe Screen statique <codeph>getScreensForRectangle()</codeph> pour obtenir l’objet Screen pour l’écran sur lequel la fenêtre est actuellement affichée.</li>
 
    <li>En redéfinissant les limites de la fenêtre selon les dimensions de l’écran.</li>
 
    <li>En retraçant le contenu de la fenêtre en fonction des nouvelles dimensions de la fenêtre.</li>
 
 </ol>
 
 <p>Cette classe ne doit pas être utilisée comme classe racine d’une application AIR avec les paramètres <codeph>SystemChrome="none"</codeph> et <codeph>transparent="true"</codeph>. Pour utiliser cette classe dans une fenêtre avec chrome système, vous devez tenir compte de l’épaisseur du chrome et de la largeur minimale de la fenêtre lorsque vous calculez l’emplacement et la taille de cette dernière.</p>
<codeblock>

package
{
    import flash.display.Screen;
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.KeyboardEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;

    public class DockingWindow extends Sprite
    {
        private const dockedWidth:uint = 80;
        private const dockedHeight:uint = 80;
        
        public function DockingWindow():void{
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onKey);
            dockLeft();
        }
        
        private function onKey(event:KeyboardEvent):void{
            switch(event.keyCode){
                case Keyboard.LEFT :
                    dockLeft();
                    break;
                case Keyboard.RIGHT :
                    dockRight();
                    break;
                case Keyboard.UP :
                    dockTop();
                    break;
                case Keyboard.DOWN :
                    dockBottom();
                    break;
                case Keyboard.SPACE :
                    stage.nativeWindow.close();
            }    
        }
        
        public function dockLeft():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.height = screen.visibleBounds.height;
            stage.stageWidth = dockedWidth;
            drawContent();
        }
        
        public function dockRight():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.width - dockedWidth;            
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.stageWidth = dockedWidth;
            stage.nativeWindow.height = screen.visibleBounds.height;
            drawContent();
        }
        
        public function dockTop():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;
            drawContent();
        }
        
        public function dockBottom():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.height - dockedHeight;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;    
            drawContent();        
        }
        
        private function getCurrentScreen():Screen{
            return Screen.getScreensForRectangle(stage.nativeWindow.bounds)[0];
        }
        
        private function drawContent():void{
            const size:int = 60;
            const pad:int = 10;
            var numHSquares:int = Math.floor(stage.stageWidth/(size + pad));
            var numVSquares:int = Math.floor(stage.stageHeight/(size + pad));
            with (graphics){
                clear();
                lineStyle(1);
                beginFill(0x3462d5,.7);
                for(var i:int = 0; i &lt; numHSquares; i++){
                    for(var j:int = 0; j &lt; numVSquares; j++){                
                            drawRect((i * (size + pad)) + pad, (j * (size + pad)) + pad, size, size);
                    }
                }
                endFill();
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Screen:getScreensForRectangle"><apiName>getScreensForRectangle</apiName><shortdesc>
		 Renvoie l’ensemble (éventuellement vide) d’écrans qui croisent le rectangle fourni.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Tableau d’objets Screen qui contient les écrans comportant une partie de la zone définie par le paramètre <codeph>rect</codeph>.
		 
		 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle avec des coordonnées par rapport à l’origine du bureau virtuel, c’est-à-dire l’angle supérieur gauche de l’écran principal.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Renvoie l’ensemble (éventuellement vide) d’écrans qui croisent le rectangle fourni.
		  
		 </apiDesc><example conref="examples\Screen.getScreensForRectangle.1.as"> L’exemple suivant indique comment obtenir le tableau d’écrans contenant au moins une partie d’un rectangle donné :
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var rect:Rectangle = new Rectangle(-200, 100, 1000, 600);
var intersectedScreens:Array = Screen.getScreensForRectangle(rect);
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:Screen:bounds:get"><apiName>bounds</apiName><shortdesc>
		 Limites de cet écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 Limites de cet écran.
		 
		 <p>L’emplacement de l’écran est relatif au bureau virtuel.</p>
		 
		 </apiDesc><example conref="examples\Screen.bounds.1.as"> L’exemple suivant indique comment obtenir les limites d’un écran (dans ce cas, l’écran d’affichage principal) :
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.bounds;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:colorDepth:get"><apiName>colorDepth</apiName><shortdesc>
		 Profondeur des couleurs de cet écran (en nombre de bits).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Profondeur des couleurs de cet écran (en nombre de bits).
		 
		 </apiDesc><example conref="examples\Screen.colorDepth.1.as"> L’exemple suivant indique comment obtenir la profondeur des couleurs d’un écran (dans ce cas, l’écran d’affichage principal) :
<codeblock>

var mainScreen:Screen = Screen.mainScreen;
var colors:uint = mainScreen.colorDepth;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:mainScreen:get"><apiName>mainScreen</apiName><shortdesc>
		 L’écran principal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Screen</apiValueClassifier></apiValueDef><apiDesc>
		 L’écran principal.
		 
		 </apiDesc><example conref="examples\Screen.mainScreen.1.as"> L’exemple suivant indique comment obtenir l’objet Screen représentant l’écran « principal » de cet ordinateur :
<codeblock>

var primaryScreen:Screen = Screen.mainScreen;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:screens:get"><apiName>screens</apiName><shortdesc>
		 Tableau des écrans actuellement disponibles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3."/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 Tableau des écrans actuellement disponibles. 
		 
		 <p>La modification du tableau renvoyé n’a aucune incidence sur les écrans disponibles.</p>
		 
		 </apiDesc><example conref="examples\Screen.screens.1.as"> L’exemple suivant indique comment obtenir le tableau contenant les écrans disponibles :
<codeblock>

var screenArray:Array = Screen.screens;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:visibleBounds:get"><apiName>visibleBounds</apiName><shortdesc>
		 Limites de la zone de cet écran dans lesquelles les fenêtres peuvent être visibles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 Limites de la zone de cet écran dans lesquelles les fenêtres peuvent être visibles.
		 
		 <p>La propriété <codeph>visibleBounds</codeph> d’un écran exclut la barre des tâches (et autres barres fixes du bureau) sous Windows, et sous Mac OS X, la barre de menu ainsi que le Dock selon les paramètres système. Certaines configurations sous Linux ne permettent pas de déterminer les limites visibles. Dans ce cas, la propriété <codeph>visibleBounds</codeph> renvoie les mêmes valeurs que la propriété <codeph>screenBounds</codeph>.</p>
		 
		 </apiDesc><example conref="examples\Screen.usableBounds.1.as"> L’exemple suivant indique comment obtenir les limites utilisables d’un écran (dans ce cas, l’écran d’affichage principal) :
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.visibleBounds;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Bitmap"><apiName>Bitmap</apiName><shortdesc>
 La classe Bitmap représente les objets d’affichage qui représentent les images bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Représente les objets d’affichage dérivés des images.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Bitmap représente les objets d’affichage qui représentent les images bitmap. Ces images peuvent être chargées avec la classe flash.display.Loader ou créées à l’aide du constructeur <codeph>Bitmap()</codeph>. 
 
 <p>Le constructeur <codeph>Bitmap()</codeph> vous permet de créer un objet Bitmap contenant une référence à un objet BitmapData. Après avoir créé un objet Bitmap, utilisez la méthode <codeph>addChild()</codeph> ou <codeph>addChildAt()</codeph> de l’occurrence parent de DisplayObjectContainer pour placer cet objet dans la liste d’affichage.</p>
 
 <p>Un objet Bitmap peut partager ses références BitmapData entre plusieurs objets Bitmap, indépendamment des propriétés de translation ou de rotation. La création de plusieurs objets Bitmap référençant un même objet BitmapData étant possible, plusieurs objets d’affichage peuvent utiliser le même objet BitmapData complexe sans faire appel aux ressources supplémentaires de mémoire requises par un objet BitmapData pour chaque occurrence d’objet d’affichage.</p>
 
 <p>Un objet BitmapData peut être dessiné à l’écran par un objet Bitmap de deux façons : avec le rendu vectoriel en tant que forme de remplissage de bitmap, ou en exécutant une routine de copie de pixels plus rapide. La routine de copie de pixels est nettement plus rapide que la fonctionnalité de rendu vectoriel, mais l’objet Bitmap doit satisfaire à certaines exigences pour y faire appel :</p>
 
 <ul>
 
 <li> L’objet Bitmap ne peut pas subir d’étirement, de rotation ou d’inclinaison.</li>
 <li> L’objet Bitmap ne peut pas subir de transformation des couleurs. </li>
 <li> Aucun mode de fondu ne peut être appliqué à l’objet Bitmap. </li>
 <li> Aucun découpage n’est effectué par le biais de calques de masque ou de méthodes <codeph>setMask()</codeph>. </li>
 <li> L’image en tant que telle ne doit pas être un masque. </li>
 <li> Les coordonnées de destination ne doivent pas correspondre à la limite d’un pixel entier. </li>
 
 </ul>
 
 <p>Si vous chargez un objet Bitmap provenant d’un autre domaine que celui de l’objet Loader utilisé pour charger l’image et qu’aucun fichier de régulation d’URL n’autorise l’accès au domaine de l’objet Loader, un script de ce domaine ne peut accéder ni à l’objet Bitmap, ni à ses propriétés et méthodes. Pour plus d’informations, voir les références suivantes :</p>
 
 <ul>
 
 <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
 </ul>
 
 
 <p><b>Remarque :</b> la classe Bitmap n’étant pas une sous-classe de la classe InteractiveObject, elle ne peut pas distribuer d’événement de souris. Vous pouvez cependant utiliser la méthode <codeph>addEventListener()</codeph> du conteneur d’objet d’affichage qui contient l’objet Bitmap.</p>
 
 </apiDesc><example conref="examples\BitmapExample.as"> L’exemple suivant utilise la classe BitmapDataExample pour charger le fichier « Image.gif » dans DisplayObject à l’emplacement par défaut (<i>x = 0, y = 0</i>). Une copie d’Image.gif est ensuite placée à droite de l’original, qui applique de nouvelles couleurs aux pixels qui répondent aux critères définis par la méthode <codeph>threshold()</codeph>. Cette tâche s’accomplit de la façon suivante :
 <ol>
  <li>Une propriété <codeph>url</codeph> est créée pour désigner l’emplacement et le nom du fichier d’image.</li>
  <li>Le constructeur de classe appelle la méthode <codeph>configureAssets()</codeph>, qui en retour appelle la méthode <codeph>completeHandler()</codeph>.</li>
  <li><codeph>configureAssets()</codeph> crée un objet Loader, qui crée à son tour un écouteur d’événements, qui est transmis lorsque <codeph>completeHandler()</codeph> termine la manipulation de l’image.</li>
  <li>Ensuite, la méthode <codeph>buildChild()</codeph> crée une occurrence d’objet URLRequest, <codeph>request</codeph>, et transmet le paramètre <codeph>url</codeph> de façon à identifier le nom de fichier et son emplacement.</li>
  <li>L’objet <codeph>request</codeph> est ensuite transmis à la méthode <codeph>loader.load()</codeph>, qui charge l’image en mémoire à l’aide d’un objet d’affichage.</li>
  <li>L’image est ensuite placée dans la liste d’affichage, qui affiche rapidement l’image aux coordonnées <i>x = 0, y = 0</i>.</li>
  <li>La méthode <codeph>completeHandler()</codeph> effectue ensuite les opérations suivantes :
  <ol outputclass="A">
      <li>Crée un deuxième objet Loader, ainsi qu’un objet Bitmap, qui est initialisé avec l’objet Loader.</li>
      <li>Crée un deuxième objet Bitmap, <codeph>duplicate</codeph>, qui appelle en retour la méthode <codeph>duplicateImage()</codeph>, qui crée elle-même un double de l’image d’origine. </li>
      <li>Crée un objet BitmapData qui est associé à l’objet BitmapData de l’objet <codeph>duplicate</codeph>.</li>
      <li>Crée un objet Rectangle qui est initialisé avec les mêmes coordonnées, la même largeur et hauteur, que l’image d’origine.</li>
      <li>Crée un objet Point, qui emploie par défaut les coordonnées <i>x = 0, y = 0</i>.</li>
      <li>Crée les variables suivantes :
      <ul>
          <li><codeph>operation</codeph> : applique la nouvelle couleur lorsque la valeur de seuil est >= à l’original.</li>
          <li><codeph>threshold</codeph> : la valeur de comparaison des pixels est définie sur gris clair, avec un alpha de 0xCC. </li>
          <li><codeph>color</codeph> : la couleur des pixels qui répondent aux critères imposés, soit jaune uni dans ce cas.</li>
          <li><codeph>mask</codeph> : le contraire exact de la couleur (bleu transparent).</li>
          <li><codeph>copySource</codeph> : défini sur false, indique que les valeurs des pixels ne sont pas copiées dans l’événement si la valeur de seuil n’est pas acceptable. Cette valeur n’a aucune signification, car l’image est dupliquée et seuls les pixels qui répondent aux critères de seuil sont modifiés.</li>
      </ul></li>
      <li>Appelle la méthode <codeph>threshold()</codeph> à l’aide des variables précédentes. L’équation de seuil qui en résulte figure ci-dessous : <codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>. </li>
  </ol></li>
 </ol>
 <p> <b>Remarques :</b>
 <ul>
  <li>Vous devrez compiler le fichier SWF en réglant « Sécurité de lecture locale » sur « Accès aux fichiers locaux uniquement ».
 </li>
  <li>Pour exécuter cet exemple, il est nécessaire de placer un fichier intitulé Image.txt dans le même répertoire que votre fichier SWF.
 </li>
  <li>Il est recommandé d’utiliser une image qui ne dépasse pas 80 pixels de largeur. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiConstructor id="flash.display:Bitmap:Bitmap"><apiName>Bitmap</apiName><shortdesc>
     Initialise un objet Bitmap pour qu’il fasse référence à l’objet BitmapData spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet BitmapData référencé. 
     
     </apiDesc></apiParam><apiParam><apiItemName>pixelSnapping</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>auto</apiData><apiDesc>Indique si l’objet Bitmap est accroché ou non au pixel le plus proche.
     
     </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si l’image bitmap est lissée lorsqu’elle est dimensionnée. Les exemples ci-dessous illustrent la même image bitmap multipliée par trois, <codeph>smoothing</codeph> étant réglé sur <codeph>false</codeph> (gauche) et <codeph>true</codeph> (droite) :
     
     <p>
      <adobetable>
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="Une image bitmap sans lissage." href="../../images/bitmap_smoothing_off.jpg"/></entry>
      <entry align="center"><adobeimage alt="Une image bitmap avec lissage." href="../../images/bitmap_smoothing_on.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     </p>
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Initialise un objet Bitmap pour qu’il fasse référence à l’objet BitmapData spécifié.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Bitmap:bitmapData:get"><apiName>bitmapData</apiName><shortdesc>
    Objet BitmapData référencé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
    Objet BitmapData référencé.
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:pixelSnapping:get"><apiName>pixelSnapping</apiName><shortdesc>
    Contrôle si l’objet Bitmap est accroché ou non au pixel le plus proche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Contrôle si l’objet Bitmap est accroché ou non au pixel le plus proche. La classe PixelSnapping inclut les valeurs possibles :
    
    <ul>
    
      <li><codeph>PixelSnapping.NEVER</codeph> — L’accrochage au pixel est désactivé.</li>
    
      <li><codeph>PixelSnapping.ALWAYS</codeph> — L’image est toujours accrochée au pixel le plus proche, quelle que soit la transformation appliquée.</li>
    
      <li><codeph>PixelSnapping.AUTO</codeph> — L’image bitmap est accrochée au pixel le plus proche si elle est dessinée sans rotation ni inclinaison et que son facteur de redimensionnement est compris entre 99,9 % et 100,1 %. Si ces conditions sont remplies, l’image bitmap est dessinée à l’échelle 100 % et accrochée au pixel le plus proche. En interne, cette valeur permet de dessiner l’image aussi rapidement que possible à l’aide de la fonctionnalité de rendu vectoriel.</li>
    
    </ul>
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:smoothing:get"><apiName>smoothing</apiName><shortdesc>
    Contrôle si l’image bitmap est lissée lorsqu’elle est dimensionnée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    Contrôle si l’image bitmap est lissée lorsqu’elle est dimensionnée. Si le paramètre est défini sur <codeph>true</codeph>, l’image bitmap est lissée. S’il est défini sur <codeph>false</codeph>, l’image bitmap n’est pas lissée.
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Scene"><apiName>Scene</apiName><shortdesc>
	La classe Scene contient des propriétés destinées à identifier le nom, les étiquettes et le nombre d’images d’une séquence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	La classe Scene contient des propriétés destinées à identifier le nom, les étiquettes et le nombre d’images d’une séquence. La classe MovieClip comporte une propriété <codeph>currentScene</codeph>, soit un objet Scene qui identifie la séquence où réside la tête de lecture dans le scénario de l’occurrence de MovieClip. La propriété <codeph>scenes</codeph> de la classe MovieClip est un tableau des objets Scene. Les méthodes <codeph>gotoAndPlay()</codeph> et <codeph>gotoAndStop()</codeph> de la classe MovieClip utilisent les objets Scene en tant que paramètres.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:Scene:labels:get"><apiName>labels</apiName><shortdesc>
		Tableau des objets FrameLabel associés à la séquence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		Tableau des objets FrameLabel associés à la séquence. Chaque objet FrameLabel contient une propriété <codeph>frame</codeph>, qui spécifie le numéro d’image qui correspond à l’étiquette, ainsi que la propriété <codeph>name</codeph>.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:Scene:name:get"><apiName>name</apiName><shortdesc>
		Nom de la séquence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Nom de la séquence.
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Scene:numFrames:get"><apiName>numFrames</apiName><shortdesc>
		Nombre d’images de la séquence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		Nombre d’images de la séquence.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageDisplayState"><apiName>StageDisplayState</apiName><shortdesc>
La classe StageDisplayState fournit des valeurs pour la propriété Stage.displayState.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe StageDisplayState fournit des valeurs pour la propriété <codeph>Stage.displayState</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link></related-links><apiValue id="flash.display:StageDisplayState:FULL_SCREEN"><apiName>FULL_SCREEN</apiName><shortdesc>
Spécifie que la scène est en mode plein écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est en mode plein écran. L’interactivité du clavier est désactivée dans ce mode.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:FULL_SCREEN_INTERACTIVE"><apiName>FULL_SCREEN_INTERACTIVE</apiName><shortdesc>
Indique que la scène est en mode plein écran avec l’interaction clavier activée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreenInteractive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Indique que la scène est en mode plein écran avec l’interaction clavier activée. <ph platform="actionscript">Seules les applications AIR prennent en charge cette fonctionnalité.</ph>

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
Spécifie que la scène est en mode normal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est en mode normal. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderData"><apiName>ShaderData</apiName><shortdesc>
	 Un objet ShaderData contient les propriétés représentant tous les paramètres et entrées d’un noyau de shader, ainsi que les propriétés contenant toutes les métadonnées spécifiées pour le shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Un objet ShaderData contient les propriétés représentant tous les paramètres et entrées d’un noyau de shader, ainsi que les propriétés contenant toutes les métadonnées spécifiées pour le shader.
	 
	 <p>Ces propriétés sont ajoutées à l’objet ShaderData lors de sa création. Le nom des propriétés correspond au nom spécifié dans le code source du shader. Le type de données de chaque propriété dépend de l’aspect du shader représenté par la propriété. Les propriétés qui représentent les paramètres du shader sont des occurrences ShaderParameter, celles qui représentent des images d’entrée sont des occurrences ShaderInput et celles qui représentent les métadonnées du shader sont des occurrences de la classe ActionScript correspondant à leur type de données (par exemple, une occurrence String pour les métadonnées textuelles et une occurrences uint pour les métadonnées uint).</p>
	 
	 <p>Examinons par exemple le shader suivant, défini avec une image d’entrée (<codeph>src</codeph>), deux paramètres (<codeph>size</codeph> et <codeph>radius</codeph>) et trois valeurs de métadonnées (<codeph>nameSpace</codeph>, <codeph>version</codeph> et <codeph>description</codeph>) :</p>
	 
	 <codeblock>
	 &lt;languageVersion : 1.0;>
	 
	 kernel DoNothing
	 &lt;
	     namespace: "Adobe::Example";
	     vendor: "Adobe examples";
	     version: 1;
	     description: "A shader that does nothing, but does it well.";
	 >
	 {
	     input image4 src;
	 
	     output pixel4 dst;
	     
	     parameter float2 size
	     &lt;
	         description: "The size of the image to which the kernel is applied";
	         minValue: float2(0.0, 0.0);
	         maxValue: float2(100.0, 100.0);
	         defaultValue: float2(50.0, 50.0);
	     >;
	     
	     parameter float radius
	     &lt;
	         description: "The radius of the effect";
	         minValue: 0.0;
	         maxValue: 50.0;
	         defaultValue: 25.0;
	     >;
	 
	     void evaluatePixel()
	     {
	         float2 one = (radius / radius) ∗ (size / size);
	         dst = sampleNearest(src, outCoord());
	     }
	 }
	 </codeblock>
	 
	 <p>Si vous créez une occurrence de Shader en chargeant le code binaire pour ce shader, l’occurrence ShaderData de sa propriété <codeph>data</codeph> contient les propriétés suivantes :</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Propriété</entry><entry>Type de données</entry><entry>Valeur</entry></row></thead><tbody><row>
	   <entry>name</entry>
	   <entry>String</entry>
	   <entry>"DoNothing"</entry>
	 </row><row>
	   <entry>nameSpace</entry>
	   <entry>String</entry>
	   <entry>"Adobe::Example"</entry>
	 </row><row>
	   <entry>version</entry>
	   <entry>String</entry>
	   <entry>"1"</entry>
	 </row><row>
	   <entry>description</entry>
	   <entry>String</entry>
	   <entry>"A shader that does nothing, but does it well."</entry>
	 </row><row>
	   <entry>src</entry>
	   <entry>ShaderInput</entry>
	   <entry><i>[Occurrence de ShaderInput]</i></entry>
	 </row><row>
	   <entry>size</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[Occurrence de ShaderParameter, avec les propriétés des métadonnées du paramètre]</i></entry>
	 </row><row>
	   <entry>radius</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[Occurrence de ShaderParameter, avec les propriétés des métadonnées du paramètre]</i></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Notez que toute image d’entrée ou tout paramètre défini dans le code source du shader qui n’est pas utilisé dans la fonction <codeph>evaluatePixel()</codeph> du shader est supprimé lorsque le shader est compilé en pseudo-code binaire. Dans ce cas, aucune occurrence ShaderInput ou ShaderParameter correspondante n’est ajoutée en tant que propriété de l’occurrence ShaderData.</p> 
	 
	 <p>De façon générale, le code du développeur ne crée pas d’occurrence ShaderData. Une occurrence ShaderData contenant des données, des paramètres et des entrées pour un shader est disponible en tant que propriété <codeph>data</codeph> de l’occurrence Shader.</p>
	 
	 </apiDesc><example conref="examples\ShaderDataExample.1.as"> L’exemple suivant charge un shader et énumère l’occurrence ShaderData dans sa propriété <codeph>data</codeph> pour afficher les propriétés des entrées, des paramètres et des métadonnées du shader.
 
 <p>Notez que cet exemple part du principe qu’un fichier de pseudo-code binaire du shader nommé « donothing.pbj » existe dans le répertoire de sortie de l’application. </p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel DoNothing
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "A shader that does nothing, but does it well.";
>
{
    input image4 src;
    
    output pixel4 dst;
    
    parameter float2 size
    &lt;
        description: "The size of the image to which the shader is applied";
        minValue: float2(0.0, 0.0);
        maxValue: float2(100.0, 100.0);
        defaultValue: float2(50.0, 50.0);
    >;
    
    parameter float radius
    &lt;
        description: "The radius of the effect";
        minValue: float(0.0);
        maxValue: float(50.0);
        defaultValue: float(25.0);
    >;

    void evaluatePixel()
    {
        float2 one = (radius / radius) * (size / size);
        dst = sampleNearest(src, outCoord());
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderDataExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function ShaderDataExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            for (var p:String in shader.data) {
                trace(p, ":", shader.data[p]);
                for (var d:String in shader.data[p]) {
                    trace("\t", d, ":", shader.data[p][d]);
                }
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links><apiConstructor id="flash.display:ShaderData:ShaderData"><apiName>ShaderData</apiName><shortdesc>
		 Crée une occurrence ShaderData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>byteCode</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Pseudo-code binaire du shader.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Crée une occurrence ShaderData. En général, le code du développeur n’appelle pas directement le constructeur ShaderData. Une occurrence ShaderData contenant des données, des paramètres et des entrées pour une occurrence Shader est accédée via sa propriété <codeph>data</codeph>.
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
	 Une occurrence ShaderJob est utilisée pour exécuter une opération de shader en mode autonome.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Une occurrence ShaderJob est utilisée pour exécuter une opération de shader en mode autonome. L’opération de shader s’exécute et renvoie son résultat. Il incombe au développeur de déterminer comment utiliser ce résultat.
	 
	 <p>Il existe deux raisons principales à l’utilisation d’un shader en mode autonome :</p>
	 
	 <ul>
	   <li>Traitement des données non graphiques : l’utilisation d’une occurrence de ShaderJob vous permet de contrôler les valeurs d’entrée, ainsi que la méthode d’utilisation du résultat du shader. Le shader peut renvoyer le résultat sous forme de données binaires ou numériques plutôt que sous forme de données image.</li>
	   <li>Traitement en arrière-plan : certains shaders sont complexes et leur exécution prend un certain temps. L’exécution d’un shader complexe dans la ligne d’exécution principale d’une application peut ralentir les autres parties de l’application, telles que l’interaction de l’utilisateur ou la mise à jour de l’écran. L’utilisation d’une occurrence de ShaderJob vous permet d’exécuter le shader dans l’arrière-plan. Lorsque le shader est exécuté de cette manière, l’opération de shader est indépendante de l’exécution principale de l’application.</li>
	 </ul>
	 
	 <p>La propriété <codeph>shader</codeph> (ou paramètre constructeur) spécifie l’occurrence Shader représentant le shader utilisé pour l’opération. Vous fournissez les paramètres ou les entrées attendues par le shader à l’aide de l’occurrence de ShaderParameter ou de ShaderInput associée.</p>
	 
	 <p>Avant l’exécution d’une opération ShaderJob, vous fournissez un objet dans lequel le résultat est écrit, en le définissant comme la valeur de la propriété <codeph>target</codeph>. Une fois l’opération de shader terminée, le résultat est écrit dans l’objet <codeph>target</codeph>.</p>
	 
	 <p>Pour commencer une opération de shader dans l’arrière-plan, appelez la méthode <codeph>start()</codeph>. Une fois l’opération terminée, le résultat est écrit dans l’objet <codeph>target</codeph>. A ce stade, l’occurrence ShaderJob déclenche un événement <codeph>complete</codeph>, qui indique aux écouteurs que le résultat est disponible.</p>
	 
	 <p>Pour exécuter un shader de façon synchrone (c’est-à-dire qui ne s’exécute pas dans l’arrière-plan), appelez la méthode <codeph>start()</codeph>, puis transmettez <codeph>true</codeph> en tant qu’argument. Le shader s’exécute dans la thread principale et votre code s’interrompt jusqu’à la fin de l’opération. Lorsque l’opération est terminée, le résultat est écrit dans l’objet <codeph>target</codeph>. A ce stade, l’application continue de s’exécuter à la ligne de code suivante.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader"><linktext>Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>ShaderParameter</linktext></link><link href="flash.events.xml#ShaderEvent"><linktext>ShaderEvent</linktext></link></related-links><adobeApiEvent id="flash.display:ShaderJob_flash.events.ShaderEvent.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	 Distribué lorsqu’un ShaderJob qui s’exécute de façon asynchrone achève de traiter les données à l’aide du shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ShaderEvent.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué lorsqu’un ShaderJob qui s’exécute de façon asynchrone achève de traiter les données à l’aide du shader. Une occurrence de ShaderJob s’exécute de façon asynchrone lorsque la méthode <codeph>start()</codeph> est appelée et que la valeur du paramètre <codeph>waitForCompletion</codeph> est définie sur <codeph>false</codeph>.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:ShaderJob:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
		 
		 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Shader à utiliser pour l’opération.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet dans lequel est écrit le résultat de l’opération du shader. Cet argument doit être une occurrence de BitmapData, de ByteArray ou de Vector.&lt;Number>.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Largeur des données du résultat dans l’objet <codeph>target</codeph> dans le cas d’une occurrence de ByteArray ou de Vector.&lt;Number>. La taille de l'occurrence de ByteArray ou de Vector.&lt;Number> est élargie au besoin et les données existantes remplacées.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Largeur des données du résultat dans l’objet <codeph>target</codeph> dans le cas d’une occurrence de ByteArray ou de Vector.&lt;Number>. La taille de l'occurrence de ByteArray ou de Vector.&lt;Number> est élargie au besoin et les données existantes remplacées.
         
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:ShaderJob:cancel"><apiName>cancel</apiName><shortdesc>
		 Annule l’opération de shader en cours d’exécution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Annule l’opération de shader en cours d’exécution. Les résultats déjà calculés sont ignorés. L’événement <codeph>complete</codeph> n’est pas déclenché.
		 
		 <p>L’appel répété de <codeph>cancel()</codeph> n’a pas d’effet.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:ShaderJob:start"><apiName>start</apiName><shortdesc>
		 Lance une opération de shader en mode synchrone ou asynchrone selon la valeur du paramètre waitForCompletion.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Lorsque la propriété <codeph>target</codeph> est définie sur <codeph>null</codeph> ou n’est pas une occurrence de BitmapData, de ByteArray ou de Vector.&lt;Number>.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsque le shader spécifie une entrée d’image non fournie.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Lorsqu’une occurrence de ByteArray ou de Vector.&lt;Number> est utilisée comme entrée et les propriétés <codeph>width</codeph> et <codeph>height</codeph> ne sont pas spécifiées pour le ShaderInput, ou les valeurs spécifiées ne correspondent pas à la quantité de données dans l’objet d’entrée. Voir la propriété <codeph>ShaderInput.input</codeph> pour plus d’informations.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>waitForCompletion</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si le shader doit être exécuté dans l’arrière-plan (<codeph>false</codeph>, valeur par défaut) ou dans l’exécution du programme principale (<codeph>true</codeph>).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Lance une opération de shader en mode synchrone ou asynchrone selon la valeur du paramètre <codeph>waitForCompletion</codeph>.
		 
		 <p>En mode asynchrone (lorsque le paramètre <codeph>waitForCompletion</codeph> est défini sur <codeph>false</codeph>), mode par défaut, l’exécution de ShaderJob a lieu dans l’arrière-plan. L’opération de shader n’a aucune incidence sur la réactivité de l’affichage ou sur d’autres opérations. En mode asynchrone, l’appel de la méthode <codeph>start()</codeph> est immédiatement renvoyé et le programme continue avec la ligne de code suivante. Lorsque l’opération de shader asynchrone est terminée, le résultat est disponible et l’événement <codeph>complete</codeph> est distribué.</p>
		 
		 <p>Une seule opération ShaderJob d’arrière-plan peut s’exécuter à la fois. Les opérations de shader restent en file d’attente jusqu’à leur exécution. Si vous appelez la méthode <codeph>start()</codeph> lorsqu’une opération de shader est en cours d’exécution, les autres opérations sont ajoutées à la fin de la file d’attente, puis sont exécutées au moment opportun.</p>
		 
		 <p>Pour exécuter une opération de shader en mode synchrone, appelez la méthode <codeph>start()</codeph> et définissez le paramètre <codeph>waitForCompletion</codeph> (l’unique paramètre) sur <codeph>true</codeph>. Votre code s’interrompt au point où la méthode <codeph>start()</codeph> est appelée jusqu’à ce que l’opération de shader se termine. A ce stade, le résultat est disponible et l’exécution se poursuit avec la ligne de code suivante.</p>
		 
		 <p>Lorsque vous appelez la méthode <codeph>start()</codeph>, l’occurrence Shader dans la propriété <codeph>shader</codeph> est copiée en interne. L’opération de shader utilise cette copie interne et non une référence du shader d’origine. Toute modification apportée au shader, par exemple la modification de la valeur d’un paramètre, l’entrée ou le pseudo-code binaire, n’est pas appliquée au shader copié utilisé pour le traitement du shader. Pour intégrer les modifications apportées au shader dans le traitement du shader, appelez la méthode <codeph>cancel()</codeph> (le cas échéant), puis de nouveau la méthode <codeph>start()</codeph> pour redémarrer le traitement du shader.</p>
		 
		 <p>Lorsqu’une opération de shader est en cours d’exécution, la valeur de l’objet <codeph>target</codeph> n’est pas modifiée. Lorsque l’opération se termine (et que l’événement <codeph>complete</codeph> est déclenché en mode asynchrone), le résultat complet est écrit en une seule fois dans l’objet <codeph>target</codeph>. Si l’objet <codeph>target</codeph> est une occurrence de BitmapData et que sa méthode <codeph>dispose()</codeph> est appelée avant la fin de l’opération, l’événement <codeph>complete</codeph> est tout de même déclenché en mode asynchrone. Toutefois, les données du résultat ne sont pas inscrites dans l’objet BitmapData car celui est en état disposé.</p>
         
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.display:ShaderJob:start_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération est terminée, si la méthode <codeph>start()</codeph> est appelée avec un argument <codeph>waitForCompletion</codeph> dont la valeur est <codeph>true</codeph>.
		 
		 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération est terminée, si la méthode start() est appelée avec un argument waitForCompletion dont la valeur est true.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.display:ShaderJob:height:get"><apiName>height</apiName><shortdesc>
		 Hauteur des données du résultat dans l’objet target dans le cas d’une occurrence de ByteArray ou de Vector.&amp;lt;Number&amp;gt;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Largeur des données du résultat dans l’objet <codeph>target</codeph> dans le cas d’une occurrence de ByteArray ou de Vector.&lt;Number>. La taille de l'occurrence de ByteArray ou de Vector.&lt;Number> est élargie au besoin et les données existantes remplacées.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:progress:get"><apiName>progress</apiName><shortdesc>
		 Progression d’un shader en cours d’exécution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Progression d’un shader en cours d’exécution. Cette propriété est une valeur comprise entre 0 et 1. La valeur initiale est zéro (0 %). 1 indique que le shader a terminé son opération.
		 
		 <p>Si la méthode <codeph>cancel()</codeph> est appelée, cette propriété devient <codeph>undefined</codeph> et sa valeur ne peut pas être utilisée de façon fiable jusqu’à ce que l’opération du shader redémarre.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:shader:get"><apiName>shader</apiName><shortdesc>
		 Shader utilisé pour l’opération.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 Shader utilisé pour l’opération. Les entrées ou paramètres attendus par le shader doivent être fournis à l’aide de la propriété ShaderInput ou ShaderParameter de la propriété <codeph>data</codeph> de l’occurrence Shader. L’entrée doit être fournie par sa propriété ShaderInput correspondante si c’est la même que l’objet <codeph>target</codeph>.
		 
		 <p>Pour traiter un ByteArray contenant un tableau de données linéaire (par opposition aux données image), définissez la propriété <codeph>height</codeph> de l’occurrence ShaderInput sur 1 et la propriété <codeph>width</codeph> sur les valeurs en virgule flottante 32 bits du ByteArray. Dans ce cas, l’entrée dans le shader doit être définie avec le type de données <codeph>image1</codeph>.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderJob:target:get"><apiName>target</apiName><shortdesc>
		 Objet dans lequel est écrit le résultat de l’opération du shader. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 Objet dans lequel est écrit le résultat de l’opération du shader. Cet objet doit être une occurrence de BitmapData, de ByteArray ou de Vector.&lt;Number>.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:width:get"><apiName>width</apiName><shortdesc>
		 Largeur des données du résultat dans l’objet target dans le cas d’une occurrence de ByteArray ou de Vector.&amp;lt;Number&amp;gt;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Largeur des données du résultat dans l’objet <codeph>target</codeph> dans le cas d’une occurrence de ByteArray ou de Vector.&lt;Number>. La taille de l'occurrence de ByteArray ou de Vector.&lt;Number> est élargie au besoin et les données existantes remplacées.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowSystemChrome"><apiName>NativeWindowSystemChrome</apiName><shortdesc>
	 La classe NativeWindowSystemChrome définit des constantes pour la propriété systemChrome de l’objet NativeWindowInitOptions utilisée pour créer une fenêtre native.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe NativeWindowSystemChrome définit des constantes pour la propriété <codeph>systemChrome</codeph> de l’objet NativeWindowInitOptions utilisée pour créer une fenêtre native.  
	 
	 <p>Le chrome système fait référence aux éléments propres au système d’exploitation d’une fenêtre tels qu’une barre des titres, les boutons Réduire, Agrandir et Fermer.</p>
  	 
	 <p><b>Remarque :</b> le type de chrome système utilisé est spécifié lorsqu’une fenêtre est créée et ne peut pas être modifié.</p>
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowSystemChrome:NONE"><apiName>NONE</apiName><shortdesc>
	 Aucun chrome système.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Aucun chrome système. 
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowSystemChrome:STANDARD"><apiName>STANDARD</apiName><shortdesc>
	 Chrome standard du système d’exploitation hôte.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Chrome standard du système d’exploitation hôte.
	 
	 <p>Utilisez ce paramètre pour émuler l’apparence du système d’exploitation natif.</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsStroke"><apiName>IGraphicsStroke</apiName><shortdesc>
	Cette interface vous permet de définir des objets pouvant être utilisés comme paramètres de trait dans les méthodes flash.display.Graphics et les classes de dessin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Cette interface vous permet de définir des objets pouvant être utilisés comme paramètres de trait dans les méthodes flash.display.Graphics et les classes de dessin. Utilisez les classes implémenteur de cette interface pour créer et gérer les données de la propriété stroke et pour réutiliser les mêmes données pour plusieurs occurrences.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
 La classe SimpleButton vous permet de contrôler toutes les occurrences de symboles de bouton dans un fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>La classe SimpleButton vous permet de contrôler toutes les occurrences de symboles de bouton dans un fichier SWF.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SimpleButton vous permet de contrôler toutes les occurrences de symboles de bouton dans un fichier SWF. Après avoir créé une occurrence de bouton dans l’outil de programmation, vous pouvez utiliser les méthodes et les propriétés de la classe SimpleButton pour manipuler les boutons avec ActionScript.
 
 <p product="flash">Vous pouvez attribuer à un bouton un nom d’occurrence dans l’inspecteur des propriétés. Les noms d’occurrence de SimpleButton s’affichent dans l’explorateur d’animations et dans la boîte de dialogue Insérer un chemin cible du panneau Actions.</p>
 
 <p>Dans ActionScript 3.0, vous devez utiliser le constructeur <codeph>new SimpleButton()</codeph> pour créer une occurrence de SimpleButton.</p>
 
 <p>La classe SimpleButton hérite de la classe InteractiveObject.</p>
 
 </apiDesc><example conref="examples\SimpleButtonExample.as"> L’exemple suivant a recours à la classe SimpleButtonExample, qui en retour utilise la classe CustomSimpleButton, qui crée quatre occurrences d’un objet ButtonDisplayState. Le résultat est un bouton qui est créé sous forme de carré, dont la couleur d’arrière-plan change en fonction de l’état de la souris en contournant les propriétés d’occurrence de la classe SimpleButton. Pour ce faire, procédez comme suit :
 <ol>
  <li>Dans le constructeur <codeph>SimpleButtonExample()</codeph>, un nouvel objet CustomSimpleButton de type SimpleButton, appelé <codeph>button</codeph>, est créé, qui appelle ensuite la méthode de constructeur <codeph>CustomSimpleButton</codeph>. L’objet <codeph>button</codeph> est ajouté à la liste d’affichage. La couleur et la taille du bouton sont déterminées par les étapes suivantes.</li>
 
  <li>Dans la classe CustomSimpleButton, les propriétés d’occurrence sont déclarées, puis utilisées pour contrôler la taille et la couleur d’arrière-plan de <codeph>button</codeph> en fonction de son état (orange dans son état normal, jaune sombre en cas de survol de la souris et bleu clair lorsque l’utilisateur clique sur l’un des boutons). Quel que soit l’état de <codeph>button</codeph>, la taille du carré est définie sur 80 pixels en utilisant la propriété <codeph>size</codeph>.</li>
 
  <li>La fonction constructeur de la classe CustomSimpleButton définit les propriétés <codeph>downState</codeph>, <codeph>overState</codeph>, <codeph>upState</codeph>, <codeph>hitTestState</codeph> et <codeph>useHandCursor</codeph> avec quatre occurrences de la classe ButtonDisplayState.</li>
 
  <li>Dans la classe ButtonDisplayState, le constructeur définit la valeur de la taille du carré et la couleur d’arrière-plan, puis appelle la méthode <codeph>draw()</codeph>.</li>
 
  <li>La méthode <codeph>draw()</codeph> redessine le carré avec la taille et la couleur d’arrière-plan définies dans le constructeur reposant sur l’état du bouton.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class SimpleButtonExample extends Sprite {
        public function SimpleButtonExample() {
            var button:CustomSimpleButton = new CustomSimpleButton();
            addChild(button);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.SimpleButton;

class CustomSimpleButton extends SimpleButton {
    private var upColor:uint   = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;
    private var size:uint      = 80;

    public function CustomSimpleButton() {
        downState      = new ButtonDisplayState(downColor, size);
        overState      = new ButtonDisplayState(overColor, size);
        upState        = new ButtonDisplayState(upColor, size);
        hitTestState   = new ButtonDisplayState(upColor, size * 2);
        hitTestState.x = -(size / 4);
        hitTestState.y = hitTestState.x;
        useHandCursor  = true;
    }
}

class ButtonDisplayState extends Shape {
    private var bgColor:uint;
    private var size:uint;

    public function ButtonDisplayState(bgColor:uint, size:uint) {
        this.bgColor = bgColor;
        this.size    = size;
        draw();
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject"><linktext>Classe InteractiveObject</linktext></link></related-links><apiConstructor id="flash.display:SimpleButton:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
	Crée une occurrence de SimpleButton.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>upState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur initiale de l’état relevé de SimpleButton.
	</apiDesc></apiParam><apiParam><apiItemName>overState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur initiale de l’état survol de SimpleButton.
	</apiDesc></apiParam><apiParam><apiItemName>downState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur initiale de l’état abaissé de SimpleButton.
	</apiDesc></apiParam><apiParam><apiItemName>hitTestState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur initiale de l’état cliqué de SimpleButton.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Crée une occurrence de SimpleButton.
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Crée une occurrence de SimpleButton. Tout ou partie des objets d’affichage qui représentent les différents états de bouton peuvent être définis en tant que paramètres dans le constructeur.  
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:SimpleButton:downState:get"><apiName>downState</apiName><shortdesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet visuel associé à l’état Abaissé du bouton (l’état du bouton lorsque l’utilisateur clique sur l’objet hitTestState.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Spécifie une valeur DisplayObject utilisée pour l’état Abaissé du bouton.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet visuel associé à l’état Abaissé du bouton (l’état du bouton lorsque l’utilisateur clique sur l’objet <codeph>hitTestState</codeph>).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Valeur booléenne spécifiant si un bouton est activé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button.enabled, enabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Spécifie si un bouton est activé (true) ou désactivé (false).
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur booléenne spécifiant si un bouton est activé. Lorsqu’il est désactivé (la propriété enabled est alors réglée sur <codeph>false</codeph>), le bouton est visible mais vous ne pouvez pas cliquer dessus. La valeur par défaut est <codeph>true</codeph>. Cette propriété s’avère utile si vous souhaitez désactiver certains des boutons de navigation. Par exemple, il peut être souhaitable de désactiver un bouton dans la page actuellement affichée afin d’empêcher l’utilisateur de cliquer dessus et de recharger la page.
	 
	 <p><b>Remarque :</b> pour éviter de cliquer sur un bouton avec la souris, réglez les propriétés <codeph>enabled</codeph> et <codeph>mouseEnabled</codeph> sur <codeph>false</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:hitTestState:get"><apiName>hitTestState</apiName><shortdesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet de test de recherche pour le bouton.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet de test de recherche pour le bouton. Pour un bouton de base, réglez la propriété <codeph>hitTestState</codeph> sur le même objet d’affichage que la propriété <codeph>overState</codeph>. Si vous ne réglez pas la propriété <codeph>hitTestState</codeph>, le bouton SimpleButton est inactif (il ne réagit pas aux événements de souris et de clavier).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:overState:get"><apiName>overState</apiName><shortdesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet visuel associé à l’état survol du bouton (l’état du bouton lorsque la souris est placée sur le bouton.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Spécifie une valeur DisplayObject utilisée pour l’état « survol » du bouton.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet visuel associé à l’état survol du bouton (l’état du bouton lorsque la souris est placée sur le bouton).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 Objet SoundTransform affecté au bouton.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should information from AS2 setTransform be here? e.g. percentage values indicating
	 how much of the left input to play in the left speaker or right speaker; it is generally
	 best to use 22-KHZ 6-bit mono sounds?
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 Objet SoundTransform affecté au bouton. Un objet SoundTransform comprend les propriétés de réglage du volume, du déplacement panoramique, ainsi que des haut-parleurs gauche et droit. Il s’applique à tous les états du bouton. Cet objet SoundTransform n’affecte que les sons intégrés.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Indique si d’autres objets d’affichage de type SimpleButton ou MovieClip peuvent recevoir des événements de relâchement de souris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si d’autres objets d’affichage de type SimpleButton ou MovieClip peuvent recevoir des événements de relâchement de souris. La propriété <codeph>trackAsMenu</codeph> permet de créer des menus. Vous pouvez définir la propriété <codeph>trackAsMenu</codeph> sur n’importe quel objet SimpleButton ou MovieClip. Si la propriété <codeph>trackAsMenu</codeph> n’existe pas, la valeur du comportement par défaut devient <codeph>false</codeph>. 
	 
	 <p>Vous pouvez modifier la propriété <codeph>trackAsMenu</codeph> à tout moment ; le bouton modifié accepte immédiatement le nouveau comportement. </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:upState:get"><apiName>upState</apiName><shortdesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet visuel associé à l’état relevé du bouton (l’état du bouton lorsque la souris n’est pas placée sur le bouton.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Spécifie une valeur DisplayObject utilisée pour l’état relevé du bouton.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Spécifie un objet d’affichage utilisé en tant qu’objet visuel associé à l’état relevé du bouton (l’état du bouton lorsque la souris n’est pas placée sur le bouton).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
     Valeur booléenne qui, lorsqu’elle est réglée sur true, indique si le curseur en forme de main s’affiche lorsque la souris survole un bouton.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create two buttons on the Stage with the instance names <code>myBtn1_btn</code> and <code>myBtn2_btn</code>. Enter the following ActionScript in Frame 1 of the Timeline:
	 <listing>
	 myBtn1_btn.useHandCursor = false;
	 myBtn1_btn.onRelease = buttonClick;
	 myBtn2_btn.onRelease = buttonClick;
	 function buttonClick() {
	   trace(this._name);
	 }
	 </listing>
	 <p>When the mouse is over and clicks <code>myBtn1_btn</code>, there is no pointing hand. However, you see the pointing hand when the button is over and clicks <code>myBtn2_btn</code>.</p>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Affiche un curseur en forme de main si true est défini.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Valeur booléenne qui, lorsqu’elle est réglée sur <codeph>true</codeph>, indique si le curseur en forme de main s’affiche lorsque la souris survole un bouton. Si cette propriété est réglée sur <codeph>false</codeph>, le pointeur flèche s’affiche. La valeur par défaut est <codeph>true</codeph>.
	 
	 <p>Vous pouvez modifier la propriété <codeph>useHandCursor</codeph> à tout moment ; le bouton modifié accepte immédiatement le nouveau comportement du curseur. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:TriangleCulling"><apiName>TriangleCulling</apiName><shortdesc>
 Définit des codes pour les algorithmes d’élimination qui déterminent quels triangles ne doivent pas être restitués lors du tracé des triangles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit des codes pour les algorithmes d’élimination qui déterminent quels triangles ne doivent pas être restitués lors du tracé des triangles.
 
 <p>
 Les termes <codeph>POSITIVE</codeph> et <codeph>NEGATIVE</codeph> font référence au signe de la normale d’un triangle le long de l’axe z. La normale est un vecteur 3D perpendiculaire à la surface du triangle.
 </p>
 
 <p>
 Un triangle dont les sommets 0, 1 et 2 sont placés dans le sens des aiguilles d’une montre a une valeur de normale positive. C’est-à-dire que sa normale pointe dans la direction positive de l’axe z, en s’éloignant du point de vue en cours. Lorsque l’algorithme <codeph>TriangleCulling.POSITIVE</codeph> est utilisé, les triangles dont les normales sont positives ne sont pas restitués. Cette opération est également appelée « Backface culling » ou suppression des faces cachées.
 </p>
 
 <p>
 Un triangle dont les sommets sont placés dans le sens contraire des aiguilles d’une montre a une valeur de normale négative. C’est-à-dire que sa normale pointe dans la direction négative de l’axe z, vers le point de vue en cours. Lorsque l’algorithme <codeph>TriangleCulling.NEGATIVE</codeph> est utilisé, les triangles dont les normales sont négatives ne sont pas restitués.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTrianglePath()"><linktext>flash.display.Graphics.drawTrianglePath()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="http://www.gamedev.net/reference/articles/article1089.asp"><linktext>Présentation des vecteurs 3D</linktext></link><link href="http://www.gamedev.net/reference/articles/article1088.asp"><linktext>Backface Culling 3D (Suppression des faces cachées)</linktext></link></related-links><apiValue id="flash.display:TriangleCulling:NEGATIVE"><apiName>NEGATIVE</apiName><shortdesc>
     Spécifie un culling de tous les triangles qui font face au point de vue en cours.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>negative</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie un culling de tous les triangles qui font face au point de vue en cours.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:NONE"><apiName>NONE</apiName><shortdesc>
     Spécifie aucun culling.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie aucun culling. Tous les triangles du tracé sont restitués.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:POSITIVE"><apiName>POSITIVE</apiName><shortdesc>
     Spécifie un culling de tous les triangles qui tournent le dos au point de vue en cours.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>positive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie un culling de tous les triangles qui tournent le dos au point de vue en cours. Ce type de culling est également appelé backface culling ou suppression des faces cachées.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
 La classe NativeWindow fournit une interface pour créer et contrôler des fenêtres de bureau natives.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe NativeWindow fournit une interface pour créer et contrôler des fenêtres de bureau natives.
  
 <p platform="actionscript">Une référence à l’occurrence NativeWindow est renvoyée par le constructeur window. Vous pouvez également accéder à une référence à l’occurrence NativeWindow à l’aide de la propriété <codeph>stage.nativeWindow</codeph> des objets d’affichage sur la scène de cette fenêtre :
 </p>
 
 <pre platform="actionscript">var window:NativeWindow = displayObject.stage.nativeWindow;</pre>
 
 <p platform="javascript">Une référence à l’occurrence NativeWindow est renvoyée par le constructeur window. JavaScript dans une page HTML peut faire référence à l’occurrence NativeWindow à l’aide de la propriété <codeph>window.nativeWindow</codeph>.
 </p>
 
 <p>Seul le contenu d’une application peut accéder aux propriétés d’une occurrence de NativeWindow. Si un contenu hors application tente d’accéder à un objet NativeWindow, une erreur de sécurité est renvoyée.</p>
 
 <p>Il est possible d’ajouter du contenu dans une fenêtre avec les méthodes DisplayObjectContainer de l’objet Stage telles que <codeph>addChild()</codeph>.</p>
 
 <p platform="actionscript">Vous ne pouvez pas ajouter de composants Flex directement à la liste d’affichage d’une occurrence NativeWindow. Utilisez plutôt les composants Flex mx:WindowedApplication et mx:Window pour créer vos fenêtres et ajouter les autres composants Flex en tant qu’enfants de ces objets. Vous pouvez ajouter un contenu SWF Flex directement à une fenêtre NativeWindow tant que le fichier SWF est chargé dans son propre domaine d’application et est un contenu d’application.
 </p>
 
 <p>Pour créer une fenêtre HTML racine qui affiche un contenu HTML, il est généralement plus facile de créer la fenêtre avec <codeph>HTMLLoader.createRootWindow()</codeph>. Un objet HTMLLoader est automatiquement ajouté aux fenêtres créées de cette manière (à partir du code JavaScript, vous pouvez également utiliser la fonction JavaScript <codeph>window.open()</codeph>. Toutefois, cette méthode vous donne moins de contrôle sur l’apparence et le comportement de la fenêtre).</p>
 
 <p>
 Les opérations suivantes sur les objets NativeWindow sont asynchrones : changements <codeph>close()</codeph>, <codeph>maximize()</codeph>, <codeph>minimize()</codeph>, <codeph>restore()</codeph> et <codeph>bounds</codeph>. Une application peut détecter la fin de ces opérations en écoutant les événements appropriés.
 </p>
 
 <p>
 Si la propriété <codeph>NativeApplication.autoExit</codeph> est <codeph>true</codeph>, qui est la valeur par défaut, l’application se ferme à la fermeture de sa dernière fenêtre (et au renvoi de tous les gestionnaires de l’événement <codeph>close</codeph>). Si <codeph>autoExit</codeph> est <codeph>false</codeph>, <codeph>NativeApplication.nativeApplication.exit()</codeph> doit être appelé pour arrêter l’application.
 </p>
 <p>
 Le nettoyage de la mémoire ne sera pas effectué sur les objets NativeWindow après l’appel du constructeur window et avant l’appel du constructeur <codeph>close()</codeph>. L’application est chargée de fermer ses fenêtres.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/nativeWindow"><linktext>flash.display.Stage.nativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="flash.desktop.xml#NativeApplication"><linktext>flash.desktop.NativeApplication</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
 Distribué par cet objet NativeWindow après la désactivation de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow après la désactivation de la fenêtre.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
 Distribué par cet objet NativeWindow après l’activation de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow après l’activation de la fenêtre.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Distribué par cet objet NativeWindow après la fermeture de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow après la fermeture de la fenêtre.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSING_closing"><apiName>closing</apiName><shortdesc>
 Distribué par cet objet NativeWindow immédiatement avant la fermeture de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow immédiatement avant la fermeture de la fenêtre. Cet événement peut être annulé pour empêcher la fermeture de la fenêtre.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE_displayStateChange"><apiName>displayStateChange</apiName><shortdesc>
 Distribué par cet objet NativeWindow après le changement de la propriété displayState de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow après le changement de la propriété <codeph>displayState</codeph> de la fenêtre.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING_displayStateChanging"><apiName>displayStateChanging</apiName><shortdesc>
 Distribué par cet objet NativeWindow immédiatement avant le changement de l’état d’affichage de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow immédiatement avant le changement de l’état d’affichage de la fenêtre. Cet événement peut être annulé pour empêcher le changement.
 
 </apiDesc><example conref="examples\NativeWindow.displayStateChanging.1.as"> L’exemple suivant indique comment annuler un événement <codeph>displayStateChanging</codeph>.
<codeblock>
function displayStateChanging_handler(displayStateEvent:NativeWindowDisplayStateEvent):void
{
  //shouldStopStateChange is an application-defined Boolean indicating 
  //that display state changes should be canceled
  if (displayStateEvent.type == NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING 
                                  &amp;&amp;    shouldStopStateChange)
  {
    displayStateEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Distribué par cet objet NativeWindow après le redimensionnement de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow après le redimensionnement de la fenêtre. Un événement <codeph>resize</codeph> est distribué lorsque la taille (propriétés <codeph>width</codeph> ou <codeph>height</codeph>) de la fenêtre change, ce qui peut avoir lieu en raison d’un redimensionnement de la fenêtre commandé par le système ; réduction, agrandissement ou restauration de la fenêtre ; ou changement de la taille de la fenêtre en définissant les propriétés <codeph>width</codeph>, <codeph>height</codeph> ou <codeph>bounds</codeph>. Les événements <codeph>resize</codeph> de NativeWindow sont distribués lors des boucles de redimensionnement commandées par le système. En revanche, les événements <codeph>resize</codeph> de l’objet Stage sont distribués lorsque la Scène est prête pour le dessin.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Stage/resize"><linktext>flash.display.Stage.resize</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZING_resizing"><apiName>resizing</apiName><shortdesc>
 Distribué par cet objet NativeWindow immédiatement avant le redimensionnement de la fenêtre sur le bureau.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow immédiatement avant le redimensionnement de la fenêtre sur le bureau. Cet événement peut être annulé pour empêcher ou modifier le redimensionnement.
 
 </apiDesc><example conref="examples\NativeWindow.resizing.1.as"> L’exemple suivant indique comment annuler un événement <codeph>resizing</codeph>.
<codeblock>
function boundsChanging_handler(boundsEvent:NativeWindowBoundsEvent):void
{
  //shouldStopResize is an application-defined Boolean indicating 
  //that resize operations should be canceled
  if (boundsEvent.type == NativeWindowBoundsEvent.RESIZING &amp;&amp; shouldStopResize)
  {
    boundsEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVE_move"><apiName>move</apiName><shortdesc>
 Distribué par cet objet NativeWindow après le déplacement de la fenêtre sur le bureau.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par cet objet NativeWindow après le déplacement de la fenêtre sur le bureau.
 <p>
 Un événement <codeph>move</codeph> est distribué lorsque l’origine (propriétés <codeph>x</codeph> ou <codeph>y</codeph>) de la fenêtre change, ce qui peut avoir lieu en raison d’un déplacement de la fenêtre commandé par le système ; réduction, agrandissement ou restauration de la fenêtre ; ou changement de l’emplacement de la fenêtre en définissant les propriétés <codeph>x</codeph>, <codeph>y</codeph> ou <codeph>bounds</codeph>.
 </p>
 <p><b>Remarque :</b> évitez les actions pouvant ouvrir des boîtes de dialogue du système d’exploitation simultanées dans les fonctions du gestionnaire pour les événements <codeph>moving</codeph> et <codeph>move</codeph> d’un objet NativeWindow. Ceci peut avoir lieu, par exemple, si les deux fonctions du gestionnaire renvoient une erreur. Si ceci a lieu, la seconde boîte de dialogue ouverte n’enregistre pas les clics de la souris et doit être fermée à l’aide du clavier.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVING_moving"><apiName>moving</apiName><shortdesc>
 Distribué par l’objet NativeWindow immédiatement avant le déplacement de la fenêtre sur le bureau.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par l’objet NativeWindow immédiatement avant le déplacement de la fenêtre sur le bureau. Cet événement peut être annulé pour empêcher ou modifier le déplacement.
 
 <p><b>Remarque :</b> évitez les actions pouvant ouvrir des boîtes de dialogue du système d’exploitation simultanées dans les fonctions du gestionnaire pour les événements <codeph>moving</codeph> et <codeph>move</codeph> d’un objet NativeWindow. Ceci peut avoir lieu, par exemple, si les deux fonctions du gestionnaire renvoient une erreur. Si ceci a lieu, la seconde boîte de dialogue ouverte n’enregistre pas les clics de la souris et doit être fermée à l’aide du clavier.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeWindow:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
    Crée une occurrence de NativeWindow et une fenêtre de système d’exploitation correspondante.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Si le paramètre <codeph>initOptions</codeph> n’est pas valide.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiParam><apiItemName>initOptions</apiItemName><apiOperationClassifier>flash.display:NativeWindowInitOptions</apiOperationClassifier><apiDesc>Un objet contenant les propriétés d’initialisation pour cette fenêtre.
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Crée une occurrence de NativeWindow et une fenêtre de système d’exploitation correspondante.
    <p>
    Les paramètres définis dans le paramètre <codeph>initOptions</codeph> ne peuvent pas être modifiés après la création de la fenêtre. Les paramètres <codeph>initOptions</codeph> non valides entraînent le renvoi d’une erreur d’opération non autorisée. Les paramètres qui sont valides mais non disponibles sur le système actuel ne renvoient pas d’exception. Les fonctionnalités de la fenêtre propres au système d’exploitation actuel peuvent être détectées, le cas échéant, à l ’aide des membres statiques NativeWindow tels que <codeph>systemMaxSize</codeph>.
    </p>
    
    <p>La taille de la fenêtre par défaut est déterminée par le système d’exploitation mais peut être modifiée en définissant les limites de la fenêtre. Le changement n’est pas visible si la propriété <codeph>visible</codeph> de la fenêtre est <codeph>false</codeph>.</p>
    
    </apiDesc><example conref="examples\NativeWindow.constructor.1.as"> L’exemple suivant crée et active une nouvelle occurrence de NativeWindow :
<codeblock>
import flash.display.NativeWindowInitOptions;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowType;
import flash.display.NativeWindow;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.geom.Rectangle;

var windowOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
windowOptions.systemChrome = NativeWindowSystemChrome.STANDARD;
windowOptions.type = NativeWindowType.NORMAL;

var newWindow:NativeWindow = new NativeWindow(windowOptions);
newWindow.stage.scaleMode = StageScaleMode.NO_SCALE;
newWindow.stage.align = StageAlign.TOP_LEFT;
newWindow.bounds = new Rectangle(100, 100, 800, 800);

newWindow.activate();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeWindow:activate"><apiName>activate</apiName><shortdesc>
	 Active cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Active cette fenêtre. 
	 
	 <p>L’activation d’une fenêtre :</p>
	 <ul> 
	 <li>Rend la fenêtre visible</li>
	 <li>Déplace la fenêtre vers l’avant</li> 
	 <li>Donne à la fenêtre le focus keyboard et mouse</li>
	 </ul>
	 
	 <p>Sous Linux, <codeph>activate()</codeph> est une opération asynchrone.</p>
	 
	 <p>L’objet NativeWindow distribue un événement <codeph>activate</codeph> sur toutes les plates-formes. </p>
	 
	 </apiDesc><example conref="examples\NativeWindow.activate.1.as"> Les exemples suivants indiquent comment activer une fenêtre.
  
 <p>Avec une référence à un objet d’affichage sur la scène de la fenêtre :</p>
<codeblock>
displayObject.stage.nativeWindow.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.2.as"> Avec une référence à une occurrence de la classe NativeWindow :
<codeblock>
windowObj.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.3.as"> A partir de JavaScript dans une page HTML rendue dans la fenêtre (où <codeph>window</codeph> est l’objet window JavaScript global) :
<codeblock>
window.nativeWindow.activate();
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/visible"><linktext>visible</linktext></link><link href="flash.display.xml#NativeWindow/orderToFront"><linktext>orderToFront</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:close"><apiName>close</apiName><shortdesc>
      Ferme cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Ferme cette fenêtre. 
      
      <p>Un événement <codeph>close</codeph> est distribué dès que l’opération de fermeture se termine. Un événement <codeph>closing</codeph> n’est pas distribué. Si l’annulation de cette opération de fermeture doit être autorisée, distribuez un événement <codeph>closing</codeph> et vérifiez si des écouteurs enregistrés annulent le comportement par défaut avant d’appeler la méthode <codeph>close</codeph>.
      </p>
      <p>
      Si les occurrences d’objets d’affichage actuellement dans la fenêtre ne sont pas référencées en un autre endroit, elles sont nettoyées et détruites, sauf dans la fenêtre de l’application initiale créée par AIR. Pour que les objets d’affichage de la fenêtre d’origine soient nettoyés, supprimez-les de la scène dans la fenêtre.
      </p>
      <p>
      Après sa fermeture, l’objet NativeWindow demeure une référence valide, mais l’accès à la plupart des propriétés et des méthodes renvoie une erreur d’opération non autorisée.
      </p>
      <p>
      Les fenêtres fermées ne peuvent pas être rouvertes. Si la fenêtre est déjà fermée, aucune action n’est effectuée et aucun événement n’est distribué.
      </p>
      
      <p>Remarque : pour masquer une fenêtre sans la fermer, définissez la propriété <codeph>visible</codeph> de la fenêtre sur <codeph>false</codeph>.
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.close.1.as"> Les exemples suivants indiquent comment fermer une fenêtre :
  
 <p>Avec une référence à l’occurrence de NativeWindow ( <codeph>windowObj</codeph>) :</p>
<codeblock>
windowObj.close();

</codeblock></example><example conref="examples\NativeWindow.close.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObj.stage.nativeWindow.close();
</codeblock></example><example conref="examples\NativeWindow.close.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader (ou fenêtre racine HTML) :
<codeblock>
window.close(); //overriddable in HTMLHost
</codeblock></example><example conref="examples\NativeWindow.close.4.as"> Ou :
<codeblock>
window.nativeWindow.close(); //not overriddable
</codeblock></example><example conref="examples\NativeWindow.close.5.as">  
 L’exemple suivant indique comment annuler une opération close (où <codeph>windowObj</codeph> est l’occurrence NativeWindow à fermer) :
<codeblock>
public function closeCommand():Boolean{
    var closeEvent:Event = new Event(Event.CLOSING,true,true);
    windowObj.dispatchEvent(closeEvent);
    if(!closeEvent.isDefaultPrevented()){
        windowObj.close();
        return true;
    } else {
      return false;
    }
}
</codeblock></example><example conref="examples\NativeWindow.close.6.as"> L’exemple suivant indique comment fermer une fenêtre à partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader (ou fenêtre racine HTML), tout en autorisant l’annulation de l’opération :
<codeblock>
&lt;script src="AIRAliases.js" type="text/javascript">&lt;/script>
&lt;script type="text/javascript">
    var dirtyData = false;
    function closeWindow(){
            var closingEvent = new air.Event(air.Event.CLOSING,true,true);
            window.nativeWindow.dispatchEvent(closingEvent);
               if(!closingEvent.isDefaultPrevented()){
                   window.nativeWindow.close();
                //or use: window.close(); 
               return true;
           } else {
               return false;
        }
    }
        
    function onClosing(event){
        if(dirtyData){
            event.preventDefault();
            //Save data...
        }
    }    

    window.nativeWindow.addEventListener(air.Event.CLOSING,onClosing);        
&lt;/script>
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/closed"><linktext>flash.display.NativeWindow.closed</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>flash.html.HTMLLoader</linktext></link><link href="../../flash/html/HTMLHost.html"><linktext>flash.html.HTMLHost</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:globalToScreen"><apiName>globalToScreen</apiName><shortdesc>
      Convertit un point en coordonnées pixels par rapport à l’origine de la scène de la fenêtre (un point global en termes de liste d’affichage), en un point sur le bureau virtuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Le point global spécifié par rapport au bureau.
      
      </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>globalPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le point sur la scène à convertir en un point sur l’écran.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Convertit un point en coordonnées pixels par rapport à l’origine de la scène de la fenêtre (un point global en termes de liste d’affichage), en un point sur le bureau virtuel.
      
      <p>Les coordonnées de bureau virtuel sont relatives à l’angle supérieur gauche du moniteur principal.</p>
      
      </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:maximize"><apiName>maximize</apiName><shortdesc>
      Agrandit cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la propriété <codeph>maximizable</codeph> de cette fenêtre est <codeph>false</codeph> ou si la méthode est appelée après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Agrandit cette fenêtre.  
      <p>
      L’appel de <codeph>maximize()</codeph> distribue un événement <codeph>displayStateChange</codeph> et, le cas échéant, un événement <codeph>move</codeph> et <codeph>resize</codeph>. Le chrome système distribue un événement <codeph>displayStateChanging</codeph> pouvant être annulé lorsqu’une commande maximize est lancée par un utilisateur, mais votre logique maximize doit implémenter ce comportement, si nécessaire.
      </p>
      <p>
      La méthode <codeph>maximize()</codeph> s’exécute de façon asynchrone. Pour détecter la fin du changement d’état, écoutez l’événement <codeph>displayStateChange</codeph>.
      </p>
      <p>Si la fenêtre est déjà agrandie, aucune action n’est effectuée et aucun événement n’est distribué.</p>
      
      <p><b>Remarques :</b></p> 
      <ul>
      <li>Sous certains systèmes d’exploitation tels que Mac OS X, dans lesquels l’agrandissement d’une fenêtre n’empêche pas le redimensionnement, l’appel de <codeph>maximize()</codeph> effectue un zoom sur la fenêtre pour qu’elle remplisse l’écran, mais n’empêche pas son redimensionnement ultérieur. Le redimensionnement d’une fenêtre sur laquelle un zoom a été effectué restaure également l’état d’affichage.</li>
      
      <li>Sous certains systèmes d’exploitation tels que Mac OS X, ainsi que dans certains gestionnaires de fenêtres sous Linux, les fenêtres ne sont pas agrandies au-delà de la largeur et de la hauteur définies dans la propriété <codeph>maxSize</codeph>. Par contre, sous d’autres systèmes d’exploitation, la fenêtre s’agrandit pour occuper la totalité de l’écran, même si l’écran est plus large que la propriété <codeph>maxSize</codeph>.</li>
      
      <li>Certains gestionnaires de fenêtres de Linux ne permettent pas d’agrandir les fenêtres d’utilitaire.</li>
      
      </ul>
      
      </apiDesc><example conref="examples\NativeWindow.maximize.1.as">  
 L’exemple suivant indique comment autoriser l’annulation d’une opération d’agrandissement :  
<codeblock>
public function maximizeWindow(nativeWin:NativeWindow):Boolean{
  if(nativeWin.displayState != NativeWindowDisplayState.MAXIMIZED){
    var beforeState:String = nativeWin.displayState;
    var afterState:String = NativeWindowDisplayState.MAXIMIZED;
    var displayStateEvent:NativeWindowDisplayStateEvent = 
        new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
    nativeWin.dispatchEvent(displayStateEvent);
    if(!displayStateEvent.isDefaultPrevented()){
        nativeWin.maximize();
        return true;
    } else {
      return false;
    }
  }
  return false;
}
</codeblock></example><example conref="examples\NativeWindow.maximize.2.as">  
 L’exemple suivant indique comment autoriser l’annulation d’une opération d’agrandissement à partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader sur la fenêtre (ou une fenêtre HTML) :  
<codeblock>
function maximizeWindow(nativeWin){
    if(nativeWin.displayState != air.NativeWindowDisplayState.MAXIMIZED){
        var beforeState = nativeWin.displayState;
        var afterState = air.NativeWindowDisplayState.MAXIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.maximize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:minimize"><apiName>minimize</apiName><shortdesc>
      Réduit cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la propriété <codeph>minimizable</codeph> de cette fenêtre est <codeph>false</codeph> ou si la méthode est appelée après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Réduit cette fenêtre. 
      <p>
      L’appel de <codeph>minimize()</codeph> distribue un événement <codeph>displayStateChange</codeph> et, le cas échéant, un événement <codeph>move</codeph> et <codeph>resize</codeph>. Un chrome système distribue un événement <codeph>displayStateChanging</codeph> pouvant être annulé lorsqu’une commande minimize est lancée par un utilisateur alors que l’appel direct de <codeph>minimize()</codeph> ne le fait pas. Votre logique minimize peut implémenter ce comportement, si nécessaire.
      </p>
      
      <p>La méthode <codeph>minimize()</codeph> s’exécute de façon asynchrone. Pour détecter la fin du changement d’état, écoutez l’événement <codeph>displayStateChange</codeph>. Si la fenêtre est déjà réduite, aucune action n’est entreprise et aucun événement n’est distribué.</p>
      
      <p>Certains gestionnaires de fenêtres de Linux ne permettent pas de minimiser les fenêtres d’utilitaire.</p>
      
	  </apiDesc><example conref="examples\NativeWindow.minimize.1.as"> L’exemple suivant indique comment autoriser l’annulation d’un appel à <codeph>minimize()</codeph> en distribuant un événement <codeph>displayStateChanging</codeph> : 
<codeblock>
public function minimizeWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.MINIMIZED){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.minimize.2.as"> L’exemple suivant indique comment autoriser l’annulation d’un appel à <codeph>minimize()</codeph> dans le code JavaScript s’exécutant dans un objet HTMLLoader (ou une fenêtre HTML) : 
<codeblock> 
function minimizeWindow(){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.MINIMIZED){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:notifyUser"><apiName>notifyUser</apiName><shortdesc>
      Déclenche un repère visuel via le système d’exploitation indiquant qu’un événement intéressant s’est produit.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne représentant l’urgence de la notification.   
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      Déclenche un repère visuel via le système d’exploitation indiquant qu’un événement intéressant s’est produit.
      
      <p>Lorsque <codeph>NativeWindow.supportsNotification</codeph> est <codeph>true</codeph>, le repère visuel se conforme à la convention du système d’exploitation du système natif. Par exemple, dans Windows, l’icône de la barre des tâches clignote.</p>
      
      <p>Le paramètre <codeph>type</codeph> détermine l’intensité du repère. Les constantes pour les valeurs autorisées sont définies dans la classe NotificationType et peuvent être :</p>
      <ul>
      <li><codeph>NotificationType.INFORMATIONAL</codeph></li>
      <li><codeph>NotificationType.CRITICAL</codeph></li>
      </ul>
      <p>Les repères fournis pour des notifications informelles durent peu de temps ; ceux fournis pour des notifications cruciales durent jusqu’à ce que l’utilisateur active cette fenêtre. Tous les gestionnaires de fenêtres de Linux ne prennent pas en charge ces deux niveaux de notification. Pour ce type de gestionnaires de fenêtres, la méthode <codeph>notifyUser()</codeph> a le même effet, quelle que soit l’option spécifiée.</p>
      
      <p><b>Remarque :</b> l’appel de <codeph>notifyUser()</codeph> lorsque <codeph>NativeWindow.supportsNotification</codeph> est <codeph>false</codeph> est autorisé mais n’a aucune incidence.</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInBackOf"><apiName>orderInBackOf</apiName><shortdesc>
      Envoie cette fenêtre juste derrière la fenêtre spécifiée. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si cette fenêtre a été envoyée à l’arrière ; <codeph>false</codeph> si cette fenêtre est invisible ou réduite.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>Une fenêtre d’application.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Envoie directement cette fenêtre derrière la fenêtre spécifiée. 
      
      <p>N’active ni n’acquiert le focus pour la fenêtre ou l’application. Les fenêtres réduites ou masquées (<codeph>visible</codeph> est défini sur <codeph>false</codeph>) ne peuvent pas être réorganisées.</p>
      
      <p>Certains gestionnaires de fenêtres de Linux ne permettent pas de placer des fenêtres d’utilitaire derrière des fenêtres normales.</p>
      
      </apiDesc><example conref="NativeWindow.orderInBackOf.1.as"> Les exemples suivants indiquent comment déplacer une fenêtre juste au-dessous d’une autre fenêtre avec des références aux occurrences NativeWindow :
<codeblock>
windowBehind.orderInBackOf(windowFront);
</codeblock></example><example conref="NativeWindow.orderInBackOf.2.as"> Avec des références à des objets d’affichage sur les scènes de la fenêtre :
<codeblock>
displayObjBehind.stage.nativeWindow.orderInBackOf(displayObjectFront.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInBackOf.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader (ou fenêtre racine HTML) utilisant des références à deux objets window JavaScript :
<codeblock>
jsWindowObjBehind.nativeWindow.orderInBackOf(jsWindowObjFront.nativeWindow);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInFrontOf"><apiName>orderInFrontOf</apiName><shortdesc>
      Déplace cette fenêtre directement devant la fenêtre spécifiée. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si cette fenêtre a été déplacée à l’avant ; <codeph>false</codeph> si cette fenêtre est invisible ou réduite.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>Une fenêtre d’application.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Déplace cette fenêtre directement devant la fenêtre spécifiée. 
      
      <p>N’active ni n’acquiert le focus pour la fenêtre ou l’application. Les fenêtres réduites ou masquées (<codeph>visible</codeph> est défini sur <codeph>false</codeph>) ne peuvent pas être réorganisées.</p>
      
      <p>Certains gestionnaires de fenêtres de Linux ne permettent pas de placer des fenêtres normales devant des fenêtres d’utilitaire.</p>
      
      </apiDesc><example conref="NativeWindow.orderInFrontOf.1.as"> Les exemples suivants indiquent comment déplacer une fenêtre juste au-dessus d’une autre fenêtre avec des références aux occurrences NativeWindow :
<codeblock>
windowFront.orderInFrontOf(windowBehind);
</codeblock></example><example conref="NativeWindow.orderInFrontOf.2.as"> Avec des références à des objets d’affichage sur les scènes de la fenêtre :
<codeblock>
displayObjFront.stage.nativeWindow.orderInFrontOf(displayObjectBehind.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInFrontOf.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader (ou fenêtre racine HTML) utilisant des références à deux objets window JavaScript :
<codeblock>
jsWindowObjFront.nativeWindow.orderInFrontOf(jsWindowObjBehind.nativeWindow);

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToBack"><apiName>orderToBack</apiName><shortdesc>
      Envoie cette fenêtre derrière les autres fenêtres visibles. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si cette fenêtre a été envoyée à l’arrière ; <codeph>false</codeph> si cette fenêtre est invisible ou réduite.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Envoie cette fenêtre derrière les autres fenêtres visibles. 
      
      <p>N’active ni n’acquiert le focus pour cette fenêtre ou l’application. Les fenêtres réduites ou masquées (<codeph>visible</codeph> est défini sur <codeph>false</codeph>) ne peuvent pas être réorganisées.</p>
      
      <p>Si <codeph>alwaysInFront </codeph> est défini sur <codeph>true</codeph>, l’appel de cette méthode n’envoie pas cette fenêtre derrière des fenêtres ayant <codeph>alwaysInFront</codeph> défini sur <codeph>false</codeph>.</p>
      
      <p>Certains gestionnaires de fenêtres de Linux ne permettent pas de placer des fenêtres d’utilitaire derrière des fenêtres normales.</p>
      
      </apiDesc><example conref="NativeWindow.orderToBack.1.as"> Les exemples suivants indiquent comment déplacer une fenêtre derrière toutes les autres fenêtres dans l’application (avec le même paramètre <codeph>alwaysInFront</codeph>) :
<codeblock>
windowObj.orderToBack();

</codeblock></example><example conref="NativeWindow.orderToBack.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObj.stage.nativeWindow.orderToBack();
</codeblock></example><example conref="NativeWindow.orderToBack.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader dans la fenêtre (ou une fenêtre HTML racine) :
<codeblock>
window.nativeWindow.orderToBack();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToFront"><apiName>orderToFront</apiName><shortdesc>
      Déplace cette fenêtre devant toute autre fenêtre visible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si cette fenêtre a été déplacée à l’avant ; <codeph>false</codeph> si cette fenêtre est invisible ou réduite.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Déplace cette fenêtre devant toute autre fenêtre visible. 
      
      <p>N’active ni n’acquiert le focus pour cette fenêtre ou l’application. Les fenêtres réduites ou masquées (<codeph>visible</codeph> est défini sur <codeph>false</codeph>) ne peuvent pas être réorganisées.</p>
       
      <p>Si <codeph>alwaysInFront </codeph> est défini sur <codeph>false</codeph>, l’appel de cette méthode n’envoie pas cette fenêtre devant des fenêtres ayant <codeph>alwaysInFront</codeph> défini sur <codeph>true</codeph>.</p>
      
      <p>Certains gestionnaires de fenêtres de Linux ne permettent pas de placer des fenêtres normales devant des fenêtres d’utilitaire.</p> 
      
      </apiDesc><example conref="NativeWindow.orderToFront.1.as"> Les exemples suivants indiquent comment déplacer une fenêtre devant toutes les autres fenêtres dans l’application (avec le même paramètre <codeph>alwaysInFront</codeph>) :
<codeblock>
windowObj.orderToFront();

</codeblock></example><example conref="NativeWindow.orderToFront.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObj.stage.nativeWindow.orderToFront();
</codeblock></example><example conref="NativeWindow.orderToFront.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader dans la fenêtre (ou une fenêtre HTML racine) :
<codeblock>
window.nativeWindow.orderToFront();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:restore"><apiName>restore</apiName><shortdesc>
      Restaure cette fenêtre d’un état réduit ou agrandi.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la méthode est appelée après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Restaure cette fenêtre d’un état réduit ou agrandi.
      
      <p>L’appel de <codeph>restore()</codeph> distribue un événement <codeph>displayStateChange</codeph> et, le cas échéant, un événement <codeph>move</codeph> et <codeph>resize</codeph>. Le chrome système distribue un événement <codeph>displayStateChanging</codeph> pouvant être annulé lorsqu’une commande restore est lancée par un utilisateur, mais votre logique restore doit implémenter ce comportement, le cas échéant.
      </p>
      
      <p>Si la fenêtre est déjà dans l’état <codeph>NativeWindowDisplayState.NORMAL</codeph>, aucune action n’est effectuée et aucun événement n’est distribué.</p>
      
      <p>
      Pour détecter la fin du changement d’état, écoutez l’événement <codeph>displayStateChange</codeph>, qui est distribué sur toutes les plates-formes. 
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.restore.1.as">  
 L’exemple suivant indique comment autoriser l’annulation d’une opération de restauration : 
<codeblock>
public function restoreWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.NORMAL){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.NORMAL;
        var displayStateChangingEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateChangingEvent);
        if(!displayStateChangingEvent.isDefaultPrevented()){
            nativeWin.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.restore.2.as"> L’exemple suivant indique comment autoriser l’annulation d’une opération de restauration à partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader sur la fenêtre (ou une fenêtre HTML) : 
<codeblock>
function restoreWindow(nativeWin){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.NORMAL){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.NORMAL;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:startMove"><apiName>startMove</apiName><shortdesc>
      Commence le déplacement commandé par le système de cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la méthode est appelée après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> si le déplacement a été initié et <codeph>false</codeph> si la fenêtre est agrandie.
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Commence le déplacement commandé par le système de cette fenêtre.
      <p>
      Lorsqu’elle est appelée d’un événement <codeph>mouseDown</codeph>, cette méthode lance une séquence de déplacement gérée par la souris qui continue jusqu’à ce que l’événement <codeph>mouseUp</codeph> ait lieu. 
      </p>
      <p>
      Lorsque cette méthode est appelée d’un autre code, elle lance une séquence de déplacement gérée par un clavier ou une souris cohérente avec la séquence par défaut du système d’exploitation.
      </p>
      
      <p>Lors d’une séquence de déplacement, une série d’événements est distribuée lors du déplacement de l’origine de la fenêtre. Pour chaque déplacement incrémentiel, un événement <codeph>moving</codeph> est d’abord distribué puis, si l’événement <codeph>moving</codeph> n’est pas annulé, l’emplacement de la fenêtre est mis à jour et un événement <codeph>move</codeph> est distribué. Si un événement <codeph>moving</codeph> est annulé, la séquence move est arrêtée immédiatement.</p>
      
      </apiDesc><example conref="NativeWindow.startMove.1.as"> L’exemple suivant indique comment déplacer une fenêtre en réponse à un événement <codeph>mouseDown</codeph> :
<codeblock>
var initOpts:NativeWindowInitOptions = new NativeWindowInitOptions();
var win:NativeWindow = new NativeWindow(initOpts);
win.activate();
win.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);

function mouseDownHandler(event:MouseEvent):void
{
    win.startMove();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:startResize"><apiName>startResize</apiName><shortdesc>
      Commence une opération de redimensionnement commandée par le système de cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la méthode est appelée après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> si le redimensionnement a été initié et <codeph>false</codeph> si la fenêtre est agrandie.

      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>edgeOrCorner</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Une constante de la classe NativeWindowResize qui spécifie le bord ou l’angle de cette fenêtre à redimensionner. Les valeurs suivantes sont prises en charge :
      
      <p>
      <adobetable class="innertable">
          
           
           
           
           
            
            
            
            
            
           
      <tgroup cols="3"><thead><row><entry>Valeur</entry><entry>Alignement vertical</entry><entry>Alignement horizontal</entry></row></thead><tbody><row><entry><codeph>NativeWindowResize.TOP</codeph></entry>
           <entry>Haut</entry>
           <entry>Centre</entry>
           </row><row><entry><codeph>NativeWindowResize.BOTTOM</codeph></entry>
           <entry>Bas</entry>
           <entry>Centre</entry>
           </row><row><entry><codeph>NativeWindowResize.LEFT</codeph></entry>
           <entry>Centre</entry>
           <entry>Gauche</entry>
           </row><row><entry><codeph>NativeWindowResize.RIGHT</codeph></entry>
           <entry>Centre</entry>
           <entry>Droit</entry>
           </row><row><entry><codeph>NativeWindowResize.TOP_LEFT</codeph></entry>
            <entry>Haut</entry>
            <entry>Gauche</entry>
            </row><row><entry><codeph>NativeWindowResize.TOP_RIGHT</codeph></entry>
            <entry>Haut</entry>
            <entry>Droit</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_LEFT</codeph></entry>
            <entry>Bas</entry>
            <entry>Gauche</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_RIGHT</codeph></entry>
            <entry>Bas</entry>
            <entry>Droit</entry>
            </row><row><entry><codeph>NativeWindowResize.NONE</codeph></entry>
            <entry>Bas</entry>
            <entry>Droit</entry>
            </row></tbody></tgroup></adobetable>
      </p>
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Commence une opération de redimensionnement commandée par le système de cette fenêtre.
      <p>
      Lorsqu’elle est appelée d’un gestionnaire d’événement <codeph>mouseDown</codeph>, cette méthode lance une séquence de redimensionnement effectuée par la souris qui continue jusqu’à ce que l’événement <codeph>mouseUp</codeph> ait lieu.  
      </p>
      <p>
      Lorsque cette méthode est appelée d’un autre code, elle lance une séquence de redimensionnement effectuée par un clavier ou une souris cohérente avec la séquence par défaut du système d’exploitation.
      </p>
      <p>Lors d’une séquence de redimensionnement, une série d’événements est distribuée lors du changement de dimensions de la fenêtre. Pour chaque changement incrémentiel, un événement <codeph>resizing</codeph> est d’abord distribué puis, si l’événement <codeph>resizing</codeph> n’est pas annulé, les dimensions de la fenêtre sont mises à jour et un événement <codeph>resize</codeph> est distribué. Si un événement <codeph>resizing</codeph> est annulé, la séquence move est arrêtée immédiatement.</p>
      
      </apiDesc><example conref="NativeWindow.startResize.1.as"> L’exemple suivant indique comment redimensionner une fenêtre en réponse à un événement <codeph>mouseDown</codeph> :
<codeblock>
stage.addEventListener(MouseEvent.MOUSE_DOWN, onResizeCommand);

function onResizeCommand(event:MouseEvent):void
{
    var win:NativeWindow = event.target.nativeWindow;
    var resizeFrom:String = "";
    if (event.stageY &lt; win.height * .33)
    {
        resizeFrom = NativeWindowResize.TOP;
    }
    else if (event.stageY > win.height * .66)
    {
        resizeFrom = NativeWindowResize.BOTTOM;
    }
    if (event.stageX &lt; win.width * .33)
    {
        resizeFrom += NativeWindowResize.LEFT;
    }
    else if (event.stageX > win.width * .66)
    {
        resizeFrom += NativeWindowResize.RIGHT;
    }
    win.startResize(resizeFrom);    
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeWindow:active:get"><apiName>active</apiName><shortdesc>
      Indique si cette fenêtre est la fenêtre de l’application active.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Indique si cette fenêtre est la fenêtre de l’application active.
      
      <p>Utilisez la méthode <codeph>activate()</codeph> pour activer une fenêtre.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate"><linktext>flash.display.NativeWindow.activate</linktext></link><link href="flash.desktop.xml#NativeApplication/activate"><linktext>flash.desktop.NativeApplication.activate</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:alwaysInFront:get"><apiName>alwaysInFront</apiName><shortdesc>
      Spécifie si cette fenêtre est toujours devant d’autres fenêtres (y compris celles d’autres applications).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Spécifie si cette fenêtre est toujours devant d’autres fenêtres (y compris celles d’autres applications).
      
      <p>Il existe deux groupes de fenêtres dans l’ordre de profondeur du système. Les fenêtres du groupe <codeph>alwaysInFront</codeph> sont toujours affichées devant toutes les autres fenêtres. L’ordre de profondeur entre des fenêtres du même groupe est déterminé normalement. En d’autres termes, l’activation d’une fenêtre la déplace devant d’autres fenêtres de son groupe.</p>
      
      <p>Si vous changez <codeph>alwaysInFront</codeph> de <codeph>false</codeph> à <codeph>true</codeph>, la fenêtre est déplacée au-dessus de toutes les autres fenêtres. Si vous changez la propriété de <codeph>true</codeph> à <codeph>false</codeph>, la fenêtre est déplacée à l’arrière des fenêtres « alwaysInFront », mais toujours devant d’autres fenêtres. Si vous réglez la propriété sur sa valeur actuelle, l’ordre de profondeur de la fenêtre ne change pas.</p>
      
      <p>La propriété <codeph>alwaysInFront</codeph> ne doit que rarement être définie sur <codeph>true</codeph> car les fenêtres ayant ce réglage apparaissent devant les fenêtres d’autres applications même lorsque l’autre application est active.</p>
      
      <p>Certains gestionnaires de fenêtres de Linux affichent toujours les fenêtres d’utilitaire devant les fenêtres normales.</p>
      
      <p><b>Remarque :</b> sous Mac OS<sup>®</sup> X, le réglage de <codeph>alwaysInFront</codeph> sur <codeph>true</codeph> n’a aucune incidence lorsque la propriété <codeph>displayState</codeph> de la scène de la fenêtre est <codeph>fullScreen</codeph> ou <codeph>fullScreenInteractive</codeph>. Sous Linux, les fenêtres plein écran dont la propriété <codeph>alwaysInFront</codeph> est définie sur <codeph>true</codeph> s’affichent toujours devant les autres fenêtres dont la propriété <codeph>alwaysInFront</codeph> est définie sur <codeph>true</codeph>.</p> 
      
      </apiDesc><example conref="NativeWindow.alwaysInFront.1.as"> Les exemples suivants forcent une fenêtre à s’afficher devant toutes les autres fenêtres (qui ne sont pas forcées à s’afficher devant, comme elle) :
<codeblock>
windowObj.alwaysInFront = true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObject.stage.nativeWindow.alwaysInFront=true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader dans la fenêtre (ou une fenêtre HTML racine) :
<codeblock>
window.nativeWindow.alwaysInFront = true;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:bounds:set"><apiName>bounds</apiName><shortdesc>
      Taille et emplacement de cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>Si le rectangle est null ou contient des valeurs non valides.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété bounds après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      La taille et l’emplacement de cette fenêtre.  
      <p>
      Les dimensions d’une fenêtre incluent les chromes système. Les dimensions de la scène d’une fenêtre équivalent à celles de la fenêtre, moins la taille des chromes système. La modification de la largeur et de la hauteur de la fenêtre change les <codeph>stageWidth</codeph> et <codeph>stageHeight</codeph> de la scène. Le contraire s’applique également ; la modification des dimensions de la scène change la taille de la fenêtre.
      </p>
      <p>Dans une fenêtre HTML racine, les propriétés <codeph>outerWidth</codeph> et <codeph>outerHeigth</codeph> équivalent aux propriétés <codeph>height</codeph> et <codeph>width</codeph> de la fenêtre. Les propriétés <codeph>innerWidth</codeph> et <codeph>innerHeight</codeph> équivalent aux propriétés <codeph>stage.stageWidth</codeph> et <codeph>stage.stageHeight</codeph>, moins l’épaisseur des barres de défilement automatiques affichées par la fenêtre.</p>
      <p>
      Un événement <codeph>resize</codeph> est distribué chaque fois que la largeur ou la hauteur de cette fenêtre change. De même, un événement <codeph>move</codeph> est distribué chaque fois que l’origine (x,y) de cette fenêtre change. Sous Mac OS et Windows, la définition directe de la propriété <codeph>bounds</codeph> ne distribue pas d’événement <codeph>moving </codeph> ou <codeph>resizing</codeph>. Toutefois, sous Linux, l’objet NativeWindow <i>distribue</i> un événement <codeph>moving</codeph> et <codeph>resizing</codeph> lorsque vous définissez la propriété <codeph>bounds</codeph>. 
      </p>
      <p>
      La définition de la propriété <codeph>bounds</codeph> d’une fenêtre équivaut à la définition de ses propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph>. De même, définir l’une des dimensions individuelles revient à définir la propriété <codeph>bounds</codeph>. Lorsque vous définissez simultanément toutes les dimensions via la propriété <codeph>bounds</codeph>, moins d’événements sont distribués. 
      </p>
      <p>L’ordre dans lequel sont définies les dimensions individuelles n’est pas garanti. Sur les gestionnaires de fenêtres de Linux qui ne permettent pas d’agrandir les fenêtres au-delà de la zone du bureau, il est possible de bloquer la modification d’une propriété individuelle, même si la modification de toutes les propriétés aurait de toute façon entraîné la création d’une fenêtre autorisée.</p>
      
      <p>Si la largeur ou la hauteur spécifiée est inférieure à la largeur ou hauteur minimale, ou supérieure à la largeur ou hauteur maximale autorisée, la largeur ou la hauteur de la fenêtre est définie sur la taille autorisée la plus proche. Les facteurs qui déterminent les largeurs et les hauteurs minimales et maximales sont les suivants : </p>
      
      <ul>
      
      	<li>Propriétés <codeph>minSize</codeph> et <codeph>maxSize</codeph> de l’objet NativeWindow</li>
      	<li>Limites minimales et maximales du système d’exploitation, qui sont les valeurs de <codeph>NativeWindow.systemMinSize</codeph> et <codeph>NativeWindow.systemMaxSize</codeph></li>
      	<li>Largeur et hauteur maximales d’une fenêtre dans Adobe AIR, qui sont chacune de 2 880 pixels. </li>
      	<li>Largeur et hauteur minimales requises par tout chrome système affiché. </li>
      
      </ul>
      
	  </apiDesc><example conref="examples\NativeWindow.bounds.1.as"> Les exemples suivants définissent les limites d’une fenêtre avec une référence à un objet NativeWindow :
<codeblock>
windowObj.bounds = new Rectangle(200, 200, 1000, 800);
</codeblock></example><example conref="examples\NativeWindow.bounds.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObject.stage.nativeWindow.bounds = new Rectangle(20, 20, 800, 600);
</codeblock></example><example conref="examples\NativeWindow.bounds.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader dans la fenêtre (ou une fenêtre HTML racine) :
<codeblock>
window.nativeWindow.bounds = new air.Rectangle(20, 20, 800, 600);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:closed:get"><apiName>closed</apiName><shortdesc>
      Indique si cette fenêtre a été fermée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Indique si cette fenêtre a été fermée.  
      
      <p>L’accès aux propriétés suivantes dans une fenêtre fermée renvoie une erreur d’opération non autorisée :</p>
      <ul> 
      <li><codeph>title</codeph></li>
      <li><codeph>bounds</codeph></li>
      <li><codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, <codeph>height</codeph></li>
      <li><codeph>displayState</codeph></li>
      <li><codeph>visible</codeph></li>
      </ul>
      <p>De même, l’appel des méthodes suivantes sur une fenêtre fermée renvoie également une erreur d’opération non autorisée :</p>
      <ul>
      <li><codeph>minimize()</codeph></li>
      <li><codeph>maximize()</codeph></li>
      <li><codeph>restore()</codeph></li>
      <li><codeph>startResize()</codeph></li>
      <li><codeph>startMove()</codeph></li>
      </ul>
      
      </apiDesc><example conref="NativeWindow.closed.1.as"> Les exemples suivants indiquent comment accéder à la propriété <codeph>closed</codeph> d’une fenêtre :
<codeblock>
var isWindowClosed:Boolean = windowObj.closed;
</codeblock></example><example conref="NativeWindow.closed.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
var isWindowClosed:Boolean = displayObject.stage.nativeWindow.closed;
</codeblock></example><example conref="NativeWindow.closed.3.as"> A partir d’une routine JavaScript s’exécutant dans objet HTMLLoader dans la fenêtre (ou une fenêtre HTML racine) :
<codeblock>
var isWindowClosed = window.nativeWindow.closed;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:displayState:get"><apiName>displayState</apiName><shortdesc>
     Etat d’affichage de cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Si vous accédez à la propriété <codeph>displayState</codeph> après la fermeture de cette fenêtre.
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Etat d’affichage de cette fenêtre.
     <p>
     Les constantes pour les valeurs possibles sont définies dans la classe NativeWindowDisplayState : 
     </p>
     <ul>
     <li><codeph>NativeWindowDisplayState.NORMAL</codeph></li>
     <li><codeph>NativeWindowDisplayState.MINIMIZED</codeph></li>
     <li><codeph>NativeWindowDisplayState.MAXIMIZED</codeph></li>
     </ul> 
     
     </apiDesc><example conref="examples\NativeWindow.displayState.1.as"> L’exemple suivant indique comment obtenir l’état d’affichage de la fenêtre actuelle avec une référence à l’objet window :
<codeblock>
var state:String = windowObj.displayState;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:height:get"><apiName>height</apiName><shortdesc>
      La hauteur de cette fenêtre en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Si la valeur est définie sur <codeph>null</codeph> ou n’est pas valide.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      La hauteur de cette fenêtre en pixels.
      
      <p>Les dimensions d’une fenêtre comprennent tout chrome système affiché. La hauteur de la zone d’affichage utilisable est disponible depuis la propriété <codeph>Stage.stageHeight</codeph>.</p>
      
      <p>Changer la propriété <codeph>height</codeph> d’une fenêtre équivaut à changer la hauteur à l’aide de la propriété <codeph>bounds</codeph>.</p>
      
      <p>Si la hauteur spécifiée est inférieure à la hauteur minimale, ou supérieure à la hauteur maximale autorisée, la largeur ou la hauteur de la fenêtre est définie sur la taille autorisée la plus proche. Les facteurs qui déterminent les hauteurs minimales et maximales sont les suivants :</p>
      
      <ul>
      
      	<li>Propriétés <codeph>minSize.x</codeph> et <codeph>maxSize.x</codeph> de l’objet NativeWindow</li>
      	<li>Limites minimales et maximales du système d’exploitation, qui sont les valeurs de <codeph>NativeWindow.systemMinSize.x</codeph> et <codeph>NativeWindow.systemMaxSize.x</codeph>.</li>
      	<li>Hauteur maximale d’une fenêtre dans Adobe AIR, qui est de 2 880 pixels.</li>
      
      </ul>
      
      <p>Sous Linux, la définition de la propriété <codeph>height</codeph> est une opération asynchrone.</p>
     
      <p>
      Pour détecter la fin du changement de hauteur, écoutez l’événement <codeph>resize</codeph>, qui est distribué sur toutes les plates-formes.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageHeight"><linktext>flash.display.Stage.stageHeight</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maxSize:get"><apiName>maxSize</apiName><shortdesc>
      La taille maximale pour cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Si la taille attribuée ne se trouve pas dans la plage des tailles de fenêtre minimum et maximum du système d’exploitation. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si la taille est interdite pour les droits d’accès actuels au contenu.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si la taille est <codeph>null</codeph> ou contient des valeurs non valides.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété <codeph>maxSize</codeph> après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Taille maximale pour cette fenêtre.  
      
      <p>La limite de taille est spécifiée comme coordonnées d’un objet Point. La propriété <codeph>x</codeph> du point correspond à la largeur de la fenêtre et la propriété <codeph>y</codeph> à sa hauteur.</p>
      
      <p>
      La restriction <codeph>maxSize</codeph> est imposée pour les opérations de redimensionnement de la fenêtre qui sont invoquées au moyen du code <ph platform="actionscript">ActionScript</ph><ph platform="javascript">JavaScript</ph> et du système d’exploitation.
      </p>
      <p>
      La définition de <codeph>maxSize</codeph> change les limites de la fenêtre si les limites actuelles sont supérieures à la nouvelle taille maximale.
      </p>
      
      <p>Si la largeur ou la hauteur spécifiée est supérieure à la largeur ou hauteur maximal autorisée, la valeur est définie sur la taille autorisée la plus proche. Les facteurs qui déterminent les largeurs et les hauteurs maximales sont les suivants :</p>
      
      <ul>
      
      	<li>Limite maximale du système d’exploitation, qui est la valeur <codeph>NativeWindow.systemMaxSize</codeph>.</li>
      	<li>Largeur et hauteur maximales d’une fenêtre dans Adobe AIR, qui sont chacune de 2 880 pixels.</li>
      
      </ul>
      
      <p>
      <b>Remarque :</b> sous certains systèmes d’exploitation tels que Mac OS X, l’agrandissement d’une fenêtre n’augmente la taille de la fenêtre que jusqu’à la valeur <codeph>maxSize</codeph>, même si la fenêtre agrandie est plus petite que l’écran du système d’exploitation. La fenêtre demeure dans l’état d’affichage agrandi.
      </p>
      
      </apiDesc><example conref="NativeWindow.maxSize.1.as"> Les exemples suivants indiquent comment régler la taille maximale autorisée pour une fenêtre.
<codeblock>
windowObj.maxSize = new Point(1040,920);
</codeblock></example><example conref="NativeWindow.maxSize.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObject.stage.nativeWindow.maxSize = new Point(800,600);
</codeblock></example><example conref="NativeWindow.maxSize.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader dans une fenêtre (ou dans une fenêtre HTML racine) :
<codeblock>
window.nativeWindow.maxSize = new air.Point(960,960);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maximizable:get"><apiName>maximizable</apiName><shortdesc>
	 Indique le paramètre maximizable utilisé pour créer cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Lorsque vous tentez de définir la valeur <codeph>false</codeph> sans privilèges suffisants.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Indique le paramètre <codeph>maximizable</codeph> utilisé pour créer cette fenêtre.
	  
	 <p>Le paramètre <codeph>maximizable</codeph> ne peut pas être modifié après la création d’une fenêtre.</p>
	 
	 <p>Tous les gestionnaires de fenêtres de Linux ne tiennent pas compte du paramètre <codeph>maximizable</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/maximizable"><linktext>flash.display.NativeWindowInitOptions.maximizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:menu:get"><apiName>menu</apiName><shortdesc>
      Le menu natif pour cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
      Le menu natif pour cette fenêtre. 
      
      <p>Lorsqu’un objet NativeMenu est attribué à la propriété <codeph>menu</codeph> de la fenêtre, un menu natif s’affiche pour une fenêtre si <codeph>NativeWindow.supportsMenu</codeph> est <codeph>true</codeph>, à moins que la propriété <codeph>systemChrome</codeph> de la fenêtre soit <codeph>NativeWindowSystemChrome.NONE</codeph>.</p>
      
      <p><b>Remarque :</b> l’attribution d’un menu à une fenêtre lorsque <codeph>NativeWindow.supportsMenu</codeph> est <codeph>false</codeph> ou lorsque la propriété <codeph>systemChrome</codeph> de la fenêtre est <codeph>NativeWindowSystemChrome.NONE</codeph> est autorisée, mais n’a aucune incidence. Utilisez la propriété <codeph>NativeWindow.supportsMenu</codeph> pour déterminer si le système d’exploitation prend en charge les fenêtres de l’application. Faire appel à d’autres méthodes (comme <codeph>Capabilities.os</codeph>) pour déterminer les prises en charge peut entraîner des erreurs de programmation (si certains systèmes d’exploitation cible possibles ne sont pas pris en compte). </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minSize:get"><apiName>minSize</apiName><shortdesc>
      La taille minimale pour cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Si la taille attribuée ne se trouve pas dans la plage de tailles de fenêtre minimum et maximum du système d’exploitation. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si la taille est interdite pour les droits d’accès actuels au contenu.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si la taille est <codeph>null</codeph> ou contient des valeurs non valides.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété <codeph>minSize</codeph> après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Taille minimale pour cette fenêtre. 
       
      <p>La limite de taille est spécifiée comme coordonnées d’un objet Point. La propriété <codeph>x</codeph> du point correspond à la largeur de la fenêtre et la propriété <codeph>y</codeph> à sa hauteur.</p>
      <p>
      Le réglage de <codeph>minSize</codeph> change les limites de la fenêtre si les limites actuelles sont inférieures à la nouvelle taille minimale.
      </p>
      <p>
      La restriction <codeph>minSize</codeph> est imposée pour les opérations de redimensionnement de la fenêtre qui sont invoquées au moyen du code <ph platform="actionscript">ActionScript</ph><ph platform="javascript">JavaScript</ph> et du système d’exploitation.
      </p>
      <p>
      <b>Remarque :</b> la largeur et la hauteur de tout chrome système affiché risquent de rendre impossible le réglage d’une fenêtre à une taille aussi petite que la taille minimale spécifiée. 
      </p>
      
      </apiDesc><example conref="NativeWindow.minSize.1.as"> Les exemples suivants indiquent comment régler la taille minimale autorisée pour une fenêtre:
<codeblock>
windowObj.minSize = new Point(200,80);
</codeblock></example><example conref="NativeWindow.minSize.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObject.stage.nativeWindow.minSize = new Point(120,60);
</codeblock></example><example conref="NativeWindow.minSize.3.as"> A partir d’une routine JavaScript s’exécutant dans un objet HTMLLoader dans une fenêtre (ou dans une fenêtre HTML racine) :
<codeblock>
window.nativeWindow.minSize = new air.Point(80,60);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minimizable:get"><apiName>minimizable</apiName><shortdesc>
	 Indique le paramètre minimizable utilisé pour créer cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Lorsque vous tentez de définir la valeur <codeph>false</codeph> sans privilèges suffisants.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Indique le paramètre <codeph>minimizable </codeph>utilisé pour créer cette fenêtre.
	 
	 <p>Le paramètre <codeph>minimizable</codeph> ne peut pas être modifié après la création d’une fenêtre.</p>
	 
	 <p>Tous les gestionnaires de fenêtres de Linux ne tiennent pas compte du paramètre <codeph>minimizable</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/minimizable"><linktext>flash.display.NativeWindowInitOptions.minimizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:resizable:get"><apiName>resizable</apiName><shortdesc>
	 Indique le paramètre resizable utilisé pour créer cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Lorsque vous tentez de définir la valeur <codeph>false</codeph> sans privilèges suffisants.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Indique le paramètre <codeph>resizable</codeph> utilisé pour créer cette fenêtre.
	 
	 <p>Le paramètre <codeph>resizable</codeph> ne peut pas être modifié après la création d’une fenêtre.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:stage:get"><apiName>stage</apiName><shortdesc>
      L’objet Stage pour cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
      Objet Stage pour cette fenêtre. <ph platform="actionscript">L’objet Stage est l’objet racine dans l’architecture de la liste d’affichage utilisée dans le contenu SWF basé sur ActionScript 3.0.</ph>
      
      <p>
      La scène est la racine de la liste d’affichage pour la fenêtre. Ajoutez des objets visual display à une fenêtre en les ajoutant à la scène ou à un autre objet se trouvant déjà dans la liste d’affichage de cette scène. Les dimensions de la scène sont celles de la zone client de la fenêtre lorsque celle-ci utilise le chrome système. Les dimensions de la scène équivalent à celles de la fenêtre si le chrome système n’est pas utilisé.
      </p>
      
      <p platform="javascript">Le HTMLLoader, qui rend le contenu HTML, est une seule feuille dans l’arborescence de la liste d’affichage. Les objets d’affichage définis par ActionScript peuvent être au-dessus et au-dessous du HTMLLoader dans l’ordre du dessin, mais pas entre les éléments visuels rendus par le HTMLLoader.</p>
      
      </apiDesc><example conref="NativeWindow.stage.1.as"> L’exemple suivant indique comment définir les propriétés stage pour une occurrence NativeWindow :
<codeblock>
import flash.display.StageAlign;

windowObj.stage.align = StageAlign.TOP_LEFT;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage"><linktext>flash.display.Stage</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
      Indique si AIR prend en charge les menus de fenêtre natifs sur le système de l’ordinateur actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Indique si AIR prend en charge les menus de fenêtre natifs sur le système de l’ordinateur actuel.
      
      <p>Lorsque <codeph>NativeWindow.supportsMenu</codeph> est <codeph>true</codeph>, un menu natif est affiché pour une fenêtre lorsqu’un objet NativeMenu est attribué à la propriété <codeph>menu</codeph> de cette fenêtre, à moins que la propriété <codeph>systemChrome</codeph> soit <codeph>NativeWindowSystemChrome.NONE</codeph>. Utilisez la propriété <codeph>NativeWindow.supportsMenu</codeph> pour déterminer si le système d’exploitation prend en charge les menus de fenêtre natifs de l’application. Faire appel à d’autres méthodes (comme <codeph>Capabilities.os</codeph>) pour déterminer les prises en charge peut entraîner des erreurs de programmation (si certains systèmes d’exploitation cible possibles ne sont pas pris en compte). </p>
      
      <p><b>Remarque :</b> l’attribution d’un menu à une fenêtre lorsque <codeph>NativeWindow.supportsMenu</codeph> est <codeph>false</codeph> ou lorsque la propriété <codeph>systemChrome</codeph> de la fenêtre est <codeph>NativeWindowSystemChrome.NONE</codeph> est autorisée, mais n’a aucune incidence.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsMenu"><linktext>flash.desktop.NativeApplication.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsNotification:get"><apiName>supportsNotification</apiName><shortdesc> 
      Indique si AIR prend en charge le repérage de notification de fenêtre sur le système de l’ordinateur actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Indique si AIR prend en charge le repérage de notification de fenêtre sur le système de l’ordinateur actuel.
      
      <p>Lorsque <codeph>NativeWindow.supportsNotification</codeph> est <codeph>true</codeph>, l’appel de la méthode <codeph>notifyUser()</codeph> de la fenêtre entraîne l’affichage d’un repère visuel indiquant à l’utilisateur qu’un événement intéressant s’est produit. Ce repère visuel est conforme à la convention du système d’exploitation du système natif. Par exemple, sous Windows<sup>®</sup>, l’icône de la barre des tâches clignote.</p>
      
      <p><b>Remarque :</b> l’appel de <codeph>notifyUser()</codeph> lorsque <codeph>NativeWindow.supportsNotification</codeph> est <codeph>false</codeph> est autorisé mais n’a aucune incidence.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsTransparency:get"><apiName>supportsTransparency</apiName><shortdesc> 
      Indique si AIR prend en charge les fenêtres natives avec des pixels transparents.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Indique si AIR prend en charge les fenêtres natives avec des pixels transparents.
      
      <p>Lorsque <codeph>NativeWindow.supportsTransparency</codeph> est <codeph>true</codeph>, la transparence des pixels d’une fenêtre native est respectée si la propriété <codeph>transparent</codeph> de la fenêtre est définie sur <codeph>true</codeph>. L’opacité de tous les pixels est définie sur 1 si <codeph>NativeWindow.supportsTransparency</codeph> est <codeph>false</codeph>, quelle que soit la valeur de la propriété <codeph>transparent</codeph> de la fenêtre. Les pixels complètement transparents apparaissent en noir lorsque la propriété <codeph>NativeWindow.supportsTransparency</codeph> est définie sur <codeph>false</codeph>. Utilisez la propriété <codeph>NativeWindow.supportsTransparency</codeph> pour déterminer si le système d’exploitation prend en charge la transparence. Faire appel à d’autres méthodes (comme <codeph>Capabilities.os</codeph>) pour déterminer les prises en charge peut entraîner des erreurs de programmation (si certains systèmes d’exploitation cible possibles ne sont pas pris en compte). </p>
      
      <p><b>Remarque :</b> la valeur de cette propriété peut changer en fonction des préférences de l’utilisateur du système d’exploitation si une application est en cours d’exécution.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/transparent"><linktext>flash.display.NativeWindow.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
	 Indique le paramètre de chrome système utilisé pour créer cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Lorsque vous tentez de définir la valeur <codeph>false</codeph> sans privilèges suffisants.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Indique le paramètre de chrome système utilisé pour créer cette fenêtre.
	 
	 <p>Les valeurs renvoyées par <codeph>NativeWindow.systemChrome</codeph> sont l’une des constantes définies dans la classe NativeWindowSystemChrome.</p>
	 
	 <p>Le paramètre de chrome système ne peut pas être modifié après la création d’une fenêtre.</p>
	 
	 </apiDesc><example conref="NativeWindow.systemChrome.1.as"> L’exemple suivant indique comment obtenir le chrome système pour une fenêtre : 
<codeblock>
var sysChromeType:String = windowObj.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
var sysChromeType:String = displayObject.stage.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.3.as"> A partir d’une routine JavaScript s’exécutant dans objet HTMLLoader dans la fenêtre (ou une fenêtre HTML racine) :
<codeblock>
var sysChromeType = window.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.4.as"> L’exemple suivant indique comment changer les paramètres de transparence et de chrome système apparents en créant une fenêtre et en déplaçant tous les objets d’affichage enfant vers la nouvelle fenêtre :
<codeblock>
import flash.display.NativeWindow;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowInitOptions;

public function deChromeWindow(oldWindow:NativeWindow):NativeWindow{
    if(oldWindow.systemChrome != NativeWindowSystemChrome.NONE){
        var newOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
        newOptions.systemChrome = NativeWindowSystemChrome.NONE;
        newOptions.transparent = true;
        
        var newWindow:NativeWindow = new NativeWindow(newOptions);
        newWindow.stage.stageWidth = oldWindow.stage.stageWidth;
        newWindow.stage.stageHeight = oldWindow.stage.stageHeight;
        newWindow.stage.align = oldWindow.stage.align;
        newWindow.stage.scaleMode = oldWindow.stage.scaleMode;
        
        for(var i:int = 0; i &lt; oldWindow.stage.numChildren; i++){
            newWindow.stage.addChild(oldWindow.stage.getChildAt(i));
        }
        newWindow.activate();
        oldWindow.close();
        
        return newWindow;
    }
    return oldWindow;
}

</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/systemChrome"><linktext>flash.display.NativeWindowInitOptions.systemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemMaxSize:get"><apiName>systemMaxSize</apiName><shortdesc>
	 La taille de fenêtre la plus grande autorisée par le système d’exploitation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 La taille de fenêtre la plus grande autorisée par le système d’exploitation.
	 
      <p>La limite de taille est spécifiée comme coordonnées d’un objet Point. La propriété <codeph>x</codeph> du point correspond à la largeur de la fenêtre et la propriété <codeph>y</codeph> à sa hauteur.</p>
      
      <p>Outre la limite de taille du système d’exploitation, AIR a une taille de fenêtre maximale de 2 880 sur 2 880 pixels. Une application peut définir une limite à l’aide de la propriété <codeph>maxSize</codeph> de l’objet NativeWindow.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:systemMinSize:get"><apiName>systemMinSize</apiName><shortdesc>
	 La taille de fenêtre la plus petite autorisée par le système d’exploitation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 La taille de fenêtre la plus petite autorisée par le système d’exploitation.
	 
      <p>La limite de taille est spécifiée comme coordonnées d’un objet Point. La propriété <codeph>x</codeph> du point correspond à la largeur de la fenêtre et la propriété <codeph>y</codeph> à sa hauteur.</p>
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:title:set"><apiName>title</apiName><shortdesc>
      Le titre de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Low-privilege apps will probably have a string appended to all of their title strings
      
      </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Le titre de la fenêtre.  
      <p>
      Le titre apparaît dans le chrome système pour la fenêtre, le cas échéant, ainsi que dans d’autres emplacements dépendant du système (la barre des tâches, par exemple).
      </p>
      
      </apiDesc><example conref="NativeWindow.title.1.as"> L’exemple suivant définit le titre d’un objet window :
<codeblock>
windowObj.title = "Window Title";
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Indique le paramètre de transparence utilisé pour créer cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Lorsque vous tentez de définir la valeur <codeph>false</codeph> sans privilèges suffisants.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Indique le paramètre de transparence utilisé pour créer cette fenêtre.
	 
     <p>La propriété <codeph>transparent</codeph> ne peut pas être modifiée après la création d’une fenêtre. La transparence affecte l’apparence visuelle et le comportement de la souris de la fenêtre. Sous Windows et Mac OS X, la fenêtre ne capture pas les événements de souris lorsque la valeur alpha du pixel est inférieure à un certain seuil, compris entre 0,06 et 0,01 selon le système d’exploitation. Sous Linux, la fenêtre capture les événements de souris au-dessus des zones complètement transparentes, ce qui, par conséquent, empêche les utilisateurs d’accéder à d’autres fenêtres ou éléments sur le bureau.</p>
     
     <p><b>Remarque :</b> la transparence de la fenêtre n’est pas toujours prise en charge. Il est possible que la transparence ne soit pas disponible selon la configuration du système d’exploitation de l’utilisateur, auquel cas la fenêtre est créée sans transparence. Les zones qui auraient été transparentes sont donc créées en noir. Utilisez la propriété <codeph>NativeWindow.supportsTransparency</codeph> pour déterminer si la transparence de la fenêtre est prise en charge.</p>
	 
	 </apiDesc><example conref="NativeWindow.transparent.1.as"/><example conref="NativeWindow.transparent.2.as"/><example conref="NativeWindow.transparent.3.as"/></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/transparent"><linktext>flash.display.NativeWindowInitOptions.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:type:get"><apiName>type</apiName><shortdesc>
	 Indique le paramètre de type de fenêtre utilisé pour créer cette fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Lorsque vous tentez de définir la valeur <codeph>false</codeph> sans privilèges suffisants.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Indique le paramètre <codeph>type</codeph> utilisé pour créer cette fenêtre.
	 
	 <p>Les valeurs renvoyées par <codeph>NativeWindow.type</codeph> sont l’une des constantes définies dans la classe NativeWindowType.</p>
	 
	 <p>Le paramètre <codeph>type</codeph> ne peut pas être modifié après la création d’une fenêtre.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/type"><linktext>flash.display.NativeWindowInitOptions.type</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:visible:get"><apiName>visible</apiName><shortdesc> 
      Spécifie si cette fenêtre est visible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Lorsque vous tentez de définir la valeur <codeph>false</codeph> sans privilèges suffisants.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
      Spécifie si cette fenêtre est visible.  
      
      <p>
      Une fenêtre invisible n’est pas affichée sur le bureau, mais toutes les méthodes et les propriétés window sont valides.
      </p> 
      <p>
      Par défaut, <codeph>visible</codeph> est définie sur <codeph>false</codeph>. Pour afficher une fenêtre, réglez <codeph>visible</codeph> sur <codeph>true</codeph> ou appelez <codeph>NativeWindow.activate()</codeph>.
      </p>
      <p>
      <b>Remarque :</b> sur Mac OS X, la définition de <codeph>visible=false</codeph> sur une fenêtre réduite ne supprime pas l’icône de la fenêtre du dock. Si un utilisateur clique ensuite sur l’icône du Dock, la fenêtre revient à l’état visible et s’affiche sur le bureau.
      </p>
      
      </apiDesc><example conref="NativeWindow.visible.1.as"> Les exemples suivants indiquent comment accéder à la propriété <codeph>visible</codeph> d’une fenêtre :
<codeblock>
windowObj.visible = true;
</codeblock></example><example conref="NativeWindow.visible.2.as"> Avec une référence à un objet d’affichage sur la scène de la fenêtre :
<codeblock>
displayObj.stage.nativeWindow.visible = true;
</codeblock></example><example conref="NativeWindow.visible.3.as"> A partir d’une routine JavaScript s’exécutant dans objet HTMLLoader dans la fenêtre (ou une fenêtre HTML racine) :
<codeblock>
window.nativeWindow.visible = true;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate()"><linktext>activate()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:width:get"><apiName>width</apiName><shortdesc>
      La largeur de cette fenêtre en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Si la valeur est définie sur <codeph>null</codeph> ou n’est pas valide.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Largeur de cette fenêtre en pixels.
      
      <p>Les dimensions indiquées pour une fenêtre native comprennent tout chrome système affiché. La largeur de la zone d’affichage utilisable est disponible depuis la propriété <codeph>Stage.stageWidth</codeph>.</p>
      
      <p>Changer la propriété <codeph>width</codeph> d’une fenêtre équivaut à changer la largeur à l’aide de la propriété <codeph>bounds</codeph>.</p>
      
      <p>Si la largeur spécifiée est inférieure à la hauteur minimale, ou supérieure à la largeur maximale autorisée, la largeur ou la largeur de la fenêtre est définie sur la taille autorisée la plus proche. Les facteurs qui déterminent les largeurs minimales et maximales sont les suivants :</p>
      
      <ul>
      
      	<li>Propriétés <codeph>minSize.y</codeph> et <codeph>maxSize.y</codeph> de l’objet NativeWindow</li>
      	<li>Limites minimales et maximales du système d’exploitation, qui sont les valeurs de <codeph>NativeWindow.systemMinSize.y</codeph> et <codeph>NativeWindow.systemMaxSize.y</codeph>.</li>
      	<li>Largeur maximale d’une fenêtre dans Adobe AIR, qui est de 2 880 pixels.</li>
      
      </ul>
      
      <p>Sous Linux, la définition de la propriété <codeph>width</codeph> est une opération asynchrone.</p>
      
      <p>
      Pour détecter la fin du changement de largeur, écoutez l’événement <codeph>resize</codeph>, qui est distribué sur toutes les plates-formes.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageWidth"><linktext>flash.display.Stage.stageWidth</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:x:get"><apiName>x</apiName><shortdesc>
      Coordonnée de l’axe horizontal de l’angle supérieur gauche de cette fenêtre par rapport à l’origine du bureau du système d’exploitation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Si la valeur est définie sur <codeph>null</codeph> ou n’est pas valide.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Coordonnée de l’axe horizontal de l’angle supérieur gauche de cette fenêtre par rapport à l’origine du bureau du système d’exploitation.
      
      <p>Sur les systèmes équipés de plusieurs écrans, <codeph>x</codeph> peut être négatif. Si vous enregistrez la valeur, par exemple pour repositionner une fenêtre à son emplacement précédent, pensez à toujours vérifier que la fenêtre est placée dans un emplacement utilisable lorsque la position est restaurée. Les modifications de la résolution ou de l’organisation de l’écran peuvent entraîner le placement de la fenêtre en dehors de l’écran. Utilisez la classe Screen pour obtenir des informations sur la géométrie du bureau.</p> 
      
      <p>Changer la propriété <codeph>x</codeph> d’une fenêtre équivaut à changer l’emplacement à l’aide de la propriété <codeph>bounds</codeph>.</p>
      
      <p>Sous Linux, la définition de la propriété <codeph>x</codeph> est une opération asynchrone.</p>
      
      <p>
      Pour détecter la fin du changement de position, écoutez l’événement <codeph>move</codeph>, qui est distribué sur toutes les plates-formes.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:y:get"><apiName>y</apiName><shortdesc>
      Coordonnée de l’axe vertical de l’angle supérieur gauche de cette fenêtre par rapport à l’angle supérieur gauche du bureau du système d’exploitation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Si la valeur est définie sur <codeph>null</codeph> ou n’est pas valide.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous accédez à la propriété après la fermeture de cette fenêtre.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Coordonnée de l’axe vertical de l’angle supérieur gauche de cette fenêtre par rapport à l’angle supérieur gauche du bureau du système d’exploitation.
      
      <p>Sur les systèmes équipés de plusieurs écrans, <codeph>y</codeph> peut être négatif. Si vous enregistrez la valeur, par exemple pour repositionner une fenêtre à son emplacement précédent, pensez à toujours vérifier que la fenêtre est placée dans un emplacement utilisable lorsque la position est restaurée. Les modifications de la résolution ou de l’organisation de l’écran peuvent entraîner le placement de la fenêtre en dehors de l’écran. Utilisez la classe Screen pour obtenir des informations sur la géométrie du bureau.</p> 
      
      <p>Changer la propriété <codeph>y</codeph> d’une fenêtre équivaut à changer l’emplacement à l’aide de la propriété <codeph>bounds</codeph>.</p>
      
      <p>Sous Linux, la définition de la propriété <codeph>y</codeph> est une opération asynchrone.</p>
       
      <p>
      Pour détecter la fin du changement de position, écoutez l’événement <codeph>move</codeph>, qui est distribué sur toutes les plates-formes.
      </p>
     
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Stage"><apiName>Stage</apiName><shortdesc>
 La classe Stage représente la zone de dessin principale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Stage représente la zone de dessin principale. 
 
 <p platform="actionscript">Pour le contenu SWF s’exécutant dans le navigateur (dans Flash<sup>®</sup> Player), la scène représente la zone entière où le contenu Flash est affiché. Pour le contenu s’exécutant dans AIR, chaque objet NativeWindow a un objet Stage correspondant.</p>
 
 <p platform="actionscript">Il est impossible d’accéder globalement à l’objet Stage. Vous devez y accéder à l’aide de la propriété <codeph>stage</codeph> d’une occurrence d’objet DisplayObject.</p> 
 
 <p platform="actionscript">La classe Stage descend de plusieurs autres classes, DisplayObjectContainer, InteractiveObject, DisplayObject et EventDispatcher, dont elle hérite des propriétés et des méthodes. La plupart de ces propriétés et de ces méthodes soit ne n’appliquent pas aux objets Stage, soit nécessite des vérifications de sécurité lorsqu’elles sont appelées sur un objet Stage. Les propriétés et les méthodes qui nécessitent des vérifications de sécurité sont documentées dans le cadre de la classe Stage.</p>
 
 <p platform="actionscript">Les propriétés héritées suivantes ne s’appliquent pas non plus aux objets Stage. Si vous tentez de les définir, une exception IllegalOperationError est renvoyée. Ces propriétés peuvent toujours être lues, mais dans la mesure où elles ne peuvent pas être définies, elles comportent toujours des valeurs par défaut.</p>
 
 <ul platform="actionscript">
 <li><codeph>accessibilityProperties</codeph></li>
 <li><codeph>alpha</codeph></li>
 <li><codeph>blendMode</codeph></li>
 <li><codeph>cacheAsBitmap</codeph></li>
 <li><codeph>contextMenu</codeph></li>
 <li><codeph>filtres</codeph></li>
 <li><codeph>focusRect</codeph></li>
 <li><codeph>loaderInfo</codeph></li>
 <li><codeph>mask</codeph></li>
 <li><codeph>mouseEnabled</codeph></li>
 <li><codeph>nom</codeph></li>
 <li><codeph>opaqueBackground</codeph></li>
 <li><codeph>rotation</codeph></li>
 <li><codeph>scale9Grid</codeph></li>
 <li><codeph>scaleX</codeph></li>
 <li><codeph>scaleY</codeph></li>
 <li><codeph>scrollRect</codeph></li>
 <li><codeph>tabEnabled</codeph></li>
 <li><codeph>tabIndex</codeph></li>
 <li><codeph>transformation</codeph></li>
 <li><codeph>visible</codeph></li>
 <li><codeph>x</codeph></li>
 <li><codeph>y</codeph></li>
 </ul>
 
 <p>Certains événements que vous soupçonniez appartenir à la classe Stage, tels que <codeph>enterFrame</codeph>, <codeph>exitFrame</codeph>, <codeph>frameConstructed</codeph> et <codeph>render</codeph>, ne peuvent pas être des événements Stage, car l’existence d’une référence à l’objet Stage ne peut être garantie dans toutes les situations où ces événements sont utilisés. Etant donné que ces événements ne peuvent pas être distribués par l’objet Stage, ils le sont par chaque occurrence de DisplayObject, ce qui signifie que vous pouvez ajouter un écouteur d’événement à n’importe quelle occurrence de DisplayObject pour écouter ces événements. Ces événements, qui font partie de la classe DisplayObject, sont appelés événements de diffusion afin de les différencier de ceux qui ciblent une occurrence de DisplayObject spécifique. Deux autres événements de diffusion, <codeph>activate</codeph> et <codeph>deactivate</codeph>, appartiennent à la super-classe de DisplayObject, EventDispatcher. Le comportement des événements <codeph>activate</codeph> et <codeph>deactivate</codeph> est identique à celui des événements de diffusion DisplayObject, à la différence que ces deux événements sont distribués non seulement par toutes les occurrences de DisplayObject, mais également par toutes les occurrences de EventDispatcher et par les occurrences d’autres sous-classes EventDispatcher. Pour plus d’informations sur les événements de diffusion, voir la classe DisplayObject.</p>
 
 </apiDesc><example conref="examples\StageExample.as"> L’exemple suivant utilise la classe <codeph>StageExample</codeph> pour distribuer des événements lorsque la scène est activée ou redimensionnée. Pour ce faire, procédez comme suit :
 <ol>
  <li>Le constructeur de classe définit au préalable l’application Flash à corriger, quelle que soit la taille de la fenêtre de Flash Player, puis ajoute deux écouteurs d’événement avec les méthodes <codeph>activateHandler()</codeph> et <codeph>resizeHandler()</codeph>.</li>
 
  <li>La méthode <codeph>activateHandler()</codeph> s’exécute lorsque vous cliquez avec le bouton gauche de la souris.</li>
 
  <li>La méthode <codeph>resizeHandler()</codeph> s’exécute lorsque la scène est redimensionnée.</li>
 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.Event;

    public class StageExample extends Sprite {

        public function StageExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.addEventListener(Event.ACTIVATE, activateHandler);
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function activateHandler(event:Event):void {
            trace("activateHandler: " + event);
        }

        private function resizeHandler(event:Event):void {
            trace("resizeHandler: " + event);
            trace("stageWidth: " + stage.stageWidth + " stageHeight: " + stage.stageHeight);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><adobeApiEvent id="flash.display:Stage_flash.events.FullScreenEvent.FULL_SCREEN_fullScreen"><apiName>fullScreen</apiName><shortdesc>
 Distribué lorsque l’objet Stage active ou désactive le mode plein écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FullScreenEvent.FULL_SCREEN</apiEventType><adobeApiEventClassifier>flash.events.FullScreenEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’objet Stage active ou désactive le mode plein écran. Toute modification du mode plein écran peut se faire à l’aide du code ActionScript, ou d’un raccourci clavier de l’utilisateur, ou lorsque le focus quitte la fenêtre en mode plein écran.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Distribué lorsque la propriété scaleMode de l’objet Stage est définie sur StageScaleMode.NO_SCALE et lorsque le fichier SWF est redimensionné.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque la propriété <codeph>scaleMode</codeph> de l’objet Stage est définie sur <codeph>StageScaleMode.NO_SCALE</codeph> et lorsque le fichier SWF est redimensionné. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.MOUSE_LEAVE_mouseLeave"><apiName>mouseLeave</apiName><shortdesc>
 Distribué par l’objet Stage lorsque le pointeur de la souris sort de la zone de scène.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.MOUSE_LEAVE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par l’objet Stage lorsque le pointeur de la souris sort de la zone de scène. Si l’utilisateur appuie sur le bouton de la souris, l’événement n’est pas distribué.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:Stage:addChild"><apiName>addChild</apiName><shortdesc>
	 
     Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>l’appel de la méthode <codeph>addChild()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Occurrence DisplayObject que vous transmettez au paramètre <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence DisplayObject à ajouter en tant qu’enfant à cette occurrence DisplayObjectContainer.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
     Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer. L’enfant est ajouté devant (par-dessus) tous les autres enfants dans cette occurrence de DisplayObjectContainer (pour ajouter un enfant à une position d’index spécifique, utilisez la méthode <codeph>addChildAt()</codeph>).
     
	 <p>Si vous ajoutez un objet enfant qui est déjà doté d’un autre conteneur d’objet d’affichage en tant que parent, il est supprimé de la liste d’enfants de cet autre conteneur d’objet d’affichage. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 
	 Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>L’appel de la méthode <codeph>addChildAt()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Occurrence DisplayObject que vous transmettez au paramètre <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence DisplayObject à ajouter en tant qu’enfant à cette occurrence DisplayObjectContainer.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index à laquelle l’enfant est ajouté. Si vous spécifiez une position d’index actuellement occupée, l’objet enfant associé à cette position et toutes les positions supérieures sont décalés d’une position vers le haut dans la liste d’enfants. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Ajoute une occurrence DisplayObject enfant à cette occurrence DisplayObjectContainer. L’enfant est placé à la position d’index spécifiée. La position d’index 0 représente la fin (le bas) de la liste d’affichage pour cet objet DisplayObjectContainer.
	 
	 <p>Ainsi, l’exemple suivant illustre trois objets d’affichage appelés a, b et c, qui occupent respectivement les positions d’index 0, 2 et 1 :</p>
	 
	 <p><adobeimage alt="b sur c sur a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>Si vous ajoutez un objet enfant qui est déjà doté d’un autre conteneur d’objet d’affichage en tant que parent, il est supprimé de la liste d’enfants de cet autre conteneur d’objet d’affichage. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	 
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>l’appel de la méthode <codeph>addEventListener</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction d’écouteur qui traite l’événement. Cette fonction doit accepter un objet Event comme paramètre unique et ne rien renvoyer<ph platform="actionscript">, comme illustré ci-dessous :</ph><ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Le nom de cette fonction n’a aucune importance.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Ce paramètre s’applique aux objets d’affichage dans l’architecture de la liste d’affichage ActionScript 3.0, utilisés par le contenu SWF.</ph> <ph platform="actionscript">Détermine si l’écouteur est actif pendant la phase de capture ou pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, l’écouteur traite l’événement uniquement pendant la phase de capture et non pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>false</codeph>, l’écouteur traite l’événement uniquement pendant les phases cible et de propagation vers le haut. Pour écouter l’événement dans les trois phases, appelez <codeph>addEventListener</codeph> à deux reprises, une première fois en définissant <codeph>useCapture</codeph> sur <codeph>true</codeph>, puis une nouvelle fois en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Niveau de priorité de l’écouteur d’événement. La priorité est indiquée par un entier signé de 32 bits. Plus le nombre est élevé, plus la priorité est élevée. Tous les écouteurs dont la priorité correspond à <i>n</i> sont traités avant les écouteurs dotés de la priorité <i>n</i> -1. Les écouteurs dont la priorité est identique sont traités dans l’ordre où ils ont été ajoutés. La priorité par défaut est 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Détermine si la référence à l’écouteur est forte ou faible. Une référence forte (valeur par défaut) empêche le nettoyage de votre écouteur, Cela n’est pas le cas avec une référence faible. <p>Les fonctions de membres de niveau classe n’étant pas soumises au nettoyage, vous pouvez définir <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour ces fonctions. Si vous définissez <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour un écouteur correspondant à une fonction imbriquée interne, la fonction sera nettoyée et ne sera donc pas permanente. Si vous créez des références à la fonction interne (enregistrée dans une autre variable), celle-ci n’est pas nettoyée et reste permanente.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement. <ph platform="actionscript">Vous pouvez enregistrer les écouteurs d’événement dans tous les nœuds de la liste d’affichage pour un type spécifique d’événement, de phase et de priorité.</ph>
	
	<p platform="javascript">Le code JavaScript dans le moteur d’exécution AIR utilise cette méthode pour enregistrer des écouteurs d’événements définis par les API AIR. Pour d’autres événements JavaScript (tels que l’événement <codeph>onload</codeph> de l’objet <codeph>body</codeph> DOM), vous pouvez utiliser des techniques de gestion d’événements standard, comme vous le feriez pour le contenu exécuté dans le navigateur.</p>
	
	<p>Après l’enregistrement d’un écouteur d’événement, vous ne pouvez plus modifier sa priorité par d’autres appels de <codeph>addEventListener()</codeph>. Pour modifier la priorité d’un écouteur, vous devez d’abord appeler <codeph>removeListener()</codeph>. Vous pouvez ensuite réenregistrer l’écouteur avec le nouveau niveau de priorité. </p>
	
	<p>N’oubliez pas qu’une fois l’écouteur enregistré, tous les prochains appels de <codeph>addEventListener()</codeph> avec une valeur <codeph>type</codeph> ou <codeph>useCapture</codeph> différente entraîneront la création d’un autre enregistrement d’écouteur. <ph platform="actionscript">Si, par exemple, vous enregistrez un écouteur dans lequel la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, il écoute uniquement pendant la phase de capture. Si vous appelez <codeph>addEventListener()</codeph> à l’aide du même objet écouteur, mais en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>, vous obtenez deux écouteurs distincts : l’un qui écoute pendant la phase de capture et l’autre qui écoute pendant les phases cible et de propagation vers le haut (bubbling).</ph>
	</p>
	
	<p platform="actionscript">Il est impossible d’enregistrer un écouteur d’événement uniquement pour la phase cible ou la phase de propagation vers le haut. Ces deux phases sont associées pendant l’enregistrement car la propagation vers le haut s’applique uniquement aux ancêtres du nœud cible.</p>
	
	<p>Si vous n’avez plus besoin d’un écouteur d’événements, supprimez-le en appelant <codeph>removeEventListener()</codeph>, afin d’éviter tout problème de mémoire. Les écouteurs d’événement ne sont pas automatiquement supprimés de la mémoire, car le nettoyeur de mémoire ne supprime pas l’écouteur tant que l’objet de distribution existe (à moins que le paramètre <codeph>useWeakReference</codeph> ne soit défini sur <codeph>true</codeph>).</p>
		
	<p>Lors de la copie d’une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés ne sont pas pris en compte (si le nouveau nœud nécessite un écouteur d’événement, vous devez associer celui-ci après la création du nœud). Toutefois, si vous déplacez une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés la suivent.</p>
	
	
	<p platform="actionscript">Si un écouteur d’événement est enregistré sur un nœud alors qu’un événement est en cours de traitement sur ce nœud, l’écouteur n’est pas déclenché pendant la phase actuelle, mais il peut l’être pendant une phase ultérieure du flux d’événements, telle que la phase de propagation vers le haut (bubbling).</p>
	
	<p platform="actionscript">Si un écouteur d’événement est supprimé d’un nœud sur lequel un événement est en cours de traitement, il est cependant déclenché par les actions en cours. Une fois supprimé, l’écouteur d’événement n’est plus jamais appelé (à moins d’être réenregistré à des fins de traitement ultérieur). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:assignFocus"><apiName>assignFocus</apiName><shortdesc>
	 Définit le focus du clavier sur l’objet interactif spécifié par objectToFocus, avec la direction du focus spécifiée par le paramètre direction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si le focus ne peut pas être défini sur la cible ou la direction, il ne s’agit pas d’un type valide.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>objectToFocus</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>Objet sur lequel effectuer le focus, ou <codeph>null</codeph> pour effacer le focus des éléments de la scène.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>direction</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>La direction à partir de laquelle le focus est effectué sur <codeph>objectToFocus</codeph>. Les valeurs valides sont énumérées en tant que constantes dans la classe FocusDirection.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Attribue un focus de clavier à un objet interactif et spécifie la direction d’où provient le focus.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Définit le focus du clavier sur l’objet interactif spécifié par <codeph>objectToFocus</codeph>, avec la direction du focus spécifiée par le paramètre <codeph>direction</codeph>. 
	 
	 <p>Le concept de direction de focus doit être défini par l’application (ou le logiciel intégré de l’application). Aucun tri de focus intrinsèque d’objets interactifs n’existe, bien que vous puissiez utiliser d’autres propriétés disponibles pour établir un principe d’ordre. Par exemple, vous pouvez trier des objets interactifs selon leurs positions sur la scène ou dans la liste d’affichage. Appeler <codeph>assignFocus()</codeph> équivaut à définir la propriété <codeph>Stage.focus</codeph>, avec la possibilité supplémentaire d’indiquer la direction à partir de laquelle le focus est réglé.</p>
	 
	 <p>Le <codeph>objectToFocus</codeph> distribue un événement <codeph>focusIn</codeph> à la réception du focus. La propriété <codeph>direction</codeph> de l’objet FocusEvent signale le réglage du paramètre <codeph>direction</codeph>.</p>
	 
	 <p>Si vous affectez un objet HTMLLoader au paramètre <codeph>objectToFocus</codeph>, l’objet HTMLLoader sélectionne l’objet approprié qui peut recevoir le focus dans le DOM HTML, en fonction de la valeur du paramètre <codeph>direction</codeph>. S’il s’agit de <codeph>FocusDirection.BOTTOM</codeph>, l’objet pouvant recevoir le focus dans le DOM HTML situé à la fin de l’ordre de lecture obtient le focus. S’il s’agit de <codeph>FocusDirection.TOP</codeph>, l’objet pouvant recevoir le focus dans le DOM HTML situé au début de l’ordre de lecture obtient le focus. S’il s’agit de <codeph>NONE</codeph>, l’objet HTMLLoader reçoit le focus sans que l’élément qui a actuellement le focus ne soit modifié.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link><link href="flash.display.xml#FocusDirection"><linktext>flash.display.FocusDirection</linktext></link><link href="flash.events.xml#FocusEvent"><linktext>flash.events.FocusEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
	 
	Distribue un événement dans le flux d’événements.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>L’appel de la méthode <codeph>dispatchEvent()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Une valeur <codeph>true</codeph> si l’événement a bien été distribué. La valeur <codeph>false</codeph> indique un échec ou que <codeph>preventDefault()</codeph> a été appelé sur l’événement.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>Objet Event qui est distribué dans le flux d’événements. Si l’événement est redistribué, un clone est automatiquement créé. Après la distribution d’un événement, il est impossible de modifier sa propriété <codeph>target</codeph>. Pour que la redistribution fonctionne, vous devez donc créer une copie de l’événement.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Distribue un événement dans le flux d’événements. La cible de l’événement est l’objet EventDispatcher sur lequel la méthode <codeph>dispatchEvent()</codeph> est appelée.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:hasEventListener"><apiName>hasEventListener</apiName><shortdesc>
	 
	Vérifie si des écouteurs sont enregistrés auprès de l’objet EventDispatcher pour un type spécifique d’événement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>L’appel de la méthode <codeph>hasEventListener()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur <codeph>true</codeph> est renvoyée si un écouteur du type spécifié est enregistré. La valeur <codeph>false</codeph> est renvoyée dans tous les autres cas.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Vérifie si des écouteurs sont enregistrés auprès de l’objet EventDispatcher pour un type spécifique d’événement. Vous pouvez ainsi déterminer précisément où un objet EventDispatcher a modifié la gestion d’un type d’événement dans la hiérarchie du flux d’événements. Pour savoir si un type d’événement spécifique déclenche réellement un écouteur d’événements, utilisez <codeph>willTrigger()</codeph>.
	
	<p>La différence entre les méthodes <codeph>hasEventListener()</codeph> et <codeph>willTrigger()</codeph> est la suivante : <codeph>hasEventListener()</codeph> examine uniquement l’objet auquel elle appartient, tandis que <codeph>willTrigger()</codeph> recherche dans la totalité du flux d’événements l’événement spécifié par le paramètre <codeph>type</codeph>. <ph platform="javascript">Le flux d’événements s’applique à la liste d’affichage ActionScript 3.0, utilisée dans le contenu SWF.</ph>
	</p>
	
	<p>Lorsque <codeph>hasEventListener()</codeph> est appelé à partir d’un objet LoaderInfo, seuls les écouteurs auxquels l’appelant a accès sont pris en compte.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:invalidate"><apiName>invalidate</apiName><shortdesc>
     L’appel de la méthode invalidate() force Flash Player à alerter les objets lorsqu’il a la possibilité de rendre la liste d’affichage (par exemple, lorsque la tête de lecture passe à une nouvelle image).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Force Flash Player à mettre à jour les propriétés des objets d’affichage dès qu’il a la possibilité d’actualiser la scène.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     L’appel de la méthode <codeph>invalidate()</codeph> force Flash Player à alerter les objets lorsqu’il a la possibilité de rendre la liste d’affichage (par exemple, lorsque la tête de lecture passe à une nouvelle image). Après avoir appelé la méthode <codeph>invalidate()</codeph> et suite au premier rendu de la liste d’affichage, Flash Player envoie un événement <codeph>render</codeph> à l’ensemble des objets d’affichage enregistrés pour l’écoute de l’événement <codeph>render</codeph>. Vous devez appeler la méthode <codeph>invalidate()</codeph> pour que Flash Player envoie des événements <codeph>render</codeph>. 
     
     <p>L’événement <codeph>render</codeph> permet d’apporter des modifications à la liste d’affichage immédiatement avant de procéder à son rendu. Vous pouvez ainsi différer les mises à jour de la liste d’affichage de façon à les appliquer au moment de votre choix. L’élimination de mises à jour d’écran superflues améliore parfois les performances.</p>
     
     <p>L’événement <codeph>render</codeph> est distribué uniquement pour afficher les objets qui appartiennent au même domaine de sécurité que le code qui appelle la méthode <codeph>stage.invalidate()</codeph> ou pour afficher des objets provenant d’un domaine de sécurité dont les autorisations ont été accordées par la méthode <codeph>Security.allowDomain()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/RENDER"><linktext>flash.events.Event.RENDER</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:isFocusInaccessible"><apiName>isFocusInaccessible</apiName><shortdesc>
	 Détermine si la propriété Stage.focus doit renvoyer null pour des raisons de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> si l’objet qui possède le focus appartient à un sandbox de sécurité auquel le fichier SWF n’a pas accès.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Détermine si la propriété <codeph>Stage.focus</codeph> doit renvoyer <codeph>null</codeph> pour des raisons de sécurité.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Détermine si la propriété <codeph>Stage.focus</codeph> doit renvoyer <codeph>null</codeph> pour des raisons de sécurité. En d’autres termes, <codeph>isFocusInaccessible</codeph> renvoie <codeph>true</codeph> si l’objet qui possède le focus appartient à un sandbox de sécurité auquel le fichier SWF n’a pas accès.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 
	 Supprime une occurrence enfant de DisplayObject de la position d’index spécifiée dans la liste d’enfants de DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>L’appel de la méthode <codeph>removeChildAt()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que l’objet à supprimer. Pour éviter cette situation, le propriétaire de cet objet peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Occurrence de DisplayObject supprimée.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Index enfant de l’objet DisplayObject à supprimer.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Supprime une occurrence enfant de DisplayObject de la position d’<codeph>index</codeph> spécifiée dans la liste d’enfants de DisplayObjectContainer. La propriété <codeph>parent</codeph> de l’enfant supprimé est réglée sur <codeph>null</codeph> et l’objet est nettoyé s’il n’existe aucune autre référence à l’enfant. Les positions d’index de tout objet d’affichage placé au-dessus de l’enfant dans DisplayObjectContainer sont diminuées d’une unité.
	 
	 <p>Le processus de nettoyage de la mémoire réaffecte l’espace mémoire non utilisé. Lorsqu’une variable ou un objet n’est plus référencé ou stocké de façon active, le nettoyeur de mémoire vide toutes ses références en mémoire qui ne sont plus utilisées.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	 
	Modifie la position d’un enfant existant dans le conteneur d’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>l’appel de la méthode <codeph>setChildIndex()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Occurrence enfant de DisplayObject dont vous voulez modifier le numéro d’index.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Nouveau numéro d’index de l’objet d’affichage <codeph>child</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Modifie la position d’un enfant existant dans le conteneur d’objet d’affichage. L’ordre des objets enfant est alors affecté. Ainsi, l’exemple suivant illustre trois objets d’affichage appelés a, b et c, qui occupent respectivement les positions d’index 0, 1 et 2 :
	
	<p><adobeimage alt="c sur b sur a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>Lorsque vous utilisez la méthode <codeph>setChildIndex()</codeph> et spécifiez une position d’index déjà occupée, les seules positions qui changent sont celles situées entre l’ancienne et la nouvelle position de l’objet d’affichage. Toutes les autres positions restent identiques. Si un enfant est déplacé sur un index INFERIEUR à son index actuel, tous les enfants situés entre les deux sont AUGMENTES de 1 pour leur référence d’index. Si un enfant est déplacé sur un index SUPERIEUR à son index actuel, tous les enfants situés entre les deux sont DIMINUES de 1 pour leur référence d’index. Par exemple, si le conteneur d’objet d’affichage de l’exemple précédent s’appelle <codeph>container</codeph>, vous pouvez permuter la position des objets d’affichage a et b en appelant le code suivant :</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>Ce code entraîne la réorganisation suivante des objets :</p>
	
    <p><adobeimage alt="c sur a sur b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 
	 Intervertit l’ordre z (ordre d’empilement du premier plan vers l’arrière-plan) des objets enfant aux deux positions d’index spécifiées dans la liste d’enfants.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>L’appel de la méthode <codeph>swapChildrenAt()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que l’un des propriétaires des objets à permuter. Pour éviter cette situation, les propriétaires d’objet peuvent accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index du premier objet enfant.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index du second objet enfant.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Intervertit l’ordre z (ordre d’empilement du premier plan vers l’arrière-plan) des objets enfant aux deux positions d’index spécifiées dans la liste d’enfants. Tous les autres objets enfant du conteneur d’objet d’affichage conservent leur position d’index.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:willTrigger"><apiName>willTrigger</apiName><shortdesc>
	 
	Vérifie si un écouteur d’événement est enregistré auprès de cet objet EventDispatcher ou de ses ancêtres pour le type d’événement spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>L’appel de la méthode <codeph>willTrigger()</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si un écouteur du type spécifié est enregistré, <codeph>false</codeph> dans tous les autres cas.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Vérifie si un écouteur d’événement est enregistré auprès de cet objet EventDispatcher ou de ses ancêtres pour le type d’événement spécifié. Cette méthode renvoie <codeph>true</codeph> si un écouteur d’événement est déclenché pendant toute phase du flux d’événements lorsqu’un événement du type spécifié est distribué à cet objet EventDispatcher ou à l’un de ses descendants.
	
	<p>La différence entre les méthodes <codeph>hasEventListener()</codeph> et <codeph>willTrigger()</codeph> est la suivante : <codeph>hasEventListener()</codeph> examine uniquement l’objet auquel elle appartient, tandis que <codeph>willTrigger()</codeph> recherche dans la totalité du flux d’événements celui qui est spécifié par le paramètre <codeph>type. </codeph> <ph platform="javascript">Le flux d’événements s’applique à la liste d’affichage ActionScript 3.0, utilisée dans le contenu SWF.</ph></p>
	
	<p>Lorsque <codeph>willTrigger()</codeph> est appelée à partir d’un objet LoaderInfo, seuls les écouteurs auxquels l’appelant a accès sont pris en compte.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:Stage:align:get"><apiName>align</apiName><shortdesc>
	 Une valeur de la classe StageAlign qui détermine l’alignement de la scène dans Flash Player ou dans le navigateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Une valeur de la classe StageAlign qui détermine l’alignement de la scène dans Flash Player ou dans le navigateur. Les valeurs suivantes sont prises en charge :
	 
	 <p>
	 <adobetable class="innertable">
	 	
	 	 
	 	 
	 	 
	 	 
	 	  
	 	  
	 	  
	 	  
	 	 
	 <tgroup cols="3"><thead><row><entry>Valeur</entry><entry>Alignement vertical</entry><entry>Horizontal</entry></row></thead><tbody><row><entry><codeph>StageAlign.TOP</codeph></entry>
	 	 <entry>Haut</entry>
	 	 <entry>Centre</entry>
	 	 </row><row><entry><codeph>StageAlign.BOTTOM</codeph></entry>
	 	 <entry>Aligner les bords inférieurs</entry>
	 	 <entry>Centre</entry>
	 	 </row><row><entry><codeph>StageAlign.LEFT</codeph></entry>
	 	 <entry>Centre</entry>
	 	 <entry>Gauche</entry>
	 	 </row><row><entry><codeph>StageAlign.RIGHT</codeph></entry>
	 	 <entry>Centre</entry>
	 	 <entry>Aligner les bords droits</entry>
	 	 </row><row><entry><codeph>StageAlign.TOP_LEFT</codeph></entry>
	 	  <entry>Haut</entry>
	 	  <entry>Gauche</entry>
	 	  </row><row><entry><codeph>StageAlign.TOP_RIGHT</codeph></entry>
	 	  <entry>Haut</entry>
	 	  <entry>Aligner les bords droits</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_LEFT</codeph></entry>
	 	  <entry>Aligner les bords inférieurs</entry>
	 	  <entry>Gauche</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_RIGHT</codeph></entry>
	 	  <entry>Aligner les bords inférieurs</entry>
	 	  <entry>Aligner les bords droits</entry>
	 	  </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>La propriété <codeph>align</codeph> est uniquement disponible pour les objets qui appartiennent au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’objet qui effectue l’appel en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.alowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageAlign"><linktext>flash.display.StageAlign</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrection:get"><apiName>colorCorrection</apiName><shortdesc>
 	 Contrôle la correction de couleur de Flash Player pour l’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Tente d’utiliser la correction de couleur de l’écran
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
 	 Contrôle la correction de couleur de Flash Player pour l’affichage. La correction de couleur ne fonctionne que si un profil de couleur ICC valide est affecté à l’écran principal, profil spécifiant les attributs de couleur particuliers du périphérique. Par défaut, Flash Player tente d’adopter la correction de couleur de son hôte (généralement, un navigateur).
     
     <p>Utilisez la propriété <codeph>Stage.colorCorrectionSupport</codeph> pour déterminer si la correction de couleur est disponible sur le système et l’état par défaut actuels. Si la correction des couleurs est disponible, toutes les couleurs de la scène sont supposées appartenir à l’espace chromatique standard RVB, c’est-à-dire à l’espace chromatique le plus courant. Les profils source des périphériques d’entrée ne sont pas pris en compte lors de la correction des couleurs. Aucune correction de couleur n’est appliquée en entrée ; seule la sortie de la scène est mise en correspondance avec le profil de couleur ICC de l’écran principal.</p>
      
     <p>De façon générale, les avantages de l’activation de la gestion des couleurs sont une couleur prévisible et cohérente, une meilleure conversion, un contrôle plus précis et un résultat inter-supports plus efficace. N’oubliez pas cependant que la gestion des couleurs n’effectue pas des conversions parfaites car la gamme de couleurs ou les images d’origine des différents périphériques diffèrent. La gestion des couleurs n’élimine pas non plus le besoin de profils personnalisés ou modifiés. Les profils de couleurs dépendent des navigateurs, des systèmes d’exploitation et de leurs extensions, des périphériques de sortie et de la prise en charge des applications.</p>
     
     <p>L’application d’une correction de couleur affecte les performances de Flash Player. La correction de couleur de Flash Player est une correction de couleur de style document car toutes les séquences SWF sont considérées comme des documents avec profils sRVB implicites. Utilisez la propriété <codeph>Stage.colorCorrectionSupport</codeph> pour indiquer à Flash Player de corriger les couleurs au mieux lorsqu’il affiche la séquence SWF (document) dans l’espace de couleur d’affichage. Flash Player n’effectue de compensation que pour les différences entre les écrans, pas pour les différences entre les périphériques d’entrée (appareil photo/scanner/etc.).
     </p>
     
 	 <p>Les trois valeurs possibles sont les chaînes possédant les constantes correspondantes dans la classe flash.display.ColorCorrection :</p>
 	  <ul><li><codeph>"default"</codeph> : la même correction des couleurs que le système hôte est utilisée.</li> 
 	 <li><codeph>"on"</codeph> : les couleurs sont toujours corrigées.</li>
 	 <li><codeph>"off"</codeph> : les couleurs ne sont jamais corrigées.</li>
 	 </ul>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrection"><linktext>flash.display.ColorCorrection</linktext></link><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>colorCorrectionSupport</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrectionSupport:get"><apiName>colorCorrectionSupport</apiName><shortdesc>
      Indique si Flash Player est exécuté sur un système d’exploitation qui prend en charge la correction de couleur, et si Flash Player est capable de lire et de comprendre le profil de couleur de l’écran principal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>ColorCorrection
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
      Indique si Flash Player est exécuté sur un système d’exploitation qui prend en charge la correction de couleur, et si Flash Player est capable de lire et de comprendre le profil de couleur de l’écran principal. Cette propriété renvoie également l’état par défaut de la correction de couleur sur le système hôte (généralement, le navigateur). Actuellement, les valeurs renvoyées peuvent être les suivantes :
 	  <p>Les trois valeurs possibles sont les chaînes possédant les constantes correspondantes dans la classe flash.display.ColorCorrectionSupport :</p>
 	   <ul><li><codeph>"unsupported"</codeph> : la correction des couleurs n’est pas disponible.</li> 
 	  <li><codeph>"defaultOn"</codeph> : les couleurs sont toujours corrigées.</li>
 	  <li><codeph>"defaultOff"</codeph> : les couleurs ne sont jamais corrigées.</li>
 	  </ul>      
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrectionSupport"><linktext>flash.display.ColorCorrectionSupport</linktext></link><link href="flash.display.xml#Stage/colorCorrection"><linktext>colorCorrection</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:displayState:get"><apiName>displayState</apiName><shortdesc>
	 Une valeur de la classe StageDisplayState qui spécifie l’état d’affichage à utiliser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>displayState</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>. La définition de la propriété <codeph>displayState</codeph> lorsque la boîte de dialogue de définition des paramètres, sans réponse utilisateur, ou si l’attribut <codeph>allowFullScreen</codeph> de la balise <codeph>param</codeph> ou <codeph>embed</codeph> n’est pas défini sur <codeph>true</codeph> renvoie une erreur de sécurité.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Une valeur de la classe StageDisplayState qui spécifie l’état d’affichage à utiliser. Les valeurs suivantes sont prises en charge : 
	 
	 <ul>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN</codeph> Définit une application AIR ou Flash Player de sorte que la scène couvre la totalité de l’écran de l’utilisateur, avec la saisie au clavier désactivée.</li>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> Définit l’application AIR de sorte que la scène couvre la totalité de l’écran de l’utilisateur, en autorisant la saisie au clavier. <ph platform="actionscript">Non disponible pour le contenu s’exécutant dans Flash Player.</ph></li>
	 
     <li><codeph>StageDisplayState.NORMAL</codeph> Rétablit le mode d’affichage standard du lecteur.</li>
	 
	 </ul> 
	 
     <p platform="actionscript">Le comportement de mise à l’échelle du clip en mode plein écran est déterminé par le paramètre <codeph>scaleMode</codeph> (défini à l’aide de la propriété <codeph>Stage.scaleMode</codeph> ou des paramètres de la balise <codeph>embed</codeph> du fichier HTML). Lorsque la propriété <codeph>scaleMode</codeph>est définie sur <codeph>noScale</codeph> pendant la transition de l’application vers le mode plein écran, les propriétés de scène <codeph>width</codeph> et <codeph>height</codeph> sont mises à jour. Ensuite, la scène distribue l’événement <codeph>resize</codeph>.</p>
     
     <p platform="actionscript">Les restrictions suivantes s’appliquent aux fichiers SWF lus dans une page HTML (pas ceux utilisant l’application Flash Player autonome ou ne s’exécutant pas dans le moteur d’exécution AIR) :</p>
     
     <ul platform="actionscript">
	 
	 <li>Pour activer le mode plein écran, ajoutez le paramètre <codeph>allowFullScreen</codeph> aux balises <codeph>object</codeph> et <codeph>embed</codeph> de la page HTML qui inclut le fichier SWF, avec <codeph>allowFullScreen</codeph> défini sur <codeph>"true"</codeph>, comme indiqué dans l’exemple suivant :
	 
	 <codeblock>&lt;param name="allowFullScreen" value="true" />
	        ...
	 &lt;embed src="example.swf" allowFullScreen="true" ... ></codeblock>
	 
	 <p>Une page HTML peut également utiliser un script pour générer des balises d’imbrication de fichiers SWF. Vous devez modifier le script de façon à insérer les paramètres <codeph>allowFullScreen</codeph> appropriés. Les pages HTML générées par Flash et FlexBuilder utilisent la fonction <codeph>AC_FL_RunContent()</codeph> pour imbriquer des références aux fichiers SWF, et vous devez ajouter le paramètre <codeph>allowFullScreen</codeph>, comme dans l’exemple suivant :</p>
	 
	 <codeblock>AC_FL_RunContent( ... "allowFullScreen", "true", ... )</codeblock></li>
	 
     <li>Le mode plein écran est initié en réponse à un clic de souris ou une pression de touche de l’utilisateur, le clip ne peut pas modifier <codeph>Stage.displayState</codeph> sans interaction de l’utilisateur. Flash Player limite la saisie clavier en mode plein écran. Les touches disponibles sont les suivantes : raccourcis clavier permettant de désactiver le mode plein écran, ainsi que les touches hors impression, telles que les touches fléchées, la touche espace, la touche Maj et la touche de tabulation. Les raccourcis clavier qui permettent de désactiver le mode plein écran sont les suivants : Echap (Windows, Linux et Mac), Ctrl+W (Windows), Commande+W (Mac) et Alt+F4.
     <p>La boîte de dialogue Flash Player se superpose au clip lorsque les utilisateurs activent le mode plein écran pour informer les utilisateurs que le mode plein écran est actif et qu’ils peuvent appuyer sur la touche Echap pour mettre fin au mode plein écran.</p></li>
     <li>A partir de Flash Player 9.0.115.0, le mode plein écran fonctionne de la même façon en mode sans fenêtre et en mode fenêtre. Si vous définissez le mode Fenêtre (<codeph>wmode</codeph> dans le code HTML) sur Opaque sans fenêtre (<codeph>opaque</codeph>) ou sur Transparent sans fenêtre (<codeph>transparent</codeph>), le mode plein écran peut être lancé, mais la fenêtre en plein écran demeurera opaque.</li> 
	 
     </ul>
     
 	 <p platform="actionscript">Ces restrictions ne sont <i>pas</i> présentes pour le contenu SWF s’exécutant dans l’application Flash Player autonome ou dans AIR. AIR prend en charge un mode plein écran interactif qui permet la saisie clavier.</p>  
	 
	 <p>Pour le contenu <ph platform="actionscript">AIR</ph> s’exécutant en mode plein écran, les options d’économiseur d’écran système et de mise en veille sont désactivées lorsque le contenu vidéo est lu et jusqu’à ce que la vidéo s’arrête ou que le mode plein écran soit désactivé.</p>
 	 
	 <p>Sous Linux, la définition de <codeph>displayState</codeph> sur <codeph>StageDisplayState.FULL_SCREEN</codeph> ou sur <codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> est une opération asynchrone.</p>
    
	 </apiDesc><example conref="examples\StageExample2.as"> L’exemple suivant montre de manière interactive comment créer une application plein écran en modifiant la propriété <codeph>displayState</codeph>. <p><b>Remarque </b>: Le mode plein écran peut être déclenché dans certaines situations, par exemple si l’utilisateur a cliqué ou appuyé sur une touche, en raison de restrictions de sécurité. La propriété allowFullScreen doit être définie sur true lorsqu’elle s’exécute dans un navigateur.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Stage;
    import flash.events.*;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.media.Video;
    
    public class FullScreenExample extends Sprite
    {
        private var videoURL:String = "testVideo.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var video:Video;        
        
        public function FullScreenExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
            
            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK,toggleFullScreen);
        }        
        
        private function toggleFullScreen(event:MouseEvent):void {
            switch(stage.displayState) {
                case "normal":
                    stage.displayState = "fullScreen";    
                    break;
                case "fullScreen":
                default:
                    stage.displayState = "normal";    
                    break;
            }
        }    
        
        // Video related:
        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }
        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);

            video = new Video(stage.stageWidth,stage.stageHeight);
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:focus:get"><apiName>focus</apiName><shortdesc>
	 L’objet interactif qui a le focus clavier ou null si le focus n’est pas défini ou si l’objet avec focus appartient à un sandbox de sécurité auquel l’objet effectuant l’appel n’a pas accès.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier><apiException><apiDesc>Renvoie une erreur s’il est impossible de définir le focus sur la cible.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Objet disposant du focus clavier.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 L’objet interactif qui a le focus clavier ou <codeph>null</codeph> si le focus n’est pas défini ou si l’objet avec focus appartient à un sandbox de sécurité auquel l’objet effectuant l’appel n’a pas accès.
	 
	 </apiDesc><example conref="Stage.focus.as"> <codeph/>  
<codeblock>
var myTF:TextField = new TextField();
myTF.border =true;
myTF.type = TextFieldType.INPUT;

addChild(myTF);
stage.focus= myTF;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Stage:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 Extrait et définit la cadence d’images de la scène.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>frameRate</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Extrait et définit la cadence d’images de la scène. soit le nombre d’images par seconde. Par défaut, cette valeur est définie sur la cadence d’images du premier fichier SWF chargé. Les plages valides vont de 0,01 à 1 000 images par seconde. 
	 
	 <p><codeph>Remarque :</codeph> une application risque de ne pas pouvoir traiter les cadences d’image élevées, soit parce que la plateforme cible n’est pas assez rapide ou parce que le lecteur n’est pas synchronisé avec la cadence des blancs verticaux de l’écran (généralement 60 Hz sur les périphériques avec écrans à cristaux liquides). Dans certains cas, une plateforme cible peut également réduire la cadence d’images maximale si elle anticipe une forte charge du processeur.</p>
	 
	 <p>Pour le contenu s’exécutant dans Adobe AIR, le réglage de la propriété <codeph>frameRate</codeph> d’un objet Stage change la cadence d’images pour tous les objets Stage (utilisés par différents objets NativeWindow).
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:fullScreenHeight:get"><apiName>fullScreenHeight</apiName><shortdesc>
  Renvoie la hauteur de l’écran qui sera utilisée lors du passage en plein écran, si cet état est entré immédiatement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Renvoie la hauteur de l’écran qui sera utilisée lors du passage en plein écran, si cet état est entré immédiatement. Si l’utilisateur utilise plusieurs écrans, l’écran choisi est celui sur lequel se trouve la majorité de la scène au moment du passage en plein écran.
  
  <p><b>Remarque</b> : si l’utilisateur a la possibilité de déplacer le navigateur d’un écran à l’autre entre la récupération de la valeur et le passage en plein écran, la valeur peut être incorrecte. Si vous récupérez la valeur dans un gestionnaire d’événement qui définit <codeph>Stage.displayState</codeph> sur <codeph>StageDisplayState.FULL_SCREEN</codeph>, la valeur sera correcte.</p>
  
  <p>Hauteur du pixel, qui correspond également à celle de la scène si <codeph>Stage.align</codeph> est défini sur <codeph>StageAlign.TOP_LEFT</codeph> et <codeph>Stage.scaleMode</codeph> sur <codeph>StageScaleMode.NO_SCALE</codeph>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> Cet exemple crée un rectangle vert de la taille de la scène et place au-dessus un carré rouge qu’il active sous forme de bouton. Un clic sur le carré rouge déclenche le gestionnaire d’événement <codeph>enterFullScreen()</codeph>, qui définit la propriété <codeph>fullScreenSourceRect</codeph> et active le mode plein écran. Pour définir la propriété <codeph>fullScreenSourceRect</codeph>, le gestionnaire d’événements commence avec l’emplacement et les dimensions du carré rouge. Il compare ensuite les proportions (largeur divisée par la hauteur) du carré rouge à celles de la scène en plein écran de manière à pouvoir étendre le rectangle (<codeph>fullScreenSourceRect</codeph>) en fonction des proportions de l’écran. En résultat, le carré rouge occupe la totalité de la hauteur de l’écran et l’arrière-plan vert est visible sur les côtés. Si les proportions ne correspondent pas, la couleur d’arrière-plan de la scène, blanche par défaut, apparaît sur les côtés à la place de l’arrière-plan vert.
 
 <p><b>Remarque</b> : testez cet exemple dans le navigateur. Dans l’onglet HTML de la boîte de dialogue Paramètres de publication de Flash, sélectionnez le modèle Flash uniquement - Autoriser le plein écran. Spécifiez la version Flash Player 9.0.115.0, et assurez-vous que les formats Flash et HTML soient sélectionnés dans l’onglet Formats. Puis, publiez et ouvrez le fichier HTML résultant dans le navigateur.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/fullScreenWidth"><linktext>fullScreenWidth</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenSourceRect:get"><apiName>fullScreenSourceRect</apiName><shortdesc>
  Définit Flash Player pour qu’il redimensionne une zone spécifique de la scène en mode plein écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
  Définit Flash Player pour qu’il redimensionne une zone spécifique de la scène en mode plein écran. Lorsque cela est possible, Flash Player effectue le redimensionnement dans le matériel, à l’aide de la carte graphique de l’ordinateur de l’utilisateur, ce qui affiche généralement le contenu plus rapidement qu’avec un redimensionnement logiciel.
  
  <p>Lorsque cette propriété est définie sur un rectangle valide et la propriété <codeph>displayState</codeph> sur le mode plein écran, Flash Player redimensionne la zone spécifiée. La taille réelle de la scène en pixels dans ActionScript ne change pas. Flash Player impose une taille limite au rectangle en fonction de la taille du message standard « Appuyez sur la touche Echap pour quitter le mode plein écran ». Cette limite est généralement d’environ 260 sur 30 pixels, mais peut varier en fonction de la plateforme et de la version de Flash Player.</p>
  
  <p>Cette propriété ne peut être définie que lorsque Flash Player n’est pas en mode plein écran. Pour utiliser cette propriété correctement, définissez d’abord cette propriété, puis la propriété <codeph>displayState</codeph> sur le mode plein écran, comme dans les exemples de code.</p>
  <p>Pour activer la mise à l’échelle, définissez la propriété <codeph>fullScreenSourceRect</codeph> sur un objet rectangle :</p>
  <codeblock>  
  // valid, will enable hardware scaling
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240); 
  </codeblock>
  
  <p>Pour activer la mise à l’échelle, définissez <codeph>fullScreenSourceRect=null</codeph> dans ActionScript 3.0, et <codeph>undefined</codeph> dans ActionScript 2.0.</p>
  <codeblock>
  stage.fullScreenSourceRect = null;
  </codeblock>
  
  <p>L’utilisateur final peut également désactiver la mise à l’échelle matérielle, activée par défaut, dans les paramètres d’affichage de Flash Player. Pour plus de détails, voir <xref href="http://www.adobe.com/go/display_settings_fr" scope="external">www.adobe.com/go/display_settings_fr</xref>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenSourceRect.1.as"> Pour tirer parti de la mise à l’échelle matérielle, définissez l’ensemble ou une partie de la scène sur le mode plein écran. Le code suivant ActionScript 3.0 définit l’ensemble de la scène en mode plein écran :
<codeblock>
 
import flash.geom.*; 
{
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240);
  stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example><example conref="examples\Stage_fullScreenSourceRectExample2.as"> Dans l’exemple suivant, l’utilisateur peut passer de la lecture d’une vidéo en mode plein écran ou normal en cliquant sur la scène. Si le fichier SWF de cet exemple s’exécute dans Flash Player  9.0.115.0 ou supérieure, l’accélération matérielle est utilisée pour améliorer la mise à l’échelle en plein écran de l’affichage.
  
 <p>Avant d’utiliser le mode plein écran avec la mise à l’échelle matérielle, les conditions suivantes doivent être remplies :</p>
 
 <ol>
 <li>Flash Player version 9.0.115.0 ou ultérieure est nécessaire, ainsi qu’un outil de programmation qui prenne en charge cette version.</li>
 <li>Les modèles HTML doivent être modifiés pour prendre en charge le plein écran. L’attribut <codeph>allowFullScreen</codeph> doit être défini sur <codeph>true</codeph> pour les balises <codeph>object</codeph> et <codeph>embed</codeph> (les scripts qui génèrent des balises SWF-embedding doivent également autoriser le plein écran). Pour un exemple de fichiers pouvant être utilisés avec Flex Builder, voir l’article, <xref href="http://www.adobe.com/devnet/flashplayer/articles/full_screen_mode.html" scope="external">Exploration du mode plein écran dans Flash Player 9</xref>.</li>
 <li>Votre application doit être autorisée à accéder à un fichier vidéo FLV. Dans cet exemple, on suppose que le fichier Flash Video (FLV) est dans le même répertoire que le fichier SWF.</li>
 <li>L’utilisateur doit autoriser l’accès au mode plein écran.</li>
 <li>Pour des informations supplémentaires sur le redimensionnement de matériel, voir l’article <xref href="http://www.adobe.com/go/hardware_scaling_fr" scope="external">Exploration de la prise en charge de Flash Player pour l’audio AAC et la vidéo H.264 haute définition</xref> pour Flash Player.</li>
 </ol>
 
 <p>Un fichier FLV est chargé à l’aide d’objets NetConnection et NetStream. Le fichier FLV étant dans le même répertoire que le fichier SWF et se connectant via HTTP, le paramètre de la méthode <codeph>NetConnection.connect()</codeph> est défini sur <codeph>null</codeph>. L’objet NetConnection <codeph>connect</codeph> signale son état en distribuant un événement <codeph>netStatus</codeph> qui invoque la méthode <codeph>netStatusHandler()</codeph>. La méthode <codeph>netStatusHandler()</codeph> vérifie si la connexion a réussi et invoque la méthode <codeph>connectStream()</codeph>, qui crée un objet NetStream acceptant l’objet NetConnection sous forme de paramètre. Elle crée également un objet video et lie l’objet NetStream à cet objet video. L’objet video est alors ajouté à la liste d’affichage et le flux est défini sur lecture. Le fichier FLV ne contenant pas de métadonnées ni d’information sur les points de repère, un événement <codeph>AsyncError</codeph> sera distribué. Un écouteur doit être défini pour gérer l’événement. Ici, l’écouteur est configuré et ignore l’événement. Un autre écouteur de l’événement <codeph>netStatus</codeph> est également configuré pour l’objet NetStream. Il affiche un message d’erreur si le flux n’est pas détecté (la méthode <codeph>netStatusHandler()</codeph> peut être utilisée pour gérer toutes les informations d’état signalées pour le flux ou la connexion).</p>
 
 <p>Lorsque les propriétés et les méthodes d’un fichier SWF chargé sont accessibles, la méthode <codeph>createMouseListener()</codeph> est invoquée. Elle configure un écouteur pour l’événement de clic de souris sur la scène. La méthode <codeph>toggleFullScreen()</codeph> vérifie si l’état d’affichage est en mode plein écran ou normal. S’il s’agit du mode normal, la taille de l’objet vidéo est définie sur la taille du flux vidéo. La propriété <codeph>fullScreenSourceRect</codeph> est définie sur un rectangle qui correspond aux dimensions de l’objet vidéo. Puis, la propriété <codeph>Stage.displayMode</codeph> est définie sur le plein écran, ce qui provoque le remplissage par la vidéo de toute la zone du plein écran. Si la configuration système requise est satisfaite, le matériel graphique de l’ordinateur est utilisé pour améliorer les performances du rendu en plein écran et l’état d’affichage est défini sur le mode plein écran. Pour récupérer toute erreur de sécurité susceptible de se produire pendant le passage au mode plein écran, un bloc <codeph>try...catch</codeph> est utilisé (l’état d’affichage doit être défini sur le mode plein écran après la définition de la propriété <codeph>fullScreenSourceRect</codeph>). Avant le passage en mode normal, la hauteur et la largeur de l’objet vidéo sont ramenées aux valeurs d’origine de l’objet enregistré. Dans le cas contraire, les changements apportés à l’objet vidéo pour le mode plein écran détermineront la hauteur et la largeur.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageDisplayState;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.NetStatusEvent;
    import flash.events.AsyncErrorEvent;
    import flash.events.SecurityErrorEvent;
    import flash.events.MouseEvent;
    import flash.events.Event;
    import flash.geom.Rectangle;
    
    public class Stage_fullScreenSourceRectExample2 extends Sprite {
        private var videoURL:String = "testVideo1.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var myVideo:Video;        
        private    var savedWidth:uint;
        private    var savedHeight:uint;
 
        public function Stage_fullScreenSourceRectExample2() {
    
            connection = new NetConnection();
             connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);    
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);

            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK, toggleFullScreen);
        }        

        private function toggleFullScreen(event:MouseEvent):void {

            if(stage.displayState == StageDisplayState.NORMAL) {
                myVideo.width = myVideo.videoWidth;
                  myVideo.height = myVideo.videoHeight;

                try {
                    stage.fullScreenSourceRect = new Rectangle(myVideo.x, myVideo.y, 
                                                           myVideo.width, myVideo.height);
                     stage.displayState = StageDisplayState.FULL_SCREEN;

                 } catch (e:SecurityError) {
                     trace ("A security error occurred while switching to full screen: " + event);
                    myVideo.width = savedWidth;
                    myVideo.height = savedHeight;
                 }

            }else {
                myVideo.width = savedWidth;
                myVideo.height = savedHeight;
                stage.displayState = StageDisplayState.NORMAL;
            }
        }    

       private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace ("Unable to locate video: " + videoURL);
                    break;
            }
        }

       private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);     

             myVideo = new Video();
            myVideo.attachNetStream(stream);
            stream.play(videoURL);

            savedWidth = myVideo.width;
            savedHeight = myVideo.height;

            addChild(myVideo);
        }
       
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);    
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/displayState"><linktext>Stage.displayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenWidth:get"><apiName>fullScreenWidth</apiName><shortdesc>
  Renvoie la largeur de l’écran utilisée lors du passage en plein écran, si cet état est entré immédiatement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Renvoie la largeur de l’écran utilisée lors du passage en plein écran, si cet état est entré immédiatement. Si l’utilisateur utilise plusieurs écrans, l’écran choisi est celui sur lequel se trouve la majorité de la scène au moment du passage en plein écran. 
  
  <p><b>Remarque</b> : si l’utilisateur a la possibilité de déplacer le navigateur d’un écran à l’autre entre la récupération de la valeur et le passage en plein écran, la valeur peut être incorrecte. Si vous récupérez la valeur dans un gestionnaire d’événement qui définit <codeph>Stage.displayState</codeph> sur <codeph>StageDisplayState.FULL_SCREEN</codeph>, la valeur sera correcte.</p>
  
  <p>Largeur du pixel, qui correspond également à celle de la scène si <codeph>Stage.align</codeph> est défini sur <codeph>StageAlign.TOP_LEFT</codeph> et <codeph>Stage.scaleMode</codeph> sur <codeph>StageScaleMode.NO_SCALE</codeph>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> Cet exemple crée un rectangle vert de la taille de la scène et place au-dessus un carré rouge qu’il active sous forme de bouton. Un clic sur le carré rouge déclenche le gestionnaire d’événement <codeph>enterFullScreen()</codeph>, qui définit la propriété <codeph>fullScreenSourceRect</codeph> et active le mode plein écran. Pour définir la propriété <codeph>fullScreenSourceRect</codeph>, le gestionnaire d’événements commence avec l’emplacement et les dimensions du carré rouge. Il compare ensuite les proportions (largeur divisée par la hauteur) du carré rouge à celles de la scène en plein écran de manière à pouvoir étendre le rectangle (<codeph>fullScreenSourceRect</codeph>) en fonction des proportions de l’écran. En résultat, le carré rouge occupe la totalité de la hauteur de l’écran et l’arrière-plan vert est visible sur les côtés. Si les proportions ne correspondent pas, la couleur d’arrière-plan de la scène, blanche par défaut, apparaît sur les côtés à la place de l’arrière-plan vert.
 
 <p><b>Remarque</b> : testez cet exemple dans le navigateur. Dans l’onglet HTML de la boîte de dialogue Paramètres de publication de Flash, sélectionnez le modèle Flash uniquement - Autoriser le plein écran. Spécifiez la version Flash Player 9.0.115.0, et assurez-vous que les formats Flash et HTML soient sélectionnés dans l’onglet Formats. Puis, publiez et ouvrez le fichier HTML résultant dans le navigateur.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenHeight"><linktext>fullScreenHeight</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:height:get"><apiName>height</apiName><shortdesc>
	 
     Indique la hauteur de l’objet d’affichage, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Toute référence à la propriété <codeph>height</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Il reste impossible de définir la propriété <codeph>height</codeph> d’un objet Stage, même si l’objet appelant est le propriétaire de l’objet Stage (le fichier SWF principal).
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Indique la hauteur de l’objet d’affichage, en pixels. La hauteur est calculée en fonction des limites du contenu de l’objet d’affichage. Lorsque vous définissez la propriété <codeph>height</codeph>, la propriété <codeph>scaleY</codeph> est ajustée en conséquence, comme illustré dans le code suivant :
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>A l’exception des objets TextField et Video, un objet d’affichage sans contenu (comme un sprite vide) a une hauteur de 0, même si vous essayez de définir <codeph>height</codeph> sur une valeur différente.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 
	 Détermine si les enfants de l’objet prennent ou non en charge la souris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Référencer la propriété <codeph>mouseChildren</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Détermine si les enfants de l’objet prennent ou non en charge la souris. Si tel est le cas, un utilisateur peut le manipuler à l’aide de la souris. La valeur par défaut est <codeph>true</codeph>.
	 
	 <p>Cette propriété s’avère utile lorsque vous créez un bouton avec une occurrence de la classe Sprite (au lieu d’utiliser la classe SimpleButton). Si vous utilisez une occurrence de Sprite pour créer un bouton, vous pouvez le décorer à l’aide de la méthode <codeph>addChild()</codeph> pour ajouter d’autres occurrences de Sprite. Ce processus risque d’associer un comportement imprévu aux événements de souris, car les occurrences de Sprite ajoutées en tant qu’enfants peuvent devenir l’objet cible d’un événement de souris alors que vous vous attendiez à ce que ce dernier corresponde à l’occurrence parent. Pour vous assurer que l’occurrence parent serve d’objet cible pour les événements de souris, vous pouvez régler la propriété <codeph>mouseChildren</codeph> de l’occurrence parent sur <codeph>false</codeph>.</p>
	 <p> Définir cette propriété ne distribue aucun événement. La méthode <codeph>addEventListener()</codeph> vous permet de créer une fonctionnalité interactive.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:nativeWindow:get"><apiName>nativeWindow</apiName><shortdesc>
	 Une référence à l’objet NativeWindow contenant cette scène.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
	 Une référence à l’objet NativeWindow contenant cette scène. 
	 
	 <p>La fenêtre représente la fenêtre du système d’exploitation native ; la scène représente le contenu de la fenêtre. Cette propriété est valide uniquement pour le contenu s’exécutant dans AIR. Dans Flash Player (contenu s’exécutant dans un navigateur), cette propriété est <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 
	 Renvoie le nombre d’enfants de l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Toute référence à la propriété <codeph>numChildren</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Renvoie le nombre d’enfants de l’objet.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:quality:get"><apiName>quality</apiName><shortdesc>
	 Valeur de la classe StageQuality qui spécifie la qualité de rendu utilisée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>quality</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Valeur de la classe StageQuality qui spécifie la qualité de rendu utilisée. Les valeurs suivantes sont prises en charge :
	 
	 <ul>
	 
	 <li><codeph>StageQuality.LOW</codeph> — Qualité de rendu inférieure. Les images ne sont pas anti-aliasées et les bitmaps ne sont pas lissées, mais le moteur d’exécution utilise toujours les mipmaps. Ce paramètre n’est pas pris en charge dans Adobe AIR.</li>
	 
	 <li><codeph>StageQuality.MEDIUM</codeph> — Qualité de rendu moyenne. Les images sont anti-aliasées selon une grille de 2 x 2 pixels ; le lissage des bitmaps dépend du paramètre <codeph>Bitmap.smoothing</codeph>. Les moteurs d’exécution utilisent les mipmaps. Ce niveau de qualité convient aux animations qui ne contiennent pas de texte. Ce paramètre n’est pas pris en charge dans Adobe AIR.</li>
	 
	 <li><codeph>StageQuality.HIGH</codeph> — Qualité de rendu supérieure. Les images sont anti-aliasées selon une grille de 4 x 4 pixels ; le lissage des bitmaps dépend du paramètre <codeph>Bitmap.smoothing</codeph>. Les moteurs d’exécution utilisent les mipmaps. Il s’agit du réglage de qualité de rendu par défaut de Flash Player.</li>
	 
	 <li><codeph>StageQuality.BEST</codeph> — Très haute qualité de rendu. Les graphiques sont anti-aliasés selon une grille de 4 x 4 pixels. Si <codeph>Bitmap.smoothing</codeph> est <codeph>true</codeph>, le moteur d’exécution utilise un algorithme de qualité supérieure pour la réduction de la résolution qui produit moins d’artefacts (l’utilisation de <codeph>StageQuality.BEST</codeph> avec <codeph>Bitmap.smoothing</codeph> paramétré sur <codeph>true</codeph> ralentit toutefois sensiblement les performances et n’est pas recommandée).</li>
	 
	 </ul>
	 
	 <p>Des paramètres de qualité supérieurs produisent un meilleur rendu des bitmaps redimensionnées. Néanmoins, des paramètres de qualité supérieurs sont plus chers. Notamment, lors du rendu de vidéo redimensionnée, l’utilisation de paramètres de qualité supérieurs peut réduire la cadence d’images.
	 </p>
	 
	 <p>Pour le contenu s’exécutant dans Adobe AIR, <codeph>quality</codeph> peut être défini sur <codeph>StageQuality.BEST</codeph> ou <codeph>StageQuality.HIGH</codeph> (et la valeur par défaut est <codeph>StageQuality.HIGH</codeph>). Si vous tentez de le définir sur une autre valeur, il ne se passe rien (et la propriété reste inchangée).
	 </p>
	 
	 <p>Pour le contenu s’exécutant dans Adobe AIR, le réglage de la propriété <codeph>quality</codeph> d’un objet Stage change la qualité de rendu pour tous les objets Stage (utilisés par différents objets NativeWindow).
	 </p>
	 
	 <b><i>Remarque :</i></b> Le système d’exploitation dessine les polices de périphérique, qui ne sont par conséquent pas affectées par la propriété <codeph>quality</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageQuality"><linktext>flash.display.StageQuality</linktext></link><link href="flash.display.xml#Bitmap/smoothing"><linktext>flash.display.Bitmap.smoothing</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
	 Valeur de la classe StageScaleMode qui spécifie le mode d’échelle à utiliser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>scaleMode</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Valeur de la classe StageScaleMode qui spécifie le mode d’échelle à utiliser.
 	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur de la classe StageScaleMode qui spécifie le mode d’échelle à utiliser. Les valeurs suivantes sont prises en charge :
	 
     <ul>
     
     <li><codeph>StageScaleMode.EXACT_FIT</codeph> — Rend tout le contenu visible dans la zone spécifiée sans tenter de préserver les proportions d’origine. Une distorsion peut se produire, et l’application peut sembler étirée ou compressée.
     </li>
     
     <li><codeph>StageScaleMode.SHOW_ALL</codeph> — Spécifie que toute l’application est visible dans la zone spécifiée, sans distorsion, tout en conservant le rapport largeur/hauteur d’origine de l’application. Des bordures peuvent apparaître de part et d’autre de l’application.   
     </li>
     
	 <li><codeph>StageScaleMode.NO_BORDER</codeph> — Spécifie que l’application entière remplit la zone spécifiée, sans distorsion mais avec un recadrage éventuel, tout en conservant le rapport largeur/hauteur d’origine de l’application.
	 </li>
	 
	 <li><codeph>StageScaleMode.NO_SCALE</codeph> — Toute l’application est ajustée, de façon à pouvoir rester inchangée, même si la taille de la fenêtre d’affichage change. Un recadrage risque de se produire si la fenêtre du lecteur est plus petite que le contenu.
	 </li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:showDefaultContextMenu:get"><apiName>showDefaultContextMenu</apiName><shortdesc>
     Spécifie l’affichage ou le masquage des éléments par défaut dans le menu contextuel de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>showDefaultContextMenu</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Spécifie l’affichage ou le masquage des éléments par défaut dans le menu contextuel de Flash Player.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Spécifie l’affichage ou le masquage des éléments par défaut dans le menu contextuel de Flash Player.
     
     <p>Si la propriété <codeph>showDefaultContextMenu</codeph> est définie sur <codeph>true</codeph> (valeur par défaut), tous les éléments du menu contextuel s’affichent. Si la propriété <codeph>showDefaultContextMenu</codeph> est réglée sur <codeph>false</codeph>, seuls les éléments Paramètres et A propos de Adobe Flash Player s’affichent.</p>
     
 	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageFocusRect:get"><apiName>stageFocusRect</apiName><shortdesc>
	 Spécifie si les objets affichent ou non une bordure rayonnante lorsqu’ils disposent du focus.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>stageFocusRect</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Spécifie si les objets affichent ou non une bordure rayonnante lorsqu’ils disposent du focus.
	 
 	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Spécifie si les objets affichent ou non une bordure rayonnante lorsqu’ils disposent du focus.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageHeight:get"><apiName>stageHeight</apiName><shortdesc>
     Hauteur actuelle, en pixels, de la scène.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>stageHeight</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Hauteur actuelle, en pixels, de la scène.
     
     <p>Si la valeur de la propriété <codeph>Stage.scaleMode</codeph> est définie sur <codeph>StageScaleMode.NO_SCALE</codeph> lorsque l’utilisateur redimensionne la fenêtre, le contenu Stage conserve sa taille définie lorsque la propriété <codeph>stageHeight</codeph> change pour refléter la nouvelle hauteur de la zone d’écran occupée par le fichier SWF (dans les autres modes d’échelle, la propriété <codeph>stageHeight</codeph> reflète toujours la hauteur d’origine du fichier SWF0). Vous pouvez ajouter un écouteur d’événement pour l’événement <codeph>resize</codeph> puis utiliser la propriété <codeph>stageHeight</codeph> de la classe Stage pour déterminer la dimension de pixels réelle de la fenêtre Flash Player redimensionnée. L’écouteur d’événements vous permet de contrôler comment le contenu de l’écran est ajusté lorsque l’utilisateur redimensionne la fenêtre.</p>
	 
	 <p><b>Remarque :</b> dans une page HTML hébergeant le fichier SWF, les attributs <codeph>height</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> doivent être définis sur un pourcentage (tel que <codeph>100%</codeph>), et non sur des pixels. Si les réglages sont générés par le code JavaScript, le paramètre <codeph>height</codeph> de la méthode <codeph>AC_FL_RunContent() </codeph> doit être défini sur un pourcentage également. Ce pourcentage s’applique à la valeur <codeph>stageHeight</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:stageWidth:get"><apiName>stageWidth</apiName><shortdesc>
     Spécifie la largeur actuelle, en pixels, de la scène.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>L’appel de la propriété <codeph>stageWidth</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Spécifie la largeur actuelle, en pixels, de la scène.
     
     
     <p>Si la valeur de la propriété <codeph>Stage.scaleMode</codeph> est définie sur <codeph>StageScaleMode.NO_SCALE</codeph> lorsque l’utilisateur redimensionne la fenêtre, le contenu Stage conserve sa taille définie lorsque la propriété <codeph>stageWidth</codeph> change pour refléter la nouvelle largeur de la zone d’écran occupée par le fichier SWF (dans les autres modes d’échelle, la propriété <codeph>stageWidth</codeph> reflète toujours la largeur d’origine du fichier SWF). Vous pouvez ajouter un écouteur d’événement pour l’événement <codeph>resize</codeph> puis utiliser la propriété <codeph>stageWidth</codeph> de la classe Stage pour déterminer la dimension de pixels réelle de la fenêtre Flash Player redimensionnée. L’écouteur d’événements vous permet de contrôler comment le contenu de l’écran est ajusté lorsque l’utilisateur redimensionne la fenêtre.</p>
	 
     <p><b>Remarque :</b> dans une page HTML hébergeant le fichier SWF, les attributs <codeph>width</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> doivent être définis sur un pourcentage (tel que <codeph>100%</codeph>), et non sur des pixels. Si les réglages sont générés par le code JavaScript, le paramètre <codeph>width</codeph> de la méthode <codeph>AC_FL_RunContent() </codeph> doit être défini sur un pourcentage également. Ce pourcentage s’applique à la valeur <codeph>stageWidth</codeph>.</p>
     
 	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 
	 Détermine si les enfants de l’objet prennent ou non en charge la tabulation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Toute référence à la propriété <codeph>tabChildren</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Détermine si les enfants de l’objet prennent ou non en charge la tabulation. Active ou désactive la sélection des enfants de l’objet avec la touche de tabulation. La valeur par défaut est <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
	 
     Renvoie un objet TextSnapshot pour l’occurrence de DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier><apiException><apiDesc>Toute référence à la propriété <codeph>textSnapshot</codeph> d’un objet Stage renvoie une exception dans la mesure où la classe Stage ne met pas en œuvre cette propriété. Pour éviter ce problème, appelez la propriété <codeph>textSnapshot</codeph> d’un objet conteneur différent de l’objet Stage.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Renvoie un objet TextSnapshot pour l’occurrence de DisplayObjectContainer.
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:width:get"><apiName>width</apiName><shortdesc>
	 
     Indique la largeur de l’objet d’affichage, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Toute référence à la propriété <codeph>width</codeph> d’un objet Stage renvoie une exception pour tout appelant qui n’appartient pas au même sandbox de sécurité que le propriétaire de l’objet Stage (le fichier SWF principal). Pour éviter cette situation, le propriétaire de l’objet Stage peut accorder une autorisation au domaine de l’appelant en exécutant la méthode <codeph>Security.allowDomain()</codeph> ou <codeph>Security.allowInsecureDomain()</codeph>. Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Il reste impossible de définir la propriété <codeph>width</codeph> d’un objet Stage, même si vous êtes le propriétaire de l’objet Stage.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Indique la largeur de l’objet d’affichage, en pixels. La largeur est calculée en fonction des limites du contenu de l’objet d’affichage. Lorsque vous définissez la propriété <codeph>width</codeph>, la propriété <codeph>scaleX</codeph> est ajustée en conséquence, comme illustré dans le code suivant :
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>A l’exception des objets TextField et Video, un objet d’affichage sans contenu (comme un sprite vide) a une largeur de 0, même si vous essayez de définir <codeph>width</codeph> sur une valeur différente.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:wmodeGPU:get"><apiName>wmodeGPU</apiName><shortdesc>
	 Indique si la composition GPU est disponible et en cours d’utilisation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si la composition GPU est disponible et en cours d’utilisation. La valeur <codeph>wmodeGPU</codeph> est <codeph>true</codeph> <i>uniquement</i> lorsque les trois conditions suivantes sont remplies : 
	 <p><ul><li>La composition GPU a été sollicitée.</li>
	 <li>La composition GPU est disponible.</li>
	 <li>La composition GPU est en cours d’utilisation.</li></ul></p>
	 <p>Concrètement, la propriété <codeph>wmodeGPU</codeph> peut indiquer plusieurs choses : </p>
	 <p><ol><li>La composition GPU n’a pas été sollicitée ou n’est pas disponible. Dans ce cas, la valeur de la propriété <codeph>wmodeGPU</codeph> est <codeph>false</codeph>.</li>
	 <li>La composition GPU a été sollicitée (s’il y a lieu et si disponible), mais l’environnement est exécuté en « mode de secours » (rendu non optimal) en raison des limites du contenu. Dans ce cas, la valeur de la propriété <codeph>wmodeGPU</codeph> est <codeph>true</codeph>.</li>
	 <li>La composition GPU a été sollicitée (s’il y a lieu et si disponible) et l’environnement est exécuté dans le mode qui convient le mieux. Dans ce cas, la valeur de propriété <codeph>wmodeGPU</codeph> est également <codeph>true</codeph>. </li></ol></p>
	 <p>En d’autres termes, la propriété <codeph>wmodeGPU</codeph> identifie la capacité et l’état de l’environnement de rendu. Pour les moteurs d’exécution qui ne prennent pas en charge la composition GPU, tels que AIR 1.5.2, la valeur est toujours <codeph>false</codeph> : la valeur est <codeph>true</codeph> uniquement lorsque la composition GPU a été sollicitée, est disponible et est en cours d’utilisation (comme indiqué ci-dessus).</p>
	 <p>La propriété <codeph>wmodeGPU</codeph> est utile pour déterminer, à l’exécution, si la composition GPU est en cours d’utilisation. La valeur de la propriété <codeph>wmodeGPU</codeph> indique si le contenu va être ou non mis à l’échelle par le matériel afin que vous puissiez présenter les images à la taille appropriée. Vous pouvez par ailleurs déterminer si vous souhaitez ou non procéder à un rendu dans un chemin rapide afin de pouvoir ajuster la complexité de votre contenu en conséquence.</p>
	 <p>Pour Flash Player dans un navigateur, la composition GPU peut être sollicitée par la valeur de <codeph>gpu</codeph> pour le paramètre HTML <codeph>wmode</codeph> dans la page qui héberge le fichier SWF. Pour d’autres configurations, la composition GPU peut être sollicitée dans l’en-tête d’un fichier SWF (défini à l’aide d’outils de création SWF).</p>	 
	 <p>Toutefois, la propriété <codeph>wmodeGPU</codeph> n’identifie pas les performances de rendu actuelles. Même si la composition GPU est « en cours d’utilisation », le processus de rendu peut ne pas être exécuté dans le mode le mieux approprié. Pour ajuster votre contenu en vue d’obtenir un rendu optimal, utilisez une version de débogage du moteur d’exécution de Flash et définissez <codeph>DisplayGPUBlendsetting</codeph> dans votre fichier mm.cfg.</p>
	 
	 <p><b>Remarque :</b> cette propriété est toujours définie sur <codeph>false</codeph> si elle est référencée à partir du code ActionScript exécuté avant que le moteur d’exécution n’effectue sa première opération de rendu. Par exemple, si vous examinez la propriété <codeph>wmodeGPU</codeph> à partir d’un script dans l’image 1 d’Adobe Flash Professional et que votre fichier SWF est le premier fichier SWF chargé dans une nouvelle occurrence du moteur d’exécution, la valeur de la propriété <codeph>wmodeGPU</codeph> est <codeph>false</codeph>. Pour obtenir une valeur exacte, attendez qu’au moins une opération de rendu ait eu lieu. Si vous programmez un écouteur d’événement pour l’événement <codeph>exitFrame</codeph> d’un objet <codeph>DisplayObject</codeph>, la propriété <codeph>wmodeGPU</codeph> est définie sur la valeur correcte.</p>
	 
	 </apiDesc><example conref="examples\Stage.wmodeGPU.as"> L’exemple suivant examine la propriété <codeph>wmodeGPU</codeph> après le rendu de l’objet d’affichage mySprite afin que vous puissiez obtenir une valeur exacte.
<codeblock>
mySprite.addEventListener(EXIT_FRAME, exithandler):

function exithandler(exiteventobject:Event):void {
                trace(stage.wmodeGPU);
}
</codeblock></example></apiValueDetail><related-links><link href="DisplayObject.html#event:exitFrame"><linktext>Evénement exitFrame de la classe DisplayObject</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	 La classe NativeWindowInitOptions définit les options d’initialisation utilisées pour construire une nouvelle occurrence de NativeWindow.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe NativeWindowInitOptions définit les options d’initialisation utilisées pour construire une nouvelle occurrence de NativeWindow. 
	 <p>Les propriétés définies dans les options d’initialisation ne peuvent pas être modifiées après la création d’une fenêtre.</p>
	 
	 <p><b>Remarque :</b> pour la fenêtre d’application initiale créée automatiquement par AIR, toutes ces propriétés (excepté <codeph>type</codeph>) sont définies dans le descripteur d’application. La fenêtre d’origine est toujours de type normal.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links><apiConstructor id="flash.display:NativeWindowInitOptions:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	    Crée un nouvel objet NativeWindowInitOptions.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	    Crée un nouvel objet NativeWindowInitOptions.
	    
        <p>Les valeurs par défaut du nouvel objet sont :</p>
	    <ul>
        <li><codeph>systemChrome = NativeWindowSystemChrome.STANDARD</codeph></li>
        <li><codeph>type = NativeWindowType.NORMAL</codeph></li>
	    <li><codeph>transparent = false</codeph></li>
	    <li><codeph>resizable = true</codeph></li>
	    <li><codeph>maximizable = true</codeph></li>
	    <li><codeph>minimizable = true</codeph></li>
	    </ul>
	    
	    </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:NativeWindowInitOptions:maximizable:get"><apiName>maximizable</apiName><shortdesc>
		 Spécifie si la fenêtre peut être agrandie par l’utilisateur. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MAXIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Spécifie si la fenêtre peut être agrandie par l’utilisateur.   
		 
		 <p>
		 Pour les fenêtres avec chrome système, ce paramètre affecte l’aspect du bouton d’agrandissement de la fenêtre. Il affecte également d’autres parties de l’interface utilisateur gérée par le système telles que le menu de la fenêtre dans Microsoft Windows.
		 </p>
		 
		 <p>
		 Lorsque la valeur définie est <codeph>false</codeph>, la fenêtre ne peut pas être agrandie par l’utilisateur. L’appel direct de la méthode <codeph>maximize()</codeph> de la classe NativeWindow agrandit la fenêtre.
		 </p>
		 
		 <p><b>Remarque :</b> sur des systèmes d’exploitation tels que Mac OS X, dans lesquels l’agrandissement d’une fenêtre n’empêche pas également le redimensionnement, <codeph>maximizable</codeph> et <codeph>resizable</codeph> doivent être définies sur <codeph>false</codeph> pour empêcher que la fenêtre soit redimensionnée ou qu’un zoom soit effectué.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:minimizable:get"><apiName>minimizable</apiName><shortdesc>
		 Spécifie si la fenêtre peut être réduite par l’utilisateur. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MINIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Spécifie si la fenêtre peut être réduite par l’utilisateur. 
		 
		 <p>
		 Pour les fenêtres avec chrome système, ce paramètre affecte l’aspect du bouton de réduction de la fenêtre. Il affecte également d’autres parties de l’interface utilisateur gérée par le système telles que le menu de la fenêtre dans Microsoft Windows.
		 </p>
		 
		 <p>
		 Lorsque la valeur définie est <codeph>false</codeph>, la fenêtre ne peut pas être réduite par l’utilisateur. L’appel direct de la méthode <codeph>minimize()</codeph> de la classe NativeWindow réduit la fenêtre.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:resizable:get"><apiName>resizable</apiName><shortdesc>
		 Spécifie si la fenêtre peut être redimensionnée par l’utilisateur. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_SIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Spécifie si la fenêtre peut être redimensionnée par l’utilisateur. 
		 
		 <p>
		 Lorsque la valeur définie est <codeph>false</codeph>, la fenêtre ne peut pas être redimensionnée par l’utilisateur à l’aide du chrome système. L’appel de la méthode <codeph>startResize()</codeph> de l’objet NativeWindow en réponse à un événement de souris permet à l’utilisateur de redimensionner la fenêtre. Définir directement les limites de la fenêtre permet également de modifier la taille de la fenêtre. 
		 </p>
		 
		 <p><b>Remarque :</b> sur des systèmes d’exploitation tels que Mac OS X, dans lesquels l’agrandissement de fenêtres est une opération de redimensionnement, <codeph>maximizable</codeph> et <codeph>resizable</codeph> doivent être définies sur <codeph>false</codeph> pour empêcher que la fenêtre soit redimensionnée ou qu’un zoom soit effectué.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
		 Indique si le chrome système est fourni pour la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowSystemChrome.STANDARD
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Indique si le chrome système est fourni pour la fenêtre. 
		  
		 <p> Chrome fait référence aux commandes de la fenêtre qui permettent à un utilisateur de commander les propriétés de bureau d’une fenêtre. Le chrome système utilise les commandes standard pour l’environnement de bureau dans lequel l’application AIR est exécutée et est conforme à l’apparence standard du système d’application natif.</p>
		 <p>
		 Pour utiliser le chrome fourni par un logiciel intégré (tel que Flex) ou pour fournir un chrome à votre fenêtre, réglez <codeph>systemChrome</codeph> sur <codeph>NativeWindowSystemChrome.NONE</codeph>.
		 </p>
		 <p>Les constantes pour les valeurs valides de cette propriété sont définies dans la classe NativeWindowSystemChrome :
         </p>
		 <ul>
         <li><codeph>NativeWindowSystemChrome.NONE</codeph></li>
		 <li><codeph>NativeWindowSystemChrome.STANDARD</codeph></li>
		 </ul>
		 
		 <p>Si elle n’est pas spécifiée, la valeur par défaut pour <codeph>systemChrome</codeph> est <codeph>NativeWindowSystemChrome.STANDARD</codeph>.
		 </p>
		 
		 <p>La définition de la propriété <codeph>transparent</codeph> sur <codeph>true</codeph> pour une fenêtre avec chrome système n’est pas prise en charge.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:transparent:get"><apiName>transparent</apiName><shortdesc>
		 Spécifie si la fenêtre prend en charge la transparence et l’alpha blending par rapport au bureau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
		 
	     </apiDefaultValue></apiValueDef><apiDesc>
		 Spécifie si la fenêtre prend en charge la transparence et l’alpha blending par rapport au bureau.
		 
		 <p>
		 Si la valeur est <codeph>true</codeph>, l’affichage de la fenêtre est combiné par rapport au bureau. Les zones de la fenêtre non couvertes par un objet d’affichage ou couvertes par des objets d’affichage avec un paramètre alpha proche de zéro, sont effectivement invisibles et n’interceptent pas d’événements mouse (qui sont reçus par l’objet desktop sous la fenêtre). La valeur alpha à laquelle un objet n’intercepte plus d’événements mouse varie entre environ ,06 et ,01 selon le système d’exploitation.
		 </p>  
		 
		 <p>La définition de la propriété <codeph>transparent</codeph> sur <codeph>true</codeph> pour une fenêtre avec chrome système n’est pas prise en charge.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowInitOptions:type:get"><apiName>type</apiName><shortdesc>
		 Spécifie le type de fenêtre à créer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowType.NORMAL
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Spécifie le type de fenêtre à créer.  
		 
		 <p>Les constantes pour les valeurs valides de cette propriété sont définies dans la classe NativeWindowType :
         </p>
         
		 <ul>
		 <li><codeph>NativeWindowType.NORMAL</codeph> — Une fenêtre classique. Les fenêtres normales utilisent le chrome plein écran, et apparaissent dans la barre des tâches Windows ou Linux et le menu de la fenêtre Mac OS X.</li>
		 
		 <li><codeph>NativeWindowType.UTILITY</codeph> — Une palette d’outils. Les fenêtres d’utilitaire utilisent une version plus fine du chrome système et n’apparaissent pas sur la barre des tâches Windows ni sur le menu de la fenêtre Mac OS X.</li>
		 
		 <li><codeph>NativeWindowType.LIGHTWEIGHT</codeph> : les fenêtres légères ne peuvent pas avoir de chrome système et n’apparaissent pas dans la barre des tâches Windows ou Linux ni dans le menu de la fenêtre Mac OS X. De plus, les fenêtres légères n’ont pas de menu Système (Alt-Espace) sous Windows. Les fenêtres légères sont adaptées aux commandes et aux bulles de notification (combo-boxes qui ouvrent une zone d’affichage de courte durée, par exemple). Lorsque le type léger est utilisé, <codeph>systemChrome</codeph> doit être réglé sur <codeph>none</codeph>.</li>
		 </ul>
		 
		 <p>
		 Si elle n’est pas spécifiée, la valeur par défaut pour <codeph>type</codeph> est <codeph>NativeWindowType.NORMAL</codeph>.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
	 Une occurrence de ShaderParameter représente un unique paramètre d’entrée d’un noyau de shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Une occurrence de ShaderParameter représente un unique paramètre d’entrée d’un noyau de shader. Un noyau peut être défini pour accepter aucun, un ou plusieurs paramètres utilisés dans l’exécution du noyau. Un ShaderParameter fournit des informations sur le paramètre, par exemple le type de données attendues. Il fournit également un mécanisme qui permet de définir la valeur du paramètre utilisé lorsque le shader s’exécute. Pour spécifier une ou plusieurs valeurs pour le paramètre du shader, créez un Array contenant la ou les valeurs et affectez-le à la propriété <codeph>value</codeph>.
	 
	 <p>Une occurrence de ShaderParameter représentant un paramètre pour une occurrence de Shader est accédée en tant que propriété de la propriété <codeph>data</codeph> du Shader. La propriété ShaderParameter a le même nom que celui du paramètre dans le code du shader. Par exemple, si un shader définit un paramètre nommé <codeph>radius</codeph>, l’occurrence de ShaderParameter représentant le paramètre <codeph>radius</codeph> est disponible en tant que propriété <codeph>radius</codeph>, comme le montre cet exemple :</p>
	 
	 <codeblock>var radiusParam:ShaderParameter = myShader.data.radius;</codeblock>
	 
	 <p>En plus des propriétés définies pour la classe ShaderParameter, chaque occurrence de ShaderParameter possède des propriétés supplémentaires correspondant à toutes métadonnées définies pour le paramètre. Ces propriétés sont ajoutées à l’objet ShaderParameter lors de sa création. Le nom des propriétés correspond à celui des métadonnées spécifiées dans le code source du shader. Le type de données de chaque propriété dépend du type de données des métadonnées correspondantes. Une valeur de métadonnées texte telle que « description » est une occurrence String. Une propriété de métadonnées avec une valeur non chaîne (telle que <codeph>minValue</codeph> ou <codeph>defaultValue</codeph>) est représentée par une occurrence Array. Le nombre d’éléments et les types de données des éléments correspondent aux valeurs des métadonnées.</p>
	 
	 <p>Supposons par exemple qu’un shader comprenne les deux déclarations de paramètres suivantes :</p>
	 
	 <codeblock>
	 parameter float2 size
	 &lt;
	     description: "The size of the image to which the kernel is applied";
	     minValue: float2(0.0, 0.0);
	     maxValue: float2(100.0, 100.0);
	     defaultValue: float2(50.0, 50.0);
	 >;
	 
	 parameter float radius
	 &lt;
	     description: "The radius of the effect";
	     minValue: 0.0;
	     maxValue: 50.0;
	     defaultValue: 25.0;
	 >;
	 </codeblock>
	 
	 <p>L’occurrence de ShaderParameter correspondant au paramètre <codeph>size</codeph> a les propriétés de métadonnées suivantes, en plus de ses propriétés intégrées :</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Nom de propriété</entry><entry>Type de données</entry><entry>Valeur</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"size"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"The size of the image to which the kernel is applied"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0, 0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[100, 100]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50, 50]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Le ShaderParameter correspondant au paramètre <codeph>radius</codeph> a les propriétés supplémentaires suivantes :</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Nom de propriété</entry><entry>Type de données</entry><entry>Valeur</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"radius"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"The radius of the effect"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[25]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>En général, le code du développeur ne crée pas directement d’occurrence de ShaderParameter. Une occurrence de ShaderParameter est créée pour chacun des paramètres d’un shader lors de la création de l’occurrence de Shader.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links><apiConstructor id="flash.display:ShaderParameter:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
		 Crée une occurrence de ShaderParameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Crée une occurrence de ShaderParameter. Le code du développeur n’appelle pas directement le constructeur ShaderParameter. Une occurrence de ShaderParameter est créée pour chacun des paramètres d’un shader lors de la création de l’occurrence de Shader.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderParameter:index:get"><apiName>index</apiName><shortdesc>
         Index du paramètre (de base zéro).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Index du paramètre (de base zéro).
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameter:type:get"><apiName>type</apiName><shortdesc>
		Type de données du paramètre tel que défini dans le shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Type de données du paramètre tel que défini dans le shader. L’ensemble des valeurs potentielles de la propriété <codeph>type</codeph> est défini par les constantes de la classe ShaderParameterType.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameterType"><linktext>flash.display.ShaderParameterType</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameter:value:get"><apiName>value</apiName><shortdesc>
		La ou les valeurs transmises en tant que valeur du paramètre au shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		La ou les valeurs transmises en tant que valeur du paramètre au shader. La propriété <codeph>value</codeph> est un Array indexé. Le nombre et le type des éléments du Array correspondent au type de données du paramètre, que la propriété <codeph>type</codeph> permet de déterminer.
		
		<p>Le tableau suivant indique le type du paramètre et le nombre et le type de données correspondant des éléments <codeph>value</codeph> du Array :</p>
		
		<adobetable class="innertable">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		<tgroup cols="3"><thead><row><entry>Type de paramètre</entry><entry># Eléments</entry><entry>Type de données de l’élément</entry></row></thead><tbody><row>
		  <entry>float (<codeph>ShaderParameterType.FLOAT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float2 (<codeph>ShaderParameterType.FLOAT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3 (<codeph>ShaderParameterType.FLOAT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4 (<codeph>ShaderParameterType.FLOAT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>int (<codeph>ShaderParameterType.INT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>int ou uint</entry>
		</row><row>
		  <entry>int2 (<codeph>ShaderParameterType.INT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>int ou uint</entry>
		</row><row>
		  <entry>int3 (<codeph>ShaderParameterType.INT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>int ou uint</entry>
		</row><row>
		  <entry>int4 (<codeph>ShaderParameterType.INT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>int ou uint</entry>
		</row><row>
		  <entry>bool (<codeph>ShaderParameterType.BOOL</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool2 (<codeph>ShaderParameterType.BOOL2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool3 (<codeph>ShaderParameterType.BOOL3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool4 (<codeph>ShaderParameterType.BOOL4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>float2x2 (<codeph>ShaderParameterType.MATRIX2X2</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3x3 (<codeph>ShaderParameterType.MATRIX3X3</codeph>)</entry>
		  <entry>9</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4x4 (<codeph>ShaderParameterType.MATRIX4X4</codeph>)</entry>
		  <entry>16</entry>
		  <entry>Number</entry>
		</row></tbody></tgroup></adobetable>
		
		<p>Pour les types de paramètres matriciels, les éléments du tableau remplissent les lignes de la matrice, puis les colonnes. Par exemple, supposons que la ligne suivante de code ActionScript soit utilisée pour remplir un paramètre <codeph>float2x2</codeph> nommé <codeph>myMatrix</codeph> :</p>
		
		<codeblock>myShader.data.myMatrix.value = [.1, .2, .3, .4];</codeblock>
		
		<p>A l’intérieur du shader, les éléments de la matrice ont les valeurs suivantes :</p>
		
		<ul>
		  <li><codeph>myMatrix[0][0]</codeph>: .1</li>
		  <li><codeph>myMatrix[0][1]</codeph>: .2</li>
		  <li><codeph>myMatrix[1][0]</codeph>: .3</li>
		  <li><codeph>myMatrix[1][1]</codeph>: .4</li>
		</ul>
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GradientType"><apiName>GradientType</apiName><shortdesc>
La classe GradientType fournit les valeurs du paramètre type dans les méthodes beginGradientFill() et lineGradientFill() de la classe flash.display.Graphics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe GradientType fournit les valeurs du paramètre <codeph>type</codeph> dans les méthodes <codeph>beginGradientFill()</codeph> et <codeph>lineGradientFill()</codeph> de la classe flash.display.Graphics.

</apiDesc></apiClassifierDetail><apiValue id="flash.display:GradientType:LINEAR"><apiName>LINEAR</apiName><shortdesc>
	Valeur utilisée pour spécifier un remplissage dégradé linéaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linear</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Valeur utilisée pour spécifier un remplissage dégradé linéaire.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GradientType:RADIAL"><apiName>RADIAL</apiName><shortdesc>
	Valeur utilisée pour spécifier un remplissage dégradé radial.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>radial</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Valeur utilisée pour spécifier un remplissage dégradé radial.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InterpolationMethod"><apiName>InterpolationMethod</apiName><shortdesc>
La classe InterpolationMethod transmet des valeurs au paramètre interpolationMethod par l’intermédiaire des méthodes Graphics.beginGradientFill() et Graphics.lineGradientStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe InterpolationMethod transmet des valeurs au paramètre <codeph>interpolationMethod</codeph> par l’intermédiaire des méthodes <codeph>Graphics.beginGradientFill()</codeph> et <codeph>Graphics.lineGradientStyle()</codeph>. Ce paramètre détermine l’espace RVB à utiliser lors du rendu du dégradé. 

 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:InterpolationMethod:LINEAR_RGB"><apiName>LINEAR_RGB</apiName><shortdesc>
	Spécifie que la méthode d’interpolation RVB linéaire doit être utilisée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linearRGB</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie que la méthode d’interpolation RVB linéaire doit être utilisée. Ceci signifie qu’un espace de couleurs RVB basé sur un modèle de couleurs RVB linéaire est utilisé.
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/RGB"><linktext>RVB</linktext></link></related-links></apiValue><apiValue id="flash.display:InterpolationMethod:RGB"><apiName>RGB</apiName><shortdesc>
	Spécifie que la méthode d’interpolation RVB doit être utilisée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>rgb</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie que la méthode d’interpolation RVB doit être utilisée. Ceci signifie que le dégradé est rendu avec un espace sRVB exponentiel (RVB standard). L’espace sRVB est une norme de la W3C qui définit la conversion entre les valeurs de composant rouge, vert et bleu et l’intensité réelle de la couleur du composant visible.
	
	<p>Prenons, par exemple, un dégradé linéaire simple entre deux couleurs (le paramètre <codeph>spreadMethod</codeph> étant réglé sur <codeph>SpreadMethod.REFLECT</codeph>). Les différentes méthodes d’interpolation influent sur l’aspect de la façon suivante : </p>
	
		<adobetable>
		
      
		
		
		
		<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="dégradé linéaire avec InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="dégradé linéaire avec InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
		</row><row>
		<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
		<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
		</row></tbody></tgroup></adobetable>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/LINEAR_RGB"><linktext>LINEAR_RGB</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsPath"><apiName>IGraphicsPath</apiName><shortdesc>
	Cette interface vous permet de définir des objets pouvant être utilisés comme paramètres de tracé dans les méthodes flash.display.Graphics et les classes de dessin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Cette interface vous permet de définir des objets pouvant être utilisés comme paramètres de tracé dans les méthodes flash.display.Graphics et les classes de dessin. Utilisez les classes implémenteur de cette interface pour créer et gérer les données de la propriété path et pour réutiliser les mêmes données pour plusieurs occurrences.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:IGraphicsFill"><apiName>IGraphicsFill</apiName><shortdesc>
	Cette interface vous permet de définir des objets pouvant être utilisés comme paramètres de remplissage dans les méthodes flash.display.Graphics et les classes de dessin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Cette interface vous permet de définir des objets pouvant être utilisés comme paramètres de remplissage dans les méthodes flash.display.Graphics et les classes de dessin. Utilisez les classes implémenteur de cette interface pour créer et gérer les données de la propriété fill et pour réutiliser les mêmes données pour plusieurs occurrences.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#GraphicsStroke/fill"><linktext>flash.display.GraphicsStroke.fill</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:LoaderInfo"><apiName>LoaderInfo</apiName><shortdesc>
 La classe LoaderInfo fournit des informations relatives à un fichier SWF ou à un fichier d’image (JPEG, GIF ou PNG) chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion><Exclude kind="method" name="dispatchEvent"/></asMetadata><asCustoms><internal>Update the places LoaderInfo can be obtained from (playerglobal.as) and double-check loader vs. loadee.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe LoaderInfo fournit des informations relatives à un fichier SWF ou à un fichier d’image (JPEG, GIF ou PNG) chargé. Les objets LoaderInfo sont disponibles pour n’importe quel objet d’affichage. Les informations indiquées comprennent la progression du chargement, les URL de l’objet Loader et du contenu chargé, le nombre total d’octets du média, ainsi que la hauteur et la largeur nominales de ce dernier.
 
 <p>Vous pouvez accéder aux objets LoaderInfo de deux façons : </p>
 
 <ul>
 
 	<li>La propriété <codeph>contentLoaderInfo</codeph> d’un objet flash.display.Loader. La propriété <codeph>contentLoaderInfo</codeph> reste disponible quel que soit l’objet Loader. Si un objet Loader n’a pas appelé la méthode <codeph>load()</codeph> ou <codeph>loadBytes()</codeph> ou que la proportion chargée n’est pas suffisante, tenter d’accéder à la plupart des propriétés de <codeph>contentLoaderInfo</codeph> renvoie une erreur.</li>
 
 	<li>La propriété <codeph>loaderInfo</codeph> d’un objet d’affichage. </li>
 
 </ul>
 
 <p>La propriété <codeph>contentLoaderInfo</codeph> d’un objet Loader fournit des informations sur le contenu chargé par cet objet, tandis que la propriété <codeph>loaderInfo</codeph> d’un objet DisplayObject propose des informations sur le fichier SWF racine correspondant à l’objet d’affichage. </p>
 
 <p>Lorsque vous utilisez un objet Loader pour charger un objet d’affichage (par exemple, un fichier SWF ou une image bitmap), la propriété <codeph>loaderInfo</codeph> de l’objet d’affichage est la même que la propriété <codeph>contentLoaderInfo</codeph> de l’objet Loader (<codeph>DisplayObject.loaderInfo = Loader.contentLoaderInfo</codeph>). L’occurrence de la classe principale du fichier SWF ne disposant pas d’un objet Loader, la propriété <codeph>loaderInfo</codeph> est l’unique moyen dont elle dispose pour accéder à LoaderInfo.</p>
 
 <p>Le diagramme ci-dessous indique les différentes utilisations de l’objet LoaderInfo pour l’occurrence de la classe principale du fichier SWF, pour la propriété <codeph>contentLoaderInfo</codeph> d’un objet Loader et pour la propriété <codeph>loaderInfo</codeph> d’un objet chargé :</p>
 
 <p>
 <adobeimage alt="Une image de différentes situations LoaderInfo" href="../../images/loaderInfo_object.jpg"/>
 </p>
 
 <p>Certaines propriétés de la propriété <codeph>contentLoaderInfo</codeph> d’un objet Loader ne sont pas disponibles tant que l’opération de chargement n’est pas terminée. Vous avez cependant accès à certaines propriétés, telles que <codeph>bytesLoaded</codeph>, <codeph>bytesTotal</codeph>, <codeph>url</codeph>, <codeph>loaderURL</codeph> et <codeph>applicationDomain</codeph>. Lorsque l’objet <codeph>loaderInfo</codeph> distribue l’événement <codeph>init</codeph>, vous pouvez accéder à toutes ses propriétés<codeph>loaderInfo</codeph>, ainsi qu’à l’image ou au fichier SWF chargés.</p>
 
 <p><b>Remarque :</b> toutes les propriétés des objets LoaderInfo sont accessibles en lecture seule.</p>
 
 <p>La méthode <codeph>EventDispatcher.dispatchEvent()</codeph> ne s’applique pas aux objets LoaderInfo. Si vous appelez <codeph>dispatchEvent()</codeph> sur un objet LoaderInfo, une exception IllegalOperationError est renvoyée.</p>
 
 
 
 </apiDesc><example conref="examples\LoaderInfoExample.as"> L’exemple suivant utilise la classe LoaderInfoExample pour afficher une image sur la scène. Pour ce faire, procédez comme suit :
 <ol>
  <li>Une propriété <codeph>url</codeph> est créée pour désigner l’emplacement et le nom de l’image.</li>
 
  <li>Le constructeur de classe crée un objet Loader appelé <codeph>loader</codeph>.</li>
 
  <li>L’objet <codeph>loader</codeph> crée une occurrence d’écouteur d’événements pour s’assurer que l’image se charge correctement.</li>
 
  <li>Le constructeur crée une occurrence d’objet URLRequest, <codeph>request</codeph>, et transmet le paramètre <codeph>url</codeph> de façon à identifier le nom de fichier et son emplacement.</li>
 
  <li>L’objet <codeph>request</codeph> est ensuite transmis à la méthode <codeph>load()</codeph> de l’objet <codeph>loader</codeph>, qui charge l’image dans la liste d’affichage.</li>
 
 </ol>
 <p><b>Important :</b> cet exemple implique l’ajout d’un fichier appelé Image.gif dans le même répertoire que le fichier SWF compilé. Utilisez une image dont la zone corresponde aux dimensions du fichier SWF principal.</p>
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.LoaderInfo;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderInfoExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderInfoExample() {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function initHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var info:LoaderInfo = LoaderInfo(loader.contentLoaderInfo);
            trace("initHandler: loaderURL=" + info.loaderURL + " url=" + info.url);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObject/loaderInfo"><linktext>flash.display.DisplayObject.loaderInfo</linktext></link></related-links><adobeApiEvent id="flash.display:LoaderInfo_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Distribué lorsqu’une requête réseau est effectuée sur HTTP et qu’un code d’état HTTP peut être détecté.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une requête réseau est effectuée sur HTTP et qu’un code d’état HTTP peut être détecté.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.UNLOAD_unload"><apiName>unload</apiName><shortdesc>
 Distribué par un objet LoaderInfo lorsqu’un objet chargé est supprimé à l’aide de la méthode unload() de l’objet Loader ou lorsqu’un second chargement est effectué par le même objet Loader et que le contenu d’origine est supprimé avant le début du chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.UNLOAD</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par un objet LoaderInfo lorsqu’un objet chargé est supprimé à l’aide de la méthode <codeph>unload()</codeph> de l’objet Loader ou lorsqu’un second chargement est effectué par le même objet Loader et que le contenu d’origine est supprimé avant le début du chargement.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>Loader.unload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Distribué lors de la réception des données au fur et à mesure du téléchargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué au fur et à mesure de la réception des données via le processus de téléchargement.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Distribué lors du démarrage d’une opération de chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lors du démarrage d’une opération de chargement.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération de chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération de chargement. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.INIT_init"><apiName>init</apiName><shortdesc>
 Distribué lorsqu’il est possible d’accéder aux propriétés et aux méthodes d’un fichier SWF chargé et de les utiliser. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.INIT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il est possible d’accéder aux propriétés et aux méthodes d’un fichier SWF chargé et de les utiliser. Il est néanmoins toujours possible de télécharger le contenu. Un objet LoaderInfo distribue l’événement <codeph>init</codeph> lorsque les conditions suivantes sont remplies :
 <ul>
     <li>Il est possible d’accéder à toutes les propriétés et méthodes associées à l’objet chargé et celles associées à l’objet LoaderInfo.</li>
     <li>L’exécution des constructeurs de tous les objets enfant est terminée.</li>
     <li>Le code ActionScript contenu dans la première image du scénario principal du fichier SWF chargé a été exécuté.</li>
 </ul>
 
 <p>Par exemple, un événement <codeph>Event.INIT</codeph> est distribué lorsque la première image d’un clip ou d’une animation est chargée. Vous pouvez alors accéder au clip et l’ajouter à la liste d’affichage. Il est toutefois possible que le téléchargement du clip complet soit un peu plus long. L’événement <codeph>Event.COMPLETE</codeph> n’est distribué que lorsque le clip complet est chargé.</p>
 
 <p>L’événement <codeph>init</codeph> précède toujours l’événement <codeph>complete</codeph>.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Distribué lorsque le chargement de données aboutit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque le chargement de données aboutit. En d’autres termes, il est distribué lorsque tout le contenu a été téléchargé et une fois le chargement terminé. L’événement <codeph>complete</codeph> est toujours distribué après l’événement <codeph>init. </codeph> L’événement <codeph>init</codeph> est distribué lorsque vous pouvez accéder à l’objet, même si le contenu est en cours de téléchargement.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:LoaderInfo:getLoaderInfoByDefinition"><apiName>getLoaderInfoByDefinition</apiName><shortdesc>
     Renvoie l’objet LoaderInfo associé à un fichier SWF défini sous forme d’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>L’appelant n’est pas exécuté dans le sandbox approuvé local.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet LoaderInfo associé. Renvoie <codeph>null</codeph> lorsqu’il est appelé dans des versions qui ne sont pas des versions débogueur (ou lorsque le débogage est désactivé) ou si l’<codeph>objet</codeph> référencé n’a pas d’objet LoaderInfo associé (comme certains objets utilisés par le moteur d’exécution AIR).
	 
	 </apiDesc><apiOperationClassifier>flash.display:LoaderInfo</apiOperationClassifier></apiReturn><apiParam><apiItemName>object</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>L’objet pour lequel vous souhaitez obtenir un objet LoaderInfo associé.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie l’objet LoaderInfo associé à un fichier SWF défini sous forme d’objet.
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:LoaderInfo:actionScriptVersion:get"><apiName>actionScriptVersion</apiName><shortdesc>
	 Version ActionScript du fichier SWF chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Si le fichier n’est pas un fichier SWF.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Version ActionScript du fichier SWF chargé. La version du langage est spécifiée par le biais des énumérations de la classe ActionScriptVersion, telles que <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> et <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>.
	 
	 <p><b>Remarque :</b> cette propriété possède toujours la valeur <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> ou <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>. ActionScript 1.0 et 2.0 correspondent tous deux à <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> (version 2.0). Cette propriété se contente de distinguer ActionScript 1.0 et 2.0 d’ActionScript 3.0.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ActionScriptVersion"><linktext>flash.display.ActionScriptVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:applicationDomain:get"><apiName>applicationDomain</apiName><shortdesc>
	 Lorsqu’un fichier SWF externe est chargé, toutes les définitions ActionScript 3.0 que contient la classe chargée sont enregistrées dans la propriété applicationDomain.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need better description and example.  
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier><apiException><apiDesc>Ce sandbox de sécurité de l’appelant n’est pas autorisé à accéder à la propriété ApplicationDomain.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Lorsqu’un fichier SWF externe est chargé, toutes les définitions ActionScript 3.0 que contient la classe chargée sont enregistrées dans la propriété <codeph>applicationDomain</codeph>.
	 
	 <p>L’ensemble du code d’un fichier SWF est défini de sorte à exister dans un domaine d’application. Votre application principale s’exécute dans le domaine d’application en cours. Le domaine du système contient tous les domaines d’application, y compris le domaine actuel et toutes les classes utilisées par Flash Player ou Adobe AIR.</p>
	 
	 <p>A l’exception du domaine du système, tous les domaines d’application sont associés à un domaine du parent. Le domaine du parent de la propriété <codeph>applicationDomain</codeph> de votre application principale est le domaine système. Les classes chargées ne sont définies que si leur parent ne les définit pas encore. Vous ne pouvez pas remplacer une définition de classe chargée par une définition plus récente.</p>
	 
	 <p>Pour obtenir des exemples d’utilisation de domaines d’application, voir le chapitre « Environnement du système client » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:bytes:get"><apiName>bytes</apiName><shortdesc>
	 Octets associés à un objet LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>Si l’objet qui accède à cette API ne peut pas accéder à l’objet chargé en raison de restrictions de sécurité. Ce cas de figure se produit par exemple lorsqu’un fichier Loader tente d’accéder à la propriété <codeph>contentLoaderInfo.content</codeph> et n’est pas autorisé à accéder au contenu chargé.
	 
	 <p>Pour plus d’informations, voir le chapitre « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Octets associés à un objet LoaderInfo. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 Nombre d’octets chargés pour le média.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’octets chargés pour le média. Lorsque ce nombre atteint la valeur de <codeph>bytesTotal</codeph>, tous les octets sont chargés.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 Nombre d’octets compressés du fichier multimédias entier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’octets compressés du fichier multimédias entier.
	 
	 <p>Avant la distribution du premier événement <codeph>progress</codeph> par l’objet Loader correspondant de cet objet LoaderInfo, <codeph>bytesTotal</codeph> est défini sur 0. Après la distribution du premier événement <codeph>progress</codeph> par l’objet Loader, <codeph>bytesTotal</codeph> reflète le nombre réel d’octets à télécharger.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:childAllowsParent:get"><apiName>childAllowsParent</apiName><shortdesc>
	 Exprime la relation de confiance qui lie le contenu (l’enfant) à l’objet Loader (le parent).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Exception renvoyée si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Exprime la relation de confiance qui lie le contenu (l’enfant) à l’objet Loader (le parent). Renvoie <codeph>true</codeph> si l’enfant a autorisé l’accès du parent, <codeph>false</codeph> dans le cas contraire. Cette propriété est définie sur <codeph>true</codeph> si l’objet enfant a appelé la méthode <codeph>allowDomain()</codeph> pour accorder une autorisation d’accès au domaine parent, ou si un fichier de régulation d’URL chargé dans le domaine enfant accorde une autorisation d’accès au domaine parent. Si l’enfant et le parent appartiennent au même domaine, cette propriété est réglée sur <codeph>true</codeph>.
	 
	 <p>Pour plus d’informations, voir le chapitre « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:childSandboxBridge:get"><apiName>childSandboxBridge</apiName><shortdesc>
	 Un objet qui peut être définir par le code du contenu chargé pour exposer des propriétés et des méthodes auxquelles le code dans le sandbox de l’objet Loader peut accéder.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Seul le contenu dans le sandbox du contenu chargé peut définir cette propriété.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Un objet qui peut être défini par le code du contenu chargé pour exposer des propriétés et des méthodes auxquelles le code dans le sandbox de l’objet Loader peut accéder. Ce <i>pont de sandbox</i>permet au contenu d’un domaine qui n’est pas un domaine d’application de bénéficier d’un accès contrôlé aux scripts dans le sandbox de l’application AIR, et vice-versa. Le pont de sandbox sert de passerelle entre les sandboxes, fournissant une interaction explicite entre les sandboxes de sécurité de l’application et les autres. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/parentSandboxBridge"><linktext>parentSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:content:get"><apiName>content</apiName><shortdesc>
	 Objet chargé associé à cet objet LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>Si l’objet qui accède à cette API ne peut pas accéder à l’objet chargé en raison de restrictions de sécurité. Ce cas de figure se produit par exemple lorsqu’un fichier Loader tente d’accéder à la propriété <codeph>contentLoaderInfo.content</codeph> et n’est pas autorisé à accéder au contenu chargé.
	 
	 <p>Pour plus d’informations, voir le chapitre « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Objet chargé associé à cet objet LoaderInfo. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:contentType:get"><apiName>contentType</apiName><shortdesc>
	 Type MIME du fichier chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Type MIME du fichier chargé. Le paramètre est défini sur <codeph>null</codeph> si le pourcentage chargé du fichier est insuffisant pour déterminer le type. La liste suivante répertorie les valeurs gérées :
	 
	 <ul>
	 	
	 	<li><codeph>"application/x-shockwave-flash"</codeph></li>
	 
	 	<li><codeph>"image/jpeg"</codeph></li>
	 
	 	<li><codeph>"image/gif"</codeph></li>
	 
	 	<li><codeph>"image/png"</codeph></li>
	 
	 </ul>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 Cadence d’images nominale, en images par seconde, du fichier SWF chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Si le fichier n’est pas un fichier SWF. 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Cadence d’images nominale, en images par seconde, du fichier SWF chargé. Cette valeur correspond souvent, mais pas nécessairement, à un entier.
	 
	 <p>Elle peut être différente de la cadence d’images utilisée. Flash Player ou Adobe AIR utilise la même cadence d’images pour tous les fichiers SWF chargés. Cette valeur est déterminée par la cadence d’images nominale du fichier SWF principal. De même, la cadence d’images principale risque de ne pas pouvoir être atteinte, selon le matériel, la synchronisation du son, et d’autres facteurs.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:height:get"><apiName>height</apiName><shortdesc>
	 Hauteur nominale du fichier chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Hauteur nominale du fichier chargé. Elle peut être différente de la hauteur réelle du contenu affiché, car le contenu chargé ou ses objets d’affichage parent risquent d’avoir été redimensionnés.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loader:get"><apiName>loader</apiName><shortdesc>
	 Objet Loader associé à cet objet LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Loader</apiValueClassifier><apiException><apiDesc>Si l’objet qui accède à cette API ne peut pas accéder à l’objet Loader en raison de restrictions de sécurité. Ce cas de figure se produit par exemple lorsqu’un fichier SWF chargé tente d’accéder à sa propriété <codeph>loaderInfo.loader</codeph> et n’est pas autorisé à accéder au fichier SWF en cours de chargement.
	 
	 <p>Pour plus d’informations, voir le chapitre « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Objet Loader associé à cet objet LoaderInfo. Si cet objet LoaderInfo figure dans la propriété <codeph>loaderInfo</codeph> de l’occurrence de la classe principale du fichier SWF, il n’est associé à aucun objet Loader.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loaderURL:get"><apiName>loaderURL</apiName><shortdesc>
	 URL du fichier SWF qui a initié le chargement du média décrit par l’objet LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 URL du fichier SWF qui a initié le chargement du média décrit par l’objet LoaderInfo. Pour l’occurrence de la classe principale du fichier SWF, cette URL correspond à l’URL du fichier SWF.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parameters:get"><apiName>parameters</apiName><shortdesc>
	 Objet contenant des paires nom-valeur qui représentent les paramètres fournis au fichier SWF chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Objet contenant des paires nom-valeur qui représentent les paramètres fournis au fichier SWF chargé.
	 
	 <p>L’utilisation d’une boucle <codeph>for-in</codeph> vous permet d’extraire tous les noms et toutes les valeurs de l’objet <codeph>parameters</codeph>.</p>
	 
	 <p>Les deux sources de paramètres sont : la chaîne de requête que contient l’URL du fichier SWF principal et la valeur du paramètre HTML <codeph>FlashVars</codeph> (qui n’affecte que le fichier SWF principal).</p>
	 
	 <p>La propriété <codeph>parameters</codeph> remplace la technique ActionScript 1.0 et 2.0 qui consistait à utiliser des paramètres de fichier SWF en tant que propriétés du scénario principal.</p>
	 
	 <p>La valeur de la propriété <codeph>parameters</codeph> est null pour les objets Loader qui contiennent des fichiers SWF qui utilisent ActionScript 1.0 ou 2.0. Elle est différente de null pour les objets Loader qui contiennent des fichiers SWF ayant recours à ActionScript 3.0.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentAllowsChild:get"><apiName>parentAllowsChild</apiName><shortdesc>
	 Exprime la relation de confiance qui lie l’objet Loader (le parent) au contenu (l’enfant).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Exception renvoyée si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Exprime la relation de confiance qui lie l’objet Loader (le parent) au contenu (l’enfant). Renvoie <codeph>true</codeph> si le parent a autorisé l’accès de l’enfant, <codeph>false</codeph> dans le cas contraire. Cette propriété est définie sur <codeph>true</codeph> si l’objet parent a appelé la méthode <codeph>allowDomain()</codeph> pour accorder une autorisation d’accès au domaine enfant, ou si un fichier de régulation d’URL chargé dans le domaine parent accorde une autorisation d’accès au domaine enfant. Si l’enfant et le parent appartiennent au même domaine, cette propriété est réglée sur <codeph>true</codeph>.
	 
	 <p>Pour plus d’informations, voir le chapitre « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentSandboxBridge:get"><apiName>parentSandboxBridge</apiName><shortdesc>
	 Un objet qui peut être défini par le code dans le sandbox de l’objet Loader pour exposer les propriétés et les méthodes auxquelles le code du contenu chargé peut accéder.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Seul le contenu dans le sandbox de l’objet Loader peut définir cette propriété.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Un objet qui peut être défini par le code dans le sandbox de l’objet Loader pour exposer les propriétés et les méthodes auxquelles le code du contenu chargé peut accéder. Ce <i>pont de sandbox</i>permet au contenu d’un domaine qui n’est pas un domaine d’application de bénéficier d’un accès contrôlé aux scripts dans le sandbox de l’application AIR, et vice-versa. Le pont de sandbox sert de passerelle entre les sandboxes, fournissant une interaction explicite entre les sandboxes de sécurité de l’application et les autres. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/childSandboxBridge"><linktext>childSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:sameDomain:get"><apiName>sameDomain</apiName><shortdesc>
	 Exprime la relation entre les domaines de l’objet loader et du contenu : true s’ils proviennent du même domaine ; false dans tous les autres cas.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Exception renvoyée si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Exprime la relation entre les domaines de l’objet loader et du contenu : <codeph>true</codeph> s’ils proviennent du même domaine ; <codeph>false</codeph> dans tous les autres cas.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:sharedEvents:get"><apiName>sharedEvents</apiName><shortdesc>
	 Occurrence de EventDispatcher permettant d’échanger des événements hors des limites de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.events:EventDispatcher</apiValueClassifier></apiValueDef><apiDesc>
	 Occurrence de EventDispatcher permettant d’échanger des événements hors des limites de sécurité. Même lorsque l’objet Loader et le contenu chargé proviennent de domaines de sécurité qui ne s’approuvent pas, ils peuvent accéder à <codeph>sharedEvents</codeph> ainsi qu’envoyer et recevoir des événements via cet objet.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:swfVersion:get"><apiName>swfVersion</apiName><shortdesc>
	 Version du format du fichier SWF chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Si le fichier n’est pas un fichier SWF.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Version du format du fichier SWF chargé. Le format du fichier est spécifié par le biais des énumérations de la classe SWFVersion, telles que <codeph>SWFVersion.FLASH7</codeph> et <codeph>SWFVersion.FLASH9</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SWFVersion"><linktext>flash.display.SWFVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:url:get"><apiName>url</apiName><shortdesc>
	 URL du média en cours de chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 URL du média en cours de chargement.
	 
	 <p>Avant la distribution du premier événement <codeph>progress</codeph> par l’objet Loader correspondant associé à cet objet LoaderInfo, la valeur de la propriété <codeph>url</codeph> risque de ne refléter que l’URL initiale spécifiée par l’appel de la méthode <codeph>load()</codeph> de l’objet Loader. Après la distribution du premier événement <codeph>progress</codeph>, la propriété <codeph>url</codeph> reflète l’URL finale du média, suite à la résolution de toute redirection et URL relative.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:width:get"><apiName>width</apiName><shortdesc>
	 Largeur nominale du contenu chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Si le pourcentage téléchargé du fichier n’est pas suffisant pour extraire les informations requises.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Largeur nominale du contenu chargé. Elle peut être différente de la largeur réelle du contenu affiché, car le contenu chargé ou ses objets d’affichage parent risquent d’avoir été redimensionnés.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageQuality"><apiName>StageQuality</apiName><shortdesc>
La classe StageQuality fournit les valeurs de la propriété Stage.quality.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe StageQuality fournit les valeurs de la propriété <codeph>Stage.quality</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/quality"><linktext>flash.display.Stage.quality</linktext></link></related-links><apiValue id="flash.display:StageQuality:BEST"><apiName>BEST</apiName><shortdesc>
Spécifie la meilleure qualité de rendu possible : les graphiques sont anti-aliasés selon une grille de 4 x 4 pixels et les bitmaps sont toujours lissés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>best</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie la meilleure qualité de rendu possible : les graphiques sont anti-aliasés selon une grille de 4 x 4 pixels et les bitmaps sont toujours lissés.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
Spécifie la qualité de rendu supérieure : les graphiques sont anti-aliasés en appliquant une grille de 4 x 4 pixels et les bitmaps sont lissées lorsque l’animation est statique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>high</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie la qualité de rendu supérieure : les graphiques sont anti-aliasés en appliquant une grille de 4 x 4 pixels et les bitmaps sont lissées lorsque l’animation est statique. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:LOW"><apiName>LOW</apiName><shortdesc>
Spécifie la qualité de rendu inférieure : les images ne sont pas anti-aliasées et les bitmaps ne sont pas lissées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>low</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie la qualité de rendu inférieure : les images ne sont pas anti-aliasées et les bitmaps ne sont pas lissées. Ce paramètre n’est pas pris en charge dans Adobe AIR.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
Spécifie la qualité de rendu intermédiaire : les images sont anti-aliasées selon une grille de 2 x 2 pixels, mais les bitmaps ne sont pas lissées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>medium</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie la qualité de rendu intermédiaire : les images sont anti-aliasées selon une grille de 2 x 2 pixels, mais les bitmaps ne sont pas lissées. Ce niveau de qualité convient aux animations qui ne contiennent pas de texte. Ce paramètre n’est pas pris en charge dans Adobe AIR.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 La classe BitmapData vous permet d’utiliser les données (pixels) de l’image bitmap d’un objet Bitmap. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Permet de manipuler les données bitmap d’un objet Bitmap.
 
 </apiTipText></apiTipTexts><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe BitmapData vous permet d’utiliser les données (pixels) <ph platform="actionscript">d’une image bitmap</ph><ph platform="javascript">d’un objet Bitmap</ph>. Les méthodes de cette classe vous permettent de créer des images bitmap transparentes ou opaques dimensionnées de manière arbitraire et de les manipuler à votre guise lors de l’exécution. <ph platform="actionscript">Vous pouvez également accéder aux objets BitmapData pour une image bitmap chargée avec la classe <codeph>flash.display.Loader</codeph>.</ph> 
 
 <p platform="actionscript">Cette classe vous permet de séparer les opérations de rendu de bitmap dans les routines de mise à jour de l’affichage interne de Flash Player. En manipulant un objet BitmapData directement, vous pouvez créer des images complexes sans utiliser de temps système supplémentaire par image résultant du retraçage constant du contenu des données vectorielles.</p>
 
 <p platform="actionscript">Les méthodes de la classe BitmapData prennent en charge les effets qui ne sont pas disponibles par le biais des filtres associés aux objets d’affichage non bitmap.</p>
 
 <p>Un objet BitmapData contient un tableau de données de pixels. Ces données peuvent représenter une image bitmap entièrement opaque ou entièrement transparente contenant des données de canal alpha. Chaque type d’objet BitmapData est stocké en tant que tampon converti en entiers 32 bits. Chaque entier 32 bits détermine les propriétés d’un pixel unique de l’image bitmap.</p>
 
 <p>Chaque entier 32 bits est une combinaison de quatre valeurs de canal de 8 bits (de 0 à 255) décrivant les valeurs de transparence alpha et les valeurs de rouge, vert et bleu (ARVB) du pixel (pour les valeurs ARVB, l’octet le plus significatif représente la valeur du canal alpha, suivie de rouge, vert et bleu).</p>
 
 <p>Les quatre canaux (alpha, rouge, vert et bleu) sont représentés sous forme de nombres lorsque vous les utilisez avec la méthode <codeph>BitmapData.copyChannel()</codeph> ou les propriétés <codeph>DisplacementMapFilter.componentX</codeph> et <codeph>DisplacementMapFilter.componentY</codeph>. Ces nombres sont en retour représentés par les constantes suivantes dans la classe BitmapDataChannel :</p>
 
 <ul>
 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
  <li><codeph>BitmapDataChannel.RED</codeph></li>
 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
</ul>
 
 <p platform="actionscript">Vous pouvez associer des objets BitmapData à un objet Bitmap à l’aide de la propriété <codeph>bitmapData</codeph> de l’objet Bitmap.</p>
 
 <p platform="actionscript">Vous pouvez utiliser un objet BitmapData pour remplir un objet Graphics à l’aide de la méthode <codeph>Graphics.beginBitmapFill()</codeph>.</p>
 
 <p>Dans le moteur d’exécution AIR, les classes DockIcon, Icon, InteractiveIcon et SystemTrayIcon comprennent chacune une propriété <codeph>bitmaps</codeph> qui est un tableau d’objets BitmapData qui définissent les images bitmap pour une icône.</p>
 
 <p>Dans AIR 1.5 et Flash Player 10, la taille maximale d’un objet BitmapData est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’un objet BitmapData est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large.</p>
 
 <p>Les appels de toute méthode ou propriété d’un objet BitmapData renvoient une erreur ArgumentError si l’objet BitmapData n’est pas valide (si <codeph>height == 0</codeph> et <codeph>width == 0</codeph>, par exemple) ou s’il a été éliminé par le biais de dispose(). </p>
 
 </apiDesc><example conref="examples\BitmapDataExample.as"> L’exemple suivant utilise la classe BitmapDataExample pour charger le fichier Image.gif dans DisplayObject à l’emplacement par défaut (0, 0). Une copie d’Image.gif est ensuite placée à droite de l’original, qui applique de nouvelles couleurs aux pixels qui répondent aux critères définis par la méthode <codeph>threshold()</codeph>. La tâche s’accomplit de la façon suivante :
 <ol>
     <li>Une propriété <codeph>url</codeph> est créée pour désigner l’emplacement et le nom du fichier d’image.</li>
     <li>Le constructeur de classe crée un objet Loader, qui crée à son tour un écouteur d’événements, qui est transmis lorsque la méthode <codeph>completeHandler()</codeph> termine la manipulation de l’image.</li>
        <li>Le paramètre <codeph>request</codeph> de l’objet URLRequest est ensuite transmise à <codeph>loader.load()</codeph>, qui charge l’image en mémoire à l’aide d’un objet d’affichage.</li>
     <li>L’image est ensuite placée dans la liste d’affichage, qui affiche l’image aux coordonnées <i>x = 0, y = 0</i>.</li>
     <li>La méthode <codeph>completeHandler()</codeph> effectue ensuite les opérations suivantes : 
     <ul>
         <li>Crée un deuxième objet Loader, ainsi qu’un objet Bitmap, qui est initialisé avec l’objet Loader.</li>
         <li>Crée un deuxième objet Bitmap, <codeph>duplicate</codeph>, qui appelle en retour la méthode <codeph>duplicateImage()</codeph>, qui crée elle-même un double de l’image d’origine. </li>
         <li>Crée un objet BitmapData qui est associé à l’objet BitmapData de l’objet <codeph>duplicate</codeph>.</li>
         <li>Crée un objet Rectangle qui est initialisé avec les mêmes coordonnées, la même largeur et hauteur, que l’image d’origine.</li>
         <li>Crée un objet Point, qui emploie par défaut les coordonnées <i>x = 0, y = 0</i>.</li>
         <li>Crée les variables suivantes :
         <ul>
             <li><codeph>operation</codeph> — Applique la nouvelle couleur lorsque la valeur de seuil est supérieure ou égale à l’original.</li>
             <li><codeph>threshold</codeph> — La valeur de chaque pixel est comparée (dans cet exemple, gris clair avec une valeur alpha de 0xCC). </li>
             <li><codeph>color</codeph> — La couleur des pixels qui répondent aux critères imposés, soit jaune uni dans ce cas.</li>
             <li><codeph>mask</codeph> — Le contraire exact de la couleur (bleu transparent).</li>
             <li><codeph>copySource</codeph> — Défini sur <codeph>false</codeph>, indique que les valeurs des pixels ne sont pas copiées si les critères de la valeur de seuil ne sont pas réunis. Cette valeur n’a aucune signification, car l’image est dupliquée et seuls les pixels qui répondent aux critères de seuil sont modifiés.</li>
      </ul></li>
         <li>Appelle la méthode <codeph>threshold()</codeph> à l’aide des variables précédentes. L’équation de seuil qui en résulte figure ci-dessous : <codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>. </li>
  </ul></li>
 </ol>
 <p> <b>Remarques :</b>
 <ul>
     <li>Vous devrez compiler le fichier SWF en définissant Sécurité de lecture locale sur Accès aux fichiers locaux uniquement.
 </li>
     <li>Pour exécuter cet exemple, il est nécessaire de placer un fichier intitulé Image.txt dans le même répertoire que votre fichier SWF.
 </li>
  <li>Il est recommandé d’utiliser une image qui ne dépasse pas 80 pixels de largeur. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example><example conref="examples\BitmapDataExample2.as"/></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/bitmapData"><linktext>flash.display.Bitmap.bitmapData</linktext></link><link href="flash.desktop.xml#DockIcon/bitmaps"><linktext>flash.desktop.DockIcon.bitmaps</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.desktop.xml#Icon/bitmaps"><linktext>flash.desktop.Icon.bitmaps</linktext></link><link href="flash.desktop.xml#InteractiveIcon/bitmaps"><linktext>flash.desktop.InteractiveIcon.bitmaps</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.desktop.xml#SystemTrayIcon/bitmaps"><linktext>flash.desktop.SystemTrayIcon.bitmaps</linktext></link></related-links><apiConstructor id="flash.display:BitmapData:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 	 Crée un objet BitmapData à la largeur et la hauteur spécifiées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>La largeur et/ou la hauteur dépassent les dimensions maximales.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Largeur de l’image bitmap en pixels.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>La hauteur de l’image bitmap en pixels.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>transparent</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Spécifie si l’image bitmap prend en charge la transparence par pixel. La valeur par défaut est <codeph>true</codeph> (transparent). Pour créer une image bitmap entièrement transparente, réglez la valeur du paramètre <codeph>transparent</codeph> sur <codeph>true</codeph> et celle du paramètre <codeph>fillColor</codeph> sur 0x00000000 (ou sur 0). Le réglage de la propriété <codeph>transparent</codeph> sur <codeph>false</codeph> peut entraîner une légère amélioration des performances de rendu. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>Valeur de couleur ARVB 32 bits utilisée pour remplir la zone de l’image bitmap. La valeur par défaut est 0xFFFFFFFF (blanc uni).
	 
 	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Crée un objet BitmapData à la largeur et la hauteur spécifiées. Si vous spécifiez une valeur pour le paramètre <codeph>fillColor</codeph>, chaque pixel de l’image bitmap est défini sur cette couleur.
	 
	 <p>Par défaut, l’image bitmap créée est transparente, sauf si vous transmettez la valeur <codeph>false</codeph> au paramètre <codeph>transparent</codeph>. Une fois l’image bitmap opaque créée, vous ne pouvez pas la transformer en bitmap transparente. Chaque pixel d’une image bitmap opaque utilise uniquement 24 bits d’informations du canal de couleur. Si vous réglez l’image bitmap sur transparent, chaque pixel utilise 32 bits d’informations de canal de couleur, y compris un canal de transparence alpha.</p>
	 
	 <p>Dans AIR 1.5 et Flash Player 10, la taille maximale d’un objet BitmapData est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’un objet BitmapData est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Si vous spécifiez une valeur de largeur ou de hauteur supérieure à 2880, la nouvelle occurrence n’est pas créée.</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:BitmapData:applyFilter"><apiName>applyFilter</apiName><shortdesc>
	 Prend une image source et un objet filtre et génère l’image filtrée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres sourceBitmapData, sourceRect, destPoint ou filter sont réglés sur la valeur null.
 	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>La transparence des objets BitmapData n’est pas compatible avec l’opération de filtrage.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre indiquant si l’application du filtre a abouti. Si 0 est renvoyé, l’application du filtre a abouti. Si un nombre négatif est renvoyé, une erreur s’est produite lors de l’application du filtre.
	 
	 </apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>L’image bitmap d’entrée à utiliser. L’image source peut être un autre objet BitmapData ou faire référence à l’occurrence de BitmapData actuelle.

	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle qui définit la zone de l’image source à utiliser en tant qu’entrée.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point de l’image de destination (l’occurrence de BitmapData actuelle) correspondant au coin supérieur gauche du rectangle source.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>Objet filtre utilisé pour effectuer l’opération de filtrage. Chaque type de filtre dispose d’exigences spécifiques, comme suit :
	 
	 <ul><li><b>BlurFilter</b> - Ce filtre peut utiliser les images source et de destination opaques ou transparentes. Si les formats des images sont différents, la copie de l’image source effectuée lors du filtrage correspond au format de l’image de destination.</li>
	 
	 <li><b>BevelFilter, DropShadowFilter, GlowFilter, ChromeFilter</b> - L’image de destination de ces filtres doit être transparente. L’appel de DropShadowFilter ou de GlowFilter permet de créer une image contenant les données de canal alpha de l’ombre portée ou du rayonnement. Il ne permet pas de créer l’ombre portée sur l’image de destination. Si vous utilisez l’un de ces filtres sur une image de destination opaque, une exception est renvoyée.</li>
	 
	 <li><b>ConvolutionFilter</b> - Ce filtre peut utiliser les images source et de destination opaques ou transparentes.</li>
	 
	 <li><b>ColorMatrixFilter</b> - Ce filtre peut utiliser les images source et de destination opaques ou transparentes.</li>
	 
	 <li><b>DisplacementMapFilter</b> - Ce filtre peut utiliser les images source et de destination opaques ou transparentes à condition que leurs formats soient identiques.</li></ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Prend une image source et un objet filtre et génère l’image filtrée.
	 
	 <p>Cette méthode repose sur le comportement des objets filtres intégrés, qui déterminent le rectangle de destination affecté par un rectangle source d’entrée.</p>
	 
	 <p>Une fois le filtre appliqué, la taille de l’image obtenue peut être supérieure à celle de l’image d’entrée. Par exemple, si vous utilisez une classe BlurFilter pour rendre flou un rectangle source de (50,50,100,100) et un point de destination de (10,10), la zone modifiée sur l’image de destination est supérieure à (10,10,60,60) en raison du flou. Cela se produit en interne au cours de l’appel <codeph>applyFilter()</codeph>.</p>
	 
	 <p>Si le paramètre <codeph>sourceRect</codeph> du paramètre <codeph>sourceBitmapData</codeph> est une zone intérieure, telle que (50,50,100,100) sur une image 200 x 200, le filtre utilise les pixels source hors du paramètre <codeph>sourceRect</codeph> pour générer le rectangle de destination.</p>
	 
	 <p>Si l’objet BitmapData et l’objet spécifié en tant que paramètre <codeph>sourceBitmapData</codeph> sont identiques, l’application utilise une copie temporaire de l’objet pour effectuer le filtrage. Pour optimiser les performances, évitez ce cas de figure.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.applyFilter.1.as"> L’exemple suivant indique comment appliquer un filtre de flou à une occurrence BitmapData :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>flash.filters.BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>flash.filters.BlurFilter</linktext></link><link href="flash.filters.xml#ColorMatrixFilter"><linktext>flash.filters.ColorMatrixFilter</linktext></link><link href="flash.filters.xml#ConvolutionFilter"><linktext>flash.filters.ConvolutionFilter</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>flash.filters.DropShadowFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>flash.filters.GlowFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:clone"><apiName>clone</apiName><shortdesc>
	 Renvoie un nouvel objet BitmapData, clone de l’occurrence d’origine avec une copie exacte de l’image bitmap contenue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet BitmapData identique à l’original.
	 
	 </apiDesc><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie un nouvel objet BitmapData avec une copie exacte de l’image bitmap originale.

	  

	  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie un nouvel objet BitmapData, clone de l’occurrence d’origine avec une copie exacte de l’image bitmap contenue.
	 
	 </apiDesc><example conref="examples\BitmapData.clone.1.as"> L’exemple suivant indique comment cloner une occurrence BitmapData. Elle indique également que lorsque vous modifiez l’occurrence BitmapData clonée, l’original reste tel quel :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:colorTransform"><apiName>colorTransform</apiName><shortdesc>
	 Définit les valeurs de couleur dans une zone spécifiée d’une image bitmap avec un objet ColorTransform.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre rect ou colorTransform est défini sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Objet Rectangle qui définit la zone de l’image dans laquelle l’objet ColorTransform est appliqué.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>Objet ColorTransform décrivant les valeurs de transformation de couleur à appliquer.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les valeurs de couleur dans une zone spécifiée d’une image bitmap en utilisant un objet <codeph>ColorTransform</codeph>. Si le rectangle correspond aux limites de l’image bitmap, cette méthode transforme les valeurs de couleur de l’image tout entière.
	 
	 </apiDesc><example conref="examples\BitmapData.colorTransform.1.as"> L’exemple suivant indique comment appliquer une transformation de couleur à la partie gauche (rectangle) d’un objet BitmapData :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:compare"><apiName>compare</apiName><shortdesc>
	 
	 Compare deux objets BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre otherBitmapData est défini sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>S’ils ont tous deux les mêmes dimensions (largeur et hauteur), la méthode renvoie un nouvel objet BitmapData, qui reprend la différence entre les deux objets (voir la discussion principale). Si les objets BitmapData sont équivalents, la méthode renvoie la valeur 0. Si les largeurs des objets BitmapData ne sont pas identiques, la méthode renvoie la valeur -3. Si les hauteurs des objets BitmapData ne sont pas identiques, la méthode renvoie la valeur -4. 
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>otherBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Objet BitmapData à comparer à l’objet BitmapData source.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Compare deux objets BitmapData. S’ils ont tous deux les mêmes dimensions (largeur et hauteur), la méthode renvoie un nouvel objet BitmapData, dans lequel chaque pixel correspond à la « différence » entre les pixels des deux objets source :
	 
	 <ul>
	 
	 	<li>Si deux pixels sont équivalents, le pixel de différence est 0x00000000. </li>
	 
	 	<li>Si deux pixels ont des valeurs RVB différentes (en dehors de la valeur alpha), le pixel de différence est 0xRRGGBB où RR/GG/BB sont les valeurs de différences individuelles entre les canaux rouge, vert et bleu (la valeur du pixel dans l’objet source moins la valeur du pixel dans l’objet <codeph>otherBitmapData</codeph>). Les différences relatives au canal alpha ne sont pas prises en compte dans ce cas. </li> 
	 
	 	<li>Si seule la valeur du canal alpha diffère, la valeur du pixel est 0x<i>ZZ</i>FFFFFF, où <i>ZZ</i> est la différence entre les valeurs alpha (la valeur alpha dans l’objet source moins la valeur alpha dans l’objet <codeph>otherBitmapData</codeph>). </li>
	 
	 </ul>
	 
	 <p>Prenons l’exemple des deux objets BitmapData suivants :</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
     </codeblock>
	 
	 <p><b>Remarque :</b> les couleurs utilisées pour remplir les deux objets BitmapData ont des valeurs RVB légèrement différentes (0xFF0000 et 0xFFAA00). L’utilisation de la méthode <codeph>compare()</codeph> entraîne la création d’un objet BitmapData dont chaque pixel indique la différence entre les valeurs RVB des deux bitmaps.</p>
	 
	 <p>Prenez l’exemple des deux objets BitmapData suivants, dans lesquels les couleurs RVB sont identiques, mais les valeurs alpha sont différentes :</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
	 </codeblock>
	 
	 <p>L’utilisation de la méthode <codeph>compare()</codeph> entraîne la création d’un objet BitmapData dont chaque pixel indique la différence entre les valeurs alpha des deux bitmaps.</p>
	 
	 <p>Si les objets BitmapData sont équivalents (largeur, hauteur et valeurs de pixels identiques), la méthode renvoie la valeur 0.</p>
	 
	 <p>Si les largeurs des objets BitmapData ne sont pas identiques, la méthode renvoie la valeur -3. </p>
	 
	 <p>Si les hauteurs des objets BitmapData ne sont pas identiques, mais que les largeurs sont les mêmes, la méthode renvoie la valeur -4.</p>
	 
	 <p>L’exemple suivant compare deux objets Bitmap de différentes largeurs (50 et 60) :</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 </apiDesc><example conref="examples\BitmapData.compare.1.as"> L’exemple suivant affiche la valeur d’un pixel dans l’objet BitmapData qui résulte de la comparaison entre deux objets BitmapData de mêmes dimensions :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:copyChannel"><apiName>copyChannel</apiName><shortdesc>
	 Transfère les données du canal d’un autre objet BitmapData ou de l’objet BitmapData actuel vers un canal de l’objet BitmapData actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres sourceBitmapData, sourceRect ou destPoint sont définis sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>L’image bitmap d’entrée à utiliser. L’image source peut être un objet BitmapData différent ou peut faire référence à l’objet BitmapData actuel.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Objet Rectangle source. Pour copier uniquement les données de canal à partir d’une zone de taille inférieure sur l’image bitmap, spécifiez un rectangle source dont la taille est inférieure à la taille globale de l’objet BitmapData. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Objet Point de destination qui représente le coin supérieur gauche de la zone rectangulaire dans laquelle les nouvelles données de canal sont placées. Pour copier uniquement les données de canal d’une zone vers une autre sur l’image de destination, spécifiez un point autre que (0,0).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Canal source. Utilisez une valeur provenant de la classe BitmapDataChannel (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Canal de destination. Utilisez une valeur provenant de la classe BitmapDataChannel (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Transfère les données du canal d’un autre objet BitmapData ou de l’objet BitmapData actuel vers un canal de l’objet BitmapData actuel. Toutes les données contenues dans les autres canaux de l’objet BitmapData de destination sont préservées.
	 
	 <p>La valeur du canal source et de destination peut être l’une des valeurs suivantes : </p>
	 <ul>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 </ul>

	 
	 </apiDesc><example conref="examples\BitmapData.copyChannel.1.as"> L’exemple suivant indique comment copier le canal rouge dans un objet BitmapData, dans son propre canal bleu, dans une zone de 20 x 20 pixels :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:copyPixels"><apiName>copyPixels</apiName><shortdesc>
	 Met en place une routine rapide permettant de manipuler les pixels de différentes images sans effets d’étirement, de rotation ou de couleur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres sourceBitmapData, sourceRect et destPoint sont définis sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Image bitmap d’entrée à partir de laquelle les pixels sont copiés. L’image source peut être une occurrence de BitmapData différente ou peut faire référence à l’occurrence de BitmapData actuelle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle qui définit la zone de l’image source à utiliser en tant qu’entrée.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point de destination représentant le coin supérieur gauche de la zone rectangulaire dans laquelle les nouveaux pixels sont placés.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Source de l’objet BitmapData alpha secondaire.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Point, sur l’objet BitmapData alpha, correspondant au coin supérieur gauche du paramètre <codeph>sourceRect</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mergeAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Pour utiliser le canal alpha, définissez la valeur sur <codeph>true</codeph>. Pour copier des pixels sans canal alpha, définissez la valeur sur <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Met en place une routine rapide permettant de manipuler les pixels de différentes images sans effets d’étirement, de rotation ou de couleur. Cette méthode copie une zone rectangulaire d’une image source dans une zone rectangulaire de taille identique au point de destination de l’objet BitmapData de destination.
	 
	 <p>Si vous incluez les paramètres <codeph>alphaBitmap</codeph> et <codeph>alphaPoint</codeph>, vous pouvez utiliser une image secondaire en tant que source alpha pour l’image source. Si l’image source contient des données alpha, les deux ensembles de données alpha sont utilisés pour composer des pixels de l’image source vers l’image de destination. Le paramètre <codeph>alphaPoint</codeph> est le point, sur l’image alpha, correspondant au coin supérieur gauche du rectangle source. Aucun pixel situé hors de l’intersection de l’image source et de l’image alpha n’est copié sur l’image de destination.</p>
	 
	 <p>La propriété <codeph>mergeAlpha</codeph> contrôle si le canal alpha est utilisé ou non lorsqu’une image transparente est copiée sur une autre image transparente. Pour copier des pixels avec les données du canal alpha, définissez la propriété <codeph>mergeAlpha</codeph> sur <codeph>true</codeph> . Par défaut, la propriété <codeph>mergeAlpha</codeph> est définie sur <codeph>false</codeph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.copyPixels.1.as"> L’exemple suivant indique comment copier des pixels à partir d’une zone de 20 x 20 pixels d’un objet BitmapData vers un autre objet BitmapData :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:dispose"><apiName>dispose</apiName><shortdesc>
	 Libère la mémoire utilisée pour stocker l’objet BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Libère la mémoire utilisée pour stocker l’objet BitmapData. 
	 
	 <p>Lorsque la méthode <codeph>dispose()</codeph> est appelée sur une image, la largeur et la hauteur de celle-ci sont définies sur 0. Tous les appels ultérieurs des méthodes ou des propriétés de cette occurrence de BitmapData échouent et une exception est renvoyée. </p>
	 <p><codeph>BitmapData.dispose()</codeph> libère immédiatement la mémoire occupée par les données bitmap actuelles (une image bitmap peut consommer jusqu’à 64 Mo de mémoire). Après avoir utilisé <codeph>BitmapData.dispose()</codeph>, l’objet BitmapData n’est plus utilisable et le moteur d’exécution de Flash renvoie une exception si vous appelez des fonctions sur l’objet BitmapData. Toutefois, <codeph>BitmapData.dispose()</codeph> ne nettoie pas l’objet BitmapData (environ 128 octets) ; la mémoire occupée par l’objet BitmapData actuel est libérée lorsque le nettoyeur de mémoire collecte l’objet BitmapData. </p>
	 
	 </apiDesc><example conref="examples\BitmapData.dispose.1.as"> L’exemple suivant illustre l’effet de l’appel d’une méthode d’objet BitmapData consécutif à l’appel de la méthode <codeph>dispose()</codeph> (une exception est renvoyée) :
<codeblock>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.system.xml#System/gc()"><linktext>flash.system.System.gc()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:draw"><apiName>draw</apiName><shortdesc>
	 Dessine l’objet d’affichage source sur l’image bitmap avec la fonctionnalité de rendu vectoriel de Flash Player ou AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre <codeph>source</codeph> n’est pas un objet BitmapData ou DisplayObject.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>L’objet <codeph>source</codeph> et (dans le cas d’un objet Sprite ou MovieClip) tous les objets enfant correspondants ne proviennent pas du même domaine que l’appelant, ou ne résident pas dans un contenu auquel ce dernier peut accéder par le biais de la méthode <codeph>Security.allowDomain()</codeph>. Cette restriction ne s’applique pas au contenu AIR dans le sandbox de sécurité de l’application.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>La source est réglée sur null ou n’est pas un objet IBitmapDrawable valide.
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>flash.display:IBitmapDrawable</apiOperationClassifier><apiDesc>Objet d’affichage ou objet BitmapData à dessiner sur l’objet BitmapData (les classes DisplayObject et BitmapData mettent en œuvre l’interface IBitmapDrawable).
	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet Matrix utilisé pour redimensionner, faire pivoter ou traduire les coordonnées de l’image bitmap. Si vous ne souhaitez pas appliquer une matrice de transformation à l’image, réglez ce paramètre sur une matrice d’identité, créée à l’aide du constructeur <codeph>new Matrix()</codeph> par défaut, ou transmettez une valeur <codeph>null</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet ColorTransform utilisé pour définir les valeurs de couleur de l’image bitmap. Si aucun objet n’est fourni, les couleurs de l’image bitmap ne sont pas transformées. Si ce paramètre doit être transmis, alors que vous ne souhaitez pas transformer l’image, réglez-le sur un objet ColorTransform créé à l’aide du constructeur <codeph>new ColorTransform()</codeph> par défaut.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>blendMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Chaîne extraite de la classe flash.display.BlendMode, qui spécifie le mode de fondu à appliquer à l’image bitmap générée par l’opération. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet Rectangle qui définit la zone de l’image source à dessiner. Si cette valeur n’est pas fournie, aucun découpage n’est effectué et l’objet source est dessiné dans sa totalité.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Une valeur booléenne qui détermine si l’objet BitmapData doit être lissé lors d’une mise à l’échelle ou d’une rotation demandée par le paramètre <codeph>matrix</codeph>. Le paramètre <codeph>smoothing</codeph> s’applique uniquement lorsque le paramètre <codeph>source</codeph> est un objet BitmapData. Lorsque le paramètre <codeph>smoothing</codeph> est défini sur <codeph>false</codeph>, l’image BitmapData pivotée ou mise à l’échelle peut sembler pixélisée ou irrégulière. Par exemple, les deux images suivantes utilisent le même objet BitmapData pour le paramètre <codeph>source</codeph>, mais le paramètre <codeph>smoothing</codeph> est défini sur <codeph>true</codeph> à gauche et sur <codeph>false</codeph> à droite :
	 
	 <p><adobeimage alt="Deux images : à gauche avec lissage et à droite sans lissage." href="../../images/bitmapData_draw_smoothing.jpg"/></p>
	 
	 <p>Le traçage d’une image bitmap avec le paramètre <codeph>smoothing</codeph> défini sur <codeph>true</codeph> prend plus de temps que lorsque <codeph>smoothing</codeph> est défini sur <codeph>false</codeph>.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Trace l’objet d’affichage <codeph>source</codeph> sur l’image bitmap avec la fonctionnalité de rendu vectoriel de <ph platform="actionscript">Flash Player ou </ph>AIR. Vous pouvez spécifier les paramètres <codeph>matrix</codeph>, <codeph>colorTransform</codeph>, <codeph>blendMode</codeph>, ainsi qu’un paramètre de destination <codeph>clipRect</codeph> pour contrôler l’exécution du rendu. Vous pouvez éventuellement indiquer si l’image bitmap doit être lissée lorsqu’elle est redimensionnée (cette opération ne fonctionne que si l’objet source est un objet BitmapData).
	  
	 <p>Cette méthode correspond directement au mode de traçage des objets à l’aide de la fonctionnalité de rendu vectoriel standard dans l’interface de l’outil de programmation.</p>
	 
	 <p>L’objet d’affichage source n’utilise pas les transformations appliquées pour cet appel. Il est traité de la manière dont il apparaît dans la bibliothèque ou dans le fichier, sans transformation de matrice, de couleurs et sans mode de fondu. Pour dessiner un objet d’affichage, tel qu’un clip, en utilisant ses propres propriétés de transformation, vous pouvez copier sa propriété <codeph>transform</codeph> dans la propriété <codeph>transform</codeph> de l’objet Bitmap qui utilise l’objet BitmapData.</p>
	 
     <p>Cette méthode est prise en charge sur RTMP dans <ph platform="actionscript">Flash Player 9.0.115.0 et versions ultérieures, et dans </ph>Adobe AIR. Vous pouvez contrôler l’accès aux flux sur un serveur FMS (Flash Media Server) dans un script coté serveur. Pour plus de détails, voir les propriétés <codeph>Client.audioSampleAccess</codeph> et <codeph>Client.videoSampleAccess</codeph> dans le <xref href="http://www.adobe.com/go/documentation_fr" scope="external"> <i>Guide de référence du langage ActionScript d’Adobe Flash Media Server côté serveur</i></xref>.</p>
	 
	 <p platform="actionscript">Si l’objet source et (dans le cas d’un objet Sprite ou MovieClip) tous les objets enfant correspondants ne proviennent pas du même domaine que l’appelant, ou ne résident pas dans un contenu auquel ce dernier peut accéder par le biais de la méthode <codeph>Security.allowDomain()</codeph>, un appel à la méthode <codeph>draw()</codeph> renvoie une exception SecurityError. Cette restriction ne s’applique pas au contenu AIR dans le sandbox de sécurité de l’application.</p>
	 
	 <p platform="actionscript">Il existe également des restrictions concernant l’utilisation d’une image bitmap chargée en tant que <codeph>source</codeph>. Un appel de la méthode <codeph>draw()</codeph> aboutit si l’image chargée provient du même domaine que l’appelant. Par ailleurs, un fichier de régulation interdomaine sur le serveur de l’image peut autoriser le domaine du contenu SWF qui appelle la méthode <codeph>draw()</codeph>. Le cas échéant, vous devez définir la propriété <codeph>checkPolicyFile</codeph> d’un objet LoaderContext, puis utiliser cet objet en tant que paramètre <codeph>context</codeph> lors de l’appel de la méthode <codeph>load()</codeph> de l’objet Loader utilisée pour charger l’image. Le contenu AIR du sandbox de sécurité de l’application n’est pas soumis à ces restrictions.</p>
	 
	 <p>Dans Windows, la méthode <codeph>draw()</codeph> ne peut pas capturer le contenu SWF incorporé dans une page HTML<ph platform="actionscript"> dans un objet HTMLLoader dans Adobe AIR</ph>.</p>
	 
	 <p>La méthode <codeph>draw()</codeph> ne peut pas capturer un contenu PDF<ph platform="actionscript"> dans Adobe AIR</ph>. Elle ne peut pas non plus capturer un contenu SWF intégré dans HTML dont l’attribut <codeph>wmode</codeph> est défini sur <codeph>"window"</codeph><ph platform="actionscript"> dans Adobe AIR</ph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.draw.1.as"> L’exemple suivant indique comment dessiner un objet TextField sur un objet BitmapData :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:fillRect"><apiName>fillRect</apiName><shortdesc>
	 Remplit une zone rectangulaire de pixels avec une couleur ARVB spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre rect est défini sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Zone rectangulaire à remplir.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur de couleur ARVB qui remplit la zone. Les couleurs ARVB sont souvent spécifiées au format hexadécimal, par exemple 0xFF336699.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Remplit une zone rectangulaire de pixels avec une couleur ARVB spécifiée.
	 
	 </apiDesc><example conref="examples\BitmapData.fillRect.1.as"> L’exemple suivant indique comment remplir une zone rectangulaire d’un objet BitmapData en bleu :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:floodFill"><apiName>floodFill</apiName><shortdesc>
	 Effectue une opération de peinture sur une image à partir de certaines coordonnées (x, y) et à l’aide d’une certaine couleur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> de l’image.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> de l’image.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Couleur ARVB à utiliser pour le remplissage.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Effectue une opération de peinture sur une image à partir de certaines coordonnées (x, y).
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Effectue une opération de peinture sur une image à partir de certaines coordonnées (<i>x</i>, <i>y</i>) et à l’aide d’une certaine couleur. La méthode <codeph>floodFill()</codeph> est similaire à l’outil Pot de peinture dans divers programmes de dessin. La couleur ARVB contient des informations alpha ainsi que des informations sur les couleurs.
	 
	 </apiDesc><example conref="examples\BitmapData.floodFill.1.as"> L’exemple suivant indique comment remplir la zone d’un objet BitmapData, c’est-à-dire la zone qui entoure le pixel défini par le point <codeph>(10, 10)</codeph> où toutes les couleurs correspondent à ce stade avec le rouge.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:generateFilterRect"><apiName>generateFilterRect</apiName><shortdesc>
	 Détermine le rectangle de destination affecté par l’appel de la méthode applyFilter(), en fonction d’un objet BitmapData, d’un rectangle source et d’un objet filtre spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre sourceRect ou filter est défini sur une valeur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Rectangle de destination dont les dimensions ont été calculées à l’aide d’une image, du paramètre <codeph>sourceRect</codeph> et d’un filtre.
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle définissant la zone de l’image source à utiliser en tant qu’entrée.
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>Objet filtre utilisé pour calculer les dimensions du rectangle de destination.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Détermine le rectangle de destination qui sera affecté par l’appel de applyFilter().
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Détermine le rectangle de destination affecté par l’appel de la méthode <codeph>applyFilter()</codeph>, en fonction d’un objet BitmapData, d’un rectangle source et d’un objet filtre spécifiés.
	 
	 <p>Par exemple, un filtre de flou affecte normalement une zone dont la taille est supérieure à celle de l’image d’origine. Une image de 100 x 200 pixels filtrée par une occurrence BlurFilter par défaut, où <codeph>blurX = blurY = 4</codeph> génère un rectangle de destination de <codeph>(-2,-2,104,204)</codeph>. La méthode <codeph>generateFilterRect()</codeph> permet de déterminer la taille de ce rectangle de destination à l’avance, de sorte que vous puissiez dimensionner l’image de destination en conséquence avant d’effectuer une opération de filtrage.</p>
	 
	 <p>Certains filtres découpent leur rectangle de destination selon la taille de l’image source. Par exemple, un filtre <codeph>DropShadow</codeph> interne ne génère pas de résultat de taille supérieure à celle de son image source. Dans cette interface API, l’objet BitmapData fait office de limites source et n’est pas utilisé en tant que paramètre <codeph>rect</codeph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.generateFilterRect.1.as"> L’exemple suivant indique comment utiliser la méthode <codeph>generateFilterRect()</codeph> pour déterminer la zone rectangulaire devant recevoir le résultat du filtre de flou. Les résultats de la méthode <codeph>generateFilterRect()</codeph> sont renvoyés par la fonction <codeph>trace()</codeph> :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock> Tenez compte du fait que la méthode <codeph>generateFilterRect()</codeph> ne s’applique pas au filtre. Appelez la méthode <codeph>applyFilter()</codeph> pour appliquer le filtre. 
</example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getColorBoundsRect"><apiName>getColorBoundsRect</apiName><shortdesc>
	 Détermine une zone rectangulaire qui regroupe entièrement tous les pixels d’une couleur spécifiée au sein de l’image bitmap (si le paramètre findColor est défini sur true) ou tous les pixels qui n’incluent pas la couleur spécifiée (si le paramètre findColor est défini sur false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Zone de l’image correspondant à la couleur spécifiée. 
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur hexadécimale qui spécifie les bits de la couleur ARVB à prendre en compte. La valeur de la couleur est combinée à cette valeur hexadécimale à l’aide de l’opérateur <codeph>&amp;</codeph> (AND au niveau du bit).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur hexadécimale qui spécifie la couleur ARVB à prendre en compte (si <codeph>findColor</codeph> est défini sur <codeph>true</codeph>) ou à ne <i>pas</i> prendre en compte (si <codeph>findColor</codeph> est défini sur <codeph>false</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>findColor</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Si la valeur est définie sur <codeph>true</codeph>, renvoie les limites d’une valeur de couleur dans une image. Si la valeur est définie sur <codeph>false</codeph>, renvoie les limites dans lesquelles cette couleur n’existe pas dans une image. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Détermine une zone rectangulaire qui regroupe entièrement tous les pixels d’une couleur spécifiée au sein de l’image bitmap (si le paramètre <codeph>findColor</codeph> est défini sur <codeph>true</codeph>) ou tous les pixels qui n’incluent pas la couleur spécifiée (si le paramètre <codeph>findColor</codeph> est défini sur <codeph>false</codeph>). 
	 
	 <p>Par exemple, si vous disposez d’une image source et souhaitez déterminer le rectangle de l’image qui contient un canal alpha différent de zéro, utilisez <codeph>{mask: 0xFF000000, color: 0x00000000}</codeph> en tant que paramètres. Si le paramètre <codeph>findColor</codeph> est défini sur <codeph>true</codeph>, les limites de pixels caractérisées par <codeph>(value &amp; mask) == color</codeph> (<codeph>value</codeph> correspondant à la valeur de la couleur du pixel) sont recherchées dans l’image entière. Si le paramètre <codeph>findColor</codeph> est défini sur <codeph>false</codeph>, la recherche des limites des pixels porte sur l’ensemble de l’image pour laquelle <codeph>(value &amp; mask) != color</codeph> (où <codeph>value</codeph> correspond à la valeur de couleur du pixel). Pour déterminer l’espace blanc entourant une image, transmettez <codeph>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</codeph> pour rechercher les limites des pixels qui ne sont pas blancs.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getColorBoundsRect.1.as"> L’exemple suivant crée un objet BitmapData comportant du rouge dans la partie supérieure de ses pixels. Il appelle ensuite la méthode <codeph>getColorBoundsRect()</codeph> pour déterminer le rectangle où les pixels sont rouges (0xFF0000), puis à nouveau la même méthode pour déterminer le rectangle où les pixels ne sont pas rouges (en définissant le paramètre <codeph>findColor</codeph> sur <codeph>false</codeph> :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getPixel"><apiName>getPixel</apiName><shortdesc>
	 Renvoie un entier représentant une valeur de pixels RVB à partir d’un objet BitmapData à un point spécifique (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nombre représentant une valeur de pixels RVB. Si les coordonnées (<i>x</i>, <i>y</i>) se trouvent à l’extérieur des limites de l’image, la méthode renvoie 0. 
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> du pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> du pixel.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie un entier représentant une valeur de pixels RVB à partir d’un objet BitmapData à un point spécifique.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie un entier représentant une valeur de pixels RVB à partir d’un objet BitmapData à un point spécifique (<i>x</i>, <i>y</i>). La méthode <codeph>getPixel()</codeph> renvoie une valeur de pixels non multipliée. Aucune information alpha n’est renvoyée.
	 
	 <p>Tous les pixels d’un objet BitmapData sont stockés en tant que valeurs de couleur prémultipliées. Les valeurs des canaux de couleur rouge, vert et bleu d’un pixel image prémultiplié sont déjà multipliées par les données alpha. Par exemple, si la valeur alpha est 0, les canaux RVB sont également définis sur 0, indépendamment de leurs valeurs non multipliées. Cette perte de données peut entraîner certains problèmes lorsque vous effectuez ces opérations. Toutes les méthodes BitmapData utilisent et renvoient des valeurs non multipliées. La représentation des pixels interne est convertie du format prémultiplié au format non multiplié avant d’être renvoyée en tant que valeur. Au cours d’une opération de définition, la valeur de pixels est prémultipliée avant de définir le pixel d’image brut.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel.1.as"> L’exemple suivant crée un objet BitmapData en rouge, puis utilise la méthode <codeph>getPixel()</codeph> pour déterminer la valeur de couleur dans le pixel supérieur gauche :
<codeblock>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(1, 1);
trace(pixelValue.toString(16)); // ff0000;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixel32"><apiName>getPixel32</apiName><shortdesc>
	 Renvoie une valeur de couleur ARVB qui contient des données de canal alpha, ainsi que les données RVB.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nombre représentant une valeur de pixels ARVB. Si les coordonnées (<i>x</i>, <i>y</i>) se trouvent à l’extérieur des limites de l’image, 0 est renvoyé.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> du pixel.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> du pixel.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une valeur de couleur ARVB qui contient des données de canal alpha, ainsi que les données RVB. Cette méthode est similaire à la méthode <codeph>getPixel()</codeph> qui renvoie une couleur RVB sans les données de canal alpha.
	 
	 <p>Tous les pixels d’un objet BitmapData sont stockés en tant que valeurs de couleur prémultipliées. Les valeurs des canaux de couleur rouge, vert et bleu d’un pixel image prémultiplié sont déjà multipliées par les données alpha. Par exemple, si la valeur alpha est 0, les canaux RVB sont également définis sur 0, indépendamment de leurs valeurs non multipliées. Cette perte de données peut entraîner certains problèmes lorsque vous effectuez ces opérations. Toutes les méthodes BitmapData utilisent et renvoient des valeurs non multipliées. La représentation des pixels interne est convertie du format prémultiplié au format non multiplié avant d’être renvoyée en tant que valeur. Au cours d’une opération de définition, la valeur de pixels est prémultipliée avant de définir le pixel d’image brut.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel32.1.as"> L’exemple suivant crée un objet BitmapData de la couleur spécifiée, puis utilise la méthode <codeph>getPixel32()</codeph> pour déterminer la valeur de couleur du pixel supérieur gauche. Enfin, elle détermine les valeurs hexadécimales de chaque composant de couleur (alpha, rouge, vert et bleu) :
<codeblock>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(1, 1);
var alphaValue:uint = pixelValue >> 24 &amp; 0xFF;
var red:uint = pixelValue >> 16 &amp; 0xFF;
var green:uint = pixelValue >> 8 &amp; 0xFF;
var blue:uint = pixelValue &amp; 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixels"><apiName>getPixels</apiName><shortdesc>
	 Génère un tableau d’octets à partir d’une zone rectangulaire de données de pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre rect est défini sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>ByteArray représentant les pixels dans le paramètre Rectangle spécifié.
	 
	 </apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Zone rectangulaire de l’objet BitmapData en cours.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Génère un tableau d’octets à partir d’une zone rectangulaire de données de pixels. Ecrit un entier non signé (valeur de pixel non multipliée 32 bits) pour chaque pixel dans le tableau d’octets.
	 
	 </apiDesc><example conref="examples\BitmapData.getPixels.1.as"> L’exemple suivant crée un objet BitmapData rempli avec des pixels de bruit aléatoires, puis applique la méthode <codeph>getPixels()</codeph> pour remplir un objet ByteArray avec la valeur de pixels pour l’objet BitmapData.
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getVector"><apiName>getVector</apiName><shortdesc>
	 Génère un tableau de vecteurs à partir d’une zone rectangulaire de données de pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre rect est défini sur null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Vecteur représentant le Rectangle donné.
	 </apiDesc><apiType value="Vector$uint"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Zone rectangulaire de l’objet BitmapData en cours.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Génère un tableau de vecteurs à partir d’une zone rectangulaire de données de pixels. Renvoie un objet Vector d’entiers non signés (une valeur de pixel non multipliée de 32 bits) pour le rectangle spécifié.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:histogram"><apiName>histogram</apiName><shortdesc>
	 Calcule l’histogramme binaire à 256 valeurs d’un objet BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Vector$Vector$Number"/></apiReturn><apiParam><apiItemName>hRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>La zone de l’objet BitmapData à utiliser.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Calcule l’histogramme binaire à 256 valeurs d’un objet BitmapData. Cette méthode renvoie un objet Vector contenant quatre occurrences de Vector.&lt;Number> (quatre objets Vector qui contiennent des objets Number). Les quatre occurrences de Vector représentent les composants rouge, vert, bleu et alpha, dans l’ordre. Chaque occurrence de Vector contient 256 valeurs qui représentent le nombre de remplissages d’un composant individuel, de 0 à 255.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:hitTest"><apiName>hitTest</apiName><shortdesc>
	 Procède à la détection des clics au niveau des pixels entre une image bitmap et un point, un rectangle ou toute autre image bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre <codeph>secondObject</codeph> n’est pas un objet Point, Rectangle, Bitmap ou BitmapData.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Le paramètre firstPoint est défini sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur <codeph>true</codeph> s’il se produit un clic, <codeph>false</codeph> dans le cas contraire.
	    
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>firstPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc> Position du coin supérieur gauche de l’image BitmapData dans un espace de coordonnées arbitraire. Le même espace de coordonnées est utilisé pour définir le paramètre <codeph>secondBitmapPoint</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>firstAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Plus petite valeur du canal alpha considéré comme étant opaque pour ce test de recherche.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet Rectangle, Point, Bitmap ou BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondBitmapDataPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Point qui définit l’emplacement d’un pixel dans le deuxième objet BitmapData. Utilisez uniquement ce paramètre lorsque la valeur de <codeph>secondObject</codeph> est un objet BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>1</apiData><apiDesc>Plus petite valeur du canal alpha considéré comme étant opaque dans le deuxième objet BitmapData. Utilisez uniquement ce paramètre lorsque la valeur de <codeph>secondObject</codeph> est un objet BitmapData et que les deux objets BitmapData sont transparents.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Procède à la détection des clics au niveau des pixels entre une image bitmap et un point, un rectangle ou toute autre image bitmap. Un clic est défini comme le chevauchement d’un point ou d’un rectangle sur un pixel opaque, ou comme deux pixels opaque se chevauchant. Aucun étirement, aucune rotation ou autre transformation n’est pris en compte lorsque vous effectuez un test de recherche. 
	 
	 <p>Si une image est opaque, elle est considérée comme étant un rectangle entièrement opaque pour cette méthode. Les deux images doivent être transparentes pour effectuer un test de recherche au niveau des pixels tenant compte de la transparence. Lorsque vous testez deux images transparentes, les paramètres de seuil alpha déterminent les valeurs des canaux alpha, comprises entre 0 et 255, considérées comme étant opaques.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.hitTest.1.as"> L’exemple suivant crée un objet BitmapData qui n’est opaque que dans une zone rectangulaire (20, 20, 40, 40) et appelle la méthode <codeph>hitTest()</codeph> avec un objet Point en tant qu’objet <codeph>secondObject</codeph>. Lors du premier appel, l’objet Point définit le coin supérieur gauche de l’objet BitmapData, qui n’est pas opaque, et lors du second appel, l’objet Point définit le centre de l’objet BitmapData, qui est opaque.
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:lock"><apiName>lock</apiName><shortdesc>
	 Verrouille une image de sorte que les objets qui référencent l’objet BitmapData, tels que les objets Bitmap, ne sont pas mis à jour lorsque celui-ci est modifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Verrouille une image de sorte que les objets qui référencent l’objet BitmapData, tels que les objets Bitmap, ne sont pas mis à jour lorsque celui-ci est modifié. Pour améliorer les performances, utilisez cette méthode en conjonction avec la méthode <codeph>unlock()</codeph> avant et après les appels répétés de la méthode <codeph>setPixel()</codeph> ou <codeph>setPixel32()</codeph>.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> L’exemple suivant crée un objet BitmapData reposant sur la propriété <codeph>bitmapData</codeph> d’un objet Bitmap, <codeph>picture</codeph>. Il appelle ensuite la méthode <codeph>lock()</codeph> avant d’appeler une fonction personnalisée complexe, <codeph>complexTransformation()</codeph>, qui modifie l’objet BitmapData (l’objet <codeph>picture</codeph> et la fonction <codeph>complexTransformation()</codeph> ne sont pas définis dans cet exemple). Même si la fonction <codeph>complexTransformation()</codeph> met à jour la propriété <codeph>bitmapData</codeph> de l’objet <codeph>picture</codeph>, les modifications ne sont répercutées que lorsque le code appelle la méthode <codeph>unlock()</codeph> sur l’objet <codeph>bitmapData</codeph> :
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:merge"><apiName>merge</apiName><shortdesc>
     Procède au mélange canal par canal d’une image source vers une image de destination.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres sourceBitmapData, sourceRect ou destPoint sont définis sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>L’image bitmap d’entrée à utiliser. L’image source peut être un objet BitmapData différent ou peut faire référence à l’objet BitmapData actuel.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle qui définit la zone de l’image source à utiliser en tant qu’entrée.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point de l’image de destination (l’occurrence de BitmapData actuelle) correspondant au coin supérieur gauche du rectangle source.
     </apiDesc></apiParam><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur uint hexadécimale par laquelle la valeur du canal rouge doit être multipliée. 
     </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur uint hexadécimale par laquelle la valeur du canal vert doit être multipliée. 
     </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur uint hexadécimale par laquelle la valeur du canal bleu doit être multipliée.
     </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur uint hexadécimale par laquelle la valeur du canal alpha doit être multipliée.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Procède au mélange canal par canal d’une image source vers une image de destination. Pour chaque canal et chaque pixel, une nouvelle valeur est calculée en fonction des valeurs de canal des pixels source et cible. Par exemple, dans le canal rouge, la nouvelle valeur est calculée comme suit (où <codeph>redSrc</codeph> est la valeur du canal rouge d’un pixel dans l’image source et <codeph>redDest</codeph> la valeur du canal rouge du pixel correspondant dans l’image cible) : 
	 <p>
	 <codeph> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </codeph>
	 </p>
	 
	 <p>Les multiplicateurs <codeph>redMultiplier</codeph>, <codeph>greenMultiplier</codeph>, <codeph>blueMultiplier</codeph> et <codeph>alphaMultiplier</codeph> sont utilisés pour chaque canal de couleur. Servez-vous d’une valeur hexadécimale comprise entre <codeph>0</codeph> et <codeph>0x100</codeph> (256), où <codeph>0</codeph> spécifie que la valeur entière de la cible est utilisée dans le résultat, <codeph>0x100</codeph> spécifie que la valeur entière de la source est utilisée, et les nombres intermédiaires spécifient l’utilisation de la fusion (par exemple <codeph>0x80</codeph> pour 50 %).</p>
	 
	 </apiDesc><example conref="examples\BitmapData.merge.1.as"> L’exemple suivant crée deux objets BitmapData. Tous deux font 100 x 80 pixels. Le premier est rempli en vert et le deuxième en rouge. Le code appelle la méthode <codeph>merge()</codeph>, fusionne les pixels du deuxième objet BitmapData avec ceux du premier, mais uniquement dans la zone rectangulaire spécifiée :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:noise"><apiName>noise</apiName><shortdesc>
	 Remplit une image avec des pixels représentant un bruit aléatoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Nombre de la valeur de départ aléatoire à utiliser. Si vous conservez tous les autres paramètres, vous pouvez générer différents résultats pseudo-aléatoires en variant la valeur de départ aléatoire. La fonction de bruit est une fonction de mappage et non une véritable fonction de génération de nombres aléatoires. Elle permet donc de créer systématiquement les mêmes résultats à partir d’une même valeur de départ aléatoire.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>low</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur la plus faible à générer pour chaque canal (de 0 à 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>high</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>255</apiData><apiDesc>Valeur la plus élevée à générer pour chaque canal (de 0 à 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc>Nombre pouvant être une combinaison des quatre valeurs de canaux de couleur (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph> et <codeph>BitmapDataChannel.ALPHA</codeph>). Vous pouvez utiliser l’opérateur logique OR (<codeph>|</codeph>) pour combiner les valeurs de canaux. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Valeur booléenne. Si la valeur est <codeph>true</codeph>, une image en nuances de gris est créée en définissant tous les canaux de couleur sur la même valeur. La sélection du canal alpha n’est pas affectée en définissant ce paramètre sur <codeph>true</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Remplit une image avec des pixels représentant un bruit aléatoire.
	 
	 </apiDesc><example conref="examples\BitmapData.noise.1.as"> L’exemple suivant crée deux objets BitmapData et appelle la méthode <codeph>noise()</codeph> sur les deux. Cependant, le paramètre <codeph>grayscale</codeph> est défini sur <codeph>false</codeph> pour l’appel à la méthode <codeph>noise()</codeph> du premier objet, et est défini sur <codeph>true</codeph> pour l’appel à la méthode <codeph>noise()</codeph> du deuxième objet :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapDataChannel/RED"><linktext>flash.display.BitmapDataChannel.RED</linktext></link><link href="flash.display.xml#BitmapDataChannel/BLUE"><linktext>flash.display.BitmapDataChannel.BLUE</linktext></link><link href="flash.display.xml#BitmapDataChannel/GREEN"><linktext>flash.display.BitmapDataChannel.GREEN</linktext></link><link href="flash.display.xml#BitmapDataChannel/ALPHA"><linktext>flash.display.BitmapDataChannel.ALPHA</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:paletteMap"><apiName>paletteMap</apiName><shortdesc>
	 Remappe les valeurs des canaux de couleur dans une image recevant jusqu’à quatre tableaux de données de palette de couleurs, un pour chaque canal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres sourceBitmapData, sourceRect ou destPoint sont définis sur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>L’image bitmap d’entrée à utiliser. L’image source peut être un autre objet BitmapData ou faire référence à l’occurrence de BitmapData actuelle.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle qui définit la zone de l’image source à utiliser en tant qu’entrée.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point de l’image de destination (l’objet BitmapData actuel) correspondant au coin supérieur gauche du rectangle source.
	 </apiDesc></apiParam><apiParam><apiItemName>redArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Si <codeph>redArray</codeph> n’a pas la valeur <codeph>null</codeph>, <codeph>red = redArray[source red value] else red = source rect value</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>greenArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Si <codeph>greenArray</codeph> n’a pas la valeur <codeph>null</codeph>, <codeph>green = greenArray[source green value] else green = source green value.</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>blueArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Si <codeph>blueArray</codeph> n’a pas la valeur <codeph>null</codeph>, <codeph>blue = blueArray[source blue value] else blue = source blue value</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Si <codeph>alphaArray</codeph> n’a pas la valeur <codeph>null</codeph>, <codeph>alpha = alphaArray[source alpha value] else alpha = source alpha value</codeph>.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Remappe les valeurs des canaux de couleur dans une image recevant jusqu’à quatre tableaux de données de palette de couleurs, un pour chaque canal. 
	 
	 <p><ph platform="actionscript">Flash Player ou </ph>AIR utilise la procédure suivante pour générer l’image résultante :</p>
	 
	 <ol>
	 
	 <li>Une fois le calcul des valeurs rouge, vert, bleu et alpha effectué, celles-ci sont additionnées en effectuant une opération arithmétique standard s’articulant autour d’un entier 32 bits. </li>
	 
	 <li>Les valeurs de couleur rouge, vert, bleu et alpha de chaque pixel sont extraites dans des valeurs distinctes comprises entre 0 et 255. Ces valeurs permettent de rechercher de nouvelles valeurs de couleur dans le tableau voulu : <codeph>redArray</codeph>, <codeph>greenArray</codeph>, <codeph>blueArray</codeph> et <codeph>alphaArray</codeph>. Chacun de ces quatre tableaux doit contenir 256 valeurs. </li>
	 
	 <li>Une fois les quatre nouvelles valeurs de canaux récupérées, elles sont combinées dans une valeur ARVB standard appliquée au pixel.</li>
	 
	 </ol>
	 
	 <p>Les effets multicanaux sont pris en charge par cette méthode. Chaque tableau d’entrée peut contenir des valeurs entières 32 bits ; aucun décalage ne se produit lorsque les valeurs sont additionnées. Cette routine ne prend pas en charge le verrouillage canal par canal. </p>
	 
	 <p>Si aucun tableau n’est spécifié pour un canal, le canal de couleur est copié de l’image source vers l’image de destination.</p>
	 
	 <p>Vous pouvez utiliser cette méthode pour de nombreux effets, tel que le mappage de palette général (qui consiste à sélectionner un canal pour le convertir en image couleur de valeur false). Vous pouvez également utiliser cette méthode pour de nombreux algorithmes de manipulation de couleurs avancés, tels que gamma, courbes, niveaux et quantification.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.paletteMap.1.as"> L’exemple suivant crée un objet BitmapData avec un carré central rouge, puis utilise la méthode <codeph>paletteMap()</codeph> pour remplacer le rouge par du vert dans la moitié rectangulaire du bas de l’objet BitmapData :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:perlinNoise"><apiName>perlinNoise</apiName><shortdesc>
	 Génère une image de bruit Perlin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>baseX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Fréquence à utiliser dans la direction <i>x</i>. Par exemple, pour générer un bruit adapté à une image de 64x128 pixels, réglez la valeur <codeph>baseX</codeph> sur 64. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>baseY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Fréquence à utiliser dans la direction <i>y</i>. Par exemple, pour générer un bruit adapté à une image de 64x128 pixels, réglez la valeur <codeph>baseY</codeph> sur 128. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numOctaves</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octaves ou de fonctions de bruit individuelles à combiner pour créer ce bruit. Plus les nombres d’octaves sont élevés, plus les images créées sont détaillées. Les nombres d’octaves plus élevés nécessitent également un temps de traitement plus important.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Nombre de la valeur de départ aléatoire à utiliser. Si vous conservez tous les autres paramètres, vous pouvez générer différents résultats pseudo-aléatoires en variant la valeur de départ aléatoire. La fonction de bruit Perlin est une fonction de mappage, plutôt qu’une véritable fonction de génération de nombres aléatoires. Elle permet donc de créer systématiquement les mêmes résultats à partir d’une même valeur de départ aléatoire.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>stitch</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Valeur booléenne. Si la valeur est <codeph>true</codeph>, la méthode tente de lisser les bords de transition de l’image pour créer des textures transparentes en vue du remplissage en mosaïque bitmap.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fractalNoise</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Valeur booléenne. Si la valeur est <codeph>true</codeph>, la méthode génère un bruit fractal ; sinon, elle génère une turbulence. Les dégradés d’une image créée à partir d’une turbulence présentent des discontinuités visibles qui lui permettent de mieux appréhender les effets visuels plus saillants, comme les flammes ou les vagues de l’océan.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc> Nombre pouvant être une combinaison des quatre valeurs de canaux de couleur (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph> et <codeph>BitmapDataChannel.ALPHA</codeph>). Vous pouvez utiliser l’opérateur logique OR (<codeph>|</codeph>) pour combiner les valeurs de canaux.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Valeur booléenne. Si la valeur est <codeph>true</codeph>, une image en nuances de gris est créée en définissant les canaux de couleur rouge, vert et bleu sur des valeurs identiques. La valeur du canal alpha n’est pas affectée si cette valeur est définie sur <codeph>true</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>offsets</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de points correspondant aux décalages <i>x</i> et <i>y</i> pour chaque octave. En manipulant les valeurs de décalage, vous pouvez effectuer un défilement lisse d’une image perlinNoise. Chaque point du tableau de décalage affecte une fonction de bruit d’octave spécifique.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Génère une image de bruit Perlin.
	 
	 <p>L’algorithme permettant de générer un bruit Perlin interpole et combine des fonctions de bruit aléatoire individuelles (appelées octaves) en fonction unique qui génère un bruit aléatoire qui semble plus naturel. Tout comme les octaves musicales, la fréquence de chaque fonction d’octave est doublée par rapport à celle qui la précède. Le bruit Perlin est décrit comme étant une « somme de bruit fractale » car il combine plusieurs ensembles de données de bruit avec différents niveaux de détails.</p>
	 
	 <p>Vous pouvez utiliser les fonctions de bruit Perlin pour simuler des phénomènes naturels et des paysages tels que le grain du bois, les nuages ou les chaînes de montagnes. Dans la plupart des cas, la sortie d’une fonction de bruit Perlin ne s’affiche pas directement mais est utilisée pour améliorer d’autres images et leur attribuer des variations pseudo-aléatoires.</p>
	 
	 <p>Les fonctions de bruit aléatoire numériques simples produisent souvent des images aux points durs et contrastés. On ne retrouve pas souvent ce type de contraste dur dans la nature. L’algorithme de bruit Perlin mélange plusieurs fonctions de bruit ayant des niveaux de détails différents. Cet algorithme engendre des variations plus petites parmi les valeurs des pixels environnants.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.perlinNoise.1.as"> L’exemple suivant crée un objet BitmapData de 200x200 pixels qui appelle la méthode <codeph>perlinNoise()</codeph> pour générer un effet d’aquarelle rouge et bleu :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:pixelDissolve"><apiName>pixelDissolve</apiName><shortdesc>
	 Procède à la dissolution de pixels, soit d’une image source vers une image de destination, soit en utilisant la même image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres sourceBitmapData, sourceRect ou destPoint sont définis sur null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>La valeur numPixels est négative.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nouvelle valeur de départ aléatoire à utiliser pour les appels suivants.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>L’image bitmap d’entrée à utiliser. L’image source peut être un autre objet BitmapData ou faire référence à l’occurrence de BitmapData actuelle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle qui définit la zone de l’image source à utiliser en tant qu’entrée.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point de l’image de destination (l’occurrence de BitmapData actuelle) correspondant au coin supérieur gauche du rectangle source.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur de départ aléatoire à utiliser pour démarrer la dissolution de pixels. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numPixels</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>La valeur par défaut est égale à 1/30 de la zone source (largeur x hauteur).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur de couleur ARVB utilisée pour remplir les pixels dont la valeur source est égale à la valeur de destination. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Procède à la dissolution de pixels, soit d’une image source vers une image de destination, soit en utilisant la même image. <ph platform="actionscript">Flash Player ou </ph>AIR utilise une valeur <codeph>randomSeed</codeph> pour générer une dissolution de pixels aléatoire. La valeur renvoyée par la fonction doit être transmise lors des appels suivants pour poursuivre la dissolution de pixels jusqu’à ce qu’elle soit terminée.
	 
	 <p>Si l’image source diffère de l’image de destination, les pixels sont copiés de la source vers la destination à l’aide de toutes les propriétés. Ce processus permet de procéder à la dissolution d’une image vide dans une image entièrement remplie.</p>
	 
	 <p>Si les images source et de destination sont équivalentes, les pixels sont remplis avec le paramètre <codeph>color</codeph>. Ce processus permet de procéder à la dissolution d’une image entièrement remplie. Dans ce mode, le paramètre <codeph>point</codeph> de destination est ignoré.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.pixelDissolve.1.as"> L’exemple suivant utilise la méthode <codeph>pixelDissolve()</codeph> pour convertir un objet BitmapData gris en rouge en procédant à la dissolution de 40 pixels à la fois jusqu’à ce que tous les pixels aient changé de couleur :
<codeblock>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 &amp;&amp; grayRegion.height == 0 ) {
        tim.stop();
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:scroll"><apiName>scroll</apiName><shortdesc>
	 Fait défiler une image en fonction d’un certain montant en pixels (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur du défilement horizontal.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur du défilement vertical.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Fait défiler une image en fonction d’un certain montant en pixels (<i>x</i>, <i>y</i>). Les zones du bord situées hors de la zone de défilement demeurent inchangées.
	 
	 </apiDesc><example conref="examples\BitmapData.scroll.1.as"> L’exemple suivant affiche l’effet du défilement d’un objet de données Bitmap de 40 pixels vers la droite :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:setPixel"><apiName>setPixel</apiName><shortdesc>
	 Définit un pixel unique d’un objet BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> du pixel dont la valeur change.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> du pixel dont la valeur change.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Couleur RVB résultante du pixel. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit un pixel unique d’un objet BitmapData. La valeur de canal alpha actuelle du pixel de l’image est préservée au cours de cette opération. La valeur du paramètre de couleur RVB est traitée en tant que valeur de couleur non multipliée.
	 
	 <p><b>Remarque :</b> lorsque vous utilisez à plusieurs reprises la méthode <codeph>setPixel()</codeph> ou <codeph>setPixel32()</codeph>, appelez la méthode <codeph>lock()</codeph> avant <codeph>setPixel()</codeph> ou <codeph>setPixel32()</codeph>, puis appelez la méthode <codeph>unlock()</codeph> une fois tous les pixels modifiés. Vous optimiserez ainsi les performances. Ce processus empêche la mise à jour des objets qui référencent cette occurrence de BitmapData tant que les modifications de pixels ne sont pas terminées.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel.1.as"> L’exemple suivant utilise la méthode <codeph>setPixel()</codeph> pour tracer une ligne rouge autour de l’objet BitmapData :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixel32"><apiName>setPixel32</apiName><shortdesc>
	 Définit les valeurs de couleur et transparence alpha d’un pixel unique d’un objet BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> du pixel dont la valeur change.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> du pixel dont la valeur change.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Couleur ARVB résultante du pixel. Si l’image bitmap est opaque (non transparente), la partie de transparence alpha de cette valeur de couleur est ignorée.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit les valeurs de couleur et transparence alpha d’un pixel unique d’un objet BitmapData. Cette méthode est similaire à la méthode <codeph>setPixel()</codeph> ; la principale différence réside dans le fait que la méthode <codeph>setPixel32()</codeph> adopte une valeur de couleur ARVB contenant les informations de canal alpha.
	 
	 <p>Tous les pixels d’un objet BitmapData sont stockés en tant que valeurs de couleur prémultipliées. Les valeurs des canaux de couleur rouge, vert et bleu d’un pixel image prémultiplié sont déjà multipliées par les données alpha. Par exemple, si la valeur alpha est 0, les canaux RVB sont également définis sur 0, indépendamment de leurs valeurs non multipliées. Cette perte de données peut entraîner certains problèmes lorsque vous effectuez ces opérations. Toutes les méthodes BitmapData utilisent et renvoient des valeurs non multipliées. La représentation des pixels interne est convertie du format prémultiplié au format non multiplié avant d’être renvoyée en tant que valeur. Au cours d’une opération de définition, la valeur de pixels est prémultipliée avant de définir le pixel d’image brut.</p>
	 
	 <p><b>Remarque :</b> lorsque vous utilisez à plusieurs reprises la méthode <codeph>setPixel()</codeph> ou <codeph>setPixel32()</codeph>, appelez la méthode <codeph>lock()</codeph> avant <codeph>setPixel()</codeph> ou <codeph>setPixel32()</codeph>, puis appelez la méthode <codeph>unlock()</codeph> une fois tous les pixels modifiés. Vous optimiserez ainsi les performances. Ce processus empêche la mise à jour des objets qui référencent cette occurrence de BitmapData tant que les modifications de pixels ne sont pas terminées.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel32.1.as"> L’exemple suivant utilise la méthode <codeph>setPixel32()</codeph> pour tracer une ligne rouge (alpha == 0x60) autour de l’objet BitmapData :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixels"><apiName>setPixels</apiName><shortdesc>
	 Convertit un tableau d’octets en une zone rectangulaire de données de pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>L’objet <codeph>inputByteArray</codeph> ne comprend pas suffisamment de données pour remplir la zone du rectangle <codeph>rect</codeph>. La méthode remplit autant de pixels que possible avant de renvoyer l’exception.
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Les paramètres rect ou inputByteArray sont réglés sur une valeur null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Spécifie la zone rectangulaire de l’objet BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputByteArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray composé de valeurs de pixel non multipliées 32 bits à utiliser dans la zone rectangulaire.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit un tableau d’octets en une zone rectangulaire de données de pixels. La méthode <codeph>ByteArray.readUnsignedInt()</codeph> est appelée pour chaque pixel et la valeur renvoyée est écrite dans ce dernier. Si le tableau d’octets prend fin avant l’écriture du rectangle complet, la fonction renvoie une valeur. Le système s’attend à ce que les données du tableau d’octets soient des valeurs de pixel ARVB 32 bits. Aucune recherche n’est effectuée dans le tableau d’octets avant ou après la lecture des pixels.  
	 
	 </apiDesc><example conref="examples\BitmapData.setPixels.1.as"> L’exemple suivant a recours aux méthodes <codeph>getPixels()</codeph> et <codeph>setPixels()</codeph> pour copier des pixels d’un objet BitmapData à l’autre :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/readUnsignedInt()"><linktext>flash.utils.ByteArray.readUnsignedInt()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setVector"><apiName>setVector</apiName><shortdesc>
	 Convertit un objet Vector en une zone rectangulaire de données de pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le tableau de vecteurs n’est pas assez grand pour lire toutes les données de pixels. 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Spécifie la zone rectangulaire de l’objet BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputVector</apiItemName><apiType value="Vector$uint"/><apiDesc>Objet Vector composé de valeurs de pixel non multipliées 32 bits à utiliser dans la zone rectangulaire.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit un objet Vector en une zone rectangulaire de données de pixels. Pour chaque pixel, un élément Vector est lu et écrit dans le pixel BitmapData. Le système s’attend à ce que les données de l’objet Vector soient des valeurs de pixel ARVB 32 bits. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:threshold"><apiName>threshold</apiName><shortdesc>
	 Teste les valeurs de pixels d’une image selon un seuil spécifié et définit les pixels qui réussissent le test sur de nouvelles valeurs de couleur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres sourceBitmapData, sourceRect, destPoint ou operation sont définis sur null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>L’opération de chaîne n’est pas une opération valide. 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre de pixels modifiés.
 	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>L’image bitmap d’entrée à utiliser. L’image source peut être un autre objet BitmapData ou faire référence à l’occurrence de BitmapData actuelle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle qui définit la zone de l’image source à utiliser en tant qu’entrée.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point de l’image de destination (l’occurrence de BitmapData actuelle) correspondant au coin supérieur gauche du rectangle source.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>L’un des opérateurs de comparaison suivants, transmis en tant que chaîne : "&lt;", "&lt;=", ">", ">=", "==", "!="
	 
	 </apiDesc></apiParam><apiParam><apiItemName>threshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur par rapport à laquelle chaque pixel est testé afin de déterminer s’il est inférieur ou égal au seuil ou s’il le dépasse.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur de couleur sur laquelle un pixel est réglé si le test de seuil aboutit. La valeur par défaut est 0x00000000.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>Masque à utiliser pour isoler un composant de couleur. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>copySource</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si la valeur est <codeph>true</codeph>, les valeurs de pixels de l’image source sont copiées vers la destination lorsque le test de seuil échoue. Si la valeur est <codeph>false</codeph>, l’image source n’est pas copiée lorsque le test de seuil échoue. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Teste les valeurs de pixels d’une image selon un seuil spécifié et définit les pixels qui réussissent le test sur de nouvelles valeurs de couleur. L’utilisation de la méthode <codeph>threshold()</codeph> permet d’isoler et de remplacer les gammes de couleurs d’une image et d’effectuer d’autres opérations logiques sur les pixels de l’image. 
	 
	 <p>La logique du test de la méthode <codeph>threshold()</codeph> est définie comme suit :</p> 
	 
	 <ol> 
	 
	 	<li>Si <codeph>((pixelValue &amp; mask) operation (threshold &amp; mask))</codeph>, définissez le pixel sur <codeph>color</codeph>.</li>
	 
	 	<li>Dans le cas contraire, si <codeph>copySource == true</codeph>, réglez le pixel sur la valeur de pixel correspondante dans <codeph>sourceBitmap</codeph>.</li>
	 </ol>
	 
	 <p>Le paramètre <codeph>operation</codeph> spécifie l’opérateur de comparaison à utiliser pour le test de seuil. Par exemple, si vous utilisez « == » en tant que paramètre <codeph>operation</codeph>, vous pouvez isoler une valeur de couleur spécifique dans une image. Ou si vous utilisez <codeph>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</codeph>, vous pouvez définir tous les pixels de destination comme étant entièrement transparents lorsque la valeur alpha du pixel de l’image source est inférieure à 0x7F. Vous pouvez utiliser cette technique pour les transitions animées et d’autres effets.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.threshold.1.as"> L’exemple suivant exploite la méthode <codeph>perlinNoise()</codeph> pour ajouter un motif bleu et rouge à un objet BitmapData, puis applique la méthode <codeph>threshold()</codeph> pour copier ces pixels du premier objet BitmapData vers un deuxième, en remplaçant les pixels dont la valeur de rouge est supérieure à 0x80 (50 %) par des pixels en rouge transparent (0x20FF0000) :
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, ">", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:unlock"><apiName>unlock</apiName><shortdesc>
	 Déverrouille une image de sorte que les objets qui référencent l’objet BitmapData, tels que les objets Bitmap, sont mis à jour lorsque celui est modifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>changeRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>La zone de l’objet BitmapData qui a été modifiée. Si vous ne spécifiez pas de valeur pour ce paramètre, la zone entière de l’objet BitmapData est considérée comme modifiée. Ce paramètre requiert Flash Player version 9.0.115.0 ou ultérieure.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Déverrouille une image de sorte que les objets qui référencent l’objet BitmapData, tels que les objets Bitmap, sont mis à jour lorsque celui est modifié. Pour améliorer les performances, utilisez cette méthode en conjonction avec la méthode <codeph>lock()</codeph> avant et après les appels répétés de la méthode <codeph>setPixel()</codeph> ou <codeph>setPixel32()</codeph>.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> L’exemple suivant crée un objet BitmapData reposant sur la propriété <codeph>bitmapData</codeph> d’un objet Bitmap, <codeph>picture</codeph>. Il appelle ensuite la méthode <codeph>lock()</codeph> avant d’appeler une fonction personnalisée complexe, <codeph>complexTransformation()</codeph>, qui modifie l’objet BitmapData (l’objet <codeph>picture</codeph> et la fonction <codeph>complexTransformation()</codeph> ne sont pas définis dans cet exemple). Même si la fonction <codeph>complexTransformation()</codeph> met à jour la propriété <codeph>bitmapData</codeph> de l’objet <codeph>picture</codeph>, les modifications ne sont reportées que lorsque le code appelle la méthode <codeph>unlock()</codeph> sur l’objet <codeph>bitmapData</codeph> :
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiValue id="flash.display:BitmapData:height:get"><apiName>height</apiName><shortdesc>
	 La hauteur de l’image bitmap en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 La hauteur de l’image bitmap en pixels.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:rect:get"><apiName>rect</apiName><shortdesc>
	 Le rectangle qui délimite la taille et l’emplacement de l’image bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
	 Le rectangle qui délimite la taille et l’emplacement de l’image bitmap. Le haut et le côté gauche du rectangle sont définis sur 0 ; la largeur et la hauteur sont égales à la largeur et à la hauteur, en pixels, de l’objet BitmapData.
   	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Définit si l’image bitmap prend en charge la transparence par pixel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Définit si l’image bitmap prend en charge la transparence par pixel. Vous pouvez définir cette valeur uniquement lorsque vous créez un objet BitmapData en transmettant la valeur <codeph>true</codeph> au paramètre <codeph>transparent</codeph> du constructeur. Après avoir créé un objet BitmapData, vous pouvez alors vérifier s’il prend en charge la transparence par pixel en déterminant si la valeur de la propriété <codeph>transparent</codeph> est <codeph>true</codeph>.
   	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:width:get"><apiName>width</apiName><shortdesc>
	 Largeur de l’image bitmap en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Largeur de l’image bitmap en pixels.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:JointStyle"><apiName>JointStyle</apiName><shortdesc>
La classe JointStyle est une énumération de valeurs constantes qui spécifient le style de liaison à utiliser pour tracer les lignes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe JointStyle est une énumération de valeurs constantes qui spécifient le style de liaison à utiliser pour tracer les lignes. Ces constantes sont utilisées en tant que valeurs du paramètre <codeph>joints</codeph> dans la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>. Cette méthode prend en charge trois types de pointe : miter, round et bevel, comme indiqué dans l’exemple suivant : 

<p><adobeimage alt="MITER, ROUND et BEVEL" href="../../images/linejoin.jpg"/></p> 

 
</apiDesc><example conref="examples\JointStyleExample.as"> L’exemple suivant utilise la classe JointStyleExample pour afficher le résultat de trois styles de joints distincts qui sont appliqués à trois ensembles de liaisons de lignes. Pour ce faire, procédez comme suit :
 <ol>
  <li>Les propriétés de chaque ligne sont définies comme suit :
  <ul>
      <li>La longueur de ligne est définie sur 80 pixels.</li>
      <li>La couleur de la bordure est définie sur orange.</li>
      <li>La taille de la bordure est définie sur 30 pixels.</li>
      <li>La couleur de surbrillance est définie sur gris.</li>
      <li>La taille de la surbrillance est définie sur zéro pixels.</li>
      <li>La valeur alpha est définie sur 1, ce qui rend la couleur unie.</li>
      <li>L’indice de lissage des pixels est défini sur false (les traits ne sont pas transformés en pixels).</li>
      <li>Le mode de mise à l’échelle de la ligne est défini sur normal. Ce mode porte sur l’épaisseur de la ligne.</li>
      <li>Les extrémités de la bordure et la limite de pointe sont déclarées sans être définies, de façon à appliquer les valeurs par défaut.</li>
  </ul></li>
  <li>Le constructeur de classe crée trois ensembles de deux segments de ligne connectés. Les segments commencent à x = 0, y = 0 en appelant trois fois la méthode <codeph>doDrawCorner()</codeph> à l’aide des trois styles de liaison (miter, round et bevel). Chacun des trois appels à <codeph>doDrawCorner()</codeph> applique le style liaison et les propriétés énumérées précédemment pour dessiner deux segments de ligne connectés et les lignes de surbrillance correspondantes. Cette opération peut s’exécuter en créant un objet Shape, <codeph>child</codeph>, puis exploite les méthodes de la classe Graphics pour définir le style de ligne et dessiner les lignes et les surbrillances. Chaque occurrence de <codeph>child</codeph> s’ajoute à la liste d’affichage et est dessinée rapidement sur la scène.</li>
  <li>Les segments de ligne connectés sont redessinés avec la méthode <codeph>refreshLayout()</codeph> à y = 80 pixels et commence à x = 80 pixels, avec une séparation de 25 pixels entre les segments de ligne.</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class JointStyleExample extends Sprite {
        private var size:uint                  = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderCaps:String;
        private var borderMiterLimit:uint;

        public function JointStyleExample() {
            doDrawCorner(JointStyle.MITER);
            doDrawCorner(JointStyle.ROUND);
            doDrawCorner(JointStyle.BEVEL);
            refreshLayout();
        }

        private function doDrawCorner(jointStyle:String):void {
            var halfSize:uint = Math.round(size / 2);
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     borderCaps,
                                     jointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = size;
            lastChild.y = size;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = size;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:JointStyle:BEVEL"><apiName>BEVEL</apiName><shortdesc>
	
	Spécifie des liaisons biseautées dans le paramètre joints de la méthode flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bevel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Spécifie des liaisons biseautées dans le paramètre <codeph>joints</codeph> de la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:MITER"><apiName>MITER</apiName><shortdesc>
	
	Spécifie des liaisons en pointe dans le paramètre joints de la méthode flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>miter</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Spécifie des liaisons en pointe dans le paramètre <codeph>joints</codeph> de la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	
	Spécifie des liaisons rondes dans le paramètre joints de la méthode flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Spécifie des liaisons rondes dans le paramètre <codeph>joints</codeph> de la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:AVM1Movie"><apiName>AVM1Movie</apiName><shortdesc>
	AVM1Movie est une classe simple représentant les clips AVM1, qui utilisent ActionScript 1.0 ou 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
	AVM1Movie est une classe simple représentant les clips AVM1, qui utilisent ActionScript 1.0 ou 2.0 (AVM1 désigne la machine virtuelle ActionScript qui exécute ActionScript 1.0 et 2.0. AVM2 désigne la machine virtuelle ActionScript qui exécute ActionScript 3.0). Lorsqu’un fichier SWF généré dans Flash Player 8 ou une version antérieure est chargé par un objet Loader, un objet AVM1Movie est créé. L’objet AVM1Movie dispose des méthodes et des propriétés dont il a hérité de la classe DisplayObject, telles que <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, etc. Toute interaction (telle que l’appel de méthodes ou l’utilisation de paramètres) entre l’objet AVM1Movie et les objets AVM2 est cependant interdite.
	
	<p>Plusieurs restrictions s’appliquent à un fichier SWF AVM1 chargé par un fichier SWF AVM2 :</p>
	
	<ul>
	
	<li>L’objet AVM1Movie chargé opère en tant qu’objet pseudo-racine pour les fichiers SWF d’AVM1 et tous les fichiers SWF chargés par AVM1 (comme si la propriété ActionScript 1.0 <codeph>lockroot</codeph> était définie sur <codeph>true</codeph>). L’animation AVM1 est toujours le premier code ActionScript 1.0 ou 2.0 exécuté dans tout enfant. La propriété <codeph>_root</codeph> associée aux enfants chargés correspond toujours à ce fichier SWF AVM1, à moins que la propriété <codeph>lockroot</codeph> ne soit définie dans un fichier SWF AVM1 chargé.</li>
	
	<li>Le contenu AVM1 ne peut pas charger de fichiers dans un niveau. Il lui est par exemple impossible de charger des fichiers en appelant <codeph>loadMovieNum("url", levelNum)</codeph>.</li>
	
	<li>Le fichier SWF AVM1 chargé par un fichier SWF AVM2 ne peut pas charger un autre fichier SWF dans <codeph>this</codeph>. En d’autres termes, il ne peut pas charger un autre fichier SWF sur lui-même. Cependant, les objets enfant Sprite, les objets MovieClip ou d’autres fichiers SWF AVM1 chargés par ce fichier SWF peuvent être chargés dans <codeph>this</codeph>.</li>
	
	</ul>
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>Classe DisplayObject</linktext></link><link href="flash.display.xml#Loader"><linktext>Loader</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
	 Une occurrence ShaderInput représente une unique image d’entrée pour un noyau de shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Une occurrence ShaderInput représente une unique image d’entrée pour un noyau de shader. Un noyau peut être défini de manière à accepter aucune, une ou plusieurs images source utilisées dans l’exécution du noyau. Une occurrence ShaderInput fournit un mécanisme qui permet de spécifier l’image d’entrée utilisée lorsque le shader s’exécute. Pour spécifier une valeur pour l’entrée, créez une occurrence de BitmapData, de ByteArray ou de Vector.&lt;Number> contenant les données d’image et affectez-la à la propriété <codeph>input</codeph>.
	 
	 <p>L’occurrence ShaderInput représentant une image d’entrée de l’occurrence Shader est accédée en tant que propriété de la propriété <codeph>data</codeph> de l’occurrence Shader. La propriété ShaderInput a le même nom que l’entrée dans le code du shader. Par exemple, si un shader définit une entrée nommée <codeph>src</codeph>, l’occurrence ShaderInput représentant l’entrée <codeph>src</codeph> est disponible en tant que propriété <codeph>src</codeph>, comme le montre cet exemple :</p>
	 
	 <codeblock>myShader.data.src.image = new BitmapData(50, 50, true, 0xFF990000);</codeblock>
	 
	 <p>Pour certaines utilisations d’une occurrence Shader, il n’est pas nécessaire de spécifier une image d’entrée car elle est automatiquement désignée par l’opération. Une entrée doit être spécifiée lorsqu’un Shader est utilisé dans les cas suivants :</p>
	 
	 <ul>
	   <li>Remplissage du shader</li>
	   <li>ShaderFilter, uniquement pour la seconde entrée ou pour les entrées supplémentaires si le shader est défini pour utiliser plusieurs entrées (l’objet auquel le filtre est appliqué est automatiquement utilisé comme première entrée).</li>
	   <li>Mode de fondu du shader, uniquement pour la troisième entrée ou pour les entrées supplémentaires si le shader est défini pour utiliser plus de deux entrées (les objets auxquels s’applique le fondu sont automatiquement utilisés comme première et seconde entrées).</li>
	   <li>Exécution en arrière-plan de ShaderJob </li>
	 </ul>
	 
	 <p>Si le shader est exécuté par le biais d’une occurrence ShaderJob pour traiter un ByteArray contenant un tableau de données linéaire, définissez la propriété <codeph>height</codeph> de l’occurrence ShaderInput sur 1 et la propriété <codeph>width</codeph> sur les valeurs en virgule flottante 32 bits du ByteArray. Dans ce cas, l’entrée dans le shader doit être définie avec le type de données <codeph>image1</codeph>.</p>
	 
	 <p>En général, le code du développeur ne crée pas directement d’occurrence ShaderInput. Une occurrence ShaderInput est créée pour chacune des entrées d’un shader lors de la création de l’occurrence Shader.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link></related-links><apiConstructor id="flash.display:ShaderInput:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
		 Crée une occurrence ShaderInput.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Crée une occurrence ShaderInput. Le code du développeur n’appelle pas directement le constructeur ShaderInput. Une occurrence ShaderInput est créée pour chacune des entrées d’un shader lors de la création de l’occurrence Shader.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderInput:channels:get"><apiName>channels</apiName><shortdesc>
         Nombre de canaux attendus par une entrée de shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Nombre de canaux attendus par une entrée de shader. Cette propriété doit être prise en compte lorsque les données d’entrée sont une occurrence ByteArray ou de Vector.&lt;Number>.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:height:get"><apiName>height</apiName><shortdesc>
		 Hauteur de l’entrée du shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Hauteur de l’entrée du shader. Cette propriété est utilisée uniquement lorsque les données d’entrée sont une occurrence de ByteArray ou de Vector.&lt;Number>. Lorsque l’entrée est une occurrence BitmapData, la hauteur est déterminée automatiquement.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:index:get"><apiName>index</apiName><shortdesc>
         Index de base zéro de l’entrée dans le shader, indiquant l’ordre des définitions d’entrée dans le shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Index de base zéro de l’entrée dans le shader, indiquant l’ordre des définitions d’entrée dans le shader.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:input:get"><apiName>input</apiName><shortdesc>
		 
		 Données d’entrée qui sont utilisées lorsque le shader s’exécute.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 
		 Données d’entrée qui sont utilisées lorsque le shader s’exécute. Cette propriété peut être une occurrence de BitmapData, une occurrence de ByteArray ou une occurrence de Vector.&lt;Number>.
		 
		 <p>Lorsqu’une valeur ByteArray est affectée à la propriété <codeph>input</codeph>, les conditions suivantes doivent être satisfaites :</p>
		 
		 <ul>
		   <li>Les propriétés <codeph>height</codeph> et <codeph>width</codeph> doivent être définies.</li>
		   <li>Le tableau d’octets ne doit contenir que des valeurs en virgule flottante 32 bits. Ces valeurs peuvent être écrites à l’aide de la méthode <codeph>ByteArray.writeFloat()</codeph>.</li>
		   <li>La longueur totale des octets dans le ByteArray doit être exactement <codeph>width</codeph> fois <codeph>height</codeph> fois <codeph>channels</codeph> fois 4.</li>
		   <li>La propriété <codeph>endian</codeph> du tableau d’octets doit être <codeph>Endian.LITTLE_ENDIAN</codeph>.</li>
		 </ul>
		 
		 <p>Si une occurrence de Vector.&lt;Number> est affectée à la propriété <codeph>input</codeph>, la longueur du Vector doit être égale à <codeph>width</codeph> fois <codeph>height</codeph> fois <codeph>channels</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:width:get"><apiName>width</apiName><shortdesc>
		 Largeur de l’entrée du shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Largeur de l’entrée du shader. Cette propriété est utilisée uniquement lorsque les données d’entrée sont une occurrence de ByteArray ou de Vector.&lt;Number>. Lorsque l’entrée est une occurrence BitmapData, la largeur est déterminée automatiquement.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrection"><apiName>ColorCorrection</apiName><shortdesc>
La classe ColorCorrection fournit les valeurs de la propriété flash.display.Stage.colorCorrection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe ColorCorrection fournit les valeurs de la propriété <codeph>flash.display.Stage.colorCorrection</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrection"><linktext>flash.display.Stage.colorCorrection</linktext></link></related-links><apiValue id="flash.display:ColorCorrection:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
Utilise la correction des couleurs par défaut de l’hôte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Utilise la correction des couleurs par défaut de l’hôte. Pour le lecteur Web, l’hôte est généralement un navigateur et Flash Player tente d’utiliser la même correction des couleurs que la page Web qui héberge le fichier SWF. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:OFF"><apiName>OFF</apiName><shortdesc>
Désactive la correction des couleurs quel que soit l’environnement hôte du lecteur, le cas échéant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>off</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Désactive la correction des couleurs quel que soit l’environnement hôte du lecteur, le cas échéant. Ce réglage permet d’optimiser les performances de rapidité. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:ON"><apiName>ON</apiName><shortdesc>
Active la correction des couleurs quel que soit l’environnement hôte du lecteur, le cas échéant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>on</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Active la correction de couleur quel que soit l’environnement hôte du lecteur, le cas échéant. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:LineScaleMode"><apiName>LineScaleMode</apiName><shortdesc>
La classe LineScaleMode fournit des valeurs pour le paramètre scaleMode de la méthode Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe LineScaleMode fournit des valeurs pour le paramètre <codeph>scaleMode</codeph> de la méthode <codeph>Graphics.lineStyle()</codeph>.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:LineScaleMode:HORIZONTAL"><apiName>HORIZONTAL</apiName><shortdesc>
	Si ce réglage est utilisé en tant que paramètre scaleMode de la méthode lineStyle(), l’épaisseur de la ligne n’est redimensionnée qu’à la verticale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>horizontal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Si ce réglage est utilisé en tant que paramètre <codeph>scaleMode</codeph> de la méthode <codeph>lineStyle()</codeph>, l’épaisseur de la ligne n’est redimensionnée <i>qu’à</i> la verticale. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.VERTICAL</codeph>. Le cercle de gauche est redimensionné à la verticale uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale.
	
    <p><adobeimage alt="Un cercle redimensionné verticalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NONE"><apiName>NONE</apiName><shortdesc>
	Si ce réglage est utilisé en tant que paramètre scaleMode de la méthode lineStyle(), l’épaisseur de la ligne n’est jamais redimensionnée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Si ce réglage est utilisé en tant que paramètre <codeph>scaleMode</codeph> de la méthode <codeph>lineStyle()</codeph>, l’épaisseur de la ligne n’est jamais redimensionnée.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	Si ce réglage est utilisé en tant que paramètre scaleMode de la méthode lineStyle(), l’épaisseur de la ligne est toujours redimensionnée lors du redimensionnement de l’objet (valeur par défaut).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Si ce réglage est utilisé en tant que paramètre <codeph>scaleMode</codeph> de la méthode <codeph>lineStyle()</codeph>, l’épaisseur de la ligne est toujours redimensionnée lors du redimensionnement de l’objet (valeur par défaut).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:VERTICAL"><apiName>VERTICAL</apiName><shortdesc>
	Si ce réglage est utilisé en tant que paramètre scaleMode de la méthode lineStyle(), l’épaisseur de la ligne n’est redimensionnée qu’à l’horizontale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>vertical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Si ce réglage est utilisé en tant que paramètre <codeph>scaleMode</codeph> de la méthode <codeph>lineStyle()</codeph>, l’épaisseur de la ligne n’est redimensionnée <i>qu’à</i> l’horizontale. Considérons par exemple les cercles illustrés ci-dessous, dessinés dans un trait d’un pixel, et pour lesquels le paramètre <codeph>scaleMode</codeph> est défini sur <codeph>LineScaleMode.HORIZONTAL</codeph>. Le cercle de gauche est redimensionné à l’horizontale uniquement, tandis que le cercle de droite est redimensionné à la verticale et à l’horizontale.
	
    <p><adobeimage alt="Un cercle redimensionné horizontalement, et un cercle redimensionné verticalement et horizontalement." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Shader"><apiName>Shader</apiName><shortdesc>
	 Une occurrence de Shader représente un noyau de shader de Pixel Bender dans le code ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Une occurrence de Shader représente un noyau de shader de Pixel Bender dans le code ActionScript. Pour utiliser un shader dans votre application, vous devez créer une occurrence de Shader pour le shader. Utilisez ensuite cette occurrence de Shader de manière à obtenir l’effet que vous souhaitez créer. Par exemple, pour utiliser le shader en tant que filtre, affectez l’occurrence Shader à la propriété <codeph>shader</codeph> d’un objet ShaderFilter.
	 
	 <p>Un shader définit une fonction qui s’exécute sur tous les pixels d’une image, un pixel après l’autre. Le résultat de chaque appel à la fonction est la couleur de sortie aux coordonnées de ce pixel dans l’image. Un shader peut spécifier une ou plusieurs images d’entrée, dont le contenu peut être utilisé pour déterminer le résultat de la fonction. Un shader peut également spécifier un ou plusieurs paramètres, correspondant aux valeurs d’entrée pouvant être utilisées pour calculer le résultat de la fonction. Dans une seule exécution de shader, les valeurs d’entrée et des paramètres sont constantes. Les seuls éléments qui varient sont les coordonnées du pixel dont la couleur est le résultat de la fonction. Les appels de la fonction du shader pour plusieurs coordonnées de pixel de sortie s’exécutent en parallèle pour améliorer les performances de l’exécution du shader.</p>
	 
	 <p>Le code binaire du shader peut être chargé au moment de l’exécution à l’aide d’une occurrence URLLoader. L’exemple suivant montre le chargement d’un fichier de code binaire de shader à l’exécution et sa liaison à une occurrence Shader.</p>
	 
	 <codeblock>
	 var loader:URLLoader = new URLLoader();
	 loader.dataFormat = URLLoaderDataFormat.BINARY;
	 loader.addEventListener(Event.COMPLETE, onLoadComplete);
	 loader.load(new URLRequest("myShader.pbj"));
	  
	 var shader:Shader;
	  
	 function onLoadComplete(event:Event):void {
	     // Create a new shader and set the loaded data as its bytecode
	     shader = new Shader();
	     shader.byteCode = loader.data;
	     
	     // You can also pass the bytecode to the Shader() constructor like this:
	     // shader = new Shader(loader.data);
	     
	     // do something with the shader
	 }
	 </codeblock>
	 
	 <p>Vous pouvez intégrer le shader dans la séquence SWF au moment de la compilation à l’aide de la balise de métadonnées <codeph>[Embed]</codeph>. La balise de métadonnées <codeph>[Embed]</codeph> n’est disponible que si vous utilisez le kit de développement Flex pour compiler le fichier SWF. Le paramètre <codeph>source</codeph> de la balise <codeph>[Embed]</codeph> pointe vers le fichier du shader, et son paramètre <codeph>mimeType</codeph> est <codeph>"application/octet-stream"</codeph>, comme dans cet exemple :</p>
	 
	 <codeblock>
	 [Embed(source="myShader.pbj", mimeType="application/octet-stream)]
	 var MyShaderClass:Class;
	  
	 // ...
	 
	 // create a new shader and set the embedded shader as its bytecode
	 var shaderShader = new Shader();
	 shader.byteCode = new MyShaderClass();
	  
	 // You can also pass the bytecode to the Shader() constructor like this:
	 // var shader:Shader = new Shader(new MyShaderClass());
	  
	 // do something with the shader
	 </codeblock>
	 
	 <p>Dans tous les cas, vous liez le shader brut (la propriété <codeph>URLLoader.data</codeph> ou une occurrence de la classe de données <codeph>[Embed]</codeph>) à l’occurrence Shader. Comme le montre l’exemple précédent, vous avez deux moyens de le faire. Vous pouvez transmettre le pseudo-code binaire du shader sous forme d’argument au constructeur <codeph>Shader()</codeph>. Vous pouvez également le définir en tant que propriété <codeph>byteCode</codeph> de l’occurrence Shader.</p>
	 
	 <p>Lorsqu’une occurrence Shader est créée, elle peut être utilisée de plusieurs manières :</p>
	 
	 <ul>
	   <li>Un remplissage de shader : le résultat du shader est utilisé comme remplissage lorsque le contenu est dessiné avec l’API de dessin. Transmettez l’occurrence Shader sous forme d’argument à la méthode <codeph>Graphics.beginShaderFill()</codeph>.</li>
	   <li>Un filtre de shader : le résultat du shader est utilisé comme filtre graphique appliqué à un objet d’affichage. Affectez l’occurrence Shader à la propriété <codeph>shader</codeph> d’une occurrence ShaderFilter.</li>
	   <li>Un mode de fondu : le résultat du shader est restitué sous forme de fondu entre deux objets d’affichage qui se chevauchent. Affectez l’occurrence Shader à la propriété <codeph>blendShader</codeph> de celui des deux objets d’affichage qui placé au-dessus.</li>
	   <li>Traitement du shader en arrière-plan : le shader s’exécute en arrière-plan, ce qui évite à l’écran de geler, et déclenche un événement lorsque le traitement est terminé. Affectez l’occurrence Shader à la propriété <codeph>shader</codeph> d’une occurrence ShaderJob.</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\ShaderExample.1.as"> L’exemple suivant charge un fichier de pseudo-code binaire de shader à l’exécution et crée une occurrence Shader liée au fichier.
 
 <p>Notez que cet exemple part du principe qu’un fichier de pseudo-code binaire du shader nommé « donothing.pbj » existe dans le répertoire de sortie de l’application. Le code source de Pixel Bender pour le shader DoNothing est disponible dans l’<xref href="ShaderData.html#includeExamplesSummary">exemple de la classe ShaderData</xref>.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class LoadedShaderExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function LoadedShaderExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example><example conref="examples\ShaderExample.2.as"> L’exemple suivant intègre un fichier de pseudo-code binaire de shader en le compilant dans le fichier SWF, et crée une occurrence Shader liée au fichier.
 
 <p>Notez que cet exemple part du principe qu’un fichier de pseudo-code binaire du shader nommé « donothing.pbj » existe dans le répertoire de sortie de l’application, et que le kit de développement Flex est utilisé pour compiler le fichier SWF. Le code source de Pixel Bender pour le shader DoNothing est disponible dans l’<xref href="ShaderData.html#includeExamplesSummary">exemple de la classe ShaderData</xref>.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;

    public class EmbeddedShaderExample extends Sprite {
        
        [Embed(source="donothing.pbj", mimeType="application/octet-stream")]
        private static var DoNothingShader:Class;
        
        public function EmbeddedShaderExample() {
            var shader:Shader = new Shader();
            shader.byteCode = new DoNothingShader();
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link><link href="flash.filters.xml#ShaderFilter"><linktext>flash.filters.ShaderFilter</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><apiConstructor id="flash.display:Shader:flash.display:Shader"><apiName>Shader</apiName><shortdesc>
		 Crée une occurrence Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Pseudo-code binaire du shader brut à lier au Shader.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Crée une occurrence Shader.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shader:data:set"><apiName>data</apiName><shortdesc>
		 Permet à l’occurrence Shader d’accéder aux paramètres, aux images d’entrée et aux métadonnées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:ShaderData</apiValueClassifier></apiValueDef><apiDesc>
		 Permet à l’occurrence Shader d’accéder aux paramètres, aux images d’entrée et aux métadonnées. Des objets ShaderParameter représentant des paramètres du shader, des objets ShaderInput représentant des images d’entrée du shader et d’autres valeurs représentant les métadonnées du shader sont ajoutées dynamiquement en tant que propriétés de l’objet <codeph>data</codeph> lors de la création de l’occurrence Shader. Ces propriétés peuvent être utilisées pour analyser le shader et pour définir les valeurs des entrées et des paramètres.
		 
		 <p>Pour plus d’informations sur l’accès et la manipulation des propriétés dynamiques de l’objet <codeph>data</codeph>, reportez-vous à la description de la classe ShaderData.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:precisionHint:set"><apiName>precisionHint</apiName><shortdesc>
		 Précision des opérations mathématiques effectuées par le shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Précision des opérations mathématiques effectuées par le shader.
		 
		 <p>L’ensemble des valeurs possibles de la propriété <codeph>precisionHint</codeph> est défini par les constantes de la classe ShaderPrecision.</p>
		 
		 <p>La valeur par défaut est <codeph>ShaderPrecision.FULL</codeph>. Le fait de définir la précision sur <codeph>ShaderPrecision.FAST</codeph> peut accélérer les opérations mathématiques au détriment de la précision.</p>
		 
		 <p>Le mode de précision totale (<codeph>ShaderPrecision.FULL</codeph>) calcule toutes les opérations mathématiques avec toute la largeur de virgule flottante 32 bits de la norme IEEE et assure un comportement cohérent sur toutes les plates-formes. Dans ce mode, certaines opérations mathématiques, telles que les fonctions trigonométriques et exponentielles, peuvent être lentes.</p>
		 
		 <p>Le mode de précision rapide (<codeph>ShaderPrecision.FAST</codeph>) est conçu pour des performances maximales, mais n’assure pas la même cohérence sur les différentes plates-formes et les configurations de CPU individuelles. Dans la plupart des cas, ce niveau de précision suffit pour créer des effets graphiques sans artefact visible.</p>
		 
		 <p>Le choix du mode de précision affecte les opérations de shader suivantes. Ces opérations sont plus rapides sur un processeur Intel avec l’instruction SSE définie :</p>
		 
		 <ul>
		   <li><codeph>sin(x)</codeph></li>
		   <li><codeph>cos(x)</codeph></li>
		   <li><codeph>tan(x)</codeph></li>
		   <li><codeph>asin(x)</codeph></li>
		   <li><codeph>acos(x)</codeph></li>
		   <li><codeph>atan(x)</codeph></li>
		   <li><codeph>atan(x, y)</codeph></li>
		   <li><codeph>exp(x)</codeph></li>
		   <li><codeph>exp2(x)</codeph></li>
		   <li><codeph>log(x)</codeph></li>
		   <li><codeph>log2(x)</codeph></li>
		   <li><codeph>pow(x, y)</codeph></li>
		   <li><codeph>reciprocal(x)</codeph></li>
		   <li><codeph>sqrt(x)</codeph></li>
		 </ul>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderPrecision"><linktext>flash.display.ShaderPrecision</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:byteCode:set"><apiName>byteCode</apiName><shortdesc>
		 Pseudo-code binaire du shader brut pour cette occurrence Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier></apiValueDef><apiDesc>
		 Pseudo-code binaire du shader brut pour cette occurrence Shader.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsData"><apiName>IGraphicsData</apiName><shortdesc>
	Cette interface permet de définir des objets pouvant être utilisés comme paramètres dans les méthodes flash.display.Graphics, notamment des remplissages, des traits et des tracés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Cette interface permet de définir des objets pouvant être utilisés comme paramètres dans les méthodes flash.display.Graphics, notamment des remplissages, des traits et des tracés. Utilisez les classes implémenteur de cette interface pour créer et gérer les données de la propriété drawing et pour réutiliser les mêmes données pour plusieurs occurrences. Utilisez ensuite les méthodes de la classe Graphics pour restituer les objets de dessin.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:MovieClip"><apiName>MovieClip</apiName><shortdesc>
 La classe MovieClip hérite des classes suivantes : Sprite, DisplayObjectContainer, InteractiveObject, DisplayObject et EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>L’objet d’affichage de base des objets créés par ActionScript.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:Sprite</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe MovieClip hérite des classes suivantes : Sprite, DisplayObjectContainer, InteractiveObject, DisplayObject et EventDispatcher.
 
 <p>A l’inverse de l’objet Sprite, un objet MovieClip dispose d’un scénario.</p>
 
 <p product="flash">Les méthodes de la classe MovieClip fournissent les mêmes fonctionnalités que les actions permettant de cibler des clips. Certaines autres méthodes ne possèdent pas d’actions équivalentes dans la boîte à outils Actions du panneau Actions de l’outil de programmation Flash. </p>
 
 <p>Les occurrences enfant placées sur la scène dans l’outil de programmation de Flash ne sont pas accessibles par le code depuis l’intérieur du constructeur d’une occurrence parent car, à ce stade de l’exécution du code, elles n’ont pas été créées. Avant d’accéder à l’enfant, le parent doit soit créer l’occurrence enfant par du code, soit retarder l’accès à une fonction de rappel qui écoute l’enfant en vue de la distribution de son événement <codeph>Event.ADDED_TO_STAGE</codeph>.</p>
 
 <p>Si vous modifiez l’une des propriétés suivantes d’un objet MovieClip contenant une interpolation de mouvement, la tête de lecture est arrêtée dans cet objet MovieClip : <codeph>alpha</codeph>, <codeph>blendMode</codeph>, <codeph>filters</codeph>, <codeph>height</codeph>, <codeph>opaqueBackground</codeph>, <codeph>rotation</codeph>, <codeph>scaleX</codeph>, <codeph>scaleY</codeph>, <codeph>scale9Grid</codeph>, <codeph>scrollRect</codeph>, <codeph>transform</codeph>, <codeph>visible</codeph>, <codeph>width</codeph>, <codeph>x</codeph> ou <codeph>y</codeph>. Il n’arrête cependant pas la tête de lecture dans tout objet MovieClip enfant de l’objet MovieClip correspondant.</p>
 
 </apiDesc><example conref="examples\MovieClipExample.as"> L’exemple suivant utilise la classe MovieClipExample pour illustrer la façon de suivre les différentes propriétés d’un objet MovieClip. Pour ce faire, procédez comme suit :
 
 <ol>
 
  <li>La fonction constructeur définit un champ de texte, qui permet d’afficher les valeurs des propriétés de l’objet MovieClipExample (qui étend MovieClip).</li>
 
  <li>La valeur renvoyée par la méthode <codeph>getPropertiesString()</codeph> est utilisée en tant que texte pour le champ de texte <codeph>outputText</codeph>. La méthode <codeph>getPropertiesString()</codeph> renvoie une chaîne qui est remplie avec des valeurs provenant des propriétés suivantes du clip : <codeph>currentFrame</codeph>, <codeph>currentLabel</codeph>, <codeph>currentScene</codeph>, <codeph>framesLoaded</codeph>, <codeph>totalFrames</codeph> et <codeph>trackAsMenu</codeph>.</li>
 
  <li>Deux des lignes de code de la fonction constructeur règlent les propriétés <codeph>width</codeph> et <codeph>height</codeph> du champ de texte <codeph>outputText</codeph>.</li>
 
  <li>La dernière ligne de la fonction constructeur ajoute le champ de texte <codeph>outputText</codeph> à la liste d’affichage.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.MovieClip;
    import flash.text.TextField;

    public class MovieClipExample extends MovieClip {

        public function MovieClipExample() {
            var outputText:TextField = new TextField();
            outputText.text = getPropertiesString();
            outputText.width = stage.stageWidth;
            outputText.height = outputText.textHeight;
            addChild(outputText);
        }

        private function getPropertiesString():String {
            var str:String = ""
                + "currentFrame: " + currentFrame + "\n"
                + "currentLabel: " + currentLabel + "\n"
                + "currentScene: " + currentScene + "\n"
                + "framesLoaded: " + framesLoaded + "\n"
                + "totalFrames: " + totalFrames + "\n"
                + "trackAsMenu: " + trackAsMenu + "\n";
            return str;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:MovieClip:MovieClip"><apiName>MovieClip</apiName><shortdesc>
	Crée une occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Crée une occurrence de MovieClip. Après avoir créé l’objet MovieClip, appelle la méthode <codeph>addChild()</codeph> ou <codeph>addChildAt()</codeph> d’un objet conteneur d’affichage qui est sur la scène.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:MovieClip:gotoAndPlay"><apiName>gotoAndPlay</apiName><shortdesc>
	 Commence la lecture du fichier SWF sur l’image spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandplay, gotoandplay
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Nombre représentant le numéro d’image ou une chaîne représentant l’étiquette de l’image cible de la tête de lecture. Si vous spécifiez un nombre, il est relatif à la séquence indiquée. Si vous ne spécifiez pas de séquence, la séquence en cours détermine le numéro d’image global à lire. Si vous spécifiez une séquence, la tête de lecture passe au numéro d’image de la séquence indiquée.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Nom de la séquence à lire. Ce paramètre est facultatif.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Commence la lecture du fichier SWF sur l’image spécifiée. Cette opération se produit lorsque l’exécution de toutes les autres actions de l’image est terminée. Pour spécifier une séquence et une image, affectez une valeur au paramètre <codeph>scene</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.gotoAndPlay.1.as"> L’exemple suivant utilise la propriété <codeph>gotoAndPlay()</codeph> pour faire avancer de cinq images la tête de lecture du clip <codeph>mc1</codeph> par rapport à sa position actuelle :
<codeblock>
mc1.gotoAndPlay(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndPlay.2.as"> Le code suivant utilise la méthode <codeph>gotoAndPlay()</codeph> pour diriger la tête de lecture du clip <codeph>mc1</codeph> vers l’image <codeph>"intro"</codeph> de la séquence <codeph>"Scene 12"</codeph> :
<codeblock>
mc1.gotoAndPlay("intro", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:gotoAndStop"><apiName>gotoAndStop</apiName><shortdesc>
	  Place la tête de lecture au niveau de l’image spécifiée du clip et l’arrête à cet endroit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandstop, gotoandstop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si les paramètres <codeph>scene</codeph> ou <codeph>frame</codeph> spécifiés ne figurent pas dans le clip.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Nombre représentant le numéro d’image ou une chaîne représentant l’étiquette de l’image cible de la tête de lecture. Si vous spécifiez un nombre, il est relatif à la séquence indiquée. Si vous ne spécifiez pas de séquence, la séquence en cours détermine le numéro d’image global cible sur laquelle s’arrêter. Si vous spécifiez une séquence, la tête de lecture passe au numéro d’image de la séquence indiquée et s’arrête.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Nom de la séquence. Ce paramètre est facultatif.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Place la tête de lecture au niveau de l’image spécifiée du clip et l’arrête à cet endroit. Cette opération se produit lorsque l’exécution de toutes les autres actions de l’image est terminée. Pour spécifier une séquence en plus d’une image, utilisez un paramètre <codeph>scene</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> L’exemple suivant utilise la méthode <codeph>gotoAndStop()</codeph> et la propriété <codeph>currentFrame</codeph> pour diriger la tête de lecture du clip <codeph>mc1</codeph> pour avancer de cinq images par rapport à sa position actuelle et s’arrêter :
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndStop.1.as"> Le code suivant utilise <codeph>gotoAndStop()</codeph> pour diriger la tête de lecture du clip <codeph>mc1</codeph> vers l’image <codeph>"finale"</codeph> de la séquence <codeph>"Scene 12"</codeph> :
<codeblock>
mc1.gotoAndStop("finale", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:nextFrame"><apiName>nextFrame</apiName><shortdesc>
	 Place la tête de lecture sur l’image suivante et l’arrête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.nextframe, nextframe
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Place la tête de lecture sur l’image suivante et l’arrête. Cette opération se produit lorsque l’exécution de toutes les autres actions de l’image est terminée.
	 
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> Dans l’exemple suivant, deux objets SimpleButton contrôlent le scénario. Le bouton <codeph>prev</codeph> déplace la tête de lecture vers l’image précédente alors que le bouton <codeph>nextBtn</codeph> la déplace vers l’image suivante.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/prevFrame()"><linktext>prevFrame()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:nextScene"><apiName>nextScene</apiName><shortdesc>
	 Place la tête de lecture sur la séquence suivante de l’occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Place la tête de lecture sur la séquence suivante de l’occurrence de MovieClip. Cette opération se produit lorsque l’exécution de toutes les autres actions de l’image est terminée.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> Dans l’exemple suivant, deux objets SimpleButton contrôlent le scénario. Le bouton <codeph>prevBtn</codeph> déplace la tête de lecture vers la séquence précédente alors que le bouton <codeph>nextBtn</codeph> la déplace vers la séquence suivante.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:play"><apiName>play</apiName><shortdesc>
	 Déplace la tête de lecture dans le scénario du clip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.play, play
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Déplace la tête de lecture dans le scénario du clip.
	 
	 </apiDesc><example conref="examples\MovieClip.play.1.as"> Le code suivant exploite la méthode pour arrêter un clip <codeph>stop()</codeph> appelé <codeph>mc1</codeph> et pour reprendre la lecture lorsque l’utilisateur clique sur le champ de texte appelé <codeph>continueText</codeph> :
<codeblock>

import flash.text.TextField;
import flash.events.MouseEvent;

var continueText:TextField = new TextField();
continueText.text = "Play movie...";
addChild(continueText);

mc1.stop();
continueText.addEventListener(MouseEvent.CLICK, resumeMovie);

function resumeMovie(event:MouseEvent):void {
    mc1.play();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>gotoAndPlay()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:prevFrame"><apiName>prevFrame</apiName><shortdesc>
	 Place la tête de lecture sur l’image précédente et l’arrête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.prevframe, prevframe, previous frame
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Place la tête de lecture sur l’image précédente et l’arrête. Cette opération se produit lorsque l’exécution de toutes les autres actions de l’image est terminée.
	  
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> Dans l’exemple suivant, deux objets SimpleButton contrôlent le scénario. Le bouton <codeph>prev</codeph> déplace la tête de lecture vers l’image précédente alors que le bouton <codeph>nextBtn</codeph> la déplace vers l’image suivante.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:prevScene"><apiName>prevScene</apiName><shortdesc>
	 Place la tête de lecture sur la séquence précédente de l’occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Place la tête de lecture sur la séquence précédente de l’occurrence de MovieClip. Cette opération se produit lorsque l’exécution de toutes les autres actions de l’image est terminée.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> Dans l’exemple suivant, deux objets SimpleButton contrôlent le scénario. Le bouton <codeph>prevBtn</codeph> déplace la tête de lecture vers la séquence précédente alors que le bouton <codeph>nextBtn</codeph> la déplace vers la séquence suivante.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:stop"><apiName>stop</apiName><shortdesc>
	 Arrête la tête de lecture dans le clip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.stop, stop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Arrête la tête de lecture dans le clip.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:MovieClip:currentFrame:get"><apiName>currentFrame</apiName><shortdesc>
	 Spécifie le numéro de l’image où réside la tête de lecture dans le scénario de l’occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.currentFrame, currentFrame, currentFrame
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le numéro de l’image où réside la tête de lecture dans le scénario de l’occurrence de MovieClip. Si le clip contient plusieurs séquences, cette valeur correspond au numéro de l’image dans la séquence en cours.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> L’exemple suivant utilise la méthode <codeph>gotoAndStop()</codeph> et la propriété <codeph>currentFrame</codeph> pour diriger la tête de lecture du clip <codeph>mc1</codeph> pour avancer de cinq images par rapport à sa position actuelle et s’arrêter :
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentFrameLabel:get"><apiName>currentFrameLabel</apiName><shortdesc>
	 Etiquette de l’image actuelle dans le scénario de l’occurrence MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Etiquette de l’image actuelle dans le scénario de l’occurrence MovieClip. Si l’image actuelle ne possède aucune étiquette, <codeph>currentLabel</codeph> est <codeph>null</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrameLabel.1.as"/></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabel:get"><apiName>currentLabel</apiName><shortdesc>
	 Etiquette où réside actuellement la tête de lecture dans le scénario de l’occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Etiquette où réside actuellement la tête de lecture dans le scénario de l’occurrence de MovieClip. Si l’image suivante ne dispose pas d’étiquette, <codeph>currentLabel</codeph> est défini en fonction du nom de la première image ayant inclus une étiquette. Si l’image actuelle et les images précédentes n’incluent pas d’étiquette, <codeph>currentLabel</codeph> renvoie <codeph>null</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabel.1.as"> Le code suivant illustre comment accéder à la propriété <codeph>currentLabel</codeph> d’un objet MovieClip appelé <codeph>mc1</codeph> :
<codeblock>
trace(mc1.currentLabel);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabels:get"><apiName>currentLabels</apiName><shortdesc>
	 Renvoie un tableau des objets FrameLabel extraits de la séquence en cours.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Renvoie un tableau des objets FrameLabel extraits de la séquence en cours. Si l’occurrence de MovieClip n’utilise pas de séquence, le tableau comprend toutes les étiquettes d’image extraites de la totalité de l’occurrence de MovieClip.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabels.1.as"> Le code suivant illustre le mode d’utilisation de la propriété <codeph>currentLabels</codeph> d’un objet MovieClip appelé <codeph>mc1</codeph> :
<codeblock>
import flash.display.FrameLabel;
 
var labels:Array = mc1.currentLabels;

for (var i:uint = 0; i &lt; labels.length; i++) {
    var label:FrameLabel = labels[i];
    trace("frame " + label.frame + ": " + label.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>flash.display.FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:currentScene:get"><apiName>currentScene</apiName><shortdesc>
	 Séquence où réside actuellement la tête de lecture dans le scénario de l’occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Scene</apiValueClassifier></apiValueDef><apiDesc>
	 Séquence où réside actuellement la tête de lecture dans le scénario de l’occurrence de MovieClip.
	 
	 </apiDesc><example conref="examples\MovieClip.currentScene.1.as"> Le code suivant illustre le mode d’utilisation de la propriété <codeph>currentScene</codeph> d’un objet MovieClip appelé <codeph>mc1</codeph> :
<codeblock>
import flash.display.Scene;
 
var scene:Scene = mc1.currentScene;
trace(scene.name + ": " + scene.numFrames + " frames");
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scène</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Valeur booléenne indiquant si un clip est activé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur booléenne indiquant si un clip est activé. La valeur par défaut de <codeph>enabled</codeph> est <codeph>true</codeph>. Si <codeph>enabled</codeph> est défini sur <codeph>false</codeph>, les images Dessus, Abaissé et Haut du clip sont désactivées. Le clip continue à recevoir des événements (par exemple, <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>, <codeph>keyDown</codeph> et <codeph>keyUp</codeph>).
	 
	 <p>La propriété <codeph>enabled</codeph> gère uniquement les propriétés spécifiques aux boutons d’un clip. Vous pouvez modifier la propriété <codeph>enabled</codeph> à tout moment ; le clip modifié est immédiatement activé ou désactivé. Si la propriété <codeph>enabled</codeph> est définie sur <codeph>false</codeph>, l’objet n’est pas inclus dans l’ordre de tabulation automatique.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.enabled.1.as"> Le code suivant illustre le mode d’utilisation de la propriété <codeph>enabled</codeph> pour désactiver les propriétés de type bouton d’un objet MovieClip appelé <codeph>mc1</codeph> :
<codeblock>
mc1.enabled = false;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:framesLoaded:get"><apiName>framesLoaded</apiName><shortdesc>
	 Nombre d’images à charger à partir d’un fichier SWF en diffusion continue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.framesLoaded, framesLoaded, framesloaded
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’images à charger à partir d’un fichier SWF en diffusion continue. Vous pouvez utiliser la propriété <codeph>framesLoaded</codeph> pour déterminer si le contenu d’une image spécifique, ainsi que l’ensemble des images chargées précédemment sont disponibles de façon locale dans le navigateur. Vous pouvez également l’utiliser pour superviser le téléchargement de fichiers SWF volumineux. Par exemple, si désiré, affichez un message aux utilisateurs leur indiquant que le chargement du fichier SWF ne commencera pas tant que le chargement d’une image spécifiée dans le fichier SWF ne sera pas terminé.
	 
	 <p>Si le clip contient plusieurs séquences, la propriété <codeph>framesLoaded</codeph> renvoie le nombre d’images chargées pour <i>toutes</i> les séquences.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.framesLoaded.1.as"> Le code suivant illustre comment utiliser les propriétés <codeph>framesLoaded</codeph> et <codeph>totalFrames</codeph> pour déterminer si un objet MovieClip en flux continu appelé <codeph>mc1</codeph> est totalement chargé :
<codeblock>
if (mc1.framesLoaded == mc1.totalFrames) {
    trace("OK.");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>Classe Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:scenes:get"><apiName>scenes</apiName><shortdesc>
	 Tableau des objets Scene, chacun d’eux indiquant le nom, le nombre d’images et les étiquettes d’image d’une séquence dans l’occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Tableau des objets Scene, chacun d’eux indiquant le nom, le nombre d’images et les étiquettes d’image d’une séquence dans l’occurrence de MovieClip.
	 
	 </apiDesc><example conref="examples\MovieClip.scenes.1.as"> Le code suivant illustre le mode d’utilisation de la propriété <codeph>scenes</codeph> d’un objet MovieClip appelé <codeph>mc1</codeph> :
<codeblock>
import flash.display.Scene;
 
for (var i:uint = 0; i &lt; mc1.scenes.length; i++) {
    var scene:Scene = mc1.scenes[i];
    trace("scene " + scene.name + ": " + scene.numFrames + " frames");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scène</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:totalFrames:get"><apiName>totalFrames</apiName><shortdesc>
	 Nombre total d’images dans l’occurrence de MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.totalFrames, totalFrames, totalFrames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre total d’images dans l’occurrence de MovieClip.
	 
	 <p>Si le clip contient plusieurs images, la propriété <codeph>totalFrames</codeph> renvoie le nombre total d’images dans <i>all</i> les séquences.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.totalFrames.1.as"> Le code suivant illustre l’utilisation de la propriété <codeph>totalFrames</codeph> d’un objet MovieClip appelé <codeph>mc1</codeph> :
<codeblock>
 trace(mc1.totalFrames);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Indique si d’autres objets d’affichage de type SimpleButton ou MovieClip peuvent recevoir des événements de relâchement de souris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si d’autres objets d’affichage de type SimpleButton ou MovieClip peuvent recevoir des événements de relâchement de souris. La propriété <codeph>trackAsMenu</codeph> permet de créer des menus. Vous pouvez définir la propriété <codeph>trackAsMenu</codeph> sur n’importe quel objet SimpleButton ou MovieClip. La valeur par défaut de la propriété <codeph>trackAsMenu</codeph> est <codeph>false</codeph>. 
	 
	 <p>Vous pouvez modifier la propriété <codeph>trackAsMenu</codeph> à tout moment ; le clip modifié accepte immédiatement le nouveau comportement.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.trackAsMenu.1.as"> Le code suivant illustre comment utiliser la propriété <codeph>trackAsMenu</codeph> pour activer les événements de relâchement de la souris pour un objet MovieClip appelé <codeph>mc1</codeph> :
<codeblock>
 mc1.trackAsMenu = true;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SWFVersion"><apiName>SWFVersion</apiName><shortdesc>
	La classe SWFVersion est une énumération de valeurs constantes qui indiquent la version du format d’un fichier SWF chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	La classe SWFVersion est une énumération de valeurs constantes qui indiquent la version du format d’un fichier SWF chargé. Les constantes SWFVersion permettent de vérifier la propriété <codeph>swfVersion</codeph> d’un objet flash.display.LoaderInfo.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/swfVersion"><linktext>flash.display.LoaderInfo.swfVersion</linktext></link></related-links><apiValue id="flash.display:SWFVersion:FLASH1"><apiName>FLASH1</apiName><shortdesc>
		Version 1.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 1.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH10"><apiName>FLASH10</apiName><shortdesc>
		Version 10.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>10</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 10.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH2"><apiName>FLASH2</apiName><shortdesc>
		Version 2.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 2.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH3"><apiName>FLASH3</apiName><shortdesc>
		Version 3.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 3.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH4"><apiName>FLASH4</apiName><shortdesc>
		Version 4.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 4.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH5"><apiName>FLASH5</apiName><shortdesc>
		Version 5.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 5.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH6"><apiName>FLASH6</apiName><shortdesc>
		Version 6.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>6</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 6.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH7"><apiName>FLASH7</apiName><shortdesc>
		Version 7.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>7</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 7.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH8"><apiName>FLASH8</apiName><shortdesc>
		Version 8.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 8.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH9"><apiName>FLASH9</apiName><shortdesc>
		Version 9.0 du format de fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>9</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Version 9.0 du format de fichier SWF. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowResize"><apiName>NativeWindowResize</apiName><shortdesc>
La classe NativeWindowResize définit des constantes pour les valeurs possibles du paramètre edgeOrCorner de la méthode NativeWindow startResize().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe NativeWindowResize définit des constantes pour les valeurs possibles du paramètre <codeph>edgeOrCorner</codeph> de la méthode NativeWindow <codeph>startResize()</codeph>. 
<p>Une constante est définie pour nommer chaque bord et chaque angle d’une fenêtre.</p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow/startResize()"><linktext>flash.display.NativeWindow.startResize()</linktext></link></related-links><apiValue id="flash.display:NativeWindowResize:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
Le bord inférieur de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Le bord inférieur de la fenêtre. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
L’angle inférieur gauche de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
L’angle inférieur gauche de la fenêtre. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
L’angle inférieur droit de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
L’angle inférieur droit de la fenêtre. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:LEFT"><apiName>LEFT</apiName><shortdesc>
Le bord gauche de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Le bord gauche de la fenêtre.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:NONE"><apiName>NONE</apiName><shortdesc>
Ne fournit aucun conseil au système sur le bord ou l’angle à partir duquel redimensionner, autorisant le comportement par défaut.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Ne fournit aucun conseil au système sur le bord ou l’angle à partir duquel redimensionner, autorisant le comportement par défaut.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:RIGHT"><apiName>RIGHT</apiName><shortdesc>
Le bord droit de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Le bord droit de la fenêtre. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP"><apiName>TOP</apiName><shortdesc>
Le bord supérieur de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Le bord supérieur de la fenêtre. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
L’angle supérieur gauche de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
L’angle supérieur gauche de la fenêtre. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
L’angle supérieur droit de la fenêtre.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
L’angle supérieur droit de la fenêtre. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapDataChannel"><apiName>BitmapDataChannel</apiName><shortdesc>
La classe BitmapDataChannel est une énumération de valeurs constantes qui désignent le canal à utiliser : rouge, bleu, vert ou transparence alpha.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe BitmapDataChannel est une énumération de valeurs constantes qui désignent le canal à utiliser : rouge, bleu, vert ou transparence alpha. 

<p>Lorsque vous appelez certaines méthodes, vous pouvez utiliser l’opérateur OR au niveau du bit (<codeph>|</codeph>) pour combiner les constantes BitmapDataChannel de sorte à indiquer des canaux de couleur multiples.</p>

<p>Les constantes BitmapDataChannel sont utilisées en tant que valeurs comme suit :</p>

<ul>

	<li>dans les paramètres <codeph>sourceChannel</codeph> et <codeph>destChannel</codeph> de la méthode <codeph>flash.display.BitmapData.copyChannel()</codeph>,</li>

	<li>dans le paramètre <codeph>channelOptions</codeph> de la méthode <codeph>flash.display.BitmapData.noise()</codeph>,</li>

	<li>dans les propriétés <codeph>flash.filters.DisplacementMapFilter.componentX</codeph> et <codeph>flash.filters.DisplacementMapFilter.componentY</codeph>.</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/copyChannel()"><linktext>flash.display.BitmapData.copyChannel()</linktext></link><link href="flash.display.xml#BitmapData/noise()"><linktext>flash.display.BitmapData.noise()</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentX"><linktext>flash.filters.DisplacementMapFilter.componentX</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentY"><linktext>flash.filters.DisplacementMapFilter.componentY</linktext></link></related-links><apiValue id="flash.display:BitmapDataChannel:ALPHA"><apiName>ALPHA</apiName><shortdesc>
		Canal alpha.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Canal alpha. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:BLUE"><apiName>BLUE</apiName><shortdesc> 
		Canal bleu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		Canal bleu. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:GREEN"><apiName>GREEN</apiName><shortdesc>
		Canal vert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Canal vert.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:RED"><apiName>RED</apiName><shortdesc>
		Canal rouge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Canal rouge. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Définit un remplissage solide.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit un remplissage solide. 
 
 <p>
 Utilisez l’objet GraphicsSolidFill avec la méthode <codeph>Graphics.drawGraphicsData()</codeph>. Dessiner un objet GraphicsSolidFill revient à appeler la méthode <codeph>Graphics.beginFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>flash.display.Graphics.beginFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsSolidFill:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Crée un nouvel objet GraphicsSolidFill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur de couleur. Les valeurs disponibles sont au format hexadécimal 0xRRGGBB.  
 </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur de transparence alpha. Les valeurs disponibles sont comprises entre 0 (entièrement transparent) et 1 (entièrement opaque).
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Crée un nouvel objet GraphicsSolidFill. 
 
 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:GraphicsSolidFill:alpha"><apiName>alpha</apiName><shortdesc>
 Indique la valeur de transparence alpha du remplissage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Indique la valeur de transparence alpha du remplissage. Les valeurs gérées sont comprises entre 0 (entièrement transparent) et 1 (entièrement opaque). La valeur par défaut est 1. Les objets d’affichage où alpha est défini sur 0 sont actifs, même s’ils sont invisibles. 
 
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsSolidFill:color"><apiName>color</apiName><shortdesc>
 Couleur du remplissage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
 Couleur du remplissage. Les valeurs disponibles sont au format hexadécimal 0xRRGGBB. La valeur par défaut est 0xFF0000 (ou uint 0). 
 
 
 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IBitmapDrawable"><apiName>IBitmapDrawable</apiName><shortdesc>
	L’interface IBitmapDrawable est implémentée par des objets qui peuvent être transmis en tant que paramètre source de la méthode draw() à la classe BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	L’interface IBitmapDrawable est implémentée par des objets qui peuvent être transmis en tant que paramètre <codeph>source</codeph> de la méthode <codeph>draw()</codeph> à la classe BitmapData. Ces objets sont de type BitmapData ou DisplayObject. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:CapsStyle"><apiName>CapsStyle</apiName><shortdesc>
 La classe CapsStyle est une énumération de valeurs constantes qui spécifient le style d’extrémité à utiliser pour tracer les lignes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe CapsStyle est une énumération de valeurs constantes qui spécifient le style d’extrémité à utiliser pour tracer les lignes. Ces constantes sont utilisées en tant que valeurs du paramètre <codeph>caps</codeph> dans la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>. Vous pouvez spécifier les trois types d’extrémités suivants :
 
 <p><adobeimage alt="Les trois types d’extrémités : NONE, ROUND et SQUARE." href="../../images/linecap.jpg"/></p> 
 
 </apiDesc><example conref="examples\CapsStyleExample.as"> L’exemple suivant utilise la classe <codeph>CapsStyleExample</codeph> pour dessiner trois lignes parallèles, chacune disposant d’un style d’extrémité de ligne différent.
 <ol>
     <li>Les propriétés de chaque ligne sont définies comme suit :
     <ul>
         <li>La longueur de ligne est définie sur 80 pixels.</li>
         <li>La couleur de la bordure est définie sur orange.</li>
         <li>La taille de la bordure est définie sur 30 pixels. </li>
         <li>La couleur de surbrillance est définie sur gris. </li>
         <li>La taille de la surbrillance est définie sur 0 pixel.</li>
         <li>La valeur alpha est définie sur 1, ce qui rend la couleur unie.</li>
         <li>L’indice de lissage des pixels est défini sur false (les traits ne sont pas transformés en pixels).</li>
         <li>Le mode de mise à l’échelle de la ligne est défini sur normal. Ce mode porte sur l’épaisseur de la ligne. </li>
         <li>Le style de liaison des extrémités de la bordure est défini sur <codeph>MITER</codeph>.</li>
         <li>La limite de pointe est définie sur 1, ce qui signifie que la pointe est coupée près de la ligne.</li>
     </ul></li>
    <li>Le constructeur de classe crée trois lignes verticales, qui commencent à <i>x = 0, y = 0</i> en appelant la méthode <codeph>drawLine()</codeph> trois fois à l’aide de trois styles d’extrémité de ligne différents (none, round et square). Ces trois types d’appel de la méthode <codeph>drawLine()</codeph> utilisent le style d’extrémité et les propriétés énumérés précédemment pour dessiner une ligne verticale et la surbrillance de ligne correspondante. Les appels créent tout d’abord un objet Shape, <codeph>child</codeph>, puis exploite les méthodes de la classe Graphics pour définir le style de ligne et dessiner les lignes et les surbrillances. Chaque occurrence de <codeph>child</codeph> s’ajoute à la liste d’affichage et est dessinée sur la scène.</li>
     <li>Les segments de ligne connectés sont redessinés avec la méthode <codeph>refreshLayout()</codeph> à <i>y = 80</i> pixels et commence à <i>x = 80</i> pixels, avec une séparation de 25 pixels entre les segments de ligne.</li>
 </ol>
<codeblock>
package {
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class CapsStyleExample extends Sprite {
        private var lineLength:uint            = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderJointStyle:String    = JointStyle.MITER;
        private var borderMiterLimit:uint      = 1;

        public function CapsStyleExample() {
            drawLine(CapsStyle.NONE);
            drawLine(CapsStyle.ROUND);
            drawLine(CapsStyle.SQUARE);
            refreshLayout();
        }

        private function drawLine(capsStyle:String):void {
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     capsStyle,
                                     borderJointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = lineLength;
            lastChild.y = lineLength;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = lineLength;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:CapsStyle:NONE"><apiName>NONE</apiName><shortdesc>
	 
	 Permet de ne pas employer d’extrémités à l’aide du paramètre caps de la méthode flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Permet de ne pas utiliser d’extrémités à l’aide du paramètre <codeph>caps</codeph> de la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	 
	 Permet de spécifier les extrémités arrondies du paramètre caps de la méthode flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Permet de spécifier les extrémités arrondies du paramètre <codeph>caps</codeph> de la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:SQUARE"><apiName>SQUARE</apiName><shortdesc>
	 
	 Permet de spécifier les extrémités carrées du paramètre caps de la méthode flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>square</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 Permet de spécifier des extrémités carrées à l’aide du paramètre <codeph>caps</codeph> de la méthode <codeph>flash.display.Graphics.lineStyle()</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageScaleMode"><apiName>StageScaleMode</apiName><shortdesc>
La classe StageScaleMode fournit les valeurs de la propriété Stage.scaleMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe StageScaleMode fournit les valeurs de la propriété <codeph>Stage.scaleMode</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/scaleMode"><linktext>flash.display.Stage.scaleMode</linktext></link></related-links><apiValue id="flash.display:StageScaleMode:EXACT_FIT"><apiName>EXACT_FIT</apiName><shortdesc>
Indique que l’application entière est visible dans la zone spécifiée, sans tenter de conserver le rapport largeur/hauteur d’origine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exactFit</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Indique que l’application entière est visible dans la zone spécifiée, sans tenter de conserver le rapport largeur/hauteur d’origine. Une distorsion risque de se produire.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_BORDER"><apiName>NO_BORDER</apiName><shortdesc>
Spécifie que l’application entière remplit la zone spécifiée, sans distorsion mais avec un recadrage éventuel, tout en conservant le rapport largeur/hauteur d’origine de l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noBorder</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que l’application entière remplit la zone spécifiée, sans distorsion mais avec un recadrage éventuel, tout en conservant le rapport largeur/hauteur d’origine de l’application.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_SCALE"><apiName>NO_SCALE</apiName><shortdesc>
Spécifie que la taille de l’application doit être fixe, afin de ne pas être modifiée même si la taille de la fenêtre du lecteur change.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noScale</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la taille de l’application doit être fixe, afin de ne pas être modifiée même si la taille de la fenêtre du lecteur change. Un recadrage risque de se produire si la fenêtre du lecteur est plus petite que le contenu.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:SHOW_ALL"><apiName>SHOW_ALL</apiName><shortdesc>
Spécifie que l’application entière est visible dans la zone spécifiée, sans distorsion, tout en conservant le rapport largeur/hauteur d’origine de l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>showAll</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que l’application entière est visible dans la zone spécifiée, sans distorsion, tout en conservant le rapport largeur/hauteur d’origine de l’application. Des bordures peuvent apparaître de part et d’autre de l’application.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SpreadMethod"><apiName>SpreadMethod</apiName><shortdesc>
La classe SpreadMethod fournit les valeurs du paramètre spreadMethod dans les méthodes beginGradientFill() et lineGradientStyle() de la classe Graphics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe SpreadMethod fournit les valeurs du paramètre <codeph>spreadMethod</codeph> dans les méthodes <codeph>beginGradientFill()</codeph> et <codeph>lineGradientStyle()</codeph> de la classe Graphics.

<p>L’exemple suivant illustre le même remplissage dégradé basé sur des méthodes d’étalement différentes :</p>

<adobetable>





<tgroup cols="3"><tbody><row>

	<entry align="center"><adobeimage alt="dégradé linéaire avec SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>

  <entry align="center"><adobeimage alt="dégradé linéaire avec SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>

  <entry align="center"><adobeimage alt="dégradé linéaire avec SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>

</row><row>

	 <entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>


</row></tbody></tgroup></adobetable>


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:SpreadMethod:PAD"><apiName>PAD</apiName><shortdesc>
Spécifie que le dégradé utilise la méthode d’étalement pad.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pad</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que le dégradé utilise la méthode d’étalement <i>pad</i>.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REFLECT"><apiName>REFLECT</apiName><shortdesc>
Spécifie que le dégradé utilise la méthode d’étalement reflect.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reflect</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que le dégradé utilise la méthode d’étalement <i>reflect</i>.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REPEAT"><apiName>REPEAT</apiName><shortdesc>
Spécifie que le dégradé utilise la méthode d’étalement repeat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>repeat</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que le dégradé utilise la méthode d’étalement <i>repeat</i>.
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:FocusDirection"><apiName>FocusDirection</apiName><shortdesc>
 La classe FocusDirection énumère les valeurs à utiliser pour le paramètre direction de la méthode assignFocus() d’un objet Stage et pour la propriété direction d’un objet FocusEvent.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe FocusDirection énumère les valeurs à utiliser pour le paramètre <codeph>direction</codeph> de la méthode <codeph>assignFocus()</codeph> d’un objet Stage et pour la propriété <codeph>direction</codeph> d’un objet FocusEvent.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#FocusEvent/direction"><linktext>flash.events.FocusEvent.direction</linktext></link><link href="flash.display.xml#Stage/assignFocus()"><linktext>flash.display.Stage.assignFocus()</linktext></link></related-links><apiValue id="flash.display:FocusDirection:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
		Indique que le focus doit être attribué à l’objet situé à la fin de l’ordre de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bottom</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Indique que le focus doit être attribué à l’objet situé à la fin de l’ordre de lecture.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:NONE"><apiName>NONE</apiName><shortdesc>
		Indique que l’objet de focus au sein de l’objet interactif ne doit pas changer.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Indique que l’objet de focus au sein de l’objet interactif ne doit pas changer.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:TOP"><apiName>TOP</apiName><shortdesc>
		Indique que le focus doit être attribué à l’objet situé au début de l’ordre de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>top</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Indique que le focus doit être attribué à l’objet situé au début de l’ordre de lecture.
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageAlign"><apiName>StageAlign</apiName><shortdesc>
La classe StageAlign fournit les valeurs constantes à utiliser pour la propriété Stage.align.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe StageAlign fournit les valeurs constantes à utiliser pour la propriété <codeph>Stage.align</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/align"><linktext>flash.display.Stage.align</linktext></link></related-links><apiValue id="flash.display:StageAlign:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
Spécifie que la scène est alignée sur le bas.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur le bas. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
Spécifie que la scène est alignée sur le coin inférieur gauche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur le coin inférieur gauche. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
Spécifie que la scène est alignée sur le coin inférieur droit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur le coin inférieur droit. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
Spécifie que la scène est alignée sur la gauche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur la gauche. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
Spécifie que la scène est alignée sur la droite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur la droite. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP"><apiName>TOP</apiName><shortdesc>
Spécifie que la scène est alignée sur le haut.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur le haut. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
Spécifie que la scène est alignée sur le coin supérieur gauche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur le coin supérieur gauche. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
Spécifie que la scène est alignée sur le coin supérieur droit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Spécifie que la scène est alignée sur le coin supérieur droit. 
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrectionSupport"><apiName>ColorCorrectionSupport</apiName><shortdesc>
La classe ColorCorrectionSupport fournit les valeurs de la propriété flash.display.Stage.colorCorrectionSupport.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe ColorCorrectionSupport fournit les valeurs de la propriété <codeph>flash.display.Stage.colorCorrectionSupport</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>flash.display.Stage.colorCorrectionSupport</linktext></link></related-links><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_OFF"><apiName>DEFAULT_OFF</apiName><shortdesc>
La correction des couleurs est prise en charge et est par défaut désactivée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOff</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
La correction des couleurs est prise en charge et est par défaut désactivée. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_ON"><apiName>DEFAULT_ON</apiName><shortdesc>
La correction des couleurs est prise en charge et est par défaut activée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOn</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
La correction des couleurs est prise en charge et est par défaut activée. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:UNSUPPORTED"><apiName>UNSUPPORTED</apiName><shortdesc>
La correction des couleurs n’est pas prise en charge par l’environnement hôte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>unsupported</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
La correction des couleurs n’est pas prise en charge par l’environnement hôte. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
 Définit un remplissage shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit un remplissage shader. 
 
 <p>
 Utilisez l’objet GraphicsShaderFill avec la méthode <codeph>Graphics.drawGraphicsData()</codeph>. Dessiner un objet GraphicsShaderFill revient à appeler la méthode <codeph>Graphics.beginShaderFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsShaderFill:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
     Crée un nouvel objet GraphicsShaderFill.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Shader à utiliser pour le remplissage. Cette occurrence Shader n’est pas obligatoire pour spécifier une entrée d’image. Toutefois, lorsqu’une entrée d’image est spécifiée dans le shader, l’entrée doit être fournie manuellement par la définition de la propriété <codeph>input</codeph> pour la propriété ShaderInput correspondante de la propriété <codeph>Shader.data</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet matrice (de la classe flash.geom.Matrix), que vous pouvez utiliser pour définir des transformations sur le shader. 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un nouvel objet GraphicsShaderFill.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsShaderFill:matrix"><apiName>matrix</apiName><shortdesc>
     Objet matrice (de la classe flash.geom.Matrix), que vous pouvez utiliser pour définir des transformations sur le shader.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Objet matrice (de la classe flash.geom.Matrix), que vous pouvez utiliser pour définir des transformations sur le shader. Par exemple, vous pouvez utiliser la matrice suivante pour faire pivoter un shader de 45 degrés (pi/4 radians) :
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     <p>Les coordonnées reçues dans le shader sont basées sur la matrice spécifiée dans le paramètre <codeph>matrix</codeph>. Dans le cas d’une matrice par défaut (<codeph>null</codeph>), les coordonnées dans le shader sont en coordonnées de pixel locales qui peuvent être utilisées pour échantillonner une entrée.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsShaderFill:shader"><apiName>shader</apiName><shortdesc>
     Shader à utiliser pour le remplissage. </shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
     Shader à utiliser pour le remplissage. Cette occurrence Shader n’est pas obligatoire pour spécifier une entrée d’image. Toutefois, lorsqu’une entrée d’image est spécifiée dans le shader, l’entrée doit être fournie manuellement par la définition de la propriété <codeph>input</codeph> pour la propriété ShaderInput correspondante de la propriété <codeph>Shader.data</codeph>.
     
     <p>Lorsque vous transmettez une occurrence Shader sous forme d’argument, le shader est copié en interne et l’opération de remplissage utilise cette copie interne, et non une référence au shader d’origine. Toute modification apportée au shader, par exemple la modification de la valeur d’un paramètre, l’entrée ou le pseudo-code binaire, n’est pas appliquée au shader copié utilisé pour le remplissage.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Shape"><apiName>Shape</apiName><shortdesc>
 Cette classe sert à créer des formes légères par le biais de l’interface de programmation d’applications (API) de dessin ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Objet d’affichage utilisé pour les formes.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Cette classe sert à créer des formes légères par le biais de l’interface de programmation d’applications (API) de dessin ActionScript. Cette classe comprend une propriété <codeph>graphics</codeph>, qui vous permet d’accéder aux méthodes de la classe Graphics.
 
 <p>La classe Sprite comporte également une propriété <codeph>graphics</codeph>, ainsi que d’autres fonctions exclues de la classe Shape. Par exemple, un objet Sprite est un conteneur d’objet d’affichage, ce qui n’est pas le cas d’un objet Shape (qui ne peut pas contenir d’objets d’affichage enfant). De ce fait, les objets Shape consomment moins de mémoire que les objets Sprite qui contiennent les mêmes images. Toutefois, un objet Sprite prend en charge les éléments associés à un clic de souris, ce qui n’est pas le cas d’un objet Shape.</p>
 
 </apiDesc><example conref="examples\ShapeExample.as"> L’exemple suivant utilise la classe <codeph>ShapeExample</codeph> pour dessiner un cercle, un rectangle arrondi et un carré. Pour ce faire, procédez comme suit :
 
 <ol>
    <li>Elle déclare la propriété <codeph>size</codeph> qui servira par la suite à déterminer la taille de chaque forme.</li>
 
     <li>Elle déclare les propriétés qui définissent la couleur de fond sur orange, la couleur de bordure sur gris foncé, la taille de la bordure sur 0 pixel, le rayon de l’angle sur 9 pixels et définit l’espace entre le bord de la scène et les autres objets sur 5 pixels.</li>
 
    <li>Utilisez les propriétés déclarées au cours des étapes précédentes, ainsi que les méthodes intégrées de la classe Graphics pour dessiner le cercle, le rectangle arrondi et le carré aux coordonnées x = 0, y = 0.</li>
 
    <li>Elle redessine les formes situées le long de la partie supérieure de la scène, en commençant par x = 5, y = 5, avec un espacement de 5 pixels entre les formes à l’aide de la méthode <codeph>refreshLayout()</codeph>.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class ShapeExample extends Sprite {
        private var size:uint           = 80;
        private var bgColor:uint       = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function ShapeExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size/2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#Sprite"><linktext>flash.display.Sprite</linktext></link></related-links><apiConstructor id="flash.display:Shape:Shape"><apiName>Shape</apiName><shortdesc>
     Crée un objet Shape.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Crée un objet Shape.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shape:graphics:get"><apiName>graphics</apiName><shortdesc>
     Spécifie l’objet Graphics qui appartient à l’objet Shape qui prend en charge les commandes de dessin vectoriel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Spécifie l’objet Graphics associé à l’objet Shape.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Spécifie l’objet Graphics qui appartient à l’objet Shape qui prend en charge les commandes de dessin vectoriel.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameterType"><apiName>ShaderParameterType</apiName><shortdesc>
	 Cette classe définit les constantes qui représentent les valeurs possibles de la propriété type de la classe ShaderParameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Cette classe définit les constantes qui représentent les valeurs possibles de la propriété <codeph>type</codeph> de la classe ShaderParameter. Chaque constante représente l’un des types de données disponibles dans Flash Player pour définir les paramètres dans le langage shader de Pixel Bender.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links><apiValue id="flash.display:ShaderParameterType:BOOL"><apiName>BOOL</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur bool, ce qui correspond à une unique occurrence Boolean dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>bool</codeph>, ce qui correspond à une unique occurrence Boolean dans ActionScript.
		 
		 <p>Notez que, bien que le paramètre n’attende qu’une seule valeur, la propriété <codeph>ShaderParameter.value</codeph> est un tableau ; cette valeur unique doit donc être le seul élément d’un tableau affecté à la propriété <codeph>value</codeph>, tel que :</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is bool
		 myShader.data.param.value = [true];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL2"><apiName>BOOL2</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur bool2, ce qui correspond à un tableau de deux occurrences Boolean dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>bool2</codeph>, ce qui correspond à un tableau de deux occurrences Boolean dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL3"><apiName>BOOL3</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur bool3, ce qui correspond à un tableau de trois occurrences Boolean dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>bool3</codeph>, ce qui correspond à un tableau de trois occurrences Boolean dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL4"><apiName>BOOL4</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur bool4, ce qui correspond à un tableau de quatre occurrences Boolean dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>bool4</codeph>, ce qui correspond à un tableau de quatre occurrences Boolean dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT"><apiName>FLOAT</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur float, ce qui correspond à une unique occurrence Number dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>float</codeph>, ce qui correspond à une unique occurrence Number dans ActionScript.
		 
		 <p>Notez que, bien que le paramètre n’attende qu’une seule valeur, la propriété <codeph>ShaderParameter.value</codeph> est un tableau ; cette valeur unique doit donc être le seul élément d’un tableau affecté à la propriété <codeph>value</codeph>, tel que :</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is float
		 myShader.data.param.value = [22.5];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT2"><apiName>FLOAT2</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur float2, ce qui correspond à un tableau de deux occurrences Number dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>float2</codeph>, ce qui correspond à un tableau de deux occurrences Number dans ActionScript.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT3"><apiName>FLOAT3</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur float3, ce qui correspond à un tableau de trois occurrences Number dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>float3</codeph>, ce qui correspond à un tableau de trois occurrences Number dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT4"><apiName>FLOAT4</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur float4, ce qui correspond à un tableau de quatre occurrences Number dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>float4</codeph>, ce qui correspond à un tableau de quatre occurrences Number dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT"><apiName>INT</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur int, ce qui correspond à une unique occurrence int ou uint dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>int</codeph>, ce qui correspond à une unique occurrence int ou uint dans ActionScript.
		 
		 <p>Notez que, bien que le paramètre n’attende qu’une seule valeur, la propriété <codeph>ShaderParameter.value</codeph> est un tableau ; cette valeur unique doit donc être le seul élément d’un tableau affecté à la propriété <codeph>value</codeph>, tel que :</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is int
		 myShader.data.param.value = [275];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT2"><apiName>INT2</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur int2, ce qui correspond à un tableau de deux occurrences int ou uint dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>int2</codeph>, ce qui correspond à un tableau de deux occurrences int ou uint dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT3"><apiName>INT3</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur int3, ce qui correspond à un tableau de trois occurrences int ou uint dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>int3</codeph>, ce qui correspond à un tableau de trois occurrences int ou uint dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT4"><apiName>INT4</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur int4, ce qui correspond à un tableau de quatre occurrences int ou uint dans ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>int4</codeph>, ce qui correspond à un tableau de quatre occurrences int ou uint dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX2X2"><apiName>MATRIX2X2</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur float2x2, ce qui correspond à une matrice 2 par 2.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix2x2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>float2x2</codeph>, ce qui correspond à une matrice 2 par 2. Cette matrice est représentée par un tableau de quatre occurrences Number dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX3X3"><apiName>MATRIX3X3</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur float3x3, ce qui correspond à une matrice 3 par 3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix3x3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>float3x3</codeph>, ce qui correspond à une matrice 3 par 3. Cette matrice est représentée par un tableau de neuf occurrences Number dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX4X4"><apiName>MATRIX4X4</apiName><shortdesc>
		 Indique que le paramètre du shader est défini en tant que valeur float4x4, ce qui correspond à une matrice 4 par 4.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix4x4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique que le paramètre du shader est défini en tant que valeur <codeph>float4x4</codeph>, ce qui correspond à une matrice 4 par 4. Cette matrice est représentée par un tableau de 16 occurrences Number dans ActionScript.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathWinding"><apiName>GraphicsPathWinding</apiName><shortdesc>
La classe GraphicsPathWinding fournit des valeurs pour la propriété flash.display.GraphicsPath.winding et la méthode flash.display.Graphics.drawPath() afin de déterminer la direction du tracé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe GraphicsPathWinding fournit des valeurs pour la propriété <codeph>flash.display.GraphicsPath.winding</codeph> et la méthode <codeph>flash.display.Graphics.drawPath()</codeph> afin de déterminer la direction du tracé. Un tracé en sens horaire est enroulé positivement et un tracé en sens anti-horaire est enroulé négativement :
<p><adobeimage alt="direction d’enroulement positif et négatif" href="../../images/winding_positive_negative.gif"/></p>
<p> Lorsque les tracés se croisent ou se chevauchent, la direction d’enroulement détermine les règles de remplissage des zones créées par l’intersection ou le chevauchement :</p>
<p><adobeimage alt="une comparaison entre les règles d’enroulement pair/impair et non nul" href="../../images/winding_rules_evenodd_nonzero.gif"/></p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#GraphicsPath/winding"><linktext>flash.display.GraphicsPath.winding</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiValue id="flash.display:GraphicsPathWinding:EVEN_ODD"><apiName>EVEN_ODD</apiName><shortdesc>
Etablit le type d’enroulement pair/impair.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>evenOdd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Etablit le type d’enroulement pair/impair. Le type d’enroulement pair/impair correspond à la règle utilisée par toutes les API de dessin d’origine ; il correspond en outre au type d’enroulement par défaut pour la méthode <codeph>flash.display.Graphics.drawPath()</codeph>. Tous les tracés se chevauchant alterneront les remplissages ouverts et les remplissages fermés. Si deux carrés qui utilisent le même remplissage se croisent, la zone d’intersection n’est pas remplie. Les zones adjacentes ne sont pas les mêmes (elles ne sont ni toutes deux remplies, ni toutes deux vides). 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathWinding:NON_ZERO"><apiName>NON_ZERO</apiName><shortdesc>
Etablit le type d’enroulement non nul.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>nonZero</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Etablit le type d’enroulement non nul. Le type d’enroulement non nul indique que lorsque les tracés possédant des enroulements opposés se croisent, la zone d’intersection n’est pas remplie (comme avec le type d’enroulement pair/impair). Pour les tracés possédant le même type d’enroulement, l’intersection est remplie.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ActionScriptVersion"><apiName>ActionScriptVersion</apiName><shortdesc>
	La classe ActionScriptVersion est une énumération de valeurs constantes qui indiquent la version de langue du fichier SWF chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	La classe ActionScriptVersion est une énumération de valeurs constantes qui indiquent la version de langue du fichier SWF chargé. Les constantes de version du langage permettent de vérifier la propriété <codeph>actionScriptVersion</codeph> d’un objet flash.display.LoaderInfo.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/actionScriptVersion"><linktext>flash.display.LoaderInfo.actionScriptVersion</linktext></link></related-links><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT2"><apiName>ACTIONSCRIPT2</apiName><shortdesc>
		Langage ActionScript version 2.0 et antérieure.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Langage ActionScript version 2.0 et antérieure. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT3"><apiName>ACTIONSCRIPT3</apiName><shortdesc>
		Langage ActionScript version 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Langage ActionScript version 3.0. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
 Collection de commandes de dessin et de leurs paramètres de coordonnées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Collection de commandes de dessin et de leurs paramètres de coordonnées.
 <p>
 Utilisez un objet GraphicsPath avec la méthode <codeph>Graphics.drawGraphicsData()</codeph>. Dessiner un objet GraphicsPath revient à appeler la méthode <codeph>Graphics.drawPath()</codeph>.
 </p>
 <p>La classe GraphicsPath dispose également de son propre jeu de méthodes (<codeph>curveTo()</codeph>, <codeph>lineTo()</codeph>, <codeph>moveTo()</codeph> <codeph>wideLineTo()</codeph> et <codeph>wideMoveTo()</codeph>), similaire à celui de la classe Graphics, permettant d’effectuer des réglages sur les tableaux vectoriels <codeph>GraphicsPath.commands</codeph> et <codeph>GraphicsPath.data</codeph>.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsPath:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
     Crée un nouvel objet GraphicsPath.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Vecteur d’entiers représentant les commandes définies par la classe GraphicsPathCommand.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Vecteur de Nombres où chaque paire de nombres est traitée comme un point (paire x, y).
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Spécifie la règle d’enroulement à l’aide d’une valeur définie dans la classe GraphicsPathWinding.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un nouvel objet GraphicsPath.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:GraphicsPath:curveTo"><apiName>curveTo</apiName><shortdesc>
     Ajoute une nouvelle commande « curveTo » au vecteur commands et de nouvelles coordonnées au vecteur data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position horizontale du point de contrôle par rapport au point d’alignement de l’objet d’affichage parent.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position verticale du point de contrôle par rapport au point d’alignement de l’objet d’affichage parent.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position horizontale du point d’ancrage suivant par rapport au point d’alignement de l’objet d’affichage parent.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui spécifie la position verticale du point d’ancrage suivant par rapport au point d’alignement de l’objet d’affichage parent.
     
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute une nouvelle commande « curveTo » au vecteur <codeph>commands</codeph> et de nouvelles coordonnées au vecteur <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/CURVE_TO"><linktext>flash.display.GraphicsPathCommand.CURVE_TO</linktext></link><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:lineTo"><apiName>lineTo</apiName><shortdesc>
     Ajoute une nouvelle commande « lineTo » au vecteur commands et de nouvelles coordonnées au vecteur data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées x du point de destination pour la ligne.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées y du point de destination pour la ligne.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute une nouvelle commande « lineTo » au vecteur <codeph>commands</codeph> et de nouvelles coordonnées au vecteur <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>flash.display.GraphicsPathCommand.LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:moveTo"><apiName>moveTo</apiName><shortdesc>
     Ajoute une nouvelle commande « moveTo » au vecteur commands et de nouvelles coordonnées au vecteur data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées x du point de destination.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées y du point de destination.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute une nouvelle commande « moveTo » au vecteur <codeph>commands</codeph> et de nouvelles coordonnées au vecteur <codeph>data</codeph>.
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>flash.display.GraphicsPathCommand.MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideLineTo"><apiName>wideLineTo</apiName><shortdesc>
     Ajoute une nouvelle commande « wideLineTo » au vecteur commands et de nouvelles coordonnées au vecteur data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées x du point de destination pour la ligne.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées y du point de destination pour la ligne.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute une nouvelle commande « wideLineTo » au vecteur <codeph>commands</codeph> et de nouvelles coordonnées au vecteur <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_LINE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_LINE_TO</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideMoveTo"><apiName>wideMoveTo</apiName><shortdesc>
     Ajoute une nouvelle commande « wideMoveTo » au vecteur commands et de nouvelles coordonnées au vecteur data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées x du point de destination.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnées y du point de destination.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute une nouvelle commande « wideMoveTo » au vecteur <codeph>commands</codeph> et de nouvelles coordonnées au vecteur <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_MOVE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_MOVE_TO</linktext></link></related-links></apiOperation><apiValue id="flash.display:GraphicsPath:commands"><apiName>commands</apiName><shortdesc>
     Vecteur des commandes de dessin sous forme d’entiers représentant le tracé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     Vecteur des commandes de dessin sous forme d’entiers représentant le tracé. Chaque commande peut correspondre à l’une des valeurs définies par la classe GraphicsPathCommand.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPath:data"><apiName>data</apiName><shortdesc>
     Vecteur de nombres contenant les paramètres utilisés avec les commandes de dessin.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Vecteur de nombres contenant les paramètres utilisés avec les commandes de dessin.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPath:winding:get"><apiName>winding</apiName><shortdesc>
     Spécifie la règle d’enroulement à l’aide d’une valeur définie dans la classe GraphicsPathWinding.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie la règle d’enroulement à l’aide d’une valeur définie dans la classe GraphicsPathWinding.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:MorphShape"><apiName>MorphShape</apiName><shortdesc>
 La classe MorphShape représente les objets MorphShape figurant dans la liste d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe MorphShape représente les objets MorphShape figurant dans la liste d’affichage. Il est impossible de créer directement des objets MorphShape dans ActionScript. Ils sont créés lorsque vous générez une interpolation de forme dans l’outil de programmation Flash.
 
 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="flash.display:PixelSnapping"><apiName>PixelSnapping</apiName><shortdesc>

La classe PixelSnapping est une énumération de valeurs constantes destinées à la définition des options d’accrochage aux pixels par le biais de la propriété pixelSnapping d’un objet Bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

La classe PixelSnapping est une énumération de valeurs constantes destinées à la définition des options d’accrochage aux pixels par le biais de la propriété <codeph>pixelSnapping</codeph> d’un objet Bitmap.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/pixelSnapping"><linktext>flash.display.Bitmap.pixelSnapping</linktext></link></related-links><apiValue id="flash.display:PixelSnapping:ALWAYS"><apiName>ALWAYS</apiName><shortdesc>
	Valeur constante utilisée dans la propriété pixelSnapping d’un objet Bitmap pour spécifier que l’image bitmap est toujours accrochée au pixel le plus proche, quelle que soit la transformation appliquée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>always</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Valeur constante utilisée dans la propriété <codeph>pixelSnapping</codeph> d’un objet Bitmap pour spécifier que l’image bitmap est toujours accrochée au pixel le plus proche, quelle que soit la transformation appliquée.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:AUTO"><apiName>AUTO</apiName><shortdesc>
	Valeur constante utilisée dans la propriété pixelSnapping d’un objet Bitmap pour spécifier que l’image bitmap est accrochée au pixel le plus proche si elle est dessinée sans rotation ni inclinaison et que son facteur de redimensionnement est compris entre 99,9 % et 100,1 %.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>auto</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Valeur constante utilisée dans la propriété <codeph>pixelSnapping</codeph> d’un objet Bitmap pour spécifier que l’image bitmap est accrochée au pixel le plus proche si elle est dessinée sans rotation ni inclinaison et que son facteur de redimensionnement est compris entre 99,9 % et 100,1 %. Si ces conditions sont remplies, l’image est dessinée à l’échelle 100 % et accrochée au pixel le plus proche. En interne, ce réglage permet de dessiner l’image aussi rapidement que possible à l’aide de la fonctionnalité de rendu vectoriel.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:NEVER"><apiName>NEVER</apiName><shortdesc>
	Valeur constante utilisée dans la propriété pixelSnapping d’un objet Bitmap pour spécifier que l’accrochage aux pixels est désactivé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Valeur constante utilisée dans la propriété <codeph>pixelSnapping</codeph> d’un objet Bitmap pour spécifier que l’accrochage aux pixels est désactivé.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathCommand"><apiName>GraphicsPathCommand</apiName><shortdesc>
 Définit les valeurs devant être utilisées pour spécifier les commandes de tracé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Définit les valeurs devant être utilisées pour spécifier les commandes de tracé. 
 
 <p>Les valeurs de cette classe sont utilisées par la méthode <codeph>Graphics.drawPath()</codeph> ou stockées dans le vecteur <codeph>commands</codeph> d’un objet GraphicsPath.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link><link href="flash.display.xml#GraphicsPath/commands"><linktext>flash.display.GraphicsPath.commands</linktext></link></related-links><apiValue id="flash.display:GraphicsPathCommand:CURVE_TO"><apiName>CURVE_TO</apiName><shortdesc>
     Spécifie une commande de dessin traçant une courbe de la position actuelle du dessin vers les coordonnées x et y spécifiées dans le vecteur de données, à l’aide d’un point de contrôle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie une commande de dessin traçant une courbe de la position actuelle du dessin vers les coordonnées x et y spécifiées dans le vecteur de données, à l’aide d’un point de contrôle. Cette commande a le même effet que la méthode <codeph>Graphics.lineTo()</codeph> et utilise deux points (un point de contrôle et un point d’ancrage) dans le vecteur data : (cx, cy, ax, ay).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:LINE_TO"><apiName>LINE_TO</apiName><shortdesc>
     Spécifie une commande de dessin traçant une ligne de la position actuelle du dessin vers les coordonnées x et y spécifiées dans le vecteur de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie une commande de dessin traçant une ligne de la position actuelle du dessin vers les coordonnées x et y spécifiées dans le vecteur de données. Cette commande a le même effet que la méthode <codeph>Graphics.lineTo()</codeph> et utilise un point dans le vecteur data : (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:MOVE_TO"><apiName>MOVE_TO</apiName><shortdesc>
     Spécifie une commande de dessin se déplaçant vers les coordonnées de dessin actuelles x et y spécifiées dans le vecteur de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie une commande de dessin se déplaçant vers les coordonnées de dessin actuelles x et y spécifiées dans le vecteur de données. Cette commande a le même effet que la méthode <codeph>Graphics.moveTo()</codeph> et utilise un point dans le vecteur data : (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:NO_OP"><apiName>NO_OP</apiName><shortdesc>
     Représente la commande « Ne rien faire » par défaut.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Représente la commande « Ne rien faire » par défaut.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_LINE_TO"><apiName>WIDE_LINE_TO</apiName><shortdesc>
     Spécifie une commande de dessin « line to », mais utilise deux jeux de coordonnées (soit quatre valeurs) au lieu d’un.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie une commande de dessin « line to », mais utilise deux jeux de coordonnées (soit quatre valeurs) au lieu d’un. Cette commande vous permet de basculer entre les commandes « line to » et « curve to », sans modifier le nombre de valeurs de données utilisées par commande. Cette commande utilise deux jeux dans le vecteur data : un faux emplacement et un emplacement (x,y).
     
     <p>Les variantes des commandes <codeph>WIDE_LINE_TO</codeph> et <codeph>WIDE_MOVE_TO</codeph> consomment le même nombre de paramètres que la commande <codeph>CURVE_TO</codeph>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_MOVE_TO"><apiName>WIDE_MOVE_TO</apiName><shortdesc>
     Spécifie une commande de dessin « move to », mais utilise deux jeux de coordonnées (soit quatre valeurs) au lieu d’un.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie une commande de dessin « move to », mais utilise deux jeux de coordonnées (soit quatre valeurs) au lieu d’un. Cette commande vous permet de basculer entre les commandes « move to » et « curve to », sans modifier le nombre de valeurs de données utilisées par commande. Cette commande utilise deux jeux dans le vecteur data : un faux emplacement et un emplacement (x,y).
     
     <p>Les variantes des commandes <codeph>WIDE_LINE_TO</codeph> et <codeph>WIDE_MOVE_TO</codeph> consomment le même nombre de paramètres que la commande <codeph>CURVE_TO</codeph>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>