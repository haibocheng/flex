<?xml version="1.0"?>
<apiPackage id="flash.filesystem"><apiName>flash.filesystem</apiName><apiDetail/><apiClassifier id="flash.filesystem:FileStream"><apiName>FileStream</apiName><shortdesc>
 Un objet FileStream est utilisé pour lire et écrire des fichiers.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Un objet FileStream est utilisé pour lire et écrire des fichiers. Les fichiers peuvent être ouverts de façon synchrone en appelant la méthode <codeph>open()</codeph> ou de façon asynchrone en appelant la méthode <codeph>openAsync()</codeph>.
 
 <p>L’avantage de l’ouverture asynchrone des fichiers est qu’un autre code peut s’exécuter pendant que Adobe AIR exécute des processus de lecture et d’écriture en arrière-plan. Dans le cas d’une ouverture asynchrone, des événements <codeph>progress</codeph> sont distribués au fur et à mesure des opérations.</p>
 
 <p>Un objet File ouvert de façon synchrone se comporte un peu comme un objet ByteArray ; un fichier ouvert de façon asynchrone se comporte un peu comme un objet Socket ou URLStream Lorsqu’un objet File est ouvert de façon synchrone, l’appelant fait une pause pendant la lecture ou l’écriture des données demandées dans le fichier sous-jacent. Lorsqu’un fichier est ouvert de façon asynchrone, les données écrites dans le flux sont immédiatement mises en mémoire tampon et écrites ultérieurement dans le fichier.</p>
 
 <p>Que la lecture d’un fichier soit synchrone ou asynchrone, les méthodes de lecture réelles sont synchrones. Dans les deux cas, elles lisent les données actuellement « disponibles ». Lorsque les données sont lues de façon synchrone, elles sont toutes disponibles à tout moment. Alors que lors d’une lecture asynchrone, les données deviennent disponibles au fur et à mesure de leur arrivée dans le tampon de lecture. Dans les deux cas, les données pouvant être lues de façon synchrone à un moment donné sont représentées par la propriété <codeph>bytesAvailable</codeph>.</p>
 
 <p>Une application qui traite une entrée de façon asynchrone s’enregistre généralement pour les événements <codeph>progress</codeph> et consomme les données au fur et à mesure qu’elles deviennent disponibles en appelant des méthodes de lecture. L’application peut également se contenter d’attendre que toutes les données soient disponibles en s’enregistrant pour l’événement <codeph>complete</codeph> et en traitant l’ensemble des données lorsque cet événement <codeph>complete</codeph> est distribué. </p>
 
 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Indique que la fin du flux a été atteint.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Indique que la fin du flux a été atteint.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#FileStream/position"><linktext>position</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.OutputProgressEvent.OUTPUT_PROGRESS_outputProgress"><apiName>outputProgress</apiName><shortdesc>
 Indique que les données placées en mémoire tampon ont été écrites dans le fichier.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.OutputProgressEvent.OUTPUT_PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.OutputProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Indique que les données placées en mémoire tampon ont été écrites dans le fichier.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Signale la disponibilité de nouvelles données dans le flux.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Signale la disponibilité de nouvelles données dans le flux.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Indique qu’une erreur s’est produite lors d’une opération d’E/S de fichier asynchrone.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Indique qu’une erreur s’est produite lors d’une opération d’E/S de fichier asynchrone.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Indique que le flux a été fermé par un appel explicite à la méthode close().</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Indique que le flux a été fermé par un appel explicite à la méthode <codeph>close()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.filesystem:FileStream:FileStream"><apiName>FileStream</apiName><shortdesc>
	 Crée un objet FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Crée un objet FileStream. Utilise la méthode <codeph>open()</codeph> ou <codeph>openAsync()</codeph> pour ouvrir un fichier.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:FileStream:close"><apiName>close</apiName><shortdesc>
	 Ferme l’objet FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Ferme l’objet FileStream. 
	 
	 <p>Vous ne pouvez plus lire ni écrire des données après avoir appelé la méthode <codeph>close()</codeph>. Si le fichier a été ouvert de façon asynchrone (l’objet FileStream a utilisé la méthode <codeph>openAsync()</codeph> pour ouvrir le fichier), un appel à la méthode <codeph>close()</codeph> entraîne la distribution de l’événement <codeph>close</codeph> par l’objet. </p>
	 
	 <p>La fermeture de l’application entraîne la fermeture automatique de tous les fichiers associés aux objets FileStream de l’application. Toutefois, il est préférable d’enregistrer un événement <codeph>closed</codeph> pour tous les objets FileStream ouverts de façon asynchrone et qui ont des données en attente d’écriture avant de fermer l’application (afin de s’assurer que ces données soient écrites).</p>
	 
	 <p>Vous pouvez réutiliser l’objet FileStream en appelant la méthode <codeph>open()</codeph> ou la méthode <codeph>openAsync()</codeph>. Tous les fichiers associés à l’objet FileStream sont ainsi fermés, mais l’objet ne déclenche pas l’événement <codeph>close</codeph>.</p>
	 
	 <p>Dans le cas d’un objet FileStream ouvert de façon asynchrone (avec la méthode <codeph>openAsync()</codeph>), même si vous appelez l’événement <codeph>close()</codeph> pour un objet FileStream et supprimez les propriétés et les variables qui référence l’objet, l’objet FileStream n’est pas nettoyé tant que des opérations sont en cours et que des gestionnaires d’événement sont enregistrés. En particulier, un objet FileStream non référencé autrement persiste tant que l’un des scénarios suivants est encore possible : </p>
	 
	 <ul>
	 
	 	<li>Pour les opérations de lecture de fichiers, la fin du fichier n’a pas été atteinte (et l’événement <codeph>complete</codeph> n’a pas été déclenché). </li>
	 
	 	<li>Des données de sortie sont toujours disponibles pour l’écriture et des événements liés à la sortie (par exemple <codeph>outputProgress</codeph> ou <codeph>ioError</codeph>) ont des écouteurs d’événement enregistrés. </li>
	 
	 </ul>
	 
	 </apiDesc><example conref="examples\FileStream.close.1.as">     Le code suivant ouvre un objet FileStream <i>de façon asynchrone</i> et écrit un fichier texte nommé test.txt dans le sous-répertoire Apollo Test du répertoire documents de l’utilisateur. Un appel à la méthode <codeph>close()</codeph> de l’objet FileStream ferme le fichier lorsque les données sont écrites. 
<codeblock>
import flash.filesystem.*;
import flash.events.Event;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.WRITE);
fileStream.writeUTFBytes("Hello");
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();

function fileClosed(event:Event):void {
    trace("closed");
}            
</codeblock></example><example conref="examples\FileStream.close.2.as">     Le code suivant ouvre un objet FileStream <i>de façon asynchrone</i> et écrit un fichier texte nommé test.txt dans le sous-répertoire Apollo Test du répertoire documents de l’utilisateur. Un appel à la méthode <codeph>close()</codeph> de l’objet FileStream ferme le fichier lorsque les données sont écrites.
<codeblock>
import flash.filesystem.*;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF("Hello");
fileStream.close();
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>open()</linktext></link><link href="flash.filesystem.xml#FileStream/event:close"><linktext>événement close</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:close_close"><apiName>close</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ouvert de façon asynchrone est fermé.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Le fichier ouvert de façon asynchrone est fermé.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:open"><apiName>open</apiName><shortdesc>
	 Ouvre l’objet FileStream de façon synchrone, en pointant vers le fichier spécifié par le paramètre file.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’existe pas ; vous ne disposez pas des autorisations appropriées pour l’ouvrir ; vous ouvrez un fichier pour un accès en lecture et vous ne disposez pas d’autorisations de lecture ; ou vous ouvrez un fichier pour un accès en écriture et vous ne disposez pas d’autorisations d’écriture. 
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Le fichier se trouve dans le répertoire de l’application et le paramètre <codeph>fileMode</codeph> est défini sur le mode « append », « update » ou « write ». 
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>Objet File désignant le fichier à ouvrir.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fileMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne provenant de la classe FileMode qui définit les capacités de l’objet FileStream, par exemple la capacité à lire ou écrire dans le fichier.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ouvre l’objet FileStream de façon synchrone, en pointant vers le fichier spécifié par le paramètre <codeph>file</codeph>. 
	 
	 <p>Si l’objet FileStream est déjà ouvert, un appel à la méthode ferme le fichier avant l’ouverture et aucun autre événement (y compris <codeph>close</codeph>) n’est délivré pour le fichier précédemment ouvert.</p>
	 
	 <p>Dans les systèmes qui prennent en charge le verrouillage de fichiers, un fichier ouvert en mode « écriture » ou en mode « mise à jour » (<codeph>FileMode.WRITE</codeph> ou <codeph>FileMode.UPDATE</codeph>) n’est plus lisible jusqu’à sa fermeture.</p>
	 
	 <p>Une fois que vous avez terminé de réaliser des opérations sur le fichier, appelez la méthode <codeph>close()</codeph> de l’objet FileStream. Certains systèmes d’exploitation limitent le nombre de fichiers ouverts simultanément. </p>
	 
	 </apiDesc><example conref="examples\FileStream.open.1.as"> Le code suivant illustre l’ouverture synchrone du fichier test.txt situé dans le sous-répertoire Apollo Test du répertoire documents de l’utilisateur, puis la lecture du fichier dans une chaîne, le jeu de caractères du système étant utilisé comme codage de texte.
<codeblock>
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);
fileStream.close();
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link><link href="flash.filesystem.xml#File"><linktext>Fichier</linktext></link><link href="flash.filesystem.xml#FileMode"><linktext>FileMode</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:openAsync"><apiName>openAsync</apiName><shortdesc>
	 Ouvre l’objet FileStream de façon asynchrone, en pointant vers le fichier spécifié par le paramètre file.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier se trouve dans le répertoire de l’application et le paramètre <codeph>fileMode</codeph> est défini sur le mode « append », « update » ou « write ». 
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>Objet File désignant le fichier à ouvrir.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fileMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne provenant de la classe FileMode qui définit les capacités de l’objet FileStream, par exemple la capacité à lire ou écrire dans le fichier.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ouvre l’objet FileStream de façon asynchrone, en pointant vers le fichier spécifié par le paramètre <codeph>file</codeph>. 
	 
	 <p>Si l’objet FileStream est déjà ouvert, un appel à la méthode ferme le fichier avant l’ouverture et aucun autre événement (y compris <codeph>close</codeph>) n’est délivré pour le fichier précédemment ouvert.</p>
	 
	 <p>Si le paramètre <codeph>fileMode</codeph> est défini sur <codeph>FileMode.READ</codeph> ou sur <codeph>FileMode.UPDATE</codeph>, AIR lit les données dans la mémoire tampon d’entrée dès l’ouverture du fichier, et des événements <codeph>progress</codeph> et <codeph>open</codeph> sont déclenchés au fur et à mesure de la lecture des données dans la mémoire tampon d’entrée.</p>
	 
	 <p>Dans les systèmes qui prennent en charge le verrouillage de fichiers, un fichier ouvert en mode « écriture » ou en mode « mise à jour » (<codeph>FileMode.WRITE</codeph> ou <codeph>FileMode.UPDATE</codeph>) n’est plus lisible jusqu’à sa fermeture.</p>
	 
	 <p>Une fois que vous avez terminé de réaliser des opérations sur le fichier, appelez la méthode <codeph>close()</codeph> de l’objet FileStream. Certains systèmes d’exploitation limitent le nombre de fichiers ouverts simultanément. </p>
	 
`	 </apiDesc><example conref="examples\FileStream.openAsync.1.as"> Le code suivant illustre l’ouverture asynchrone du fichier test.txt situé dans le sous-répertoire Apollo Test du répertoire documents de l’utilisateur, puis la lecture du fichier dans une chaîne, le jeu de caractères du système étant utilisé comme codage de texte.
<codeblock>
import flash.filesystem.*;
import flash.events.Event;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.addEventListener(Event.COMPLETE, fileCompleteHandler)
fileStream.openAsync(file, FileMode.READ);

function fileCompleteHandler(event:Event):void {
    var str:String = fileStream.readMultiByte(fileStream.bytesAvailable, File.systemCharset);
    trace(str);
    fileStream.close();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link><link href="flash.filesystem.xml#FileStream/event:complete"><linktext>événement complete</linktext></link><link href="flash.filesystem.xml#FileStream/event:ioError"><linktext>événement ioError</linktext></link><link href="flash.filesystem.xml#FileStream/event:progress"><linktext>événement progress</linktext></link><link href="flash.filesystem.xml#FileMode"><linktext>FileMode</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:openAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier n’existe pas ; vous ne disposez pas des autorisations appropriées pour l’ouvrir ; vous ouvrez un fichier pour un accès en lecture et vous ne disposez pas d’autorisations de lecture ; ou vous ouvrez un fichier pour un accès en écriture et vous ne disposez pas d’autorisations d’écriture. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Le fichier n’existe pas ; vous ne disposez pas des autorisations appropriées pour l’ouvrir ; vous ouvrez un fichier pour un accès en lecture et vous ne disposez pas d’autorisations de lecture ; ou vous ouvrez un fichier pour un accès en écriture et vous ne disposez pas d’autorisations d’écriture.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque les données sont lues dans la mémoire tampon d’entrée (le fichier doit être ouvert avec le paramètre <codeph>fileMode</codeph> défini sur <codeph>FileMode.READ</codeph> ou sur <codeph>FileMode.UPDATE</codeph>).
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque les données sont lues dans la mémoire tampon d’entrée.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Les données du fichier ont été lues dans la mémoire tampon d’entrée (le fichier doit être ouvert avec le paramètre <codeph>fileMode</codeph> défini sur <codeph>FileMode.READ</codeph> ou sur <codeph>FileMode.UPDATE</codeph>).
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Les données du fichier ont été lues dans la mémoire tampon d’entrée.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	
	 Lit une valeur booléenne dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur booléenne, <codeph>true</codeph> si l’octet correspond à une valeur non nulle, <codeph>false</codeph> dans le cas contraire.
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit une valeur booléenne dans le flux de fichiers, le flux d’octets ou le tableau d’octets. Un seul octet est lu, et la valeur <codeph>true</codeph> est renvoyée s’il n’est pas nul, <codeph>false</codeph> dans le cas contraire.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBoolean_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readByte"><apiName>readByte</apiName><shortdesc>
	
	 Lit un octet signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre -128 et 127.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un octet signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readBytes"><apiName>readBytes</apiName><shortdesc>
	
	 Lit le nombre d’octets de données spécifié par le paramètre length dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet <codeph>ByteArray</codeph> contenant les données à lire.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décalage dans le paramètre <codeph>bytes</codeph> où la lecture des données doit commencer.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre d’octets à lire. La valeur 0 (par défaut) provoque la lecture de toutes les données disponibles.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Lit le nombre d’octets de données spécifié par le paramètre <codeph>length</codeph> dans le flux de fichiers, le flux d’octets ou le tableau d’octets. Les octets sont lus dans l’objet ByteArray spécifié par le paramètre <codeph>bytes</codeph>, à partir de la position indiquée par <codeph>offset</codeph>.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readDouble"><apiName>readDouble</apiName><shortdesc>
	
	 Lit un nombre à virgule flottante à deux décimales, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à deux décimales et conforme au standard IEEE 754.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un nombre à virgule flottante à deux décimales, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readDouble_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readFloat"><apiName>readFloat</apiName><shortdesc>
	
	 Lit un nombre à virgule flottante à une décimale, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à une décimale et conforme au standard IEEE 754.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un nombre à virgule flottante à une décimale, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readFloat_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readInt"><apiName>readInt</apiName><shortdesc>
	
	 Lit un entier signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre -2147483648 et 2147483647.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un entier signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	
	 Lit une chaîne multi-octets de longueur spécifiée dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne au format UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire dans le flux d’octets.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne désignant le le jeu de caractères à utiliser pour interpréter les octets. Parmi les chaînes de jeu de caractères possibles figurent <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>. 
	 
     <p><b>Remarque :</b> si la valeur du paramètre <codeph>charSet</codeph> n’est pas reconnue par le système actuel, <ph platform="actionscript">Adobe<sup>®</sup> Flash<sup>®</sup> Player ou </ph>Adobe<sup>®</sup> AIR<sup>®</sup> utilise la page de code par défaut du système comme jeu de caractères. Par exemple, une valeur pour le paramètre <codeph>charSet</codeph>, comme dans <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> qui utilise <codeph>01</codeph> au lieu de <codeph>1</codeph> pourra éventuellement fonctionner sur votre machine de développement, mais pas sur un autre ordinateur. Sur l’autre ordinateur, <ph platform="actionscript">Flash Player ou </ph>le moteur d’exécution AIR utilise la page de code par défaut du système.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Lit une chaîne multi-octets de longueur spécifiée dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/systemCharset"><linktext>File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readMultiByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readObject"><apiName>readObject</apiName><shortdesc>
	
	 Lit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet désérialisé
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readObject_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readShort"><apiName>readShort</apiName><shortdesc>
	
	 Lit un entier signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des 
données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre -32768 et 32767.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un entier signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTF"><apiName>readUTF</apiName><shortdesc>
	
	 Lit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8 générée par la représentation des caractères sous forme d’octets.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets. La chaîne doit être précédée d’un caractère non signé indiquant la longueur en octets.
	 
	 <p>Cette méthode est similaire à la méthode <codeph>readUTF()</codeph> de l’interface IDataInput Java<sup>®</sup>.</p>
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTF_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	
	 Lit une séquence d’octets UTF-8 dans le flux ou le tableau d’octets et renvoie une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8 de longueur spécifiée, générée par la représentation des caractères sous forme d’octets.	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Lit une séquence d’octets UTF-8 dans le flux ou le tableau d’octets et renvoie une chaîne.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTFBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	
	 Lit un octet non signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre 0 et 255. 	   
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un octet non signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	
	 Lit un entier non signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre 0 et 4294967295.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un entier non signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	
	 Lit un entier non signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités de lecture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être lu (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>La position spécifiée pour la lecture des données excède le nombre d’octets disponibles (défini par la propriété <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre 0 et 65535. 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Lit un entier non signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier ne peut pas être lu ou n’est pas ouvert. Cet événement n’est distribué que pour les fichiers ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Le fichier ne peut pas être lu ou n’est pas ouvert.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:truncate"><apiName>truncate</apiName><shortdesc>
	 Tronque le fichier placé à la position spécifiée par la propriété position de l’objet FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’est pas ouvert pour l’écriture.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Tronque le fichier placé à la position spécifiée par la propriété <codeph>position</codeph> de l’objet FileStream. 
	 
	 <p>Les octets situés entre la position spécifiée par la propriété <codeph>position</codeph> et la fin du fichier sont supprimés. Le fichier doit être ouvert pour l’écriture.</p>
	 
	 </apiDesc><example conref="examples\FileStream.truncate.1.as"> Le code suivant ouvre de façon synchrone le fichier test.txt situé dans le sous-répertoire Apollo Test du répertoire documents de l’utilisateur, puis réduit le fichier à une longueur de 100 caractères lorsqu’il est plus long.
<codeblock>
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.UPDATE);
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.close();
</codeblock></example><example conref="examples\FileStream.truncate.2.as"> Le code suivant ouvre <i>de façon asynchrone</i> le fichier test.txt situé dans le sous-répertoire Apollo Test du répertoire documents de l’utilisateur, puis réduit le fichier à une longueur de 100 caractères lorsqu’il est plus long.
<codeblock>
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.UPDATE);
trace("start", file.size)
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();
function fileClosed(event:Event):void {
    trace("closed", file.size); 
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/position"><linktext>position</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	
	 Ecrit une valeur booléenne.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Valeur booléenne qui détermine l’octet écrit. Si le paramètre a pour valeur <codeph>true</codeph>, 1 est écrit ; s’il a pour valeur <codeph>false</codeph>, 0 est écrit.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit une valeur booléenne. Un seul octet est écrit, conformément au paramètre <codeph>value</codeph>, soit 1 si <codeph>true</codeph> ou 0 si <codeph>false</codeph>.
	 
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBoolean_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeByte"><apiName>writeByte</apiName><shortdesc>
	
	 Ecrit un octet.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit un octet. Les 8 bits inférieurs du paramètre sont utilisés. Les 24 bits supérieurs ne sont pas pris en compte.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	
	 Ecrit une séquence d’octets à partir du tableau d’octets ou des octets spécifiés, en partant de l’octet spécifié par l’offset (à l’aide d’un index de base zéro) dont la longueur est indiquée par le paramètre length dans le flux de fichiers ou d’octets, ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Tableau d’octets à écrire.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Index de base zéro qui indique où débuter l’écriture dans le tableau.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier non signé qui indique l’emplacement du début d’écriture dans la mémoire tampon.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit une séquence d’octets à partir du tableau d’octets ou des <codeph>octets</codeph> spécifiés, en partant de l’octet spécifié par l’<codeph>offset</codeph> (à l’aide d’un index de base zéro) dont la longueur est indiquée par le paramètre <codeph>length</codeph> dans le flux de fichiers ou d’octets, ou le tableau d’octets.
	 
	 <p>Si le paramètre <codeph>length</codeph> est omis, la longueur par défaut est utilisée (à savoir 0) et tout le contenu de la mémoire tampon à partir de <codeph>offset</codeph> est écrit. Si le paramètre <codeph>offset</codeph> est également omis, toute la mémoire tampon est écrite. </p>
	 
	 <p>Si les paramètres <codeph>offset</codeph> ou <codeph>length</codeph> ne sont pas compris dans la plage supportée, ils sont réglés sur le début et la fin du tableau d’octets (<codeph>bytes</codeph>).</p>
 	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	
	 Ecrit un nombre à virgule flottante à deux décimales (64 bits) et conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à virgule flottante à deux décimales (64 bits).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit un nombre à virgule flottante à deux décimales (64 bits) et conforme à IEEE 754.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeDouble_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	
	 Ecrit un nombre à virgule flottante à une décimale (32 bits) et conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à virgule flottante à une décimale (32 bits).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit un nombre à virgule flottante à une décimale (32 bits) et conforme à IEEE 754.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeFloat_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeInt"><apiName>writeInt</apiName><shortdesc>
	
	 Ecrit un entier signé de 32 bits.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier signé.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit un entier signé de 32 bits.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	
	 Ecrit une chaîne multi-octets dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne indiquant le jeu de caractères à utiliser. Parmi les chaînes de jeu de caractères possibles figurent <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>. 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit une chaîne multi-octets dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/systemCharset"><linktext>File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeMultiByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeObject"><apiName>writeObject</apiName><shortdesc>
	
	 Ecrit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Objet à sérialiser.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeObject_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeShort"><apiName>writeShort</apiName><shortdesc>
	
	 Ecrit un entier de 16 bits.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit un entier de 16 bits. Les 16 bits inférieurs du paramètre sont utilisés. Les 16 bits supérieurs ne sont pas pris en compte.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	
	 Ecrit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets. La longueur de la chaîne UTF-8 exprimée en octets est d’abord écrite sous forme d’entier de 16 bits, suivi des octets représentant les caractères de la chaîne.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTF_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	
	 Ecrit une chaîne UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit une chaîne UTF-8. Comme <codeph>writeUTF()</codeph>, mais n’insère pas dans la chaîne un préfixe correspondant à un mot de 16 bits.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTFBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	
	 Ecrit un entier non signé de 32 bits.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’a pas été ouvert ; le fichier a été ouvert mais pas avec des capacités d’écriture ; ou, dans le cas d’un fichier ouvert pour des opérations synchrones (avec la méthode <codeph>open()</codeph>), le fichier ne peut pas être écrit (par exemple, parce qu’il est absent).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier non signé.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Ecrit un entier non signé de 32 bits.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUnsignedInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent). Cet événement n’est distribué que pour les fichiers qui ont été ouverts pour des opérations asynchrones (avec la méthode <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Vous ne pouvez pas écrire dans le fichier (par exemple parce qu’il est absent).</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.filesystem:FileStream:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	
	 Renvoie le nombre d’octets de données disponibles pour la lecture dans le tampon de saisie.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	
	 Renvoie le nombre d’octets de données disponibles pour la lecture dans le tampon de saisie. Le code utilisateur doit appeler <codeph>bytesAvailable</codeph> pour garantir que les données disponibles sont suffisantes avant leur lecture à l’aide de l’une des méthodes read.
	 </apiDesc><example conref="examples\FileStream.bytesAvailable.1.as"/></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:endian:get"><apiName>endian</apiName><shortdesc>
	
	 Ordre d’octet des données, à savoir la constante BIG_ENDIAN ou LITTLE_ENDIAN de la classe Endian.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	 Ordre d’octet des données, à savoir la constante <codeph>BIG_ENDIAN</codeph> ou <codeph>LITTLE_ENDIAN</codeph> de la classe Endian.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Spécifie si le format AMF3 ou AMF0 est utilisé lors de l’écriture ou de la lecture de données binaires avec la méthode readObject() ou writeObject().</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie si le format AMF3 ou AMF0 est utilisé lors de l’écriture ou de la lecture de données binaires avec la méthode <codeph>readObject()</codeph> ou <codeph>writeObject()</codeph>.
	 
	 <p>La valeur est une constante extraite de la classe ObjectEncoding. Par défaut, le format AMF3 est utilisé.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="flash.filesystem.xml#FileStream/readObject()"><linktext>readObject()</linktext></link><link href="flash.filesystem.xml#FileStream/writeObject()"><linktext>writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:FileStream:position:get"><apiName>position</apiName><shortdesc>
	 Position actuelle dans le fichier.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Position actuelle dans le fichier. 
	 
	 <p>Cette valeur est modifiée dans l’un des cas suivants :</p>
	 
	 <ul>
	 
	 	<li>Lorsque vous définissez la propriété explicitement</li>
	 
	 	<li>Lors d’une lecture de l’objet FileStream (avec l’une les méthodes de lecture)</li>
	 
	 	<li>Lors d’une écriture dans l’objet FileStream</li>
	 
	 </ul>
	 
	 <p>La position est définie sous forme numérique (à la place d’uint) pour que les fichiers dont la longueur est supérieure à 2<sup>32</sup> octets puissent être pris en charge. La valeur de cette propriété est toujours un nombre entier inférieur à 2<sup>53</sup>. Si vous définissez cette valeur sur un nombre décimal, la valeur est arrondie au nombre entier le plus proche.</p>
	 
	 <p>Lorsqu’un fichier est lu de façon asynchrone, si vous définissez la propriété <codeph>position</codeph>, l’application commence à remplir la mémoire tampon de lecture par les données en commençant à la position spécifiée, et la propriété <codeph>bytesAvailable</codeph> peut être définie sur 0. Attendez un événement <codeph>complete</codeph> avant d’utiliser une méthode de lecture pour lire des données ; ou attendez un événement <codeph>progress</codeph> et vérifiez la propriété <codeph>bytesAvailable</codeph> avant d’utiliser une méthode de lecture.</p>
	  
	 </apiDesc><example conref="examples\FileStream.position.1.as"> Le code suivant illustre la mise à jour de la propriété <codeph>position</codeph> de l’objet FileStream lorsque l’application lit des données dans un fichier.
<codeblock>
import flash.fileSystem.*;
import flash.utils.ByteArray;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory.resolvePath("Apollo Test/test.txt");
var stream:FileStream = new FileStream();
stream.addEventListener(Event.COMPLETE, readBytes);
stream.openAsync(sourceFile, File);

function readBytes(e:Event):void {
    var bytes:ByteArray = new ByteArray();
    trace("position 0:", stream.position); // 0
    bytes[0] = stream.readByte();
    trace("position 1:", stream.position); // 1
    fileStream.readBytes(bytes, stream.position, 4); 
    trace("position 2:", stream.position); // 5
    stream.close();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:readAhead:get"><apiName>readAhead</apiName><shortdesc>
	 Lorsque les fichiers sont lus de façon asynchrone, la quantité de données requises.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Should the readAhead value dwindle to 0 as the data is read in.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Lorsque les fichiers sont lus de façon asynchrone, la quantité de données requises.
	 
	 <p>Cette propriété spécifie la quantité de données qu’un flux asynchrone tentera de lire à partir de la position actuelle. La valeur par défaut de cette propriété est infinity : par défaut, un fichier ouvert pour une lecture asynchrone est lu jusqu’à la fin du fichier.</p>
	 
	 <p>La lecture de données dans la mémoire tampon de lecture ne change pas la valeur de la propriété <codeph>readAhead</codeph>. Lorsque des données sont lues dans la mémoire tampon, de nouvelles données sont lues pour remplir la mémoire tampon de lecture.</p>
	 
	 <p>La propriété <codeph>readAhead</codeph> n’a aucune incidence sur un fichier ouvert de façon synchrone.</p>
	 
	 <p>Lorsque des données sont lues de façon asynchrone, l’objet FileStream déclenche des événements <codeph>progress</codeph>. Dans la méthode du gestionnaire de l’événement <codeph>progress</codeph>, vérifiez que le nombre requis d’octets est disponible (en vérifiant la propriété <codeph>bytesAvailable</codeph>), puis lisez les données dans la mémoire tampon de lecture à l’aide d’une méthode de lecture.</p>
	 
	 </apiDesc><example conref="examples\FileStream.readAhead.1.as">     Le code suivant illustre l’utilisation de la propriété <codeph>readAhead</codeph> pour limiter la quantité de données lues dans un fichier à 100 octets :
<codeblock>
import flash.filesystem.*;

var file:File = File.desktopDirectory.resolvePath("test.txt");
var fileStream:FileStream = new FileStream();
fileStream.readAhead = 100;
fileStream.addEventListener(ProgressEvent.PROGRESS, readProgressHandler)
fileStream.openAsync(file, FileMode.READ);
var results:ByteArray;

function readProgressHandler(event:ProgressEvent):void {
    if (fileStream.bytesAvailable >= 100) {
        fileStream.readBytes(results, 0, 100);
    }
}
</codeblock><swfblock conref="examples\FileStream.readAhead.1.swf"/></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filesystem:FileMode"><apiName>FileMode</apiName><shortdesc>
 La classe FileMode définit les constantes de chaîne utilisées dans le paramètre fileMode des méthodes open() et openAsync() de la classe FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe FileMode définit les constantes de chaîne utilisées dans le paramètre <codeph>fileMode</codeph> des méthodes <codeph>open()</codeph> et <codeph>openAsync()</codeph> de la classe FileStream. Le paramètre <codeph>fileMode</codeph> de ces méthodes déterminent les capacités disponibles pour l’objet FileStream après l’ouverture du fichier. 
 
 <p>Les capacités suivantes sont disponibles, dans différentes combinaisons, selon la valeur du paramètre <codeph>fileMode</codeph> spécifiée dans la méthode d’ouverture :</p>
 
 <ul>
 
 	<li>Lecture—L’objet FileStream peut lire des données dans le fichier.</li>
 	<li>Ecriture—L’objet FileStream peut écrire des données dans le fichier.</li>
 	<li>Création—L’objet FileStream crée un fichier non existant, à l’ouverture.</li>
 	<li>Troncature à l’ouverture—Les données du fichier sont supprimées à l’ouverture (avant que d’autres ne soient écrites).</li>
 	<li>Ajout de données—Les données sont toujours écrites à la fin du fichier (lorsqu’une méthode d’écriture est appelée).</li>
 
 </ul>
 
 <p>Le tableau suivant montre les capacités fournies par chaque constante de la classe FileMode lorsqu’elles sont appliquées sous forme de paramètre <codeph>fileMode</codeph> d’une méthode d’ouverture d’un objet FileStream :</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 <tgroup cols="6"><thead><row><entry>Constante FileMode</entry><entry align="center">Lecture</entry><entry align="center">Ecriture</entry><entry align="center">Création</entry><entry align="center">Troncature à l’ouverture</entry><entry align="center">Ajout de données</entry></row></thead><tbody><row>
 	<entry><codeph>READ</codeph></entry>
 	<entry align="center"> • </entry>
 	<entry> </entry>
 	<entry> </entry>
 	<entry> </entry>
 	<entry> </entry>
 </row><row>
 	<entry><codeph>WRITE</codeph></entry>
 	<entry> </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry> </entry>
 </row><row>
 	<entry><codeph>APPEND</codeph></entry>
 	<entry> </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry/>
 	<entry align="center"> • </entry>
 </row><row>
 	<entry><codeph>UPDATE</codeph></entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"/>
 	<entry> </entry>
 </row></tbody></tgroup></adobetable>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>FileStream.open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()"><linktext>FileStream.openAsync()</linktext></link></related-links><apiValue id="flash.filesystem:FileMode:APPEND"><apiName>APPEND</apiName><shortdesc> 
	Utilisé pour ouvrir un fichier en mode écriture, toutes les données écrites étant ajoutées à la fin du fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>append</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Utilisé pour ouvrir un fichier en mode écriture, toutes les données écrites étant ajoutées à la fin du fichier. A l’ouverture, tout fichier qui n’existe pas est créé. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:READ"><apiName>READ</apiName><shortdesc> 
	Utilisé pour ouvrir un fichier en mode lecture seule.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>read</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Utilisé pour ouvrir un fichier en mode lecture seule. Le fichier doit exister (les fichiers absents ne sont pas créés).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:UPDATE"><apiName>UPDATE</apiName><shortdesc> 
	Utilisé pour ouvrir un fichier en mode lecture/écriture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>update</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Utilisé pour ouvrir un fichier en mode lecture/écriture. A l’ouverture, tout fichier qui n’existe pas est créé. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:WRITE"><apiName>WRITE</apiName><shortdesc> 
	Utilisé pour ouvrir un fichier en mode écriture seule.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>write</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Utilisé pour ouvrir un fichier en mode écriture seule. A l’ouverture, tout fichier qui n’existe pas est créé et les fichiers existants sont tronqués (leurs données sont supprimées).
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filesystem:File"><apiName>File</apiName><shortdesc>
 Un objet File représente un chemin vers un fichier ou un répertoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.net:FileReference</apiBaseClassifier></apiClassifierDef><apiDesc>
 Un objet File représente un chemin vers un fichier ou un répertoire. Il peut s’agir d’un fichier ou d’un répertoire existant ou qui n’existe pas encore ; par exemple, il peut représenter le chemin vers un fichier ou un répertoire que vous envisagez de créer. 
 
  <p>La classe File possède un certain nombre de propriétés et de méthodes qui lui permettent d’obtenir des informations sur le système de fichiers et d’exécuter des opérations, par exemple la copie de fichiers et de répertoires.</p>
  
  <p>Vous pouvez utiliser des objets File avec la classe FileStream pour lire et écrire des fichiers. </p>
  
  <p>La classe File étend la classe FileReference. La classe FileReference, disponible dans Flash<sup>®</sup> Player et dans Adobe<sup>®</sup> AIR<sup>®</sup>, représente un pointeur vers un fichier, mais la classe File ajoute des propriétés et des méthodes qui ne sont pas exposées dans Flash Player (dans un fichier SWF s’exécutant dans un navigateur) pour des raisons de sécurité.</p>
  
  <p>La classe File contient des propriétés statiques qui vous permettent de référencer les emplacements de répertoire les plus fréquemment utilisés. Voici quelques unes de ces propriétés statiques :</p>
  
  <ul>
  	<li><codeph>File.applicationStorageDirectory</codeph> : un répertoire de stockage spécifique à chaque application AIR installée</li>
      <li><codeph>File.applicationDirectory</codeph> : le répertoire en lecture seule dans lequel est installée l’application (et qui contient tout autre actif installé)</li>
      <li><codeph>File.desktopDirectory</codeph> : le répertoire Bureau de l’utilisateur</li>
      <li><codeph>File.documentsDirectory</codeph> : le répertoire documents de l’utilisateur</li>
      <li><codeph>File.userDirectory</codeph> : le répertoire de l’utilisateur</li>
  </ul>
  
  <p>Ces propriétés ont des valeurs différentes selon le système d’exploitation. Par exemple, les chemins natifs vers le répertoire Bureau de l’utilisateur sont différents sous Mac OS, Linux et Windows. Néanmoins, la propriété <codeph>File.desktopDirectory</codeph> pointe vers le chemin du répertoire Bureau correct sur chacune de ces plateformes. Pour développer des applications qui fonctionnent correctement sur toutes les plateformes, utilisez ces propriétés comme base pour référencer d’autres fichiers dont se sert l’application. Utilisez ensuite la méthode <codeph>resolvePath()</codeph> pour affiner le chemin. Par exemple, le code suivant pointe vers le fichier preferences.xml dans le répertoire de stockage de l’application :</p>
  
  <codeblock platform="actionscript"> var prefsFile:File = File.applicationStorageDirectory;
  prefsFile = prefsFile.resolvePath("preferences.xml");</codeblock>
  
  <codeblock platform="javascript"> var prefsFile = air.File.applicationStorageDirectory;
  prefsFile = prefsFile.resolvePath("preferences.xml");</codeblock>
  
  <p>Si vous utilisez un chemin natif littéral lors du référencement d’un fichier, il ne fonctionnera que sur une seule plateforme. Par exemple, l’objet File suivant ne fonctionnerait que sous Windows :</p> 
  
  <codeblock platform="actionscript">new File("C:\Documents and Settings\joe\My Documents\test.txt")</codeblock>
  <codeblock platform="javascript">new air.File("C:\Documents and Settings\joe\My Documents\test.txt")</codeblock>
  
  <p>Le répertoire de stockage de l’application est particulièrement utile. Il fournit un répertoire de stockage spécifique à l’application pour l’application AIR. Il est défini par la propriété <codeph>File.applicationStorageDirectory</codeph>.</p>
  
  <p>N’ajoutez ni ne supprimez aucun contenu du répertoire de l’application (dans lequel est installée l’application AIR). Vous risquez en effet de rendre l’application AIR inutilisable et d’invalider la signature de l’application. Par défaut, AIR ne permet pas d’écrire dans le répertoire de l’application ; en effet, tous les comptes utilisateur ne sont pas habilités à écrire dans ce répertoire sur tous les systèmes d’exploitation. Utilisez le répertoire de stockage de l’application pour écrire des fichiers internes. Utilisez le répertoire documents pour écrire des fichiers que l’utilisateur pourra utiliser hors de l’application, notamment des images éditées ou des fichiers texte.</p>
  
  </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#FileStream"><linktext>FileStream</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.DIRECTORY_LISTING_directoryListing"><apiName>directoryListing</apiName><shortdesc>
 Distribué lorsqu’une liste de répertoires est disponible après un appel à la méthode getDirectoryListingAsync().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FileListEvent.DIRECTORY_LISTING</apiEventType><adobeApiEventClassifier>flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une liste de répertoires est disponible après un appel à la méthode <codeph>getDirectoryListingAsync()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListingAsync()"><linktext>File.getDirectoryListingAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.SELECT_MULTIPLE_selectMultiple"><apiName>selectMultiple</apiName><shortdesc>
 Distribué lorsque l’utilisateur sélectionne des fichiers dans la boîte de dialogue ouverte par un appel à la méthode browseForOpenMultiple().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FileListEvent.SELECT_MULTIPLE</apiEventType><adobeApiEventClassifier>flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur sélectionne des fichiers dans la boîte de dialogue ouverte par un appel à la méthode <codeph>browseForOpenMultiple()</codeph>. 
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#File/browseForMultiple()"><linktext>browseForMultiple()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
 Distribué lorsque l’utilisateur sélectionne un fichier ou un répertoire dans une boîte de dialogue de recherche de fichier ou de répertoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur sélectionne un fichier ou un répertoire dans une boîte de dialogue de recherche de fichier ou de répertoire. 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Distribué lorsqu’une opération viole une contrainte de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération viole une contrainte de sécurité.
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’une erreur se produit au cours d’une opération de fichier asynchrone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une erreur se produit au cours d’une opération de fichier asynchrone.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Distribué lorsqu’une opération asynchrone se termine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération asynchrone se termine.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Distribué lorsqu’une opération asynchrone en attente est annulée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une opération asynchrone en attente est annulée.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.filesystem:File:File"><apiName>File</apiName><shortdesc>
	Fonction constructeur de la classe File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>La syntaxe du paramètre <codeph>path</codeph> n’est pas valide.
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>path</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Chemin d’accès au fichier. Vous pouvez spécifier le chemin à l’aide d’une URL ou en utilisant une notation de chemin natif (spécifique à la plateforme). 
	
	<p>Si vous spécifiez une URL, vous pouvez utiliser l’un des modèles d’URL suivants : <codeph>file</codeph>, <codeph>app</codeph> ou <codeph>app-storage</codeph>. Voici quelques valeurs valides pour le paramètre <codeph>path</codeph> avec la notation URL : </p>
	
	<ul>
	
		<li><codeph>"app:/DesktopPathTest.xml"</codeph></li> 
		<li><codeph>"app-storage:/preferences.xml"</codeph></li> 
		<li><codeph>"file:///C:/Documents%20and%20Settings/bob/Desktop"</codeph> (le bureau de l’ordinateur Windows de Bob)</li>
		<li><codeph>"file:///Users/bob/Desktop"</codeph> (le bureau de l’ordinateur Mac de Bob)</li>
	
	</ul>
	
	<p>Les modèles d’URL <codeph>app</codeph> et <codeph>app-storage</codeph> sont utiles, car ils peuvent pointer vers un fichier valide sur tous les systèmes de fichier. Toutefois, dans les deux autres exemples qui utilisent le modèle d’URL <codeph>file</codeph> pour pointer vers le répertoire desktop de l’utilisateur, il serait préférable de transmettre l’argument <i>no</i> <codeph>path</codeph> au constructeur <codeph>File()</codeph>, puis d’affecter <codeph>File.desktopDirectory</codeph> à l’objet File car cette manière d’accéder au répertoire desktop est indépendante de la plateforme et de l’utilisateur.</p>
	
	<p>Si vous spécifiez un chemin natif, sous Windows vous pouvez utiliser la barre oblique inversée ou la barre oblique comme séparateur de chemin dans cet argument ; sous Mac OS et Linux, utilisez la barre oblique. Voici quelques valeurs valides pour le paramètre <codeph>path</codeph> avec la notation de chemin natif :</p>
	
	<ul>
	
		<li><codeph>"C:/Documents and Settings/bob/Desktop"</codeph></li>
		<li><codeph>"/Users/bob/Desktop"</codeph></li>
	
	</ul>
	
	<p>Toutefois, pour les deux exemples, il est préférable de transmettre l’argument <i>no</i> <codeph>path</codeph> au constructeur <codeph>File()</codeph>, puis d’affecter <codeph>File.desktopDirectory</codeph> à l’objet File car cette manière d’accéder au répertoire desktop est indépendante de la plateforme et de l’utilisateur.</p>
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Fonction constructeur de la classe File. 
	
	<p>Si vous transmettez un argument <codeph>path</codeph>, l’objet File pointe vers le chemin spécifié et les propriétés <codeph>nativePath</codeph> et <codeph>url</codeph> sont définies de manière à refléter ce chemin.</p>
	
	<p>Bien que vous puissiez transmettre un argument <codeph>path</codeph> pour spécifier un chemin de fichier, cela peut impliquer l’utilisation de code spécifique à une plateforme. Par exemple, un chemin natif tel que <codeph>"C:\\\\Documents and Settings\\bob\\Desktop"</codeph> ou une URL telle que <codeph>"file:///C:/Documents%20and%20Settings/bob/Desktop"</codeph> n’est valable que sous Windows. Il est donc préférable d’utiliser les propriétés statiques suivantes, qui représentent les répertoires les plus fréquemment utilisés et qui sont valables sur toutes les plateformes :</p>
	
	<ul>
	<li><codeph>File.applicationDirectory</codeph></li>
	<li><codeph>File.applicationStorageDirectory</codeph></li>
	<li><codeph>File.desktopDirectory</codeph></li>
	<li><codeph>File.documentsDirectory</codeph></li>
	<li><codeph>File.userDirectory</codeph></li>
	</ul>
	
	<p>Vous pouvez alors utiliser la méthode <codeph>resolvePath()</codeph> pour obtenir un chemin relatif à ces répertoires. Par exemple, le code suivant définit un objet File de sorte qu’il pointe vers le fichier settings.xml du répertoire de stockage de l’application :</p>
	
	<codeblock platform="actionscript">var file:File = File.applicationStorageDirectory.resolvePath("settings.xml");</codeblock>
	
	<codeblock platform="javascript">var file = air.File.applicationStorageDirectory.resolvePath("settings.xml");</codeblock>
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filesystem.xml#File/nativePath"><linktext>nativePath</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:File:browseForDirectory"><apiName>browseForDirectory</apiName><shortdesc>
	 Ouvre une boîte de dialogue permettant à l’utilisateur de sélectionner un répertoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne affichée dans la barre de titre de la boîte de dialogue.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ouvre une boîte de dialogue permettant à l’utilisateur de sélectionner un répertoire. Lorsque l’utilisateur sélectionne le répertoire, l’événement <codeph>select</codeph> est distribué. La propriété <codeph>target</codeph> de l’événement <codeph>select</codeph> est l’objet File qui pointe vers le répertoire sélectionné.
	 
	 </apiDesc><example conref="examples\File.browseForDirectory.1.as"> Le code suivant utilise la méthode <codeph>File.browseForDirectory()</codeph> pour laisser l’utilisateur choisir un répertoire. Une fois le répertoire sélectionné, le code énumère le contenu du répertoire sélectionné dans le résultat de la méthode <codeph>trace()</codeph> :
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var directory:File = File.documentsDirectory;

try
{
    directory.browseForDirectory("Select Directory");
    directory.addEventListener(Event.SELECT, directorySelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function directorySelected(event:Event):void 
{
    directory = event.target as File;
    var files:Array = directory.getDirectoryListing();
    for(var i:uint = 0; i &lt; files.length; i++)
    {
        trace(files[i].name);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForDirectory_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Ouvrir. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Ouvrir.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForDirectory_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur sélectionne un répertoire et ferme la boîte de dialogue de sélection des répertoires. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur sélectionne un répertoire et ferme la boîte de dialogue de sélection des répertoires.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpen"><apiName>browseForOpen</apiName><shortdesc>
	 Affiche la boîte de dialogue Ouvrir qui permet à l’utilisateur de sélectionner un fichier à ouvrir.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne affichée dans la barre de titre de la boîte de dialogue.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau d’occurrences de FileFilter utilisé pour filtrer les fichiers qui s’affichent dans la boîte de dialogue. Si vous omettez ce paramètre, tous les fichiers s’affichent. Pour plus d’informations, voir la classe FileFilter.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Affiche la boîte de dialogue Ouvrir qui permet à l’utilisateur de sélectionner un fichier à ouvrir.
	 
	 <p>Lorsque l’utilisateur sélectionne le fichier, l’événement <codeph>select</codeph> est distribué. La propriété <codeph>target</codeph> de l’événement <codeph>select</codeph> est l’objet File qui pointe vers le fichier sélectionné.</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpen.1.as"> Le code suivant utilise la méthode <codeph>File.browseForOpen()</codeph> pour laisser l’utilisateur choisir un fichier texte. Lorsque le fichier est sélectionné, le code lit les données du fichier dans une chaîne.
<codeblock>
import flash.filesystem.*;
import flash.events.Event;
import flash.net.FileFilter;

var fileToOpen:File = new File();
var txtFilter:FileFilter = new FileFilter("Text", "*.as;*.css;*.html;*.txt;*.xml");

try 
{
    fileToOpen.browseForOpen("Open", [txtFilter]);
    fileToOpen.addEventListener(Event.SELECT, fileSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function fileSelected(event:Event):void 
{
    var stream:FileStream = new FileStream();
    stream.open(event.target, FileMode.READ);
    var fileData:String = stream.readUTFBytes(stream.bytesAvailable);
    trace(fileData);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpenMultiple()"><linktext>browseForOpenMultiple()</linktext></link><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpen_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Ouvrir. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Ouvrir.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpen_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur sélectionne un fichier et ferme la boîte de dialogue Ouvrir. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur sélectionne un fichier et ferme la boîte de dialogue Ouvrir.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpenMultiple"><apiName>browseForOpenMultiple</apiName><shortdesc>
	 Affiche la boîte de dialogue Ouvrir qui permet à l’utilisateur de sélectionner un ou plusieurs fichiers à ouvrir.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne affichée dans la barre de titre de la boîte de dialogue.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau d’occurrences de FileFilter utilisé pour filtrer les fichiers qui s’affichent dans la boîte de dialogue. Si vous omettez ce paramètre, tous les fichiers s’affichent. Pour plus d’informations, voir la classe FileFilter.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Affiche la boîte de dialogue Ouvrir qui permet à l’utilisateur de sélectionner un ou plusieurs fichiers à ouvrir.
	 
	 <p>Lorsque l’utilisateur sélectionne plusieurs fichiers, l’événement <codeph>selectMultiple</codeph> est distribué. La propriété <codeph>target</codeph> de l’événement <codeph>select</codeph> est cet objet File. Contrairement à <codeph>browseForOpen()</codeph>, avec la méthode <codeph>browseForOpenMultiple()</codeph>, cet objet File n’est pas mis à jour pour référencer l’un des fichiers choisis. A l’inverse, l’événement <codeph>selectMultiple</codeph> contient un tableau des fichiers choisis.</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpenMultiple.1.as"> Le code suivant utilise la méthode <codeph>File.browseForOpenMultiple()</codeph> pour laisser l’utilisateur choisir plusieurs fichiers. Une fois les fichiers sélectionnés, le code renvoie les chemins correspondants.
<codeblock>
import flash.filesystem.*;
import flash.events.FileListEvent;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForOpenMultiple("Select Files");
    docsDir.addEventListener(FileListEvent.SELECT_MULTIPLE, filesSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function filesSelected(event:FileListEvent):void 
{
    for (var i:uint = 0; i &lt; event.files.length; i++) 
    {
        trace(event.files[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:selectMultiple"><linktext>selectMultiple</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Ouvrir. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Ouvrir.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_selectMultiple"><apiName>selectMultiple</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur sélectionne des fichiers et ferme la boîte de dialogue Ouvrir. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur sélectionne des fichiers et ferme la boîte de dialogue Ouvrir.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForSave"><apiName>browseForSave</apiName><shortdesc>
	 Affiche la boîte de dialogue Enregistrer le fichier dans laquelle l’utilisateur peut sélectionner la destination du fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne affichée dans la barre de titre de la boîte de dialogue.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Affiche la boîte de dialogue Enregistrer le fichier dans laquelle l’utilisateur peut sélectionner la destination du fichier. 
	 
	 <p>Lorsque l’utilisateur sélectionne le fichier, l’événement <codeph>select</codeph> est distribué. La propriété <codeph>target</codeph> de l’événement <codeph>select</codeph> est l’objet File qui pointe vers la destination d’enregistrement sélectionnée.</p>
	 
	 </apiDesc><example conref="examples\File.browseForSave.1.as"> Le code suivant utilise la méthode <codeph>File.browseForSave()</codeph> pour permettre à l’utilisateur de sélectionner le chemin d’enregistrement d’un fichier. Une fois les fichiers sélectionnés, le code enregistre les données sur le chemin de fichier sélectionné.
<codeblock>
import flash.filesystem.*;
import flash.events.Event;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForSave("Save As");
    docsDir.addEventListener(Event.SELECT, saveData);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function saveData(event:Event):void 
{
    var newFile:File = event.target as File;
    var str:String = "Hello.";
    if (!newFile.exists)
    {
        var stream:FileStream = new FileStream();
        stream.open(newFile, FileMode.WRITE);
        stream.writeUTFBytes(str);
        stream.close();
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForSave_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Enregistrer le fichier. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur clique sur le bouton Annuler dans la boîte de dialogue Enregistrer le fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForSave_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur sélectionne un fichier et ferme la boîte de dialogue Enregistrer le fichier. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur sélectionne un fichier et ferme la boîte de dialogue Enregistrer le fichier.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:cancel"><apiName>cancel</apiName><shortdesc>
	 Annule toute opération asynchrone en attente.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Annule toute opération asynchrone en attente.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:canonicalize"><apiName>canonicalize</apiName><shortdesc>
	 Rend le chemin de l’objet File canonique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Rend le chemin de l’objet File canonique.
	 
	 <p>Si l’objet File représente un fichier ou un répertoire existant, sa mise en forme canonique ajuste le chemin de sorte qu’il corresponde à la casse du nom réel du fichier ou du répertoire. Si l’objet File est un lien symbolique, sa mise en forme canonique ajuste le chemin de sorte qu’il corresponde au fichier ou au répertoire vers lequel pointe le lien, que ce fichier ou ce répertoire existe ou non. Sur des systèmes de fichiers sensibles à la casse tels que Linux, lorsqu’il existe plusieurs fichiers dont les noms diffèrent au niveau de la casse uniquement, la méthode <codeph>canonicalize()</codeph> ajuste le chemin afin qu’il corresponde au premier fichier trouvé (dans un ordre déterminé par le système de fichiers).</p>
	 
	 <p>De plus, la mise en forme canonique convertit les noms de fichier courts en noms de fichier longs sous Windows.</p>
	 
	 </apiDesc><example conref="examples\File.canonicalize.2.as">     Le code suivant illustre l’utilisation de la méthode <codeph>canonicalize()</codeph> pour identifier la casse correcte du nom d’un répertoire. Avant d’exécuter cet exemple, créez un répertoire AIR Test sur le bureau de votre ordinateur.
<codeblock>
import flash.filesystem.*;

var path:File = File.desktopDirectory.resolvePath("air test");
trace(path.nativePath); 
path.canonicalize();
trace(path.nativePath); // ...\AIR Test

</codeblock></example><example conref="examples\File.canonicalize.1.as">     Le code suivant illustre l’utilisation de la méthode <codeph>canonicalize()</codeph> pour rechercher le nom long d’un répertoire Windows à partir de son nom court. Cet exemple présume qu’un répertoire AIR Test existe à la racine du lecteur C: et que le système lui a attribué le nom court AIR~1.
<codeblock>
import flash.filesystem.*;

var path:File = new File();
path.nativePath = "C:\\AIR~1";
path.canonicalize();
trace(path.nativePath); // C:\AIR Test
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:clone"><apiName>clone</apiName><shortdesc>
	 Renvoie une copie de cet objet File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une copie de cet objet File. Les inscriptions d’événements ne sont pas copiées.
	 
	 <p><i>Remarque :</i> cette méthode ne copie <i>pas</i> le fichier lui-même. Elle fait simplement une copie de l’occurrence de l’objet File <ph platform="actionscript">ActionScript</ph><ph platform="javascript">JavaScript</ph>. Pour copier un fichier, utilisez la méthode <codeph>copyTo()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:copyTo"><apiName>copyTo</apiName><shortdesc>
	 Copie le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File à l’emplacement spécifié par le paramètre newLocation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La source n’existe pas ou la destination existe et <codeph>overwrite</codeph> est <codeph>false</codeph> ; ou la source n’a pas pu être copiée à destination ; ou la source et la destination font référence au même fichier ou dossier et <codeph>overwrite</codeph> est défini sur <codeph>true</codeph>. Windows ne permet pas à l’utilisateur de copier un fichier ouvert ou un répertoire contenant un fichier ouvert.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Emplacement de destination du nouveau fichier. Notez que cet objet File spécifie le fichier ou le répertoire résultant (copié), <i>pas</i> le chemin du répertoire conteneur.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si <codeph>false</codeph>, la copie échoue si le fichier spécifié par le paramètre <codeph>target</codeph> existe déjà. Si la valeur est <codeph>true</codeph>, l’opération remplace tout fichier ou répertoire portant le même nom.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Copie le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File à l’emplacement spécifié par le paramètre <codeph>newLocation</codeph>. Le processus de copie crée tous les répertoires parent requis (si possible).
	 
	 </apiDesc><example conref="examples\File.copyTo.1.as"> Le code suivant illustre l’utilisation de la méthode <codeph>copyTo()</codeph> pour copier un fichier. Avant d’exécuter ce code, créez un fichier test1.txt dans le sous-répertoire AIR Test du répertoire documents de votre ordinateur. Le fichier résultant est nommé test2.txt et est également situé dans le sous-répertoire AIR Test. Lorsque vous définissez le paramètre <codeph>clobber</codeph> sur <codeph>true</codeph>, l’opération remplace tout fichier test2.txt existant.
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:FileReference = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:FileReference = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

if (sourceFile.copyTo(destination, true)) {
    trace("Done.");
}
</codeblock></example><example conref="examples\File.copyTo.2.as"> Le code suivant illustre l’utilisation de la méthode <codeph>copyTo()</codeph> pour copier un fichier. Avant d’exécuter ce code, créez un fichier test1.txt dans le sous-répertoire AIR Test du répertoire d’accueil de votre ordinateur. Le fichier résultant est nommé test2.txt. Les instructions <codeph>try</codeph> et <codeph>catch</codeph> indiquent comment répondre aux erreurs.
<codeblock>
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

try 
{
    sourceFile.copyTo(destination, true);
}
catch (error:Error)
{
    trace("Error:", error.message);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyToAsync()"><linktext>copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()"><linktext>moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:copyToAsync"><apiName>copyToAsync</apiName><shortdesc>
	 Commence par copier le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File à l’emplacement spécifié par le paramètre destination.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Emplacement de destination du nouveau fichier. Notez que cet objet File spécifie le fichier ou le répertoire résultant (copié), <i>pas</i> le chemin du répertoire conteneur.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si <codeph>false</codeph>, la copie échoue si le fichier spécifié par le fichier <codeph>target</codeph> existe déjà. Si la valeur est <codeph>true</codeph>, l’opération remplace tout fichier ou répertoire portant le même nom.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Commence par copier le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File à l’emplacement spécifié par le paramètre <codeph>destination</codeph>. 
	 
	 <p>Lorsque l’opération est terminée, un événement <codeph>complete</codeph> (réussite) ou <codeph>ioError</codeph> (échec) est renvoyé. Le processus de copie crée tous les répertoires parent requis (si possible).</p>
	 
	 </apiDesc><example conref="examples\File.copyToAsync.1.as"> Le code suivant illustre l’utilisation de la méthode <codeph>copyToAsync()</codeph> pour copier un fichier. Avant d’exécuter ce code, assurez-vous de créer un fichier test1.txt dans le sous-répertoire AIR Test du répertoire documents de votre ordinateur. Le fichier résultant est nommé test2.txt et est également situé dans le sous-répertoire AIR Test. Lorsque vous définissez le paramètre <codeph>clobber</codeph> sur <codeph>true</codeph>, l’opération remplace tout fichier test2.txt existant.
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

sourceFile.copyToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileCopiedHandler);

function fileCopiedHandler(event:Event):void {
    trace("Done.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyTo()"><linktext>copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()"><linktext>moveToAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:copyToAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque le fichier ou le répertoire a bien été copié. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le fichier ou le répertoire a bien été copié.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:copyToAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>La source n’existe pas ou la destination existe et <codeph>overwrite</codeph> est <codeph>false</codeph> ; ou la source n’a pas pu être copiée à destination ; ou la source et la destination font référence au même fichier ou dossier et <codeph>overwrite</codeph> est défini sur <codeph>true</codeph>. Windows ne permet pas à l’utilisateur de copier un fichier ouvert ou un répertoire contenant un fichier ouvert.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>La source n’existe pas ou la destination existe et overwrite est false ; ou la source n’a pas pu être copiée à destination ; ou la source et la destination font référence au même fichier ou dossier et overwrite est défini sur true.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:createDirectory"><apiName>createDirectory</apiName><shortdesc>
	 Crée le répertoire spécifié et tous les répertoires parent nécessaires.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le répertoire n’existait pas et n’a pas pu être créé. 
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Crée le répertoire spécifié et tous les répertoires parent nécessaires. Si le répertoire existe déjà, aucune action n’est effectuée.
	 
	 </apiDesc><example conref="examples\File.createDirectory.1.as">     Le code suivant déplace le fichier test.txt situé sur le bureau vers le sous-répertoire AIR Test du répertoire documents. L’appel de la méthode <codeph>createDirectory()</codeph> vérifie l’existence du répertoire AIR Test avant de déplacer le fichier.
<codeblock>
import flash.filesystem.*;

var source:File = File.desktopDirectory.resolvePath("test.txt");
var target:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var targetParent:File = target.parent;
targetParent.createDirectory();
source.moveTo(target, true);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:createTempDirectory"><apiName>createTempDirectory</apiName><shortdesc>
	 Renvoie une référence à un nouveau répertoire temporaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Objet File référençant le nouveau répertoire temporaire.
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une référence à un nouveau répertoire temporaire. Il s’agit d’un nouveau répertoire dans le chemin de répertoire temporaire du système.
	 
	 <p>Cette méthode permet d’identifier un nouveau répertoire unique sans avoir à demander au système de vérifier qu’il est nouveau et unique.</p>
	 
	 <p>Vous pouvez supprimer le répertoire temporaire avant de fermer l’application puisqu’il n’est pas supprimé automatiquement.</p>
	 
	 </apiDesc><example conref="examples\File.createTempDirectory.1.as"> Le code suivant utilise la méthode <codeph>createTempFile()</codeph> pour obtenir une référence à un nouveau répertoire temporaire.
<codeblock>
import flash.File;

var temp:File = File.createTempDirectory();
trace(temp.nativePath);
</codeblock> Chaque fois que vous exécutez ce code, un nouveau fichier (unique) est créé. 
</example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/createTempFile()"><linktext>createTempFile()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:createTempFile"><apiName>createTempFile</apiName><shortdesc>
	 Renvoie une référence à un nouveau fichier temporaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Objet File référençant le nouveau fichier temporaire.
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une référence à un nouveau fichier temporaire. Il s’agit d’un nouveau fichier dans le chemin de répertoire temporaire du système.
	 
	 <p>Cette méthode permet d’identifier un nouveau fichier unique sans avoir à demander au système de vérifier que le fichier est nouveau et unique.</p>
	 
	 <p>Vous pouvez supprimer le fichier temporaire avant de fermer l’application puisqu’il n’est pas supprimé automatiquement.</p>
	 
	 </apiDesc><example conref="examples\File.createTempFile.1.as"> Le code suivant utilise la méthode <codeph>createTempFile()</codeph> pour obtenir une référence à un nouveau fichier temporaire.
<codeblock>
import flash.File;

var temp:File = File.createTempFile();
trace(temp.nativePath);
</codeblock> Chaque fois que vous exécutez ce code, un nouveau fichier (unique) est créé. 
</example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/createTempDirectory()"><linktext>createTempDirectory()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectory"><apiName>deleteDirectory</apiName><shortdesc>
	 Supprime le répertoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le répertoire n’existe pas ou n’a pas pu être supprimé. Windows ne permet pas à l’utilisateur de supprimer un répertoire qui contient un fichier ouvert.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deleteDirectoryContents</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si le répertoire qui contient des fichiers ou des sous-répertoires doit être supprimé. Si <codeph>false</codeph>, et que le répertoire contient des fichiers ou des sous-répertoires, un appel à cette méthode renvoie une exception.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Supprime le répertoire. Si ce fichier est un lien symbolique à un répertoire, seul le lien (et non le répertoire) est supprimé.
	 
	 </apiDesc><example conref="examples\File.deleteDirectory.1.as"> Le code suivant crée un répertoire vide, puis utilise la méthode <codeph>deleteDirectory()</codeph> pour le supprimer. 
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Empty Junk Directory/");
File.createDirectory(directory);
trace(directory.exists); // true
directory.deleteDirectory();
trace(directory.exists); // false
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectoryAsync()"><linktext>deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()"><linktext>deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectoryAsync"><apiName>deleteDirectoryAsync</apiName><shortdesc>
	 Supprime le répertoire de façon asynchrone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deleteDirectoryContents</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si le répertoire qui contient des fichiers ou des sous-répertoires doit être supprimé. Si <codeph>false</codeph> et si le répertoire contient des fichiers ou des répertoires, l’objet File renvoie un événement <codeph>ioError</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Supprime le répertoire de façon asynchrone. Si ce fichier est un lien symbolique à un répertoire, seul le lien (et non le répertoire) est supprimé.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectory()"><linktext>deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()"><linktext>deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque le répertoire a bien été supprimé. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le répertoire a bien été supprimé.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le répertoire n’existe pas ou n’a pas pu être supprimé. Windows ne permet pas à l’utilisateur de supprimer un répertoire qui contient un fichier ouvert.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Le répertoire n’existe pas ou n’a pas pu être supprimé.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:deleteFile"><apiName>deleteFile</apiName><shortdesc>
	 Supprime le fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le fichier n’existe pas ou n’a pas pu être supprimé. Windows ne permet pas de supprimer un fichier ouvert.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Supprime le fichier. Si ce fichier est un lien symbolique, seul le lien (et non le fichier cible) est supprimé.
	 
	 </apiDesc><example conref="examples\File.deleteFile.1.as"> Le code suivant crée un fichier temporaire, puis appelle la méthode <codeph>deleteFile()</codeph> pour le supprimer.
<codeblock>
import flash.filesystem.*;

var file:File = File.createTempFile();
trace(file.exists); // true
file.deleteFile();
trace(file.exists); // false
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectory()"><linktext>deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()"><linktext>deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteFileAsync"><apiName>deleteFileAsync</apiName><shortdesc>
	 Supprime le fichier de façon asynchrone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Supprime le fichier de façon asynchrone. Si ce fichier est un lien symbolique, seul le lien (et non le fichier cible) est supprimé.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectoryAsync()"><linktext>deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()"><linktext>deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque le fichier a bien été supprimé. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le fichier a bien été supprimé.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le fichier n’existe pas ou n’a pas pu être supprimé. Windows ne permet pas de supprimer un fichier ouvert.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Le fichier n’existe pas ou n’a pas pu être supprimé.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListing"><apiName>getDirectoryListing</apiName><shortdesc>
	 Renvoie un tableau d’objets File correspondant aux fichiers et aux répertoires du répertoire représenté par cet objet File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Tableau d’objets File.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie un tableau d’objets File correspondant aux fichiers et aux répertoires du répertoire représenté par cet objet File. Cette méthode n’explore pas le contenu des sous-répertoires.
	 
	 </apiDesc><example conref="examples\File.getDirectoryListing.1.as"> Le code suivant illustre l’utilisation de la méthode <codeph>getDirectoryListing()</codeph> pour énumérer le contenu du répertoire user.
<codeblock>
import flash.filesystem.File;

var directory:File = File.userDirectory;
var list:Array = directory.getDirectoryListing();
for (var i:uint = 0; i &lt; list.length; i++) {
    trace(list[i].nativePath);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListingAsync()"><linktext>getDirectoryListingAsync()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()"><linktext>getRootDirectories()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListingAsync"><apiName>getDirectoryListingAsync</apiName><shortdesc>
	 Récupère de façon asynchrone un tableau d’objets File correspondant au contenu du répertoire représenté par cet objet File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Récupère de façon asynchrone un tableau d’objets File correspondant au contenu du répertoire représenté par cet objet File. 
	 
	 </apiDesc><example conref="examples\File.getDirectoryListingAsync.1.as"> Le code suivant illustre l’utilisation de la méthode <codeph>getDirectoryListingAsync()</codeph> pour énumérer le contenu du répertoire user.
<codeblock>
import flash.filesystem.File;
import flash.events.FileListEvent;

var directory:File = File.userDirectory;
directory.getDirectoryListingAsync();
directory.addEventListener(FileListEvent.DIRECTORY_LISTING, directoryListingHandler);

function directoryListingHandler(event:FileListEvent):void {
    var list:Array = event.files;
    for (var i:uint = 0; i &lt; list.length; i++) {
        trace(list[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListing()"><linktext>getDirectoryListing()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()"><linktext>getRootDirectories()</linktext></link><link href="flash.filesystem.xml#File/event:directoryListing"><linktext>événement directoryListing</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Vous ne disposez pas des autorisations appropriées pour lire ce répertoire, ou le répertoire n’existe pas.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Vous ne disposez pas des autorisations appropriées pour lire ce répertoire, ou le répertoire n’existe pas.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_directoryListing"><apiName>directoryListing</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le contenu du répertoire a bien été énuméré. L’événement <codeph>contents</codeph> comprend une propriété <codeph>files</codeph> correspondant au tableau résultant d’objets File.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Le contenu du répertoire a bien été énuméré.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:getRelativePath"><apiName>getRelativePath</apiName><shortdesc>
	 Recherche le chemin relatif entre deux chemins File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La référence est définie sur <codeph>null</codeph>.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>L’appelant n’est pas dans le sandbox de sécurité de l’application.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chemin relatif entre ce fichier (ou répertoire) et le fichier <codeph>ref</codeph> (ou répertoire), si possible ; autrement, <codeph>null</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>ref</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc> Objet File pour lequel le chemin est donné.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>useDotDot</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc> Spécifie si le chemin relatif résultant peut utiliser des composants « .. » .
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Recherche le chemin relatif entre deux chemins File.
	 
	 <p>Le chemin relatif est la liste des composants qui peuvent être ajoutés (résolus par) à cette référence pour localiser la seconde référence (paramètre). Le chemin relatif est renvoyé avec le caractère de séparation « / ».</p>
	 
	 <p>Les chemins relatifs peuvent éventuellement contenir des références « .. », mais de tels chemins ne traversent pas les limites de volumes visibles.</p>
	 
	 </apiDesc><example conref="examples\File.getRelativePath.1.as"/></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:getRootDirectories"><apiName>getRootDirectories</apiName><shortdesc>
	 Renvoie un tableau d’objets File, indiquant les répertoires racine du système de fichiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Tableau d’objets File énumérant les répertoires racine. 
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie un tableau d’objets File, indiquant les répertoires racine du système de fichiers. 
	 
	 <p>Sous Windows, par exemple, il s’agit de la liste des volumes tels que les lecteurs C: et D:. Les lecteurs vides, tels que des lecteurs CD ou DVD, dans lesquels aucun disque n’était inséré ne sont pas inclus dans ce tableau. Sous Mac et Linux, cette méthode renvoie le répertoire racine unique de la machine (le répertoire « / »).</p>
	 
	 </apiDesc><example conref="examples\File.getRootDirectories.1.as"> Le code suivant renvoie la liste des répertoires racine :
<codeblock>
import flash.filesystem.File;
var rootDirs:Array = File.getRootDirectories();

for (var i:uint = 0; i &lt; rootDirs.length; i++) {
    trace(rootDirs[i].nativePath);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:moveTo"><apiName>moveTo</apiName><shortdesc>
	 Déplace le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File vers l’emplacement spécifié par le paramètre destination.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La source n’existe pas ou la destination existe et <codeph>overwrite</codeph> est défini sur <codeph>false</codeph> ; ou le fichier source n’a pas pu être déplacé vers l’emplacement cible ; ou la source et la destination font référence au même fichier ou dossier et <codeph>overwrite</codeph> est défini sur <codeph>true</codeph>. Windows ne permet pas à l’utilisateur de déplacer un fichier ouvert ou un répertoire contenant un fichier ouvert.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Emplacement cible du déplacement. Cet objet spécifie le chemin du fichier ou du répertoire résultant (déplacé), <i>pas</i> le chemin du répertoire conteneur.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si <codeph>false</codeph>, le déplacement échoue si le fichier <codeph>target</codeph> existe déjà. Si <codeph>true</codeph>, l’opération remplace tout fichier ou répertoire portant le même nom. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Déplace le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File vers l’emplacement spécifié par le paramètre <codeph>destination</codeph>. 
	 
	 <p>Pour renommer un fichier, définissez le paramètre <codeph>destination</codeph> de sorte qu’il pointe vers un chemin situé dans le répertoire du fichier, mais avec un autre nom.</p>
	 
	 <p>Le processus de déplacement crée tous les répertoires parent requis (si possible).</p>
	 
	 </apiDesc><example conref="examples\File.moveTo.1.as"> Le code suivant illustre l’utilisation de la méthode <codeph>moveTo()</codeph> pour renommer un fichier. Le nom d’origine du fichier est test1.txt et le nom résultant test2.txt. Comme les objets File source et cible pointent vers le même répertoire (le sous-répertoire Apollo Test du répertoire documents de l’utilisateur), la méthode <codeph>moveTo()</codeph> renomme le fichier au lieu de le déplacer vers un nouveau répertoire. Avant d’exécuter ce code, créez un fichier test1.txt dans le sous-répertoire AIR Test du répertoire documents de votre ordinateur. Lorsque vous définissez le paramètre <codeph>clobber</codeph> sur <codeph>true</codeph>, l’opération remplace tout fichier test2.txt existant.
<codeblock>

import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

try  
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" error.message);
}
</codeblock></example><example conref="examples\File.moveTo.2.as"> Le code suivant illustre l’utilisation de la méthode <codeph>moveTo()</codeph> pour déplacer un fichier. Le fichier d’origine est le fichier test1.txt du sous-répertoire Apollo Test du répertoire documents de l’utilisateur, et la méthode le déplace vers le sous-répertoire Results. Avant d’exécuter ce code, créez un fichier test1.txt dans le sous-répertoire AIR Test du répertoire d’accueil de votre ordinateur. Les instructions <codeph>try</codeph> et <codeph>catch</codeph> indiquent comment répondre aux erreurs.
<codeblock>
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/Results/test1.txt");

try 
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" error.message);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyTo()"><linktext>copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()"><linktext>moveToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:moveToAsync"><apiName>moveToAsync</apiName><shortdesc>
	 Commence par déplacer le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File vers l’emplacement spécifié par le paramètre newLocation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Emplacement cible du déplacement. Cet objet spécifie le chemin du fichier ou du répertoire résultant (déplacé), <i>pas</i> le chemin du répertoire conteneur.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Si <codeph>false</codeph>, le déplacement échoue si le fichier <codeph>target</codeph> existe déjà. Si <codeph>true</codeph>, l’opération remplace tout fichier ou répertoire portant le même nom.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Commence par déplacer le fichier ou le répertoire situé à l’emplacement spécifié par cet objet File vers l’emplacement spécifié par le paramètre <codeph>newLocation</codeph>. 
	 
	 <p>Pour renommer un fichier, définissez le paramètre <codeph>destination</codeph> de sorte qu’il pointe vers un chemin situé dans le répertoire du fichier, mais avec un autre nom.</p>
	 
	 <p>Le processus de déplacement crée tous les répertoires parent requis (si possible).</p>
	 
	 </apiDesc><example conref="examples\File.moveToAsync.1.as"> Le code suivant illustre l’utilisation de la méthode <codeph>moveToAsync()</codeph> pour renommer un fichier. Le nom d’origine du fichier est test1.txt et le nom résultant test2.txt. Comme les objets File source et cible pointent vers le même répertoire (le sous-répertoire Apollo Test du répertoire documents de l’utilisateur), la méthode <codeph>moveToAsync()</codeph> renomme le fichier au lieu de le déplacer vers un nouveau répertoire. Avant d’exécuter ce code, créez un fichier test1.txt dans le sous-répertoire Apollo Test du répertoire documents de votre ordinateur. Lorsque vous définissez le paramètre <codeph>clobber</codeph> sur <codeph>true</codeph>, l’opération remplace tout fichier test2.txt existant.
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("Apollo Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

var sourceFile.moveToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileMoveCompleteHandler);

function fileMoveCompleteHandler(event:Event):void 
{
    trace("Done.")
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyToAsync()"><linktext>copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()"><linktext>moveTo()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque le fichier ou le répertoire a bien été déplacé. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le fichier ou le répertoire a bien été déplacé.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>La source n’existe pas ; ou la destination existe et <codeph>overwrite</codeph> est défini sur <codeph>false</codeph> ; ou la source n’a pas pu être déplacée vers la cible ; ou la source et la destination font référence au même fichier ou dossier et <codeph>overwrite</codeph> est définie sur <codeph>true</codeph>. Windows ne permet pas à l’utilisateur de déplacer un fichier ouvert ou un répertoire contenant un fichier ouvert.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>La source n’existe pas ; ou la cible existe et overwrite est défini sur false ; ou la source n’a pas pu être déplacée vers la cible ; ou la source et la définition font référence au même fichier ou dossier et overwrite est défini sur true.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:moveToTrash"><apiName>moveToTrash</apiName><shortdesc>
	 Déplace un fichier ou un répertoire vers la corbeille.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le système d’exploitation n’a pas autorisé l’opération ou le fichier ou le répertoire n’existe pas. Windows ne permet pas à l’utilisateur de déplacer un fichier ouvert ou un répertoire contenant un fichier ouvert.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Déplace un fichier ou un répertoire vers la corbeille.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:moveToTrashAsync"><apiName>moveToTrashAsync</apiName><shortdesc>
	 Déplace un fichier ou un répertoire vers la corbeille de façon asynchrone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Déplace un fichier ou un répertoire vers la corbeille de façon asynchrone. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Le système d’exploitation n’a pas autorisé l’opération ou le fichier ou le répertoire n’existe pas. Windows ne permet pas à l’utilisateur de déplacer un fichier ouvert ou un répertoire contenant un fichier ouvert.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Le système d’exploitation n’a pas autorisé l’opération ou le fichier ou le répertoire n’existe pas. </shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque le fichier ou le répertoire a bien été déplacé vers la corbeille.  
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le fichier ou le répertoire a bien été déplacé vers la corbeille. </shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:resolvePath"><apiName>resolvePath</apiName><shortdesc>
	 Crée un nouvel objet File avec un chemin relatif au chemin de cet objet File, en fonction du paramètre path (une chaîne).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet File pointant vers le chemin résultant.
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn><apiParam><apiItemName>path</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chemin à ajouter à la fin du chemin de cet objet File (si le paramètre <codeph>path</codeph> est un chemin relatif) ; ou chemin à renvoyer (si le paramètre <codeph>path</codeph> est un chemin absolu).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Crée un nouvel objet File avec un chemin relatif au chemin de cet objet File, en fonction du paramètre <codeph>path</codeph> (une chaîne).
	 
	 <p>Vous pouvez utiliser un chemin relatif ou absolu comme paramètre <codeph>path</codeph>.</p>
	 
	 <p>Si vous spécifiez un chemin relatif, le paramètre <codeph>path</codeph> fourni est ajouté à la fin du chemin de l’objet File. Toutefois, l’utilisation de « .. » dans le paramètre <codeph>path</codeph> peut renvoyer un chemin résultant qui n’est pas un enfant de l’objet File. La référence résultante n’a pas besoin de faire référence à un emplacement réel du système de fichiers.</p>
	 
	 <p>Si vous spécifiez une référence de fichier absolu, la méthode renvoie l’objet File pointant vers ce chemin. La référence de fichier absolu doit utiliser une syntaxe de chemin native valide pour le système d’exploitation de l’utilisateur (par exemple <codeph>"C:\\test"</codeph> sous Windows). N’utilisez <i>pas</i> d’URL (par exemple <codeph>"file:///c:/test"</codeph>) comme paramètre <codeph>path</codeph>.</p>
	 
	 <p>Tous les chemins résultants sont normalisés comme suit : </p>
	 
	 <ul>
	 
	 	<li>Tout élément « . » est ignoré.</li>
	 
	 	<li>Tout élément « .. » détruit son entrée parent.  </li>
	 
	 	<li>Aucune référence « .. » qui atteint la racine du système de fichiers ou la racine de stockage de l’application ne passe ce noeud ; elle est ignorée.</li>
	 
	 </ul>
	 
	 <p>Veillez à toujours utiliser la barre oblique ( <codeph>/</codeph> ) comme séparateur de chemin. Sous Windows, vous pouvez également utiliser la barre oblique inverse ( <codeph>\</codeph> ), mais l’application risque de ne pas fonctionner correctement sur d’autres plateformes.</p>
	 
	 <p>Sous Linux, les noms de fichier et les noms de répertoire sont sensibles à la casse.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filesystem:File:applicationDirectory:get"><apiName>applicationDirectory</apiName><shortdesc>
	 Dossier contenant les fichiers installés de l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Dossier contenant les fichiers installés de l’application.
	 
	 <p>La propriété <codeph>url</codeph> de cet objet utilise le modèle d’URL <codeph>app</codeph> (pas le modèle d’URL <codeph>file</codeph>). Cela signifie que la chaîne <codeph>url</codeph> est spécifiée en commençant par <codeph>"app:"</codeph> (pas par <codeph>"file:"</codeph>). De même, si vous créez un objet File relatif au répertoire <codeph>File.applicationDirectory</codeph> (en utilisant la méthode <codeph>resolvePath()</codeph>), la propriété <codeph>url</codeph> de l’objet File utilise également le modèle d’URL <codeph>app</codeph>. 
	 </p>
	 
	 <p><i>Remarque :</i> vous ne pouvez pas écrire dans des fichiers ou des répertoires dont le chemin utilise le modèle d’URL <codeph>app</codeph>. Vous ne pouvez pas non plus supprimer ni créer des fichiers ou des dossiers dont le chemin utilise le modèle d’URL <codeph>app</codeph>. Pour des raisons de sécurité, il n’est pas conseillé de modifier le contenu du répertoire de l’application. Pour stocker des données spécifiques à l’application, pensez à utiliser son répertoire de stockage (<codeph>File.applicationStorageDirectory</codeph>). Si vous souhaitez que certains des contenus du répertoire de stockage de l’application aient accès aux fonctionnalités de l’application (les API AIR), vous pouvez exposer cette fonctionnalité à l’aide d’un pont sandbox.</p>
	 
	 <p>La propriété <codeph>applicationDirectory</codeph> permet de référencer le répertoire de l’application de façon à ce qu’il fonctionne sur toutes les plateformes. Si vous définissez un objet File pour référencer le répertoire de l’application à l’aide de la propriété <codeph>nativePath</codeph> ou <codeph>url</codeph>, il ne fonctionne que sur la plateforme pour laquelle ce chemin est valide.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filesystem.xml#File/applicationStorageDirectory"><linktext>applicationStorageDirectory</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:applicationStorageDirectory:get"><apiName>applicationStorageDirectory</apiName><shortdesc>
     Répertoire de stockage privé de l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
     Répertoire de stockage privé de l’application. 
	 
	 <p>Chaque application AIR possède un répertoire de stockage permanent et unique créé lors du premier accès à <codeph>File.applicationStorageDirectory</codeph>. Ce répertoire est très pratique pour stocker les données propres à l’application.</p>
	 
	 <p>Lors de la désinstallation d’une application AIR, le programme de désinstallation ne supprime pas les fichiers stockés dans le répertoire de stockage de l’application.</p>
	 
	 <p>La propriété <codeph>url</codeph> de cet objet utilise le modèle d’URL <codeph>app-storage</codeph> (pas le modèle d’URL <codeph>file</codeph>). Cela signifie que la chaîne <codeph>url</codeph> est spécifiée en commençant par <codeph>"app-storage:"</codeph> (pas par <codeph>"file:"</codeph>). De même, si vous créez un objet File relatif au répertoire <codeph>File.applicationStoreDirectory</codeph> (en utilisant la méthode <codeph>resolvePath()</codeph>), l’<codeph>url</codeph> de l’objet File utilise également le modèle d’URL <codeph>app-storage</codeph> (comme dans l’exemple).</p>
	 
	 <p>La propriété <codeph>applicationStorageDirectory</codeph> permet de référencer le répertoire de stockage de l’application de façon à ce qu’il fonctionne sur toutes les plateformes. Si vous définissez un objet File pour référencer le répertoire de stockage de l’application à l’aide de la propriété <codeph>nativePath</codeph> ou <codeph>url</codeph>, il ne fonctionne que sur la plateforme pour laquelle ce chemin est valide.</p>
	 
	 </apiDesc><example conref="examples\File.applicationStorageDirectory.1.as"> Le code suivant crée un objet File qui pointe vers le sous-répertoire « images » du répertoire de stockage de l’application.
<codeblock>
import flash.filesystem.File;

var tempFiles:File = File.applicationStorageDirectory;
tempFiles = tempFiles.resolvePath("images/");
trace(tempFiles.url); // app-storage:/images
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:desktopDirectory:get"><apiName>desktopDirectory</apiName><shortdesc>
	 Répertoire Bureau de l’utilisateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Répertoire Bureau de l’utilisateur.
	 
	 <p>La propriété <codeph>desktopDirectory</codeph> permet de référencer le répertoire Bureau de façon à ce qu’il fonctionne sur toutes les plateformes. Si vous définissez un objet File pour référencer le répertoire Bureau à l’aide de la propriété <codeph>nativePath</codeph> ou <codeph>url</codeph>, il ne fonctionne que sur la plateforme pour laquelle ce chemin est valide.</p>
	 
	 </apiDesc><example conref="examples\File.desktopDirectory.1.as"> Le code suivant fournit la liste des fichiers et des répertoires contenus dans le répertoire Bureau de l’utilisateur.
<codeblock>
import flash.filesystem.File;
var desktop:File = File.desktopDirectory;

var files:Array = desktop.getDirectoryListing();

for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock><swfblock conref="examples\File.desktopDirectory.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:documentsDirectory:get"><apiName>documentsDirectory</apiName><shortdesc>
	 Répertoire documents de l’utilisateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Répertoire documents de l’utilisateur.
	 
	 <p>Sous Windows, il s’agit du répertoire Mes documents (par exemple C:\Documents and Settings\nomUtilisateur\Mes documents). Sous Mac OS, l’emplacement par défaut est le suivant : /Utilisateurs/nomUtilisateur/Documents. Sous Linux, l’emplacement par défaut est le suivant : /home/nomUtilisateur/Documents (système anglais) et la propriété tient compte du paramètre <codeph>xdg-user-dirs</codeph>. </p>
	 
	 <p>La propriété <codeph>documentsDirectory</codeph> permet de référencer le répertoire documents de façon à ce qu’il fonctionne sur toutes les plateformes. Si vous définissez un objet File pour référencer le répertoire documents à l’aide de la propriété <codeph>nativePath</codeph> ou <codeph>url</codeph>, il ne fonctionne que sur la plateforme pour laquelle ce chemin est valide.</p>
	 
	 </apiDesc><example conref="examples\File.documentsDirectory.1.as"> Le code suivant utilise la propriété <codeph>File.documentsDirectory</codeph> et la méthode <codeph>File.createDirectory()</codeph> pour vérifier l’existence du répertoire « AIR Test » dans le répertoire documents de l’utilisateur.
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory;
directory = directory.resolvePath("AIR Test");

File.createDirectory(directory);
trace(directory.exists); // true
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:exists:get"><apiName>exists</apiName><shortdesc>
     Indique si le fichier ou le répertoire référencé existe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si le fichier ou le répertoire référencé existe. La valeur est <codeph>true</codeph> si l’objet File pointe vers un fichier ou répertoire existant et <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc><example conref="examples\File.exists.1.as"> Le code suivant crée un fichier temporaire, puis le supprime et utilise la propriété <codeph>File.exists</codeph> pour vérifier l’existence du fichier.
<codeblock>
import flash.filesystem.*;

var temp:File = File.createTempFile();
trace(temp.exists); // true
temp.deleteFile();
trace(temp.exists); // false
</codeblock><swfblock conref="examples\File.exists.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:icon:get"><apiName>icon</apiName><shortdesc>
	 Objet Icon contenant les icônes définies pour le fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:Icon</apiValueClassifier></apiValueDef><apiDesc>
	 Objet Icon contenant les icônes définies pour le fichier. Un objet Icon est un tableau d’objets BitmapData correspondant aux différents états des icônes. Sous Linux, l’objet Icon ne contient aucune icône.
	 
	 </apiDesc><example conref="examples\File.icon.1.as"> Le code suivant illustre la recherche de l’image du tableau <codeph>icon</codeph> dont la hauteur est la plus grande, et définit un objet Bitmap sur cette image.
<codeblock>
import flash.filesystem.File;
import flash.display.*;

var directory:File = File.documentsDirectory;
var bitmaps:Array = directory.icon.bitmaps;
var bmpData:BitmapData = new BitmapData(1, 1);
for (var i:uint = 0; i &lt; bitmaps.length; i++) {
    if (bitmaps[i].height > bmpData.height) {
        bmpData = directory.icon.bitmaps[i];
    }
}
var iconBmp:Bitmap = new Bitmap(bmpData);
</codeblock> Vous pouvez ajouter cet objet Bitmap en tant qu’enfant d’un conteneur d’objet d’affichage, par exemple un objet Sprite ou un objet Flex UIComponent.
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isDirectory:get"><apiName>isDirectory</apiName><shortdesc>
     Indique si la référence pointe vers un répertoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si la référence pointe vers un répertoire. La valeur est <codeph>true</codeph> si l’objet File pointe vers un répertoire ; <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc><example conref="examples\File.isDirectory.1.as"> Le code suivant crée un tableau d’objets File pointant vers les fichiers et les répertoires du dossier utilisateur, puis utilise la propriété <codeph>isDirectory</codeph> pour répertorier uniquement les objets File pointant vers des répertoires (pas vers des fichiers).
<codeblock>
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isDirectory) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isDirectory.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isHidden:get"><apiName>isHidden</apiName><shortdesc>
     Indique si le fichier ou le répertoire référencé est « masqué ». La valeur est true si le fichier ou le répertoire référencé est masqué, et false dans le cas contraire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>(Waiting for Stan's OK:)
	 
	 <ul>
	 
	 	<li>On Windows, a file or directory is designated as hidden by specifying the 
	 Hidden attribute (for example, in the File Properties dialog box) for the file.</li>
	 
	 	<li>On Mac OS and Linux, files can be designated as hidden for a number of reasons. Files with 
	 names that begin with the dot (.) character are designated as hidden. A .hidden file 
	 in the root directory lists other hidden files. Also, there is a bit in the file that, 
	 when set, makes it hidden.</li>
	 
	 </ul>
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si le fichier ou le répertoire référencé est « masqué ». La valeur est <codeph>true</codeph> si le fichier ou le répertoire référencé est masqué, et <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc><example conref="examples\File.isHidden.1.as"> Le code suivant crée un tableau d’objets File pointant vers les fichiers et répertoires du dossier utilisateur, puis utilise la propriété <codeph>isHidden</codeph> pour répertorier les fichiers et les répertoires masqués.
<codeblock>
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isHidden) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isHidden.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isPackage:get"><apiName>isPackage</apiName><shortdesc>
     Indique si le répertoire référencé est un package.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si le répertoire référencé est un package.
     
	 <p>La valeur est <codeph>true</codeph> si le fichier ou le répertoire est un package, et <codeph>false</codeph> dans le cas contraire. Notez que la classe File ne permet pas de créer des packages directement.</p>
	 
	 <ul>
	 
	 	<li>Sous Mac OS, les répertoires peuvent être désignés comme des packages et s’affichent dans le Finder sous la forme d’un seul fichier plutôt que sous la forme d’un répertoire. Cette propriété est définie sur <codeph>true</codeph> si le répertoire référencé est un package, et sur <codeph>false</codeph> si le fichier n’est pas un répertoire, n’existe pas ou n’est pas un package.</li>
	 
	 	<li>Sous les autres systèmes d’exploitation, cette propriété est toujours définie sur <codeph>false</codeph>.</li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isSymbolicLink:get"><apiName>isSymbolicLink</apiName><shortdesc>
     Indique si la référence est un lien symbolique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si la référence est un lien symbolique.
     
	 <p>La valeur est <codeph>true</codeph> si l’objet File pointe vers un lien symbolique, et <codeph>false</codeph> dans le cas contraire. Notez que la classe File ne permet pas de créer des liens symboliques directement.</p>
	 
	 <p>Les liens symboliques permettent à un fichier de pointer vers un autre fichier ou un répertoire du disque. Bien que similaires, les liens symboliques ne correspondent pas aux alias de Mac OS ni aux raccourcis de Windows. Un alias ou un raccourci est toujours signalé sous forme de fichier (plutôt que sous forme de répertoire) et la lecture ou l’écriture dans un alias ou un raccourci n’affecte jamais le fichier ou le répertoire original cible. En revanche, un lien symbolique se comporte généralement comme le fichier ou le répertoire vers lequel il pointe. Il peut être signalé comme un fichier ou un répertoire, et la lecture ou l’écriture dans un lien symbolique affecte le fichier ou le répertoire vers lequel il pointe, pas le lien symbolique lui-même. Notez toutefois que la suppression d’un lien symbolique supprime le lien mais pas la cible du lien.</p>
	 
	 <p>Mac<sup>®</sup> OS<sup>®</sup>, Linux et Windows<sup>®</sup> Vista<sup>®</sup> prennent en charge les liens symboliques. De plus, sous Windows, la propriété <codeph>isSymbolicLink</codeph> d’un objet File référençant un point de jonction (utilisé dans le système de fichiers NTFS) est définie sur <codeph>true</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:lineEnding:get"><apiName>lineEnding</apiName><shortdesc>
	 Suite de caractères de fin de ligne utilisée par le système d’exploitation hôte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Suite de caractères de fin de ligne utilisée par le système d’exploitation hôte.
	 
	 <p>Sous Mac OS et Linux, il s’agit du caractère de changement de ligne (code hexadécimal 0x0A). Sous Windows, il s’agit du caractère de retour chariot (code hexadécimal 0x0D) suivi du caractère de changement de ligne (code hexadécimal 0x0A).</p>
	 
	 </apiDesc><example conref="examples\File.lineEnding.1.as"> Le code suivant écrit une chaîne (<codeph>str</codeph>) dans un fichier texte et utilise la propriété statique <codeph>File.lineEnding</codeph> pour remplacer toutes les occurrences du caractère de nouvelle ligne (représenté dans le code par l’expression régulière <codeph>/\n/g</codeph>) par le caractère de fin de ligne favori du système d’exploitation hôte.
<codeblock>
import flash.filesystem.*;

var str:String = "Hello\n" + 
        "World\n";
str = str.replace(/\n/g, File.lineEnding);
var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF(str);
fileStream.close();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:nativePath:get"><apiName>nativePath</apiName><shortdesc>
	 Chemin complet dans la représentation du système d’exploitation hôte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>L’appelant n’est pas dans le sandbox de sécurité de l’application.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>La syntaxe du chemin n’est pas valide.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Chemin complet dans la représentation du système d’exploitation hôte. Sous Mac OS et Linux, la barre oblique (/) est utilisée comme séparateur de chemin. Toutefois, sous Windows, vous pouvez <i>définir</i> la propriété <codeph>nativePath</codeph> en utilisant le caractère barre oblique ou barre oblique inverse (\) comme séparateur de chemin, et AIR remplace automatiquement la barre oblique par le caractère barre oblique inverse approprié.
	 
	<p>Avant d’écrire du code en vue de <i>définir</i> la propriété <codeph>nativePath</codeph> directement, tenez compte du fait que cela peut impliquer l’utilisation de code spécifique à une application. Par exemple, un chemin natif tel que <codeph>"C:\\Documents and Settings\\bob\\Desktop"</codeph> n’est valable que sous Windows. Il est donc préférable d’utiliser les propriétés statiques suivantes, qui représentent les répertoires les plus fréquemment utilisés et qui sont valables sur toutes les plateformes :</p>
	
	<ul>
	<li><codeph>File.applicationDirectory</codeph></li>
	<li><codeph>File.applicationStorageDirectory</codeph></li>
	<li><codeph>File.desktopDirectory</codeph></li>
	<li><codeph>File.documentsDirectory</codeph></li>
	<li><codeph>File.userDirectory</codeph></li>
	</ul>
	
	<p>Vous pouvez utiliser la méthode <codeph>resolvePath()</codeph> pour obtenir un chemin relatif à ces répertoires.</p>
	
	<p product="flex">Certaines API de Flex, telles que la propriété <codeph>source</codeph> de la classe SWFLoader utilisent une URL (la propriété <codeph>url</codeph> d’un objet File), et non un chemin natif (la propriété <codeph>nativePath</codeph>).</p>
	
	<p platform="javascript">Certaines API, telles que la propriété <codeph>src</codeph> d’un objet IMG utilisent une URL (la propriété <codeph>url</codeph> d’un objet File), et non un chemin natif (la propriété <codeph>nativePath</codeph>).</p>
	
	 </apiDesc><example conref="examples\File.nativePath.1.as"> Le code suivant montre la différence entre les propriétés <codeph>nativePath</codeph> et <codeph>url</codeph> d’un objet File. Les commentaires montrent les résultats sur un ordinateur Windows.
<codeblock>
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:parent:get"><apiName>parent</apiName><shortdesc>
     Répertoire qui contient le fichier ou le répertoire référencé par cet objet File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
     Répertoire qui contient le fichier ou le répertoire référencé par cet objet File. 
	 
	 <p>Si le fichier ou le répertoire n’existe pas, la propriété <codeph>parent</codeph> renvoie toujours l’objet File pointant vers le répertoire conteneur, même si ce dernier n’existe pas.</p>
	 
	 <p>Cette propriété est identique à la valeur renvoyée par <codeph>resolvePath("..")</codeph> si ce n’est que le parent d’un répertoire racine est <codeph>null</codeph>.</p>
	 
	 </apiDesc><example conref="examples\File.parent.1.as"> Le code suivant utilise la propriété <codeph>parent</codeph> pour indiquer le répertoire contenant un fichier temporaire.
<codeblock>
import flash.filesystem.File;

var tempFile:File = File.createTempDirectory();
trace(tempFile.parent.nativePath);
tempFile.deleteFile();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:separator:get"><apiName>separator</apiName><shortdesc>
	 Caractère de séparation des composants du chemin du système d’exploitation hôte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Caractère de séparation des composants du chemin du système d’exploitation hôte.
	 
	 <p>Sous Mac OS et Linux, il s’agit de la barre oblique (/). Sous Windows, il s’agit du caractère barre oblique inversée (\).</p>
	 
	 <p><i>Remarque :</i> lorsque vous utilisez le caractère barre oblique inversée dans une chaîne littérale, pensez à taper le caractère à deux reprises (comme dans <codeph>"directory\\file.ext"</codeph>). Chaque paire de barres obliques inversées insérée dans une chaîne représentent une seule barre oblique inversée dans la chaîne.</p>
	 
	 </apiDesc><example conref="examples\File.separator.1.as"> Le code suivant utilise la méthode <codeph>getRelativePath()</codeph> pour obtenir le chemin relatif entre un répertoire et un fichier. Le code utilise ensuite la propriété statique <codeph>File.separator</codeph> pour remplacer les caractères barre oblique (/) du chemin par le caractère de séparation utilisé par le système d’exploitation, c’est-à-dire par une barre oblique inversée (\) sous Windows et une barre oblique dans les autres systèmes d’exploitation.
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Apollo Test");
var file:File = File.documentsDirectory.resolvePath("Apollo Test/employees/bob/test.txt");

var relativePath:String = directory.getRelativePath(file); // employees/bob/test.txt
relativePath = relativePath.replace(/\//g, File.separator);
trace(relativePath); 
</codeblock> Dans cet exemple, la méthode <codeph>replace()</codeph> utilise une expression régulière <codeph>/\//g</codeph> pour la correspondance de <i>tous</i> les caractères barre oblique.
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:spaceAvailable:get"><apiName>spaceAvailable</apiName><shortdesc>
	 Espace disponible pour cet emplacement File, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Espace disponible pour cet emplacement File, en octets. 
	 
	 <p> Si l’objet File fait référence à un répertoire, <codeph>spaceAvailable</codeph> désigne l’espace pouvant être utilisé par des fichiers dans le répertoire. Si l’objet File fait référence à un fichier, <codeph>spaceAvailable</codeph> désigne l’espace que le fichier peut occuper. Si l’emplacement du fichier n’existe pas, <codeph>spaceAvailable</codeph> est défini sur 0. Si l’objet File fait référence à un lien symbolique, <codeph>spaceAvailable</codeph> désigne l’espace disponible à l’emplacement vers lequel pointe le lien symbolique.</p>
	 
	 <p>En général, l’espace disponible pour un répertoire ou un fichier correspond à l’espace disponible sur le volume contenant le répertoire ou le fichier. Toutefois, l’espace disponible peut tenir compte de quotas et de limites par répertoire.</p>
	 
	 <p>L’ajout d’un fichier ou d’un répertoire dans un volume nécessite généralement plus d’espace que la taille réelle du fichier ou du contenu du répertoire. Par exemple, le système d’exploitation peut requérir davantage d’espace pour stocker les informations d’index. De même, les secteurs du disque requis peuvent utiliser un espace supplémentaire. Enfin, l’espace disponible change de façon dynamique. Vous ne pouvez donc pas envisager d’affecter <i>tout</i> l’espace signalé au stockage des fichiers.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:systemCharset:get"><apiName>systemCharset</apiName><shortdesc>
	 Codage par défaut utilisé par le système d’exploitation hôte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Codage par défaut utilisé par le système d’exploitation hôte. 
	 
	 <p>Les valeurs possibles comprennent <codeph>"windows-1252"</codeph> <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>.</p>
	 
	 <p>Vous pouvez utiliser cette valeur lorsque vous utilisez les méthodes <codeph>readMultiByte()</codeph> et <codeph>writeMultiByte()</codeph> de la classe FileStream.</p>
	 
	 </apiDesc><example conref="examples\File.systemCharSet.1.as"> Le code suivant ouvre un fichier (le fichier test.txt situé dans le sous-répertoire AIR Test du répertoire documents de l’utilisateur) et utilise la propriété <codeph>File.systemCharset</codeph> comme paramètre <codeph>charSet</codeph> d’un appel à la méthode <codeph>readMultiByte()</codeph> d’un objet FileStream.
<codeblock>
import flash.filesystem.File;

var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);    
</codeblock></example></apiValueDetail><related-links><link href="flash.filesystem.xml#FileStream/readMultiByte()"><linktext>FileStream.readMultiByte()</linktext></link><link href="flash.filesystem.xml#FileStream/writeMultiByte()"><linktext>FileStream.writeMultiByte()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:url:get"><apiName>url</apiName><shortdesc>
	 URL de ce chemin de fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>The URL will have a null "host" specification. (As opposed to "localhost". This is more confusing than 
	 informative.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>La syntaxe de l’URL n’est pas valide.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>L’appelant n’est pas dans le sandbox de sécurité de l’application.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 URL de ce chemin de fichier.
	 
	 <p>S’il s’agit d’une référence à un chemin dans le répertoire de stockage de l’application, le modèle d’URL est <codeph>"app-storage"</codeph> ; s’il s’agit d’une référence à un chemin dans le répertoire de l’application, le modèle d’URL est <codeph>"app"</codeph> ; autrement le modèle est <codeph>"file"</codeph>. </p>
	 
	 <p>Vous pouvez utiliser des caractères d’espace vide (au lieu de <codeph>"%20"</codeph>) lorsque vous <i>affectez</i> une valeur à la propriété <codeph>url</codeph> ; AIR encode automatiquement les chaînes (par exemple conversion des espaces en <codeph>"%20"</codeph>).</p>
	 
	 </apiDesc><example conref="examples\File.nativePath.1.as"> Le code suivant montre la différence entre les propriétés <codeph>nativePath</codeph> et <codeph>url</codeph> d’un objet File. Les commentaires montrent les résultats sur un ordinateur Windows.
<codeblock>
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail><related-links><link href="flash.filesystem.xml#File/nativePath"><linktext>nativePath</linktext></link><link href="../../package.html#decodeURI()"><linktext>Fonction globale decodeURI()</linktext></link><link href="../../package.html#decodeURIComponent()"><linktext>Fonction globale decodeURIComponent()</linktext></link><link href="../../package.html#encodeURI()"><linktext>Fonction globale decodeURI()</linktext></link><link href="../../package.html#encodeURIComponent()"><linktext>Fonction globale decodeURIComponent()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:userDirectory:get"><apiName>userDirectory</apiName><shortdesc>
	 Répertoire de l’utilisateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Répertoire de l’utilisateur.
	 
	 <p>Sous Windows, il s’agit du parent du répertoire Mes documents (par exemple C:\Documents and Settings\nomUtilisateur). Sous Mac OS, il s’agit de /Utilisateurs/nomUtilisateur. Sous Linux, il s’agit de /home/nomUtilisateur.</p>
	 
	 <p>La propriété <codeph>userDirectory</codeph> permet de référencer le répertoire de l’utilisateur de façon à ce qu’il fonctionne sur toutes les plateformes. Si vous définissez la propriété <codeph>nativePath</codeph> ou <codeph>url</codeph> d’un objet File directement, elle ne fonctionne que sur la plateforme pour laquelle ce chemin est valide.</p>
	 
	 </apiDesc><example conref="examples\File.userDirectory.1.as"> Le code suivant donne la liste des fichiers et répertoires contenus au niveau racine du répertoire de l’utilisateur :
<codeblock>
import flash.filesystem.File;

var files:Array = File.userDirectory.listDirectory();
for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier></apiPackage>