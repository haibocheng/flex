<?xml version="1.0"?>
<apiPackage id="flash.filters"><apiName>flash.filters</apiName><apiDetail/><apiClassifier id="flash.filters:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
La classe ColorMatrixFilter vous permet d’appliquer une transformation de matrice 4 x 5 aux valeurs de couleur RVBA et alpha de chaque pixel de l’image d’entrée afin d’obtenir un résultat intégrant un nouvel ensemble de valeurs de couleur RVBA et alpha.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Applique une transformation de matrice de couleurs sur les valeurs de couleur et de transparence alpha de chaque pixel.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe ColorMatrixFilter vous permet d’appliquer une transformation de matrice 4 x 5 aux valeurs de couleur RVBA et alpha de chaque pixel de l’image d’entrée afin d’obtenir un résultat intégrant un nouvel ensemble de valeurs de couleur RVBA et alpha. Cette classe permet d’effectuer des modifications de saturation et des rotations de teinte, de définir la luminance de l’alpha et de produire d’autres effets. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.

<p><b>Remarque :</b> pour les valeurs RVBA, l’octet le plus significatif représente la valeur du canal rouge, suivie de vert, bleu et alpha.</p>

<p>Pour créer un filtre matrice de couleurs, utilisez la syntaxe <codeph>new ColorMatrixFilter()</codeph>. L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
<ul><li>Pour appliquer des filtres aux clips, champs de texte, boutons et vidéo, utilisez la propriété <codeph>filters</codeph> (héritée de DisplayObject). Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>

<li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
</ul>

<p>Si vous appliquez un filtre à un objet d’affichage, la propriété <codeph>cacheAsBitmap</codeph> de cet objet est réglée sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>

<p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, lorsque vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue atteint les dimensions maximales.</p>

</apiDesc><example conref="examples\ColorMatrixFilterExample.as"> L’exemple suivant applique différents filtres matrice de couleurs à un fichier image. Le constructeur de filtres appelle quatre fois <codeph>buildChild()</codeph> pour charger et afficher quatre occurrences de l’image. Le premier appel à <codeph>buildChild()</codeph> prend <codeph>null</codeph> comme argument, en n’appliquant aucun filtre à la première occurrence. Chaque appel ultérieur à <codeph>buildChild()</codeph> prend comme argument une fonction qui applique un filtre matrice de couleurs différent à chaque occurrence ultérieure de l’image.
 <p>La fonction <codeph>buildChild()</codeph> crée un nouvel objet Loader appelé <codeph>loader</codeph>. Pour chaque appel à <codeph>buildChild()</codeph>, joignez un écouteur d’événements à l’objet Loader pour écouter les événements <codeph>complete</codeph> qui sont gérés par la fonction transmise à <codeph>buildChild()</codeph>.</p>
 
 <p>Les fonctions <codeph>applyRed()</codeph>, <codeph>applyGreen()</codeph> et <codeph>applyBlue()</codeph> utilisent différentes valeurs pour le tableau <codeph>matrix</codeph> afin d’obtenir différents effets.</p>
 <p><b>Remarque </b>: pour de meilleurs résultats, utilisez une image d’une largeur de 80 pixels environ. Le nom et l’emplacement du fichier image doivent correspondre à la valeur que vous transmettez à la propriété <codeph>url</codeph>. En l’occurrence, dans l’exemple, la valeur transmise à <codeph>url</codeph> pointe vers un fichier image nommé « Image.jpg » qui est situé dans le même répertoire que votre fichier SWF.
 </p>
 <codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.filters.ColorMatrixFilter;
    import flash.net.URLRequest;

    public class ColorMatrixFilterExample extends Sprite {
        private var size:uint  = 140;
        private var url:String = "Image.jpg";

        public function ColorMatrixFilterExample() {
            buildChild(null);
            buildChild(applyRed);
            buildChild(applyGreen);
            buildChild(applyBlue);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if (loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyRed(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([1, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyGreen(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 1, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyBlue(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>flash.display.BitmapData.getPixel()</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:ColorMatrixFilter:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
	Initialise une nouvelle occurrence de ColorMatrixFilter avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de 20 éléments organisés en matrice de 4 x 5.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Initialise une nouvelle occurrence ColorMatrixFilter.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Initialise une nouvelle occurrence de ColorMatrixFilter avec les paramètres spécifiés.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ColorMatrixFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
 	clones it using the <code>clone</code> method. The <code>matrix</code> property cannot be changed directly (for example,
	<code>clonedFilter.matrix[2] = 1;</code>). Instead, you must get a reference
	to the array, make the change, and reset the value using
	<code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter:       " + filter.matrix);
	
	var clonedFilter:ColorMatrixFilter = filter.clone();
	matrix = clonedFilter.matrix;
	matrix[2] = 1;
	clonedFilter.matrix = matrix;
	trace("clonedFilter: " + clonedFilter.matrix);
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de ColorMatrixFilter dont les propriétés sont toutes identiques à celles de l’occurrence d’origine.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ColorMatrixFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	Tableau de 20 éléments pour la transformation de couleurs 4 x 5.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
  	changes its <code>matrix</code> property. The <code>matrix</code> property cannot be changed by directly modifying
  	its value (for example, <code>clonedFilter.matrix[2] = 1;</code>). Instead, you must
  	get a reference to the array, make the change to the reference, and reset the
	value using <code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter: " + filter.matrix);
	var changedMatrix:Array = filter.matrix;
	changedMatrix[2] = 1;
	filter.matrix = changedMatrix;
	trace("filter: " + filter.matrix);
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Tableau de 20 éléments pour la transformation de couleurs 4 x 5. Il est impossible de changer la propriété <codeph>matrix</codeph> directement en modifiant sa valeur (par exemple, <codeph>myFilter.matrix[2] = 1;</codeph>). A la place, extrayez une référence au tableau, effectuez la modification de la référence et restaurez la valeur.
	
	<p>Le filtre matrice de couleurs sépare chaque pixel d’origine en composants rouge, vert, bleu et alpha comme suit : srcR, srcG, srcB, srcA. Pour calculer le résultat des quatre canaux, la valeur de chaque pixel de l’image est multipliée par les valeurs de la matrice de transformation. Un décalage, compris entre -255 et 255, peut éventuellement être ajouté à chaque résultat (le cinquième élément de chaque ligne de la matrice). Le filtre associe les composants de couleur pour former un pixel unique et renvoie le résultat. Dans la formule suivante, les éléments a[0] à a[19] correspondent aux entrées 0 à 19 du tableau de 20 éléments qui est transmis à la propriété <codeph>matrix</codeph> :</p>
	<pre>
	redResult   = (a[0]  ~~ srcR) + (a[1]  ~~ srcG) + (a[2]  ~~ srcB) + (a[3]  ~~ srcA) + a[4]
	greenResult = (a[5]  ~~ srcR) + (a[6]  ~~ srcG) + (a[7]  ~~ srcB) + (a[8]  ~~ srcA) + a[9]
	blueResult  = (a[10] ~~ srcR) + (a[11] ~~ srcG) + (a[12] ~~ srcB) + (a[13] ~~ srcA) + a[14]
	alphaResult = (a[15] ~~ srcR) + (a[16] ~~ srcG) + (a[17] ~~ srcB) + (a[18] ~~ srcA) + a[19]
	</pre>
	
	<p>Pour chaque valeur de couleur du tableau, la valeur 1 signifie que 100 % de ce canal est envoyé en sortie, préservant la valeur du canal de couleur.</p>
	
	<p>Les calculs sont effectués sur des valeurs de couleur non multipliées. Si le graphique d’entrée est constitué de valeurs de couleur prémultipliées, celles-ci sont automatiquement converties en valeurs de couleur non multipliées en vue de cette opération.</p>
	
	<p>Deux modes optimisés sont disponibles :</p>
	
	<p><b>Alpha uniquement.</b> Quand vous transmettez au filtre une matrice qui ajuste uniquement le composant alpha, comme indiqué ici, le filtre optimise ses performances :</p>
	<pre>
	    1 0 0 0 0
	    0 1 0 0 0
	    0 0 1 0 0
	    0 0 0 N 0  (where N is between 0.0 and 1.0)
	</pre>
	
	<p><b>Version plus rapide</b>. Disponible uniquement sur les processeurs dotés d’un accélérateur SSE/Altivec (tels qu’Intel<sup>®</sup> Pentium<sup>®</sup> 3 et version ultérieure, Apple<sup>®</sup> G4 et version ultérieure). L’accélérateur est utilisé quand les termes de multiplicateur sont compris entre -15,99 et 15,99, et les termes d’additionneur a[4], a[9], a[14] et a[19] sont compris entre -8 000 et 8 000.</p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
 La classe GradientGlowFilter permet d’appliquer un effet de rayonnement dégradé à des objets d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Permet de créer un effet néon en dégradé.
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe GradientGlowFilter permet d’appliquer un effet de rayonnement dégradé à des objets d’affichage. L’aspect d’un rayonnement dégradé est réaliste et inclut un dégradé de couleurs que vous pouvez contrôler. Vous pouvez appliquer un rayonnement dégradé autour du bord intérieur ou extérieur d’un objet, ou encore par-dessus l’objet. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.
 
 <p>L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
 <ul><li>Pour appliquer des filtres aux objets d’affichage, utilisez la propriété <codeph>filters</codeph>. Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>
 
 <li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
 </ul>
 
 <p>Si vous appliquez un filtre à un objet d’affichage, la propriété <codeph>cacheAsBitmap</codeph> de cet objet est réglée sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p> 
 
 <p>Ce filtre prend en charge le redimensionnement de la scène. Toutefois, le redimensionnement général, la rotation et l’inclinaison ne sont pas pris en charge. Si l’objet est lui-même redimensionné (si les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne sont pas réglées sur 1,0), l’effet de filtre n’est pas redimensionné. Le redimensionnement est effectué uniquement en cas de zoom avant sur la scène.</p>
 
 <p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, lorsque vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>
 
 </apiDesc><example conref="examples\GradientGlowFilterExample.as"> L’exemple suivant dessine un carré auquel un filtre de rayonnement dégradé est appliqué. La séquence des principales tâches de l’exemple s’organise comme suit :
 <ol>
  <li>Importation des classes requises.</li>
  <li>Déclaration des variables globales utilisées pour définir le carré et le filtre.</li>
  <li>Création de la fonction constructeur qui effectue les actions suivantes :
      <ul>
          <li>Appel de la méthode <codeph>draw()</codeph> qui utilise des méthodes de la classe Graphics, accessibles par le biais de la propriété <codeph>graphics</codeph> de Sprite, pour dessiner un carré.</li>
          <li>Création d’un objet BitmapFilter nommé <codeph>filter</codeph> auquel est attribuée la valeur renvoyée d’un appel à <codeph>getBitmapFilter()</codeph> qui crée le filtre.</li>
          <li>Création d’un nouveau tableau nommé <codeph>myFilters</codeph> auquel est ajouté <codeph>filter</codeph>.</li>
          <li>Attribution de <codeph>myFilters</codeph> à la propriété <codeph>filters</codeph> de l’objet GradientGlowFilterExample. Ceci a pour effet d’appliquer tous les filtres trouvés dans <codeph>myFilters</codeph>, en l’occurrence <codeph>filter</codeph> uniquement.</li>
      </ul>
  </li>
 </ol>
<codeblock>
package {
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientGlowFilter;
    import flash.display.Sprite;

    public class GradientGlowFilterExample extends Sprite {
        private var bgColor:uint = 0xCCCCCC;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        private var distance:Number  = 0;
        private var angleInDegrees:Number = 45;
        private var colors:Array     = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
        private var alphas:Array     = [0, 1, 1, 1];
        private var ratios:Array     = [0, 63, 126, 255];
        private var blurX:Number     = 50;
        private var blurY:Number     = 50;
        private var strength:Number  = 2.5;
        private var quality:Number   = BitmapFilterQuality.HIGH;
        private var type:String      = BitmapFilterType.OUTER;
        private var knockout:Boolean = false;

        public function GradientGlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientGlowFilter(distance,
                                          angleInDegrees,
                                          colors,
                                          alphas,
                                          ratios,
                                          blurX,
                                          blurY,
                                          strength,
                                          quality,
                                          type,
                                          knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>Classe GlowFilter</linktext></link></related-links><apiConstructor id="flash.filters:GradientGlowFilter:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
	Initialise le filtre avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a gradient glow filter, assigns 
	its values, and applies it to a flat rectangle image.
	
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var art:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	var distance:Number = 0;
	var angleInDegrees:Number = 45;
 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
 	var alphas:Array = [0, 1, 1, 1];
 	var ratios:Array = [0, 63, 126, 255];
	var blurX:Number = 50;
	var blurY:Number = 50;
	var strength:Number = 2.5;
	var quality:Number = 3;
	var type:String = "outer";
	var knockout:Boolean = false;
	
	var filter:GradientGlowFilter = new GradientGlowFilter(distance, 
														 angleInDegrees, 
														 colors, 
														 alphas, 
														 ratios, 
														 blurX, 
														 blurY, 
														 strength, 
														 quality, 
														 type, 
														 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	art.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
	mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Distance de décalage du rayonnement. 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Angle, exprimé en degrés. Les valeurs valides sont comprises entre 0 et 360. 
	
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de couleurs définissant un dégradé. Par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.
	
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de valeurs de transparence alpha pour les couleurs correspondantes du tableau <codeph>colors</codeph>. Les valeurs valides pour chaque élément du tableau sont comprises entre 0 et 1. La valeur 0,25, par exemple, définit une valeur de transparence alpha de 25 %.
	
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau des taux de répartition des couleurs. Les valeurs valides sont comprises entre 0 et 255. Cette valeur définit le pourcentage de la largeur où la couleur est échantillonnée sur 100 %.
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste entre le rayonnement et l’arrière-plan est important. Les valeurs valides sont comprises entre 0 et 255. Plus la valeur est élevée, plus l’empreinte est marquée. La valeur 0 signifie que le filtre n’est pas appliqué.
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Nombre d’applications du filtre. Utilisez les constantes BitmapFilterQuality :
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Pour plus d’informations, voir la description de la propriété <codeph>quality</codeph>.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Positionnement de l’effet de filtre. Les valeurs possibles sont les constantes flash.filters.BitmapFilterType :
	<ul>
	<li><codeph>BitmapFilterType.OUTER</codeph>, rayonnement sur le bord extérieur de l’objet ;</li>
	<li><codeph>BitmapFilterType.INNER</codeph>, rayonnement sur le bord intérieur de l’objet, il s’agit de la valeur par défaut.</li>
	<li><codeph>BitmapFilterType.FULL</codeph>, rayonnement au-dessus de l’objet.</li>
	</ul>
	
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Spécifie si l’objet a un effet de masquage. Un effet de masquage rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. La valeur <codeph>true</codeph> spécifie un effet de masquage ; la valeur par défaut est <codeph>false</codeph> (pas d’effet de masquage).
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialise le filtre avec les paramètres spécifiés.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:GradientGlowFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GradientGlowFilter objects and compares them; <code>filter_1</code>
	is created by using the GradientGlowFilter construtor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example below modifies the <code>knockout</code> property of <code>filter_1</code>. Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de GradientGlowFilter dont toutes les propriétés sont identiques à celles de l’occurrence de GradientGlowFilter d’origine.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientGlowFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	Tableau de valeurs de transparence alpha pour les couleurs correspondantes du tableau colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alphas</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAlphas");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var alphas:Array = filter.alphas;
		alphas.pop();
		alphas.pop();
		alphas.push(.3);
		alphas.push(1);
		filter.alphas = alphas;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Tableau de valeurs de transparence alpha.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Tableau de valeurs de transparence alpha pour les couleurs correspondantes du tableau <codeph>colors</codeph>. Les valeurs valides pour chaque élément du tableau sont comprises entre 0 et 1. Par exemple, 0,25 définit une valeur de transparence de 25 %.
	
	<p>La propriété <codeph>alphas</codeph> ne peut pas être modifiée en manipulant directement ses valeurs. Vous devez obtenir une référence à <codeph>alphas</codeph>, effectuer les modifications sur la référence, puis définir la propriété <codeph>alphas</codeph> sur la référence.</p>
	
	<p>Les propriétés <codeph>colors</codeph>, <codeph>alphas</codeph> et <codeph>ratios</codeph> sont liées. Le premier élément du tableau <codeph>colors</codeph> correspond au premier élément du tableau <codeph>alphas</codeph>, du tableau <codeph>ratios</codeph>, etc.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Angle, exprimé en degrés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAngle");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 50;
		filter.angle = 90;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Angle, exprimé en degrés. Les valeurs valides sont comprises entre 0 et 360. La valeur par défaut est 45. 
	
	<p>La valeur d’angle représente l’angle de la source lumineuse théorique éclairant l’objet et détermine l’emplacement de l’effet par rapport à ce dernier. Si la valeur de <codeph>distance</codeph> est 0, il n’y a pas d’effet de décalage par rapport à l’objet. La propriété <codeph>angle</codeph> n’a donc aucun effet.</p>
        
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	 Quantité de flou horizontal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	 Quantité de flou vertical.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:colors:get"><apiName>colors</apiName><shortdesc>
	 Tableau de couleurs définissant un dégradé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>colors</code> property on an existing movie clip 
	 when a user clicks it.
	 <listing version="2.0">
	 import flash.filters.GradientGlowFilter;
	 var mc:MovieClip = createGradientGlowRectangle("GlowColors");
	 mc.onRelease = function() {
	 	var filter:GradientGlowFilter = this.filters[0];
	 	var colors:Array = filter.colors;
	 	colors.pop();
	 	colors.push(0xFF00FF);
	 	filter.colors = colors;
	 	this.filters = new Array(filter);
	 }
	 
	 function createGradientGlowRectangle(name:String):MovieClip {
	 	var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
	 	var w:Number = 100;
	 	var h:Number = 100;
	 	art.beginFill(0x003366);
	 	art.lineTo(w, 0);
	 	art.lineTo(w, h);
	 	art.lineTo(0, h);
	 	art.lineTo(0, 0);
	 	art._x = 20;
	 	art._y = 20;
	 
	 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	 	var alphas:Array = [0, 1, 1, 1];
	 	var ratios:Array = [0, 63, 126, 255];
	 	var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	 	var filterArray:Array = new Array();
	 	filterArray.push(filter);
	 	art.filters = filterArray;
	 	return art;
	 }
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Tableau de couleurs définissant un dégradé. Par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.
	 
	 <p>La propriété <codeph>colors</codeph> ne peut pas être modifiée en manipulant directement ses valeurs. Vous devez obtenir une référence à <codeph>colors</codeph>, effectuer les modifications sur la référence, puis définir la propriété <codeph>colors</codeph> sur la référence.</p>
	 
	 <p>Les propriétés <codeph>colors</codeph>, <codeph>alphas</codeph> et <codeph>ratios</codeph> sont liées. Le premier élément du tableau <codeph>colors</codeph> correspond au premier élément du tableau <codeph>alphas</codeph>, du tableau <codeph>ratios</codeph>, etc.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Distance de décalage du rayonnement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowDistance");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 20;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Distance de décalage du rayonnement. La valeur par défaut est 4.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Spécifie si l’objet a un effet de masquage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowKnockout");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}

	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie si l’objet a un effet de masquage. Un effet de masquage rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. La valeur <codeph>true</codeph> spécifie un effet de masquage ; la valeur par défaut est <codeph>false</codeph> (pas d’effet de masquage).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Nombre d’applications du filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowQuality");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.quality = 3;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Nombre d’applications du filtre. La valeur par défaut est <codeph>BitmapFilterQuality.LOW</codeph>, ce qui revient à appliquer le filtre une seule fois. La valeur <codeph>BitmapFilterQuality.MEDIUM</codeph> applique le filtre deux fois. La valeur <codeph>BitmapFilterQuality.HIGH</codeph> l’applique trois fois. Les rendus des filtres de valeurs faibles sont obtenus plus rapidement.
	
	<p>Pour la plupart des applications, une valeur de <codeph>quality</codeph> faible, moyenne ou élevée est suffisante. Il est possible d’utiliser des valeurs numériques allant jusqu’à 15 pour obtenir différents effets, mais le rendu des valeurs les plus élevées est moins rapide. Sans augmenter la valeur de <codeph>quality</codeph>, vous pouvez généralement obtenir un effet similaire, avec un rendu plus rapide, en augmentant simplement les valeurs des propriétés <codeph>blurX</codeph> et <codeph>blurY</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	Tableau de taux de répartition des couleurs, pour les couleurs correspondantes du tableau colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>ratios</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowRatios");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var ratios:Array = filter.ratios;
		ratios.shift();
		ratios.unshift(40);
		filter.ratios = ratios;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Tableau de taux de répartition des couleurs, pour les couleurs correspondantes du tableau <codeph>colors</codeph>. Les valeurs valides sont comprises entre 0 et 255. 
	
	<p>La propriété <codeph>ratios</codeph> ne peut pas être modifiée en manipulant directement ses valeurs. Vous devez obtenir une référence à <codeph>ratios</codeph>, effectuer les modifications sur la référence, puis définir la propriété <codeph>ratios</codeph> sur la référence.</p>
	
	<p>Les propriétés <codeph>colors</codeph>, <codeph>alphas</codeph> et <codeph>ratios</codeph> sont liées. Le premier élément du tableau <codeph>colors</codeph> correspond au premier élément du tableau <codeph>alphas</codeph>, du tableau <codeph>ratios</codeph>, etc.</p>
	
	<p>Considérez le filtre de rayonnement dégradé comme un rayonnement émanant du centre de l’objet (si la valeur <codeph>distance</codeph> est définie sur 0), avec des bandes de couleurs se mêlant les unes aux autres pour constituer le dégradé. La première couleur du tableau <codeph>colors</codeph> est la couleur la plus proche de l’extérieur du rayonnement. La dernière couleur est la plus au centre du rayonnement.</p> 
	
	<p>Chaque valeur du tableau <codeph>ratios</codeph> définit l’emplacement de la couleur sur le rayon du dégradé, 0 représentant le point le plus éloigné et 255, le point le plus proche du centre du dégradé. Les valeurs de ratio s’échelonnent progressivement de 0 à 255 pixels : par exemple [0, 64, 128, 200, 255]. Les valeurs comprises entre 0 et 128 apparaissent sur les bords extérieurs du rayonnement. Les valeurs comprises entre 129 et 255 apparaissent à l’intérieur du rayonnement. Selon les valeurs de ratio des couleurs et la valeur <codeph>type</codeph> du filtre, les couleurs du filtre peuvent être obscurcies par l’objet auquel le filtre est appliqué.</p>
	
	<p>Dans le code et l’image ci-dessous, un filtre est appliqué à un cercle noir animé, le type étant défini sur la valeur <codeph>"full"</codeph>. Pour les besoins de la démonstration, la première couleur du tableau <codeph>colors</codeph>, rose, a une valeur <codeph>alpha</codeph> de 1 pour qu’elle se détache bien sur le fond blanc du document (dans la pratique, vous ne choisirez probablement pas la première couleur ainsi). La dernière couleur du tableau, jaune, cache le cercle noir auquel le filtre est appliqué :</p>
	
	<p><pre>
	var colors:Array = [0xFFCCFF, 0x0000FF, 0x9900FF, 0xFF0000, 0xFFFF00];
	var alphas:Array = [1, 1, 1, 1, 1];
	var ratios:Array = [0, 32, 64, 128, 225];
	var myGGF:GradientGlowFilter = new GradientGlowFilter(0, 0, colors, alphas, ratios, 50, 50, 1, 2, "full", false);
	</pre></p>
    <p><adobeimage alt="Filtre de rayonnement dégradé avec un tableau des rapports de 0, 32, 64, 128, 225." href="../../images/gradientGlowDiagram.jpg"/></p>
	
	<p>Pour obtenir un effet de transparence homogène sur le fond de votre document lorsque vous définissez la valeur <codeph>type</codeph> sur <codeph>"outer"</codeph> ou <codeph>"full"</codeph>, définissez la première couleur du tableau comme identique à celle de l’arrière-plan du document, ou définissez la valeur alpha de la première couleur sur 0. Ces deux techniques entraînent le mélange du filtre avec l’arrière-plan.</p>
	
	<p>Deux petites modifications au code peuvent se traduire par un effet du rayonnement complètement différent et ce, même si les tableaux <codeph>ratios</codeph> et <codeph>colors</codeph> restent les mêmes. Définissez la valeur alpha de la première colonne du tableau sur 0 pour que le filtre se mélange à l’arrière-plan blanc du document ; puis définissez la propriété <codeph>type</codeph> sur <codeph>"outer"</codeph> ou <codeph>"inner"</codeph>. Observez le résultat sur les illustrations suivantes.</p>
        <p><adobeimage alt="outer glow" href="../../images/gradientGlowOuter.jpg"/> <adobeimage alt="inner glow" href="../../images/gradientGlowInner.jpg"/></p>
	<p>N’oubliez pas que la répartition des couleurs dans le dégradé varie en fonction des valeurs des propriétés <codeph>blurX</codeph>, <codeph>blurY</codeph>, <codeph>strength</codeph> et <codeph>quality</codeph>, ainsi que des valeurs de <codeph>ratios</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Intensité de l’empreinte ou recouvrement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowStrength");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste entre le rayonnement et l’arrière-plan est important. Les valeurs valides sont comprises entre 0 et 255. La valeur 0 signifie que le filtre n’est pas appliqué. La valeur par défaut est 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:type:get"><apiName>type</apiName><shortdesc>
	Positionnement de l’effet de filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowType");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.type = "inner";
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>La chaîne prend la valeur null lors de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Positionnement de l’effet de filtre. Les valeurs possibles sont les constantes flash.filters.BitmapFilterType :
	<ul><li><codeph>BitmapFilterType.OUTER</codeph>, rayonnement sur le bord extérieur de l’objet.</li>
	<li><codeph>BitmapFilterType.INNER</codeph>, rayonnement sur le bord intérieur de l’objet, il s’agit de la valeur par défaut.</li>
	<li><codeph>BitmapFilterType.FULL</codeph>, rayonnement au-dessus de l’objet.</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
La classe DisplacementMapFilter utilise les valeurs de pixels de l’objet BitmapData spécifié (appelé image de mappage du déplacement) pour déplacer un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Déplace l’objet d’origine auquel le filtre s’applique.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe DisplacementMapFilter utilise les valeurs de pixels de l’objet BitmapData spécifié (appelé <i>displacement map image</i>) pour déplacer un objet. Vous pouvez utiliser ce filtre pour appliquer un effet voilé ou tacheté à tout objet héritant des propriétés de la classe DisplayObject, tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.

<p>L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
<ul><li>Pour appliquer des filtres à un objet d’affichage, utilisez la propriété <codeph>filters</codeph> de cet objet. Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>

<li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
</ul>

<p>Si vous appliquez un filtre à un objet d’affichage, la valeur de la propriété <codeph>cacheAsBitmap</codeph> de cet objet est définie sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>

<p>Le filtre utilise la formule suivante :</p>

<codeblock>
dstPixel[x, y] = srcPixel[x + ((componentX(x, y) - 128) ~~ scaleX) / 256, y + ((componentY(x, y) - 128) ~~scaleY) / 256)
</codeblock>

<p>où <codeph>componentX(x, y)</codeph> extrait la valeur de couleur de la propriété <codeph>componentX</codeph> de la propriété <codeph>mapBitmap</codeph>, à <codeph>(x - mapPoint.x ,y - mapPoint.y)</codeph>.</p>

<p>L’image de mappage utilisée par le filtre est redimensionnée en fonction de l’échelle de la scène. Elle n’est en aucun cas redimensionnée lorsque l’objet l’est.</p>

<p>Ce filtre prend en charge le redimensionnement de la scène. Mais le redimensionnement général, la rotation et l’inclinaison ne sont pas gérés. Si l’objet lui-même est redimensionné (si les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne correspondent pas à 1,0), l’effet du filtre n’est pas redimensionné. Le redimensionnement est effectué uniquement en cas de zoom avant sur la scène.</p>

 </apiDesc><example conref="examples\DisplacementMapFilterExample.as"> L’exemple suivant dessine un carré avec un remplissage en dégradé radial, une zone de texte et un objet BitmapData sont créés et un filtre de mappage du déplacement est appliqué à l’objet DisplacementMapFilterExample. La séquence des principales tâches de cet exemple s’organise comme suit :
 <ol>
  <li>La classe définit des variables pour la couleur de l’arrière-plan, le libellé de la zone de texte, ainsi que pour la taille et le décalage qui seront utilisés dans diverses fonctions.</li>
  <li>La fonction constructeur appelle la méthode <codeph>draw()</codeph> qui utilise les méthodes de la classe Graphics pour dessiner un carré avec un remplissage en dégradé radial. Remarquez que <codeph>graphics</codeph> est une propriété de l’objet DisplacementMapFilterExample qui étend Sprite.</li>
  <li>La fonction constructeur appelle la méthode <codeph>createLabel()</codeph> qui crée une zone de texte affichant la valeur de <codeph>labelText</codeph> et l’ajoute à la liste d’affichage.</li>
  <li>La fonction constructeur appelle la méthode <codeph>createFilter()</codeph> qui effectue les actions suivantes :
      <ul>
          <li>Création d’une variable nommée <codeph>filter</codeph> pour l’objet filtre.</li>
          <li>Appel de la méthode <codeph>getDisplacementMapFilter()</codeph> et attribution de sa valeur renvoyée à la variable <codeph>filter</codeph>.</li>
          <li>Transmission de <codeph>filter</codeph> à la propriété <codeph>filters</codeph> de l’objet DisplacementFilterExample (la classe principale).</li>
      </ul>
   </li> 
  <li>La méthode <codeph>getBitmapFilter()</codeph> crée un objet BitmapData nommé <codeph>mapBitmap</codeph> et lui attribue les résultat de la méthode <codeph>createBitmapData()</codeph>. L’objet <codeph>mapBitmap</codeph>, parallèlement à d’autres variables, définit un nouveau filtre de mappage du déplacement.</li>
  <li>La méthode <codeph>createBitmapData()</codeph> crée un nouvel objet BitmapData basé sur le contenu actuel de l’objet DisplacementMapFilterExample. Une nouvelle image bitmap est créée d’après <codeph>bitmapData</codeph> et est ajoutée à la scène.</li>
 </ol>
<codeblock>
package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.BitmapDataChannel;
    import flash.display.GradientType;
    import flash.display.SpreadMethod;
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.DisplacementMapFilter;
    import flash.filters.DisplacementMapFilterMode;
    import flash.geom.Matrix;
    import flash.geom.Point;
    import flash.text.TextField;
    
    public class DisplacementMapFilterExample extends Sprite {
        private var bgColor:uint     = 0xFFCC00;
        private var size:uint        = 200;
        private var offset:uint      = 90;
        private var labelText:String = "Watch the text bend with the displacement map";

        public function DisplacementMapFilterExample() {
            draw();
            createLabel();
            createFilter();
        }

        private function createFilter():void {
            var filter:BitmapFilter = getBitmapFilter();
            filters = new Array(filter);
        }

        private function getBitmapFilter():BitmapFilter {
            var mapBitmap:BitmapData = createBitmapData();
            var mapPoint:Point       = new Point(0, 0);
            var channels:uint        = BitmapDataChannel.RED;
            var componentX:uint      = channels;
            var componentY:uint      = channels;
            var scaleX:Number        = 0.5;
            var scaleY:Number        = -30;
            var mode:String          = DisplacementMapFilterMode.CLAMP;
            var color:uint           = 0;
            var alpha:Number         = 0;
            return new DisplacementMapFilter(mapBitmap,
                                             mapPoint,
                                             componentX,
                                             componentY,
                                             scaleX,
                                             scaleY,
                                             mode,
                                             color,
                                             alpha);
        }

        private function draw():void {
            var matrix:Matrix = new Matrix();
            matrix.createGradientBox(size, size);
            graphics.beginGradientFill(GradientType.RADIAL,
                                       [0xFF0000, 0x0000FF],
                                       [100, 100],
                                       [55, 200],
                                       matrix,
                                       SpreadMethod.PAD);
            graphics.drawRect(0, 0, size, size);
        }

        private function createBitmapData():BitmapData {
            var bitmapData:BitmapData = new BitmapData(size, size, true, bgColor);
            bitmapData.draw(this, new Matrix());
            var bitmap:Bitmap = new Bitmap(bitmapData);
            bitmap.x = size;
            addChild(bitmap);
            return bitmapData;
        }

        private function createLabel():void {
            var tf:TextField = new TextField();
            tf.text = labelText;
            tf.y = offset;
            tf.width = size;
            addChild(tf);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DisplacementMapFilter:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
	Initialise une occurrence de DisplacementMapFilter avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Constructor
	 
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>mapBitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet BitmapData contenant les données de mappage du déplacement.
	</apiDesc></apiParam><apiParam><apiItemName>mapPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur contenant le décalage du coin supérieur gauche de l’objet d’affichage cible par rapport au coin supérieur gauche de l’image de mappage.
	</apiDesc></apiParam><apiParam><apiItemName>componentX</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décrit le canal de couleur à utiliser dans l’image de mappage pour déplacer le résultat <i>x</i>. Les valeurs possibles sont les constantes BitmapDataChannel. 
	</apiDesc></apiParam><apiParam><apiItemName>componentY</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décrit le canal de couleur à utiliser dans l’image de mappage pour déplacer le résultat <i>y</i>. Les valeurs possibles sont les constantes BitmapDataChannel. 
	</apiDesc></apiParam><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Multiplicateur à utiliser pour redimensionner le résultat du déplacement <i>x</i> à partir du calcul de mappage.
	</apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Multiplicateur à utiliser pour redimensionner le résultat du déplacement <i>y</i> à partir du calcul de mappage.
	</apiDesc></apiParam><apiParam><apiItemName>mode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>wrap</apiData><apiDesc>Mode du filtre. Les valeurs possibles sont les constantes DisplacementMapFilterMode.
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Spécifie la couleur à utiliser pour les déplacements en dehors des limites. La plage valide est comprise entre 0,0 et 1,0. Utilisez ce paramètre si la propriété <codeph>mode</codeph> est réglée sur <codeph>DisplacementMapFilterMode.COLOR</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Spécifie la valeur alpha à utiliser pour les déplacements en dehors des limites. Elle est spécifiée en tant que valeur normalisée comprise entre 0,0 et 1,0. Par exemple, 0,25 définit une valeur de transparence de 25 %. Utilisez ce paramètre si la propriété <codeph>mode</codeph> est réglée sur <codeph>DisplacementMapFilterMode.COLOR</codeph>.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Initialise une occurrence DisplacementMapFilter.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Initialise une occurrence de DisplacementMapFilter avec les paramètres spécifiés.
	
   	</apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DisplacementMapFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>DisplacementMapFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>DisplacementMapFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}		
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>mode</code> property of <code>filter_1</code>.  Modifying <code>mode</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1.mode);			// wrap
	trace(filter_2.mode);			// wrap
	trace(clonedFilter.mode);		// wrap
		
	filter_1.mode = "ignore";
	
	trace(filter_1.mode);			// ignore
	trace(filter_2.mode);			// ignore
	trace(clonedFilter.mode);		// wrap
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de DisplacementMapFilter dont les propriétés sont toutes identiques à celles de l’occurrence d’origine.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DisplacementMapFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Spécifie la transparence alpha à utiliser pour les déplacements en dehors des limites.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>alpha</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie la transparence alpha à utiliser pour les déplacements en dehors des limites. Elle est spécifiée en tant que valeur normalisée comprise entre 0,0 et 1,0. Par exemple, 0,25 définit une valeur de transparence de 25 %. La valeur par défaut est 0. Utilisez cette propriété si la propriété <codeph>mode</codeph> est réglée sur <codeph>DisplacementMapFilterMode.COLOR</codeph>.  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:color:get"><apiName>color</apiName><shortdesc>
	Spécifie la couleur à utiliser pour les déplacements en dehors des limites.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>color</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		filter.color = 0x00FF00;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie la couleur à utiliser pour les déplacements en dehors des limites. La plage valide est comprise entre 0,0 et 1,0. Les valeurs sont au format hexadécimal. La valeur par défaut pour <codeph>color</codeph> est 0. Utilisez cette propriété si la propriété <codeph>mode</codeph> est réglée sur <codeph>DisplacementMapFilterMode.COLOR</codeph>. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentX:get"><apiName>componentX</apiName><shortdesc>
	Décrit le canal de couleur à utiliser dans l’image de mappage pour déplacer le résultat x.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.  It changes the value from 1 to 4 which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentX = 4;
		this.filters = new Array(filter);
	}
	
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiTipTexts><apiTipText>Canal couleur à utiliser pour déplacer le résultat x.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Décrit le canal de couleur à utiliser dans l’image de mappage pour déplacer le résultat <i>x</i>. Les valeurs possibles sont les constantes BitmapDataChannel :
	<ul>
		<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	<li><codeph>BitmapDataChannel.BLUE</codeph></li>
	<li><codeph>BitmapDataChannel.GREEN</codeph></li>
	<li><codeph>BitmapDataChannel.RED</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentY:get"><apiName>componentY</apiName><shortdesc>
	 Décrit le canal de couleur à utiliser dans l’image de mappage pour déplacer le résultat y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks it.  The value changes from 1 to 4, which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentY = 4;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Décrit le canal de couleur à utiliser dans l’image de mappage pour déplacer le résultat <i>y</i>. Les valeurs possibles sont les constantes BitmapDataChannel :
	 <ul>
	 	<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
         </ul>
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapBitmap:get"><apiName>mapBitmap</apiName><shortdesc>
	Objet BitmapData contenant les données de mappage du déplacement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapBitmap</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	var scope:Object = this;
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapBitmap = scope.createGradientBitmap(300, 80, 0xFF000000, "linear");
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	
	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier><apiException><apiDesc>L’objet BitmapData prend la valeur null lors de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Objet BitmapData contenant les données de mappage du déplacement.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapPoint:get"><apiName>mapPoint</apiName><shortdesc>
	Valeur contenant le décalage du coin supérieur gauche de l’objet d’affichage cible par rapport au coin supérieur gauche de l’image de mappage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapPoint</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapPoint = new Point(-30, -40);
		this.filters = new Array(filter);
		this._x = 30;
		this._y = 40;
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Le Point prend la valeur null lors de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Valeur contenant le décalage du coin supérieur gauche de l’objet d’affichage cible par rapport au coin supérieur gauche de l’image de mappage.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mode:get"><apiName>mode</apiName><shortdesc>
	Mode du filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example modifies <code>scaleY</code> inorder to create a displacement
	value that is out of range and then changes the <code>mode</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>ignore</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "ignore";
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	</oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>La chaîne prend la valeur null lors de sa définition.
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>La chaîne de mode ne correspond pas à un des types gérés.
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Mode du filtre. Les valeurs possibles sont les constantes DisplacementMapFilterMode :
	<ul>
	<li><codeph>DisplacementMapFilterMode.WRAP</codeph> — Ramène la valeur de déplacement à l’autre côté de l’image source.</li>
	<li><codeph>DisplacementMapFilterMode.CLAMP</codeph> — Corrige la valeur de déplacement en fonction du bord de l’image source.</li>
	<li><codeph>DisplacementMapFilterMode.IGNORE</codeph> — Si la valeur de déplacement est hors limites, ignore le déplacement et utilise le pixel source.</li>
	<li><codeph>DisplacementMapFilterMode.COLOR</codeph> — Si la valeur de déplacement est en dehors de l’image, remplace les valeurs des propriétés <codeph>color</codeph> et <codeph>alpha</codeph>.</li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleX:get"><apiName>scaleX</apiName><shortdesc>
	Multiplicateur à utiliser pour redimensionner le résultat du déplacement x à partir du calcul de mappage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleX = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Multiplicateur à utiliser pour redimensionner le résultat du déplacement <i>x</i> à partir du calcul de mappage.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleY:get"><apiName>scaleY</apiName><shortdesc>
	Multiplicateur à utiliser pour redimensionner le résultat du déplacement y à partir du calcul de mappage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Multiplicateur à utiliser pour redimensionner le résultat du déplacement <i>y</i> à partir du calcul de mappage.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterType"><apiName>BitmapFilterType</apiName><shortdesc>
La classe BitmapFilterType contient des valeurs permettant de définir le type d’un objet BitmapFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe BitmapFilterType contient des valeurs permettant de définir le type d’un objet BitmapFilter.

</apiDesc><example conref="examples\BitmapFilterTypeExample.as"> L’exemple suivant dessine un carré gris auquel un objet BevelFilter est appliqué. L’exemple définit la propriété <codeph>type</codeph> en utilisant la constante <codeph>BitmapFilterType.HIGH</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterTypeExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterTypeExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterType:FULL"><apiName>FULL</apiName><shortdesc>
	Définit le paramètre qui applique un filtre à toute la superficie d’un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit le paramètre qui applique un filtre à toute la superficie d’un objet.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:INNER"><apiName>INNER</apiName><shortdesc>
	Définit le paramètre qui applique un filtre à l’intérieur d’un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>inner</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit le paramètre qui applique un filtre à l’intérieur d’un objet.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:OUTER"><apiName>OUTER</apiName><shortdesc>
	Définit le paramètre qui applique un filtre à l’extérieur d’un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>outer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit le paramètre qui applique un filtre à l’extérieur d’un objet.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
La classe DropShadowFilter permet d’ajouter un effet d’ombre portée aux objets d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe DropShadowFilter permet d’ajouter un effet d’ombre portée aux objets d’affichage. L’algorithme d’ombre est dérivé du même filtre que celui utilisé par le filtre de flou. Vous disposez de plusieurs options pour définir le style de l’ombre portée, notamment l’ombre intérieure ou extérieure et le mode de masquage. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.

<p>L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
 <ul><li>Pour appliquer des filtres aux objets d’affichage, utilisez la propriété <codeph>filters</codeph> (héritée de DisplayObject). Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>
 
 <li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
 </ul>

<p>Si vous appliquez un filtre à un objet d’affichage, la valeur de la propriété <codeph>cacheAsBitmap</codeph> de cet objet est définie sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>
 <p>Ce filtre prend en charge le redimensionnement de la scène. Cependant, il ne prend pas en charge le redimensionnement général, la rotation ni l’inclinaison. Si l’objet est redimensionné (si les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne sont pas réglées sur 1,0), le filtre ne l’est pas. Le redimensionnement est effectué uniquement en cas de zoom avant sur la scène.</p>
 
 <p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, si vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>

</apiDesc><example conref="examples\DropShadowFilterExample.as"> L’exemple suivant crée un carré jaune auquel une ombre portée est appliquée. La séquence des tâches principales de cet exemple s’organise comme suit :
 <ol>
  <li>Déclaration des trois propriétés qui sont utilisées pour dessiner le carré auquel le filtre est appliqué.</li>
  <li>Création de la fonction constructeur. Le constructeur appelle la méthode <codeph>draw()</codeph> qui utilise des méthodes de la classe Graphics, accessibles par le biais de la propriété <codeph>graphics</codeph> de Sprite, pour dessiner un carré orange.</li>
  <li>Dans le constructeur, déclaration d’une variable <codeph>filter</codeph> comme objet BitmapFilter et attribution de celui-ci à la valeur renvoyée d’un appel à <codeph>getBitmapFilter()</codeph>. La méthode <codeph>getBitmapFilter()</codeph> définit le filtre d’ombre portée utilisé.</li>
  <li>Création d’un nouvel objet Array <codeph>myFilters</codeph> et ajout de <codeph>filter</codeph> au tableau. Attribution du tableau <codeph>myFilters</codeph> à la propriété <codeph>filters</codeph> de l’objet DropShadowFilterExample. Ceci a pour effet d’appliquer tous les filtres trouvés dans <codeph>myFilters</codeph>, en l’occurrence <codeph>filter</codeph> uniquement.</li>
  </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.DropShadowFilter;

    public class DropShadowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function DropShadowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x000000;
            var angle:Number = 45;
            var alpha:Number = 0.8;
            var blurX:Number = 8;
            var blurY:Number = 8;
            var distance:Number = 15;
            var strength:Number = 0.65;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;
            return new DropShadowFilter(distance,
                                        angle,
                                        color,
                                        alpha,
                                        blurX,
                                        blurY,
                                        strength,
                                        quality,
                                        inner,
                                        knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DropShadowFilter:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
	Crée une occurrence de DropShadowFilter avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new DropShadowFilter object
	with the default values:
	<pre>
	myFilter = new flash.filters.DropShadowFilter()
	</pre>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Distance de décalage de l’ombre, en pixels. 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Angle de l’ombre, de 0 à 360° (virgule flottante). 
	
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Couleur de l’ombre, au format hexadécimal <i>0xRRGGBB</i>. La valeur par défaut est 0x000000.
	
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur de transparence alpha de la couleur d’ombre. Les valeurs valides sont comprises entre 0.0 et 1.0. Par exemple, 0,25 définit une valeur de transparence de 25 %. 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255.0 (virgule flottante). 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255.0 (virgule flottante). 
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste est important entre l’ombre et l’arrière-plan. Les valeurs valides sont comprises entre 0 et 255.0. 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Nombre d’applications du filtre. Utilisez les constantes BitmapFilterQuality :
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Pour plus d’informations sur ces valeurs, voir la description de la propriété <codeph>quality</codeph>.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si l’ombre est intérieure ou non. La valeur <codeph>true</codeph> spécifie une ombre intérieure. La valeur <codeph>false</codeph> renvoie une ombre extérieure au niveau des bords extérieurs de l’objet.
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Applique un effet de masquage (<codeph>true</codeph>) qui, en réalité, rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. 
	
	</apiDesc></apiParam><apiParam><apiItemName>hideObject</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si l’objet est caché ou non. La valeur <codeph>true</codeph> indique que l’objet lui-même n’est pas tracé et que seule l’ombre est visible. 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Crée une occurrence de DropShadowFilter avec les paramètres spécifiés.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DropShadowFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three DropShadowFilter objects and compares them.  <code>filter_1</code>
	is created using the DropShadowFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de DropShadowFilter dont les propriétés sont toutes identiques à celles de l’occurrence de DropShadowFilter d’origine.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DropShadowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Valeur de transparence alpha de la couleur d’ombre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAlpha");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Valeur de transparence alpha de la couleur d’ombre. Les valeurs valides sont comprises entre 0.0 et 1.0. Par exemple, 0,25 définit une valeur de transparence de 25 %. La valeur par défaut est 1.0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Angle de l’ombre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAngle");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.angle = 135;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Angle de l’ombre. Les valeurs valides sont comprises entre 0 et 360 degrés (virgule flottante). La valeur par défaut est 45.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Quantité de flou horizontal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurX");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurX = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255.0 (virgule flottante). La valeur par défaut est 4.0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Quantité de flou vertical.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurY");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurY = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255.0 (virgule flottante). La valeur par défaut est 4.0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:color:get"><apiName>color</apiName><shortdesc>
	Couleur de l’ombre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowColor");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.color = 0xFF0000;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Couleur de l’ombre. Les valeurs valides sont au format hexadécimal <i>0xRRGGBB</i>. La valeur par défaut est 0x000000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Distance de décalage de l’ombre, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowDistance");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.distance = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Distance de décalage de l’ombre, en pixels. La valeur par défaut est 4,0 (virgule flottante).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:hideObject:get"><apiName>hideObject</apiName><shortdesc>
	Indique si l’objet est caché ou non.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>hideObject</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowHideObject");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.hideObject = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Indique si l’objet est caché ou non. Une valeur <codeph>true</codeph> indique que l’objet lui-même n’est pas tracé et que seule l’ombre est visible. La valeur par défaut est <codeph>false</codeph>, soit montrer l’objet.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	Indique si l’ombre est intérieure ou non.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowInner");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Indique si l’ombre est intérieure ou non. La valeur <codeph>true</codeph> indique une ombre intérieure. La valeur par défaut est <codeph>false</codeph>, renvoyant une ombre extérieure au niveau des bords extérieurs de l’objet.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Applique un effet de masquage (true) qui, en réalité, rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowKnockout");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Applique un effet de masquage (<codeph>true</codeph>) qui, en réalité, rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. La valeur par défaut est <codeph>false</codeph> (pas de masquage).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	 Nombre d’applications du filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowQuality");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.quality = 0;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’applications du filtre. La valeur par défaut est <codeph>BitmapFilterQuality.LOW</codeph>, ce qui revient à appliquer le filtre une seule fois. La valeur <codeph>BitmapFilterQuality.MEDIUM</codeph> applique le filtre deux fois. La valeur <codeph>BitmapFilterQuality.HIGH</codeph> l’applique trois fois. Les rendus des filtres de valeurs faibles sont obtenus plus rapidement.
	 
	 <p>Pour la plupart des applications, une valeur de qualité faible, moyenne ou élevée est suffisante. Il est possible d’utiliser des valeurs numériques allant jusqu’à 15 pour obtenir différents effets, mais le rendu des valeurs les plus élevées est moins rapide. Sans augmenter la valeur de <codeph>quality</codeph>, vous pouvez généralement obtenir un effet similaire, avec un rendu plus rapide, en augmentant simplement les valeurs des propriétés <codeph>blurX</codeph> et <codeph>blurY</codeph>.</p>
         </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:DropShadowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Intensité de l’empreinte ou recouvrement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowStrength");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.strength = .6;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste est important entre l’ombre et l’arrière-plan. Les valeurs valides sont comprises entre 0 et 255.0. La valeur par défaut est de 1.0.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterQuality"><apiName>BitmapFilterQuality</apiName><shortdesc>
La classe BitmapFilterQuality contient des valeurs permettant de définir la qualité de rendu d’un objet BitmapFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe BitmapFilterQuality contient des valeurs permettant de définir la qualité de rendu d’un objet BitmapFilter.

</apiDesc><example conref="examples\BitmapFilterQualityExample.as"> L’exemple suivant dessine un carré gris auquel un objet BevelFilter est appliqué. L’exemple définit la propriété <codeph>quality</codeph> en utilisant la constante <codeph>BitmapFilterQuality.HIGH</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterQualityExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterQualityExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>BlurFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>DropShadowFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
	Définit le paramètre de filtre de qualité supérieure.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Définit le paramètre de filtre de qualité supérieure.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:LOW"><apiName>LOW</apiName><shortdesc>
	Définit le paramètre de filtre de qualité inférieure.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Définit le paramètre de filtre de qualité inférieure. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
	Définit le paramètre de filtre de qualité moyenne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Définit le paramètre de filtre de qualité moyenne.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilterMode"><apiName>DisplacementMapFilterMode</apiName><shortdesc>
La classe DisplacementMapFilterMode fournit des valeurs à la propriété mode de la classe DisplacementMapFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe DisplacementMapFilterMode fournit des valeurs à la propriété <codeph>mode</codeph> de la classe DisplacementMapFilter.

</apiDesc></apiClassifierDetail><apiValue id="flash.filters:DisplacementMapFilterMode:CLAMP"><apiName>CLAMP</apiName><shortdesc>
	Corrige la valeur de déplacement en fonction du bord de l’image source.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>clamp</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Corrige la valeur de déplacement en fonction du bord de l’image source. Utilisez avec la propriété <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:COLOR"><apiName>COLOR</apiName><shortdesc>
	Si la valeur de déplacement est en dehors de l’image, remplace les valeurs des propriétés color et alpha.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>color</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Si la valeur de déplacement est en dehors de l’image, remplace les valeurs des propriétés <codeph>color</codeph> et <codeph>alpha</codeph>. Utilisez avec la propriété <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:IGNORE"><apiName>IGNORE</apiName><shortdesc>
	Si la valeur de déplacement est hors limites, ignore le déplacement et utilise le pixel source.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ignore</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Si la valeur de déplacement est hors limites, ignore le déplacement et utilise le pixel source. Utilisez avec la propriété <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:WRAP"><apiName>WRAP</apiName><shortdesc>
	Ramène la valeur de déplacement à l’autre côté de l’image source.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>wrap</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Ramène la valeur de déplacement à l’autre côté de l’image source. Utilisez avec la propriété <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.filters:BevelFilter"><apiName>BevelFilter</apiName><shortdesc> 
 La classe BevelFilter permet d’appliquer un effet de biseau à des objets d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Ajoute un niveau de biseautage. 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc> 
 La classe BevelFilter permet d’appliquer un effet de biseau à des objets d’affichage. L’effet de biseau donne aux objets tels que des boutons un aspect tridimensionnel. Vous pouvez personnaliser l’aspect du biseau grâce à différentes couleurs d’éclairage et d’ombre, à la quantité de flou sur le biseau, à l’angle du biseau, au positionnement du biseau et à un effet de masquage. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.
 
 <p>Pour créer un filtre, utilisez le constructeur <codeph>new BevelFilter()</codeph>. L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
 <ul><li>Pour appliquer des filtres aux clips, champs de texte, boutons et vidéo, utilisez la propriété <codeph>filters</codeph> (héritée de DisplayObject). Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>
 
 <li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
 </ul>
 
 <p>Si vous appliquez un filtre à un objet d’affichage, la valeur de la propriété <codeph>cacheAsBitmap</codeph> de cet objet est définie sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>
 
 <p>Ce filtre prend en charge le redimensionnement de la scène. Cependant, il ne prend pas en charge le redimensionnement général, la rotation ni l’inclinaison. Si l’objet lui-même est redimensionné (si les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne sont pas définies sur 100 %), l’effet de filtre n’est pas redimensionné. Le redimensionnement est effectué uniquement en cas de zoom avant sur la scène.</p>
 
 <p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, si vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>
 
 </apiDesc><example conref="examples\BevelFilterExample.as"> L’exemple suivant crée un carré jaune foncé et applique un biseau d’une couleur de surbrillance (0xFFFF00) jaune vif avec une ombre (0x0000FF) bleue. La séquence des principales tâches de cet exemple s’organise comme suit :
 <ol>
  <li>Importation des classes requises.</li>   
  <li>Déclaration des trois propriétés utilisées dans la fonction <codeph>draw()</codeph> qui dessine l’objet auquel le filtre de biseau est appliqué.</li>
  <li>Création de la fonction constructeur <codeph>BevelFilterExample()</codeph> qui effectue les actions suivantes :
      <ul>
          <li>Appel de la fonction <codeph>draw()</codeph> qui est déclarée ultérieurement.</li>
          <li>Déclaration d’une variable <codeph>filter</codeph> comme objet BitmapFilter et attribution de celui-ci à la valeur renvoyée d’un appel à <codeph>getBitmapFilter()</codeph>.</li>
          <li>Création d’un nouvel objet Array <codeph>myFilters</codeph>, ajout de <codeph>filter</codeph> au tableau, puis attribution de <codeph>myFilters</codeph> à la propriété <codeph>filters</codeph> de l’objet BevelFilterExample. Ceci a pour effet d’appliquer tous les filtres trouvés dans <codeph>myFilters</codeph>, en l’occurrence <codeph>filter</codeph> uniquement.</li>      
      </ul>
 </li>
  <li>Création de la fonction <codeph>getBitmapFilter</codeph> afin de créer et de définir des propriétés pour le filtre.</li>
  <li>Création de la fonction <codeph>draw()</codeph>. Cette fonction utilise des méthodes de la classe Graphics, accessibles par le biais de la propriété <codeph>graphics</codeph> de la classe Sprite, pour dessiner le carré.</li>
  
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BevelFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xFFFF00;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x0000FF;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BevelFilter:BevelFilter"><apiName>BevelFilter</apiName><shortdesc>
	Initialise une nouvelle occurrence de BevelFilter avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following code creates a new BevelFilter instance. The values given 
	are the default values; you could call the constructor without any values and get the same result.
	<listing> filter = new flash.filters.BevelFilter (4, 45, 0xFFFFFF, 1, 0x000000, 1, 4, 4, 1, 
	1, "inner", false) 
	</listing>
	The next example instantiates a new BevelFilter and applies it to the MovieClip <code>rect</code>.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var distance:Number = 5;
	var angleInDegrees:Number = 45;
	var highlightColor:uint = 0xFFFF00;
	var highlightAlpha:Number = .8;
	var shadowColor:uint = 0x0000FF;
	var shadowAlpha:Number = .8;
	var blurX:Number = 20;
	var blurY:Number = 20;
	var strength:Number = 1;
	var quality:int = 3;
	var type:String = "inner";
	var knockout:Boolean = false;
	
	var filter:BevelFilter = new BevelFilter(distance, angleInDegrees, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout);
	
	var rect:MovieClip = createRectangle(100, 100, 0x00CC00, "bevelFilterExample");
	rect.filters = new Array(filter);
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Distance de décalage du biseau, en pixels (virgule flottante). 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Angle du biseau, de 0 à 360 degrés. 
	</apiDesc></apiParam><apiParam><apiItemName>highlightColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFF</apiData><apiDesc>Couleur de surbrillance du biseau, <i>0xRRGGBB</i>. 
	</apiDesc></apiParam><apiParam><apiItemName>highlightAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur de transparence alpha de la couleur d’éclairage. Les valeurs valides sont comprises entre 0.0 et 1.0. Par exemple, 0,25 définit une valeur de transparence de 25 %. 
	</apiDesc></apiParam><apiParam><apiItemName>shadowColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0x000000</apiData><apiDesc>Couleur d’ombre du biseau, <i>0xRRGGBB</i>. 
	</apiDesc></apiParam><apiParam><apiItemName>shadowAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur de transparence alpha de la couleur d’ombre. Les valeurs valides sont comprises entre 0.0 et 1.0. Par exemple, 0,25 définit une valeur de transparence de 25 %. 
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou horizontal, en pixels. Les valeurs valides sont comprises entre 0 et 255.0 (virgule flottante). 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou vertical en pixels. Les valeurs valides sont comprises entre 0 et 255.0 (virgule flottante).
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste est important entre le biseau et l’arrière-plan. Les valeurs valides sont comprises entre 0 et 255.0. 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Qualité du biseau. Les valeurs gérées sont comprises entre 0 et 15, mais pour la plupart des applications, vous pouvez utiliser les constantes <codeph>BitmapFilterQuality</codeph> :
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Le rendu des filtres de valeur faible est plus rapide. Vous pouvez utiliser les autres valeurs numériques disponibles pour obtenir des effets différents.</p>

	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Le type de biseau. Les valeurs gérées sont les constantes <codeph>BitmapFilterType</codeph> : <codeph>BitmapFilterType.INNER</codeph>, <codeph>BitmapFilterType.OUTER</codeph> ou <codeph>BitmapFilterType.FULL</codeph>. 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Applique un effet de masquage (<codeph>true</codeph>) qui, en réalité, rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialise une nouvelle occurrence de BevelFilter avec les paramètres spécifiés.
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#BitmapFilterType"><linktext>BitmapFilterType</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:BevelFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BevelFilter objects and compares them.  <code>filter_1</code>
	is created using the BevelFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
	 	// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
		// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de BevelFilter dont toutes les propriétés sont identiques à celles de l’occurrence de BevelFilter d’origine.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Angle du biseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.angle = 225;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Angle du biseau. Les valeurs valides sont comprises entre 0 et 360°. La valeur par défaut est 45°.
	
	<p>La valeur d’angle représente l’angle de la source lumineuse théorique éclairant l’objet et détermine l’emplacement de l’effet par rapport à ce dernier. Si la valeur de la propriété <codeph>distance</codeph> est définie sur 0, il n’y a pas d’effet de décalage par rapport à l’objet. La propriété <codeph>angle</codeph> n’a donc aucun effet.</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Quantité de flou horizontal, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurX");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurX = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou horizontal, en pixels. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Quantité de flou vertical, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurY");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurY = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou vertical, en pixels. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	La distance de décalage du biseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.distance = 3;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	La distance de décalage du biseau. Les valeurs valides sont en pixels (virgule flottante). La valeur par défaut est 4.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightAlpha:get"><apiName>highlightAlpha</apiName><shortdesc>
	Valeur de transparence alpha de la couleur d’éclairage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Valeur de transparence alpha de la couleur d’éclairage. Cette valeur est spécifiée en tant que valeur normalisée comprise entre 0 et 1. Par exemple, 0,25 définit une valeur de transparence de 25 %. La valeur par défaut est 1.
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightColor:get"><apiName>highlightColor</apiName><shortdesc>
	Couleur d’éclairage du biseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightColor = 0x0000FF;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Couleur d’éclairage du biseau. Les valeurs valides sont au format hexadécimal, <i>0xRRGGBB</i>. La valeur par défaut est 0xFFFFFF.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
    Applique un effet de masquage (true) qui, en réalité, rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelKnockout");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    Applique un effet de masquage (<codeph>true</codeph>) qui, en réalité, rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. La valeur par défaut est <codeph>false</codeph> (pas de masquage).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Nombre d’applications du filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelQuality");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Nombre d’applications du filtre. La valeur par défaut est <codeph>BitmapFilterQuality.LOW</codeph>, ce qui revient à appliquer le filtre une seule fois. La valeur <codeph>BitmapFilterQuality.MEDIUM</codeph> applique le filtre deux fois. La valeur <codeph>BitmapFilterQuality.HIGH</codeph> l’applique trois fois. Les rendus des filtres de valeurs faibles sont obtenus plus rapidement.
	
	<p>Pour la plupart des applications, une valeur de <codeph>quality</codeph> faible, moyenne ou élevée est suffisante. Il est possible d’utiliser des valeurs numériques allant jusqu’à 15 pour obtenir différents effets, mais le rendu des valeurs les plus élevées est moins rapide. Sans augmenter la valeur de <codeph>quality</codeph>, vous pouvez généralement obtenir un effet similaire, avec un rendu plus rapide, en augmentant simplement les valeurs des propriétés <codeph>blurX</codeph> et <codeph>blurY</codeph>.</p>
	
	<p>Vous pouvez utiliser les constantes <codeph>BitmapFilterQuality</codeph> suivantes pour spécifier les valeurs de la propriété <codeph>quality</codeph> :
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowAlpha:get"><apiName>shadowAlpha</apiName><shortdesc>
	Valeur de transparence alpha de la couleur d’ombre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Valeur de transparence alpha de la couleur d’ombre. Cette valeur est spécifiée en tant que valeur normalisée comprise entre 0 et 1. Par exemple, 0,25 définit une valeur de transparence de 25 %. La valeur par défaut est 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowColor:get"><apiName>shadowColor</apiName><shortdesc>
	La couleur d’ombre du biseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowColor = 0xFFFF00;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	La couleur d’ombre du biseau. Les valeurs valides sont au format hexadécimal, <i>0xRRGGBB</i>. La valeur par défaut est 0x000000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Intensité de l’empreinte ou recouvrement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelStrength");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.strength = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Intensité de l’empreinte ou recouvrement. Les valeurs valides sont comprises entre 0 et 255. Plus la valeur est élevée, plus l’intensité des couleurs apparaît à l’impression et plus le contraste est important entre le biseau et l’arrière-plan. La valeur par défaut est 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:type:get"><apiName>type</apiName><shortdesc>
	Positionnement de l’effet de biseau sur l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelType");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.type = "outer";
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>La chaîne prend la valeur null lors de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Positionnement de l’effet de biseau sur l’objet. Les biseaux intérieurs et extérieurs sont placés au niveau des bords intérieurs ou extérieurs. Un biseau complet recouvre tout l’objet. Les valeurs gérées sont les constantes <codeph>BitmapFilterType</codeph> :
	
	<ul>
	<li><codeph>BitmapFilterType.INNER</codeph></li>
	<li><codeph>BitmapFilterType.OUTER</codeph></li>
	<li><codeph>BitmapFilterType.FULL</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilter"><apiName>BitmapFilter</apiName><shortdesc>
 La classe BitmapFilter est la classe de base pour tous les effets de filtrage d’image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Classe de base pour tous les effets de filtrage d’image.
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe BitmapFilter est la classe de base pour tous les effets de filtrage d’image. 
 
 <p>Les classes BevelFilter, BlurFilter, ColorMatrixFilter, ConvolutionFilter, DisplacementMapFilter, DropShadowFilter, GlowFilter, GradientBevelFilter et GradientGlowFilter étendent toutes la classe BitmapFilter. Vous pouvez appliquer ces effets de filtre aux objets d’affichage.</p>
 
 <p>Vous ne pouvez pas directement instancier ni étendre BitmapFilter.</p>
 
 </apiDesc><example conref="examples\BitmapFilterExample.as"> L’exemple suivant montre comment plusieurs filtres peuvent être appliqués à un objet DisplayObject donné et suivis à l’aide de la propriété <codeph>filters</codeph>.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.*;

    public class BitmapFilterExample extends Sprite {
        public function BitmapFilterExample() {
            trace(this.filters.length);             // 0

            var tmpFilters:Array = this.filters;
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.BEVEL_FILTER));
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.GLOW_FILTER));
            this.filters = tmpFilters;

            trace(this.filters.length);             // 2
            trace(this.filters[0] is BitmapFilter); // true
            trace(this.filters[0] is BevelFilter);  // true
            trace(this.filters[1] is BitmapFilter); // true
            trace(this.filters[1] is GlowFilter);   // true
        }
    }
}

import flash.filters.*;
class FilterFactory {
    public static var BEVEL_FILTER:String = "BevelFilter";
    public static var BevelFilterConstructor:Class = BevelFilter;

    public static var BLUR_FILTER:String = "BlurFilter";
    public static var BlurFilterConstructor:Class = BlurFilter;

    public static var COLOR_MATRIX_FILTER:String = "ColorMatrixFilter";
    public static var ColorMatrixFilterConstructor:Class = ColorMatrixFilter;

    public static var CONVOLUTION_FILTER:String = "ConvolutionFilter";
    public static var ConvolutionFilterConstructor:Class = ConvolutionFilter;

    public static var DISPLACEMENT_MAP_FILTER:String = "DisplacementMapFilter";
    public static var DisplacementMapFilterConstructor:Class = DisplacementMapFilter;

    public static var DROP_SHADOW_FILTER:String = "DropShadowFilter";
    public static var DropShadowFilterConstructor:Class = DropShadowFilter;

    public static var GLOW_FILTER:String = "GlowFilter";
    public static var GlowFilterConstructor:Class = GlowFilter;

    public static var GRADIENT_BEVEL_FILTER:String = "GradientBevelFilter";
    public static var GradientBevelFilterConstructor:Class = GradientBevelFilter;

    public static var GRADIENT_GLOW_FILTER:String = "GradientGlowFilter";
    public static var GradientGlowFilterConstructor:Class = GradientGlowFilter;

    public static function createFilter(type:String):BitmapFilter {
        return new FilterFactory[type + "Constructor"]();   
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.filters:BitmapFilter:clone"><apiName>clone</apiName><shortdesc>
	 Renvoie un objet BitmapFilter qui est une copie exacte de l’objet BitmapFilter d’origine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet BitmapFilter.
	 
	 </apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Une copie de l’objet BitmapFilter.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie un objet BitmapFilter qui est une copie exacte de l’objet BitmapFilter d’origine.
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.filters:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
 La classe BlurFilter permet d’appliquer un effet visuel de flou aux objets d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Effet de flou.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe BlurFilter permet d’appliquer un effet visuel de flou aux objets d’affichage. Un effet de flou adoucit les détails d’une image. Vous pouvez produire différents flous, d’un aspect doux et sans contours précis, à un flou gaussien dont l’aspect voilé produit le même effet que celui d’une image regardée à travers un verre semi-opaque. Quand la propriété <codeph>quality</codeph> de ce filtre est réglée sur faible, vous obtenez un aspect doux sans contours précis. Quand la propriété <codeph>quality</codeph> est élevée, l’effet se rapproche d’un filtre de flou gaussien. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.
 
 <p>Pour créer un nouveau filtre, utilisez le constructeur <codeph>new BlurFilter()</codeph>. L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
 <ul><li>Pour appliquer des filtres aux clips, champs de texte, boutons et vidéo, utilisez la propriété <codeph>filters</codeph> (héritée de DisplayObject). Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>
 
 <li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
 </ul>
 
 <p>Si vous appliquez un filtre à un objet d’affichage, la propriété <codeph>cacheAsBitmap</codeph> de cet objet est réglée sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>
 
 <p>Ce filtre prend en charge le redimensionnement de la scène. Cependant, il ne prend pas en charge le redimensionnement général, la rotation ni l’inclinaison. Si l’objet lui-même est redimensionné (les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne sont pas réglées sur 100 %), l’effet de filtre n’est pas redimensionné. Le redimensionnement est effectué uniquement en cas de zoom avant sur la scène.</p>
 
 <p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, si vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>
 
 </apiDesc><example conref="examples\BlurFilterExample.as"> L’exemple suivant crée un carré jaune foncé auquel un filtre de flou gaussien est appliqué. La séquence des principales tâches de cet exemple s’organise comme suit :
 <ol>
  <li>Importation des classes requises.</li>   
  <li>Déclaration des trois propriétés utilisées dans la fonction <codeph>draw()</codeph> qui dessine l’objet auquel le filtre de flou est appliqué. </li>
  <li>Création de la fonction constructeur <codeph>BlurFilterExample()</codeph> qui effectue les actions suivantes :
      <ul>
          <li>Appel de la fonction <codeph>draw()</codeph> qui est déclarée ultérieurement.</li>
          <li>Déclaration d’une variable <codeph>filter</codeph> comme objet BitmapFilter et attribution de celui-ci à la valeur renvoyée d’un appel à <codeph>getBitmapFilter()</codeph>.</li>
          <li>Création d’un nouvel objet Array <codeph>myFilters</codeph>, ajout de <codeph>filter</codeph> au tableau, puis attribution de <codeph>myFilters</codeph> à la propriété <codeph>filters</codeph> de l’objet BlurFilterExample. Ceci a pour effet d’appliquer tous les filtres trouvés dans <codeph>myFilters</codeph>, en l’occurrence <codeph>filter</codeph> uniquement.</li>
      </ul>
  </li>
  <li>Création de la fonction <codeph>getBitmapFilter()</codeph> afin de créer et de définir des propriétés pour le filtre.</li>
  <li>Création de la fonction <codeph>draw()</codeph>. Cette fonction utilise des méthodes de la classe Graphics, accessibles par le biais de la propriété <codeph>graphics</codeph> de la classe Sprite, pour dessiner le carré.</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BlurFilter;

    public class BlurFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BlurFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var blurX:Number = 30;
            var blurY:Number = 30;
            return new BlurFilter(blurX, blurY, BitmapFilterQuality.HIGH);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BlurFilter:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
	Initialise le filtre avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Instantiate a new <code>BlurFilter</code> and apply it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "BlurFilterExample");
	
	var blurX:Number = 30;
	var blurY:Number = 30;
	var quality:Number = 3;
	
	var filter:BlurFilter = new BlurFilter(blurX, blurY, quality);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou à appliquer horizontalement. Les valeurs valides sont comprises entre 0 et 255,0 (valeur en virgule flottante). 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou à appliquer verticalement. Les valeurs valides sont comprises entre 0 et 255,0 (valeur en virgule flottante). 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Nombre d’applications du filtre. Vous pouvez définir la qualité à l’aide des constantes BitmapFilterQuality :
	<ul>
	<li><codeph>flash.filters.BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>La qualité supérieure se rapproche d’un flou gaussien. Dans la plupart des cas, ces trois valeurs sont suffisantes. Il est possible d’utiliser des valeurs numériques allant jusqu’à 15 pour obtenir différents effets, mais le rendu des valeurs les plus élevées est moins rapide.</p>
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Initialise le filtre.
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Initialise le filtre avec les paramètres spécifiés. Les valeurs par défaut créent une image floue sans contours précis.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:BlurFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BlurFilter objects and compares them.  <code>filter_1</code>
	is created using the BlurFilter constructor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>quality</code> property of <code>filter_1</code>.  Modifying <code>quality</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1.quality);			// 2
	trace(filter_2.quality);			// 2
	trace(clonedFilter.quality);		// 2
	
	filter_1.quality = 1;
	
	trace(filter_1.quality);			// 1
	trace(filter_2.quality);			// 1
	trace(clonedFilter.quality);		// 2
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de BlurFilter dont toutes les propriétés sont identiques à celles de l’occurrence BlurFilter d’origine.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BlurFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Quantité de flou horizontal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurX");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurX = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Quantité de flou vertical.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurY");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurY = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Nombre d’applications du flou.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterQuality");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Nombre d’applications du flou. La valeur par défaut est <codeph>BitmapFilterQuality.LOW</codeph>, ce qui revient à appliquer le filtre une seule fois. La valeur <codeph>BitmapFilterQuality.MEDIUM</codeph> applique le filtre deux fois. La valeur <codeph>BitmapFilterQuality.HIGH</codeph> l’applique trois fois et se rapproche d’un flou gaussien. Les rendus des filtres de valeurs faibles sont obtenus plus rapidement.
	
	<p>Pour la plupart des applications, une valeur de <codeph>quality</codeph> faible, moyenne ou élevée est suffisante. Il est possible d’utiliser des valeurs numériques allant jusqu’à 15 pour augmenter le nombre d’applications du flou, mais le rendu des valeurs les plus élevées est moins rapide. Sans augmenter la valeur de <codeph>quality</codeph>, vous pouvez généralement obtenir un effet similaire, avec un rendu plus rapide, en augmentant simplement les valeurs des propriétés <codeph>blurX</codeph> et <codeph>blurY</codeph>.</p>
	
	<p>Vous pouvez utiliser les constantes BitmapFilterQuality suivantes pour spécifier les valeurs de la propriété <codeph>quality</codeph> :</p>
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
La classe ConvolutionFilter applique un effet de filtre de convolution de matrice.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Do we allow anything other than 3x3 matrix convolution? Are default x y values correct?

</internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Applique un filtre de convolution de matrice.

</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe ConvolutionFilter applique un effet de filtre de convolution de matrice. Une convolution associe les pixels de l’image d’entrée aux pixels environnants pour produire une image. Les convolutions permettent de produire de nombreux effets d’image, notamment le flou, la détection de contour, l’accentuation, l’estampage et le biseautage. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.

<p>Pour créer un filtre de convolution, utilisez la syntaxe <codeph>new ConvolutionFilter()</codeph>. L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
<ul><li>Pour appliquer des filtres aux clips, champs de texte, boutons et vidéo, utilisez la propriété <codeph>filters</codeph> (héritée de DisplayObject). Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>

<li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
</ul>

<p>Si vous appliquez un filtre à un objet d’affichage, la valeur de la propriété <codeph>cacheAsBitmap</codeph> de cet objet est définie sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>

<p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, lorsque vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>

</apiDesc><example conref="examples\ConvolutionFilterExample.as"> L’exemple suivant applique différents filtres de convolution à un fichier image. Le constructeur de filtres appelle quatre fois <codeph>buildChild()</codeph> pour charger et afficher quatre occurrences de l’image. Chaque appel à <codeph>buildChild()</codeph> prend comme argument une fonction qui n’applique aucun filtre à la première occurrence, mais un filtre de convolution différent à chaque occurrence ultérieure.
 <p>La fonction <codeph>buildChild()</codeph> crée un nouvel objet Loader appelé <codeph>loader</codeph>. Pour chaque appel à <codeph>buildChild()</codeph>, joignez un écouteur d’événements à l’objet Loader pour écouter les événements <codeph>complete</codeph> qui sont gérés par la fonction transmise à <codeph>buildChild()</codeph>.</p>
 
 <p>Les fonctions <codeph>applyBrightness()</codeph>, <codeph>applySharpness()</codeph> et <codeph>applyOutline()</codeph> utilisent différentes valeurs pour le tableau <codeph>matrix</codeph> afin d’obtenir différents effets ConvolutionFilter.</p>
 <p><b>Remarque </b>: pour de meilleurs résultats, utilisez une image d’une largeur de 80 pixels environ. Le nom et l’emplacement du fichier image doivent correspondre à la valeur que vous transmettez à la propriété <codeph>url</codeph>. En l’occurrence, dans l’exemple, la valeur transmise à <codeph>url</codeph> pointe vers un fichier image nommé « Image.jpg » qui est situé dans le même répertoire que votre fichier SWF.
 </p>
 
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.filters.BitmapFilter;
    import flash.filters.ConvolutionFilter;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class ConvolutionFilterExample extends Sprite {
        private var size:uint = 140;
        private var url:String = "Image.jpg";

        public function ConvolutionFilterExample() {
            buildChild(applyNothing);
            buildChild(applyBrightness);
            buildChild(applySharpness);
            buildChild(applyOutline);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if(loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyNothing(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            applyLabel(child, "no filter");
        }

        private function applyBrightness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [5, 5, 5,
                                5, 0, 5,
                                5, 5, 5];
            applyFilter(child, matrix);
            applyLabel(child, "brightness");
        }

        private function applySharpness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [0, -1, 0,
                               -1, 20, -1,
                                0, -1, 0];
            applyFilter(child, matrix);
            applyLabel(child, "sharpness");
        }

        private function applyOutline(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [-30, 30, 0,
                                -30, 30, 0,
                                -30, 30, 0];
            applyFilter(child, matrix);
            applyLabel(child, "outline");
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var matrixX:Number = 3;
            var matrixY:Number = 3;
            var divisor:Number = 9;
            var filter:BitmapFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }

        private function applyLabel(child:DisplayObject, label:String):void {
            var tf:TextField = new TextField();
            tf.x = child.x;
            tf.y = child.height;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.text = label;
            addChild(tf);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.filters.xml#ConvolutionFilter/matrix"><linktext>matrix</linktext></link></related-links><apiConstructor id="flash.filters:ConvolutionFilter:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
	Initialise une occurrence de ConvolutionFilter avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a ConvolutionFilter
	object with the four required parameters <code>matrixX</code>, <code>matrixY</code>, 
	<code>matrix</code>, and <code>divisor</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var matrixX:Number = 3;
	var matrixY:Number = 3;
	var matrix:Array = [1, 1, 1, 1, 1, 1, 1, 1, 1];
	var divisor:Number = 9;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
	
   	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
   	
  	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
  	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
   	myBitmapData.noise(128);
   		
   	mc.onPress = function() {
   		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
   	}
	</listing>
	
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrixX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Dimension <i>x</i> de la matrice (nombre de colonnes de la matrice). La valeur par défaut est 0.
	</apiDesc></apiParam><apiParam><apiItemName>matrixY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Dimension <i>y</i> de la matrice (nombre de lignes de la matrice). La valeur par défaut est 0.
	</apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau des valeurs utilisées pour la transformation de matrice. Le nombre d’éléments dans le tableau doit être égal à <codeph>matrixX ~~ matrixY</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>divisor</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Diviseur utilisé pendant la transformation de matrice. La valeur par défaut est 1. Un diviseur correspondant à la somme de toutes les valeurs de matrice atténue l’intensité de couleurs globale du résultat. La valeur 0 est ignorée ; elle est remplacée par la valeur par défaut. 
	</apiDesc></apiParam><apiParam><apiItemName>bias</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Ecart à ajouter au résultat de la transformation de matrice. La valeur par défaut est 0.
	</apiDesc></apiParam><apiParam><apiItemName>preserveAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>La valeur <codeph>false</codeph> indique que la valeur alpha n’est pas conservée et que la convolution s’applique à tous les canaux, y compris le canal alpha. La valeur <codeph>true</codeph> indique que la convolution s’applique uniquement aux canaux de couleur. La valeur par défaut est <codeph>true</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>clamp</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Pour les pixels provenant de l’image source, la valeur <codeph>true</codeph> indique que l’image d’entrée est agrandie autant que nécessaire au niveau de ses bordures en dupliquant les valeurs de couleur sur le bord donné. La valeur <codeph>false</codeph> indique qu’il faut utiliser une autre couleur, comme spécifié dans les propriétés <codeph>color</codeph> et <codeph>alpha</codeph>. La valeur par défaut est <codeph>true</codeph>. 
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Couleur hexadécimale à substituer aux pixels provenant de l’image source.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Alpha de la couleur de substitution.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialise une occurrence de ConvolutionFilter avec les paramètres spécifiés.
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ConvolutionFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>ConvolutionFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>ConvolutionFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}		
	</listing>
	
	<p>To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>bias</code> property of <code>filter_1</code>.  Modifying <code>bias</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.</p>
	
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	trace(filter_1.bias);			// 0
	trace(filter_2.bias);			// 0
	trace(clonedFilter.bias);		// 0
	
	filter_1.bias = 20;
	
	trace(filter_1.bias);			// 20
	trace(filter_2.bias);			// 20
	trace(clonedFilter.bias);		// 0
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>BitmapFilter Nouvelle occurrence de ConvolutionFilter dont les propriétés sont toutes identiques à celles de l’occurrence de ConvolutionMatrixFilter d’origine.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ConvolutionFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Valeur de transparence alpha de la couleur de substitution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property of <code>filter</code>
	from its default value of <code>1</code> to <code>.35</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var alpha:Number = .35;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, 0x0000FF, alpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	 
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, 98, 78), new Point(2, 2), filter);
  	}
	</listing>	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Valeur de transparence alpha de la couleur de substitution. Les valeurs valides sont comprises entre 0 et 1.0. La valeur par défaut est de 0. Par exemple, 0,25 définit une valeur de transparence de 25 %.	  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:bias:get"><apiName>bias</apiName><shortdesc>
	Ecart à ajouter au résultat de la transformation de matrice.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>bias</code> property of <code>filter</code>
	from its default value of 0 to 50.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var bias:Number = 50;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, bias);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
 	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Ecart à ajouter au résultat de la transformation de matrice. L’écart augmente la valeur de couleur de chaque canal de telle sorte que les couleurs sombres paraissent plus vives. La valeur par défaut est 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:clamp:get"><apiName>clamp</apiName><shortdesc>
	Indique si l’image doit être corrigée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Indique si l’image doit être corrigée. Pour les pixels provenant de l’image source, la valeur <codeph>true</codeph> indique que l’image d’entrée est agrandie autant que nécessaire au niveau de ses bordures en dupliquant les valeurs de couleur de chacun de ses bords respectifs. La valeur <codeph>false</codeph> indique qu’il faut utiliser une autre couleur, comme spécifié dans les propriétés <codeph>color</codeph> et <codeph>alpha</codeph>. La valeur par défaut est <codeph>true</codeph>.
	
	</apiDesc><example conref="ConvolutionClampExample.as"> L’exemple suivant crée deux zones à l’aide de la classe <codeph>BitmapData</codeph>, l’une de ces zones est moitié plus petite que l’autre. Lorsque l’exemple est chargé pour la première fois, la zone la plus grande est dessinée à l’intérieur de <codeph>mc</codeph> à l’aide de <codeph>attachBitmap()</codeph>. Lorsque l’utilisateur clique sur <codeph>mc</codeph> et que la méthode <codeph>applyFilter()</codeph> est appelée, l’occurrence <codeph>largeBox</codeph> de <codeph>BitmapData</codeph> est redessinée avec <codeph>smallBox</codeph> comme image bitmap source. Etant donné que <codeph>applyFilter()</codeph> dessine la zone <codeph>smallBox</codeph> selon un <codeph>Rectangle</codeph> dont la largeur et la hauteur sont spécifiées comme étant celles de la zone <codeph>largeBox</codeph>, l’image bitmap source est plus petite que l’espace de dessin. Dans ce cas, la propriété <codeph>clamp</codeph> de <codeph>ConvolutionFilter</codeph> est définie sur <codeph>false</codeph> et la zone qui n’est pas couverte par l’image bitmap source, en l’occurrence <codeph>smallBox</codeph>, est de couleur rouge uni tel que déterminé par les variables <codeph>clampColor</codeph> et <codeph>clampAlpha</codeph>.
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.filters.ConvolutionFilter;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.geom.Point;

    public class ConvolutionClampExample extends Sprite {
        // Variables that affect clamping:
        var clamp:Boolean = false;
        var clampColor:Number = 0xFF0000;
        var clampAlpha:Number = 1;
        
        // For illustration, keep other ConvolutionFilter variables neutral:
        var bias:Number = 0;
        var preserveAlpha:Boolean = false;
        // Also, construct a neutral matrix
        var matrixCols:Number = 3;
        var matrixRows:Number = 3;
        var matrix:Array = [ 1,1,1,
                             1,1,1,
                             1,1,1 ];
        
        var filter:ConvolutionFilter = new ConvolutionFilter(matrixCols, matrixRows, matrix, matrix.length, bias, preserveAlpha, clamp, clampColor, clampAlpha);
        
        var largeBoxWidth:Number = 100;
        var largeBoxHeight:Number = 100;
        var largeBox:BitmapData = new BitmapData(largeBoxWidth, largeBoxWidth, true, 0xCC00FF00);
        var smallBoxWidth:Number = largeBoxWidth / 2;
        var smallBoxHeight:Number = largeBoxHeight / 2;
        var smallBox:BitmapData = new BitmapData(smallBoxWidth, smallBoxWidth, true, 0xCC0000FF);
            
        var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
        mc.attachBitmap(largeBox, this.getNextHighestDepth());
        
        mc.onPress = function() {
            largeBox.applyFilter(smallBox,
                                 new Rectangle(0,0, largeBoxWidth, largeBoxHeight),
                                 new Point(0,0),
                                 filter);
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:color:get"><apiName>color</apiName><shortdesc>
	Couleur hexadécimale à substituer aux pixels provenant de l’image source.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property of <code>filter</code>
	from its default value of <code>0</code> to <code>0xFF0000</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var color:Number = 0x0000FF;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, color, 1);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	  	
  	var height:Number = 100;
  	var width:Number = 80;
  	mc.onPress = function() {
  		height -= 2;
  		width -= 2;
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, height, width), new Point(2, 2), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Couleur hexadécimale à substituer aux pixels provenant de l’image source. C’est une valeur RVB sans composant alpha. La valeur par défaut est 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:divisor:get"><apiName>divisor</apiName><shortdesc>
	Diviseur utilisé pendant la transformation de matrice.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>divisor</code> property of <code>filter</code>
	to 6.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  	
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	 	
  	mc.onPress = function() {
  		var newDivisor:Number = 6;
  		filter.divisor = newDivisor;
  	 	myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Diviseur utilisé pendant la transformation de matrice. La valeur par défaut est 1. Un diviseur correspondant à la somme de toutes les valeurs de matrice atténue l’intensité globale des couleurs du résultat. La valeur 0 est ignorée ; elle est remplacée par la valeur par défaut. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	Tableau des valeurs utilisées pour la transformation de matrice.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>matrix</code> property of <code>filter</code>
	from one that blurs a bitmap to one that sharpens it.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  		
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	  	
  	mc.onPress = function() {
  		var newMatrix:Array = [0, -1, 0, -1, 8, -1, 0, -1, 0];
  		filter.matrix = newMatrix;
  		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Tableau des valeurs utilisées pour la transformation de matrice. Le nombre d’éléments dans le tableau doit être égal à <codeph>matrixX ~~ matrixY</codeph>.
	<p> Une convolution de matrice s’articule autour d’une matrice <i>n</i> par <i>m</i> qui décrit la façon dont une valeur de pixels donnée dans l’image d’entrée est associée aux valeurs des pixels environnants pour obtenir une nouvelle valeur de pixels. Chaque pixel obtenu est déterminé par l’application de la matrice au pixel source correspondant et à ses pixels environnants.</p>
	
	<p> Pour une convolution de matrice 3 par 3, la formule suivante est utilisée pour chaque canal de couleur indépendant :
	<pre><codeph>
	dst (x, y) = ((src (x-1, y-1) ~~ a0 + src(x, y-1) ~~ a1....
	                  src(x, y+1) ~~ a7 + src (x+1,y+1) ~~ a8) / divisor) + bias
	</codeph></pre>
	</p>
	
	<p>Certaines spécifications de filtre s’exécutent plus rapidement lorsque le processeur utilisé pour leur exécution est doté d’extensions Streaming SIMD (SSE). Les critères suivants favorisent des convolutions plus rapides :</p>
	<ul>
	<li>Le filtre doit être un filtre 3 par 3.</li>
	<li>Tous les termes du filtre doivent être des entiers compris entre -127 et +127.</li>
	<li>La valeur absolue correspondant à la somme de tous les termes du filtre ne doit pas être supérieure à 127.</li> 
	<li>Si un terme de filtre est négatif, le diviseur doit être compris entre 2,00001 et 256.</li>
	<li>Si tous les termes de filtre sont positifs, le diviseur doit être compris entre 1,1 et 256.</li>
	<li>L’écart doit être un entier.</li>
	</ul>
    <p><b>Remarque :</b> si vous créez une occurrence de ConvolutionFilter à l’aide du constructeur sans paramètres, l’ordre dans lequel vous affectez des valeurs aux propriétés de la matrice modifie le comportement du filtre. Dans le cas suivant, le tableau de la matrice est affecté alors que les propriétés <codeph>matrixX</codeph> et <codeph>matrixY</codeph> sont toujours définies sur <codeph>0</codeph> (valeur par défaut) :</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    </codeblock>
    <p>Dans le cas suivant, le tableau de la matrice est affecté alors que les propriétés <codeph>matrixX</codeph> et <codeph>matrixY</codeph> sont définies sur <codeph>3</codeph> :</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    </codeblock>
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixX:get"><apiName>matrixX</apiName><shortdesc>
	Dimension x de la matrice (le nombre de colonnes de la matrice).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixX</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
 	
 	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixX);	// 2
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Dimension <i>x</i> de la matrice (nombre de colonnes de la matrice). La valeur par défaut est 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixY:get"><apiName>matrixY</apiName><shortdesc>
	Dimension y de la matrice (le nombre de lignes de la matrice).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixY</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixY);	// 3
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Dimension <i>y</i> de la matrice (nombre de lignes de la matrice). La valeur par défaut est 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:preserveAlpha:get"><apiName>preserveAlpha</apiName><shortdesc>
	Indique si le canal alpha est conservé ou si le filtre de convolution s’applique aussi bien à lui qu’aux canaux de couleur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>preserveAlpha</code> property of <code>filter</code>
	from its default value of <code>true</code> to <code>false</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var preserveAlpha:Boolean = false;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, preserveAlpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
	
	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Indique si le canal alpha est conservé ou si le filtre de convolution s’applique aussi bien à lui qu’aux canaux de couleur. La valeur <codeph>false</codeph> indique que la convolution s’applique à tous les canaux, y compris le canal alpha. La valeur <codeph>true</codeph> indique que la convolution s’applique uniquement aux canaux de couleur. La valeur par défaut est <codeph>true</codeph>.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
La classe GradientBevelFilter permet d’appliquer un effet de biseau en dégradé à des objets d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Permet d’appliquer un effet de biseau en dégradé.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe GradientBevelFilter permet d’appliquer un effet de biseau en dégradé à des objets d’affichage. Un biseau en dégradé est une bordure biseautée, enrichie par des couleurs dégradées à l’extérieur, à l’intérieur ou au-dessus d’un objet. Les bordures biseautées donnent un aspect tridimensionnel aux objets. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.

 <p>L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
 <ul><li>Pour appliquer des filtres aux objets d’affichage, utilisez la propriété <codeph>filters</codeph>. Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>
 
 <li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
 </ul>

<p>Si vous appliquez un filtre à un objet d’affichage, la propriété <codeph>cacheAsBitmap</codeph> de cet objet est réglée sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p> 

<p>Ce filtre prend en charge le redimensionnement de la scène. Toutefois, le redimensionnement général, la rotation et l’inclinaison ne sont pas pris en charge. Si l’objet est lui-même redimensionné (si les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne sont pas réglées sur 1,0), l’effet de filtre n’est pas redimensionné. Le redimensionnement est effectué uniquement en cas de zoom avant sur la scène.</p>

<p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, lorsque vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>

 </apiDesc><example conref="examples\GradientBevelFilterExample.as"> L’exemple suivant dessine un carré auquel un filtre de biseau dégradé est appliqué. La séquence des tâches principales de cet exemple s’organise comme suit :
 <ol>
  <li>Importation des classes requises.</li>
  <li>Déclaration des variables globales pour définir le carré et le filtre.</li>
  <li>Création des fonctions constructeur qui effectuent les actions suivantes :
      <ul>
          <li>Appel de la méthode <codeph>draw()</codeph> qui utilise des méthodes de la classe Graphics, accessibles par le biais de la propriété <codeph>graphics</codeph> de Sprite, pour dessiner un carré gris.</li>
          <li>Création d’un objet BitmapFilter nommé <codeph>filter</codeph> auquel est attribuée la valeur renvoyée d’un appel à <codeph>getBitmapFilter()</codeph> qui crée le filtre.</li>
          <li>Création d’un nouveau tableau nommé <codeph>myFilters</codeph> auquel est ajouté <codeph>filter</codeph>.</li>
          <li>Attribution de <codeph>myFilters</codeph> à la propriété <codeph>filters</codeph> de l’objet GradientBevelFilterExample. Ceci a pour effet d’appliquer tous les filtres trouvés dans <codeph>myFilters</codeph>, en l’occurrence <codeph>filter</codeph> uniquement.</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientBevelFilter;

    public class GradientBevelFilterExample extends Sprite {
        private var bgColor:uint     = 0xCCCCCC;
        private var size:uint        = 80;
        private var offset:uint      = 50;
        private var distance:Number  = 5;
        private var angleInDegrees:Number = 225; // opposite 45 degrees
        private var colors:Array     = [0xFFFFFF, 0xCCCCCC, 0x000000];
        private var alphas:Array     = [1, 0, 1];
        private var ratios:Array     = [0, 128, 255];
        private var blurX:Number     = 8;
        private var blurY:Number     = 8;
        private var strength:Number  = 2;
        private var quality:Number   = BitmapFilterQuality.HIGH
        private var type:String      = BitmapFilterType.INNER;
        private var knockout:Boolean = true;

        public function GradientBevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientBevelFilter(distance,
                                           angleInDegrees,
                                           colors,
                                           alphas,
                                           ratios,
                                           blurX,
                                           blurY,
                                           strength,
                                           quality,
                                           type,
                                           knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:GradientBevelFilter:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
	Initialise le filtre avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Constructor
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>La distance de décalage. Les valeurs valides sont comprises entre 0 et 8. 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Angle, exprimé en degrés. Les valeurs valides sont comprises entre 0 et 360. 
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de valeurs hexadécimales de couleur RVB à utiliser pour le dégradé. Par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de valeurs de transparence alpha pour les couleurs correspondantes du tableau <codeph>colors</codeph>. Les valeurs valides pour chaque élément du tableau sont comprises entre 0 et 1. Par exemple, 0,25 définit une valeur de transparence de 25 %.
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau de taux de distribution des couleurs ; les valeurs valides sont comprises entre 0 et 255.
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste est important entre le biseau et l’arrière-plan. Les valeurs valides sont comprises entre 0 et 255. La valeur 0 signifie que le filtre n’est pas appliqué. 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>La qualité du filtre. Utilisez les constantes BitmapFilterQuality :
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Pour plus d’informations, voir la description de la propriété <codeph>quality</codeph>.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Positionnement de l’effet biseau. Les valeurs possibles sont les constantes BitmapFilterType :
	<ul><li><codeph>BitmapFilterType.OUTER</codeph>, biseau sur le bord extérieur de l’objet.</li>
	<li><codeph>BitmapFilterType.INNER</codeph>, biseau sur le bord intérieur de l’objet.</li>
	<li><codeph>BitmapFilterType.FULL</codeph>, biseau sur le dessus de l’objet.</li>
	</ul>
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Spécifie si un effet de masquage est appliqué. La valeur <codeph>true</codeph> applique un effet de masquage qui rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialise le filtre avec les paramètres spécifiés.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/quality"><linktext>GradientBevelFilter.quality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GradientBevelFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two rectangle shapes. The first, 
	<code>sourceClip</code> has a bevel effect. The second, 
	<code>resultClip</code> has no effect until it is clicked.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var sourceClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneSourceClip");
	var resultClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneResultClip");
	
	resultClip.source = sourceClip;
	
	var sourceFilter:GradientBevelFilter = getNewFilter();
	sourceClip.filters = new Array(sourceFilter);
	
	resultClip._x = 180;
	resultClip.onRelease = function() {
		this.filters = new Array(this.source.filters[0].clone());
	}
	
	function setUpFlatRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		return mc;
	}
	
	function getNewFilter():GradientBevelFilter {
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		return new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	}
	
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de GradientBevelFilter dont toutes les propriétés sont identiques à celles de l’occurrence de GradientBevelFilter d’origine.
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientBevelFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	Tableau de valeurs de transparence alpha pour les couleurs correspondantes du tableau colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>alphas</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("alphasExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [.2, 0, .2];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [1, 0, 1];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Tableau de valeurs alpha.
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Tableau de valeurs de transparence alpha pour les couleurs correspondantes du tableau <codeph>colors</codeph>. Les valeurs valides pour chaque élément du tableau sont comprises entre 0 et 1. Par exemple, 0,25 définit une valeur de transparence de 25 %.
	
	<p>La propriété <codeph>alphas</codeph> ne peut pas être modifiée en manipulant directement ses valeurs. Vous devez obtenir une référence à <codeph>alphas</codeph>, effectuer les modifications sur la référence, puis définir la propriété <codeph>alphas</codeph> sur la référence.</p>
	
	<p>Les propriétés <codeph>colors</codeph>, <codeph>alphas</codeph> et <codeph>ratios</codeph> sont liées. Le premier élément du tableau <codeph>colors</codeph> correspond au premier élément du tableau <codeph>alphas</codeph>, du tableau <codeph>ratios</codeph>, etc.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Angle, exprimé en degrés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>angle</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("angleExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].angle = 45;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Angle, exprimé en degrés. Les valeurs valides sont comprises entre 0 et 360. La valeur par défaut est 45.
	
	<p>La valeur d’angle représente l’angle de la source lumineuse théorique éclairant l’objet. La valeur détermine l’angle selon lequel les couleurs de dégradé sont appliquées à l’objet : soit où la surbrillance et l’ombre apparaissent, soit où la première couleur du tableau apparaît. Les couleurs sont ensuite appliquées selon leur ordre d’apparition dans le tableau.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Quantité de flou horizontal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurX</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurXExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurX = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Quantité de flou vertical.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurY</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurYExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurY = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255. Un flou d’une valeur inférieure ou égale à 1 signifie que l’image d’origine n’est pas modifiée avant d’être copiée. La valeur par défaut est 4. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:colors:get"><apiName>colors</apiName><shortdesc>
	Tableau de valeurs hexadécimales de couleur RVB à utiliser pour le dégradé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>colors</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("colorsExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0x000000, 0xCCCCCC, 0xFFFFFF];
		arr[0].colors = colors;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		arr[0].colors = colors;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Un tableau de valeurs de couleur RVB hexadécimales.
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Tableau de valeurs hexadécimales de couleur RVB à utiliser pour le dégradé. Par exemple, rouge correspond à 0xFF0000, bleu à 0x0000FF, etc.
	
	<p>La propriété <codeph>colors</codeph> ne peut pas être modifiée en manipulant directement ses valeurs. Vous devez obtenir une référence à <codeph>colors</codeph>, effectuer les modifications sur la référence, puis définir la propriété <codeph>colors</codeph> sur la référence.</p>
	
	<p>Les propriétés <codeph>colors</codeph>, <codeph>alphas</codeph> et <codeph>ratios</codeph> sont liées. Le premier élément du tableau <codeph>colors</codeph> correspond au premier élément du tableau <codeph>alphas</codeph>, du tableau <codeph>ratios</codeph>, etc.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	La distance de décalage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>distance</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("distanceExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].distance = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	La distance de décalage. Les valeurs valides sont comprises entre 0 et 8. La valeur par défaut est 4.0.
	
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Spécifie si l’objet a un effet de masquage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>knockout</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("knockoutExample");
	mc.onRelease = function() {
	var arr:Array = this.filters;
		arr[0].knockout = true;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie si l’objet a un effet de masquage. Un effet de masquage rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. La valeur <codeph>true</codeph> spécifie un effet de masquage ; la valeur par défaut est <codeph>false</codeph> (pas d’effet de masquage).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Nombre d’applications du filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>quality</code> property on an existing
	object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("qualityExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].quality = 1; // low quality
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Nombre d’applications du filtre. La valeur par défaut est <codeph>BitmapFilterQuality.LOW</codeph>, ce qui revient à appliquer le filtre une seule fois. La valeur <codeph>BitmapFilterQuality.MEDIUM</codeph> applique le filtre deux fois. La valeur <codeph>BitmapFilterQuality.HIGH</codeph> l’applique trois fois. Les rendus des filtres de valeurs faibles sont obtenus plus rapidement.
	
	<p>Pour la plupart des applications, une valeur de <codeph>quality</codeph> faible, moyenne ou élevée est suffisante. Il est possible d’utiliser des valeurs numériques allant jusqu’à 15 pour obtenir différents effets, mais le rendu des valeurs les plus élevées est moins rapide. Sans augmenter la valeur de <codeph>quality</codeph>, vous pouvez généralement obtenir un effet similaire, avec un rendu plus rapide, en augmentant simplement les valeurs des propriétés <codeph>blurX</codeph> et <codeph>blurY</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	Tableau de taux de répartition des couleurs, pour les couleurs correspondantes du tableau colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>ratios</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("ratiosExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [127, 128, 129];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [0, 128, 255];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>La valeur du tableau est null au moment de sa définition.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Tableau de taux de répartition des couleurs, pour les couleurs correspondantes du tableau <codeph>colors</codeph>. Les valeurs valides pour chaque élément du tableau sont comprises entre 0 et 255.
	
	<p>La propriété <codeph>ratios</codeph> ne peut pas être modifiée en manipulant directement ses valeurs. Vous devez obtenir une référence à <codeph>ratios</codeph>, effectuer les modifications sur la référence, puis définir la propriété <codeph>ratios</codeph> sur la référence.</p>
	
	<p> Les propriétés <codeph>colors</codeph>, <codeph>alphas</codeph> et <codeph>ratios</codeph> sont liées. Le premier élément du tableau <codeph>colors</codeph> correspond au premier élément du tableau <codeph>alphas</codeph>, du tableau <codeph>ratios</codeph>, etc.</p>
	
	<p> Pour comprendre comment les couleurs du biseau dégradé sont appliquées, considérez les couleurs que vous souhaitez intégrer à votre biseau dégradé. Un biseau simple possède une couleur d’éclairage et une couleur d’ombre. Un biseau dégradé possède un dégradé éclairé et un dégradé ombré. Supposons que l’éclairage apparaît dans l’angle supérieur gauche et l’ombre, dans l’angle inférieur droit. Et imaginons que l’une des utilisations possibles du filtre comporte quatre couleurs dans la zone éclairée et quatre dans l’ombre. En plus de l’éclairage et de l’ombre, le filtre utilise une couleur de remplissage de base qui apparaît à la jonction des zones éclairées et ombrées. Le nombre total de couleurs est donc neuf, et le nombre d’éléments correspondants dans le tableau des rapports, également neuf.</p>
	
	<p> Si vous souhaitez obtenir un dégradé composé de bandes de différentes couleurs qui se mêlent les unes aux autres, chaque valeur de ratio définit l’emplacement de la couleur sur le rayon du dégradé, 0 représentant le point le plus éloigné et 255, le point le plus proche du centre du dégradé. En général, la valeur moyenne, 128, constitue la valeur de remplissage de base. Pour obtenir l’effet de biseau illustré ci-dessous, affectez les valeurs de ratio comme suit, en vous aidant des neuf couleurs d’exemple :</p>
	
	<ul> 
	<li> Les quatre premières couleurs se situent dans la plage 0 à 127, chaque valeur étant supérieure ou égale à la précédente. Elles définissent le bord du biseau éclairé.</li>
	<li> La cinquième couleur (la couleur du milieu) correspond au remplissage de base et est définie sur 128. La valeur de pixel 128 définit le remplissage de base qui apparaît soit à l’extérieur de la forme (et au niveau des bords du biseau) si le type externe est spécifié, soit à l’intérieur de la forme en couvrant efficacement le remplissage même de l’objet, si le type spécifié est interne.</li>
	<li> Les quatre dernières couleurs se situent dans la plage 129 à 255, chaque valeur étant supérieure ou égale à la précédente. Elles définissent le bord du biseau ombré.</li>
	</ul>
	
	<p> Pour obtenir une répartition équivalente des couleurs sur chaque bord, utilisez un nombre de couleurs impair, la couleur centrale constituant le remplissage de base. Distribuez les valeurs de manière homogène entre 0-127 et 129-255 pour vos couleurs, puis ajustez la valeur pour modifier la largeur de chaque bande de couleur du dégradé. Pour un biseau dégradé possédant neuf couleurs, le tableau [16, 32, 64, 96, 128, 160, 192, 224, 235] est possible. L’image suivante illustre le biseau dégradé décrit :</p>
	
	<p><adobeimage alt="Un biseau en dégradé à neuf couleurs." href="../../images/gradientBevelRainbow.jpg"/></p>
	
	<p>N’oubliez pas que la répartition des couleurs dans le dégradé varie en fonction des valeurs des propriétés <codeph>blurX</codeph>, <codeph>blurY</codeph>, <codeph>strength</codeph> et <codeph>quality</codeph>, ainsi que des valeurs de <codeph>ratios</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Intensité de l’empreinte ou recouvrement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>strength</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("strengthExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].strength = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste est important entre le biseau et l’arrière-plan. Les valeurs valides sont comprises entre 0 et 255. La valeur 0 signifie que le filtre n’est pas appliqué. La valeur par défaut est 1.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:type:get"><apiName>type</apiName><shortdesc>
	Positionnement de l’effet biseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>type</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("typeExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].type = "outer";
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Positionnement de l’effet biseau. Les valeurs possibles sont les constantes BitmapFilterType :
	<ul><li><codeph>BitmapFilterType.OUTER</codeph>, biseau sur le bord extérieur de l’objet.</li>
	<li><codeph>BitmapFilterType.INNER</codeph>, biseau sur le bord intérieur de l’objet.</li>
	<li><codeph>BitmapFilterType.FULL</codeph>, biseau sur le dessus de l’objet.</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
 La classe GlowFilter permet d’appliquer un effet de rayonnement aux objets d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Permet d’ajouter un effet néon.
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe GlowFilter permet d’appliquer un effet de rayonnement aux objets d’affichage. Vous disposez de plusieurs options pour définir le style de rayonnement, notamment le rayonnement interne ou externe et le mode de masquage. Le filtre de rayonnement est similaire au filtre d’ombre portée dont les propriétés <codeph>distance</codeph> et <codeph>angle</codeph> sont définies sur zéro. Vous pouvez appliquer le filtre à tout objet d’affichage (autrement dit, aux objets héritant des propriétés de la classe DisplayObject), tels que MovieClip, SimpleButton, TextField et Video, ainsi qu’aux objets BitmapData.
 
 <p>L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
 <ul><li>Pour appliquer des filtres aux objets d’affichage, utilisez la propriété <codeph>filters</codeph> (héritée de DisplayObject). Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre. </li>
 
 <li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
 </ul>
 
 
 <p>Si vous appliquez un filtre à un objet d’affichage, la propriété <codeph>cacheAsBitmap</codeph> de cet objet est réglée sur <codeph>true</codeph>. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>

 <p>Ce filtre prend en charge le redimensionnement de la scène. Cependant, il ne prend pas en charge le redimensionnement général, la rotation ni l’inclinaison. Si l’objet est redimensionné (si les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne sont pas réglées sur 1,0), le filtre ne l’est pas. Le redimensionnement est effectué uniquement en cas de zoom avant sur la scène.</p>
 
 <p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, lorsque vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>
 
 </apiDesc><example conref="examples\GlowFilterExample.as"> L’exemple suivant dessine un carré auquel un filtre de flou est appliqué. La séquence des principales tâches de l’exemple s’organise comme suit :
 <ol>
  <li>Importation des classes requises.</li>
  <li>Déclaration des trois propriétés utilisées dans la méthode <codeph>draw</codeph> qui utilise des méthodes de la classe Graphics, accessibles par le biais de la propriété <codeph>graphics</codeph> de Sprite, pour dessiner un carré orange.</li>
  <li>Création de la fonction constructeur qui effectue les actions suivantes :
      <ul>
          <li>Appel de la méthode <codeph>draw</codeph>.</li> 
          <li>Création d’un nouvel objet BitmapFilter nommé <codeph>filter</codeph> auquel est attribuée la valeur renvoyée d’un appel à <codeph>getBitmapFilter()</codeph> qui définit le filtre.</li>
          <li>Création d’un nouveau tableau nommé <codeph>myFilters</codeph> auquel est ajouté <codeph>filter</codeph>. </li>
          <li>Attribution de <codeph>myFilters</codeph> à la propriété <codeph>filters</codeph> de l’objet BevelFilterExample. Ceci a pour effet d’appliquer tous les filtres trouvés dans <codeph>myFilters</codeph>, en l’occurrence <codeph>filter</codeph> uniquement.</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.GlowFilter;

    public class GlowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function GlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x33CCFF;
            var alpha:Number = 0.8;
            var blurX:Number = 35;
            var blurY:Number = 35;
            var strength:Number = 2;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;

            return new GlowFilter(color,
                                  alpha,
                                  blurX,
                                  blurY,
                                  strength,
                                  quality,
                                  inner,
                                  knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/scaleX"><linktext>flash.display.DisplayObject.scaleX</linktext></link><link href="flash.display.xml#DisplayObject/scaleY"><linktext>flash.display.DisplayObject.scaleY</linktext></link><link href="flash.filters.xml#DropShadowFilter/distance"><linktext>flash.filters.DropShadowFilter.distance</linktext></link><link href="flash.filters.xml#DropShadowFilter/angle"><linktext>flash.filters.DropShadowFilter.angle</linktext></link></related-links><apiConstructor id="flash.filters:GlowFilter:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
	Initialise une nouvelle occurrence de GlowFilter avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example instantiates a new GlowFilter instance and applies
	it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	
	var color:Number = 0x33CCFF;
	var alpha:Number = .8;
	var blurX:Number = 35;
	var blurY:Number = 35;
	var strength:Number = 2;
	var quality:Number = 3;
	var inner:Boolean = false;
	var knockout:Boolean = false;
	
	var filter:GlowFilter = new GlowFilter(color, 
										 alpha, 
										 blurX, 
										 blurY, 
										 strength, 
										 quality, 
										 inner, 
										 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFF0000</apiData><apiDesc>Couleur du rayonnement, au format hexadécimal 0x<i>RRGGBB</i>. La valeur par défaut est 0xFF0000.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur de transparence alpha de la couleur. Les valeurs valides sont comprises entre 0 et 1. Par exemple, 0,25 définit une valeur de transparence de 25 %.
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>2</apiData><apiDesc>Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste entre le rayonnement et l’arrière-plan est important. Les valeurs valides sont comprises entre 0 et 255. 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Nombre d’applications du filtre. Utilisez les constantes BitmapFilterQuality :
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Pour plus d’informations, voir la description de la propriété <codeph>quality</codeph>.</p>
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Spécifie si le rayonnement est interne. La valeur <codeph> true</codeph> indique un rayonnement interne. La valeur <codeph>false</codeph> renvoie un rayonnement externe (au niveau des bords extérieurs de l’objet). 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Spécifie si l’objet a un effet de masquage. La valeur <codeph>true</codeph> applique un effet de masquage qui rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. 
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Initialise une nouvelle occurrence de GlowFilter avec les paramètres spécifiés.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GlowFilter/quality"><linktext>GlowFilter.quality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GlowFilter:clone"><apiName>clone</apiName><shortdesc>
	Renvoie une copie de cet objet filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GlowFilter objects and compares them: <code>filter_1</code>
	is created by using the GlowFilter constructor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> strength: 2
		// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> strength: 2
	// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Nouvelle occurrence de GlowFilter dont toutes les propriétés sont identiques à celles de l’occurrence de GlowFilter d’origine.
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Renvoie une copie de cet objet filtre.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GlowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Valeur de transparence alpha de la couleur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterAlpha");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Valeur de transparence alpha de la couleur. Les valeurs valides sont comprises entre 0 et 1. Par exemple, 0,25 définit une valeur de transparence de 25 %. La valeur par défaut est 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Quantité de flou horizontal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurX");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurX = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou horizontal. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). La valeur par défaut est 6. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Quantité de flou vertical.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurY");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurY = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Quantité de flou vertical. Les valeurs valides sont comprises entre 0 et 255 (virgule flottante). La valeur par défaut est 6. Les valeurs correspondant à une puissance de 2 (telles que 2, 4, 8, 16 et 32) sont optimisées pour obtenir un rendu plus rapide qu’avec les autres valeurs.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:color:get"><apiName>color</apiName><shortdesc>
	Couleur du rayonnement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterColor");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.color = 0x00FF33;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Couleur du rayonnement. Les valeurs valides sont au format hexadécimal 0x<i>RRGGBB</i>. La valeur par défaut est 0xFF0000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	Spécifie si le rayonnement est interne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterInner");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie si le rayonnement est interne. La valeur <codeph>true</codeph> indique un rayonnement interne. La valeur par défaut est <codeph>false</codeph>, renvoyant un rayonnement externe (au niveau des bords extérieurs de l’objet). 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Spécifie si l’objet a un effet de masquage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterKnockout");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Spécifie si l’objet a un effet de masquage. La valeur <codeph>true</codeph> applique un effet de masquage qui rend le remplissage de l’objet transparent et révèle la couleur d’arrière-plan du document. La valeur par défaut est <codeph>false</codeph> (pas de masquage).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Nombre d’applications du filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterQuality");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Nombre d’applications du filtre. La valeur par défaut est <codeph>BitmapFilterQuality.LOW</codeph>, ce qui revient à appliquer le filtre une seule fois. La valeur <codeph>BitmapFilterQuality.MEDIUM</codeph> applique le filtre deux fois. La valeur <codeph>BitmapFilterQuality.HIGH</codeph> l’applique trois fois. Les rendus des filtres de valeurs faibles sont obtenus plus rapidement.
	
	<p>Pour la plupart des applications, une valeur de <codeph>quality</codeph> faible, moyenne ou élevée est suffisante. Il est possible d’utiliser des valeurs numériques allant jusqu’à 15 pour obtenir différents effets, mais le rendu des valeurs les plus élevées est moins rapide. Sans augmenter la valeur de <codeph>quality</codeph>, vous pouvez généralement obtenir un effet similaire, avec un rendu plus rapide, en augmentant simplement les valeurs des propriétés <codeph>blurX</codeph> et <codeph>blurY</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Intensité de l’empreinte ou recouvrement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterStrength");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.strength = .8;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Intensité de l’empreinte ou recouvrement. Plus la valeur est élevée, plus le recouvrement est intense et plus le contraste entre le rayonnement et l’arrière-plan est important. Les valeurs valides sont comprises entre 0 et 255. La valeur par défaut est 2.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
	 La classe ShaderFilter applique un filtre en exécutant un shader sur l’objet filtré.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe ShaderFilter applique un filtre en exécutant un shader sur l’objet filtré. L’objet filtré est utilisé comme entrée du shader et la sortie du shader devient le résultat du filtre.
	 
	 <p>Pour créer un filtre, utilisez le constructeur <codeph>new ShaderFilter()</codeph>. L’utilisation de filtres dépend de l’objet auquel vous appliquez le filtre.</p>
	 
	 <ul>
	   <li>Pour appliquer des filtres aux clips, champs de texte, boutons et vidéo, utilisez la propriété <codeph>filters</codeph> (héritée de DisplayObject). Lorsque vous définissez la propriété <codeph>filters</codeph> d’un objet, celui-ci n’est pas modifié. En outre, vous pouvez supprimer la propriété <codeph>filters</codeph> pour enlever le filtre.</li>
	   <li>Pour appliquer des filtres aux objets BitmapData, utilisez la méthode <codeph>BitmapData.applyFilter()</codeph>. L’appel de <codeph>applyFilter()</codeph> pour un objet BitmapData génère une image filtrée à partir de l’objet BitmapData source et de l’objet filtre.</li>
	 </ul>
	 
	 <p>Si vous appliquez un filtre à un objet d’affichage, la valeur de la propriété <codeph>cacheAsBitmap</codeph> de cet objet est définie sur true. Si vous supprimez tous les filtres, la valeur d’origine de <codeph>cacheAsBitmap</codeph> est restaurée.</p>
	 
	 <p>Ce filtre prend en charge la mise à l’échelle de la scène. Cependant, il ne prend pas en charge le redimensionnement général, la rotation ni l’inclinaison. Si l’objet lui-même est redimensionné (si les propriétés <codeph>scaleX</codeph> et <codeph>scaleY</codeph> ne sont pas définies sur 100 %), l’effet de filtre n’est pas redimensionné. La mise à l’échelle est effectuée uniquement en cas de zoom avant sur la scène.</p>
	 
	 <p>Aucun filtre n’est appliqué si l’image obtenue dépasse les dimensions maximales. Dans AIR 1.5 et Flash Player 10, la taille maximale est de 8 191 pixels en largeur ou en hauteur, et le nombre total de pixels ne peut pas excéder 16 777 215 pixels (ainsi, si la largeur d’une image est de 8 191 pixels, sa hauteur maximale doit être de 2 048 pixels). Dans Flash Player 9 et les versions antérieures, ainsi que dans AIR 1.1 et les versions antérieures, la limite est de 2 880 pixels de haut sur 2 880 pixels de large. Par exemple, si vous effectuez un zoom avant sur un clip de grande taille auquel un filtre est appliqué, le filtre sera désactivé si l’image obtenue dépasse les dimensions maximales.</p>
	 
	 <p>Pour spécifier l’occurrence Shader à utiliser avec le filtre, transmettez l’occurrence Shader en tant qu’argument au constructeur <codeph>ShaderFilter()</codeph> ou définissez-la en tant que valeur de la propriété <codeph>shader</codeph>.</p>
	 
	 <p>Pour que le résultat du shader puisse s’étendre au-delà des limites de l’objet filtré, utilisez les propriétés <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> et <codeph>bottomExtension</codeph>.</p>
	 
	 </apiDesc><example conref="examples\ShaderFilterExample.1.as"> L’exemple suivant charge un shader et l’utilise en tant que propriété <codeph>shader</codeph> d’un ShaderFilter. Le code trace un cercle dans une occurrence Sprite et l’ajoute sur la scène. Lorsque le shader est chargé, le filtre du shader est appliqué à cette occurrence Sprite.
 
 <p>Notez que cet exemple part du principe qu’un fichier de pseudo-code binaire du shader nommé « gradient.pbj » existe dans le répertoire de sortie de l’application.</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel RedGradientFilter
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "Applies a gradient across the red channel of the input image.";
>
{
    input image4 src;
    output pixel4 dst;
    
    parameter float width
    &lt;
        description: "The width of the image to which the shader is applied.";
        minValue: 0.0;
    >;

    void evaluatePixel()
    {
        pixel4 temp = sampleNearest(src, outCoord());
        temp.r = 1.0 - (outCoord().x * (1.0 / width));
        dst = temp;
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.filters.ShaderFilter;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderFilterExample extends Sprite {
        
        private var loader:URLLoader;
        private var s:Sprite;
        
        public function ShaderFilterExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("gradient.pbj"));
            
            s = new Sprite();
            s.graphics.beginFill(0x009900);
            s.graphics.drawCircle(100, 100, 100);
            addChild(s);
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader(loader.data);
            shader.data.width.value = [s.width];
            
            var gradientFilter:ShaderFilter = new ShaderFilter(shader);
            s.filters = [gradientFilter];
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links><apiConstructor id="flash.filters:ShaderFilter:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
		 Crée un nouveau filtre shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Shader à utiliser pour ce filtre. Pour plus d’informations et pour connaître les limites que le shader doit respecter, voir la description de la propriété <codeph>shader</codeph>.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Crée un nouveau filtre shader.
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#ShaderFilter/shader"><linktext>shader</linktext></link></related-links></apiConstructor><apiValue id="flash.filters:ShaderFilter:bottomExtension:get"><apiName>bottomExtension</apiName><shortdesc>
		 Croissance en pixels sur le bas de l’objet cible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Croissance en pixels sur le bas de l’objet cible.
		 
		 <p>La croissance correspond à la zone située au-delà des limites de l’objet cible transmise au shader durant l’exécution. Au moment de l’exécution, Flash Player ou AIR calcule les limites normales du clip et les étend sur la base des valeurs <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> et <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:leftExtension:get"><apiName>leftExtension</apiName><shortdesc>
		 Croissance en pixels sur le côté gauche de l’objet cible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Croissance en pixels sur le côté gauche de l’objet cible.
		 
		 <p>La croissance correspond à la zone située au-delà des limites de l’objet cible transmise au shader durant l’exécution. Au moment de l’exécution, Flash Player ou AIR calcule les limites normales du clip et les étend sur la base des valeurs <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> et <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:rightExtension:get"><apiName>rightExtension</apiName><shortdesc>
		 Croissance en pixels sur le côté droit de l’objet cible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Croissance en pixels sur le côté droit de l’objet cible.
		 
		 <p>La croissance correspond à la zone située au-delà des limites de l’objet cible transmise au shader durant l’exécution. Au moment de l’exécution, Flash Player ou AIR calcule les limites normales du clip et les étend sur la base des valeurs <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> et <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:shader:get"><apiName>shader</apiName><shortdesc>
		 Shader à utiliser pour ce filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 Shader à utiliser pour ce filtre.
		 
		 <p>Le Shader affecté à la propriété <codeph>shader</codeph> doit spécifier au moins une entrée <codeph>image4</codeph>. Il n’est <b>pas</b> nécessaire de spécifier l’entrée dans le code via la propriété <codeph>input</codeph> de l’objet ShaderInput. L’objet auquel le filtre est appliqué est en fait automatiquement utilisé comme première entrée (entrée avec <codeph>index</codeph> 0). Un shader utilisé comme filtre peut spécifier plusieurs entrées, auquel cas toute entrée supplémentaire doit être spécifiée par la définition de la propriété <codeph>input</codeph> de son occurrence ShaderInput.</p>
		 
		 <p>Lorsque vous affectez une occurrence Shader à cette propriété, le shader est copié en interne et l’opération de filtrage utilise cette copie interne, et non une référence au shader d’origine. Toute modification apportée au shader, par exemple la modification de la valeur d’un paramètre, l’entrée ou le pseudo-code binaire, n’est pas appliquée au shader copié utilisé pour le filtre. Pour que les modifications apportées au shader soient prises en compte dans le résultat du filtre, vous devez réaffecter l’occurrence Shader à la propriété <codeph>shader</codeph>. Comme pour tous les filtres, vous devez également réaffecter l’occurrence de ShaderFilter à la propriété <codeph>filters</codeph> de l’objet d’affichage afin d’appliquer les modifications du filtre.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:topExtension:get"><apiName>topExtension</apiName><shortdesc>
		 Croissance en pixels sur le haut de l’objet cible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Croissance en pixels sur le haut de l’objet cible.
		 
		 <p>La croissance correspond à la zone située au-delà des limites de l’objet cible transmise au shader durant l’exécution. Au moment de l’exécution, Flash Player ou AIR calcule les limites normales du clip et les étend sur la base des valeurs <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> et <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>