<?xml version="1.0"?>
<apiPackage id="flash.geom"><apiName>flash.geom</apiName><apiDetail/><apiClassifier id="flash.geom:Utils3D"><apiName>Utils3D</apiName><shortdesc> 
 La classe Utils3D contient des méthodes statiques qui simplifient l’implémentation de certaines opérations de matrices tridimensionnelles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Classe d’utilitaires avec méthodes statiques qui simplifient l’implémentation de certaines opérations tridimensionnelles. 
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 La classe Utils3D contient des méthodes statiques qui simplifient l’implémentation de certaines opérations de matrices tridimensionnelles.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiOperation id="flash.geom:Utils3D:pointTowards"><apiName>pointTowards</apiName><shortdesc>
    Interpole l’orientation d’un objet par rapport à une position.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Version modifiée de l’objet Matrix3D spécifié dans le second paramètre. Pour transformer l’objet d’affichage à l’aide de la méthode <codeph>pointTowards()</codeph>, définissez la propriété Matrix3D de l’objet d’affichage sur l’objet Matrix3D renvoyé.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre compris entre 0 et 1 qui tourne progressivement (par incrément) l’objet vers la cible.
    
    </apiDesc></apiParam><apiParam><apiItemName>mat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Propriété Matrix3D de l’objet transformé. 
    
    </apiDesc></apiParam><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Position par rapport au monde de l’objet cible. Le terme « par rapport au monde » définit la transformation de l’objet par rapport à l’espace monde et aux coordonnées, dans lequel tous les objets sont positionnés.  
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Vecteur relatif à l’objet qui définit l’endroit vers lequel pointe l’objet d’affichage. Le terme « relatif à l’objet » définit la transformation de l’objet par rapport à l’espace objet, la propre image de référence de l’objet et son propre système de coordonnées. La valeur par défaut est (0,0,-1).
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Vecteur relatif à l’objet qui définit « up » pour l’objet d’affichage. Si l’objet est dessiné tel que regardant vers le bas à partir du point ci-dessus, l’axe <i>+z</i> est son vecteur « up ». Le terme « relatif à l’objet » définit la transformation de l’objet par rapport à l’espace objet, la propre image de référence de l’objet et son propre système de coordonnées. La valeur par défaut est (0,-1,0).
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Interpole l’orientation d’un objet par rapport à une position. La méthode <codeph>pointTowards()</codeph> combine les fonctionnalités des méthodes <codeph>Matrix3D.pointAt()</codeph> et <codeph>Matrix3D.interpolateTo()</codeph>.  
    
    <p>La méthode <codeph>pointTowards()</codeph> autorise des modifications en place de l’orientation. Elle décompose la Matrix3D de l’objet d’affichage et remplace les éléments de rotation par ceux qui entraînent une rotation en pourcentage vers la position de la cible. L’objet peut se tourner progressivement vers la cible tout en continuant à se déplacer dans sa propre direction. Les appels consécutifs à la méthode <codeph>pointTowards()</codeph> suivis d’une méthode de translation peuvent produire l’animation d’un objet poursuivant une cible en déplacement. Commencez par faire pointer l’objet d’un pour cent vers la cible, puis déplacez progressivement (par incrément) l’objet le long d’un axe.</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/pointAt()"><linktext>flash.geom.Matrix3D.pointAt()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>flash.geom.Matrix3D.interpolateTo()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>flash.geom.Matrix3D.interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVector"><apiName>projectVector</apiName><shortdesc>
    A l’aide d’un objet de projection Matrix3D, projette un objet Vector3D d’une coordonnée spatiale vers une autre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nouveau Vector3D avec une coordonnée spatiale transformée.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Objet de projection Matrix3D qui implémente la transformation de la projection. Si un objet d’affichage dispose d’un objet PerspectiveProjection, vous pouvez utiliser la méthode <codeph>perspectiveProjection.toMatrix()</codeph> pour produire un objet de projection Matrix3D s’appliquant aux enfants de l’objet d’affichage. Pour des projections plus avancées, utilisez la propriété <codeph>matrix3D.rawData</codeph> pour créer une matrice de projection personnalisée. Aucune méthode Matrix3D intégrée ne permet de créer un objet de projection Matrix3D.
    
    </apiDesc></apiParam><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D projeté vers une nouvelle coordonnée spatiale.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    A l’aide d’un objet de projection Matrix3D, projette un objet Vector3D d’une coordonnée spatiale vers une autre. La méthode <codeph>projectVector()</codeph> est identique à la méthode <codeph>Matrix3D.transformVector()</codeph> si ce n’est que la méthode <codeph>projectVector()</codeph> divise les éléments <i>x</i>, <i>y</i> et <i>z</i> de l’objet Vector3D d’origine par la valeur de profondeur de la projection. La valeur de profondeur est la distance qui sépare l’oeil de l’objet Vector3D dans l’espace visuel ou d’affichage. La valeur par défaut de cette distance est celle de l’élément <i>z</i>.
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>flash.geom.Matrix3D.transformVector()</linktext></link><link href="flash.geom.xml#Utils3D/projectVectors()"><linktext>projectVectors()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVectors"><apiName>projectVectors</apiName><shortdesc>
    A l’aide d’un objet de projection Matrix3D, projette un vecteur de coordonnées tridimensionnelles (verts) sur un vecteur de coordonnées bidimensionnelles (projectedVerts).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Objet de projection Matrix3D qui implémente la transformation de la projection. Vous pouvez produire un objet de projection Matrix3D à l’aide de la propriété <codeph>Matrix3D.rawData</codeph>.
    </apiDesc></apiParam><apiParam><apiItemName>verts</apiItemName><apiType value="Vector$Number"/><apiDesc>Vecteur de nombres, où chaque triplet de nombres représentent les coordonnées <i>x</i>, <i>y</i> et <i>z</i> d’un espace tridimensionnel, tel que <codeph>Vector3D(x,y,z)</codeph>. 
    
    </apiDesc></apiParam><apiParam><apiItemName>projectedVerts</apiItemName><apiType value="Vector$Number"/><apiDesc>Vecteur de nombres, où chaque paire de nombres représente une coordonnée bidimensionnelle projetée, telle que <codeph>Point(x,y)</codeph>. Il est préférable de préaffecter l’objet Vector. La méthode <codeph>projectVectors()</codeph> remplit les valeurs de chaque point projeté.
    
    </apiDesc></apiParam><apiParam><apiItemName>uvts</apiItemName><apiType value="Vector$Number"/><apiDesc>Vecteur de nombres, où chaque triplet de nombres représente les éléments <i>u</i>, <i>v</i> et <i>t</i> des données <codeph>uvt</codeph>. Les valeurs <i>u</i> et <i>v</i> représentent la coordonnée de texture de chaque point projeté. La valeur <i>t</i> est la valeur de profondeur de la projection, ou distance entre l’oeil et l’objet Vector3D dans l’espace d’affichage ou visuel. Il est préférable de préaffecter le vecteur et de spécifier les valeurs <i>u</i> et <i>v</i>. La méthode <codeph>projectVectors()</codeph> renseigne la valeur <i>t</i> de chaque point projeté.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Projette un vecteur de coordonnées tridimensionnelles sur un vecteur de coordonnées bidimensionnelles.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    A l’aide d’un objet de projection Matrix3D, projette un vecteur de coordonnées tridimensionnelles (<i>verts</i>) sur un vecteur de coordonnées bidimensionnelles (<codeph>projectedVerts</codeph>). L’objet Vector projeté doit être préaffecté avant d’être utilisé comme paramètre. 
    
    <p>La méthode <codeph>projectVectors()</codeph> définit également la valeur <i>t</i> des données <i>uvt</i>. Il est préférable de préaffecter l’objet Vector détenant les données <i>uvts</i> de chaque jeu de coordonnées d’un objet Vector projeté. De la même façon, spécifiez les valeurs <i>u</i> et <i>v</i> des données <i>uvt</i>. Les données <i>uvt</i> représentent un vecteur de coordonnées normalisées utilisé pour le mappage de la texture. Dans les coordonnées UV, (0,0) est le coin supérieur gauche de l’image bitmap et (1,1) son coin inférieur droit.</p>
    
    <p>Cette méthode peut être utilisée en combinaison avec la méthode <codeph>Graphics.drawTriangles()</codeph> et la classe <codeph>GraphicsTrianglePath</codeph>.</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D/projectVector()"><linktext>projectVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.geom:Vector3D"><apiName>Vector3D</apiName><shortdesc> 
 La classe Vector3D représente un point ou un emplacement dans l’espace tridimensionnel à l’aide de coordonnées cartésiennes (x,y,z).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 La classe Vector3D représente un point ou un emplacement dans l’espace tridimensionnel à l’aide de coordonnées cartésiennes (x,y,z). Comme dans un espace à deux dimensions, la propriété <codeph>x</codeph> représente l’axe horizontal et la propriété <codeph>y</codeph> l’axe vertical. Dans l’espace à trois dimensions, la propriété <codeph>z</codeph> représente la profondeur. La valeur de la propriété <codeph>x</codeph> augmente lorsque l’objet se déplace vers la droite. La valeur de la propriété <codeph>y</codeph> augmente lorsque l’objet se déplace vers le bas. La valeur de la propriété <codeph>z</codeph> augmente lorsque l’objet s’éloigne du point de vue. Avec une projection de perspective et une mise à l’échelle, l’objet semble grossir lorsqu’il est proche et diminuer lorsqu’il s’éloigne de l’écran. Comme dans un système tridimensionnel dirigé vers la droite, l’axe z positif s’éloigne de l’observateur et la valeur de la propriété <codeph>z</codeph> augmente au fur et à mesure que l’objet s’éloigne de l’oeil de l’observateur. Le point d’origine (0,0,0) de l’espace global est le coin supérieur gauche de la scène. 
   
 <p><adobeimage alt="Axes X, Y, Z" href="../../images/xyzAxes.jpg"/></p>
 
 <p>La classe Vector3D peut également représenter une direction, une flèche pointant de l’origine des coordonnées, par exemple (0,0,0), vers un point de fin ; ou un composant à virgule flottante du modèle de couleur RVB (Rouge, Vert, Bleu).</p> 
 
 <p>La notation quaternion introduit un quatrième élément, la propriété <codeph>w</codeph>, qui donne des informations supplémentaires sur l’orientation. Par exemple, la propriété <codeph>w</codeph> peut définir l’angle de rotation d’un objet Vector3D. La combinaison de l’angle de rotation et des coordonnées x, y et z peut déterminer l’orientation de l’objet d’affichage. Voici une représentation d’éléments Vector3D dans une notation matricielle :</p>
 
 <p><adobeimage alt="Eléments Vector3D" href="../../images/Vector3Delements.jpg"/></p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiConstructor id="flash.geom:Vector3D:Vector3D"><apiName>Vector3D</apiName><shortdesc>
     Crée une occurrence d’objet Vector3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Premier élément, par exemple la coordonnée x. 
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Deuxième élément, par exemple la coordonnée y. 
     </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Troisième élément, par exemple la coordonnée z. 
     </apiDesc></apiParam><apiParam><apiItemName>w</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>Elément facultatif pour des données supplémentaires telles que l’angle de rotation. 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence d’objet Vector3D. Si vous ne spécifiez pas de paramètre pour le constructeur, un objet Vector3D est créé avec les éléments (0,0,0,0).
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Vector3D:add"><apiName>add</apiName><shortdesc>
    Ajoute la valeur des éléments x, y et z de l’objet Vector3D actuel aux valeurs des éléments x, y et z d’un autre objet Vector3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Vector3D résultant de l’ajout de l’objet Vector3D actuel à un autre objet Vector3D.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D à ajouter à l’objet Vector3D actuel.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Ajoute l’objet Vector3D actuel à un autre pour créer un nouvel objet Vector3D. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Ajoute la valeur des éléments x, y et z de l’objet Vector3D actuel aux valeurs des éléments x, y et z d’un autre objet Vector3D. La méthode <codeph>add()</codeph> ne change pas l’objet Vector3D actuel, mais renvoie un nouvel objet Vector3D avec les nouvelles valeurs.
    
    <p>L’addition des deux vecteurs résulte en un autre vecteur. Pour visualiser le résultat, il suffit de tracer un vecteur de l’origine ou la queue du premier vecteur jusqu’à la fin ou la tête du second vecteur. Le vecteur résultant est la distance entre le point d’origine du premier vecteur et le point de fin du second.</p>   
    
    <p><adobeimage alt="Vector3D résultant" href="../../images/resultantVector3D.jpg"/></p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/incrementBy()"><linktext>incrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:angleBetween"><apiName>angleBetween</apiName><shortdesc>
    Renvoie l’angle entre deux vecteurs, en radians.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Angle entre deux objets Vector3D.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Premier objet Vector3D.
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Deuxième objet Vector3D.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Renvoie l’angle entre deux vecteurs, en radians. L’angle renvoyé est le plus petit radian selon lequel le premier objet Vector3D pivote jusqu’à ce qu’il soit aligné sur le deuxième objet Vector3D. 
    
    <p>La méthode <codeph>angleBetween()</codeph> est une méthode statique. Vous pouvez l’utiliser directement en tant que méthode de la classe Vector3D.</p>
    
    <p>Pour convertir un degré en radian, vous pouvez utiliser la formule suivante :</p> 
    
    <p><codeph>radian = Math.PI/180 ~~ degré</codeph></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:clone"><apiName>clone</apiName><shortdesc>
    Renvoie un nouvel objet Vector3D qui est une copie exacte de l’objet Vector3D actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet Vector3D qui est une copie de l’objet Vector3D actuel.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Renvoie un nouvel objet Vector3D qui est une copie exacte de l’objet Vector3D actuel.
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:crossProduct"><apiName>crossProduct</apiName><shortdesc>
    Renvoie un nouvel objet Vector3D perpendiculaire (à angle droit) à l’objet Vector3D actuel et à un autre objet Vector3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet Vector3D perpendiculaire à l’objet Vector3D actuel et à l’objet Vector3D spécifié sous forme de paramètre.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Deuxième objet Vector3D. 
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Renvoie un nouvel objet Vector3D perpendiculaire (à angle droit) à l’objet Vector3D actuel et à un autre objet Vector3D. Si les coordonnées de l’objet Vector3D renvoyé sont (0,0,0), les deux objets Vector3D sont perpendiculaires entre eux.
    
    <p><adobeimage alt="Produit vectoriel" href="../../images/crossproduct.jpg"/></p>
    
    <p>Vous pouvez utiliser le produit vectoriel normalisé de deux sommets d’une surface polygonale par le vecteur normalisé du point de vue de la caméra ou de l’oeil pour obtenir un produit scalaire. La valeur du produit scalaire indique si la surface d’un objet tridimensionnel est invisible pour le point de vue.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/dotProduct()"><linktext>dotProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:decrementBy"><apiName>decrementBy</apiName><shortdesc>
    Décrémente la valeur des éléments x, y et z de l’objet Vector3D actuel par les valeurs des éléments x, y et z de l’objet Vector3D spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D contenant les valeurs à soustraire de l’objet Vector3D actuel.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Décrémente l’objet Vector3D actuel par un autre objet Vector3D.  
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Décrémente la valeur des éléments x, y et z de l’objet Vector3D actuel par les valeurs des éléments x, y et z de l’objet Vector3D spécifié. Contrairement à la méthode <codeph>Vector3D.subtract()</codeph>, la méthode <codeph>decrementBy()</codeph> change l’objet Vector3D actuel et ne renvoie pas de nouvel objet Vector3D.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/subtract()"><linktext>subtract()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:distance"><apiName>distance</apiName><shortdesc>
    Renvoie la distance entre deux objets Vector3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Distance entre deux objets Vector3D.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D en tant que premier point tridimensionnel. 
    </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D en tant que second point tridimensionnel.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Renvoie la distance entre deux objets Vector3D. La méthode <codeph>distance()</codeph> est une méthode statique. Vous pouvez l’utiliser directement en tant que méthode de la classe Vector3D pour obtenir la distance euclidienne entre deux points tridimensionnels.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:dotProduct"><apiName>dotProduct</apiName><shortdesc>
    Si l’objet Vector3D actif et celui spécifié en tant que paramètre sont des sommets unitaires, cette méthode renvoie le cosinus de l’angle séparant les deux sommets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Scalaire correspondant au produit scalaire de l’objet Vector3D actuel et de l’objet Vector3D spécifié.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Deuxième objet Vector3D. 
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie le produit scalaire de l’objet actuel avec un autre objet Vector3D.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Si l’objet Vector3D actif et celui spécifié en tant que paramètre sont des sommets unitaires, cette méthode renvoie le cosinus de l’angle séparant les deux sommets. Les sommets unitaires sont des sommets qui pointent dans la même direction mais dont la longueur est égale à un. Ils retirent la longueur du vecteur en tant que facteur dans le résultat. Vous pouvez utiliser la méthode <codeph>normalize()</codeph> pour convertir un vecteur en vecteur unitaire. 
    
    <p>La méthode <codeph>dotProduct()</codeph> recherche l’angle séparant deux sommets. Elle est également utilisée pour le calcul du backface culling (élimination des faces cachées) ou de l’éclairage. Le backface culling est une procédure qui consiste à identifier les surfaces invisibles à partir du point de vue. Vous pouvez utiliser les sommets normalisés du point de vue de l’appareil photo, ou de l’oeil, et le produit vectoriel des sommets d’une surface polygonale pour obtenir le produit scalaire. Si le produit scalaire est inférieur à zéro, la surface fait face à l’objectif ou à l’observateur. Si les deux sommets unitaires sont perpendiculaires entre eux, ils sont orthogonaux et le produit scalaire est égal à zéro. Si les deux sommets sont parallèles entre eux, le produit scalaire est égal à un.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/crossProduct()"><linktext>crossProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:equals"><apiName>equals</apiName><shortdesc>
    Détermine si deux objets Vector3D sont égaux en comparant les éléments x, y et z de l’objet Vector3D actuel à un objet Vector3D spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>La valeur est <codeph>true</codeph> si l’objet Vector3D spécifié est égal à l’objet Vector3D actuel ; <codeph>false</codeph> s’ils ne sont pas égaux.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D à comparer à l’objet Vector3D actuel.
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Paramètre facultatif qui spécifie si la propriété <codeph>w</codeph> des objets Vector3D est utilisée dans la comparaison.  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Détermine si deux objets Vector3D sont égaux en comparant les éléments x, y et z de l’objet Vector3D actuel à un objet Vector3D spécifié. Si les valeurs de ces éléments sont identiques, les deux objets Vector3D sont égaux. Si le second paramètre est défini sur <codeph>true</codeph>, les quatre éléments des objets Vector3D, y compris la propriété <codeph>w</codeph>, sont comparés. 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/nearEquals()"><linktext>nearEquals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:incrementBy"><apiName>incrementBy</apiName><shortdesc>
    Incrémente la valeur des éléments x, y et z de l’objet Vector3D actuel en fonction des valeurs des éléments x, y et z d’un objet Vector3D spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D à ajouter à l’objet Vector3D actuel.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Incrémente l’objet Vector3D actuel par un autre objet Vector3D. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Incrémente la valeur des éléments x, y et z de l’objet Vector3D actuel en fonction des valeurs des éléments x, y et z d’un objet Vector3D spécifié. Contrairement à la méthode <codeph>Vector3D.add()</codeph>, la méthode <codeph>incrementBy()</codeph> change l’objet Vector3D actuel et ne renvoie pas de nouvel objet Vector3D.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/add()"><linktext>add()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:nearEquals"><apiName>nearEquals</apiName><shortdesc>
    Compare les éléments de l’objet Vector3D actuel et ceux d’un objet Vector3D spécifié afin de déterminer s’ils sont à peu près égaux.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>La valeur est <codeph>true</codeph> si l’objet Vector3D spécifié est à peu près égal à l’objet Vector3D actuel ; <codeph>false</codeph> dans le cas contraire.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D à comparer à l’objet Vector3D actuel. 
    </apiDesc></apiParam><apiParam><apiItemName>tolerance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre déterminant le facteur de tolérance. Si la différence entre les valeurs de l’élément Vector3D spécifié dans le paramètre <codeph>toCompare</codeph> et l’élément Vector3D actuel est inférieure au nombre de tolérance, les deux valeurs sont considérées comme quasiment égales.  
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Paramètre facultatif qui spécifie si la propriété <codeph>w</codeph> des objets Vector3D est utilisée dans la comparaison.  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Compare les éléments de l’objet Vector3D actuel et ceux d’un objet Vector3D spécifié afin de déterminer s’ils sont à peu près égaux. Les deux objets Vector3D sont à peu près égaux si la valeur de tous les éléments des deux sommets sont égaux, ou si le résultat de la comparaison est comprise dans la plage de tolérance. La différence entre deux éléments doit être inférieure au nombre spécifié en tant que paramètre <codeph>tolerance</codeph>. Si le troisième paramètre facultatif est défini sur <codeph>true</codeph>, les quatre éléments des objets Vector3D, y compris la propriété <codeph>w</codeph>, sont comparés. Dans le cas contraire, seuls les éléments x, y et z sont inclus dans la comparaison.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/equals()"><linktext>equals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:negate"><apiName>negate</apiName><shortdesc>
    Définit l’objet Vector3D actuel sur son inverse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Définit l’objet Vector3D actuel sur son inverse. L’objet inverse est également considéré comme l’opposé de l’objet d’origine. La valeur des propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph> de l’objet Vector3D actuel est modifiée en <codeph>-x</codeph>, <codeph>-y</codeph> et <codeph>-z</codeph>. 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:normalize"><apiName>normalize</apiName><shortdesc>
    Convertit un objet Vector3D en vecteur unitaire en divisant les trois premiers éléments (x, y, z) par la longueur du vecteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Longueur de l’objet Vector3D actuel.
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Convertit un objet Vector3D en vecteur unitaire en divisant les trois premiers éléments (x, y, z) par la longueur du vecteur. Les sommets unitaires sont des sommets qui ont une direction mais dont la longueur est égale à un. Ils simplifient les calculs de vecteur en supprimant la longueur en tant que facteur.
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:project"><apiName>project</apiName><shortdesc>
     Divise la valeur des propriétés x, y et z de l’objet Vector3D actuel par la valeur de sa propriété w.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Divise la valeur des propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph> de l’objet Vector3D actuel par la valeur de sa propriété <codeph>w</codeph>. 
     
     <p>Si l’objet Vector3D actuel résulte de la multiplication d’un objet Vector3D par un objet Matrix3D de projection, la propriété <codeph>w</codeph> peut détenir la valeur de transformation. La méthode <codeph>project()</codeph> peut alors compléter la projection en divisant les éléments par la propriété <codeph>w</codeph>. Utilisez la propriété <codeph>Matrix3D.rawData</codeph> pour créer un objet de Matrix3D de projection.</p>
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:scaleBy"><apiName>scaleBy</apiName><shortdesc>
    Met à l’échelle l’objet Vector3D actuel en multipliant par un nombre scalaire, une amplitude.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur (scalaire) utilisé pour mettre un objet Vector3D à l’échelle.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Met à l’échelle l’objet Vector3D actuel en multipliant par un nombre scalaire, une amplitude. Les éléments x, y et z de l’objet Vector3D sont multipliés par le nombre scalaire spécifié dans le paramètre. Par exemple, si le vecteur est mis à l’échelle par une multiplication par 10, le résultat est un vecteur 10 fois plus grand. Le nombre scalaire peut également changer la direction du vecteur. La multiplication du vecteur par un nombre négatif inverse sa direction.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:subtract"><apiName>subtract</apiName><shortdesc>
    Soustrait la valeur des éléments x, y et z de l’objet Vector3D actuel des valeurs des éléments x, y et z d’un autre objet Vector3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet Vector3D correspondant à la différence entre l’objet Vector3D actuel et l’objet Vector3D spécifié.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D à soustraire de l’objet Vector3D actuel.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Soustrait l’objet Vector3D actuel d’un autre objet Vector3D pour créer un nouvel objet Vector3D. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Soustrait la valeur des éléments x, y et z de l’objet Vector3D actuel des valeurs des éléments x, y et z d’un autre objet Vector3D. La méthode <codeph>subtract()</codeph> ne change pas l’objet Vector3D actuel, mais renvoie un nouvel objet Vector3D avec les nouvelles valeurs.
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/decrementBy()"><linktext>decrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:toString"><apiName>toString</apiName><shortdesc>
     Renvoie une représentation sous forme de chaîne de l’objet Vector3D actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne contenant les valeurs des propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph>.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Renvoie une représentation sous forme de chaîne de l’objet Vector3D actuel. Chaîne contenant les valeurs des propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph>.
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Vector3D:X_AXIS"><apiName>X_AXIS</apiName><shortdesc>
    Axe x défini en tant qu’objet Vector3D avec les coordonnées (1,0,0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Axe x défini en tant qu’objet Vector3D avec les coordonnées (1,0,0).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Y_AXIS"><apiName>Y_AXIS</apiName><shortdesc>
    Axe y défini en tant qu’objet Vector3D avec les coordonnées (0,1,0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Axe y défini en tant qu’objet Vector3D avec les coordonnées (0,1,0).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Z_AXIS"><apiName>Z_AXIS</apiName><shortdesc>
    Axe z défini en tant qu’objet Vector3D avec les coordonnées (0,0,1).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Axe z défini en tant qu’objet Vector3D avec les coordonnées (0,0,1).
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:w"><apiName>w</apiName><shortdesc>
     Le quatrième élément d’un objet Vector3D (en plus des propriétés x, y et z) peut détenir des données telles que l’angle de rotation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Le quatrième élément d’un objet Vector3D (en plus des propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph>) peut détenir des données telles que l’angle de rotation. La valeur par défaut est 0.
     
     <p>La notation quaternion emploie un angle comme quatrième élément dans son calcul de la rotation tridimensionnelle. La propriété <codeph>w</codeph> peut être utilisée pour définir l’angle de rotation autour de l’objet Vector3D. La combinaison de l’angle de rotation et des coordonnées (x,y,z) détermine l’orientation de l’objet d’affichage. </p>
     <p>De plus, la propriété <codeph>w</codeph> peut être utilisée en tant que facteur de déformation de la perspective pour une position tridimensionnelle projetée, ou en tant que valeur de transformation de la projection lors de la représentation d’une coordonnée tridimensionnelle projetée dans un espace à deux dimensions. Par exemple, vous pouvez créer une matrice de projection à l’aide de la propriété <codeph>Matrix3D.rawData</codeph>, qui, une fois appliquée à un objet Vector3D, produit une valeur de transformation dans le quatrième élément de l’objet Vector3D (la propriété <codeph>w</codeph>). La division des autres éléments de l’objet Vector3D par la valeur de transformation produit alors un objet Vector3D projeté. Vous pouvez utiliser la méthode <codeph>Vector3D.project()</codeph> pour diviser les trois premiers éléments d’un objet Vector3D par son quatrième élément.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/project()"><linktext>project()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:x"><apiName>x</apiName><shortdesc>
     Premier élément d’un objet Vector3D, par exemple la coordonnée x d’un point dans l’espace tridimensionnel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Premier élément d’un objet Vector3D, par exemple la coordonnée x d’un point dans l’espace tridimensionnel. La valeur par défaut est 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:y"><apiName>y</apiName><shortdesc>
     Second élément d’un objet Vector3D, par exemple la coordonnée y d’un point dans l’espace tridimensionnel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Second élément d’un objet Vector3D, par exemple la coordonnée y d’un point dans l’espace tridimensionnel. La valeur par défaut est 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:z"><apiName>z</apiName><shortdesc>
     Troisième élément d’un objet Vector3D, par exemple la coordonnée z d’un point dans l’espace tridimensionnel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Troisième élément d’un objet Vector3D, par exemple la coordonnée z d’un point dans l’espace tridimensionnel. La valeur par défaut est 0.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:length:get"><apiName>length</apiName><shortdesc>
    Longueur, amplitude, de l’objet Vector3D actuel depuis l’origine (0,0,0) jusqu’aux coordonnées x, y et z de l’objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Longueur de l’objet Vector3D actuel. 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Longueur, amplitude, de l’objet Vector3D actuel depuis l’origine (0,0,0) jusqu’aux coordonnées x, y et z de l’objet. La propriété <codeph>w</codeph> est ignorée. Le vecteur unitaire a une longueur ou une amplitude égale à un.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/lengthSquared"><linktext>lengthSquared</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:lengthSquared:get"><apiName>lengthSquared</apiName><shortdesc>
    Carré de la longueur de l’objet Vector3D actuel, calculé à l’aide des propriétés x, y, et z.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Carré de la longueur de l’objet Vector3D actuel. 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Carré de la longueur de l’objet Vector3D actuel, calculé à l’aide des propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>z</codeph>. La propriété <codeph>w</codeph> est ignorée. Utilisez la méthode <codeph>lengthSquared()</codeph> chaque fois que possible à la place de l’appel à la méthode <codeph>Math.sqrt()</codeph>, plus lent, de la méthode <codeph>Vector3D.length()</codeph>.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/length"><linktext>length</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
 La classe Matrix3D représente une matrice de transformation qui détermine la position et l’orientation d’un l’objet d’affichage tridimensionnel (3D).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><internal>Removed the following since it was very unclear. It could be used for a future example however:
 <p>To support a camera viewpoint and motion, create a camera class that keeps a Matrix3D object for 
 handling the movement of the display objects relative to the camera. In the camera space, the display objects 
 move in the opposite direction of the camera movement. For example, when the camera moves closer, the objects 
 become bigger. In other words, if the camera moves down the world z axis, the objects moves up 
 the z axis. One way to produce this effect is by setting the Matrix3D object of the camera class 
 to the inverse of the display objects' transformation. If the display objects are children of the <code>root</code> 
 display object, the Matrix3D object of the camera class can be set to the inverse of the <code>root</code> 
 display object. Another option is to have the display objects as children of a camera object.</p>
 
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Matrix3D représente une matrice de transformation qui détermine la position et l’orientation d’un l’objet d’affichage tridimensionnel (3D). La matrice peut exécuter des fonctions de transformation : translation (repositionnement le long des axes x, y et z), rotation et mise à l’échelle (redimensionnement), entre autres. La classe Matrix3D peut également exécuter une projection en perspective, qui mappe des points de l’espace de coordonnées 3D sur un affichage bidimensionnel (2D). 
 
 <p>Une seule matrice peut combiner plusieurs transformations et les appliquer simultanément à un objet d’affichage 3D. Par exemple, une matrice peut être appliquée à des coordonnées 3D et effectuer une rotation, puis une translation. </p> 
 
 <p>Lorsque vous définissez de façon explicite la propriété <codeph>z</codeph> ou l’une des propriétés de rotation ou de mise à l’échelle d’un objet d’affichage, un objet Matrix3D correspondant est automatiquement créé.</p>
 
 <p>Vous pouvez accéder à l’objet Matrix3D d’un objet d’affichage 3D par le biais de la propriété <codeph>transform.matrix3d</codeph>. Les objets 2D ne possèdent pas d’objet Matrix3D. </p>
 
 <p>La valeur de la propriété <codeph>z</codeph> d’un objet 2D est zéro et la valeur de sa propriété <codeph>matrix 3D</codeph> est <codeph>null</codeph>.</p> 
 
 <p><b>Remarque :</b> si le même objet Matrix3D est attribué à deux objets d’affichage distincts, une erreur d’exécution est renvoyée.</p>
 
 <p>La classe Matrix3D utilise une matrice carrée 4x4 : une table de quatre lignes et colonnes de nombres qui contiennent les données de la transformation. Les trois premières lignes de la matrice contiennent les données de chaque axe 3D (x,y,z). Les informations de translation sont dans la dernière colonne. Les données d’orientation et de mise à l’échelle sont dans les trois premières colonnes. Les facteurs de mise à l’échelle sont les nombres situés dans les diagonales des trois premières colonnes. Voici une représentation d’éléments Matrix3D :</p>  
 
 <p><adobeimage alt="Eléments Matrix3D" href="../../images/Matrix3Delements.jpg"/></p>
 
 <p>Il n’est pas nécessaire de comprendre les mathématiques matricielles pour pouvoir utiliser la classe Matrix3D. Elle offre des méthodes spécifiques qui simplifient la tâche de la transformation et de la projection : <codeph>appendTranslation()</codeph>, <codeph>appendRotation()</codeph> et <codeph>interpolateTo()</codeph>. Vous pouvez également utiliser les méthodes <codeph>decompose()</codeph> et <codeph>recompose()</codeph> ou la propriété <codeph>rawData</codeph> pour accéder aux éléments de la matrice sous-jacente.</p>
 
 <p>Les objets d’affichage mettent en cache les propriétés de rotation de leurs axes pour obtenir une rotation distincte pour chaque axe et gérer les différentes combinaisons de rotation. Lorsqu’une méthode d’un objet Matrix3D est appelée pour transformer un objet d’affichage, le cache de la rotation de l’objet est invalidé.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links><apiConstructor id="flash.geom:Matrix3D:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
    Crée un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>v</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Objet Vector de seize nombres, dans lequel chaque groupe de quatre éléments peut être une ligne ou une colonne d’une matrice 4x4.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Crée un objet Matrix3D. Les objets Matrix3D peuvent être initialisés avec un objet Vector de 16 nombres, où chaque groupe de quatre éléments peut être une ligne ou une colonne. Après la création de l’objet Matrix3D, vous pouvez accéder aux éléments de sa matrice par la propriété <codeph>rawData</codeph>. 
    
    <p>Si aucun paramètre n’est défini, le constructeur produit un objet Matrix3D d’identité ou unitaire. Dans la notation des matrices, une matrice d’identité a une valeur de un pour tous les éléments situés sur la diagonale principale et une valeur de zéro pour tous les autres éléments. La valeur de la propriété <codeph>rawData</codeph> d’une matrice d’identité est : <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph>. La position ou la valeur de translation de la matrice d’identité est <codeph>Vector3D(0,0,0)</codeph>, le paramètre de rotation est <codeph>Vector3D(0,0,0)</codeph> et la valeur de mise à l’échelle est <codeph>Vector3D(1,1,1)</codeph>.</p> 
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix3D/identity()"><linktext>identity()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Matrix3D:append"><apiName>append</apiName><shortdesc>
    Ajoute la matrice en multipliant un autre objet Matrix3D par l’objet Matrix3D actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Matrice gauche multipliée par l’objet Matrix3D actuel.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute la matrice en multipliant un autre objet Matrix3D par l’objet Matrix3D actuel. Le résultat combine les deux transformations de matrice. Vous pouvez multiplier un objet Matrix3D par de nombreuses matrices. L’objet Matrix3D final contient le résultat de toutes les transformations.
    
    <p>Les multiplications de matrices diffèrent des additions de matrices. La multiplication de matrices n’est pas commutative. En d’autres termes, A fois B n’est pas égal à B fois A. Avec la méthode <codeph>append()</codeph>, la multiplication s’effectue à partir du côté gauche, ce qui signifie que l’objet Matrix3D <codeph>lhs</codeph> est situé à gauche de l’opérateur de la multiplication.</p>
    
    <codeph>thisMatrix = lhs ~~ thisMatrix;</codeph>
      
    <p>La première fois que la méthode <codeph>append()</codeph> est appelée, elle effectue une modification par rapport à l’espace parent. Les appels suivants sont relatifs à l’image de référence de l’objet Matrix3D ajouté.</p>
    
    <p>La méthode <codeph>append()</codeph> remplace la matrice actuelle par la matrice ajoutée. Si vous souhaitez ajouter deux matrices sans modifier la matrice actuelle, copiez cette dernière à l’aide de la méthode <codeph>clone()</codeph> et appliquez la méthode <codeph>append()</codeph> à la copie.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prepend()"><linktext>flash.geom.Matrix3D.prepend()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendRotation"><apiName>appendRotation</apiName><shortdesc>
    Ajoute une rotation incrémentielle à la fin d’un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Degré de la rotation.
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Axe ou direction de la rotation. Les axes habituels sont <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) et <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Point qui détermine le centre de la rotation d’un objet. Le point de pivot par défaut d’un objet est son point d’alignement.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute une rotation incrémentielle à la fin d’un objet Matrix3D. Lorsque l’objet Matrix3D est appliqué à un objet d’affichage, la matrice exécute la rotation après les autres transformations dans l’objet Matrix3D. 
    
    <p>La rotation de l’objet d’affichage est définie par un axe, un degré incrémentiel de rotation autour de l’axe et un point de pivot facultatif pour le centre de la rotation de l’objet. L’axe peut être toute direction générale. Les axes courants sont <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) et <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). Dans la terminologie de l’aviation, la rotation autour de l’axe y est appelée lacet. La rotation autour de l’axe x est appelée tangage ou pas. La rotation autour de l’axe z est appelée roulis.</p> 
    
    <p>L’ordre des transformations a son importance. Une rotation suivie d’une transformation de translation n’a pas le même effet qu’une translation suivie d’une transformation de rotation.</p>
    
    <p>L’effet de la rotation n’est pas absolu. Il est relatif à la position et à l’orientation actuelles. Pour apporter une modification absolue à la matrice de transformation, utilisez la méthode <codeph>recompose()</codeph>. La méthode <codeph>appendRotation()</codeph> diffère également de la propriété rotation de l’axe de l’objet d’affichage, telle que la propriété <codeph>rotationX</codeph>. La propriété rotation est toujours exécutée avant toute translation, puisque la méthode <codeph>appendRotation()</codeph> est exécutée par rapport à tout élément déjà présent dans la matrice. Pour être certain d’obtenir un effet similaire à la propriété rotation de l’axe de l’objet d’affichage, utilisez la méthode <codeph>prependRotation()</codeph>, qui exécute la rotation avant les autres transformations dans la matrice.</p>
    
    <p>Lorsque la transformation de la méthode <codeph>appendRotation()</codeph> est appliquée à un objet Matrix3D d’un objet d’affichage, les valeurs mises en cache de la propriété rotation de l’objet d’affichage sont invalidées.</p> 
    
    <p>Pour qu’un objet d’affichage pivote autour d’un point spécifique par rapport à son emplacement, une méthode consiste à définir la translation de l’objet sur le point spécifié, à faire pivoter l’objet avec la méthode <codeph>appendRotation()</codeph> et à lui appliquer une translation pour le ramener dans sa position d’origine. Dans l’exemple suivant, l’objet d’affichage 3D <codeph>myObject</codeph> effectue une rotation sur l’axe y autour de la coordonnée (10,10,0).</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.appendTranslation(10,10,0);
    myObject.transform.matrix3D.appendRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.appendTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependRotation()"><linktext>prependRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendScale"><apiName>appendScale</apiName><shortdesc>
    Ajoute un changement d’échelle incrémentiel le long des axes x, y et z à la fin d’un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet le long de l’axe x.
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet le long de l’axe y.
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet le long de l’axe z.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute un changement d’échelle incrémentiel le long des axes x, y et z à la fin d’un objet Matrix3D. Lorsque l’objet Matrix3D est appliqué à un objet d’affichage, la matrice exécute les changements d’échelle après les autres transformations dans l’objet Matrix3D. Le facteur d’échelle par défaut est (1.0, 1.0, 1.0).
    
    <p>L’échelle est définie comme un ensemble de trois modifications incrémentielles le long des trois axes (x,y,z). Vous pouvez multiplier chaque axe par un nombre différent. Lorsque des modifications d’échelle sont appliquées à un objet d’affichage, la taille de l’objet augmente ou diminue. Par exemple, définir les axes x, y et z sur deux double la taille de l’objet, alors que définir les axes sur <codeph>0.5</codeph> réduit la taille de moitié. Pour être certain que la transformation d’échelle n’affecte qu’un axe spécifique, définissez les autres paramètres sur un. Un paramètre de un signifie qu’aucune modification d’échelle n’est apportée le long de l’axe spécifique.</p>
    
    <p>La méthode <codeph>appendScale()</codeph> peut être utilisée pour le redimensionnement mais aussi pour la gestion des distorsions, par exemple pour étirer ou rétrécir un objet d’affichage, ou pour faire un zoom avant ou arrière sur un emplacement. Les transformations d’échelle sont exécutées automatiquement pendant la rotation et la translation d’un objet d’affichage.</p>
    
    <p>L’ordre des transformations a son importance. Un redimensionnement suivi d’une transformation de translation n’a pas le même effet qu’une translation suivie d’une transformation de redimensionnement.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependScale()"><linktext>prependScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendTranslation"><apiName>appendTranslation</apiName><shortdesc>
    Ajoute une translation incrémentielle, repositionnement le long des axes x, y et z, à la fin d’un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Translation incrémentielle le long de l’axe x.
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Translation incrémentielle le long de l’axe y.
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Translation incrémentielle le long de l’axe z.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute une translation incrémentielle, repositionnement le long des axes x, y et z, à la fin d’un objet Matrix3D. Lorsque l’objet Matrix3D est appliqué à un objet d’affichage, la matrice effectue les modifications de translation après les autres transformations dans l’objet Matrix3D.
    
    <p>La translation est définie comme un ensemble de trois modifications incrémentielles le long des trois axes (x,y,z). Lorsque la transformation est appliquée à un objet d’affichage, celui-ci se déplace de son point d’origine le long des axes x, y et z, tel que spécifié par les paramètres. Pour être certain que la translation n’affecte qu’un axe spécifique, définissez les autres paramètres sur zéro. Un paramètre de valeur zéro signifie qu’aucune modification n’a lieu le long de l’axe spécifique.</p> 
    
    <p>Les modifications de translation ne sont pas absolues. Elles sont relatives à la position et à l’orientation actuelles de la matrice. Pour apporter une modification absolue à la matrice de transformation, utilisez la méthode <codeph>recompose()</codeph>. L’ordre des transformations a aussi son importance. Une translation suivie d’une transformation de rotation n’a pas le même effet qu’une rotation suivie d’une translation.</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependTranslation()"><linktext>prependTranslation()</linktext></link><link href="flash.geom.xml#Matrix3D/position"><linktext>position</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:clone"><apiName>clone</apiName><shortdesc>
    Renvoie un nouvel objet Matrix3D qui est une copie exacte de l’objet Matrix3D actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet Matrix3D qui est une copie exacte de l’objet Matrix3D actuel.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Renvoie un nouvel objet Matrix3D qui est une copie exacte de l’objet Matrix3D actuel.      
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:decompose"><apiName>decompose</apiName><shortdesc>
    Renvoie les paramètres de translation, de rotation et d’échelle de la matrice de transformation, sous forme de vecteur de trois objets Vector3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Vecteur de trois objets Vector3D, contenant chacun les paramètres de translation, de rotation et de mise à l’échelle, respectivement. 
    
    </apiDesc><apiType value="Vector$flash.geom:Vector3D"/></apiReturn><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>Paramètre facultatif qui détermine le style d’orientation utilisé pour la transformation de la matrice. Les trois types de style d’orientation sont <codeph>eulerAngles</codeph> (<codeph>EULER_ANGLES</codeph> constants), <codeph>axisAngle</codeph> (<codeph>AXIS_ANGLE</codeph> constant) et <codeph>quaternion</codeph> (<codeph>QUATERNION</codeph> constant). Pour plus d’informations sur les différents styles d’orientation, voir la classe <codeph>geom.Orientation3D</codeph>.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Renvoie les paramètres de translation, de rotation et d’échelle de la matrice de transformation, sous forme de vecteur de trois objets Vector3D. Le premier objet Vector3D détient les éléments de translation. Le deuxième objet Vector3D détient les éléments de rotation. Le troisième objet Vector3D détient les éléments d’échelle. 
    
    <p>Certaines méthodes Matrix3D, par exemple <codeph>interpolateTo()</codeph>, décomposent et recomposent automatiquement la matrice pour effectuer leur transformation.</p> 
       
    <p>Pour modifier la transformation de la matrice avec une image de référence de parent absolu, récupérez les paramètres avec la méthode <codeph>decompose()</codeph> et apportez les modifications appropriées. Vous pouvez alors définir l’objet Matrix3D sur la transformation modifiée à l’aide de la méthode <codeph>recompose()</codeph>.</p>
    
    <p>Le paramètre de la méthode <codeph>decompose()</codeph> définit le style d’orientation à utiliser pour la transformation. L’orientation par défaut est <codeph>eulerAngles</codeph>, qui définit l’orientation avec trois angles de rotation distincts pour chaque axe. Les rotations s’effectuent consécutivement et ne modifient pas l’axe des autres rotations. Les propriétés de rotation de l’axe de l’objet d’affichage effectuent une transformation de style d’orientation Angles d’Euler. Les autres options de style d’orientation sont <codeph>axisAngle</codeph> et <codeph>quaternion</codeph>. L’orientation Angle des axes utilise une combinaison d’un axe et d’un angle pour déterminer l’orientation. L’axe autour duquel l’objet pivote est un vecteur unitaire qui représente une direction. L’angle représente l’amplitude de la rotation autour du vecteur. La direction détermine également l’endroit qui fait face à l’objet d’affichage et l’angle détermine la direction du haut. Les méthodes <codeph>appendRotation()</codeph> et <codeph>prependRotation()</codeph> utilisent l’orientation Angle des axes. L’orientation quaternion utilise des nombres complexes et le quatrième élément d’un vecteur. Les trois axes de rotation (x,y,z) et un angle de rotation (w) représentent l’orientation. La méthode <codeph>interpolate()</codeph> utilise l’orientation quaternion.</p> 
    
    </apiDesc><example conref="examples\Matrix3DdecomposeExample.as"> Cet exemple utilise les méthodes <codeph>decompose()</codeph> et <codeph>recompose()</codeph> pour étirer horizontalement une ellipse lorsqu’elle va vers le point de fuite. Le premier objet Vector3D renvoyé par la méthode <codeph>decompose()</codeph> contient les coordonnées de translation. Le troisième objet Vector3D détient les paramètres d’échelle. La méthode <codeph>incrementBy()</codeph> de l’objet Vector3D incrémente les paramètres d’échelle et la translation absolue de la matrice.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.Event;
    
    public class Matrix3DdecomposeExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DdecomposeExample():void {
            
            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight - 40);
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 50, 40);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function enterFrameHandler(e:Event):void {  

            var v3:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(3);
            v3 = ellipse.transform.matrix3D.decompose();
            v3[0].incrementBy(new Vector3D(0,0,1));
            v3[2].incrementBy(new Vector3D(0.01,0,0));
            ellipse.transform.matrix3D.recompose(v3);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>recompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:deltaTransformVector"><apiName>deltaTransformVector</apiName><shortdesc>
    Utilise une matrice de transformation sans ses éléments de translation pour transformer un objet Vector3D d’une coordonnée spatiale en une autre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Vector3D avec les coordonnées transformées.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D contenant les coordonnées à transformer.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Utilise une matrice de transformation sans ses éléments de translation pour transformer un objet Vector3D d’une coordonnée spatiale en une autre. L’objet Vector3D renvoyé contient les nouvelles coordonnées après que les transformations de rotation et de mise à l’échelle aient été appliquées. Si la méthode <codeph>deltaTransformVector()</codeph> applique une matrice qui ne contient qu’une transformation de translation, l’objet Vector3D renvoyé correspond à l’objet Vector3D d’origine.
    
    <p>Vous pouvez utiliser la méthode <codeph>deltaTransformVector()</codeph> pour qu’un objet d’affichage d’un espace de coordonnées réponde à la transformation de rotation d’un deuxième objet d’affichage. L’objet ne copie pas la rotation, mais modifie sa position pour refléter les modifications de la rotation. Par exemple pour utiliser l’API <codeph>display.Graphics</codeph> en vue de dessiner un objet 3D en rotation, vous devez mapper les coordonnées de rotation de cet objet sur un point 2D. A l’aide de la méthode <codeph>deltaTransformVector()</codeph>, récupérez tout d’abord les coordonnées 3D de l’objet après chaque rotation. Ensuite, appliquez la méthode <codeph>local3DToGlobal()</codeph> de l’objet d’affichage pour convertir les coordonnées 3D en points 2D. Vous pouvez alors utiliser les points 2D pour dessiner l’objet 3D en rotation.</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:identity"><apiName>identity</apiName><shortdesc>
    Convertit la matrice actuelle en matrice d’identité ou unitaire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Convertit la matrice actuelle en matrice d’identité ou unitaire. Une matrice d’identité a une valeur de un pour les éléments situés sur la diagonale principale et une valeur de zéro pour tous les autres éléments. Le résultat est une matrice dont la valeur <codeph>rawData</codeph> est <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph> et le paramètre de rotation est défini sur <codeph>Vector3D(0,0,0)</codeph>, le paramètre de position ou de translation est défini sur <codeph>Vector3D(0,0,0)</codeph> et l’échelle est définie sur <codeph>Vector3D(1,1,1)</codeph>. Voici une représentation de matrice d’identité.
    
    <p><adobeimage alt="Matrice d’identité" href="../../images/identityMatrix.jpg"/></p>
    
    <p>Un objet transformé par l’application d’une matrice d’identité n’effectue aucune transformation. En d’autres termes, lorsqu’une matrice est multipliée par une matrice d’identité, le résultat est une matrice identique à la matrice d’origine.</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolate"><apiName>interpolate</apiName><shortdesc>
    Simplifie l’interpolation entre une image de référence et une autre, en interpolant un objet d’affichage un pour cent plus près d’un objet d’affichage cible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Objet Matrix3D avec des éléments qui placent les valeurs de la matrice entre la matrice d’origine et la matrice cible. Lorsque la matrice renvoyée est appliquée à l’objet d’affichage <codeph>this</codeph>, l’objet se rapproche de l’objet cible en fonction du pourcentage spécifié.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>thisMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Objet Matrix3D qui doit être interpolé.
    </apiDesc></apiParam><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Objet Matrix3D cible.
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur comprise entre <codeph>0</codeph> et <codeph>1</codeph> qui détermine le pourcentage d’interpolation de l’objet Matrix3D <codeph>thisMat</codeph> vers l’objet Matrix3D cible.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Interpole un objet d’affichage un pour cent plus près d’un objet d’affichage cible.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Simplifie l’interpolation entre une image de référence et une autre, en interpolant un objet d’affichage un pour cent plus près d’un objet d’affichage cible. Le résultat est un nouvel objet Matrix3D dans tous les éléments de translation, de rotation et d’échelle sont interpolés sur des valeurs comprises entre les objets d’affichage actuel et cible.
    
    <p>La méthode <codeph>interpolate()</codeph> évite certains des résultats non désirés pouvant survenir avec l’utilisation de méthodes telles que les propriétés de rotation de l’axe de l’objet d’affichage. La méthode <codeph>interpolate()</codeph> invalide la valeur mise en cache de la propriété rotation de l’objet d’affichage et convertit les éléments de rotation de la matrice de l’objet d’affichage en quaternion avant l’interpolation. Un quaternion garantit le chemin le plus efficace et le plus court pour la rotation. Il permet également d’obtenir une rotation sans gimbal lock. Un gimbal lock peut se produire lorsque les angles d’Euler sont utilisés et que chaque axe est traité indépendamment. Lors d’une rotation autour de plusieurs axes, les axes peuvent s’aligner et entraîner des résultats inattendus. La rotation quaternion permet d’éviter le gimbal lock.</p> 
    
    <p>Les prochains appels à la méthode <codeph>interpolate()</codeph> peuvent produire un effet tel qu’un objet d’affichage démarrant rapidement, puis s’approchant lentement d’un autre objet d’affichage. Par exemple, si vous définissez le paramètre <codeph>thisMat</codeph> sur l’objet Matrix3D renvoyé, le paramètre <codeph>toMat</codeph> sur l’objet Matrix3D associé de l’objet d’affichage cible et le paramètre <codeph>percent</codeph> sur <codeph>0.1</codeph>, l’objet d’affichage se déplace de dix pour-cent vers l’objet cible. Lors des prochains appels ou dans les images suivantes, l’objet parcourt dix pour cent des 90 pour cent restants, dix pour cent des 80 pour cent restants, jusqu’à atteindre la cible.</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>interpolateTo()</linktext></link><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolateTo"><apiName>interpolateTo</apiName><shortdesc>
    Interpole la matrice de l’objet d’affichage un pour cent plus près de la matrice de la cible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Objet Matrix3D cible.  
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur comprise entre <codeph>0</codeph> et <codeph>1</codeph> qui détermine l’emplacement de l’objet d’affichage par rapport à la cible. Plus la valeur est proche de <codeph>1.0</codeph>, plus l’objet d’affichage est proche de sa position actuelle. Plus la valeur est proche de <codeph>0</codeph>, plus l’objet d’affichage est proche de la cible.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Interpole la matrice de l’objet d’affichage un pour cent plus près de la matrice de la cible. Tous les éléments de translation, de rotation et d’échelle de l’objet d’affichage sont interpolés sur des valeurs comprises entre la matrice des objets d’affichage actuel et cible. 
    
    <p>La méthode <codeph>interpolateTo()</codeph> permet d’éviter des résultats non désirés pouvant survenir lors de l’utilisation de méthodes telles que les propriétés de rotation de l’axe de l’objet d’affichage. La méthode <codeph>interpolateTo()</codeph> invalide la valeur mise en cache de la propriété rotation de l’objet d’affichage et convertit les éléments d’orientation de la matrice de l’objet d’affichage en quaternion avant l’interpolation. Un quaternion garantit le chemin le plus efficace et le plus court pour la rotation. Il permet également d’obtenir une rotation sans gimbal lock. Un gimbal lock peut se produire lorsque les angles d’Euler sont utilisés et que chaque axe est traité indépendamment. Lors d’une rotation autour de plusieurs axes, les axes peuvent s’aligner et entraîner des résultats inattendus. La rotation quaternion permet d’éviter le gimbal lock.</p> 
    
    <p>Les prochains appels à la méthode <codeph>interpolateTo()</codeph> peuvent produire un effet tel qu’un objet d’affichage démarrant rapidement, puis s’approchant lentement d’un autre objet d’affichage. Par exemple, si le paramètre percent est défini sur <codeph>0.1</codeph>, l’objet d’affichage se déplace de 10 % vers l’objet cible spécifié par le paramètre <codeph>toMat</codeph>. Lors des prochains appels ou dans les images suivantes, l’objet parcourt dix pour cent des 90 pour cent restants, dix pour cent des 80 pour cent restants, jusqu’à atteindre la cible.</p>  
    
    </apiDesc><example conref="examples\InterpolateToExample.as"> Dans cet exemple, un objet d’affichage tridimensionnel nommé <codeph>ellipse2</codeph> s’avance vers <codeph>ellipse1</codeph>, un autre objet d’affichage tridimensionnel. <codeph>ellipse2</codeph> suit <codeph>ellipse1</codeph> en essayant de l’attraper. Si <codeph>ellipse1</codeph> ne pivote pas autour de son axe y, <codeph>ellipse2</codeph> va atteindre et se poser sur <codeph>ellipse1</codeph>. Les deux ellipses sont dessinées de la même façon mais sont placées dans différents espaces monde tridimensionnels. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class InterpolateToExample extends MovieClip {
        private var ellipse1:Shape = new Shape();
        private var ellipse2:Shape = new Shape();

        public function InterpolateToExample():void {

            ellipse1 = myEllipses(250, 100, 500, 0xFF0000);
            addChild(ellipse1);
            
            ellipse2 = myEllipses(-30, 120, 1, 0x00FF00);
            addChild(ellipse2);

            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function myEllipses(x:Number, y:Number, z:Number, c:Number):Shape {
            var s:Shape = new Shape();                            
            s.x = x;
            s.y = y;
            s.z = z;
            s.graphics.beginFill(c);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(100, 50, 100, 80);
            s.graphics.endFill();
            return s;
        }

        private function enterFrameHandler(e:Event) {
            ellipse1.rotationY += 1;

            ellipse2.transform.matrix3D.interpolateTo(ellipse1.transform.matrix3D, 0.1);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:invert"><apiName>invert</apiName><shortdesc>
    Inverse la matrice actuelle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si la matrice a bien été inversée. 
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Inverse la matrice actuelle. Une matrice inversée a la même taille que l’originale mais effectue la transformation opposée à la matrice originale. Par exemple, si un objet de la matrice d’origine pivote autour de l’axe x dans une direction, l’objet de la matrice inverse pivote autour de l’axe dans la direction opposée. L’application d’une matrice inversée à un objet annule la transformation effectuée par la matrice d’origine. Lorsqu’une matrice est multipliée par sa matrice inverse, le résultat est une matrice d’identité. 
    
    <p>L’inverse d’une matrice peut être utilisé pour diviser une matrice par une autre. Une manière de diviser une matrice A par une matrice B consiste à multiplier la matrice A par l’inverse de la matrice B. La matrice inverse peut également être utilisée avec un espace de caméra. Lorsque la caméra se déplace dans l’espace monde, l’objet présent dans le monde doit se déplacer dans le sens opposé pour passer de l’espace monde à l’espace de la caméra ou à l’espace visuel. Par exemple, si la caméra se rapproche, les objets deviennent plus gros. En d’autres termes, si la caméra se déplace vers le bas de l’axe z du monde, l’objet se déplace vers le haut de ce même axe.</p> 
    
    <p>La méthode <codeph>invert()</codeph> remplace la matrice actuelle par une matrice inversée. Pour inverser une matrice sans modifier la matrice actuelle, commencez par copier la matrice actuelle à l’aide de la méthode <codeph>clone()</codeph>, puis appliquez la méthode <codeph>invert()</codeph> à la copie.</p>
    
    <p>L’objet Matrix3D doit être réversible.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/determinant"><linktext>determinant</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:pointAt"><apiName>pointAt</apiName><shortdesc>
    Fait pivoter l’objet d’affichage de sorte qu’il fasse face à une position spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Position par rapport au monde de l’objet cible. Le terme « par rapport au monde » définit la transformation de l’objet par rapport aux coordonnées et à l’espace monde dans lequel tous les objets sont positionnés.
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Vecteur relatif à l’objet qui définit l’endroit vers lequel pointe l’objet d’affichage. Le terme « relatif à l’objet » définit la transformation de l’objet par rapport à l’espace de l’objet, c’est-à-dire sa propre image de référence et son propre système de coordonnées. La valeur par défaut est l’axe <i>-z</i> (0,0,-1).
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Vecteur relatif à l’objet qui définit « up » pour l’objet d’affichage. Si l’objet est dessiné regardant vers le bas, l’axe <i>+z</i> est son vecteur « up ». Le terme « relatif à l’objet » définit la transformation de l’objet par rapport à l’espace de l’objet, c’est-à-dire sa propre image de référence et son propre système de coordonnées. La valeur par défaut est l’axe <i>-y</i> (0,-1,0).
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Fait pivoter l’objet d’affichage de sorte qu’il fasse face à une position spécifiée. Cette méthode autorise une modification en place de l’orientation. Le vecteur de direction vers l’avant de l’objet d’affichage (objet Vector3D <codeph>at</codeph>) pointe vers la position relative au monde spécifiée. La direction vers le haut de l’objet d’affichage est spécifiée par l’objet Vector3D <codeph>up</codeph>. 
    
    <p>La méthode <codeph>pointAt()</codeph> invalide la valeur mise en cache de la propriété rotation de l’objet d’affichage. La méthode décompose la matrice de l’objet d’affichage et modifie les éléments de rotation pour que l’objet tourne vers la position spécifiée. Elle recompose ensuite (met à jour) la matrice de l’objet d’affichage, qui effectue la transformation. Si l’objet pointe vers une cible en mouvement, par exemple vers la position d’un objet en mouvement, à chaque appel suivant, la méthode fait pivoter l’objet vers la cible en mouvement.</p>
    
    </apiDesc><example conref="examples\PointAtExample.as"> Dans cet exemple, un triangle pointe et suit la trajectoire du mouvement de l’ellipse. L’ellipse et le triangle sont définis sur des emplacements différents. L’ellipse se déplace ensuite vers le haut et le coin de la scène. Le triangle suit les modifications de translation de l’ellipse. Vous pouvez modifier la forme du triangle et les paramètres « at » et « up » de <codeph>pointAt()</codeph> pour observer leur impact sur le mouvement du triangle.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class PointAtExample extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var triangle:Shape = new Shape();

        public function PointAtExample():void {
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(30, 40, 50, 40);
            ellipse.graphics.endFill();
            ellipse.x = 100;
            ellipse.y = 150;
            ellipse.z = 1;

            triangle.graphics.beginFill(0x0000FF);
            triangle.graphics.moveTo(0, 0);
            triangle.graphics.lineTo(40, 40);
            triangle.graphics.lineTo(80, 0);
            triangle.graphics.lineTo(0, 0);
            triangle.graphics.endFill();
            triangle.x = 200;
            triangle.y = 50;
            triangle.z = 1;

            addChild(ellipse);
            addChild(triangle);

            ellipse.addEventListener(Event.ENTER_FRAME, ellipseEnterFrameHandler);
            triangle.addEventListener(Event.ENTER_FRAME, triangleEnterFrameHandler);
        }

        private function ellipseEnterFrameHandler(e:Event) {
            if(e.target.y > 0) {
                e.target.y -= 1;
                e.target.x -= 1;
            }
        }
        
        private function triangleEnterFrameHandler(e:Event) {
            e.target.transform.matrix3D.pointAt(ellipse.transform.matrix3D.position,
                                                Vector3D.X_AXIS, Vector3D.Y_AXIS);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prepend"><apiName>prepend</apiName><shortdesc>
    Ajoute une matrice au début en multipliant l’objet Matrix3D actuel par un autre objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>Côté droit de la matrice par laquelle l’objet Matrix3D actuel est multiplié.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute une matrice au début en multipliant l’objet Matrix3D actuel par un autre objet Matrix3D. Le résultat combine les deux transformations de matrice.  
    
    <p>Les multiplications de matrices diffèrent des additions de matrices. La multiplication de matrices n’est pas commutative. En d’autres termes, A fois B n’est pas égal à B fois A. Avec la méthode <codeph>prepend()</codeph>, la multiplication s’effectue à partir du côté droit, ce qui signifie que l’objet Matrix3D <codeph>rhs</codeph> est situé à droite de l’opérateur de la multiplication.</p>
    
    <codeph>thisMatrix = thisMatrix ~~ rhs</codeph>
      
    <p>Les modifications apportées par la méthode <codeph>prepend()</codeph> sont relatives à l’espace de l’objet. En d’autres termes, elles sont toujours relatives à l’image de référence initiale de l’objet.</p>
    
    <p>La méthode <codeph>prepend()</codeph> remplace la matrice actuelle par la matrice ajoutée. Si vous souhaitez ajouter deux matrices sans modifier la matrice actuelle, commencez par copier la matrice actuelle à l’aide de la méthode <codeph>clone()</codeph>, puis appliquez la méthode <codeph>prepend()</codeph> à la copie.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/append()"><linktext>append()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependRotation"><apiName>prependRotation</apiName><shortdesc>
    Ajoute une rotation incrémentielle au début d’un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Degré de rotation.
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Axe ou direction de la rotation. Les axes habituels sont <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) et <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>Point qui détermine le centre de rotation. Le point de pivot par défaut d’un objet est son point d’alignement.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute une rotation incrémentielle au début d’un objet Matrix3D. Lorsque l’objet Matrix3D est appliqué à un objet d’affichage, la matrice exécute la rotation avant les autres transformations dans l’objet Matrix3D. 
    
    <p>La rotation de l’objet d’affichage est définie par un axe, un degré incrémentiel de rotation autour de l’axe et un point de pivot facultatif pour le centre de la rotation de l’objet. L’axe peut être toute direction générale. Les axes courants sont <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>), <codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) et <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>). Dans la terminologie de l’aviation, la rotation autour de l’axe y est appelée lacet. La rotation autour de l’axe x est appelée tangage ou pas. La rotation autour de l’axe z est appelée roulis.</p> 
    
    <p>L’ordre des transformations a son importance. Une rotation suivie d’une transformation de translation n’a pas le même effet qu’une translation suivie d’une rotation.</p>
    
    <p>L’effet de la rotation n’est pas absolu. L’effet est relatif à l’objet, relatif à l’image de référence de la position et de l’orientation d’origine. Pour apporter une modification absolue à la transformation, utilisez la méthode <codeph>recompose()</codeph>.</p>
    
    <p>Lorsque la transformation de la méthode <codeph>prependRotation()</codeph> est appliquée à un objet Matrix3D, les valeurs mises en cache de la propriété rotation de l’objet d’affichage sont invalidées.</p> 
    
    <p>Pour qu’un objet d’affichage pivote autour d’un point spécifique par rapport à son emplacement, une méthode consiste à définir la translation de l’objet sur le point spécifié, à faire pivoter l’objet avec la méthode <codeph>prependRotation()</codeph> et à lui appliquer une translation pour le ramener dans sa position d’origine. Dans l’exemple suivant, l’objet d’affichage 3D <codeph>myObject</codeph> effectue une rotation sur l’axe y autour de la coordonnée (10,10,0).</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.prependTranslation(10,10,0);
    myObject.transform.matrix3D.prependRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.prependTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc><example conref="examples\Matrix3DprependRotationExample.as"> Dans cet exemple, l’utilisateur peut utiliser une souris pour faire pivoter une ellipse le long de ses axes <i>x</i> et <i>y</i>. L’ellipse est tracée avec son point d’alignement en son centre. Elle pivote autour de son axe <i>y</i> selon la coordonnée <i>x</i> de la souris. Elle pivote autour de son axe <i>x</i> selon la coordonnée <i>y</i> de la souris.
 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.MouseEvent;
    
    public class Matrix3DprependRotationExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DprependRotationExample():void {

            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(-50, -40, 100, 80);
            ellipse.graphics.endFill();

            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight / 2);
            ellipse.z = 1;
            
            addChild(ellipse);

            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function mouseMoveHandler(e:MouseEvent):void {
            var y:int;
            var x:int;
            
            if(e.localX > ellipse.x) {
                y = (Math.round(e.localX) / 100);   
            } else {
                y = -(Math.round(e.localX) / 10);   
            }
            
            if(e.localY > ellipse.y) {
                x = (Math.round(e.localY) / 100);
            } else {
                x = -(Math.round(e.localY) / 100);
            }
            
            ellipse.transform.matrix3D.prependRotation(y, Vector3D.Y_AXIS);
            ellipse.transform.matrix3D.prependRotation(x, Vector3D.X_AXIS);
        }
        
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendRotation()"><linktext>appendRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependScale"><apiName>prependScale</apiName><shortdesc>
    Ajoute une modification d’échelle incrémentielle le long des axes x, y et z au début d’un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet le long de l’axe x.
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet le long de l’axe y.
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet le long de l’axe z.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute une modification d’échelle incrémentielle le long des axes x, y et z au début d’un objet Matrix3D. Lorsque l’objet Matrix3D est appliqué à un objet d’affichage, la matrice exécute les changements d’échelle avant les autres transformations dans l’objet Matrix3D. Les changements sont relatifs à l’objet, relatifs à l’image de référence de la position et de l’orientation d’origine. Le facteur d’échelle par défaut est (1.0, 1.0, 1.0).
    
    <p>L’échelle est définie comme un ensemble de trois modifications incrémentielles le long des trois axes (x,y,z). Vous pouvez multiplier chaque axe par un nombre différent. Lorsque des modifications d’échelle sont appliquées à un objet d’affichage, la taille de l’objet augmente ou diminue. Par exemple, définir les axes x, y et z sur deux double la taille de l’objet, alors que définir les axes sur <codeph>0.5</codeph> réduit la taille de moitié. Pour être certain que la transformation d’échelle n’affecte qu’un axe spécifique, définissez les autres paramètres sur un. Un paramètre de un signifie qu’aucune modification d’échelle n’est apportée le long de l’axe spécifique.</p>
    
    <p>La méthode <codeph>prependScale()</codeph> peut être utilisée pour un redimensionnement mais aussi pour la gestion des distorsions, par exemple pour étirer ou compacter un objet d’affichage. Elle peut également être utilisée pour faire un zoom avant et arrière sur un emplacement. Les transformations d’échelle sont exécutées automatiquement pendant la rotation et la translation d’un objet d’affichage.</p>
    
    <p>L’ordre des transformations a son importance. Un redimensionnement suivi d’une transformation de translation n’a pas le même effet qu’une translation suivie d’une transformation de redimensionnement.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendScale()"><linktext>appendScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependTranslation"><apiName>prependTranslation</apiName><shortdesc>
    Ajoute une translation incrémentielle, repositionnement le long des axes x, y et z, au début d’un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Translation incrémentielle le long de l’axe x.
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Translation incrémentielle le long de l’axe y.
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Translation incrémentielle le long de l’axe z.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Ajoute une translation incrémentielle, repositionnement le long des axes x, y et z, au début d’un objet Matrix3D. Lorsque l’objet Matrix3D est appliqué à un objet d’affichage, la matrice exécute les modifications de translation avant les autres transformations dans l’objet Matrix3D. 
       
    <p>La translation définit la distance sur laquelle l’objet d’affichage se déplace, depuis son emplacement actuel le long des axes x, y et z. La méthode <codeph>prependTranslation()</codeph> définit la translation comme un ensemble de trois modifications incrémentielles le long des trois axes (x,y,z). Pour que la translation n’affecte qu’un axe spécifique, définissez les autres paramètres sur zéro. Un paramètre de valeur zéro signifie qu’aucune modification n’a lieu le long de l’axe spécifique.</p>
    
    <p>Les modifications de translation ne sont pas absolues. L’effet est relatif à l’objet, relatif à l’image de référence de la position et de l’orientation d’origine. Pour apporter une modification absolue à la matrice de transformation, utilisez la méthode <codeph>recompose()</codeph>. L’ordre des transformations a aussi son importance. Une translation suivie d’une transformation de rotation n’a pas le même effet qu’une rotation suivie d’une transformation de translation. Lorsque la méthode <codeph>prependTranslation()</codeph> est utilisée, l’objet d’affichage poursuit son déplacement dans la direction à laquelle il fait face, quelles que soient les autres transformations. Par exemple, si un objet d’affichage faisait face à l’axe x positif, il poursuit son déplacement dans le sens spécifié par la méthode <codeph>prependTranslation()</codeph>, quelle que soit la rotation ayant été appliquée à l’objet. Pour que les modifications de translation se produisent après les autres transformations, utilisez la méthode <codeph>appendTranslation()</codeph>.</p> 
    
    
    </apiDesc><example conref="examples\Matrix3DprependTranslationExample.as"> Dans cet exemple, l’utilisateur peut pousser une ellipse sur la scène le long de l’axe <i>y</i> avec une souris. Lorsque l’utilisateur survole l’ellipse avec sa souris, l’ellipse saute de dix coordonnées vers le haut de l’axe <i>y</i>. Lorsque la souris quitte l’ellipse, si celle-ci n’a pas atteint le bord supérieur, elle saute de nouveau de dix coordonnées vers le haut de l’axe <i>y</i>. Lorsque l’ellipse atteint le bord supérieur, elle est ramenée en bas de la scène.
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.geom.*;
    import flash.events.MouseEvent;

    public class Matrix3DprependTranslationExample extends MovieClip {
        private var ellipse:Sprite = new Sprite();

        public function Matrix3DprependTranslationExample():void {
            ellipse.x = this.stage.stageWidth / 2;
            ellipse.y = this.stage.stageHeight - 100;
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 60, 50);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
            ellipse.addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        }

        private function mouseOverHandler(e:MouseEvent):void {
            if(ellipse.y > 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } 
        }
        
        private function mouseOutHandler(e:MouseEvent):void {
            if(ellipse.y > 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } else {
                ellipse.transform.matrix3D.prependTranslation(0, 
                                     (this.stage.stageHeight - 100), 0);
            }   
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendTranslation()"><linktext>appendTranslation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:recompose"><apiName>recompose</apiName><shortdesc>
    Définit les paramètres de translation, de rotation et d’échelle de la matrice de transformation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Renvoie <codeph>false</codeph> si l’un des éléments d’échelle est égal à zéro.
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>components</apiItemName><apiType value="Vector$flash.geom:Vector3D"/><apiDesc>Vecteur de trois objets Vector3D qui remplace les éléments d’échelle, de translation et de rotation de l’objet Matrix3D. 
    
    </apiDesc></apiParam><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>Paramètre facultatif qui détermine le style d’orientation utilisé pour la transformation de la matrice. Les trois types de styles d’orientation sont <codeph>eulerAngles</codeph> (<codeph>EULER_ANGLES</codeph> constants), <codeph>axisAngle</codeph> (<codeph>AXIS_ANGLE</codeph> constant) et <codeph>quaternion</codeph> (<codeph>QUATERNION</codeph> constant). Pour plus d’informations sur les différents styles d’orientation, voir la classe <codeph>geom.Orientation3D</codeph>.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Définit les paramètres de translation, de rotation et d’échelle de la matrice de transformation. Contrairement aux modifications incrémentielles apportées par les propriétés de rotation de l’objet d’affichage ou les méthodes de rotation de l’objet Matrix3D, les modifications apportées par la méthode <codeph>recompose()</codeph> sont des modifications absolues. La méthode <codeph>recompose()</codeph> remplace la transformation de la matrice.
    
    <p>Pour modifier la transformation de la matrice avec une image de référence de parent absolu, récupérez les paramètres avec la méthode <codeph>decompose()</codeph> et apportez les modifications appropriées. Vous pouvez alors définir l’objet Matrix3D sur la transformation modifiée à l’aide de la méthode <codeph>recompose()</codeph>.</p>
    
    <p>Le paramètre de la méthode <codeph>recompose()</codeph> spécifie le style d’orientation utilisé pour la transformation. L’orientation par défaut est <codeph>eulerAngles</codeph>, qui définit l’orientation avec trois angles de rotation distincts pour chaque axe. Les rotations s’effectuent consécutivement et ne modifient pas l’axe des autres rotations. Les propriétés de rotation de l’axe de l’objet d’affichage effectuent une transformation de style d’orientation Angles d’Euler. Les autres options de style d’orientation sont <codeph>axisAngle</codeph> et <codeph>quaternion</codeph>. L’orientation Angle des axes détermine l’orientation en combinant un axe et un angle. L’axe autour duquel l’objet pivote est un vecteur unitaire qui représente une direction. L’angle représente l’amplitude de la rotation autour du vecteur. La direction détermine également l’endroit qui fait face à l’objet d’affichage et l’angle détermine la direction du haut. Les méthodes <codeph>appendRotation()</codeph> et <codeph>prependRotation()</codeph> utilisent l’orientation Angle des axes. L’orientation quaternion utilise des nombres complexes et le quatrième élément d’un vecteur. Une orientation est représentée par les trois axes de rotation (x,y,z) et un angle de rotation (w). La méthode <codeph>interpolate()</codeph> utilise l’orientation quaternion.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>decompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVector"><apiName>transformVector</apiName><shortdesc>
    Utilise la matrice de transformation pour transformer un objet Vector3D d’une coordonnée spatiale en une autre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Vector3D avec les coordonnées transformées.
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Objet Vector3D contenant les coordonnées à transformer.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Utilise la matrice de transformation pour transformer un objet Vector3D d’une coordonnée spatiale en une autre. L’objet Vector3D renvoyé contient les nouvelles coordonnées après transformation. Toutes les transformations matricielles, y compris la translation, s’appliquent à l’objet Vector3D.
    
    <p>Si le résultat de la méthode <codeph>transformVector()</codeph> a été appliqué à la position d’un objet d’affichage, seule la position de cet objet change. Les éléments de rotation et d’échelle de l’objet d’affichage demeurent les mêmes.</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVectors"><apiName>transformVectors</apiName><shortdesc>
    Utilise la matrice de transformation pour transformer un vecteur de nombres d’une coordonnée spatiale en une autre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vin</apiItemName><apiType value="Vector$Number"/><apiDesc>Vecteur de nombres, où chaque triplet de nombres est une coordonnée 3D (x,y,z) qui va être transformée.
    </apiDesc></apiParam><apiParam><apiItemName>vout</apiItemName><apiType value="Vector$Number"/><apiDesc>Vecteur de nombres, où chaque triplet de nombres est une coordonnée 3D transformée (x,y,z).
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Utilise la matrice de transformation pour transformer un vecteur de nombres d’une coordonnée spatiale en une autre. La méthode <codeph>tranformVectors()</codeph> lit chaque groupe de trois nombres dans l’objet Vector <codeph>vin</codeph> comme une coordonnée 3D (x,y,z) et place une coordonnée 3D transformée dans l’objet Vector <codeph>vout</codeph>. Toutes les transformations matricielles, y compris la translation, sont appliquées à l’objet Vector <codeph>vin</codeph>. Vous pouvez utiliser la méthode <codeph>transformVectors()</codeph> pour restituer et transformer un objet 3D en tant que maillage. Un maillage est un ensemble de sommets ou points qui définissent la forme de l’objet.
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transpose"><apiName>transpose</apiName><shortdesc>
    Convertit l’objet Matrix3D en cours en une matrice dont les lignes et les colonnes sont permutées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Convertit l’objet Matrix3D en cours en une matrice dont les lignes et les colonnes sont permutées. Par exemple, si le paramètre <codeph>rawData</codeph> de l’objet Matrix3D actuel contient les 16 nombres suivants, <codeph>1,2,3,4,11,12,13,14,21,22,23,24,31,32,33,34</codeph>, la méthode <codeph>transpose()</codeph> lit chaque ensemble de quatre éléments en tant que ligne et transforme ces lignes en colonnes. Le résultat est une matrice dont le paramètre <codeph>rawData</codeph> est : <codeph>1,11,21,31,2,12,22,32,3,13,23,33,4,14,24,34</codeph>. 
    
    <p>La méthode <codeph>transpose()</codeph> remplace la matrice actuelle par une matrice transposée. Pour transposer une matrice sans modifier la matrice actuelle, commencez par copier cette dernière à l’aide de la méthode <codeph>clone()</codeph>, puis appliquez la méthode <codeph>transpose()</codeph> à la copie.</p>
    
    <p>Une matrice orthogonale est une matrice carrée dont la transposition est égale à son inverse.</p> 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix3D:determinant:get"><apiName>determinant</apiName><shortdesc>
    Objet Number qui détermine si une matrice est réversible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
    Objet Number qui détermine si une matrice est réversible. 
    
    <p>Un objet Matrix3D doit être réversible. Pour être certain qu’un objet Matrix3D est réversible, vous pouvez utiliser la propriété <codeph>determinant</codeph>. Si la propriété determinant est zéro, il n’existe aucun inverse de la matrice. Par exemple, si une ligne ou une colonne entière d’une matrice est zéro ou si deux lignes ou deux colonnes sont égales, la propriété determinant est zéro. La propriété determinant permet également de résoudre une suite d’équations.</p> 
    
    <p>Seule une matrice carrée, telle que la classe Matrix3D, possède une propriété determinant.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/invert()"><linktext>invert()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:position:set"><apiName>position</apiName><shortdesc>
    Objet Vector3D contenant la position, les coordonnées 3D (x,y,z) d’un objet d’affichage dans l’image de référence de la transformation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    Objet Vector3D contenant la position, les coordonnées 3D (x,y,z) d’un objet d’affichage dans l’image de référence de la transformation. La propriété <codeph>position</codeph> permet d’accéder immédiatement au vecteur de translation de la matrice de l’objet d’affichage sans qu’il soit nécessaire de décomposer et de recomposer la matrice. 
    
    <p>La propriété <codeph>position</codeph> vous permet d’obtenir et de définir les éléments de translation de la matrice de transformation.</p>
    
    
    </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.geom.xml#position/appendTranslation()"><linktext>appendTranslation()</linktext></link><link href="" invalidHref="flash.geom.xml#position/prependTranslation()"><linktext>prependTranslation()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:rawData:get"><apiName>rawData</apiName><shortdesc>
    Vecteur de 16 nombres, dans lequel chaque groupe de quatre éléments peut être une ligne ou une colonne d’une matrice 4x4.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
    Vecteur de 16 nombres, dans lequel chaque groupe de quatre éléments peut être une ligne ou une colonne d’une matrice 4x4. 
    
    <p>Une exception est renvoyée si la propriété <codeph>rawData</codeph> est définie sur une matrice non réversible. L’objet Matrix3D doit être réversible. Si une matrice non réversible est nécessaire, créez une sous-classe de l’objet Matrix3D.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Transform"><apiName>Transform</apiName><shortdesc>
 La classe Transform permet d’accéder aux propriétés de réglage des couleurs et aux objets de transformation bi ou tridimensionnels pouvant s’appliquer à un objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Permet d’accéder aux couleurs, ainsi qu’aux matrices et aux objets de transformation bi et tridimensionnels pouvant s’appliquer à un objet d’affichage.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Transform permet d’accéder aux propriétés de réglage des couleurs et aux objets de transformation bi ou tridimensionnels pouvant s’appliquer à un objet d’affichage. Pendant la transformation, la couleur ou l’orientation et la position de l’objet d’affichage est ajustée (décalée) à partir des coordonnées ou des valeurs actuelles vers les nouvelles valeurs ou coordonnées. La classe Transform collecte également des données sur la couleur et les transformations de matrices bidimensionnelles appliquées à un objet d’affichage et à tous ses objets parent. Vous pouvez accéder à ces transformations combinées par le biais des propriétés <codeph>concatenatedColorTransform</codeph> et <codeph>concatenatedMatrix</codeph>.
 
 <p>Pour appliquer les transformations de couleur : créez un objet ColorTransform, définissez les réglages de couleur à l’aide des méthodes et des propriétés de l’objet, puis affectez la propriété <codeph>colorTransformation</codeph> de la propriété <codeph>transform</codeph> de l’objet d’affichage au nouvel objet ColorTransformation.</p>
 
 <p>Pour appliquer des transformations bidimensionnelles : créez un objet Matrix, définissez la transformation bidimensionnelle de la matrice, puis affectez la propriété <codeph>transform.matrix</codeph> de l’objet d’affichage au nouvel objet Matrix.</p>
 
 <p>Pour appliquer des transformations tridimensionnelles : partez d’un objet d’affichage tridimensionnel. Un objet d’affichage tridimensionnel a une propriété <codeph>z</codeph> dont la valeur est différente de zéro. Il n’est pas nécessaire de créer l’objet Matrix3D. Pour tous les objets tridimensionnels, un objet Matrix3D est créé automatiquement lorsque vous affectez une valeur <codeph>z</codeph> à un objet d’affichage. Vous pouvez accéder à l’objet Matrix3D de l’objet d’affichage par la propriété <codeph>transform</codeph> de l’objet d’affichage. A l’aide des méthodes de la classe Matrix3D, vous pouvez ajouter des paramètres de transformation ou modifier les existants. De même, vous pouvez créer un objet Matrix3D personnalisé, définir ses éléments de transformation, puis affecter le nouvel objet Matrix3D à l’objet d’affichage à l’aide de la propriété <codeph>transform.matrix</codeph>.</p>
 
 <p>Pour modifier la projection de la perspective de la scène ou de l’objet racine : utilisez la propriété <codeph>transform.matrix</codeph> de l’objet d’affichage racine pour accéder à l’objet PerspectiveProjection. Ou, appliquez différentes propriétés de projection de perspective à un objet d’affichage en définissant les propriétés de projection de perspective de son parent. L’objet d’affichage enfant hérite alors des nouvelles propriétés. Plus précisément, créez un objet PerspectiveProjection et définissez ses propriétés, puis affectez l’objet PerspectiveProjection à la propriété <codeph>perspectiveProjection</codeph> de la propriété <codeph>transform</codeph> de l’objet d’affichage parent. La transformation de projection spécifiée s’applique alors à tous les enfants tridimensionnels de l’objet d’affichage.</p>
 
 <p>Comme les objets PerspectiveProjection et Matrix3D transforment tous deux la perspective, ne les affectez pas ensemble à un objet d’affichage. Utilisez l’objet PerspectiveProjection pour les modifications de la longueur focale et du centre de projection. Pour contrôler encore davantage la transformation de la perspective, créez un objet de projection de perspective Matrix3D.</p>
 
 
 </apiDesc><example conref="examples\TransformExample.as"> L’exemple suivant utilise la classe TransformExample pour incliner le côté inférieur d’une icône animée (sprite) de forme carrée dont le remplissage est dégradé. Chaque fois que l’utilisateur clique sur le carré, l’application transforme l’icône animée en l’inclinant, en passant par les étapes suivantes :
 
 <ol>
  <li>Le constructeur <codeph>TransformExample()</codeph> crée un nouvel objet Sprite <codeph>target</codeph>.</li>
 
  <li>Le constructeur <codeph>TransformExample()</codeph> appelle la méthode <codeph>draw()</codeph> qui dessine un carré dégradé dans l’icône animée (sprite).</li>
 
  <li>Le constructeur <codeph>TransformExample()</codeph> ajoute un écouteur d’événement clic pour le sprite ; il est géré par le biais de la méthode <codeph>clickHandler()</codeph>. </li>
 
     <li>La méthode <codeph>clickHandler()</codeph> crée un objet Matrix, <codeph>skewMatrix</codeph>, qui est défini pour appliquer un effet d’inclinaison. Une autre matrice, <codeph>tempMatrix</codeph>, est attribuée à la matrice de transformation actuelle de l’icône animée, puis elle est combinée avec l’objet <codeph>skewMatrix</codeph> par le biais de la méthode <codeph>concat()</codeph>. Cette matrice est affectée à la propriété <codeph>transform.matrix</codeph> de l’icône animée carrée. Chaque fois que l’utilisateur clique sur le carré, l’appel de la méthode <codeph>clickHandler()</codeph> modifie la forme du carré en l’inclinant.  </li>
  <li>Par ailleurs, la méthode <codeph>clickHandler()</codeph> crée un objet ColorTransform. La propriété <codeph>redOffset</codeph> du nouvel objet ColorTransform est définie sur la valeur actuelle de redOffset et est incrémentée de 25. De même, la propriété <codeph>blueOffset</codeph> est réduite de 25. Les couleurs de l’icône animée changent à chaque clic. </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.Matrix;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class TransformExample extends Sprite {
        public function TransformExample() { 
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var skewMatrix:Matrix = new Matrix();
            skewMatrix.c = 0.25;
            var tempMatrix:Matrix = this.transform.matrix;
            tempMatrix.concat(skewMatrix);
            this.transform.matrix = tempMatrix;
            
            var rOffset:Number = this.transform.colorTransform.redOffset + 25;
            var bOffset:Number = this.transform.colorTransform.blueOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiOperation id="flash.geom:Transform:getRelativeMatrix3D"><apiName>getRelativeMatrix3D</apiName><shortdesc>
     Renvoie un objet Matrix3D, capable de transformer l’espace de l’objet d’affichage spécifié par rapport à l’espace de l’objet d’affichage actif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Matrix3D pouvant être utilisé pour transformer l’espace à partir de l’objet d’affichage <codeph>relativeTo</codeph> vers l’espace de l’objet d’affichage actif.
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>relativeTo</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Objet d’affichage par rapport auquel la transformation se produit. Pour obtenir un objet Matrix3D relatif à la scène, définissez le paramètre sur l’objet <codeph>root</codeph> ou <codeph>stage</codeph>. Pour obtenir une matrice relative au monde de l’objet d’affichage, définissez le paramètre sur un objet d’affichage auquel est appliquée une transformation de perspective.
         
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie un objet Matrix3D, capable de transformer l’espace de l’objet d’affichage spécifié par rapport à l’espace de l’objet d’affichage actif. Vous pouvez utiliser la méthode <codeph>getRelativeMatrix3D()</codeph> pour déplacer un objet d’affichage tridimensionnel par rapport à un autre. 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:Transform:colorTransform:get"><apiName>colorTransform</apiName><shortdesc>
     Objet ColorTransform contenant des valeurs qui règlent de façon universelle les couleurs de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the ColorTransform object <code>blueColorTransform</code> to 
    the Transform object <code>trans</code>.  This ColorTransform converts the color of the MovieClip 
    <code>rect</code> from red to blue.
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    
    var trans:Transform = new Transform(rect);
    trace(trans.colorTransform);          
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    trace(trans.colorTransform);          
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier><apiException><apiDesc>L’objet colorTransform prend la valeur null lors de sa définition.
     
    </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Objet ColorTransform contenant des valeurs qui règlent de façon universelle les couleurs de l’objet d’affichage.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedColorTransform:get"><apiName>concatenatedColorTransform</apiName><shortdesc>
     Objet ColorTransform représentant les transformations de couleur combinées qui s’appliquent à l’objet d’affichage et à l’ensemble de ses objets parent, jusqu’à la racine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to both a parent and child MovieClip.
    A <code>blueColorTransform</code> is then applied to the Transform object <code>parentTrans</code> which
    adjusts the color of both parent and child MovieClips towards blue.  Notice how <code>child.concatenatedColorTransform</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    
    trace(childTrans.concatenatedColorTransform);     
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    trace(childTrans.colorTransform);                 
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    trace(parentTrans.concatenatedColorTransform);    
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier></apiValueDef><apiDesc>
     Objet ColorTransform représentant les transformations de couleur combinées qui s’appliquent à l’objet d’affichage et à l’ensemble de ses objets parent, jusqu’à la racine. Si différentes transformations de couleur s’appliquent à différents niveaux, elles sont concaténées dans un objet ColorTransform unique pour cette propriété.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedMatrix:get"><apiName>concatenatedMatrix</apiName><shortdesc>
     Objet Matrix représentant les matrices de transformation combinées qui s’appliquent à l’objet d’affichage et à l’ensemble de ses objets parent, jusqu’à la racine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to a parent movie clip and to a child movie clip.
    A <code>scaleMatrix</code> is then applied to the Transform object <code>parentTrans</code> which
    scales both parent and child MovieClips.  Notice how <code>child.concatenatedMatrix</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.Matrix;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var scaleMatrix:Matrix = new Matrix();
    scaleMatrix.scale(2, 2);
    
    parentTrans.matrix = scaleMatrix;
    
    trace(childTrans.concatenatedMatrix);     // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(childTrans.matrix);                 // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(parentTrans.concatenatedMatrix);    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Objet Matrix représentant les matrices de transformation combinées qui s’appliquent à l’objet d’affichage et à l’ensemble de ses objets parent, jusqu’à la racine. Si différentes matrices de transformation s’appliquent à différents niveaux, elles sont concaténées en une seule matrice pour cette propriété. Par ailleurs, pour le contenu SWF redimensionnable exécuté dans le navigateur, cette propriété influe sur la différence entre les coordonnées de la scène et les coordonnées de la fenêtre à cause du redimensionnement de la fenêtre. Par conséquent, cette propriété convertit les coordonnées locales en coordonnées de fenêtre ; il est donc possible que l’espace de coordonnées ne soit pas le même que celui de la Scène.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Transform:matrix:get"><apiName>matrix</apiName><shortdesc>
     Objet Matrix contenant des valeurs qui influent sur le redimensionnement, la rotation et la translation de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the Matrix object <code>scaleMatrix</code> to the Transform
     object <code>trans</code>.  This Matrix scales the MovieClip <code>rect</code> by a factor of two.
     <listing version="2.0">
     import flash.geom.Transform;
     import flash.geom.Matrix;
     
     var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
     
     var trans:Transform = new Transform(rect);
     trace(trans.matrix);         // (a=1, b=0, c=0, d=1, tx=0, ty=0)
          
     var scaleMatrix:Matrix = new Matrix();
     scaleMatrix.scale(2, 2);
     
     trans.matrix = scaleMatrix;
     trace(trans.matrix);         // (a=2, b=0, c=0, d=2, tx=0, ty=0)
     
     function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
     }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier><apiException><apiDesc>La matrice prend la valeur null lors de sa définition.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Objet Matrix contenant des valeurs qui influent sur le redimensionnement, la rotation et la translation de l’objet d’affichage.
     
     <p>Si la propriété <codeph>matrix</codeph> est définie sur une valeur (sauf sur <codeph>null</codeph>), la propriété <codeph>matrix3D</codeph> est <codeph>null</codeph>. Et si la propriété <codeph>matrix3D</codeph> est définie sur une valeur (sauf sur <codeph>null</codeph>), la propriété <codeph>matrix</codeph> est <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:matrix3D:get"><apiName>matrix3D</apiName><shortdesc>
     Permet d’accéder à l’objet Matrix3D d’un objet d’affichage tridimensionnel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix3D</apiValueClassifier></apiValueDef><apiDesc>
     Permet d’accéder à l’objet Matrix3D d’un objet d’affichage tridimensionnel. L’objet Matrix3D représente une matrice de transformation qui détermine la position et l’orientation de l’objet d’affichage. Un objet Matrix3D peut également effectuer une projection de perspective.
     
     <p>Si la propriété <codeph>matrix</codeph> est définie sur une valeur (sauf sur <codeph>null</codeph>), la propriété <codeph>matrix3D</codeph> est <codeph>null</codeph>. Et si la propriété <codeph>matrix3D</codeph> est définie sur une valeur (sauf sur <codeph>null</codeph>), la propriété <codeph>matrix</codeph> est <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:perspectiveProjection:get"><apiName>perspectiveProjection</apiName><shortdesc>
     Permet d’accéder à l’objet PerspectiveProjection d’un objet d’affichage tridimensionnel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:PerspectiveProjection</apiValueClassifier></apiValueDef><apiDesc>
     Permet d’accéder à l’objet PerspectiveProjection d’un objet d’affichage tridimensionnel. L’objet PerspectiveProjection peut être utilisé pour modifier la transformation de perspective de la scène ou pour affecter une transformation de perspective à tous les enfants tridimensionnels d’un objet d’affichage.
     
     <p>A partir du champ de vision et des proportions (dimensions) de la scène, un objet PerspectiveProjection est affecté par défaut à l’objet racine.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:pixelBounds:get"><apiName>pixelBounds</apiName><shortdesc>
     Objet Rectangle qui définit le cadre de sélection de l’objet d’affichage sur la scène.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Transform object <code>trans</code> and traces out
    its <code>pixelBounds</code>.  Notice that pixel bounds returns a bounding box with values 
    equal to MovieClip's <code>getBounds()</code> and <code>getRect()</code> methods.
    <listing version="2.0">
    import flash.geom.Transform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var trans:Transform = new Transform(rect);
    trace(trans.pixelBounds);         // (x=0, y=0, w=20, h=80)
    
    var boundsObj:Object = rect.getBounds();
    trace(boundsObj.xMin);            // 0
    trace(boundsObj.yMin);            // 0
    trace(boundsObj.xMax);            // 20
    trace(boundsObj.yMax);            // 80
    
    var rectObj:Object = rect.getRect();
    trace(rectObj.xMin);              // 0
    trace(rectObj.yMin);              // 0
    trace(rectObj.xMax);              // 20
    trace(rectObj.yMax);              // 80
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     Objet Rectangle qui définit le cadre de sélection de l’objet d’affichage sur la scène.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix"><apiName>Matrix</apiName><shortdesc>
 La classe Matrix représente une matrice de transformation qui détermine le mappage des points d’un espace de coordonnées à l’autre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Classe Matrix homogène à deux dimensions standard.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Matrix représente une matrice de transformation qui détermine le mappage des points d’un espace de coordonnées à l’autre. Pour appliquer diverses transformations graphiques à un objet d’affichage, vous pouvez définir les propriétés d’un objet Matrix, puis appliquer cet objet à la propriété <codeph>matrix</codeph> d’un objet Transform que vous appliquez ensuite comme propriété <codeph>transform</codeph> de l’objet d’affichage. Ces fonctions de transformation incluent la translation (repositionnement de <i>x</i> et <i>y</i>), la rotation, le redimensionnement et l’inclinaison. 
 
 <p>Associés, ces types de transformations sont connus sous le nom de <i>transformations affines</i>. Les transformations affines préservent la rectitude des lignes au cours de la transformation, de sorte que les lignes parallèles restent parallèles.</p>
 
 <p>Pour appliquer une matrice de transformation à un objet d’affichage, vous créez un objet Transform, réglez sa propriété <codeph>matrix</codeph> sur la matrice de transformation, puis réglez la propriété <codeph>transform</codeph> de l’objet d’affichage sur l’objet Transform. Les objets Matrix peuvent également être utilisés comme paramètres de certaines méthodes, indiquées ci-dessous :</p>
 
 <ul>
 
 <li>la méthode <codeph>draw()</codeph> d’un objet BitmapData ;</li>
 
 <li>les méthodes <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> ou <codeph>lineGradientStyle()</codeph> d’un objet Graphics.</li>
 
 </ul>
 
 <p>Un objet de matrice de transformation est considéré comme étant une matrice 3 x 3 comprenant le contenu suivant :</p>
 
 <p><adobeimage alt="Des propriétés de la classe Matrix dans la notation des matrices" href="../../images/matrix_props1.jpg"/></p>
 
 <p>Dans le cas des matrices de transformation classiques, les propriétés <codeph>u</codeph>, <codeph>v</codeph> et <codeph>w</codeph> sont dotées de fonctionnalités supplémentaires. La classe Matrix fonctionne uniquement dans un espace bidimensionnel ; ainsi, elle suppose toujours que les valeurs des propriétés <codeph>u</codeph> et <codeph>v</codeph> sont 0,0, et que la valeur de la propriété <codeph>w</codeph> est 1,0. Les valeurs réelles de la matrice sont les suivantes :</p>
 
 <p><adobeimage alt="Les propriétés de la classe Matrix dans la notation des matrices montrant les valeurs supposées de u, v et w." href="../../images/matrix_props2.jpg"/></p>
 
 <p>Vous pouvez obtenir et définir les valeurs des six autres propriétés d’un objet Matrix : <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph>, <codeph>d</codeph>, <codeph>tx</codeph> et <codeph>ty</codeph>.</p>
 
 <p>La classe Matrix prend en charge les quatre principaux types de transformations : translation, redimensionnement, rotation et inclinaison. Vous pouvez définir trois de ces transformations à l’aide de méthodes spécialisées, tel que décrit dans le tableau ci-dessous. </p>
 
 <adobetable class="innertable">
   
   
   
   
   
 <tgroup cols="5"><thead><row><entry>Transformation</entry><entry>Méthode</entry><entry>Valeurs de matrice</entry><entry>Résultat affiché</entry><entry>Description</entry></row></thead><tbody><row valign="top">
  <entry>Translation (déplacement)</entry>
  <entry outputclass="nowrap"><codeph>translate(tx, ty)</codeph> </entry>
  <entry><adobeimage alt="Notation des matrices des paramètres de la méthode translate" height="104" href="../../images/matrix_translate.jpg" width="150"/></entry>
  <entry><adobeimage alt="Illustration des effets de la méthode translate" height="91" href="../../images/matrix_translate_image.jpg" width="111"/></entry>
  <entry>Déplace les pixels <codeph>tx</codeph> de l’image vers la droite, et les pixels <codeph>ty</codeph> vers le bas.</entry>
   </row><row valign="top">
  <entry>Redimensionnement</entry>
  <entry><codeph>scale(sx, sy)</codeph></entry>
  <entry><adobeimage alt="Notation des matrices des paramètres de la méthode scale" height="105" href="../../images/matrix_scale.jpg" width="140"/></entry>
  <entry><adobeimage alt="Illustration des effets de la méthode scale" height="84" href="../../images/matrix_scale_image.jpg" width="111"/></entry>
  <entry>Redimensionne l’image en multipliant l’emplacement de chaque pixel par <codeph>sx</codeph> sur l’axe <i>x</i> et par <codeph>sy</codeph> sur l’axe <i>y</i>.</entry>
   </row><row valign="top">
  <entry>Rotation</entry>
  <entry><codeph>rotate(q)</codeph></entry>
  <entry><adobeimage alt="Notation de matrices des propriétés de la méthode rotate" height="105" href="../../images/matrix_rotate.jpg" width="219"/></entry>
  <entry><adobeimage alt="Illustration des effets de la méthode rotate" height="91" href="../../images/matrix_rotate_image.jpg" width="111"/></entry>
  <entry>Fait pivoter l’image selon un angle <codeph>q</codeph>, mesuré en radians.</entry>
   </row><row valign="top">
  <entry>Inclinaison ou cisaillement </entry>
  <entry>Aucun ; il est nécessaire de définir les propriétés <codeph>b</codeph> et <codeph>c</codeph>.</entry>
  <entry><adobeimage alt="Notation de matrice des propriétés de la fonction skew" href="../../images/matrix_skew.jpg"/></entry>
  <entry><adobeimage alt="Illustration des effets de la fonction skew" height="77" href="../../images/matrix_skew_image.jpg" width="111"/></entry>
  <entry>Fait glisser l’image progressivement dans une direction parallèle à l’axe <i>x</i> ou <i>y</i>. La propriété <codeph>b</codeph> de l’objet Matrix représente la tangente de l’angle d’inclinaison sur l’axe <i>y</i>, sa propriété <codeph>c</codeph> la tangente de l’angle d’inclinaison sur l’axe <i>x</i>.</entry>
   </row></tbody></tgroup></adobetable>
 <p>Chaque fonction de transformation modifie les propriétés de matrice actuelles, ce qui vous permet d’associer plusieurs transformations. Pour ce faire, il vous suffit d’appeler plusieurs fonctions de transformation avant d’appliquer la matrice à son objet d’affichage cible (à l’aide de la propriété <codeph>transform</codeph> de celui-ci).</p>
 
 <p>Utilisez le constructeur <codeph>new Matrix()</codeph> pour créer un objet Matrix afin de pouvoir appeler les méthodes connexes.</p>
 
 </apiDesc><example conref="examples\MatrixExample.as"> L’exemple suivant exploite la classe <codeph>MatrixExample</codeph> pour montrer comment générer un carré de grande taille avec une zone de remplissage dégradée. Cette opération se déroule selon la procédure suivante :
 <ol>
     <li>L’application crée un nouvel objet Matrix <codeph>myMatrix</codeph> et utilise la méthode <codeph>trace()</codeph> pour produire les valeurs de propriété par défaut de l’objet <codeph>myMatrix</codeph>.</li>
     <li>L’application appelle <codeph>createGradientBox()</codeph> avec les paramètres <codeph>width</codeph> et <codeph>height</codeph> définis sur 200 pixels ; il n’y a pas de rotation et la distance à translater sur les axes <i>x</i> et <i>y</i> est définie sur 50 pixels.</li>
     <li>L’application imprime l’objet <codeph>myMatrix</codeph> une nouvelle fois pour signaler la modification après l’appel de <codeph>createGradientBox()</codeph>.</li>
     <li>L’application utilise trois variables pour contrôler le remplissage de la zone de dégradé :
     <ul>
         <li><codeph>colors</codeph> : définit les couleurs de dégradé allant du rouge au bleu unis.</li>
         <li><codeph>alphas</codeph> : définit l’opacité sur uni.</li>
         <li><codeph>ratios</codeph> : définit une répartition des couleurs égale pour le rouge et le bleu.</li>
  </ul></li>
     <li>L’application appelle la méthode Graphics <codeph>beginGradientFill()</codeph>, qui est active sur l’objet <codeph>myMatrix</codeph>, et la méthode <codeph>lineTo()</codeph>, qui se traduit par une zone de remplissage dégradée.</li>
 </ol>
<codeblock>
package {
    import flash.geom.Matrix;
    import flash.display.Sprite;
    import flash.display.GradientType;

    public class MatrixExample extends Sprite {

        public function MatrixExample() {
            var myMatrix:Matrix = new Matrix();
            trace(myMatrix.toString());    // (a=1, b=0, c=0, d=1, tx=0, ty=0)

            myMatrix.createGradientBox(200, 200, 0, 50, 50);
            trace(myMatrix.toString());    // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)

            var colors:Array = [0xFF0000, 0x0000FF];
            var alphas:Array = [1, 1];
            var ratios:Array = [0, 0xFF];
            graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
            graphics.lineTo(0, 300);
            graphics.lineTo(300, 300);
            graphics.lineTo(300, 0);
            graphics.lineTo(0, 0);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiConstructor id="flash.geom:Matrix:Matrix"><apiName>Matrix</apiName><shortdesc>
    Crée un objet Matrix avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
    
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Valeur qui affecte le positionnement des pixels sur l’axe <i>x</i> lors du redimensionnement ou de la rotation d’une image.
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur qui affecte le positionnement des pixels sur l’axe <i>y</i> lors de la rotation ou de l’inclinaison d’une image.
    </apiDesc></apiParam><apiParam><apiItemName>c</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur qui affecte le positionnement des pixels sur l’axe <i>x</i> lors de la rotation ou de l’inclinaison d’une image.
    </apiDesc></apiParam><apiParam><apiItemName>d</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Valeur qui affecte le positionnement des pixels sur l’axe <i>y</i> lors du redimensionnement ou de la rotation d’une image.
    </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Distance de translation de chaque point sur l’axe <i>x</i>.
    </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Distance de translation de chaque point sur l’axe <i>y</i>.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Crée un objet de Matrix bidimensionnel.
    
    </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
    Crée un objet Matrix avec les paramètres spécifiés. Dans la notation des matrices, les propriétés sont organisées comme suit :
    
    <p><adobeimage alt="Les propriétés de la classe Matrix dans la notation des matrices montrant les valeurs supposées de u, v et w." href="../../images/matrix_props2.jpg"/></p>
    
    <p>Si vous ne transmettez aucun paramètre au constructeur <codeph>new Matrix()</codeph>, celui-ci crée une <i>matrice d’identité</i> dotée des valeurs suivantes :</p>
    <adobetable class="innertable">
    
    
    
    <tgroup cols="2"><tbody><row>
      <entry><pre>a = 1</pre></entry>
      <entry><pre>b = 0</pre></entry>
    </row><row>
      <entry><pre>c = 0</pre></entry>
      <entry><pre>d = 1</pre></entry>
    </row><row>
      <entry><pre>tx = 0</pre></entry>
      <entry><pre>ty = 0</pre></entry>
    </row></tbody></tgroup></adobetable>
    <p>Dans la notation des matrices, la matrice d’identité a l’aspect suivant :</p>
    
    <p><adobeimage alt="Des propriétés de la classe Matrix dans la notation des matrices" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc><example conref="examples\Matrix.1.as"> L’exemple suivant crée <codeph>matrix_1</codeph> sans transmettre de paramètre au constructeur <codeph>Matrix()</codeph> et <codeph>matrix_2</codeph> en lui transmettant des paramètres. Remarquez que <codeph>matrix_1</codeph>, créé sans paramètres, forme une matrice d’identité dotée des valeurs <codeph>a</codeph>=1, <codeph>b</codeph>=0, <codeph>c</codeph>=0, <codeph>d</codeph>=1, <codeph>tx</codeph>=0, <codeph>ty</codeph>=0.
<codeblock>
import flash.geom.Matrix;

var matrix_1:Matrix = new Matrix();
trace(matrix_1);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)

var matrix_2:Matrix = new Matrix(1, 2, 3, 4, 5, 6);
trace(matrix_2);  // (a=1, b=2, c=3, d=4, tx=5, ty=6)
</codeblock></example></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Matrix:clone"><apiName>clone</apiName><shortdesc>
    Renvoie un nouvel objet Matrix, clone de cette matrice, avec une copie exacte de l’objet contenu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>clonedMatrix</code> from <code>myMatrix</code>.
    Notice that the Matrix class does not have an equals method, so the following example
    uses a custom written function to test the equality of two Matricies.
    
    <listing version="2.0">
    import flash.geom.Matrix;
       
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
    var clonedMatrix:Matrix = new Matrix();
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // false
    
    clonedMatrix = myMatrix.clone(); 
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // true
    
    function equals(m1:Matrix, m2:Matrix):Boolean {
        return m1.toString() == m2.toString();
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Matrix.
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie un nouvel objet Matrix, copie de la matrice actuelle.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Renvoie un nouvel objet Matrix, clone de cette matrice, avec une copie exacte de l’objet contenu.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:concat"><apiName>concat</apiName><shortdesc>
    Concatène une matrice et la matrice actuelle, ce qui a pour effet de combiner les effets géométriques des deux matrices.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three Matricies that define transformations for
    three rectangle MovieClips.  The first two Matricies <code>rotate45Matrix</code>
    and <code>doubleScaleMatrix</code> are applied to the two rectangles 
    <code>rectangleMc_1</code> and <code>rectangleMc_2</code>.  Then, the third
    Matrix is created using the <code>concat()</code> method on <code>rotate45Matrix</code> and 
    <code>doubleScaleMatrix</code> to create <code>scaleAndRotateMatrix</code>. 
    This Matrix is then applied to <code>rectangleMc_3</code> to scale and rotate it.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var rectangleMc_0:MovieClip = createRectangle(20, 80, 0x000000);
    var rectangleMc_1:MovieClip = createRectangle(20, 80, 0xFF0000);   
    var rectangleMc_2:MovieClip = createRectangle(20, 80, 0x00FF00);   
    var rectangleMc_3:MovieClip = createRectangle(20, 80, 0x0000FF);
    
    var rectangleTrans_1:Transform = new Transform(rectangleMc_1);
    var rectangleTrans_2:Transform = new Transform(rectangleMc_2);
    var rectangleTrans_3:Transform = new Transform(rectangleMc_3);
    
    var rotate45Matrix:Matrix = new Matrix();
    rotate45Matrix.rotate(Math.PI/4);
    rectangleTrans_1.matrix = rotate45Matrix;
    rectangleMc_1._x = 100;
    trace(rotate45Matrix.toString());    // (a=0.707106781186548, b=0.707106781186547, c=-0.707106781186547, d=0.707106781186548, tx=0, ty=0)
    
    var doubleScaleMatrix:Matrix = new Matrix();
    doubleScaleMatrix.scale(2, 2);
    rectangleTrans_2.matrix = doubleScaleMatrix;
    rectangleMc_2._x = 200;
    trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    var scaleAndRotateMatrix:Matrix = doubleScaleMatrix.clone();
    scaleAndRotateMatrix.concat(rotate45Matrix);
    rectangleTrans_3.matrix = scaleAndRotateMatrix;
    rectangleMc_3._x = 300;
    trace(scaleAndRotateMatrix.toString());   // (a=1.4142135623731, b=1.41421356237309, c=-1.41421356237309, d=1.4142135623731, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
        var depth:Number = this.getNextHighestDepth();
        var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
        mc.beginFill(color);
        mc.lineTo(0, height);
        mc.lineTo(width, height);
        mc.lineTo(width, 0);
        mc.lineTo(0, 0);
        return mc;
    }
    
    </listing>
    
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiDesc>Matrice à concaténer avec la matrice source.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Concatène une matrice et la matrice actuelle, ce qui a pour effet de combiner les effets géométriques des deux matrices. En termes mathématiques, la concaténation de deux matrices revient à les combiner par l’intermédiaire de la multiplication de matrices.
    
    <p>Par exemple, si la matrice <codeph>m1</codeph> redimensionne un objet en le multipliant par 4 et si la matrice <codeph>m2</codeph> fait pivoter un objet de 1,5707963267949 radians (<codeph>Math.PI/2</codeph>), alors <codeph>m1.concat(m2)</codeph> transforme <codeph>m1</codeph> en une matrice qui redimensionne un objet en le multipliant par 4 et le fait pivoter de <codeph>Math.PI/2</codeph> radians. </p>
    
    <p>Cette méthode permet de remplacer la matrice source par la matrice concaténée. Si vous souhaitez concaténer deux matrices sans modifier les deux matrices source, copiez d’abord la matrice source via la méthode <codeph>clone()</codeph>, comme indiqué dans la section relative aux exemples de la classe.</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:createBox"><apiName>createBox</apiName><shortdesc>
     Inclut les paramètres de redimensionnement, de rotation et de translation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Facteur à appliquer au redimensionnement horizontal. 
     
     </apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Facteur à appliquer au redimensionnement vertical. 
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur de rotation, en radians. 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre de pixels à translater (déplacer) vers la droite sur l’axe des <i>x</i>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre de pixels à translater (déplacer) vers le bas sur l’axe des <i>y</i>.  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Crée une matrice à l’aide de valeurs de redimensionnement, de rotation et de translation.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Inclut les paramètres de redimensionnement, de rotation et de translation. Lorsqu’elle est appliquée à une matrice, elle définit ses valeurs en fonction de ces paramètres.
     
     <p>L’utilisation de la méthode <codeph>createBox()</codeph> vous permet d’obtenir la même matrice que si vous appliquiez successivement les méthodes <codeph>identity()</codeph>, <codeph>rotate()</codeph>, <codeph>scale()</codeph> et <codeph>translate()</codeph>. Par exemple, <codeph>mat1.createBox(2,2, Math.PI/4, 100, 100)</codeph> permet d’obtenir le résultat suivant :</p>
     
     <codeblock platform="actionscript">
     import flash.geom.Matrix;
     
     var mat1:Matrix = new Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2,2);
     mat1.translate(10,20);
     </codeblock>
     
     <codeblock platform="javascript">
     var mat1 = new air.Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2, 2);
     mat1.translate(10, 20);
     </codeblock>
     
     </apiDesc><example conref="examples\Matrix_createBox.as"> L’exemple suivant définit les redimensionnements x et y, la rotation, ainsi que les emplacements x et y de <codeph>myMatrix</codeph> en appelant sa méthode <codeph>createBox()</codeph>.
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_createBox extends Sprite
    {
        public function Matrix_createBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createBox(1, 2, Math.PI/4, 50, 100);
             trace(myMatrix.toString());  
             // (a=0.7071067811865476, b=1.414213562373095, c=-0.7071067811865475, 
             //  d=1.4142135623730951, tx=100, ty=200)
             
             var rectangleShape:Shape = createRectangle(20, 80, 0xFF0000);   
             addChild(rectangleShape);
              
             var rectangleTrans:Transform = new Transform(rectangleShape);
             rectangleTrans.matrix = myMatrix;
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:createGradientBox"><apiName>createGradientBox</apiName><shortdesc>
     Crée le style spécifique de matrice attendu par les méthodes beginGradientFill() et lineGradientStyle() de la classe Graphics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
     
     </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Largeur de la zone de dégradé.
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Hauteur de la zone de dégradé.
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur de rotation, en radians. 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Distance, en pixels, à translater vers la droite sur l’axe des <i>x</i>. Cette valeur est décalée de la moitié du paramètre <codeph>width</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Distance, en pixels, à translater vers le bas sur l’axe des <i>y</i>. Cette valeur est décalée de la moitié du paramètre <codeph>height</codeph>. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Crée le style spécifique de matrice attendu par la méthode beginGradientFill() de la classe Graphics.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Crée le style spécifique de matrice attendu par les méthodes <codeph>beginGradientFill()</codeph> et <codeph>lineGradientStyle()</codeph> de la classe Graphics. La largeur et la hauteur sont redimensionnées selon une paire <codeph>scaleX</codeph>/<codeph>scaleY</codeph> et les valeurs <codeph>tx</codeph>/<codeph>ty</codeph> sont décalées de la moitié de la largeur et de la hauteur.
     
     <p>Par exemple, supposons un dégradé possédant les caractéristiques suivantes:</p>
     
     <ul>
     
     <li><codeph>GradientType.LINEAR</codeph></li>
     <li>Deux couleurs, vert et bleu, le tableau des rapports (ratios) correspondant à <codeph>[0, 255]</codeph></li>
     <li><codeph>SpreadMethod.PAD</codeph></li>
     <li><codeph>InterpolationMethod.LINEAR_RGB</codeph></li>
     
     </ul>
     
     <p>Les illustrations suivantes représentent des dégradés dans lesquels la matrice a été définie à l’aide de la méthode <codeph>createGradientBox()</codeph> et un paramétrage différent :</p>
     
     <adobetable class="innertable">
     
      
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry>Paramètres <codeph>createGradientBox()</codeph></entry><entry>Dégradé obtenu</entry></row></thead><tbody><row>
     
      <entry><pre>width = 25;
     height = 25; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="dégradé linéaire produit" href="../../images/createGradientBox-1.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 25; 
     height = 25; 
     rotation = 0; 
     tx = 25; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="dégradé linéaire produit" href="../../images/createGradientBox-2.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50; 
     height = 50; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="dégradé linéaire produit" href="../../images/createGradientBox-3.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50;
     height = 50; 
     rotation = Math.PI / 4; // 45 degrees
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="dégradé linéaire produit" href="../../images/createGradientBox-4.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\Matrix_createGradientBox.as"> L’exemple suivant définit les redimensionnements x et y, la rotation, ainsi que les emplacements x et y de <codeph>myMatrix</codeph> en appelant sa méthode <codeph>createBox()</codeph>.
<codeblock>

package
{
    import flash.display.GradientType;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    
    public class Matrix_createGradientBox extends Sprite
    {
        public function Matrix_createGradientBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());          // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createGradientBox(200, 200, 0, 50, 50);
             trace(myMatrix.toString());          // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)
             
             var colors:Array = [0xFF0000, 0x0000FF];
             var alphas:Array = [100, 100];
             var ratios:Array = [0, 0xFF];
             
             this.graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
             this.graphics.drawRect(0, 0, 300, 200);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:deltaTransformPoint"><apiName>deltaTransformPoint</apiName><shortdesc>
    Etant donné un point dans l’espace de coordonnées de prétransformation, cette méthode renvoie les coordonnées de ce point après la transformation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>deltaTransformPoint()</code> method 
    to create <code>deltaTransformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method has no affect on the position of <code>deltaTransformedPoint</code>.
    In the example, however, <code>scale()</code> does affect the position.  It
    increases the original <code>x</code> value by a factor of three from 50 to 150.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);   // (50, 0)              
    
    var deltaTransformedPoint:Point = myMatrix.deltaTransformPoint(myPoint);
    trace(deltaTransformedPoint); // (150, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = deltaTransformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Point résultant de l’application de la transformation de matrice.
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point pour lequel vous souhaitez obtenir le résultat de la transformation de matrice.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Etant donné un point dans l’espace de coordonnées de prétransformation, cette méthode renvoie les coordonnées de ce point après la transformation. Contrairement à la transformation standard appliquée via la méthode <codeph>transformPoint()</codeph>, la transformation de la méthode <codeph>deltaTransformPoint()</codeph> ne prend pas en considération les paramètres de translation <codeph>tx</codeph> et <codeph>ty</codeph>.
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:identity"><apiName>identity</apiName><shortdesc>
    Règle chaque propriété d’une matrice sur une valeur qui entraîne une transformation nulle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
    </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    Règle chaque propriété d’une matrice sur une valeur qui entraîne une transformation nulle. Un objet transformé par l’application d’une matrice d’identité est identique à l’objet d’origine.
    
    <p>Faisant suite à l’appel de la méthode <codeph>identity()</codeph>, la matrice obtenue présente les propriétés suivantes : <codeph>a</codeph> =1, <codeph>b</codeph> =0, <codeph>c</codeph> =0, <codeph>d</codeph> =1, <codeph>tx</codeph> =0, <codeph>ty</codeph> =0.</p>
    
    <p>Dans la notation des matrices, la matrice d’identité a l’aspect suivant :</p>
    
    <p><adobeimage alt="Des propriétés de la classe Matrix dans la notation des matrices" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:invert"><apiName>invert</apiName><shortdesc>
     Effectue la transformation opposée de la matrice d’origine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Effectue la transformation opposée de la matrice d’origine. Vous pouvez appliquer une matrice inversée à un objet pour annuler la transformation effectuée lors de l’application de la matrice d’origine.
     
     </apiDesc><example conref="examples\Matrix_invert.as"> L’exemple suivant crée <codeph>halfScaleMatrix</codeph> en appelant la méthode <codeph>invert()</codeph> de <codeph>doubleScaleMatrix</codeph>. Il démontre ensuite que les deux objets Matrix sont inversés l’un par rapport à l’autre (matrices annulant toute tranformation effectuée par son pendant) en créant <codeph>originalAndInverseMatrix</codeph> qui est l’équivalent de <codeph>noScaleMatrix</codeph>.
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_invert extends Sprite
    {
        public function Matrix_invert()
        {
            var rect0:Shape = createRectangle(20, 80, 0xFF0000);   
            var rect1:Shape = createRectangle(20, 80, 0x00FF00);   
            var rect2:Shape = createRectangle(20, 80, 0x0000FF);
            var rect3:Shape = createRectangle(20, 80, 0x000000);
            
            var trans0:Transform = new Transform(rect0);
            var trans1:Transform = new Transform(rect1);
            var trans2:Transform = new Transform(rect2);
            var trans3:Transform = new Transform(rect3);
             
            var doubleScaleMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
            trans0.matrix = doubleScaleMatrix;
            trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
             
            var noScaleMatrix:Matrix = new Matrix(1, 0, 0, 1, 0, 0);
            trans1.matrix = noScaleMatrix;
            rect1.x = 50;
            trace(noScaleMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
            var halfScaleMatrix:Matrix = doubleScaleMatrix.clone();
            halfScaleMatrix.invert();
            trans2.matrix = halfScaleMatrix;
            rect2.x = 100;
            trace(halfScaleMatrix.toString());  // (a=0.5, b=0, c=0, d=0.5, tx=0, ty=0)
             
            var originalAndInverseMatrix:Matrix = doubleScaleMatrix.clone();
            originalAndInverseMatrix.concat(halfScaleMatrix);
            trans3.matrix = originalAndInverseMatrix;
            rect3.x = 150;
            trace(originalAndInverseMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)            
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:rotate"><apiName>rotate</apiName><shortdesc>
     Applique une transformation de rotation à l’objet Matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example the <code>rotate()</code> method rotates <code>rectangleMc</code>
    30 degrees clockwise.  Notice that applying <code>myMatrix</code> to <code>rectangleMc</code>
    resets its <i>_x</i> value leaving us to reset it to 100 manually.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());           // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());           // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    The above example uses the <code>_x</code> property of the MovieClip object 
    to position <code>rectangleMc</code>.  Generally, when dealing with Matrix
    positioning, mixing positioning techniques is considered bad style.  The  
    example above written in good style would concatenate a translation Matrix to
    <code>myMatrix</code> to change the horizontal location of <code>rectangleMc</code>. 
    The following example demonstrates this. 
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());   // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var translateMatrix:Matrix = new Matrix();
    translateMatrix.translate(100, 0);
    myMatrix.concat(translateMatrix);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=100, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);        // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);        // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);        // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Angle de rotation en radians.
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Applique une transformation de rotation à l’objet Matrix. 
     
     <p>La méthode <codeph>rotate()</codeph> modifie les propriétés <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph> et <codeph>d</codeph> de l’objet Matrix. Dans la notation des matrices, cela équivaut à concaténer la matrice actuelle et les matrices ci-dessous :</p>
     
     <p><adobeimage alt="Notation des matrices des paramètres de la méthode scale" height="105" href="../../images/matrix_rotate.jpg" width="219"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:scale"><apiName>scale</apiName><shortdesc>
     Applique une transformation de redimensionnement à la matrice.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>scale()</code> method to
    scale <code>myMatrix</code> by a factor of 3 horizontally and a factor of 4 
    vertically.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.scale(3, 4);
    trace(myMatrix.toString());   // (a=6, b=0, c=0, d=8, tx=300, ty=400)
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet sur l’axe des <i>x</i>.
     </apiDesc></apiParam><apiParam><apiItemName>sy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Multiplicateur utilisé pour redimensionner l’objet sur l’axe des <i>y</i>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Applique une transformation de redimensionnement à la matrice. L’axe des <i>x</i> est multiplié par <codeph>sx</codeph> et l’axe des <i>y</i> par <codeph>sy</codeph>.
     
     <p>La méthode <codeph>scale()</codeph> modifie les propriétés <codeph>a</codeph> et <codeph>d</codeph> de l’objet Matrix. Dans la notation des matrices, cela équivaut à concaténer la matrice actuelle et les matrices ci-dessous :</p>
     <p><adobeimage alt="Notation des matrices des paramètres de la méthode scale" height="105" href="../../images/matrix_scale.jpg" width="140"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:toString"><apiName>toString</apiName><shortdesc>
     Renvoie une valeur de texte donnant la liste des propriétés de l’objet Matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>myMatrix</code> and converts its values 
     to a String in the format of (a=A, b=B, c=C, d=D, tx=TX, ty=TY).
     
     <listing version="2.0">
     import flash.geom.Matrix;
     
     var myMatrix:Matrix = new Matrix();
     trace("myMatrix: " + myMatrix.toString()); // (a=1, b=0, c=0, d=1, tx=0, ty=0)
     </listing>
      
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne répertoriant les valeurs des propriétés de l’objet Matrix : <codeph>a</codeph>, <codeph>b</codeph>, <codeph>c</codeph>, <codeph>d</codeph>, <codeph>tx</codeph> et <codeph>ty</codeph>.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie une valeur de texte donnant la liste des propriétés de cet objet Matrix.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Renvoie une valeur de texte donnant la liste des propriétés de l’objet Matrix.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:transformPoint"><apiName>transformPoint</apiName><shortdesc>
     Renvoie le résultat de l’application de la transformation géométrique représentée par l’objet Matrix au point spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>transformPoint()</code> method 
    to create <code>transformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method does have an affect on the position of <code>transformedPoint</code>.
    In the example, <code>scale()</code> increases the original <code>x</code> 
    value by a factor of three from 50 to 150, and <code>translate()</code> increases 
    <code>x</code> by 300 for a total value of 450.
    
    <listing version="2.0">
    import flash.geom.Matrix;     
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);                   // (50, 0)
          
    var transformedPoint:Point = myMatrix.transformPoint(myPoint);
    trace(transformedPoint);  // (450, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = transformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Point résultant de l’application de la transformation Matrix.
    
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point pour lequel vous souhaitez obtenir le résultat de la transformation Matrix.
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie le résultat d’une transformation géométrique vers un objet Point.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Renvoie le résultat de l’application de la transformation géométrique représentée par l’objet Matrix au point spécifié. 
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:translate"><apiName>translate</apiName><shortdesc>
    Translation de la matrice sur les axes x et y en fonction des paramètres dx et dy.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>translate()</code> method to position 
    <code>rectangleMc</code> x:100 and y:50. Notice that <code>translate()</code> affects 
    the translate values <code>tx</code> and <code>ty</code> but not <code>a</code>, <code>b</code>,
    <code>c</code>, or <code>d</code>.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.translate(100, 50);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=200, ty=150)
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Quantité de mouvement vers la droite sur l’axe des <i>x</i>, en pixels.
    
    </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Quantité de mouvement vers le bas sur l’axe des <i>y</i>, en pixels.
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Translation de la matrice sur les axes x et y.
    
    <p>La méthode <codeph>translate()</codeph> modifie les propriétés <codeph>tx</codeph> et <codeph>ty</codeph> de l’objet Matrix. Dans la notation des matrices, cela équivaut à concaténer la matrice actuelle et les matrices ci-dessous :</p>
    
    <p><adobeimage alt="Notation des matrices des paramètres de la méthode scale" height="105" href="../../images/matrix_translate.jpg" width="150"/></p>
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Translation de la matrice sur les axes <i>x</i> et <i>y</i> en fonction des paramètres <codeph>dx</codeph> et <codeph>dy</codeph>.
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix:a"><apiName>a</apiName><shortdesc>
     Valeur qui affecte le positionnement des pixels sur l’axe x lors du redimensionnement ou de la rotation d’une image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Valeur qui affecte le positionnement des pixels sur l’axe x lors du redimensionnement ou de la rotation d’une image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Valeur qui affecte le positionnement des pixels sur l’axe <i>x</i> lors du redimensionnement ou de la rotation d’une image.
     
     </apiDesc><example conref="examples\Matrix.a.1.as"> L’exemple suivant crée l’objet Matrix <codeph>myMatrix</codeph> et définit sa valeur <codeph>a</codeph>.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.a);  // 1

myMatrix.a = 2;
trace(myMatrix.a);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:b"><apiName>b</apiName><shortdesc>
     Valeur qui affecte le positionnement des pixels sur l’axe y lors de la rotation ou de l’inclinaison d’une image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Valeur qui affecte le positionnement des pixels sur l’axe y lors de la rotation ou de l’inclinaison d’une image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Valeur qui affecte le positionnement des pixels sur l’axe <i>y</i> lors de la rotation ou de l’inclinaison d’une image.
     
     </apiDesc><example conref="examples\Matrix.b.1.as"> L’exemple suivant crée l’objet Matrix <codeph>myMatrix</codeph> et définit sa valeur <codeph>b</codeph>.
<codeblock>
import flash.geom.Matrix;
 
var myMatrix:Matrix = new Matrix();
trace(myMatrix.b);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.b = Math.tan(radians);
trace(myMatrix.b);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:c"><apiName>c</apiName><shortdesc>
     Valeur qui affecte le positionnement des pixels sur l’axe x lors de la rotation ou de l’inclinaison d’une image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Valeur qui affecte le positionnement des pixels sur l’axe x lors de la rotation ou de l’inclinaison d’une image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Valeur qui affecte le positionnement des pixels sur l’axe <i>x</i> lors de la rotation ou de l’inclinaison d’une image.
     
     </apiDesc><example conref="examples\Matrix.c.1.as"> L’exemple suivant crée l’objet Matrix <codeph>myMatrix</codeph> et définit sa valeur <codeph>c</codeph>.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.c);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.c = Math.tan(radians);
trace(myMatrix.c);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:d"><apiName>d</apiName><shortdesc>
     Valeur qui affecte le positionnement des pixels sur l’axe y lors du redimensionnement ou de la rotation d’une image.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Valeur qui affecte le positionnement des pixels sur l’axe y lors du redimensionnement ou de la rotation d’une image.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Valeur qui affecte le positionnement des pixels sur l’axe <i>y</i> lors du redimensionnement ou de la rotation d’une image.
     
     </apiDesc><example conref="examples\Matrix.d.1.as"> L’exemple suivant crée l’objet Matrix <codeph>myMatrix</codeph> et définit sa valeur <codeph>d</codeph>.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.d);  // 1

myMatrix.d = 2;
trace(myMatrix.d);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:tx"><apiName>tx</apiName><shortdesc>
     Distance de translation de chaque point sur l’axe x.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Distance de translation de chaque point sur l’axe x.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Distance de translation de chaque point sur l’axe <i>x</i>.
     
     </apiDesc><example conref="examples\Matrix.tx.1.as"> L’exemple suivant crée l’objet Matrix <codeph>myMatrix</codeph> et définit sa valeur <codeph>tx</codeph>.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.tx);  // 0

myMatrix.tx = 50;  // 50
trace(myMatrix.tx);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:ty"><apiName>ty</apiName><shortdesc>
     Distance de translation de chaque point sur l’axe y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Distance de translation de chaque point sur l’axe y.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Distance de translation de chaque point sur l’axe <i>y</i>.
     
     </apiDesc><example conref="examples\Matrix.ty.1.as"> L’exemple suivant crée l’objet Matrix <codeph>myMatrix</codeph> et définit sa valeur <codeph>ty</codeph>.
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.ty);  // 0

myMatrix.ty = 50;
trace(myMatrix.ty);  // 50
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Rectangle"><apiName>Rectangle</apiName><shortdesc>
 Un objet Rectangle est une zone définie par sa position, indiquée par son angle supérieur gauche (x, y), ainsi que par sa largeur et sa hauteur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Un objet Rectangle est une zone définie par sa position, indiquée par son angle supérieur gauche (x, y), ainsi que par sa largeur et sa hauteur.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Un objet Rectangle est une zone définie par sa position, indiquée par son angle supérieur gauche (<i>x</i>, <i>y</i>), ainsi que par sa largeur et sa hauteur. 
 
 <p>Les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph> de la classe Rectangle sont indépendantes les unes des autres. Le fait de modifier l’une de ces propriétés n’a aucun effet sur les autres. Les propriétés <codeph>right</codeph> et <codeph>bottom</codeph>, en revanche, sont intégralement liées à ces quatre propriétés. La modification de la valeur des propriétés <codeph>right</codeph> et <codeph>bottom</codeph>, par exemple, a une incidence sur la valeur des propriétés <codeph>width</codeph> et <codeph>height</codeph>, respectivement. </p>
 
 <p platform="actionscript">Les méthodes et propriétés suivantes utilisent les objets Rectangle :</p>
 
 <ul platform="actionscript">
 
 	<li>Les méthodes <codeph>applyFilter()</codeph>, <codeph>colorTransform()</codeph>, <codeph>copyChannel()</codeph>, <codeph>copyPixels()</codeph>, <codeph>draw()</codeph>, <codeph>fillRect()</codeph>, <codeph>generateFilterRect()</codeph>, <codeph>getColorBoundsRect()</codeph>, <codeph>getPixels()</codeph>, <codeph>merge()</codeph>, <codeph>paletteMap()</codeph>, <codeph>pixelDisolve()</codeph>, <codeph>setPixels()</codeph> et <codeph>threshold()</codeph> et la propriété <codeph>rect</codeph> de la classe BitmapData</li>
 
 	<li>les méthodes <codeph>getBounds()</codeph> et <codeph>getRect()</codeph>, ainsi que les propriétés <codeph>scrollRect</codeph> et <codeph>scale9Grid</codeph> de la classe DisplayObject ;</li>
 
 	<li>la méthode <codeph>getCharBoundaries()</codeph> de la classe TextField ;</li>
 
 	<li>la propriété <codeph>pixelBounds</codeph> de la classe Transform ;</li>
 
 	<li>le paramètre <codeph>bounds</codeph> de la méthode <codeph>startDrag()</codeph> de la classe Sprite ;</li>
 
 	<li>le paramètre <codeph>printArea</codeph> de la méthode <codeph>addPage()</codeph> de la classe PrintJob.</li>
 
 </ul>
 
 <p>Vous pouvez utiliser le constructeur <codeph>new Rectangle()</codeph> pour créer un objet Rectangle.</p>
 
 <p platform="actionscript"><b>Remarque :</b> la classe Rectangle ne définit pas un objet d’affichage Shape rectangulaire. Pour dessiner un objet Shape rectangulaire à l’écran, utilisez la méthode <codeph>drawRect()</codeph> de la classe Graphics.</p>
 
 </apiDesc><example conref="examples\RectangleExample.as"> L’exemple suivant utilise la classe RectangleExample pour créer trois nouveaux objets Rectangle à diverses coordonnées <i>x</i>,<i>y</i> et selon différentes hauteurs et largeurs ; la méthode <codeph>trace()</codeph> est utilisée pour confirmer la création réussie des occurrences de Rectangle. Une variable booléenne <codeph>isContained</codeph> est ensuite attribuée au résultat de l’appel à la méthode <codeph>containsRect()</codeph> qui détermine que le deuxième rectangle n’englobe pas complètement le troisième rectangle.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Rectangle;

    public class RectangleExample extends Sprite {

        public function RectangleExample() {
            var firstRect:Rectangle = new Rectangle();
            trace(firstRect);  // (x=0, y=0, w=0, h=0)
            var secondRect:Rectangle = new Rectangle(1, 3, 11, 13);
            trace(secondRect); // (x=1, y=3, w=11, h=13)
            var thirdRect:Rectangle = new Rectangle(5, 8, 17, 19);
            trace(thirdRect);  // (x=5, y=8, w=17, h=19)
            var isContained:Boolean = secondRect.containsRect(thirdRect);
            trace(isContained); // false
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/scrollRect"><linktext>flash.display.DisplayObject.scrollRect</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.text.xml#TextField/getCharBoundaries()"><linktext>flash.text.TextField.getCharBoundaries()</linktext></link><link href="flash.geom.xml#Transform/pixelBounds"><linktext>flash.geom.Transform.pixelBounds</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>flash.display.Sprite.startDrag()</linktext></link><link href="flash.printing.xml#PrintJob/addPage()"><linktext>flash.printing.PrintJob.addPage()</linktext></link></related-links><apiConstructor id="flash.geom:Rectangle:Rectangle"><apiName>Rectangle</apiName><shortdesc>
	Crée un objet Rectangle dont le coin supérieur gauche est déterminé par les paramètres x et y, avec des paramètres width et height spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle with with specific parameters.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.toString()); // (x=5, y=10, w=50, h=100)
	</listing>
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Coordonnée <i>x</i> du coin supérieur gauche du rectangle.
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Coordonnée <i>y</i> du coin supérieur gauche du rectangle.
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Largeur du rectangle en pixels.
	</apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Hauteur du rectangle en pixels.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Crée un objet Rectangle dont le coin supérieur gauche est déterminé par les paramètres x et y, et dont la hauteur et la largeur sont spécifiées.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Crée un objet Rectangle dont le coin supérieur gauche est déterminé par les paramètres <codeph>x</codeph> et <codeph>y</codeph> et présentant la hauteur et la largeur spécifiées par les paramètres <codeph>width</codeph> et <codeph>height</codeph>. Si vous appelez cette fonction sans paramètres, les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph> du rectangle créé seront définies sur 0.
	
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Rectangle:clone"><apiName>clone</apiName><shortdesc>
	Renvoie un nouvel objet Rectangle avec les mêmes valeurs que l’objet Rectangle d’origine pour les propriétés x, y, width (largeur) et height (hauteur).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the <code>clone</code> member.
	<listing version="2.0">
	import flash.geom.Rectangle;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var shadow:Rectangle = rect.clone();
	shadow.offset(5, 5);
	trace(rect); // (x=1, y=2, w=4, h=8)
	trace(shadow); // (x=6, y=7, w=4, h=8)
	</listing>

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet Rectangle avec les mêmes valeurs que l’objet Rectangle d’origine pour les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph>.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie une copie de cet objet Rectangle.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Renvoie un nouvel objet Rectangle avec les mêmes valeurs que l’objet Rectangle d’origine pour les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph>.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:contains"><apiName>contains</apiName><shortdesc>
	Détermine si le point spécifié figure dans la zone rectangulaire définie par cet objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the coordinates fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var doesContain_1:Boolean = rect.contains(59, 59);
	trace(doesContain_1); // true
	var doesContain_2:Boolean = rect.contains(10, 10);
	trace(doesContain_2); // true
	var doesContain_3:Boolean = rect.contains(60, 60);
	trace(doesContain_3); // false
	</listing>

	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Si le point spécifié figure dans l’objet Rectangle, <codeph>true</codeph> est renvoyé ; <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> (position horizontale) du point.  
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> (position verticale) du point.
	</apiDesc></apiParam><apiTipTexts><apiTipText>Détermine si le point spécifié figure dans la zone rectangulaire.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Détermine si le point spécifié figure dans la zone rectangulaire définie par cet objet Rectangle.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsPoint"><apiName>containsPoint</apiName><shortdesc>
	Détermine si le point spécifié figure dans la zone rectangulaire définie par cet objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the specified Points fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var containsPoint_1:Boolean = rect.containsPoint(new Point(10, 10));
	trace(containsPoint_1); // true
	var containsPoint_2:Boolean = rect.containsPoint(new Point(59, 59));
	trace(containsPoint_2); // true
	var containsPoint_3:Boolean = rect.containsPoint(new Point(60, 60));
	trace(containsPoint_3); // false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Si le point spécifié figure dans l’objet Rectangle, <codeph>true</codeph> est renvoyé ; <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le point, tel qu’il est représenté par ses coordonnées <i>x</i> et <i>y</i>.  
	</apiDesc></apiParam><apiTipTexts><apiTipText>Détermine si le point spécifié figure dans la zone rectangulaire définie par cet objet Rectangle en utilisant un objet Point comme paramètre.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Détermine si le point spécifié figure dans la zone rectangulaire définie par cet objet Rectangle. Cette méthode est similaire à la méthode <codeph>Rectangle.contains()</codeph>, à ceci près qu’elle prend un objet Point comme paramètre.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/contains()"><linktext>contains()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsRect"><apiName>containsRect</apiName><shortdesc>
	Détermine si l’objet Rectangle spécifié par le paramètre rect figure dans cet objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>A Rectangle is said to contain another if that second 
	Rectangle falls entirely within the boundaries of the first.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectC:Rectangle = new Rectangle(10, 10, 51, 51);
	var rectD:Rectangle = new Rectangle(15, 15, 45, 45);
	var rectAContainsB:Boolean = rectA.containsRect(rectB); // true
	var rectAContainsC:Boolean = rectA.containsRect(rectC); // false
	var rectAContainsD:Boolean = rectA.containsRect(rectD); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Si l’objet Rectangle que vous spécifiez est compris dans cet objet Rectangle, <codeph>true</codeph> est renvoyé ; <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Objet Rectangle en cours de vérification.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Détermine si l’objet Rectangle spécifié par le paramètre rect figure dans cet objet Rectangle.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Détermine si l’objet Rectangle spécifié par le paramètre <codeph>rect</codeph> figure dans cet objet Rectangle. On dit qu’un objet Rectangle en contient un autre si ce dernier est entièrement circonscrit dans les limites du premier.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:equals"><apiName>equals</apiName><shortdesc>
	Détermine si l’objet spécifié dans le paramètre toCompare est égal à cet objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Even though the method signature only expects an abstract Object
	only other Rectangle instances will ever be treated as equal.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	var nonRect:Object = new Object();
	nonRect.x = 0;
	nonRect.y = 0;
	nonRect.width = 50;
	nonRect.height = 100;
	trace(rect_1.equals(nonRect));
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Si l’objet a exactement les mêmes valeurs que cet objet Rectangle en ce qui concerne les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph>, la valeur <codeph>true</codeph> est renvoyée ; <codeph>false</codeph> est renvoyée dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Rectangle que vous voulez comparer à cet objet Rectangle.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Détermine si l’objet spécifié dans le paramètre toCompare est égal à cet objet Rectangle.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Détermine si l’objet spécifié dans le paramètre <codeph>toCompare</codeph> est égal à cet objet Rectangle. Cette méthode compare les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph> d’un objet aux mêmes propriétés de cet objet Rectangle.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflate"><apiName>inflate</apiName><shortdesc>
	Agrandit l’objet Rectangle en fonction des quantités spécifiées en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and increase its <code>width</code> by 16 ~~ 2 (32) and it's <code>height</code> by 32 ~~ 2 (64)
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.toString()); // (x=1, y=2, w=4, h=8)
	rect.inflate(16, 32);
	trace(rect.toString()); // (x=-15, y=-30, w=36, h=72)	
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur à ajouter sur la gauche et sur la droite de l’objet Rectangle. L’équation suivante permet de calculer la nouvelle largeur et la nouvelle position du rectangle :
	
	<codeblock>
	x -= dx;
	width += 2 ~~ dx;
	</codeblock>
	
	</apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur à ajouter en haut et en bas de l’objet Rectangle. L’équation suivante permet de calculer la nouvelle hauteur et la nouvelle position du rectangle :
	
	<codeblock>
	y -= dy;
	height += 2 ~~ dy;
	</codeblock>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Agrandit l’objet Rectangle en fonction des quantités spécifiées, en pixels. Le point central de l’objet Rectangle reste inchangé tandis que sa taille augmente de la valeur de <codeph>dx</codeph> sur la gauche et la droite, et de la valeur de <codeph>dy</codeph> vers le haut et bas.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflatePoint"><apiName>inflatePoint</apiName><shortdesc>
	 Agrandit la taille de l’objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and inflate it by the <i>x</i> <i>horizontal</i> and <i>y</i> <i>vertical</i> amounts found in Point
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(0, 0, 2, 5);
	 var myPoint:Point = new Point(2, 2);
	 rect.inflatePoint(myPoint);
	 trace(rect.toString()); // (x=-2, y=-2, w=6, h=9)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>La propriété <codeph>x</codeph> de cet objet Point permet d’agrandir l’objet Rectangle horizontalement. Sa propriété <codeph>y</codeph> permet d’agrandir l’objet Rectangle verticalement.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Agrandit la taille de l’objet Rectangle en utilisant un objet Point comme paramètre.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Agrandit la taille de l’objet Rectangle. Cette méthode est similaire à la méthode <codeph>Rectangle.inflate()</codeph>, à ceci près qu’elle prend un objet Point comme paramètre.
	 
	  <p>Les deux exemples de code suivants donnent le même résultat :</p>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 var pt1:Point = new Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 var pt1 = new air.Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:intersection"><apiName>intersection</apiName><shortdesc>
	Si l’objet Rectangle spécifié dans le paramètre toIntersect forme une intersection avec cet objet Rectangle, la zone d’intersection est renvoyée en tant qu’objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>What area overlaps <code>rect_1</code> between <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 50);
	var rect_2:Rectangle = new Rectangle(25, 25, 100, 100);
	var intersectingArea:Rectangle = rect_1.intersection(rect_2);
	trace(intersectingArea.toString()); // (x=25, y=25, w=25, h=25)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Rectangle qui correspond à la zone d’intersection. Si les rectangles ne se recoupent pas, cette méthode renvoie un objet Rectangle vide, c’est-à-dire un rectangle dont les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph> sont définies sur 0.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Objet Rectangle à prendre comme comparaison pour voir s’il recoupe cet objet Rectangle.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la zone de l’intersection.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Si l’objet Rectangle spécifié dans le paramètre <codeph>toIntersect</codeph> forme une intersection avec cet objet Rectangle, la zone d’intersection est renvoyée en tant qu’objet Rectangle. Si les rectangles ne se recoupent pas, cette méthode renvoie un objet Rectangle vide dont les propriétés sont définies sur 0.
	
    <p><adobeimage alt="Le rectangle d’intersection produit." href="../../images/rectangle_intersect.jpg"/></p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:intersects"><apiName>intersects</apiName><shortdesc>
	Détermine si l’objet spécifié par le paramètre toIntersect forme une intersection avec cet objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Does <code>rect_1</code> intersect with <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(59, 59, 50, 50);
	var rectC:Rectangle = new Rectangle(60, 60, 50, 50);
	var rectAIntersectsB:Boolean = rectA.intersects(rectB);
	var rectAIntersectsC:Boolean = rectA.intersects(rectC);
	trace(rectAIntersectsB); // true
	trace(rectAIntersectsC); // false
	
	var firstPixel:Rectangle = new Rectangle(0, 0, 1, 1);
	var adjacentPixel:Rectangle = new Rectangle(1, 1, 1, 1);
	var pixelsIntersect:Boolean = firstPixel.intersects(adjacentPixel);
	trace(pixelsIntersect); // false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Si l’objet spécifié forme une intersection avec cet objet Rectangle, <codeph>true</codeph> est renvoyé ; <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Objet Rectangle à comparer à cet objet Rectangle. 
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Détermine si l’objet spécifié dans le paramètre toIntersect forme une intersection avec cet objet Rectangle.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Détermine si l’objet spécifié par le paramètre <codeph>toIntersect</codeph> forme une intersection avec cet objet Rectangle. Cette méthode vérifie les propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph> de l’objet Rectangle spécifié pour déterminer s’il recoupe cet objet Rectangle.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:isEmpty"><apiName>isEmpty</apiName><shortdesc>
	Détermine si cet objet Rectangle est vide.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it become empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.isEmpty()); // false
	rect.width = 0;
	trace(rect.isEmpty()); // true
	rect.width = 4;
	trace(rect.isEmpty()); // false
	rect.height = 0;
	trace(rect.isEmpty()); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Si la largeur ou la hauteur de l’objet Rectangle est inférieure ou égale à 0, <codeph>true</codeph> est renvoyé ; <codeph>false</codeph> dans le cas contraire.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Détermine si cet objet Rectangle est vide. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offset"><apiName>offset</apiName><shortdesc>
	 Règle la position de l’objet Rectangle, identifié par son coin supérieur gauche, en fonction des quantités spécifiées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and offset it's <i>x</i> and <i>y</i> values by 5 and 10 respectively
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	 rect.offset(16, 32);
	 trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Déplace en fonction de cette quantité la valeur <i>x</i> de l’objet Rectangle.
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Déplace en fonction de cette quantité la valeur <i>y</i> de l’objet Rectangle.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Règle l’emplacement de l’objet Rectangle.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Règle la position de l’objet Rectangle, identifié par son coin supérieur gauche, en fonction des quantités spécifiées.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offsetPoint"><apiName>offsetPoint</apiName><shortdesc>
	 Règle l’emplacement de l’objet Rectangle en utilisant un objet Point comme paramètre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Offset a Rectangle by using the values found in a Point
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var myPoint:Point = new Point(16, 32);
	rect.offsetPoint(myPoint);
	trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Objet Point à utiliser pour décaler cet objet Rectangle.
	 
	</apiDesc></apiParam><apiTipTexts><apiTipText>Règle l’emplacement de l’objet Rectangle en utilisant un objet Point comme paramètre.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Règle l’emplacement de l’objet Rectangle en utilisant un objet Point comme paramètre. Cette méthode est similaire à la méthode <codeph>Rectangle.offset()</codeph>, à ceci près qu’elle prend un objet Point comme paramètre.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:setEmpty"><apiName>setEmpty</apiName><shortdesc>
	Définit toutes les propriétés de l’objet Rectangle sur 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.isEmpty()); // false
	rect.setEmpty();
	trace(rect.isEmpty()); // true
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Définit l’ensemble des propriétés sur 0.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Définit toutes les propriétés de l’objet Rectangle sur 0. Un objet Rectangle est vide si sa largeur ou sa hauteur est inférieure ou égale à 0.
	
	<p> Cette méthode règle les valeurs des propriétés <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph> sur 0.</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:toString"><apiName>toString</apiName><shortdesc>
	Crée et renvoie une chaîne qui répertorie les positions horizontale et verticale ainsi que la largeur et la hauteur de l’objet Rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Concatenate a String representation of <code>rect_1</code> with some helpful 
	debugging text.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	trace("Rectangle 1 : " + rect_1.toString()); // Rectangle 1 : (x=0, y=0, w=50, h=100)
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne répertoriant la valeur de chacune des propriétés suivantes de l’objet Rectangle : <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph>.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Crée et renvoie une chaîne qui répertorie les positions horizontale et verticale ainsi que la largeur et la hauteur de l’objet Rectangle.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:union"><apiName>union</apiName><shortdesc> 
	 Additionne deux rectangles pour créer un nouvel objet Rectangle en remplissant l’essentiel de l’espace horizontal et vertical qui les sépare.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle out of the Union of two others.
	<p>For example, consider a rectangle with properties <code>x=20</code>, <code>y=50</code>, <code>width=60</code>, and 
	<code>height=30</code> (20, 50, 60, 30) and a second rectangle with properties (150, 130, 50, 30). 
	The union of these two rectangles would be a larger rectangle encompassing the two rectangles 
	with the properties (20, 50, 180, 110).</p>
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(20, 50, 60, 30);
	var rect_2:Rectangle = new Rectangle(150, 130, 50, 30);
	var combined:Rectangle = rect_1.union(rect_2);
	trace(combined.toString()); // (x=20, y=50, w=180, h=110)
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet Rectangle qui correspond à l’union des deux rectangles.
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toUnion</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Objet Rectangle à ajouter à cet objet Rectangle.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Additionne deux rectangles pour créer un nouvel objet Rectangle.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc> 
	 Additionne deux rectangles pour créer un nouvel objet Rectangle en remplissant l’essentiel de l’espace horizontal et vertical qui les sépare.
	 
    <p><adobeimage alt="Le rectangle d’union produit." href="../../images/rectangle_union.jpg"/></p>
	<p><b>Remarque :</b> la méthode <codeph>union()</codeph> ignore les rectangles dotés de la valeur <codeph>0</codeph> comme hauteur ou largeur, comme : <codeph>var rect2:Rectangle = new Rectangle(300,300,50,0);</codeph></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Rectangle:height"><apiName>height</apiName><shortdesc>
	Hauteur du rectangle en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>width</i> property 
	from 10 to 20. Notice that <code>rect.right</code> is also
	changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>La hauteur du rectangle en pixels.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Hauteur du rectangle en pixels. La modification de la valeur <codeph>height</codeph> d’un objet Rectangle n’a pas d’effet sur les propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>width</codeph>.
	
    <p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:width"><apiName>width</apiName><shortdesc>
	Largeur du rectangle en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Rectangle object and change its <code>width</code> property 
	from 10 to 20. Notice that <code>rect.right</code> also
	changes.

	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>La largeur du rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Largeur du rectangle, en pixels. La modification de la valeur <codeph>width</codeph> d’un objet Rectangle n’a pas d’effet sur les propriétés <codeph>x</codeph>, <codeph>y</codeph> et <codeph>height</codeph>.
	
	<p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:x"><apiName>x</apiName><shortdesc>
	Coordonnée x du coin supérieur gauche du rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>x</i> property 
	to 10. Notice that <code>rect.left</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.x); // 0
	trace(rect.left); // 0
	rect.x = 10;
	trace(rect.x); // 10
	trace(rect.left); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Coordonnée x du coin supérieur gauche du rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Coordonnée <i>x</i> du coin supérieur gauche du rectangle. La modification de la valeur de la propriété <codeph>x</codeph> d’un objet Rectangle n’a pas d’effet sur les propriétés <codeph>y</codeph>, <codeph>width</codeph> et <codeph>height</codeph>. 
	
	<p>La valeur de la propriété <codeph>x</codeph> est égale à la valeur de la propriété <codeph>left</codeph>.</p>
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/left"><linktext>left</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:y"><apiName>y</apiName><shortdesc>
	Coordonnée y du coin supérieur gauche du rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>y</i> property
	to 10. Notice that <code>rect.top</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.y); // 0
	trace(rect.top); // 0
	rect.y = 10;
	trace(rect.y); // 10
	trace(rect.top); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>La coordonnée y du coin supérieur gauche.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Coordonnée <i>y</i> du coin supérieur gauche du rectangle. La modification de la valeur de la propriété <codeph>y</codeph> d’un objet Rectangle n’a pas d’effet sur les propriétés <codeph>x</codeph>, <codeph>width</codeph> et <codeph>height</codeph>.
	
	<p>La valeur de la propriété <codeph>y</codeph> est égale à la valeur de la propriété <codeph>top</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link><link href="flash.geom.xml#Rectangle/top"><linktext>top</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottom:get"><apiName>bottom</apiName><shortdesc>
	Somme des propriétés y et height.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>bottom</i> property 
	from 15 to 30. Notice that <code>rect.height</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.height); // 10
	trace(rect.bottom); // 15
	rect.bottom = 30;
	trace(rect.height); // 25
	trace(rect.bottom); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Somme des propriétés y et height.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Somme des propriétés <codeph>y</codeph> et <codeph>height</codeph>.
	
    <p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottomRight:get"><apiName>bottomRight</apiName><shortdesc>
	Emplacement du coin inférieur droit de l’objet Rectangle, déterminé par les valeurs des propriétés right et bottom.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>bottomRight</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.bottom); // 5
	trace(rect.right); // 10
	var myBottomRight:Point = rect.bottomRight;
	trace(myBottomRight.x); // 5
	trace(myBottomRight.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>Emplacement du coin inférieur droit de l’objet Rectangle, déterminé par les propriétés right et bottom.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Emplacement du coin inférieur droit de l’objet Rectangle, déterminé par les valeurs des propriétés <codeph>right</codeph> et <codeph>bottom</codeph>.
	
    <p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:left:get"><apiName>left</apiName><shortdesc>
	Coordonnée x du coin supérieur gauche du rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>left</i> property and notice that 
	<code>rect.x</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.left); // 0
	trace(rect.x); // 0
	rect.left = 10;
	trace(rect.left); // 10
	trace(rect.x); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Coordonnée x du coin supérieur gauche du rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Coordonnée <i>x</i> du coin supérieur gauche du rectangle. La modification de la propriété <codeph>left</codeph> d’un objet Rectangle n’a pas d’effet sur les propriétés <codeph>y</codeph> et <codeph>height</codeph>. Elle a toutefois une incidence sur la propriété <codeph>width</codeph>, alors que la modification de la valeur <codeph>x</codeph> n’a <i>aucun</i> effet sur la propriété <codeph>width</codeph>.
	
	<p>La valeur de la propriété <codeph>left</codeph> est égale à la valeur de la propriété <codeph>x</codeph>.</p>
	
	
    <p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:right:get"><apiName>right</apiName><shortdesc>
	Somme des propriétés x et width.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>right</i> property 
	from 15 to 30. Notice that <code>rect.width</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.right = 30;
	trace(rect.width); // 25
	trace(rect.right); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Somme des propriétés x et width.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Somme des propriétés <codeph>x</codeph> et <codeph>width</codeph>.
	
    <p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:size:get"><apiName>size</apiName><shortdesc>
	Taille de l’objet Rectangle, exprimée en tant qu’objet Point avec les valeurs des propriétés width et height.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Rectangle, retrieves it's <code>size</code>,
	changes the <code>size</code> and sets the new values on the Rectangle instance.
	It is critical to remember that the <code>Point</code> object used by <code>size</code>
	uses x and y values to represent the <code>width</code> and <code>height</code> properties
	of the Rectangle.
	<listing version="2.0">
	import flash.geom.Rectangle;
	import flash.geom.Point;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	
	var size:Point = rect.size;
	trace(size.x); // 4;
	trace(size.y); // 8;
	
	size.x = 16;
	size.y = 32;
	rect.size = size;
	trace(rect.x); // 1
	trace(rect.y); // 2
	trace(rect.width); // 16
	trace(rect.height); // 32
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>Taille de l’objet Rectangle, exprimée en tant qu’objet Point avec les valeurs width (largeur) et height (hauteur).
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Taille de l’objet Rectangle, exprimée en tant qu’objet Point avec les valeurs des propriétés <codeph>width</codeph> et <codeph>height</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:top:get"><apiName>top</apiName><shortdesc>
	Coordonnée y du coin supérieur gauche du rectangle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>top</i> property and notice that 
	<code>rect.y</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.top); // 0
	trace(rect.y); // 0
	rect.top = 10;
	trace(rect.top); // 10
	trace(rect.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Coordonnée y du coin supérieur gauche du rectangle.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Coordonnée <i>y</i> du coin supérieur gauche du rectangle. La modification de la propriété <codeph>top</codeph> d’un objet Rectangle n’a pas d’effet sur les propriétés <codeph>x</codeph> et <codeph>width</codeph>. Elle a toutefois une incidence sur la propriété <codeph>height</codeph>, alors que la modification de la valeur <codeph>y</codeph> n’a <i>aucun</i> effet sur la propriété <codeph>height</codeph>.
	
	<p>La valeur de la propriété <codeph>top</codeph> est égale à la valeur de la propriété <codeph>y</codeph>.</p>
	
    <p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:topLeft:get"><apiName>topLeft</apiName><shortdesc>
	Emplacement du coin supérieur gauche de l’objet Rectangle, déterminé par les coordonnées x et y du point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>topLeft</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(5, 15);
	var myTopLeft:Point = rect.topLeft;
	trace(myTopLeft.x); // 5;
	trace(myTopLeft.y); // 15;
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>Emplacement du coin supérieur gauche de l’objet Rectangle, déterminé par les valeurs x et y du point.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Emplacement du coin supérieur gauche de l’objet Rectangle, déterminé par les coordonnées <i>x</i> et <i>y</i> du point.
	
    <p><adobeimage alt="Image de rectangle montrant les propriétés location et measurement." href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
 La classe ColorTransform vous permet de régler les valeurs de couleur d’un objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe ColorTransform vous permet de régler les valeurs de couleur d’un objet d’affichage. Le réglage des couleurs ou <i>transformation de couleur</i> peut être appliqué aux quatre canaux : rouge, vert, bleu et transparence alpha.
 
 <p>Lorsqu’un objet ColorTransform est appliqué à un objet d’affichage, une nouvelle valeur est calculée de la manière suivante pour chaque canal de couleur :</p>
 
 <ul>
 <li>Nouvelle valeur de rouge = (ancienne valeur de rouge * <codeph>redMultiplier</codeph>) + <codeph>redOffset</codeph></li>
 <li>Nouvelle valeur de vert = (ancienne valeur de vert * <codeph>greenMultiplier</codeph>) + <codeph>greenOffset</codeph></li>
 <li>Nouvelle valeur de bleu = (ancienne valeur de bleu * <codeph>blueMultiplier</codeph>) + <codeph>blueOffset</codeph></li>
 <li>Nouvelle valeur alpha = (ancienne valeur alpha * <codeph>alphaMultiplier</codeph>) + <codeph>alphaOffset</codeph></li>
 </ul>
 
 <p>Toute valeur de canal de couleur supérieure à 255 après le calcul est ramenée à 255. Si elle est inférieure à 0, elle est réglée sur 0.</p>
 
 <p>Vous pouvez utiliser les objets ColorTransform comme suit :</p>
 
 <ul>
 
 	<li>Dans le paramètre <codeph>colorTransform</codeph> de la méthode <codeph>colorTransform()</codeph> de la classe BitmapData.</li>
 
 	<li>En tant que propriété <codeph>colorTransform</codeph> d’un objet Transform (utilisable comme propriété <codeph>transform</codeph> d’un objet d’affichage).</li>
 
 </ul>
 
 <p>Vous devez utiliser le constructeur <codeph>new ColorTransform()</codeph> pour créer un objet ColorTransform avant de pouvoir appeler les méthodes de l’objet ColorTransform.</p>
 
 <p>Les transformations de couleurs ne s’appliquent pas à la couleur d’arrière-plan d’un clip (tel qu’un objet SWF chargé). Elles s’appliquent uniquement aux graphiques et symboles associés au clip.</p>
 
 </apiDesc><example conref="examples\ColorTransformExample.as"> L’exemple suivant utilise la classe TransformExample pour créer une icône animée (sprite) simple, de forme carrée et dont le remplissage est dégradé. Chaque fois que l’utilisateur clique sur le carré, l’application transforme les couleurs de l’icône animée par un ajout sur le canal de la couleur rouge et un éclaircissement sur le canal de la couleur bleue. Cette opération se déroule selon la procédure suivante :
 
 <ol>
     <li>Le constructeur crée un nouvel objet Sprite <codeph>target</codeph>.</li>
 
     <li>Le constructeur <codeph>CustomButton()</codeph> appelle la méthode <codeph>draw()</codeph> qui dessine un carré dégradé dans l’icône animée (sprite).</li>
 
     <li>Le constructeur <codeph>CustomButton()</codeph> ajoute un écouteur d’événement clic pour le sprite ; il est géré par le biais de la méthode <codeph>clickHandler()</codeph>.  </li>
 
     <li>Dans la méthode <codeph>clickHandler()</codeph>, deux propriétés sont défnies sur les propriétés <codeph>redOffset</codeph> et <codeph>blueOffset</codeph> de la transformation de couleur actuelle. Chacune d’elles est réglée sur 25. La propriété de l’icône animée carrée <codeph>transform.colorTransform</codeph> est ensuite modifiée pour utiliser les nouvelles valeurs de décalage. Chaque fois que l’utilisateur clique sur le carré, l’appel de la méthode <codeph>clickHandler()</codeph> modifie la couleur du carré en augmentant sa valeur de couleur rouge et en diminuant celle de couleur bleue.  </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class ColorTransformExample extends Sprite {
        public function ColorTransformExample() {
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var rOffset:Number = transform.colorTransform.redOffset + 25;
            var bOffset:Number = transform.colorTransform.redOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);
        }
    }
}    
</codeblock></example></apiClassifierDetail><related-links><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.display.xml#BitmapData/colorTransform()"><linktext>flash.display.BitmapData.colorTransform()</linktext></link></related-links><apiConstructor id="flash.geom:ColorTransform:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
	 Crée un objet ColorTransform pour un objet d’affichage avec les paramètres RVB et alpha spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new ColorTransform, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur du multiplicateur de rouge, comprise entre 0 et 1.
	 </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur du multiplicateur de vert, comprise entre 0 et 1.
	 </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur du multiplicateur de bleu, comprise entre 0 et 1.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Valeur du multiplicateur de transparence alpha, comprise entre 0 et 1.
	 </apiDesc></apiParam><apiParam><apiItemName>redOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur du décalage appliqué au canal de couleur rouge, comprise entre -255 et 255.
	 </apiDesc></apiParam><apiParam><apiItemName>greenOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur du décalage appliqué au canal de couleur vert, comprise entre -255 et 255.
	 </apiDesc></apiParam><apiParam><apiItemName>blueOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur du décalage appliqué au canal de couleur bleu, comprise entre -255 et 255.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Valeur du décalage appliqué au canal de transparence alpha, comprise entre -255 et 255.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Crée un objet ColorTransform pour un objet d’affichage.
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Crée un objet ColorTransform pour un objet d’affichage avec les paramètres RVB et alpha spécifiés. 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:ColorTransform:concat"><apiName>concat</apiName><shortdesc>
	 Concatène l’objet ColorTranform, spécifié par le paramètre second, et l’objet ColorTransform actuel en définissant ce dernier comme résultat, ce qui se traduit par l’addition des deux transformations de couleur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example concatenates the ColorTransform object <code>colorTrans_2</code>
	to <code>colorTrans_1</code> resulting in a full red offset combined with a .5 alpha multiplier.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans_1:ColorTransform = new ColorTransform(1, 1, 1, 1, 255, 0, 0, 0);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var colorTrans_2:ColorTransform = new ColorTransform(1, 1, 1, .5, 0, 0, 0, 0);
	trace(colorTrans_2);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	colorTrans_1.concat(colorTrans_2);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans_1;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>Objet ColorTransform devant être combiné à l’objet ColorTransform actuel.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Concatène l’objet ColorTranform, spécifié par le paramètre <codeph>second</codeph>, et l’objet ColorTransform actuel en définissant ce dernier comme résultat, ce qui se traduit par l’addition des deux transformations de couleur. L’application de l’objet ColorTransform concaténé revient à appliquer la <codeph>second</codeph> transformation de couleur, puis la seconde (<i>original</i>).
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:ColorTransform:toString"><apiName>toString</apiName><shortdesc>
	 Formate et renvoie une chaîne qui décrit l’ensemble des propriétés de l’objet ColorTransform.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and calls its <code>toSting()</code> method.  This method results in a string with the format
	(redMultiplier=RM, greenMultiplier=GM, blueMultiplier=BM, alphaMultiplier=AM, redOffset=RO, greenOffset=GO, blueOffset=BO, alphaOffset=AO).
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform(1, 2, 3, 4, -255, -128, 128, 255);
 	trace(colorTrans.toString());		// (redMultiplier=1, greenMultiplier=2, blueMultiplier=3, alphaMultiplier=4, redOffset=-255, greenOffset=-128, blueOffset=128, alphaOffset=255)
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne répertoriant toutes les propriétés de l’objet ColorTransform.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Formate et renvoie une chaîne qui décrit l’ensemble des propriétés de l’objet ColorTransform.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:ColorTransform:alphaMultiplier"><apiName>alphaMultiplier</apiName><shortdesc>
	 Valeur décimale multipliée par la valeur du canal de transparence alpha.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	import flash.geom.Transform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaMultiplier);		// 1
	
	colorTrans.alphaMultiplier = .5;	
	trace(colorTrans.alphaMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur décimale multipliée par la valeur du canal de transparence alpha.
	 
	 <p>Définir directement la valeur de transparence alpha d’un objet d’affichage à l’aide de la propriété <codeph>alpha</codeph> de l’occurrence de DisplayObject a une incidence sur la valeur de la propriété <codeph>alphaMultiplier</codeph> de la propriété <codeph>transform.colorTransform</codeph> de l’objet d’affichage.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/alpha"><linktext>flash.display.DisplayObject.alpha</linktext></link></related-links></apiValue><apiValue id="flash.geom:ColorTransform:alphaOffset"><apiName>alphaOffset</apiName><shortdesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de transparence alpha après sa multiplication par la valeur alphaMultiplier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaOffset</code> from 0 to -128.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaOffset);			// 0
	
	colorTrans.alphaOffset = -128;
	trace(colorTrans.alphaOffset);			// -128
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de transparence alpha après sa multiplication par la valeur alphaMultiplier.
   	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de transparence alpha après sa multiplication par la valeur <codeph>alphaMultiplier</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueMultiplier"><apiName>blueMultiplier</apiName><shortdesc>
	 Valeur décimale multipliée par la valeur du canal de bleu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueMultiplier);		// 1
	
	colorTrans.blueMultiplier = .5;
	trace(colorTrans.blueMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x0000FF);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur décimale multipliée par la valeur du canal de bleu.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueOffset"><apiName>blueOffset</apiName><shortdesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de bleu après sa multiplication par la valeur blueMultiplier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueOffset);			// 0
	
	colorTrans.blueOffset = 255;
	trace(colorTrans.blueOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de bleu après sa multiplication par la valeur blueMultiplier.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de bleu après sa multiplication par la valeur <codeph>blueMultiplier</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenMultiplier"><apiName>greenMultiplier</apiName><shortdesc>
	 Valeur décimale multipliée par la valeur du canal de vert.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenMultiplier);		// 1
	
	colorTrans.greenMultiplier = .5;
	trace(colorTrans.greenMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x00FF00);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur décimale multipliée par la valeur du canal de vert.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenOffset"><apiName>greenOffset</apiName><shortdesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de vert après sa multiplication par la valeur greenMultiplier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.greenOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de vert après sa multiplication par la valeur greenMultiplier.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de vert après sa multiplication par la valeur <codeph>greenMultiplier</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redMultiplier"><apiName>redMultiplier</apiName><shortdesc>
	 Valeur décimale multipliée par la valeur du canal de rouge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform();
 	trace(colorTrans.redMultiplier);		// 1
 	
 	colorTrans.redMultiplier = .5;
 	trace(colorTrans.redMultiplier);		// .5
 	
 	var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
 	var trans:Transform = new Transform(rect);
 	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur décimale multipliée par la valeur du canal de rouge. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redOffset"><apiName>redOffset</apiName><shortdesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de rouge après sa multiplication par la valeur redMultiplier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.redOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.redOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de rouge après sa multiplication par la valeur redMultiplier.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Nombre, compris entre -255 et 255, qui est ajouté à la valeur du canal de rouge après sa multiplication par la valeur <codeph>redMultiplier</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:color:get"><apiName>color</apiName><shortdesc>
	 Valeur de couleur RVB d’un objet ColorTransform.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>This example sets the RGB color value for the movie clip <code>my_mc</code>.<span class="flashonly"> To see this code work, place a movie clip on the Stage with the instance name <code>my_mc</code>. Then place the following code on Frame 1 in the main Timeline and select Control > Test Movie:</span>
	 <pre>
	 <code>var my_color:Color = new Color(my_mc);</code>
	 <code>my_color.setRGB(0xFF0000); // my_mc turns red</code>
	 </pre>
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur de couleur RVB d’un objet ColorTransform.
	 
	 <p>La définition de cette propriété entraîne la modification des trois valeurs de décalage de couleur (<codeph>redOffset</codeph>, <codeph>greenOffset</codeph> et <codeph>blueOffset</codeph>) et le réglage sur zéro des trois valeurs de multiplicateur de couleur (<codeph>redMultiplier</codeph>, <codeph>greenMultiplier</codeph> et <codeph>blueMultiplier</codeph>). Les valeurs de multiplicateur et de décalage de la transparence alpha ne changent pas.</p>
	 
	 <p>Lorsque vous définissez la valeur de cette propriété, utilisez le format 0x<i>RRGGBB</i>. Les valeurs <i>RR</i>, <i>GG</i> et <i>BB</i> se composent chacune de deux chiffres hexadécimaux qui spécifient le décalage de chaque composant de couleur. La valeur 0x indique au compilateur ActionScript que le nombre est une valeur hexadécimale.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Point"><apiName>Point</apiName><shortdesc>
 L’objet Point représente un emplacement dans un système de coordonnées à deux dimensions où x est l’axe horizontal et y l’axe vertical.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>La classe Point représente un emplacement dans un système de coordonnées à deux dimensions.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 L’objet Point représente un emplacement dans un système de coordonnées à deux dimensions où <i>x</i> est l’axe horizontal et <i>y</i> l’axe vertical. 
 
 <p>Le code suivant crée un point à (0,0) :</p>
 
 <codeblock platform="actionscript">var myPoint:Point = new Point();</codeblock>
 
 <codeblock platform="javascript">var myPoint = new Point();</codeblock>
 
 <p>Les méthodes et propriétés des classes suivantes utilisent des objets Point :</p>
 
 <ul>
 
 <li platform="actionscript">BitmapData</li>
 
 <li platform="actionscript">Classe DisplayObject</li>
 
 <li platform="actionscript">DisplayObjectContainer</li>
 
 <li platform="actionscript">DisplacementMapFilter</li>
 
 <li>NativeWindow</li>
 
 <li platform="actionscript">Matrix</li>
 
 <li>Rectangle</li>
 
 </ul>
 
 <p>Vous pouvez utiliser le constructeur <codeph>new Point()</codeph> pour créer un objet Point.</p>
 
 </apiDesc><example conref="examples\PointExample.as"> L’exemple suivant utilise la classe PointExample pour créer un nombre de nouveaux objets Point à différentes coordonnées <i>x,y</i>, puis il utilise la méthode <codeph>trace()</codeph> pour produire les résultats de diverses méthodes de classe.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Point;

    public class PointExample extends Sprite {

        public function PointExample() {
        var point1:Point = new Point();
        trace(point1);  // (x=0, y=0)
        
        var point2:Point = new Point(6, 8);
        trace(point2); // (x=6, y=8)
        
        trace(Point.interpolate(point1, point2, 0.5)); // (x=3, y=4)
        
        trace(Point.distance(point1, point2)); // 10
        
        trace(point1.add(point2)); // (x=6, y=8)
        
        var point3:Point = point2.clone();
        trace(point2.equals(point3)); // true
        
        point3.normalize(2.5);
        trace(point3); // (x=1.5, y=2)
        
        trace(point2.subtract(point3)); // (x=4.5, y=6)
        
        trace(point1.offset(2, 3)); // 
        
        var angle:Number = Math.PI * 2 * (30 / 360); // 30Â°
        trace(Point.polar(4, angle)) // (x=3.464101615137755, y=1.9999999999999998)   
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links><apiConstructor id="flash.geom:Point:Point"><apiName>Point</apiName><shortdesc>
	 Crée un nouveau point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The first example creates <code>point_1</code> with the default constructor.
	 <listing version="2.0">
	 import flash.geom.Point;
	 var point_1:Point = new Point();
	 trace(point_1.x); // 0
	 trace(point_1.y); // 0
	 </listing>
	 The second example creates <code>point_2</code> with the coordinates x = 1 and y = 2.
     <listing version="2.0">
	 import flash.geom.Point;
	 var point_2:Point = new Point(1, 2);
	 trace(point_2.x); // 1
	 trace(point_2.y); // 2
	 </listing>
	 
	  
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Coordonnée horizontale. 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Coordonnée verticale. 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un nouveau point. Si vous ne transmettez pas de paramètres à cette méthode, un point est créé aux coordonnées (0,0).
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Point:add"><apiName>add</apiName><shortdesc>
      	 Ajoute les coordonnées d’un autre point à celles de ce point pour créer un nouveau point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>resultPoint</code> by adding <code>point_2</code> to 
	 <code>point_1</code>.
   	 
   	 <listing version="2.0">
   	 import flash.geom.Point;
   	 var point_1:Point = new Point(4, 8);
   	 var point_2:Point = new Point(1, 2);
   	 var resultPoint:Point = point_1.add(point_2);
   	 trace(resultPoint.toString()); // (x=5, y=10)
   	 </listing>
	 
   	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Le nouveau point.
   	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le point à ajouter.
	 
      	 </apiDesc></apiParam></apiOperationDef><apiDesc>
      	 Ajoute les coordonnées d’un autre point à celles de ce point pour créer un nouveau point.
	 
      	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:clone"><apiName>clone</apiName><shortdesc>
	 Crée une copie de cet objet Point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a <code>clonedPoint</code> from the values found in 
 	 <code>myPoint</code>.  The <code>clonedPoint</code> contains all the
	 the values from <code>myPoint</code> but is not the same object.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(1, 2);
	 var clonedPoint:Point = myPoint.clone();
	 trace(clonedPoint.x); // 1
	 trace(clonedPoint.y); // 2
	 trace(myPoint.equals(clonedPoint)); // true
	 trace(myPoint === clonedPoint); // false
	 </listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nouvel objet Point.
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Crée une copie de l’objet Point.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Crée une copie de cet objet Point.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:distance"><apiName>distance</apiName><shortdesc>
	 Renvoie la distance entre pt1 et pt2.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Distance entre le premier et le second point.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le premier point.
	 </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le second point.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie la distance entre <codeph>pt1</codeph> et <codeph>pt2</codeph>.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:equals"><apiName>equals</apiName><shortdesc>
	 Détermine si deux points sont égaux.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Si l’objet est égal à cet objet Point, <codeph>true</codeph> est renvoyé ; <codeph>false</codeph> est renvoyé dans le cas contraire.
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point à comparer.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Détermine si deux points sont égaux. Deux points sont considérés comme égaux s’ils ont les mêmes valeurs <i>x</i> et <i>y</i>.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:interpolate"><apiName>interpolate</apiName><shortdesc>
    Détermine un point entre deux points spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example locates the interpolated point (<code>interpolatedPoint</code>) half way (50%) between <code>point_1</code> and <code>point_2</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(-100, -100);
   	var point_2:Point = new Point(50, 50);
   	var interpolatedPoint:Point = Point.interpolate(point_1, point_2, .5);
   	trace(interpolatedPoint.toString()); // (x=-25, y=-25)
   	</listing> 
	
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Nouveau point, interpolé. 
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le premier point.
	</apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Le second point.
	</apiDesc></apiParam><apiParam><apiItemName>f</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Niveau d’interpolation entre les deux points. Indique l’emplacement du nouveau point sur la ligne reliant <codeph>pt1</codeph> et <codeph>pt2</codeph>. Si <codeph>f</codeph>=1, <codeph>pt1</codeph> est renvoyé ; si <codeph>f</codeph>=0, <codeph>pt2</codeph> est renvoyé.
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    Détermine un point entre deux points spécifiés. Le paramètre <codeph>f</codeph> détermine l’emplacement du nouveau point interpolé par rapport aux deux points d’extrémité spécifiés par les paramètres <codeph>pt1</codeph> et <codeph>pt2</codeph>. Plus la valeur du paramètre <codeph>f</codeph> est proche de <codeph>1.0</codeph>, plus le point interpolé est proche du premier point (paramètre <codeph>pt1</codeph>). Plus la valeur du paramètre <codeph>f</codeph> est proche de 0, plus le point interpolé est proche du second point (paramètre <codeph>pt2</codeph>).
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:normalize"><apiName>normalize</apiName><shortdesc>
	Met à l’échelle le segment de ligne entre (0,0) et le point actuel en fonction d’une longueur définie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example extends the length of the <code>normalizedPoint</code> object from 5 to 10.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var normalizedPoint:Point = new Point(3, 4);
   	trace(normalizedPoint.length); // 5
   	trace(normalizedPoint.toString()); // (x=3, y=4)
   	normalizedPoint.normalize(10);
   	trace(normalizedPoint.length); // 10
   	trace(normalizedPoint.toString()); // (x=6, y=8)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Point normalisé.
	
   	</apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur de redimensionnement. Si, par exemple, le point actuel se trouve à (0,5) et que vous le normalisez à 1, les coordonnées du point renvoyé sont (0,1).
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Met à l’échelle le segment de ligne entre (0,0) et le point actuel en fonction d’une longueur définie. 
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:offset"><apiName>offset</apiName><shortdesc>
	 Décale l’objet Point de la quantité spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur de décalage pour la coordonnée horizontale, <i>x</i>.
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur de décalage pour la coordonnée verticale, <i>y</i>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Décale l’objet Point de la quantité spécifiée. La valeur de <codeph>dx</codeph> est ajoutée à la valeur d’origine de <i>x</i> pour créer la nouvelle valeur de <i>x</i>. La valeur de <codeph>dy</codeph> est ajoutée à la valeur d’origine de <i>y</i> pour créer la nouvelle valeur de <i>y</i>.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:polar"><apiName>polar</apiName><shortdesc>
	Convertit une paire de coordonnées polaires en coordonnées cartésiennes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>cartesianPoint</code> from the value of <code>angleInRadians</code>
	and a line length of 5.  The <code>angleInRadians</code> value equal to Math.atan(3/4)
   	is used because of the characteristics of right triangles with sides that 
   	have ratios of 3:4:5.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 5;
   	var angleInRadians:Number = Math.atan(3/4);
   	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // (x=4, y=3)
   	</listing>
	
	When computers work with transcendental numbers such as pi, some round-off
	error occurs because floating-point arithmetic has only finite precision.
	When you use <code>Math.PI</code>, consider using the <code>Math.round()</code> function, as shown 
	in the following example.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 10;
   	var angleInRadians:Number = Math.PI;
    	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // should be (x=-10, y=0), but is (x=-10, y=1.22460635382238e-15)
   	trace(Math.round(cartesianPoint.y)); // 0
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Point cartésien.
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée de longueur de la paire polaire.
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Angle, en radians, de la paire polaire.
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Convertit une paire de coordonnées polaires en coordonnées cartésiennes.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:subtract"><apiName>subtract</apiName><shortdesc>
	Soustrait les coordonnées d’un autre point à celles de ce point pour créer un nouveau point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>point_3</code> by subtracting <code>point_2</code> from <code>point_1</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(4, 8);
   	var point_2:Point = new Point(1, 2);
   	var resultPoint:Point = point_1.subtract(point_2);
   	trace(resultPoint.toString()); // (x=3, y=6)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Le nouveau point.
   	
     	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point à soustraire.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Soustrait les coordonnées d’un autre point à celles de ce point pour créer un nouveau point.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:toString"><apiName>toString</apiName><shortdesc>
	 Renvoie une chaîne qui contient les valeurs des coordonnées x et y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Représentation sous forme de chaîne des coordonnées.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie une chaîne qui contient les valeurs des coordonnées x et y. 

	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie une chaîne qui contient les valeurs des coordonnées <i>x</i> et <i>y</i>. La chaîne se présente au format <codeph>"(x=<i>x</i>, y=<i>y</i>)"</codeph> ; par conséquent, l’appel de la méthode <codeph>toString()</codeph> pour un point se trouvant à 23,17 renvoie <codeph>"(x=23, y=17)"</codeph>.
   	 
   	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Point:x"><apiName>x</apiName><shortdesc>
	 Les coordonnées horizontales du point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>x</i> (horizontal) coordinate of <code>myPoint</code> and gets <code>myX</code> from <code>myPoint.x</code>.
	 
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.x); // 0
	 myPoint.x = 5;
	 trace(myPoint.x); // 5
	 var myX:Number = myPoint.x;
	 trace(myX); // 5
     </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Les coordonnées horizontales du point. La valeur par défaut est 0.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:y"><apiName>y</apiName><shortdesc>
	 Les coordonnées verticales du point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>y</i> (vertical) coordinate of <code>myPoint</code> and gets <code>myY</code> from <code>myPoint.y</code>.
     
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.y); // 0
	 myPoint.y = 5;
	 trace(myPoint.y); // 5
	 var myY:Number = myPoint.y;
	 trace(myY); // 5
  	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Les coordonnées verticales du point. La valeur par défaut est 0.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:length:get"><apiName>length</apiName><shortdesc>
	 La longueur du segment de ligne de (0,0) à ce point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Point, <code>myPoint</code>, and determines the length of a line from (0, 0) to that Point.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(3,4);
	 trace(myPoint.length); // 5
	 </listing>
	 
   	  
   	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 La longueur du segment de ligne de (0,0) à ce point. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point/polar()"><linktext>Point.polar()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc> 
 La classe PerspectiveProjection permet d’affecter ou de modifier facilement les transformations de perspective d’un objet d’affichage et de tous ses enfants.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 La classe PerspectiveProjection permet d’affecter ou de modifier facilement les transformations de perspective d’un objet d’affichage et de tous ses enfants. Pour des transformations de perspective complexes ou personnalisées, utilisez la classe Matrix3D. Alors que la classe PerspectiveProjection fournit les propriétés de base de la présentation tridimensionnelle, la classe Matrix3D permet de mieux contrôler la présentation tridimensionnelle des objets d’affichage.
 
 <p>La projection est un moyen de représenter un objet tridimensionnel dans un espace à deux dimensions, par exemple un cube projeté sur l’écran d’un ordinateur. La projection de perspectives utilise un affichage frustum (pyramide rectangulaire) pour modeler et projeter un monde tridimensionnel et ses objets sur l’écran. L’affichage frustum devient de plus en plus large au fur et à mesure qu’il s’éloigne de l’origine du point de vue. L’origine du point de vue peut être un appareil photo ou les yeux d’un observateur faisant face à l’écran. La perspective projetée donne l’illusion d’un espace à trois dimensions, avec profondeur et distance, où les objets proches de l’écran semblent plus gros que les objets éloignés.</p>
 
 <p><adobeimage alt="Zone d’affichage frustum" href="../../images/frustum.jpg"/></p>
 
 <p>Tout objet PerspectiveProjection par défaut est une structure définie pour la transformation de perspective de l’objet racine, basée sur le champ de vision et les proportions (dimensions) de la scène. Le centre de la projection, ou point de fuite, est défini au centre de la scène, ce qui signifie que les objets d’affichage tridimensionnels disparaissent vers le centre de la scène lorsqu’ils reculent sur l’axe z. Le point de vue par défaut est au point (0,0), regardant vers l’axe z positif. L’axe y pointe vers le bas de l’écran. Vous pouvez accéder aux paramètres de projection de perspective de l’objet d’affichage <codeph>root</codeph> et modifier les propriétés de champ de vision et de centre de projection de la propriété <codeph>perspectiveProjection</codeph> par l’intermédiaire de la propriété <codeph>DisplayObject.transform</codeph> de l’objet <codeph>root</codeph>.</p> 
 
 <p>Vous pouvez également définir un paramètre de projection de perspective différent pour un objet d’affichage via la projection de perspective du parent. Commencez par créer un objet PerspectiveProjection et définissez ses propriétés <codeph>fieldOfView</codeph> et <codeph>projectionCenter</codeph>. Ensuite, affectez l’objet PerspectiveProjection à l’objet d’affichage parent à l’aide de la propriété <codeph>DisplayObject.transform</codeph>. La transformation et la matrice de projection spécifiée s’appliqueront alors à tous les enfants tridimensionnels de l’objet d’affichage.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link></related-links><apiConstructor id="flash.geom:PerspectiveProjection:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc>
     Crée une occurrence d’objet PerspectiveProjection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
     </helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Crée une occurrence d’objet PerspectiveProjection. 
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:PerspectiveProjection:toMatrix3D"><apiName>toMatrix3D</apiName><shortdesc>
     Renvoie l’objet Matrix3D sous-jacent de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet Matrix3D sous-jacent. 
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Renvoie l’objet Matrix3D sous-jacent de l’objet d’affichage.  
     
     <p>Un objet d’affichage, tel que l’objet racine, peut avoir un objet PerspectiveProjection sans que la propriété Matrix3D ne soit définie pour ses transformations. En fait, pour spécifier la transformation de la perspective, servez-vous d’un objet PerspectiveProjection ou Matrix3D. Si, lorsque vous utilisez l’objet PerspectiveProjection, un objet Matrix3D est nécessaire, la méthode <codeph>toMatrix3D()</codeph> peut récupérer l’objet Matrix3D sous-jacent de l’objet d’affichage. Par exemple, la méthode <codeph>toMatrix3D()</codeph> peut être utilisée avec la méthode <codeph>Utils3D.projectVectors()</codeph>.</p> 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:PerspectiveProjection:fieldOfView:set"><apiName>fieldOfView</apiName><shortdesc>
     Spécifie l’angle, en degrés compris entre 0 et 180, du champ de vision en trois dimensions.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Spécifie l’angle, en degrés compris entre 0 et 180, du champ de vision en trois dimensions.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Spécifie l’angle, en degrés compris entre <codeph>0</codeph> et <codeph>180</codeph>, du champ de vision en trois dimensions. Cette valeur détermine la puissance de la transformation de perspective, et la distorsion s’applique à un objet d’affichage tridimensionnel avec coordonnée z non nulle.
     
     <p>Une valeur proche de <codeph>0</codeph> signifie que les coordonnées bidimensionnelles x et y de l’écran sont quasiment les mêmes que les coordonnées tridimensionnelles x, y et z, avec très peu ou aucune distorsion. En d’autres termes, dans le cas d’un angle faible, un objet d’affichage se déplaçant vers le bas de l’axe z semble conserver à peu près la même taille et ne se déplacer que très peu. </p>
     
     <p>Une valeur proche de <codeph>180</codeph> degrés entraînent un effet de déformation : les positions dont la valeur <codeph>z</codeph> est inférieure à <codeph>0</codeph> sont exagérées, tandis que les positions dont la valeur <codeph>z</codeph> est supérieure à <codeph>0</codeph> sont réduites. Avec un très grand angle, un objet d’affichage se déplaçant le long de l’axe z semble changer de taille rapidement et se déplacer sur de grandes distances. Si le champ de vision est défini sur <codeph>0</codeph> ou <codeph>180</codeph>, rien n’est visible à l’écran.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:PerspectiveProjection:focalLength:get"><apiName>focalLength</apiName><shortdesc>
     Distance entre l’oeil ou l’origine du point de vue (0,0,0) et l’objet d’affichage placé sur l’axe z.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Distance entre l’oeil ou l’origine du point de vue (0,0,0) et l’objet d’affichage placé sur l’axe z. Pendant la transformation de la perspective, la propriété <codeph>focalLength</codeph> est calculée dynamiquement à l’aide de l’angle du champ de vision et des proportions de la scène (largeur de la scène divisée par sa hauteur).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection/fieldOfView"><linktext>fieldOfView</linktext></link></related-links></apiValue><apiValue id="flash.geom:PerspectiveProjection:projectionCenter:set"><apiName>projectionCenter</apiName><shortdesc>
     Point bidimensionnel représentant le centre de la projection, le point de fuite de l’objet d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
     Point bidimensionnel représentant le centre de la projection, le point de fuite de l’objet d’affichage. 
     
     <p>La propriété <codeph>projectionCenter</codeph> est un décalage du point d’alignement par défaut, correspondant au point supérieur gauche de la scène, point (0,0). Le centre de la transformation de projection par défaut est placé au milieu de la scène, ce qui signifie que les objets d’affichage tridimensionnels disparaissent vers le centre de la scène au fur et à mesure qu’ils reculent sur l’axe z.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Orientation3D"><apiName>Orientation3D</apiName><shortdesc>
La classe Orientation3D énumère les valeurs constantes représentant le style d’orientation d’un objet Matrix3D.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe Orientation3D énumère les valeurs constantes représentant le style d’orientation d’un objet Matrix3D. Les trois types d’orientation sont les angles d’Euler, l’angle des axes et le quaternion. Les méthodes <codeph>decompose</codeph> et <codeph>recompose</codeph> de l’objet Matrix3D prennent l’un de ces types énumérés pour identifier les composants de rotation de la matrice.

</apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiValue id="flash.geom:Orientation3D:AXIS_ANGLE"><apiName>AXIS_ANGLE</apiName><shortdesc>
    L’orientation de l’angle des axes utilise une combinaison d’un axe et d’un angle pour déterminer l’orientation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>axisAngle</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    L’orientation de l’angle des axes utilise une combinaison d’un axe et d’un angle pour déterminer l’orientation. Une ligne ou un vecteur partant du centre d’un globe tridimensionnel et allant vers la surface est un exemple d’axe. L’axe autour duquel l’objet pivote est un vecteur unitaire qui représente toutes les directions possibles dans l’espace à trois dimensions. L’angle représente l’amplitude de la rotation autour du vecteur. La direction détermine le point auquel fait face un objet d’affichage et l’angle de roulement détermine le haut. Vous pouvez utiliser les objets Vector3D et Matrix3D pour déterminer les diverses transformations matricielles, de même que les valeurs de programmation tridimensionnelles importantes, telles que la distance par rapport à l’intersection de deux objets pouvant permettre de détecter une simple collision entre des objets tridimensionnels.
    
    <p>Les méthodes <codeph>Matrix3D.appendRotation()</codeph> et <codeph>Matrix3D.prependRotation()</codeph> utilisent l’orientation de l’angle des axes.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:EULER_ANGLES"><apiName>EULER_ANGLES</apiName><shortdesc> 
    Les angles d’Euler, orientation par défaut des méthodes decompose() et recompose(), définissent l’orientation avec trois angles de rotation distincts pour chaque axe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>eulerAngles</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Définit l’orientation avec trois angles de rotation distincts pour chaque axe.
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
    Les angles d’Euler, orientation par défaut des méthodes <codeph>decompose()</codeph> et <codeph>recompose()</codeph>, définissent l’orientation avec trois angles de rotation distincts pour chaque axe. En général, une rotation autour de l’axe x est suivie d’une rotation autour de l’axe y, suivie d’une rotation autour de l’axe z. 
    
    <p>Les angles d’Euler entraînent parfois des erreurs d’animation à cause de problèmes tels que des singularités lors de la rotation autour de l’axe x ou gimbal lock (perte d’un degré de liberté). Par exemple, comme avec les angles d’Euler chaque axe est géré indépendamment, la singularité gimbal lock peut survenir en cas de rotation autour de plusieurs axes. Les axes peuvent alors s’aligner, ce qui entraîne des résultats inattendus.</p>
    
    <p>Les propriétés de rotation des axes de l’objet d’affichage effectuent la rotation des angles d’Euler.</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:QUATERNION"><apiName>QUATERNION</apiName><shortdesc>
    L’orientation quaternion utilise des nombres complexes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>quaternion</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Une orientation en quaternion utilise les trois axes (x,y,z) et un angle de rotation (w).
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    L’orientation quaternion utilise des nombres complexes. Une orientation en quaternion utilise les trois axes (x,y,z) et un angle de rotation (w). Un quaternion garantit le chemin le plus efficace et le plus court pour la rotation. Il permet également d’obtenir une rotation sans gimbal lock. Un gimbal lock peut survenir lorsque les axes s’alignent lors d’une rotation autours de plusieurs axes, entraînant ainsi des résultats inattendus. 
    
    <p>La méthode <codeph>Matrix3D.interpolate()</codeph> utilise le quaternion.</p> 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>